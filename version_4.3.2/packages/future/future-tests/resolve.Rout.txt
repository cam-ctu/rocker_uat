
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[10:26:59.120] plan(): Setting new future strategy stack:
[10:26:59.121] List of future strategies:
[10:26:59.121] 1. sequential:
[10:26:59.121]    - args: function (..., envir = parent.frame())
[10:26:59.121]    - tweaked: FALSE
[10:26:59.121]    - call: future::plan("sequential")
[10:26:59.147] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> strategies <- supportedStrategies()
> 
> message("*** resolve() ...")
*** resolve() ...
> 
> message("*** resolve() for default ...")
*** resolve() for default ...
> 
> x <- 1
> y <- resolve(x)
> stopifnot(identical(y, x))
> 
> message("*** resolve() for default ... DONE")
*** resolve() for default ... DONE
> 
> 
> for (strategy in strategies) {
+   message(sprintf("- plan('%s') ...", strategy))
+   plan(strategy)
+ 
+   if (strategy == "multisession" && availableCores() >= 2) {
+     message("*** resolve() for Future objects ...")
+     
+     for (result in c(FALSE, TRUE)) {
+       for (recursive in list(FALSE, TRUE, -1, 0, 1, 2, Inf)) {
+         message(sprintf("- result = %s, recursive = %s ...", result, recursive))
+       
+         f <- future({
+           Sys.sleep(0.5)
+           list(a = 1, b = 42L)
+         })
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         f <- future({
+           Sys.sleep(0.5)
+           list(a = 1, b = 42L)
+         }, lazy = TRUE)
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         message("- w/ exception ...")
+         f <- future(list(a = 1, b = 42L, c = stop("Nah!")))
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         f <- future(list(a = 1, b = 42L, c = stop("Nah!")), lazy = TRUE)
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         message(sprintf("- result = %s, recursive = %s ... DONE", result, recursive))
+       } ## for (resolve ...)
+     } ## for (result ...)
+     
+     message("*** resolve() for Future objects ... DONE")
+   } ## if (strategy == "multisession" && availableCores() >= 2)
+   
+   message("*** resolve() for lists ...")
+ 
+   x <- list()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   x$a <- 1
+   x$b <- 2
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   x$a <- future(1)
+   x$b <- future(2)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1, lazy = TRUE)
+   x$b <- future(2)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1, lazy = TRUE)
+   x$b <- future(2, lazy = TRUE)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1)
+   x$b <- future({Sys.sleep(0.5); 2})
+   x[[4]] <- 4
+   dim(x) <- c(2, 2)
+   y <- resolve(x, idxs = 1)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x[[1]]))
+   y <- resolve(x, idxs = 2)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x[[2]]))
+   y <- resolve(x, idxs = 3)
+   stopifnot(identical(y, x))
+   y <- resolve(x, idxs = seq_along(x))
+   stopifnot(identical(y, x))
+   y <- resolve(x, idxs = names(x))
+   stopifnot(identical(y, x))
+ 
+   y <- resolve(x, idxs = matrix(c(1, 2), ncol = 2L), result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   for (kk in 1:3) x[[kk]] <- future({ Sys.sleep(0.1); kk })
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   for (kk in 1:3) x[[kk]] <- future({ Sys.sleep(0.1); kk }, lazy = TRUE)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   x <- list()
+   x$a <- 1
+   x$b <- 2
+ 
+   res <- tryCatch(y <- resolve(x, idxs = 0L), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   x <- list(1, 2)
+   res <- tryCatch(x <- resolve(x, idxs = "a"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for lists ... DONE")
+ 
+ 
+   message("*** resolve() for environments ...")
+ 
+   x <- new.env()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- new.env()
+   x$a <- 1
+   x$b <- 2
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 0L)
+ 
+   x <- new.env()
+   x$a <- future(1)
+   x$b <- future(2)
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x$b))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- new.env()
+   x$a %<-% { 1 }
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)  ## FIXME: Should not do value()!
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- new.env()
+   x$a <- future({ 1 })
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "a")
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "b")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "c")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = names(x), result = TRUE)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, recursive = TRUE, result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for environments ... DONE")
+ 
+ 
+   message("*** resolve() for list environments ...")
+ 
+   x <- listenv()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- listenv()
+   x$a <- 1
+   x$b <- 2
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 0L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- listenv()
+   x$a <- future(1)
+   x$b <- future(2)
+   x$c <- 3
+   names <- names(x)
+   dim(x) <- c(1, 3)
+   names(x) <- names
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- listenv()
+   x$a %<-% { 1 }
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)  ## FIXME: Should not do value()!
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x$a, mustExist = FALSE)))
+   #stopifnot(is.na(futureOf(x$b, mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- listenv()
+   x$a <- future({ 1 })
+   x$b %<-% { Sys.sleep(0.5); 2 }
+   x$c %<-% { 3 }
+   x$d <- 4
+   names <- names(x)
+   dim(x) <- c(2, 2)
+   names(x) <- names
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+   y <- resolve(x, idxs = "a")
+   stopifnot(identical(y, x))
+   stopifnot(identical(futureOf(x$a, mustExist = FALSE), x$a))
+   stopifnot(resolved(x$a))
+   y <- resolve(x, idxs = "b")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   idxs <- matrix(c(1, 2), ncol = 2L)
+   y <- resolve(x, idxs = idxs)
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x$c, mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, idxs = 4L)
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x[[4L]], mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, idxs = names(x), result = TRUE)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, recursive = TRUE, result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   res <- tryCatch(y <- resolve(x, idxs = 0L), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for list environments ... DONE")
+ 
+   message(sprintf("- plan('%s') ...", strategy))
+ } ## for (strategy ...)
- plan('sequential') ...
[10:26:59.363] plan(): Setting new future strategy stack:
[10:26:59.363] List of future strategies:
[10:26:59.363] 1. sequential:
[10:26:59.363]    - args: function (..., envir = parent.frame())
[10:26:59.363]    - tweaked: FALSE
[10:26:59.363]    - call: plan(strategy)
[10:26:59.376] plan(): nbrOfWorkers() = 1
*** resolve() for lists ...
[10:26:59.377] resolve() on list ...
[10:26:59.377]  recursive: 0
[10:26:59.377]  length: 2
[10:26:59.377]  elements: ‘a’, ‘b’
[10:26:59.378]  length: 1 (resolved future 1)
[10:26:59.378]  length: 0 (resolved future 2)
[10:26:59.378] resolve() on list ... DONE
[10:26:59.379] getGlobalsAndPackages() ...
[10:26:59.379] Searching for globals...
[10:26:59.381] 
[10:26:59.381] Searching for globals ... DONE
[10:26:59.381] - globals: [0] <none>
[10:26:59.381] getGlobalsAndPackages() ... DONE
[10:26:59.382] run() for ‘Future’ ...
[10:26:59.382] - state: ‘created’
[10:26:59.383] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:59.383] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:59.383] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:59.383]   - Field: ‘label’
[10:26:59.383]   - Field: ‘local’
[10:26:59.383]   - Field: ‘owner’
[10:26:59.383]   - Field: ‘envir’
[10:26:59.384]   - Field: ‘packages’
[10:26:59.384]   - Field: ‘gc’
[10:26:59.384]   - Field: ‘conditions’
[10:26:59.384]   - Field: ‘expr’
[10:26:59.384]   - Field: ‘uuid’
[10:26:59.384]   - Field: ‘seed’
[10:26:59.384]   - Field: ‘version’
[10:26:59.384]   - Field: ‘result’
[10:26:59.384]   - Field: ‘asynchronous’
[10:26:59.384]   - Field: ‘calls’
[10:26:59.384]   - Field: ‘globals’
[10:26:59.385]   - Field: ‘stdout’
[10:26:59.385]   - Field: ‘earlySignal’
[10:26:59.385]   - Field: ‘lazy’
[10:26:59.385]   - Field: ‘state’
[10:26:59.385] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:59.385] - Launch lazy future ...
[10:26:59.386] Packages needed by the future expression (n = 0): <none>
[10:26:59.386] Packages needed by future strategies (n = 0): <none>
[10:26:59.387] {
[10:26:59.387]     {
[10:26:59.387]         {
[10:26:59.387]             ...future.startTime <- base::Sys.time()
[10:26:59.387]             {
[10:26:59.387]                 {
[10:26:59.387]                   {
[10:26:59.387]                     base::local({
[10:26:59.387]                       has_future <- base::requireNamespace("future", 
[10:26:59.387]                         quietly = TRUE)
[10:26:59.387]                       if (has_future) {
[10:26:59.387]                         ns <- base::getNamespace("future")
[10:26:59.387]                         version <- ns[[".package"]][["version"]]
[10:26:59.387]                         if (is.null(version)) 
[10:26:59.387]                           version <- utils::packageVersion("future")
[10:26:59.387]                       }
[10:26:59.387]                       else {
[10:26:59.387]                         version <- NULL
[10:26:59.387]                       }
[10:26:59.387]                       if (!has_future || version < "1.8.0") {
[10:26:59.387]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:59.387]                           "", base::R.version$version.string), 
[10:26:59.387]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:59.387]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:59.387]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:59.387]                             "release", "version")], collapse = " "), 
[10:26:59.387]                           hostname = base::Sys.info()[["nodename"]])
[10:26:59.387]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:59.387]                           info)
[10:26:59.387]                         info <- base::paste(info, collapse = "; ")
[10:26:59.387]                         if (!has_future) {
[10:26:59.387]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:59.387]                             info)
[10:26:59.387]                         }
[10:26:59.387]                         else {
[10:26:59.387]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:59.387]                             info, version)
[10:26:59.387]                         }
[10:26:59.387]                         base::stop(msg)
[10:26:59.387]                       }
[10:26:59.387]                     })
[10:26:59.387]                   }
[10:26:59.387]                   options(future.plan = NULL)
[10:26:59.387]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:59.387]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:59.387]                 }
[10:26:59.387]                 ...future.workdir <- getwd()
[10:26:59.387]             }
[10:26:59.387]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:59.387]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:59.387]         }
[10:26:59.387]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:59.387]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:59.387]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:59.387]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:59.387]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:59.387]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:59.387]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:59.387]             base::names(...future.oldOptions))
[10:26:59.387]     }
[10:26:59.387]     if (FALSE) {
[10:26:59.387]     }
[10:26:59.387]     else {
[10:26:59.387]         if (TRUE) {
[10:26:59.387]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:59.387]                 open = "w")
[10:26:59.387]         }
[10:26:59.387]         else {
[10:26:59.387]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:59.387]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:59.387]         }
[10:26:59.387]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:59.387]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:59.387]             base::sink(type = "output", split = FALSE)
[10:26:59.387]             base::close(...future.stdout)
[10:26:59.387]         }, add = TRUE)
[10:26:59.387]     }
[10:26:59.387]     ...future.frame <- base::sys.nframe()
[10:26:59.387]     ...future.conditions <- base::list()
[10:26:59.387]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:59.387]     if (FALSE) {
[10:26:59.387]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:59.387]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:59.387]     }
[10:26:59.387]     ...future.result <- base::tryCatch({
[10:26:59.387]         base::withCallingHandlers({
[10:26:59.387]             ...future.value <- base::withVisible(base::local(1))
[10:26:59.387]             future::FutureResult(value = ...future.value$value, 
[10:26:59.387]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:59.387]                   ...future.rng), globalenv = if (FALSE) 
[10:26:59.387]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:59.387]                     ...future.globalenv.names))
[10:26:59.387]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:59.387]         }, condition = base::local({
[10:26:59.387]             c <- base::c
[10:26:59.387]             inherits <- base::inherits
[10:26:59.387]             invokeRestart <- base::invokeRestart
[10:26:59.387]             length <- base::length
[10:26:59.387]             list <- base::list
[10:26:59.387]             seq.int <- base::seq.int
[10:26:59.387]             signalCondition <- base::signalCondition
[10:26:59.387]             sys.calls <- base::sys.calls
[10:26:59.387]             `[[` <- base::`[[`
[10:26:59.387]             `+` <- base::`+`
[10:26:59.387]             `<<-` <- base::`<<-`
[10:26:59.387]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:59.387]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:59.387]                   3L)]
[10:26:59.387]             }
[10:26:59.387]             function(cond) {
[10:26:59.387]                 is_error <- inherits(cond, "error")
[10:26:59.387]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:59.387]                   NULL)
[10:26:59.387]                 if (is_error) {
[10:26:59.387]                   sessionInformation <- function() {
[10:26:59.387]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:59.387]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:59.387]                       search = base::search(), system = base::Sys.info())
[10:26:59.387]                   }
[10:26:59.387]                   ...future.conditions[[length(...future.conditions) + 
[10:26:59.387]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:59.387]                     cond$call), session = sessionInformation(), 
[10:26:59.387]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:59.387]                   signalCondition(cond)
[10:26:59.387]                 }
[10:26:59.387]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:59.387]                 "immediateCondition"))) {
[10:26:59.387]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:59.387]                   ...future.conditions[[length(...future.conditions) + 
[10:26:59.387]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:59.387]                   if (TRUE && !signal) {
[10:26:59.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:59.387]                     {
[10:26:59.387]                       inherits <- base::inherits
[10:26:59.387]                       invokeRestart <- base::invokeRestart
[10:26:59.387]                       is.null <- base::is.null
[10:26:59.387]                       muffled <- FALSE
[10:26:59.387]                       if (inherits(cond, "message")) {
[10:26:59.387]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:59.387]                         if (muffled) 
[10:26:59.387]                           invokeRestart("muffleMessage")
[10:26:59.387]                       }
[10:26:59.387]                       else if (inherits(cond, "warning")) {
[10:26:59.387]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:59.387]                         if (muffled) 
[10:26:59.387]                           invokeRestart("muffleWarning")
[10:26:59.387]                       }
[10:26:59.387]                       else if (inherits(cond, "condition")) {
[10:26:59.387]                         if (!is.null(pattern)) {
[10:26:59.387]                           computeRestarts <- base::computeRestarts
[10:26:59.387]                           grepl <- base::grepl
[10:26:59.387]                           restarts <- computeRestarts(cond)
[10:26:59.387]                           for (restart in restarts) {
[10:26:59.387]                             name <- restart$name
[10:26:59.387]                             if (is.null(name)) 
[10:26:59.387]                               next
[10:26:59.387]                             if (!grepl(pattern, name)) 
[10:26:59.387]                               next
[10:26:59.387]                             invokeRestart(restart)
[10:26:59.387]                             muffled <- TRUE
[10:26:59.387]                             break
[10:26:59.387]                           }
[10:26:59.387]                         }
[10:26:59.387]                       }
[10:26:59.387]                       invisible(muffled)
[10:26:59.387]                     }
[10:26:59.387]                     muffleCondition(cond, pattern = "^muffle")
[10:26:59.387]                   }
[10:26:59.387]                 }
[10:26:59.387]                 else {
[10:26:59.387]                   if (TRUE) {
[10:26:59.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:59.387]                     {
[10:26:59.387]                       inherits <- base::inherits
[10:26:59.387]                       invokeRestart <- base::invokeRestart
[10:26:59.387]                       is.null <- base::is.null
[10:26:59.387]                       muffled <- FALSE
[10:26:59.387]                       if (inherits(cond, "message")) {
[10:26:59.387]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:59.387]                         if (muffled) 
[10:26:59.387]                           invokeRestart("muffleMessage")
[10:26:59.387]                       }
[10:26:59.387]                       else if (inherits(cond, "warning")) {
[10:26:59.387]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:59.387]                         if (muffled) 
[10:26:59.387]                           invokeRestart("muffleWarning")
[10:26:59.387]                       }
[10:26:59.387]                       else if (inherits(cond, "condition")) {
[10:26:59.387]                         if (!is.null(pattern)) {
[10:26:59.387]                           computeRestarts <- base::computeRestarts
[10:26:59.387]                           grepl <- base::grepl
[10:26:59.387]                           restarts <- computeRestarts(cond)
[10:26:59.387]                           for (restart in restarts) {
[10:26:59.387]                             name <- restart$name
[10:26:59.387]                             if (is.null(name)) 
[10:26:59.387]                               next
[10:26:59.387]                             if (!grepl(pattern, name)) 
[10:26:59.387]                               next
[10:26:59.387]                             invokeRestart(restart)
[10:26:59.387]                             muffled <- TRUE
[10:26:59.387]                             break
[10:26:59.387]                           }
[10:26:59.387]                         }
[10:26:59.387]                       }
[10:26:59.387]                       invisible(muffled)
[10:26:59.387]                     }
[10:26:59.387]                     muffleCondition(cond, pattern = "^muffle")
[10:26:59.387]                   }
[10:26:59.387]                 }
[10:26:59.387]             }
[10:26:59.387]         }))
[10:26:59.387]     }, error = function(ex) {
[10:26:59.387]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:59.387]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:59.387]                 ...future.rng), started = ...future.startTime, 
[10:26:59.387]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:59.387]             version = "1.8"), class = "FutureResult")
[10:26:59.387]     }, finally = {
[10:26:59.387]         if (!identical(...future.workdir, getwd())) 
[10:26:59.387]             setwd(...future.workdir)
[10:26:59.387]         {
[10:26:59.387]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:59.387]                 ...future.oldOptions$nwarnings <- NULL
[10:26:59.387]             }
[10:26:59.387]             base::options(...future.oldOptions)
[10:26:59.387]             if (.Platform$OS.type == "windows") {
[10:26:59.387]                 old_names <- names(...future.oldEnvVars)
[10:26:59.387]                 envs <- base::Sys.getenv()
[10:26:59.387]                 names <- names(envs)
[10:26:59.387]                 common <- intersect(names, old_names)
[10:26:59.387]                 added <- setdiff(names, old_names)
[10:26:59.387]                 removed <- setdiff(old_names, names)
[10:26:59.387]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:59.387]                   envs[common]]
[10:26:59.387]                 NAMES <- toupper(changed)
[10:26:59.387]                 args <- list()
[10:26:59.387]                 for (kk in seq_along(NAMES)) {
[10:26:59.387]                   name <- changed[[kk]]
[10:26:59.387]                   NAME <- NAMES[[kk]]
[10:26:59.387]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:59.387]                     next
[10:26:59.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:59.387]                 }
[10:26:59.387]                 NAMES <- toupper(added)
[10:26:59.387]                 for (kk in seq_along(NAMES)) {
[10:26:59.387]                   name <- added[[kk]]
[10:26:59.387]                   NAME <- NAMES[[kk]]
[10:26:59.387]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:59.387]                     next
[10:26:59.387]                   args[[name]] <- ""
[10:26:59.387]                 }
[10:26:59.387]                 NAMES <- toupper(removed)
[10:26:59.387]                 for (kk in seq_along(NAMES)) {
[10:26:59.387]                   name <- removed[[kk]]
[10:26:59.387]                   NAME <- NAMES[[kk]]
[10:26:59.387]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:59.387]                     next
[10:26:59.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:59.387]                 }
[10:26:59.387]                 if (length(args) > 0) 
[10:26:59.387]                   base::do.call(base::Sys.setenv, args = args)
[10:26:59.387]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:59.387]             }
[10:26:59.387]             else {
[10:26:59.387]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:59.387]             }
[10:26:59.387]             {
[10:26:59.387]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:59.387]                   0L) {
[10:26:59.387]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:59.387]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:59.387]                   base::options(opts)
[10:26:59.387]                 }
[10:26:59.387]                 {
[10:26:59.387]                   {
[10:26:59.387]                     NULL
[10:26:59.387]                     RNGkind("Mersenne-Twister")
[10:26:59.387]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:59.387]                       inherits = FALSE)
[10:26:59.387]                   }
[10:26:59.387]                   options(future.plan = NULL)
[10:26:59.387]                   if (is.na(NA_character_)) 
[10:26:59.387]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:59.387]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:59.387]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:59.387]                   {
[10:26:59.387]                     future <- SequentialFuture(..., envir = envir)
[10:26:59.387]                     if (!future$lazy) 
[10:26:59.387]                       future <- run(future)
[10:26:59.387]                     invisible(future)
[10:26:59.387]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:59.387]                 }
[10:26:59.387]             }
[10:26:59.387]         }
[10:26:59.387]     })
[10:26:59.387]     if (TRUE) {
[10:26:59.387]         base::sink(type = "output", split = FALSE)
[10:26:59.387]         if (TRUE) {
[10:26:59.387]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:59.387]         }
[10:26:59.387]         else {
[10:26:59.387]             ...future.result["stdout"] <- base::list(NULL)
[10:26:59.387]         }
[10:26:59.387]         base::close(...future.stdout)
[10:26:59.387]         ...future.stdout <- NULL
[10:26:59.387]     }
[10:26:59.387]     ...future.result$conditions <- ...future.conditions
[10:26:59.387]     ...future.result$finished <- base::Sys.time()
[10:26:59.387]     ...future.result
[10:26:59.387] }
[10:26:59.389] plan(): Setting new future strategy stack:
[10:26:59.389] List of future strategies:
[10:26:59.389] 1. sequential:
[10:26:59.389]    - args: function (..., envir = parent.frame())
[10:26:59.389]    - tweaked: FALSE
[10:26:59.389]    - call: NULL
[10:26:59.390] plan(): nbrOfWorkers() = 1
[10:26:59.391] plan(): Setting new future strategy stack:
[10:26:59.391] List of future strategies:
[10:26:59.391] 1. sequential:
[10:26:59.391]    - args: function (..., envir = parent.frame())
[10:26:59.391]    - tweaked: FALSE
[10:26:59.391]    - call: plan(strategy)
[10:26:59.391] plan(): nbrOfWorkers() = 1
[10:26:59.392] SequentialFuture started (and completed)
[10:26:59.392] - Launch lazy future ... done
[10:26:59.392] run() for ‘SequentialFuture’ ... done
[10:26:59.392] getGlobalsAndPackages() ...
[10:26:59.393] Searching for globals...
[10:26:59.393] 
[10:26:59.393] Searching for globals ... DONE
[10:26:59.393] - globals: [0] <none>
[10:26:59.393] getGlobalsAndPackages() ... DONE
[10:26:59.393] run() for ‘Future’ ...
[10:26:59.394] - state: ‘created’
[10:26:59.394] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:59.394] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:59.394] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:59.394]   - Field: ‘label’
[10:26:59.394]   - Field: ‘local’
[10:26:59.394]   - Field: ‘owner’
[10:26:59.394]   - Field: ‘envir’
[10:26:59.395]   - Field: ‘packages’
[10:26:59.395]   - Field: ‘gc’
[10:26:59.395]   - Field: ‘conditions’
[10:26:59.395]   - Field: ‘expr’
[10:26:59.395]   - Field: ‘uuid’
[10:26:59.395]   - Field: ‘seed’
[10:26:59.395]   - Field: ‘version’
[10:26:59.395]   - Field: ‘result’
[10:26:59.395]   - Field: ‘asynchronous’
[10:26:59.395]   - Field: ‘calls’
[10:26:59.396]   - Field: ‘globals’
[10:26:59.396]   - Field: ‘stdout’
[10:26:59.396]   - Field: ‘earlySignal’
[10:26:59.396]   - Field: ‘lazy’
[10:26:59.396]   - Field: ‘state’
[10:26:59.396] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:59.396] - Launch lazy future ...
[10:26:59.396] Packages needed by the future expression (n = 0): <none>
[10:26:59.396] Packages needed by future strategies (n = 0): <none>
[10:26:59.397] {
[10:26:59.397]     {
[10:26:59.397]         {
[10:26:59.397]             ...future.startTime <- base::Sys.time()
[10:26:59.397]             {
[10:26:59.397]                 {
[10:26:59.397]                   {
[10:26:59.397]                     base::local({
[10:26:59.397]                       has_future <- base::requireNamespace("future", 
[10:26:59.397]                         quietly = TRUE)
[10:26:59.397]                       if (has_future) {
[10:26:59.397]                         ns <- base::getNamespace("future")
[10:26:59.397]                         version <- ns[[".package"]][["version"]]
[10:26:59.397]                         if (is.null(version)) 
[10:26:59.397]                           version <- utils::packageVersion("future")
[10:26:59.397]                       }
[10:26:59.397]                       else {
[10:26:59.397]                         version <- NULL
[10:26:59.397]                       }
[10:26:59.397]                       if (!has_future || version < "1.8.0") {
[10:26:59.397]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:59.397]                           "", base::R.version$version.string), 
[10:26:59.397]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:59.397]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:59.397]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:59.397]                             "release", "version")], collapse = " "), 
[10:26:59.397]                           hostname = base::Sys.info()[["nodename"]])
[10:26:59.397]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:59.397]                           info)
[10:26:59.397]                         info <- base::paste(info, collapse = "; ")
[10:26:59.397]                         if (!has_future) {
[10:26:59.397]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:59.397]                             info)
[10:26:59.397]                         }
[10:26:59.397]                         else {
[10:26:59.397]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:59.397]                             info, version)
[10:26:59.397]                         }
[10:26:59.397]                         base::stop(msg)
[10:26:59.397]                       }
[10:26:59.397]                     })
[10:26:59.397]                   }
[10:26:59.397]                   options(future.plan = NULL)
[10:26:59.397]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:59.397]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:59.397]                 }
[10:26:59.397]                 ...future.workdir <- getwd()
[10:26:59.397]             }
[10:26:59.397]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:59.397]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:59.397]         }
[10:26:59.397]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:59.397]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:59.397]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:59.397]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:59.397]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:59.397]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:59.397]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:59.397]             base::names(...future.oldOptions))
[10:26:59.397]     }
[10:26:59.397]     if (FALSE) {
[10:26:59.397]     }
[10:26:59.397]     else {
[10:26:59.397]         if (TRUE) {
[10:26:59.397]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:59.397]                 open = "w")
[10:26:59.397]         }
[10:26:59.397]         else {
[10:26:59.397]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:59.397]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:59.397]         }
[10:26:59.397]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:59.397]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:59.397]             base::sink(type = "output", split = FALSE)
[10:26:59.397]             base::close(...future.stdout)
[10:26:59.397]         }, add = TRUE)
[10:26:59.397]     }
[10:26:59.397]     ...future.frame <- base::sys.nframe()
[10:26:59.397]     ...future.conditions <- base::list()
[10:26:59.397]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:59.397]     if (FALSE) {
[10:26:59.397]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:59.397]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:59.397]     }
[10:26:59.397]     ...future.result <- base::tryCatch({
[10:26:59.397]         base::withCallingHandlers({
[10:26:59.397]             ...future.value <- base::withVisible(base::local(2))
[10:26:59.397]             future::FutureResult(value = ...future.value$value, 
[10:26:59.397]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:59.397]                   ...future.rng), globalenv = if (FALSE) 
[10:26:59.397]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:59.397]                     ...future.globalenv.names))
[10:26:59.397]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:59.397]         }, condition = base::local({
[10:26:59.397]             c <- base::c
[10:26:59.397]             inherits <- base::inherits
[10:26:59.397]             invokeRestart <- base::invokeRestart
[10:26:59.397]             length <- base::length
[10:26:59.397]             list <- base::list
[10:26:59.397]             seq.int <- base::seq.int
[10:26:59.397]             signalCondition <- base::signalCondition
[10:26:59.397]             sys.calls <- base::sys.calls
[10:26:59.397]             `[[` <- base::`[[`
[10:26:59.397]             `+` <- base::`+`
[10:26:59.397]             `<<-` <- base::`<<-`
[10:26:59.397]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:59.397]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:59.397]                   3L)]
[10:26:59.397]             }
[10:26:59.397]             function(cond) {
[10:26:59.397]                 is_error <- inherits(cond, "error")
[10:26:59.397]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:59.397]                   NULL)
[10:26:59.397]                 if (is_error) {
[10:26:59.397]                   sessionInformation <- function() {
[10:26:59.397]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:59.397]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:59.397]                       search = base::search(), system = base::Sys.info())
[10:26:59.397]                   }
[10:26:59.397]                   ...future.conditions[[length(...future.conditions) + 
[10:26:59.397]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:59.397]                     cond$call), session = sessionInformation(), 
[10:26:59.397]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:59.397]                   signalCondition(cond)
[10:26:59.397]                 }
[10:26:59.397]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:59.397]                 "immediateCondition"))) {
[10:26:59.397]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:59.397]                   ...future.conditions[[length(...future.conditions) + 
[10:26:59.397]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:59.397]                   if (TRUE && !signal) {
[10:26:59.397]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:59.397]                     {
[10:26:59.397]                       inherits <- base::inherits
[10:26:59.397]                       invokeRestart <- base::invokeRestart
[10:26:59.397]                       is.null <- base::is.null
[10:26:59.397]                       muffled <- FALSE
[10:26:59.397]                       if (inherits(cond, "message")) {
[10:26:59.397]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:59.397]                         if (muffled) 
[10:26:59.397]                           invokeRestart("muffleMessage")
[10:26:59.397]                       }
[10:26:59.397]                       else if (inherits(cond, "warning")) {
[10:26:59.397]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:59.397]                         if (muffled) 
[10:26:59.397]                           invokeRestart("muffleWarning")
[10:26:59.397]                       }
[10:26:59.397]                       else if (inherits(cond, "condition")) {
[10:26:59.397]                         if (!is.null(pattern)) {
[10:26:59.397]                           computeRestarts <- base::computeRestarts
[10:26:59.397]                           grepl <- base::grepl
[10:26:59.397]                           restarts <- computeRestarts(cond)
[10:26:59.397]                           for (restart in restarts) {
[10:26:59.397]                             name <- restart$name
[10:26:59.397]                             if (is.null(name)) 
[10:26:59.397]                               next
[10:26:59.397]                             if (!grepl(pattern, name)) 
[10:26:59.397]                               next
[10:26:59.397]                             invokeRestart(restart)
[10:26:59.397]                             muffled <- TRUE
[10:26:59.397]                             break
[10:26:59.397]                           }
[10:26:59.397]                         }
[10:26:59.397]                       }
[10:26:59.397]                       invisible(muffled)
[10:26:59.397]                     }
[10:26:59.397]                     muffleCondition(cond, pattern = "^muffle")
[10:26:59.397]                   }
[10:26:59.397]                 }
[10:26:59.397]                 else {
[10:26:59.397]                   if (TRUE) {
[10:26:59.397]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:59.397]                     {
[10:26:59.397]                       inherits <- base::inherits
[10:26:59.397]                       invokeRestart <- base::invokeRestart
[10:26:59.397]                       is.null <- base::is.null
[10:26:59.397]                       muffled <- FALSE
[10:26:59.397]                       if (inherits(cond, "message")) {
[10:26:59.397]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:59.397]                         if (muffled) 
[10:26:59.397]                           invokeRestart("muffleMessage")
[10:26:59.397]                       }
[10:26:59.397]                       else if (inherits(cond, "warning")) {
[10:26:59.397]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:59.397]                         if (muffled) 
[10:26:59.397]                           invokeRestart("muffleWarning")
[10:26:59.397]                       }
[10:26:59.397]                       else if (inherits(cond, "condition")) {
[10:26:59.397]                         if (!is.null(pattern)) {
[10:26:59.397]                           computeRestarts <- base::computeRestarts
[10:26:59.397]                           grepl <- base::grepl
[10:26:59.397]                           restarts <- computeRestarts(cond)
[10:26:59.397]                           for (restart in restarts) {
[10:26:59.397]                             name <- restart$name
[10:26:59.397]                             if (is.null(name)) 
[10:26:59.397]                               next
[10:26:59.397]                             if (!grepl(pattern, name)) 
[10:26:59.397]                               next
[10:26:59.397]                             invokeRestart(restart)
[10:26:59.397]                             muffled <- TRUE
[10:26:59.397]                             break
[10:26:59.397]                           }
[10:26:59.397]                         }
[10:26:59.397]                       }
[10:26:59.397]                       invisible(muffled)
[10:26:59.397]                     }
[10:26:59.397]                     muffleCondition(cond, pattern = "^muffle")
[10:26:59.397]                   }
[10:26:59.397]                 }
[10:26:59.397]             }
[10:26:59.397]         }))
[10:26:59.397]     }, error = function(ex) {
[10:26:59.397]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:59.397]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:59.397]                 ...future.rng), started = ...future.startTime, 
[10:26:59.397]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:59.397]             version = "1.8"), class = "FutureResult")
[10:26:59.397]     }, finally = {
[10:26:59.397]         if (!identical(...future.workdir, getwd())) 
[10:26:59.397]             setwd(...future.workdir)
[10:26:59.397]         {
[10:26:59.397]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:59.397]                 ...future.oldOptions$nwarnings <- NULL
[10:26:59.397]             }
[10:26:59.397]             base::options(...future.oldOptions)
[10:26:59.397]             if (.Platform$OS.type == "windows") {
[10:26:59.397]                 old_names <- names(...future.oldEnvVars)
[10:26:59.397]                 envs <- base::Sys.getenv()
[10:26:59.397]                 names <- names(envs)
[10:26:59.397]                 common <- intersect(names, old_names)
[10:26:59.397]                 added <- setdiff(names, old_names)
[10:26:59.397]                 removed <- setdiff(old_names, names)
[10:26:59.397]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:59.397]                   envs[common]]
[10:26:59.397]                 NAMES <- toupper(changed)
[10:26:59.397]                 args <- list()
[10:26:59.397]                 for (kk in seq_along(NAMES)) {
[10:26:59.397]                   name <- changed[[kk]]
[10:26:59.397]                   NAME <- NAMES[[kk]]
[10:26:59.397]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:59.397]                     next
[10:26:59.397]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:59.397]                 }
[10:26:59.397]                 NAMES <- toupper(added)
[10:26:59.397]                 for (kk in seq_along(NAMES)) {
[10:26:59.397]                   name <- added[[kk]]
[10:26:59.397]                   NAME <- NAMES[[kk]]
[10:26:59.397]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:59.397]                     next
[10:26:59.397]                   args[[name]] <- ""
[10:26:59.397]                 }
[10:26:59.397]                 NAMES <- toupper(removed)
[10:26:59.397]                 for (kk in seq_along(NAMES)) {
[10:26:59.397]                   name <- removed[[kk]]
[10:26:59.397]                   NAME <- NAMES[[kk]]
[10:26:59.397]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:59.397]                     next
[10:26:59.397]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:59.397]                 }
[10:26:59.397]                 if (length(args) > 0) 
[10:26:59.397]                   base::do.call(base::Sys.setenv, args = args)
[10:26:59.397]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:59.397]             }
[10:26:59.397]             else {
[10:26:59.397]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:59.397]             }
[10:26:59.397]             {
[10:26:59.397]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:59.397]                   0L) {
[10:26:59.397]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:59.397]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:59.397]                   base::options(opts)
[10:26:59.397]                 }
[10:26:59.397]                 {
[10:26:59.397]                   {
[10:26:59.397]                     NULL
[10:26:59.397]                     RNGkind("Mersenne-Twister")
[10:26:59.397]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:59.397]                       inherits = FALSE)
[10:26:59.397]                   }
[10:26:59.397]                   options(future.plan = NULL)
[10:26:59.397]                   if (is.na(NA_character_)) 
[10:26:59.397]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:59.397]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:59.397]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:59.397]                   {
[10:26:59.397]                     future <- SequentialFuture(..., envir = envir)
[10:26:59.397]                     if (!future$lazy) 
[10:26:59.397]                       future <- run(future)
[10:26:59.397]                     invisible(future)
[10:26:59.397]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:59.397]                 }
[10:26:59.397]             }
[10:26:59.397]         }
[10:26:59.397]     })
[10:26:59.397]     if (TRUE) {
[10:26:59.397]         base::sink(type = "output", split = FALSE)
[10:26:59.397]         if (TRUE) {
[10:26:59.397]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:59.397]         }
[10:26:59.397]         else {
[10:26:59.397]             ...future.result["stdout"] <- base::list(NULL)
[10:26:59.397]         }
[10:26:59.397]         base::close(...future.stdout)
[10:26:59.397]         ...future.stdout <- NULL
[10:26:59.397]     }
[10:26:59.397]     ...future.result$conditions <- ...future.conditions
[10:26:59.397]     ...future.result$finished <- base::Sys.time()
[10:26:59.397]     ...future.result
[10:26:59.397] }
[10:26:59.399] plan(): Setting new future strategy stack:
[10:26:59.399] List of future strategies:
[10:26:59.399] 1. sequential:
[10:26:59.399]    - args: function (..., envir = parent.frame())
[10:26:59.399]    - tweaked: FALSE
[10:26:59.399]    - call: NULL
[10:26:59.399] plan(): nbrOfWorkers() = 1
[10:26:59.400] plan(): Setting new future strategy stack:
[10:26:59.400] List of future strategies:
[10:26:59.400] 1. sequential:
[10:26:59.400]    - args: function (..., envir = parent.frame())
[10:26:59.400]    - tweaked: FALSE
[10:26:59.400]    - call: plan(strategy)
[10:26:59.400] plan(): nbrOfWorkers() = 1
[10:26:59.401] SequentialFuture started (and completed)
[10:26:59.401] - Launch lazy future ... done
[10:26:59.401] run() for ‘SequentialFuture’ ... done
[10:26:59.401] resolve() on list ...
[10:26:59.401]  recursive: 0
[10:26:59.401]  length: 3
[10:26:59.401]  elements: ‘a’, ‘b’, ‘’
[10:26:59.402] resolved() for ‘SequentialFuture’ ...
[10:26:59.402] - state: ‘finished’
[10:26:59.402] - run: TRUE
[10:26:59.402] - result: ‘FutureResult’
[10:26:59.402] resolved() for ‘SequentialFuture’ ... done
[10:26:59.402] Future #1
[10:26:59.402]  length: 2 (resolved future 1)
[10:26:59.402] resolved() for ‘SequentialFuture’ ...
[10:26:59.403] - state: ‘finished’
[10:26:59.403] - run: TRUE
[10:26:59.403] - result: ‘FutureResult’
[10:26:59.403] resolved() for ‘SequentialFuture’ ... done
[10:26:59.403] Future #2
[10:26:59.403]  length: 1 (resolved future 2)
[10:26:59.403]  length: 0 (resolved future 3)
[10:26:59.403] resolve() on list ... DONE
[10:26:59.403] resolved() for ‘SequentialFuture’ ...
[10:26:59.403] - state: ‘finished’
[10:26:59.404] - run: TRUE
[10:26:59.404] - result: ‘FutureResult’
[10:26:59.404] resolved() for ‘SequentialFuture’ ... done
[10:26:59.404] resolved() for ‘SequentialFuture’ ...
[10:26:59.404] - state: ‘finished’
[10:26:59.404] - run: TRUE
[10:26:59.404] - result: ‘FutureResult’
[10:26:59.404] resolved() for ‘SequentialFuture’ ... done
[10:26:59.404] getGlobalsAndPackages() ...
[10:26:59.404] Searching for globals...
[10:26:59.408] 
[10:26:59.408] Searching for globals ... DONE
[10:26:59.408] - globals: [0] <none>
[10:26:59.408] getGlobalsAndPackages() ... DONE
[10:26:59.408] getGlobalsAndPackages() ...
[10:26:59.408] Searching for globals...
[10:26:59.409] 
[10:26:59.409] Searching for globals ... DONE
[10:26:59.409] - globals: [0] <none>
[10:26:59.409] getGlobalsAndPackages() ... DONE
[10:26:59.409] run() for ‘Future’ ...
[10:26:59.409] - state: ‘created’
[10:26:59.410] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:59.410] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:59.410] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:59.410]   - Field: ‘label’
[10:26:59.410]   - Field: ‘local’
[10:26:59.410]   - Field: ‘owner’
[10:26:59.410]   - Field: ‘envir’
[10:26:59.411]   - Field: ‘packages’
[10:26:59.411]   - Field: ‘gc’
[10:26:59.411]   - Field: ‘conditions’
[10:26:59.411]   - Field: ‘expr’
[10:26:59.411]   - Field: ‘uuid’
[10:26:59.411]   - Field: ‘seed’
[10:26:59.411]   - Field: ‘version’
[10:26:59.411]   - Field: ‘result’
[10:26:59.411]   - Field: ‘asynchronous’
[10:26:59.411]   - Field: ‘calls’
[10:26:59.412]   - Field: ‘globals’
[10:26:59.412]   - Field: ‘stdout’
[10:26:59.412]   - Field: ‘earlySignal’
[10:26:59.412]   - Field: ‘lazy’
[10:26:59.412]   - Field: ‘state’
[10:26:59.412] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:59.412] - Launch lazy future ...
[10:26:59.412] Packages needed by the future expression (n = 0): <none>
[10:26:59.412] Packages needed by future strategies (n = 0): <none>
[10:26:59.413] {
[10:26:59.413]     {
[10:26:59.413]         {
[10:26:59.413]             ...future.startTime <- base::Sys.time()
[10:26:59.413]             {
[10:26:59.413]                 {
[10:26:59.413]                   {
[10:26:59.413]                     base::local({
[10:26:59.413]                       has_future <- base::requireNamespace("future", 
[10:26:59.413]                         quietly = TRUE)
[10:26:59.413]                       if (has_future) {
[10:26:59.413]                         ns <- base::getNamespace("future")
[10:26:59.413]                         version <- ns[[".package"]][["version"]]
[10:26:59.413]                         if (is.null(version)) 
[10:26:59.413]                           version <- utils::packageVersion("future")
[10:26:59.413]                       }
[10:26:59.413]                       else {
[10:26:59.413]                         version <- NULL
[10:26:59.413]                       }
[10:26:59.413]                       if (!has_future || version < "1.8.0") {
[10:26:59.413]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:59.413]                           "", base::R.version$version.string), 
[10:26:59.413]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:59.413]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:59.413]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:59.413]                             "release", "version")], collapse = " "), 
[10:26:59.413]                           hostname = base::Sys.info()[["nodename"]])
[10:26:59.413]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:59.413]                           info)
[10:26:59.413]                         info <- base::paste(info, collapse = "; ")
[10:26:59.413]                         if (!has_future) {
[10:26:59.413]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:59.413]                             info)
[10:26:59.413]                         }
[10:26:59.413]                         else {
[10:26:59.413]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:59.413]                             info, version)
[10:26:59.413]                         }
[10:26:59.413]                         base::stop(msg)
[10:26:59.413]                       }
[10:26:59.413]                     })
[10:26:59.413]                   }
[10:26:59.413]                   options(future.plan = NULL)
[10:26:59.413]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:59.413]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:59.413]                 }
[10:26:59.413]                 ...future.workdir <- getwd()
[10:26:59.413]             }
[10:26:59.413]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:59.413]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:59.413]         }
[10:26:59.413]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:59.413]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:59.413]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:59.413]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:59.413]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:59.413]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:59.413]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:59.413]             base::names(...future.oldOptions))
[10:26:59.413]     }
[10:26:59.413]     if (FALSE) {
[10:26:59.413]     }
[10:26:59.413]     else {
[10:26:59.413]         if (TRUE) {
[10:26:59.413]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:59.413]                 open = "w")
[10:26:59.413]         }
[10:26:59.413]         else {
[10:26:59.413]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:59.413]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:59.413]         }
[10:26:59.413]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:59.413]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:59.413]             base::sink(type = "output", split = FALSE)
[10:26:59.413]             base::close(...future.stdout)
[10:26:59.413]         }, add = TRUE)
[10:26:59.413]     }
[10:26:59.413]     ...future.frame <- base::sys.nframe()
[10:26:59.413]     ...future.conditions <- base::list()
[10:26:59.413]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:59.413]     if (FALSE) {
[10:26:59.413]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:59.413]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:59.413]     }
[10:26:59.413]     ...future.result <- base::tryCatch({
[10:26:59.413]         base::withCallingHandlers({
[10:26:59.413]             ...future.value <- base::withVisible(base::local(2))
[10:26:59.413]             future::FutureResult(value = ...future.value$value, 
[10:26:59.413]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:59.413]                   ...future.rng), globalenv = if (FALSE) 
[10:26:59.413]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:59.413]                     ...future.globalenv.names))
[10:26:59.413]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:59.413]         }, condition = base::local({
[10:26:59.413]             c <- base::c
[10:26:59.413]             inherits <- base::inherits
[10:26:59.413]             invokeRestart <- base::invokeRestart
[10:26:59.413]             length <- base::length
[10:26:59.413]             list <- base::list
[10:26:59.413]             seq.int <- base::seq.int
[10:26:59.413]             signalCondition <- base::signalCondition
[10:26:59.413]             sys.calls <- base::sys.calls
[10:26:59.413]             `[[` <- base::`[[`
[10:26:59.413]             `+` <- base::`+`
[10:26:59.413]             `<<-` <- base::`<<-`
[10:26:59.413]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:59.413]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:59.413]                   3L)]
[10:26:59.413]             }
[10:26:59.413]             function(cond) {
[10:26:59.413]                 is_error <- inherits(cond, "error")
[10:26:59.413]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:59.413]                   NULL)
[10:26:59.413]                 if (is_error) {
[10:26:59.413]                   sessionInformation <- function() {
[10:26:59.413]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:59.413]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:59.413]                       search = base::search(), system = base::Sys.info())
[10:26:59.413]                   }
[10:26:59.413]                   ...future.conditions[[length(...future.conditions) + 
[10:26:59.413]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:59.413]                     cond$call), session = sessionInformation(), 
[10:26:59.413]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:59.413]                   signalCondition(cond)
[10:26:59.413]                 }
[10:26:59.413]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:59.413]                 "immediateCondition"))) {
[10:26:59.413]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:59.413]                   ...future.conditions[[length(...future.conditions) + 
[10:26:59.413]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:59.413]                   if (TRUE && !signal) {
[10:26:59.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:59.413]                     {
[10:26:59.413]                       inherits <- base::inherits
[10:26:59.413]                       invokeRestart <- base::invokeRestart
[10:26:59.413]                       is.null <- base::is.null
[10:26:59.413]                       muffled <- FALSE
[10:26:59.413]                       if (inherits(cond, "message")) {
[10:26:59.413]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:59.413]                         if (muffled) 
[10:26:59.413]                           invokeRestart("muffleMessage")
[10:26:59.413]                       }
[10:26:59.413]                       else if (inherits(cond, "warning")) {
[10:26:59.413]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:59.413]                         if (muffled) 
[10:26:59.413]                           invokeRestart("muffleWarning")
[10:26:59.413]                       }
[10:26:59.413]                       else if (inherits(cond, "condition")) {
[10:26:59.413]                         if (!is.null(pattern)) {
[10:26:59.413]                           computeRestarts <- base::computeRestarts
[10:26:59.413]                           grepl <- base::grepl
[10:26:59.413]                           restarts <- computeRestarts(cond)
[10:26:59.413]                           for (restart in restarts) {
[10:26:59.413]                             name <- restart$name
[10:26:59.413]                             if (is.null(name)) 
[10:26:59.413]                               next
[10:26:59.413]                             if (!grepl(pattern, name)) 
[10:26:59.413]                               next
[10:26:59.413]                             invokeRestart(restart)
[10:26:59.413]                             muffled <- TRUE
[10:26:59.413]                             break
[10:26:59.413]                           }
[10:26:59.413]                         }
[10:26:59.413]                       }
[10:26:59.413]                       invisible(muffled)
[10:26:59.413]                     }
[10:26:59.413]                     muffleCondition(cond, pattern = "^muffle")
[10:26:59.413]                   }
[10:26:59.413]                 }
[10:26:59.413]                 else {
[10:26:59.413]                   if (TRUE) {
[10:26:59.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:59.413]                     {
[10:26:59.413]                       inherits <- base::inherits
[10:26:59.413]                       invokeRestart <- base::invokeRestart
[10:26:59.413]                       is.null <- base::is.null
[10:26:59.413]                       muffled <- FALSE
[10:26:59.413]                       if (inherits(cond, "message")) {
[10:26:59.413]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:59.413]                         if (muffled) 
[10:26:59.413]                           invokeRestart("muffleMessage")
[10:26:59.413]                       }
[10:26:59.413]                       else if (inherits(cond, "warning")) {
[10:26:59.413]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:59.413]                         if (muffled) 
[10:26:59.413]                           invokeRestart("muffleWarning")
[10:26:59.413]                       }
[10:26:59.413]                       else if (inherits(cond, "condition")) {
[10:26:59.413]                         if (!is.null(pattern)) {
[10:26:59.413]                           computeRestarts <- base::computeRestarts
[10:26:59.413]                           grepl <- base::grepl
[10:26:59.413]                           restarts <- computeRestarts(cond)
[10:26:59.413]                           for (restart in restarts) {
[10:26:59.413]                             name <- restart$name
[10:26:59.413]                             if (is.null(name)) 
[10:26:59.413]                               next
[10:26:59.413]                             if (!grepl(pattern, name)) 
[10:26:59.413]                               next
[10:26:59.413]                             invokeRestart(restart)
[10:26:59.413]                             muffled <- TRUE
[10:26:59.413]                             break
[10:26:59.413]                           }
[10:26:59.413]                         }
[10:26:59.413]                       }
[10:26:59.413]                       invisible(muffled)
[10:26:59.413]                     }
[10:26:59.413]                     muffleCondition(cond, pattern = "^muffle")
[10:26:59.413]                   }
[10:26:59.413]                 }
[10:26:59.413]             }
[10:26:59.413]         }))
[10:26:59.413]     }, error = function(ex) {
[10:26:59.413]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:59.413]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:59.413]                 ...future.rng), started = ...future.startTime, 
[10:26:59.413]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:59.413]             version = "1.8"), class = "FutureResult")
[10:26:59.413]     }, finally = {
[10:26:59.413]         if (!identical(...future.workdir, getwd())) 
[10:26:59.413]             setwd(...future.workdir)
[10:26:59.413]         {
[10:26:59.413]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:59.413]                 ...future.oldOptions$nwarnings <- NULL
[10:26:59.413]             }
[10:26:59.413]             base::options(...future.oldOptions)
[10:26:59.413]             if (.Platform$OS.type == "windows") {
[10:26:59.413]                 old_names <- names(...future.oldEnvVars)
[10:26:59.413]                 envs <- base::Sys.getenv()
[10:26:59.413]                 names <- names(envs)
[10:26:59.413]                 common <- intersect(names, old_names)
[10:26:59.413]                 added <- setdiff(names, old_names)
[10:26:59.413]                 removed <- setdiff(old_names, names)
[10:26:59.413]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:59.413]                   envs[common]]
[10:26:59.413]                 NAMES <- toupper(changed)
[10:26:59.413]                 args <- list()
[10:26:59.413]                 for (kk in seq_along(NAMES)) {
[10:26:59.413]                   name <- changed[[kk]]
[10:26:59.413]                   NAME <- NAMES[[kk]]
[10:26:59.413]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:59.413]                     next
[10:26:59.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:59.413]                 }
[10:26:59.413]                 NAMES <- toupper(added)
[10:26:59.413]                 for (kk in seq_along(NAMES)) {
[10:26:59.413]                   name <- added[[kk]]
[10:26:59.413]                   NAME <- NAMES[[kk]]
[10:26:59.413]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:59.413]                     next
[10:26:59.413]                   args[[name]] <- ""
[10:26:59.413]                 }
[10:26:59.413]                 NAMES <- toupper(removed)
[10:26:59.413]                 for (kk in seq_along(NAMES)) {
[10:26:59.413]                   name <- removed[[kk]]
[10:26:59.413]                   NAME <- NAMES[[kk]]
[10:26:59.413]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:59.413]                     next
[10:26:59.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:59.413]                 }
[10:26:59.413]                 if (length(args) > 0) 
[10:26:59.413]                   base::do.call(base::Sys.setenv, args = args)
[10:26:59.413]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:59.413]             }
[10:26:59.413]             else {
[10:26:59.413]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:59.413]             }
[10:26:59.413]             {
[10:26:59.413]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:59.413]                   0L) {
[10:26:59.413]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:59.413]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:59.413]                   base::options(opts)
[10:26:59.413]                 }
[10:26:59.413]                 {
[10:26:59.413]                   {
[10:26:59.413]                     NULL
[10:26:59.413]                     RNGkind("Mersenne-Twister")
[10:26:59.413]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:59.413]                       inherits = FALSE)
[10:26:59.413]                   }
[10:26:59.413]                   options(future.plan = NULL)
[10:26:59.413]                   if (is.na(NA_character_)) 
[10:26:59.413]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:59.413]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:59.413]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:59.413]                   {
[10:26:59.413]                     future <- SequentialFuture(..., envir = envir)
[10:26:59.413]                     if (!future$lazy) 
[10:26:59.413]                       future <- run(future)
[10:26:59.413]                     invisible(future)
[10:26:59.413]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:59.413]                 }
[10:26:59.413]             }
[10:26:59.413]         }
[10:26:59.413]     })
[10:26:59.413]     if (TRUE) {
[10:26:59.413]         base::sink(type = "output", split = FALSE)
[10:26:59.413]         if (TRUE) {
[10:26:59.413]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:59.413]         }
[10:26:59.413]         else {
[10:26:59.413]             ...future.result["stdout"] <- base::list(NULL)
[10:26:59.413]         }
[10:26:59.413]         base::close(...future.stdout)
[10:26:59.413]         ...future.stdout <- NULL
[10:26:59.413]     }
[10:26:59.413]     ...future.result$conditions <- ...future.conditions
[10:26:59.413]     ...future.result$finished <- base::Sys.time()
[10:26:59.413]     ...future.result
[10:26:59.413] }
[10:26:59.415] plan(): Setting new future strategy stack:
[10:26:59.415] List of future strategies:
[10:26:59.415] 1. sequential:
[10:26:59.415]    - args: function (..., envir = parent.frame())
[10:26:59.415]    - tweaked: FALSE
[10:26:59.415]    - call: NULL
[10:26:59.415] plan(): nbrOfWorkers() = 1
[10:26:59.416] plan(): Setting new future strategy stack:
[10:26:59.416] List of future strategies:
[10:26:59.416] 1. sequential:
[10:26:59.416]    - args: function (..., envir = parent.frame())
[10:26:59.416]    - tweaked: FALSE
[10:26:59.416]    - call: plan(strategy)
[10:26:59.417] plan(): nbrOfWorkers() = 1
[10:26:59.417] SequentialFuture started (and completed)
[10:26:59.417] - Launch lazy future ... done
[10:26:59.417] run() for ‘SequentialFuture’ ... done
[10:26:59.417] resolve() on list ...
[10:26:59.417]  recursive: 0
[10:26:59.418]  length: 3
[10:26:59.418]  elements: ‘a’, ‘b’, ‘’
[10:26:59.418] run() for ‘Future’ ...
[10:26:59.418] - state: ‘created’
[10:26:59.418] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:59.418] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:59.418] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:59.418]   - Field: ‘label’
[10:26:59.419]   - Field: ‘local’
[10:26:59.419]   - Field: ‘owner’
[10:26:59.419]   - Field: ‘envir’
[10:26:59.419]   - Field: ‘packages’
[10:26:59.419]   - Field: ‘gc’
[10:26:59.419]   - Field: ‘conditions’
[10:26:59.419]   - Field: ‘expr’
[10:26:59.419]   - Field: ‘uuid’
[10:26:59.419]   - Field: ‘seed’
[10:26:59.419]   - Field: ‘version’
[10:26:59.420]   - Field: ‘result’
[10:26:59.420]   - Field: ‘asynchronous’
[10:26:59.420]   - Field: ‘calls’
[10:26:59.420]   - Field: ‘globals’
[10:26:59.420]   - Field: ‘stdout’
[10:26:59.420]   - Field: ‘earlySignal’
[10:26:59.420]   - Field: ‘lazy’
[10:26:59.420]   - Field: ‘state’
[10:26:59.420] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:59.420] - Launch lazy future ...
[10:26:59.421] Packages needed by the future expression (n = 0): <none>
[10:26:59.421] Packages needed by future strategies (n = 0): <none>
[10:26:59.421] {
[10:26:59.421]     {
[10:26:59.421]         {
[10:26:59.421]             ...future.startTime <- base::Sys.time()
[10:26:59.421]             {
[10:26:59.421]                 {
[10:26:59.421]                   {
[10:26:59.421]                     base::local({
[10:26:59.421]                       has_future <- base::requireNamespace("future", 
[10:26:59.421]                         quietly = TRUE)
[10:26:59.421]                       if (has_future) {
[10:26:59.421]                         ns <- base::getNamespace("future")
[10:26:59.421]                         version <- ns[[".package"]][["version"]]
[10:26:59.421]                         if (is.null(version)) 
[10:26:59.421]                           version <- utils::packageVersion("future")
[10:26:59.421]                       }
[10:26:59.421]                       else {
[10:26:59.421]                         version <- NULL
[10:26:59.421]                       }
[10:26:59.421]                       if (!has_future || version < "1.8.0") {
[10:26:59.421]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:59.421]                           "", base::R.version$version.string), 
[10:26:59.421]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:59.421]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:59.421]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:59.421]                             "release", "version")], collapse = " "), 
[10:26:59.421]                           hostname = base::Sys.info()[["nodename"]])
[10:26:59.421]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:59.421]                           info)
[10:26:59.421]                         info <- base::paste(info, collapse = "; ")
[10:26:59.421]                         if (!has_future) {
[10:26:59.421]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:59.421]                             info)
[10:26:59.421]                         }
[10:26:59.421]                         else {
[10:26:59.421]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:59.421]                             info, version)
[10:26:59.421]                         }
[10:26:59.421]                         base::stop(msg)
[10:26:59.421]                       }
[10:26:59.421]                     })
[10:26:59.421]                   }
[10:26:59.421]                   options(future.plan = NULL)
[10:26:59.421]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:59.421]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:59.421]                 }
[10:26:59.421]                 ...future.workdir <- getwd()
[10:26:59.421]             }
[10:26:59.421]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:59.421]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:59.421]         }
[10:26:59.421]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:59.421]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:59.421]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:59.421]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:59.421]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:59.421]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:59.421]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:59.421]             base::names(...future.oldOptions))
[10:26:59.421]     }
[10:26:59.421]     if (FALSE) {
[10:26:59.421]     }
[10:26:59.421]     else {
[10:26:59.421]         if (TRUE) {
[10:26:59.421]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:59.421]                 open = "w")
[10:26:59.421]         }
[10:26:59.421]         else {
[10:26:59.421]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:59.421]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:59.421]         }
[10:26:59.421]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:59.421]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:59.421]             base::sink(type = "output", split = FALSE)
[10:26:59.421]             base::close(...future.stdout)
[10:26:59.421]         }, add = TRUE)
[10:26:59.421]     }
[10:26:59.421]     ...future.frame <- base::sys.nframe()
[10:26:59.421]     ...future.conditions <- base::list()
[10:26:59.421]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:59.421]     if (FALSE) {
[10:26:59.421]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:59.421]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:59.421]     }
[10:26:59.421]     ...future.result <- base::tryCatch({
[10:26:59.421]         base::withCallingHandlers({
[10:26:59.421]             ...future.value <- base::withVisible(base::local(1))
[10:26:59.421]             future::FutureResult(value = ...future.value$value, 
[10:26:59.421]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:59.421]                   ...future.rng), globalenv = if (FALSE) 
[10:26:59.421]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:59.421]                     ...future.globalenv.names))
[10:26:59.421]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:59.421]         }, condition = base::local({
[10:26:59.421]             c <- base::c
[10:26:59.421]             inherits <- base::inherits
[10:26:59.421]             invokeRestart <- base::invokeRestart
[10:26:59.421]             length <- base::length
[10:26:59.421]             list <- base::list
[10:26:59.421]             seq.int <- base::seq.int
[10:26:59.421]             signalCondition <- base::signalCondition
[10:26:59.421]             sys.calls <- base::sys.calls
[10:26:59.421]             `[[` <- base::`[[`
[10:26:59.421]             `+` <- base::`+`
[10:26:59.421]             `<<-` <- base::`<<-`
[10:26:59.421]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:59.421]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:59.421]                   3L)]
[10:26:59.421]             }
[10:26:59.421]             function(cond) {
[10:26:59.421]                 is_error <- inherits(cond, "error")
[10:26:59.421]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:59.421]                   NULL)
[10:26:59.421]                 if (is_error) {
[10:26:59.421]                   sessionInformation <- function() {
[10:26:59.421]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:59.421]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:59.421]                       search = base::search(), system = base::Sys.info())
[10:26:59.421]                   }
[10:26:59.421]                   ...future.conditions[[length(...future.conditions) + 
[10:26:59.421]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:59.421]                     cond$call), session = sessionInformation(), 
[10:26:59.421]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:59.421]                   signalCondition(cond)
[10:26:59.421]                 }
[10:26:59.421]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:59.421]                 "immediateCondition"))) {
[10:26:59.421]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:59.421]                   ...future.conditions[[length(...future.conditions) + 
[10:26:59.421]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:59.421]                   if (TRUE && !signal) {
[10:26:59.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:59.421]                     {
[10:26:59.421]                       inherits <- base::inherits
[10:26:59.421]                       invokeRestart <- base::invokeRestart
[10:26:59.421]                       is.null <- base::is.null
[10:26:59.421]                       muffled <- FALSE
[10:26:59.421]                       if (inherits(cond, "message")) {
[10:26:59.421]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:59.421]                         if (muffled) 
[10:26:59.421]                           invokeRestart("muffleMessage")
[10:26:59.421]                       }
[10:26:59.421]                       else if (inherits(cond, "warning")) {
[10:26:59.421]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:59.421]                         if (muffled) 
[10:26:59.421]                           invokeRestart("muffleWarning")
[10:26:59.421]                       }
[10:26:59.421]                       else if (inherits(cond, "condition")) {
[10:26:59.421]                         if (!is.null(pattern)) {
[10:26:59.421]                           computeRestarts <- base::computeRestarts
[10:26:59.421]                           grepl <- base::grepl
[10:26:59.421]                           restarts <- computeRestarts(cond)
[10:26:59.421]                           for (restart in restarts) {
[10:26:59.421]                             name <- restart$name
[10:26:59.421]                             if (is.null(name)) 
[10:26:59.421]                               next
[10:26:59.421]                             if (!grepl(pattern, name)) 
[10:26:59.421]                               next
[10:26:59.421]                             invokeRestart(restart)
[10:26:59.421]                             muffled <- TRUE
[10:26:59.421]                             break
[10:26:59.421]                           }
[10:26:59.421]                         }
[10:26:59.421]                       }
[10:26:59.421]                       invisible(muffled)
[10:26:59.421]                     }
[10:26:59.421]                     muffleCondition(cond, pattern = "^muffle")
[10:26:59.421]                   }
[10:26:59.421]                 }
[10:26:59.421]                 else {
[10:26:59.421]                   if (TRUE) {
[10:26:59.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:59.421]                     {
[10:26:59.421]                       inherits <- base::inherits
[10:26:59.421]                       invokeRestart <- base::invokeRestart
[10:26:59.421]                       is.null <- base::is.null
[10:26:59.421]                       muffled <- FALSE
[10:26:59.421]                       if (inherits(cond, "message")) {
[10:26:59.421]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:59.421]                         if (muffled) 
[10:26:59.421]                           invokeRestart("muffleMessage")
[10:26:59.421]                       }
[10:26:59.421]                       else if (inherits(cond, "warning")) {
[10:26:59.421]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:59.421]                         if (muffled) 
[10:26:59.421]                           invokeRestart("muffleWarning")
[10:26:59.421]                       }
[10:26:59.421]                       else if (inherits(cond, "condition")) {
[10:26:59.421]                         if (!is.null(pattern)) {
[10:26:59.421]                           computeRestarts <- base::computeRestarts
[10:26:59.421]                           grepl <- base::grepl
[10:26:59.421]                           restarts <- computeRestarts(cond)
[10:26:59.421]                           for (restart in restarts) {
[10:26:59.421]                             name <- restart$name
[10:26:59.421]                             if (is.null(name)) 
[10:26:59.421]                               next
[10:26:59.421]                             if (!grepl(pattern, name)) 
[10:26:59.421]                               next
[10:26:59.421]                             invokeRestart(restart)
[10:26:59.421]                             muffled <- TRUE
[10:26:59.421]                             break
[10:26:59.421]                           }
[10:26:59.421]                         }
[10:26:59.421]                       }
[10:26:59.421]                       invisible(muffled)
[10:26:59.421]                     }
[10:26:59.421]                     muffleCondition(cond, pattern = "^muffle")
[10:26:59.421]                   }
[10:26:59.421]                 }
[10:26:59.421]             }
[10:26:59.421]         }))
[10:26:59.421]     }, error = function(ex) {
[10:26:59.421]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:59.421]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:59.421]                 ...future.rng), started = ...future.startTime, 
[10:26:59.421]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:59.421]             version = "1.8"), class = "FutureResult")
[10:26:59.421]     }, finally = {
[10:26:59.421]         if (!identical(...future.workdir, getwd())) 
[10:26:59.421]             setwd(...future.workdir)
[10:26:59.421]         {
[10:26:59.421]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:59.421]                 ...future.oldOptions$nwarnings <- NULL
[10:26:59.421]             }
[10:26:59.421]             base::options(...future.oldOptions)
[10:26:59.421]             if (.Platform$OS.type == "windows") {
[10:26:59.421]                 old_names <- names(...future.oldEnvVars)
[10:26:59.421]                 envs <- base::Sys.getenv()
[10:26:59.421]                 names <- names(envs)
[10:26:59.421]                 common <- intersect(names, old_names)
[10:26:59.421]                 added <- setdiff(names, old_names)
[10:26:59.421]                 removed <- setdiff(old_names, names)
[10:26:59.421]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:59.421]                   envs[common]]
[10:26:59.421]                 NAMES <- toupper(changed)
[10:26:59.421]                 args <- list()
[10:26:59.421]                 for (kk in seq_along(NAMES)) {
[10:26:59.421]                   name <- changed[[kk]]
[10:26:59.421]                   NAME <- NAMES[[kk]]
[10:26:59.421]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:59.421]                     next
[10:26:59.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:59.421]                 }
[10:26:59.421]                 NAMES <- toupper(added)
[10:26:59.421]                 for (kk in seq_along(NAMES)) {
[10:26:59.421]                   name <- added[[kk]]
[10:26:59.421]                   NAME <- NAMES[[kk]]
[10:26:59.421]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:59.421]                     next
[10:26:59.421]                   args[[name]] <- ""
[10:26:59.421]                 }
[10:26:59.421]                 NAMES <- toupper(removed)
[10:26:59.421]                 for (kk in seq_along(NAMES)) {
[10:26:59.421]                   name <- removed[[kk]]
[10:26:59.421]                   NAME <- NAMES[[kk]]
[10:26:59.421]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:59.421]                     next
[10:26:59.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:59.421]                 }
[10:26:59.421]                 if (length(args) > 0) 
[10:26:59.421]                   base::do.call(base::Sys.setenv, args = args)
[10:26:59.421]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:59.421]             }
[10:26:59.421]             else {
[10:26:59.421]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:59.421]             }
[10:26:59.421]             {
[10:26:59.421]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:59.421]                   0L) {
[10:26:59.421]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:59.421]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:59.421]                   base::options(opts)
[10:26:59.421]                 }
[10:26:59.421]                 {
[10:26:59.421]                   {
[10:26:59.421]                     NULL
[10:26:59.421]                     RNGkind("Mersenne-Twister")
[10:26:59.421]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:59.421]                       inherits = FALSE)
[10:26:59.421]                   }
[10:26:59.421]                   options(future.plan = NULL)
[10:26:59.421]                   if (is.na(NA_character_)) 
[10:26:59.421]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:59.421]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:59.421]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:59.421]                   {
[10:26:59.421]                     future <- SequentialFuture(..., envir = envir)
[10:26:59.421]                     if (!future$lazy) 
[10:26:59.421]                       future <- run(future)
[10:26:59.421]                     invisible(future)
[10:26:59.421]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:59.421]                 }
[10:26:59.421]             }
[10:26:59.421]         }
[10:26:59.421]     })
[10:26:59.421]     if (TRUE) {
[10:26:59.421]         base::sink(type = "output", split = FALSE)
[10:26:59.421]         if (TRUE) {
[10:26:59.421]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:59.421]         }
[10:26:59.421]         else {
[10:26:59.421]             ...future.result["stdout"] <- base::list(NULL)
[10:26:59.421]         }
[10:26:59.421]         base::close(...future.stdout)
[10:26:59.421]         ...future.stdout <- NULL
[10:26:59.421]     }
[10:26:59.421]     ...future.result$conditions <- ...future.conditions
[10:26:59.421]     ...future.result$finished <- base::Sys.time()
[10:26:59.421]     ...future.result
[10:26:59.421] }
[10:26:59.423] plan(): Setting new future strategy stack:
[10:26:59.423] List of future strategies:
[10:26:59.423] 1. sequential:
[10:26:59.423]    - args: function (..., envir = parent.frame())
[10:26:59.423]    - tweaked: FALSE
[10:26:59.423]    - call: NULL
[10:26:59.423] plan(): nbrOfWorkers() = 1
[10:26:59.424] plan(): Setting new future strategy stack:
[10:26:59.424] List of future strategies:
[10:26:59.424] 1. sequential:
[10:26:59.424]    - args: function (..., envir = parent.frame())
[10:26:59.424]    - tweaked: FALSE
[10:26:59.424]    - call: plan(strategy)
[10:26:59.425] plan(): nbrOfWorkers() = 1
[10:26:59.425] SequentialFuture started (and completed)
[10:26:59.425] - Launch lazy future ... done
[10:26:59.425] run() for ‘SequentialFuture’ ... done
[10:26:59.425] resolved() for ‘SequentialFuture’ ...
[10:26:59.425] - state: ‘finished’
[10:26:59.425] - run: TRUE
[10:26:59.425] - result: ‘FutureResult’
[10:26:59.426] resolved() for ‘SequentialFuture’ ... done
[10:26:59.426] Future #1
[10:26:59.426]  length: 2 (resolved future 1)
[10:26:59.426] resolved() for ‘SequentialFuture’ ...
[10:26:59.426] - state: ‘finished’
[10:26:59.426] - run: TRUE
[10:26:59.426] - result: ‘FutureResult’
[10:26:59.426] resolved() for ‘SequentialFuture’ ... done
[10:26:59.426] Future #2
[10:26:59.426]  length: 1 (resolved future 2)
[10:26:59.427]  length: 0 (resolved future 3)
[10:26:59.427] resolve() on list ... DONE
[10:26:59.427] resolved() for ‘SequentialFuture’ ...
[10:26:59.427] - state: ‘finished’
[10:26:59.427] - run: TRUE
[10:26:59.427] - result: ‘FutureResult’
[10:26:59.427] resolved() for ‘SequentialFuture’ ... done
[10:26:59.427] resolved() for ‘SequentialFuture’ ...
[10:26:59.427] - state: ‘finished’
[10:26:59.427] - run: TRUE
[10:26:59.427] - result: ‘FutureResult’
[10:26:59.428] resolved() for ‘SequentialFuture’ ... done
[10:26:59.428] getGlobalsAndPackages() ...
[10:26:59.428] Searching for globals...
[10:26:59.428] 
[10:26:59.428] Searching for globals ... DONE
[10:26:59.428] - globals: [0] <none>
[10:26:59.428] getGlobalsAndPackages() ... DONE
[10:26:59.429] getGlobalsAndPackages() ...
[10:26:59.429] Searching for globals...
[10:26:59.429] 
[10:26:59.429] Searching for globals ... DONE
[10:26:59.429] - globals: [0] <none>
[10:26:59.429] getGlobalsAndPackages() ... DONE
[10:26:59.430] resolve() on list ...
[10:26:59.430]  recursive: 0
[10:26:59.430]  length: 3
[10:26:59.430]  elements: ‘a’, ‘b’, ‘’
[10:26:59.430] run() for ‘Future’ ...
[10:26:59.430] - state: ‘created’
[10:26:59.430] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:59.430] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:59.431] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:59.431]   - Field: ‘label’
[10:26:59.431]   - Field: ‘local’
[10:26:59.431]   - Field: ‘owner’
[10:26:59.431]   - Field: ‘envir’
[10:26:59.431]   - Field: ‘packages’
[10:26:59.431]   - Field: ‘gc’
[10:26:59.431]   - Field: ‘conditions’
[10:26:59.431]   - Field: ‘expr’
[10:26:59.431]   - Field: ‘uuid’
[10:26:59.431]   - Field: ‘seed’
[10:26:59.432]   - Field: ‘version’
[10:26:59.432]   - Field: ‘result’
[10:26:59.432]   - Field: ‘asynchronous’
[10:26:59.432]   - Field: ‘calls’
[10:26:59.432]   - Field: ‘globals’
[10:26:59.432]   - Field: ‘stdout’
[10:26:59.432]   - Field: ‘earlySignal’
[10:26:59.432]   - Field: ‘lazy’
[10:26:59.432]   - Field: ‘state’
[10:26:59.432] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:59.433] - Launch lazy future ...
[10:26:59.433] Packages needed by the future expression (n = 0): <none>
[10:26:59.433] Packages needed by future strategies (n = 0): <none>
[10:26:59.433] {
[10:26:59.433]     {
[10:26:59.433]         {
[10:26:59.433]             ...future.startTime <- base::Sys.time()
[10:26:59.433]             {
[10:26:59.433]                 {
[10:26:59.433]                   {
[10:26:59.433]                     base::local({
[10:26:59.433]                       has_future <- base::requireNamespace("future", 
[10:26:59.433]                         quietly = TRUE)
[10:26:59.433]                       if (has_future) {
[10:26:59.433]                         ns <- base::getNamespace("future")
[10:26:59.433]                         version <- ns[[".package"]][["version"]]
[10:26:59.433]                         if (is.null(version)) 
[10:26:59.433]                           version <- utils::packageVersion("future")
[10:26:59.433]                       }
[10:26:59.433]                       else {
[10:26:59.433]                         version <- NULL
[10:26:59.433]                       }
[10:26:59.433]                       if (!has_future || version < "1.8.0") {
[10:26:59.433]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:59.433]                           "", base::R.version$version.string), 
[10:26:59.433]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:59.433]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:59.433]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:59.433]                             "release", "version")], collapse = " "), 
[10:26:59.433]                           hostname = base::Sys.info()[["nodename"]])
[10:26:59.433]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:59.433]                           info)
[10:26:59.433]                         info <- base::paste(info, collapse = "; ")
[10:26:59.433]                         if (!has_future) {
[10:26:59.433]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:59.433]                             info)
[10:26:59.433]                         }
[10:26:59.433]                         else {
[10:26:59.433]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:59.433]                             info, version)
[10:26:59.433]                         }
[10:26:59.433]                         base::stop(msg)
[10:26:59.433]                       }
[10:26:59.433]                     })
[10:26:59.433]                   }
[10:26:59.433]                   options(future.plan = NULL)
[10:26:59.433]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:59.433]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:59.433]                 }
[10:26:59.433]                 ...future.workdir <- getwd()
[10:26:59.433]             }
[10:26:59.433]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:59.433]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:59.433]         }
[10:26:59.433]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:59.433]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:59.433]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:59.433]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:59.433]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:59.433]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:59.433]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:59.433]             base::names(...future.oldOptions))
[10:26:59.433]     }
[10:26:59.433]     if (FALSE) {
[10:26:59.433]     }
[10:26:59.433]     else {
[10:26:59.433]         if (TRUE) {
[10:26:59.433]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:59.433]                 open = "w")
[10:26:59.433]         }
[10:26:59.433]         else {
[10:26:59.433]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:59.433]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:59.433]         }
[10:26:59.433]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:59.433]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:59.433]             base::sink(type = "output", split = FALSE)
[10:26:59.433]             base::close(...future.stdout)
[10:26:59.433]         }, add = TRUE)
[10:26:59.433]     }
[10:26:59.433]     ...future.frame <- base::sys.nframe()
[10:26:59.433]     ...future.conditions <- base::list()
[10:26:59.433]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:59.433]     if (FALSE) {
[10:26:59.433]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:59.433]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:59.433]     }
[10:26:59.433]     ...future.result <- base::tryCatch({
[10:26:59.433]         base::withCallingHandlers({
[10:26:59.433]             ...future.value <- base::withVisible(base::local(1))
[10:26:59.433]             future::FutureResult(value = ...future.value$value, 
[10:26:59.433]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:59.433]                   ...future.rng), globalenv = if (FALSE) 
[10:26:59.433]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:59.433]                     ...future.globalenv.names))
[10:26:59.433]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:59.433]         }, condition = base::local({
[10:26:59.433]             c <- base::c
[10:26:59.433]             inherits <- base::inherits
[10:26:59.433]             invokeRestart <- base::invokeRestart
[10:26:59.433]             length <- base::length
[10:26:59.433]             list <- base::list
[10:26:59.433]             seq.int <- base::seq.int
[10:26:59.433]             signalCondition <- base::signalCondition
[10:26:59.433]             sys.calls <- base::sys.calls
[10:26:59.433]             `[[` <- base::`[[`
[10:26:59.433]             `+` <- base::`+`
[10:26:59.433]             `<<-` <- base::`<<-`
[10:26:59.433]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:59.433]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:59.433]                   3L)]
[10:26:59.433]             }
[10:26:59.433]             function(cond) {
[10:26:59.433]                 is_error <- inherits(cond, "error")
[10:26:59.433]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:59.433]                   NULL)
[10:26:59.433]                 if (is_error) {
[10:26:59.433]                   sessionInformation <- function() {
[10:26:59.433]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:59.433]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:59.433]                       search = base::search(), system = base::Sys.info())
[10:26:59.433]                   }
[10:26:59.433]                   ...future.conditions[[length(...future.conditions) + 
[10:26:59.433]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:59.433]                     cond$call), session = sessionInformation(), 
[10:26:59.433]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:59.433]                   signalCondition(cond)
[10:26:59.433]                 }
[10:26:59.433]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:59.433]                 "immediateCondition"))) {
[10:26:59.433]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:59.433]                   ...future.conditions[[length(...future.conditions) + 
[10:26:59.433]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:59.433]                   if (TRUE && !signal) {
[10:26:59.433]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:59.433]                     {
[10:26:59.433]                       inherits <- base::inherits
[10:26:59.433]                       invokeRestart <- base::invokeRestart
[10:26:59.433]                       is.null <- base::is.null
[10:26:59.433]                       muffled <- FALSE
[10:26:59.433]                       if (inherits(cond, "message")) {
[10:26:59.433]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:59.433]                         if (muffled) 
[10:26:59.433]                           invokeRestart("muffleMessage")
[10:26:59.433]                       }
[10:26:59.433]                       else if (inherits(cond, "warning")) {
[10:26:59.433]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:59.433]                         if (muffled) 
[10:26:59.433]                           invokeRestart("muffleWarning")
[10:26:59.433]                       }
[10:26:59.433]                       else if (inherits(cond, "condition")) {
[10:26:59.433]                         if (!is.null(pattern)) {
[10:26:59.433]                           computeRestarts <- base::computeRestarts
[10:26:59.433]                           grepl <- base::grepl
[10:26:59.433]                           restarts <- computeRestarts(cond)
[10:26:59.433]                           for (restart in restarts) {
[10:26:59.433]                             name <- restart$name
[10:26:59.433]                             if (is.null(name)) 
[10:26:59.433]                               next
[10:26:59.433]                             if (!grepl(pattern, name)) 
[10:26:59.433]                               next
[10:26:59.433]                             invokeRestart(restart)
[10:26:59.433]                             muffled <- TRUE
[10:26:59.433]                             break
[10:26:59.433]                           }
[10:26:59.433]                         }
[10:26:59.433]                       }
[10:26:59.433]                       invisible(muffled)
[10:26:59.433]                     }
[10:26:59.433]                     muffleCondition(cond, pattern = "^muffle")
[10:26:59.433]                   }
[10:26:59.433]                 }
[10:26:59.433]                 else {
[10:26:59.433]                   if (TRUE) {
[10:26:59.433]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:59.433]                     {
[10:26:59.433]                       inherits <- base::inherits
[10:26:59.433]                       invokeRestart <- base::invokeRestart
[10:26:59.433]                       is.null <- base::is.null
[10:26:59.433]                       muffled <- FALSE
[10:26:59.433]                       if (inherits(cond, "message")) {
[10:26:59.433]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:59.433]                         if (muffled) 
[10:26:59.433]                           invokeRestart("muffleMessage")
[10:26:59.433]                       }
[10:26:59.433]                       else if (inherits(cond, "warning")) {
[10:26:59.433]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:59.433]                         if (muffled) 
[10:26:59.433]                           invokeRestart("muffleWarning")
[10:26:59.433]                       }
[10:26:59.433]                       else if (inherits(cond, "condition")) {
[10:26:59.433]                         if (!is.null(pattern)) {
[10:26:59.433]                           computeRestarts <- base::computeRestarts
[10:26:59.433]                           grepl <- base::grepl
[10:26:59.433]                           restarts <- computeRestarts(cond)
[10:26:59.433]                           for (restart in restarts) {
[10:26:59.433]                             name <- restart$name
[10:26:59.433]                             if (is.null(name)) 
[10:26:59.433]                               next
[10:26:59.433]                             if (!grepl(pattern, name)) 
[10:26:59.433]                               next
[10:26:59.433]                             invokeRestart(restart)
[10:26:59.433]                             muffled <- TRUE
[10:26:59.433]                             break
[10:26:59.433]                           }
[10:26:59.433]                         }
[10:26:59.433]                       }
[10:26:59.433]                       invisible(muffled)
[10:26:59.433]                     }
[10:26:59.433]                     muffleCondition(cond, pattern = "^muffle")
[10:26:59.433]                   }
[10:26:59.433]                 }
[10:26:59.433]             }
[10:26:59.433]         }))
[10:26:59.433]     }, error = function(ex) {
[10:26:59.433]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:59.433]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:59.433]                 ...future.rng), started = ...future.startTime, 
[10:26:59.433]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:59.433]             version = "1.8"), class = "FutureResult")
[10:26:59.433]     }, finally = {
[10:26:59.433]         if (!identical(...future.workdir, getwd())) 
[10:26:59.433]             setwd(...future.workdir)
[10:26:59.433]         {
[10:26:59.433]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:59.433]                 ...future.oldOptions$nwarnings <- NULL
[10:26:59.433]             }
[10:26:59.433]             base::options(...future.oldOptions)
[10:26:59.433]             if (.Platform$OS.type == "windows") {
[10:26:59.433]                 old_names <- names(...future.oldEnvVars)
[10:26:59.433]                 envs <- base::Sys.getenv()
[10:26:59.433]                 names <- names(envs)
[10:26:59.433]                 common <- intersect(names, old_names)
[10:26:59.433]                 added <- setdiff(names, old_names)
[10:26:59.433]                 removed <- setdiff(old_names, names)
[10:26:59.433]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:59.433]                   envs[common]]
[10:26:59.433]                 NAMES <- toupper(changed)
[10:26:59.433]                 args <- list()
[10:26:59.433]                 for (kk in seq_along(NAMES)) {
[10:26:59.433]                   name <- changed[[kk]]
[10:26:59.433]                   NAME <- NAMES[[kk]]
[10:26:59.433]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:59.433]                     next
[10:26:59.433]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:59.433]                 }
[10:26:59.433]                 NAMES <- toupper(added)
[10:26:59.433]                 for (kk in seq_along(NAMES)) {
[10:26:59.433]                   name <- added[[kk]]
[10:26:59.433]                   NAME <- NAMES[[kk]]
[10:26:59.433]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:59.433]                     next
[10:26:59.433]                   args[[name]] <- ""
[10:26:59.433]                 }
[10:26:59.433]                 NAMES <- toupper(removed)
[10:26:59.433]                 for (kk in seq_along(NAMES)) {
[10:26:59.433]                   name <- removed[[kk]]
[10:26:59.433]                   NAME <- NAMES[[kk]]
[10:26:59.433]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:59.433]                     next
[10:26:59.433]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:59.433]                 }
[10:26:59.433]                 if (length(args) > 0) 
[10:26:59.433]                   base::do.call(base::Sys.setenv, args = args)
[10:26:59.433]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:59.433]             }
[10:26:59.433]             else {
[10:26:59.433]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:59.433]             }
[10:26:59.433]             {
[10:26:59.433]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:59.433]                   0L) {
[10:26:59.433]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:59.433]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:59.433]                   base::options(opts)
[10:26:59.433]                 }
[10:26:59.433]                 {
[10:26:59.433]                   {
[10:26:59.433]                     NULL
[10:26:59.433]                     RNGkind("Mersenne-Twister")
[10:26:59.433]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:59.433]                       inherits = FALSE)
[10:26:59.433]                   }
[10:26:59.433]                   options(future.plan = NULL)
[10:26:59.433]                   if (is.na(NA_character_)) 
[10:26:59.433]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:59.433]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:59.433]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:59.433]                   {
[10:26:59.433]                     future <- SequentialFuture(..., envir = envir)
[10:26:59.433]                     if (!future$lazy) 
[10:26:59.433]                       future <- run(future)
[10:26:59.433]                     invisible(future)
[10:26:59.433]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:59.433]                 }
[10:26:59.433]             }
[10:26:59.433]         }
[10:26:59.433]     })
[10:26:59.433]     if (TRUE) {
[10:26:59.433]         base::sink(type = "output", split = FALSE)
[10:26:59.433]         if (TRUE) {
[10:26:59.433]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:59.433]         }
[10:26:59.433]         else {
[10:26:59.433]             ...future.result["stdout"] <- base::list(NULL)
[10:26:59.433]         }
[10:26:59.433]         base::close(...future.stdout)
[10:26:59.433]         ...future.stdout <- NULL
[10:26:59.433]     }
[10:26:59.433]     ...future.result$conditions <- ...future.conditions
[10:26:59.433]     ...future.result$finished <- base::Sys.time()
[10:26:59.433]     ...future.result
[10:26:59.433] }
[10:26:59.435] plan(): Setting new future strategy stack:
[10:26:59.435] List of future strategies:
[10:26:59.435] 1. sequential:
[10:26:59.435]    - args: function (..., envir = parent.frame())
[10:26:59.435]    - tweaked: FALSE
[10:26:59.435]    - call: NULL
[10:26:59.435] plan(): nbrOfWorkers() = 1
[10:26:59.436] plan(): Setting new future strategy stack:
[10:26:59.436] List of future strategies:
[10:26:59.436] 1. sequential:
[10:26:59.436]    - args: function (..., envir = parent.frame())
[10:26:59.436]    - tweaked: FALSE
[10:26:59.436]    - call: plan(strategy)
[10:26:59.437] plan(): nbrOfWorkers() = 1
[10:26:59.437] SequentialFuture started (and completed)
[10:26:59.437] - Launch lazy future ... done
[10:26:59.437] run() for ‘SequentialFuture’ ... done
[10:26:59.437] resolved() for ‘SequentialFuture’ ...
[10:26:59.437] - state: ‘finished’
[10:26:59.437] - run: TRUE
[10:26:59.437] - result: ‘FutureResult’
[10:26:59.438] resolved() for ‘SequentialFuture’ ... done
[10:26:59.438] Future #1
[10:26:59.438]  length: 2 (resolved future 1)
[10:26:59.438] run() for ‘Future’ ...
[10:26:59.438] - state: ‘created’
[10:26:59.438] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:59.438] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:59.438] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:59.439]   - Field: ‘label’
[10:26:59.439]   - Field: ‘local’
[10:26:59.439]   - Field: ‘owner’
[10:26:59.439]   - Field: ‘envir’
[10:26:59.439]   - Field: ‘packages’
[10:26:59.439]   - Field: ‘gc’
[10:26:59.439]   - Field: ‘conditions’
[10:26:59.439]   - Field: ‘expr’
[10:26:59.439]   - Field: ‘uuid’
[10:26:59.439]   - Field: ‘seed’
[10:26:59.440]   - Field: ‘version’
[10:26:59.440]   - Field: ‘result’
[10:26:59.440]   - Field: ‘asynchronous’
[10:26:59.440]   - Field: ‘calls’
[10:26:59.440]   - Field: ‘globals’
[10:26:59.440]   - Field: ‘stdout’
[10:26:59.440]   - Field: ‘earlySignal’
[10:26:59.440]   - Field: ‘lazy’
[10:26:59.440]   - Field: ‘state’
[10:26:59.440] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:59.440] - Launch lazy future ...
[10:26:59.441] Packages needed by the future expression (n = 0): <none>
[10:26:59.441] Packages needed by future strategies (n = 0): <none>
[10:26:59.443] {
[10:26:59.443]     {
[10:26:59.443]         {
[10:26:59.443]             ...future.startTime <- base::Sys.time()
[10:26:59.443]             {
[10:26:59.443]                 {
[10:26:59.443]                   {
[10:26:59.443]                     base::local({
[10:26:59.443]                       has_future <- base::requireNamespace("future", 
[10:26:59.443]                         quietly = TRUE)
[10:26:59.443]                       if (has_future) {
[10:26:59.443]                         ns <- base::getNamespace("future")
[10:26:59.443]                         version <- ns[[".package"]][["version"]]
[10:26:59.443]                         if (is.null(version)) 
[10:26:59.443]                           version <- utils::packageVersion("future")
[10:26:59.443]                       }
[10:26:59.443]                       else {
[10:26:59.443]                         version <- NULL
[10:26:59.443]                       }
[10:26:59.443]                       if (!has_future || version < "1.8.0") {
[10:26:59.443]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:59.443]                           "", base::R.version$version.string), 
[10:26:59.443]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:59.443]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:59.443]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:59.443]                             "release", "version")], collapse = " "), 
[10:26:59.443]                           hostname = base::Sys.info()[["nodename"]])
[10:26:59.443]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:59.443]                           info)
[10:26:59.443]                         info <- base::paste(info, collapse = "; ")
[10:26:59.443]                         if (!has_future) {
[10:26:59.443]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:59.443]                             info)
[10:26:59.443]                         }
[10:26:59.443]                         else {
[10:26:59.443]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:59.443]                             info, version)
[10:26:59.443]                         }
[10:26:59.443]                         base::stop(msg)
[10:26:59.443]                       }
[10:26:59.443]                     })
[10:26:59.443]                   }
[10:26:59.443]                   options(future.plan = NULL)
[10:26:59.443]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:59.443]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:59.443]                 }
[10:26:59.443]                 ...future.workdir <- getwd()
[10:26:59.443]             }
[10:26:59.443]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:59.443]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:59.443]         }
[10:26:59.443]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:59.443]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:59.443]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:59.443]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:59.443]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:59.443]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:59.443]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:59.443]             base::names(...future.oldOptions))
[10:26:59.443]     }
[10:26:59.443]     if (FALSE) {
[10:26:59.443]     }
[10:26:59.443]     else {
[10:26:59.443]         if (TRUE) {
[10:26:59.443]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:59.443]                 open = "w")
[10:26:59.443]         }
[10:26:59.443]         else {
[10:26:59.443]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:59.443]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:59.443]         }
[10:26:59.443]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:59.443]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:59.443]             base::sink(type = "output", split = FALSE)
[10:26:59.443]             base::close(...future.stdout)
[10:26:59.443]         }, add = TRUE)
[10:26:59.443]     }
[10:26:59.443]     ...future.frame <- base::sys.nframe()
[10:26:59.443]     ...future.conditions <- base::list()
[10:26:59.443]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:59.443]     if (FALSE) {
[10:26:59.443]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:59.443]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:59.443]     }
[10:26:59.443]     ...future.result <- base::tryCatch({
[10:26:59.443]         base::withCallingHandlers({
[10:26:59.443]             ...future.value <- base::withVisible(base::local(2))
[10:26:59.443]             future::FutureResult(value = ...future.value$value, 
[10:26:59.443]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:59.443]                   ...future.rng), globalenv = if (FALSE) 
[10:26:59.443]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:59.443]                     ...future.globalenv.names))
[10:26:59.443]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:59.443]         }, condition = base::local({
[10:26:59.443]             c <- base::c
[10:26:59.443]             inherits <- base::inherits
[10:26:59.443]             invokeRestart <- base::invokeRestart
[10:26:59.443]             length <- base::length
[10:26:59.443]             list <- base::list
[10:26:59.443]             seq.int <- base::seq.int
[10:26:59.443]             signalCondition <- base::signalCondition
[10:26:59.443]             sys.calls <- base::sys.calls
[10:26:59.443]             `[[` <- base::`[[`
[10:26:59.443]             `+` <- base::`+`
[10:26:59.443]             `<<-` <- base::`<<-`
[10:26:59.443]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:59.443]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:59.443]                   3L)]
[10:26:59.443]             }
[10:26:59.443]             function(cond) {
[10:26:59.443]                 is_error <- inherits(cond, "error")
[10:26:59.443]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:59.443]                   NULL)
[10:26:59.443]                 if (is_error) {
[10:26:59.443]                   sessionInformation <- function() {
[10:26:59.443]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:59.443]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:59.443]                       search = base::search(), system = base::Sys.info())
[10:26:59.443]                   }
[10:26:59.443]                   ...future.conditions[[length(...future.conditions) + 
[10:26:59.443]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:59.443]                     cond$call), session = sessionInformation(), 
[10:26:59.443]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:59.443]                   signalCondition(cond)
[10:26:59.443]                 }
[10:26:59.443]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:59.443]                 "immediateCondition"))) {
[10:26:59.443]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:59.443]                   ...future.conditions[[length(...future.conditions) + 
[10:26:59.443]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:59.443]                   if (TRUE && !signal) {
[10:26:59.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:59.443]                     {
[10:26:59.443]                       inherits <- base::inherits
[10:26:59.443]                       invokeRestart <- base::invokeRestart
[10:26:59.443]                       is.null <- base::is.null
[10:26:59.443]                       muffled <- FALSE
[10:26:59.443]                       if (inherits(cond, "message")) {
[10:26:59.443]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:59.443]                         if (muffled) 
[10:26:59.443]                           invokeRestart("muffleMessage")
[10:26:59.443]                       }
[10:26:59.443]                       else if (inherits(cond, "warning")) {
[10:26:59.443]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:59.443]                         if (muffled) 
[10:26:59.443]                           invokeRestart("muffleWarning")
[10:26:59.443]                       }
[10:26:59.443]                       else if (inherits(cond, "condition")) {
[10:26:59.443]                         if (!is.null(pattern)) {
[10:26:59.443]                           computeRestarts <- base::computeRestarts
[10:26:59.443]                           grepl <- base::grepl
[10:26:59.443]                           restarts <- computeRestarts(cond)
[10:26:59.443]                           for (restart in restarts) {
[10:26:59.443]                             name <- restart$name
[10:26:59.443]                             if (is.null(name)) 
[10:26:59.443]                               next
[10:26:59.443]                             if (!grepl(pattern, name)) 
[10:26:59.443]                               next
[10:26:59.443]                             invokeRestart(restart)
[10:26:59.443]                             muffled <- TRUE
[10:26:59.443]                             break
[10:26:59.443]                           }
[10:26:59.443]                         }
[10:26:59.443]                       }
[10:26:59.443]                       invisible(muffled)
[10:26:59.443]                     }
[10:26:59.443]                     muffleCondition(cond, pattern = "^muffle")
[10:26:59.443]                   }
[10:26:59.443]                 }
[10:26:59.443]                 else {
[10:26:59.443]                   if (TRUE) {
[10:26:59.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:59.443]                     {
[10:26:59.443]                       inherits <- base::inherits
[10:26:59.443]                       invokeRestart <- base::invokeRestart
[10:26:59.443]                       is.null <- base::is.null
[10:26:59.443]                       muffled <- FALSE
[10:26:59.443]                       if (inherits(cond, "message")) {
[10:26:59.443]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:59.443]                         if (muffled) 
[10:26:59.443]                           invokeRestart("muffleMessage")
[10:26:59.443]                       }
[10:26:59.443]                       else if (inherits(cond, "warning")) {
[10:26:59.443]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:59.443]                         if (muffled) 
[10:26:59.443]                           invokeRestart("muffleWarning")
[10:26:59.443]                       }
[10:26:59.443]                       else if (inherits(cond, "condition")) {
[10:26:59.443]                         if (!is.null(pattern)) {
[10:26:59.443]                           computeRestarts <- base::computeRestarts
[10:26:59.443]                           grepl <- base::grepl
[10:26:59.443]                           restarts <- computeRestarts(cond)
[10:26:59.443]                           for (restart in restarts) {
[10:26:59.443]                             name <- restart$name
[10:26:59.443]                             if (is.null(name)) 
[10:26:59.443]                               next
[10:26:59.443]                             if (!grepl(pattern, name)) 
[10:26:59.443]                               next
[10:26:59.443]                             invokeRestart(restart)
[10:26:59.443]                             muffled <- TRUE
[10:26:59.443]                             break
[10:26:59.443]                           }
[10:26:59.443]                         }
[10:26:59.443]                       }
[10:26:59.443]                       invisible(muffled)
[10:26:59.443]                     }
[10:26:59.443]                     muffleCondition(cond, pattern = "^muffle")
[10:26:59.443]                   }
[10:26:59.443]                 }
[10:26:59.443]             }
[10:26:59.443]         }))
[10:26:59.443]     }, error = function(ex) {
[10:26:59.443]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:59.443]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:59.443]                 ...future.rng), started = ...future.startTime, 
[10:26:59.443]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:59.443]             version = "1.8"), class = "FutureResult")
[10:26:59.443]     }, finally = {
[10:26:59.443]         if (!identical(...future.workdir, getwd())) 
[10:26:59.443]             setwd(...future.workdir)
[10:26:59.443]         {
[10:26:59.443]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:59.443]                 ...future.oldOptions$nwarnings <- NULL
[10:26:59.443]             }
[10:26:59.443]             base::options(...future.oldOptions)
[10:26:59.443]             if (.Platform$OS.type == "windows") {
[10:26:59.443]                 old_names <- names(...future.oldEnvVars)
[10:26:59.443]                 envs <- base::Sys.getenv()
[10:26:59.443]                 names <- names(envs)
[10:26:59.443]                 common <- intersect(names, old_names)
[10:26:59.443]                 added <- setdiff(names, old_names)
[10:26:59.443]                 removed <- setdiff(old_names, names)
[10:26:59.443]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:59.443]                   envs[common]]
[10:26:59.443]                 NAMES <- toupper(changed)
[10:26:59.443]                 args <- list()
[10:26:59.443]                 for (kk in seq_along(NAMES)) {
[10:26:59.443]                   name <- changed[[kk]]
[10:26:59.443]                   NAME <- NAMES[[kk]]
[10:26:59.443]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:59.443]                     next
[10:26:59.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:59.443]                 }
[10:26:59.443]                 NAMES <- toupper(added)
[10:26:59.443]                 for (kk in seq_along(NAMES)) {
[10:26:59.443]                   name <- added[[kk]]
[10:26:59.443]                   NAME <- NAMES[[kk]]
[10:26:59.443]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:59.443]                     next
[10:26:59.443]                   args[[name]] <- ""
[10:26:59.443]                 }
[10:26:59.443]                 NAMES <- toupper(removed)
[10:26:59.443]                 for (kk in seq_along(NAMES)) {
[10:26:59.443]                   name <- removed[[kk]]
[10:26:59.443]                   NAME <- NAMES[[kk]]
[10:26:59.443]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:59.443]                     next
[10:26:59.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:59.443]                 }
[10:26:59.443]                 if (length(args) > 0) 
[10:26:59.443]                   base::do.call(base::Sys.setenv, args = args)
[10:26:59.443]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:59.443]             }
[10:26:59.443]             else {
[10:26:59.443]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:59.443]             }
[10:26:59.443]             {
[10:26:59.443]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:59.443]                   0L) {
[10:26:59.443]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:59.443]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:59.443]                   base::options(opts)
[10:26:59.443]                 }
[10:26:59.443]                 {
[10:26:59.443]                   {
[10:26:59.443]                     NULL
[10:26:59.443]                     RNGkind("Mersenne-Twister")
[10:26:59.443]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:59.443]                       inherits = FALSE)
[10:26:59.443]                   }
[10:26:59.443]                   options(future.plan = NULL)
[10:26:59.443]                   if (is.na(NA_character_)) 
[10:26:59.443]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:59.443]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:59.443]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:59.443]                   {
[10:26:59.443]                     future <- SequentialFuture(..., envir = envir)
[10:26:59.443]                     if (!future$lazy) 
[10:26:59.443]                       future <- run(future)
[10:26:59.443]                     invisible(future)
[10:26:59.443]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:59.443]                 }
[10:26:59.443]             }
[10:26:59.443]         }
[10:26:59.443]     })
[10:26:59.443]     if (TRUE) {
[10:26:59.443]         base::sink(type = "output", split = FALSE)
[10:26:59.443]         if (TRUE) {
[10:26:59.443]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:59.443]         }
[10:26:59.443]         else {
[10:26:59.443]             ...future.result["stdout"] <- base::list(NULL)
[10:26:59.443]         }
[10:26:59.443]         base::close(...future.stdout)
[10:26:59.443]         ...future.stdout <- NULL
[10:26:59.443]     }
[10:26:59.443]     ...future.result$conditions <- ...future.conditions
[10:26:59.443]     ...future.result$finished <- base::Sys.time()
[10:26:59.443]     ...future.result
[10:26:59.443] }
[10:26:59.445] plan(): Setting new future strategy stack:
[10:26:59.445] List of future strategies:
[10:26:59.445] 1. sequential:
[10:26:59.445]    - args: function (..., envir = parent.frame())
[10:26:59.445]    - tweaked: FALSE
[10:26:59.445]    - call: NULL
[10:26:59.446] plan(): nbrOfWorkers() = 1
[10:26:59.447] plan(): Setting new future strategy stack:
[10:26:59.447] List of future strategies:
[10:26:59.447] 1. sequential:
[10:26:59.447]    - args: function (..., envir = parent.frame())
[10:26:59.447]    - tweaked: FALSE
[10:26:59.447]    - call: plan(strategy)
[10:26:59.447] plan(): nbrOfWorkers() = 1
[10:26:59.447] SequentialFuture started (and completed)
[10:26:59.447] - Launch lazy future ... done
[10:26:59.447] run() for ‘SequentialFuture’ ... done
[10:26:59.448] resolved() for ‘SequentialFuture’ ...
[10:26:59.448] - state: ‘finished’
[10:26:59.448] - run: TRUE
[10:26:59.448] - result: ‘FutureResult’
[10:26:59.448] resolved() for ‘SequentialFuture’ ... done
[10:26:59.448] Future #2
[10:26:59.448]  length: 1 (resolved future 2)
[10:26:59.448]  length: 0 (resolved future 3)
[10:26:59.448] resolve() on list ... DONE
[10:26:59.448] resolved() for ‘SequentialFuture’ ...
[10:26:59.449] - state: ‘finished’
[10:26:59.449] - run: TRUE
[10:26:59.449] - result: ‘FutureResult’
[10:26:59.449] resolved() for ‘SequentialFuture’ ... done
[10:26:59.449] resolved() for ‘SequentialFuture’ ...
[10:26:59.449] - state: ‘finished’
[10:26:59.449] - run: TRUE
[10:26:59.449] - result: ‘FutureResult’
[10:26:59.449] resolved() for ‘SequentialFuture’ ... done
[10:26:59.450] getGlobalsAndPackages() ...
[10:26:59.450] Searching for globals...
[10:26:59.450] 
[10:26:59.450] Searching for globals ... DONE
[10:26:59.450] - globals: [0] <none>
[10:26:59.450] getGlobalsAndPackages() ... DONE
[10:26:59.450] run() for ‘Future’ ...
[10:26:59.451] - state: ‘created’
[10:26:59.451] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:59.451] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:59.451] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:59.451]   - Field: ‘label’
[10:26:59.451]   - Field: ‘local’
[10:26:59.451]   - Field: ‘owner’
[10:26:59.452]   - Field: ‘envir’
[10:26:59.452]   - Field: ‘packages’
[10:26:59.452]   - Field: ‘gc’
[10:26:59.452]   - Field: ‘conditions’
[10:26:59.452]   - Field: ‘expr’
[10:26:59.452]   - Field: ‘uuid’
[10:26:59.452]   - Field: ‘seed’
[10:26:59.452]   - Field: ‘version’
[10:26:59.452]   - Field: ‘result’
[10:26:59.452]   - Field: ‘asynchronous’
[10:26:59.453]   - Field: ‘calls’
[10:26:59.453]   - Field: ‘globals’
[10:26:59.453]   - Field: ‘stdout’
[10:26:59.453]   - Field: ‘earlySignal’
[10:26:59.453]   - Field: ‘lazy’
[10:26:59.453]   - Field: ‘state’
[10:26:59.453] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:59.453] - Launch lazy future ...
[10:26:59.453] Packages needed by the future expression (n = 0): <none>
[10:26:59.454] Packages needed by future strategies (n = 0): <none>
[10:26:59.454] {
[10:26:59.454]     {
[10:26:59.454]         {
[10:26:59.454]             ...future.startTime <- base::Sys.time()
[10:26:59.454]             {
[10:26:59.454]                 {
[10:26:59.454]                   {
[10:26:59.454]                     base::local({
[10:26:59.454]                       has_future <- base::requireNamespace("future", 
[10:26:59.454]                         quietly = TRUE)
[10:26:59.454]                       if (has_future) {
[10:26:59.454]                         ns <- base::getNamespace("future")
[10:26:59.454]                         version <- ns[[".package"]][["version"]]
[10:26:59.454]                         if (is.null(version)) 
[10:26:59.454]                           version <- utils::packageVersion("future")
[10:26:59.454]                       }
[10:26:59.454]                       else {
[10:26:59.454]                         version <- NULL
[10:26:59.454]                       }
[10:26:59.454]                       if (!has_future || version < "1.8.0") {
[10:26:59.454]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:59.454]                           "", base::R.version$version.string), 
[10:26:59.454]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:59.454]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:59.454]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:59.454]                             "release", "version")], collapse = " "), 
[10:26:59.454]                           hostname = base::Sys.info()[["nodename"]])
[10:26:59.454]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:59.454]                           info)
[10:26:59.454]                         info <- base::paste(info, collapse = "; ")
[10:26:59.454]                         if (!has_future) {
[10:26:59.454]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:59.454]                             info)
[10:26:59.454]                         }
[10:26:59.454]                         else {
[10:26:59.454]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:59.454]                             info, version)
[10:26:59.454]                         }
[10:26:59.454]                         base::stop(msg)
[10:26:59.454]                       }
[10:26:59.454]                     })
[10:26:59.454]                   }
[10:26:59.454]                   options(future.plan = NULL)
[10:26:59.454]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:59.454]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:59.454]                 }
[10:26:59.454]                 ...future.workdir <- getwd()
[10:26:59.454]             }
[10:26:59.454]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:59.454]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:59.454]         }
[10:26:59.454]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:59.454]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:59.454]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:59.454]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:59.454]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:59.454]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:59.454]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:59.454]             base::names(...future.oldOptions))
[10:26:59.454]     }
[10:26:59.454]     if (FALSE) {
[10:26:59.454]     }
[10:26:59.454]     else {
[10:26:59.454]         if (TRUE) {
[10:26:59.454]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:59.454]                 open = "w")
[10:26:59.454]         }
[10:26:59.454]         else {
[10:26:59.454]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:59.454]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:59.454]         }
[10:26:59.454]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:59.454]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:59.454]             base::sink(type = "output", split = FALSE)
[10:26:59.454]             base::close(...future.stdout)
[10:26:59.454]         }, add = TRUE)
[10:26:59.454]     }
[10:26:59.454]     ...future.frame <- base::sys.nframe()
[10:26:59.454]     ...future.conditions <- base::list()
[10:26:59.454]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:59.454]     if (FALSE) {
[10:26:59.454]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:59.454]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:59.454]     }
[10:26:59.454]     ...future.result <- base::tryCatch({
[10:26:59.454]         base::withCallingHandlers({
[10:26:59.454]             ...future.value <- base::withVisible(base::local(1))
[10:26:59.454]             future::FutureResult(value = ...future.value$value, 
[10:26:59.454]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:59.454]                   ...future.rng), globalenv = if (FALSE) 
[10:26:59.454]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:59.454]                     ...future.globalenv.names))
[10:26:59.454]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:59.454]         }, condition = base::local({
[10:26:59.454]             c <- base::c
[10:26:59.454]             inherits <- base::inherits
[10:26:59.454]             invokeRestart <- base::invokeRestart
[10:26:59.454]             length <- base::length
[10:26:59.454]             list <- base::list
[10:26:59.454]             seq.int <- base::seq.int
[10:26:59.454]             signalCondition <- base::signalCondition
[10:26:59.454]             sys.calls <- base::sys.calls
[10:26:59.454]             `[[` <- base::`[[`
[10:26:59.454]             `+` <- base::`+`
[10:26:59.454]             `<<-` <- base::`<<-`
[10:26:59.454]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:59.454]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:59.454]                   3L)]
[10:26:59.454]             }
[10:26:59.454]             function(cond) {
[10:26:59.454]                 is_error <- inherits(cond, "error")
[10:26:59.454]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:59.454]                   NULL)
[10:26:59.454]                 if (is_error) {
[10:26:59.454]                   sessionInformation <- function() {
[10:26:59.454]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:59.454]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:59.454]                       search = base::search(), system = base::Sys.info())
[10:26:59.454]                   }
[10:26:59.454]                   ...future.conditions[[length(...future.conditions) + 
[10:26:59.454]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:59.454]                     cond$call), session = sessionInformation(), 
[10:26:59.454]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:59.454]                   signalCondition(cond)
[10:26:59.454]                 }
[10:26:59.454]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:59.454]                 "immediateCondition"))) {
[10:26:59.454]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:59.454]                   ...future.conditions[[length(...future.conditions) + 
[10:26:59.454]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:59.454]                   if (TRUE && !signal) {
[10:26:59.454]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:59.454]                     {
[10:26:59.454]                       inherits <- base::inherits
[10:26:59.454]                       invokeRestart <- base::invokeRestart
[10:26:59.454]                       is.null <- base::is.null
[10:26:59.454]                       muffled <- FALSE
[10:26:59.454]                       if (inherits(cond, "message")) {
[10:26:59.454]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:59.454]                         if (muffled) 
[10:26:59.454]                           invokeRestart("muffleMessage")
[10:26:59.454]                       }
[10:26:59.454]                       else if (inherits(cond, "warning")) {
[10:26:59.454]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:59.454]                         if (muffled) 
[10:26:59.454]                           invokeRestart("muffleWarning")
[10:26:59.454]                       }
[10:26:59.454]                       else if (inherits(cond, "condition")) {
[10:26:59.454]                         if (!is.null(pattern)) {
[10:26:59.454]                           computeRestarts <- base::computeRestarts
[10:26:59.454]                           grepl <- base::grepl
[10:26:59.454]                           restarts <- computeRestarts(cond)
[10:26:59.454]                           for (restart in restarts) {
[10:26:59.454]                             name <- restart$name
[10:26:59.454]                             if (is.null(name)) 
[10:26:59.454]                               next
[10:26:59.454]                             if (!grepl(pattern, name)) 
[10:26:59.454]                               next
[10:26:59.454]                             invokeRestart(restart)
[10:26:59.454]                             muffled <- TRUE
[10:26:59.454]                             break
[10:26:59.454]                           }
[10:26:59.454]                         }
[10:26:59.454]                       }
[10:26:59.454]                       invisible(muffled)
[10:26:59.454]                     }
[10:26:59.454]                     muffleCondition(cond, pattern = "^muffle")
[10:26:59.454]                   }
[10:26:59.454]                 }
[10:26:59.454]                 else {
[10:26:59.454]                   if (TRUE) {
[10:26:59.454]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:59.454]                     {
[10:26:59.454]                       inherits <- base::inherits
[10:26:59.454]                       invokeRestart <- base::invokeRestart
[10:26:59.454]                       is.null <- base::is.null
[10:26:59.454]                       muffled <- FALSE
[10:26:59.454]                       if (inherits(cond, "message")) {
[10:26:59.454]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:59.454]                         if (muffled) 
[10:26:59.454]                           invokeRestart("muffleMessage")
[10:26:59.454]                       }
[10:26:59.454]                       else if (inherits(cond, "warning")) {
[10:26:59.454]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:59.454]                         if (muffled) 
[10:26:59.454]                           invokeRestart("muffleWarning")
[10:26:59.454]                       }
[10:26:59.454]                       else if (inherits(cond, "condition")) {
[10:26:59.454]                         if (!is.null(pattern)) {
[10:26:59.454]                           computeRestarts <- base::computeRestarts
[10:26:59.454]                           grepl <- base::grepl
[10:26:59.454]                           restarts <- computeRestarts(cond)
[10:26:59.454]                           for (restart in restarts) {
[10:26:59.454]                             name <- restart$name
[10:26:59.454]                             if (is.null(name)) 
[10:26:59.454]                               next
[10:26:59.454]                             if (!grepl(pattern, name)) 
[10:26:59.454]                               next
[10:26:59.454]                             invokeRestart(restart)
[10:26:59.454]                             muffled <- TRUE
[10:26:59.454]                             break
[10:26:59.454]                           }
[10:26:59.454]                         }
[10:26:59.454]                       }
[10:26:59.454]                       invisible(muffled)
[10:26:59.454]                     }
[10:26:59.454]                     muffleCondition(cond, pattern = "^muffle")
[10:26:59.454]                   }
[10:26:59.454]                 }
[10:26:59.454]             }
[10:26:59.454]         }))
[10:26:59.454]     }, error = function(ex) {
[10:26:59.454]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:59.454]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:59.454]                 ...future.rng), started = ...future.startTime, 
[10:26:59.454]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:59.454]             version = "1.8"), class = "FutureResult")
[10:26:59.454]     }, finally = {
[10:26:59.454]         if (!identical(...future.workdir, getwd())) 
[10:26:59.454]             setwd(...future.workdir)
[10:26:59.454]         {
[10:26:59.454]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:59.454]                 ...future.oldOptions$nwarnings <- NULL
[10:26:59.454]             }
[10:26:59.454]             base::options(...future.oldOptions)
[10:26:59.454]             if (.Platform$OS.type == "windows") {
[10:26:59.454]                 old_names <- names(...future.oldEnvVars)
[10:26:59.454]                 envs <- base::Sys.getenv()
[10:26:59.454]                 names <- names(envs)
[10:26:59.454]                 common <- intersect(names, old_names)
[10:26:59.454]                 added <- setdiff(names, old_names)
[10:26:59.454]                 removed <- setdiff(old_names, names)
[10:26:59.454]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:59.454]                   envs[common]]
[10:26:59.454]                 NAMES <- toupper(changed)
[10:26:59.454]                 args <- list()
[10:26:59.454]                 for (kk in seq_along(NAMES)) {
[10:26:59.454]                   name <- changed[[kk]]
[10:26:59.454]                   NAME <- NAMES[[kk]]
[10:26:59.454]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:59.454]                     next
[10:26:59.454]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:59.454]                 }
[10:26:59.454]                 NAMES <- toupper(added)
[10:26:59.454]                 for (kk in seq_along(NAMES)) {
[10:26:59.454]                   name <- added[[kk]]
[10:26:59.454]                   NAME <- NAMES[[kk]]
[10:26:59.454]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:59.454]                     next
[10:26:59.454]                   args[[name]] <- ""
[10:26:59.454]                 }
[10:26:59.454]                 NAMES <- toupper(removed)
[10:26:59.454]                 for (kk in seq_along(NAMES)) {
[10:26:59.454]                   name <- removed[[kk]]
[10:26:59.454]                   NAME <- NAMES[[kk]]
[10:26:59.454]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:59.454]                     next
[10:26:59.454]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:59.454]                 }
[10:26:59.454]                 if (length(args) > 0) 
[10:26:59.454]                   base::do.call(base::Sys.setenv, args = args)
[10:26:59.454]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:59.454]             }
[10:26:59.454]             else {
[10:26:59.454]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:59.454]             }
[10:26:59.454]             {
[10:26:59.454]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:59.454]                   0L) {
[10:26:59.454]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:59.454]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:59.454]                   base::options(opts)
[10:26:59.454]                 }
[10:26:59.454]                 {
[10:26:59.454]                   {
[10:26:59.454]                     NULL
[10:26:59.454]                     RNGkind("Mersenne-Twister")
[10:26:59.454]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:59.454]                       inherits = FALSE)
[10:26:59.454]                   }
[10:26:59.454]                   options(future.plan = NULL)
[10:26:59.454]                   if (is.na(NA_character_)) 
[10:26:59.454]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:59.454]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:59.454]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:59.454]                   {
[10:26:59.454]                     future <- SequentialFuture(..., envir = envir)
[10:26:59.454]                     if (!future$lazy) 
[10:26:59.454]                       future <- run(future)
[10:26:59.454]                     invisible(future)
[10:26:59.454]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:59.454]                 }
[10:26:59.454]             }
[10:26:59.454]         }
[10:26:59.454]     })
[10:26:59.454]     if (TRUE) {
[10:26:59.454]         base::sink(type = "output", split = FALSE)
[10:26:59.454]         if (TRUE) {
[10:26:59.454]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:59.454]         }
[10:26:59.454]         else {
[10:26:59.454]             ...future.result["stdout"] <- base::list(NULL)
[10:26:59.454]         }
[10:26:59.454]         base::close(...future.stdout)
[10:26:59.454]         ...future.stdout <- NULL
[10:26:59.454]     }
[10:26:59.454]     ...future.result$conditions <- ...future.conditions
[10:26:59.454]     ...future.result$finished <- base::Sys.time()
[10:26:59.454]     ...future.result
[10:26:59.454] }
[10:26:59.456] plan(): Setting new future strategy stack:
[10:26:59.456] List of future strategies:
[10:26:59.456] 1. sequential:
[10:26:59.456]    - args: function (..., envir = parent.frame())
[10:26:59.456]    - tweaked: FALSE
[10:26:59.456]    - call: NULL
[10:26:59.456] plan(): nbrOfWorkers() = 1
[10:26:59.457] plan(): Setting new future strategy stack:
[10:26:59.457] List of future strategies:
[10:26:59.457] 1. sequential:
[10:26:59.457]    - args: function (..., envir = parent.frame())
[10:26:59.457]    - tweaked: FALSE
[10:26:59.457]    - call: plan(strategy)
[10:26:59.458] plan(): nbrOfWorkers() = 1
[10:26:59.458] SequentialFuture started (and completed)
[10:26:59.458] - Launch lazy future ... done
[10:26:59.458] run() for ‘SequentialFuture’ ... done
[10:26:59.458] getGlobalsAndPackages() ...
[10:26:59.458] Searching for globals...
[10:26:59.464] - globals found: [2] ‘{’, ‘Sys.sleep’
[10:26:59.464] Searching for globals ... DONE
[10:26:59.464] Resolving globals: FALSE
[10:26:59.465] 
[10:26:59.465] 
[10:26:59.465] getGlobalsAndPackages() ... DONE
[10:26:59.465] run() for ‘Future’ ...
[10:26:59.465] - state: ‘created’
[10:26:59.465] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:59.466] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:59.466] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:59.466]   - Field: ‘label’
[10:26:59.466]   - Field: ‘local’
[10:26:59.466]   - Field: ‘owner’
[10:26:59.466]   - Field: ‘envir’
[10:26:59.466]   - Field: ‘packages’
[10:26:59.466]   - Field: ‘gc’
[10:26:59.466]   - Field: ‘conditions’
[10:26:59.467]   - Field: ‘expr’
[10:26:59.467]   - Field: ‘uuid’
[10:26:59.467]   - Field: ‘seed’
[10:26:59.467]   - Field: ‘version’
[10:26:59.467]   - Field: ‘result’
[10:26:59.467]   - Field: ‘asynchronous’
[10:26:59.467]   - Field: ‘calls’
[10:26:59.467]   - Field: ‘globals’
[10:26:59.467]   - Field: ‘stdout’
[10:26:59.467]   - Field: ‘earlySignal’
[10:26:59.467]   - Field: ‘lazy’
[10:26:59.468]   - Field: ‘state’
[10:26:59.468] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:59.468] - Launch lazy future ...
[10:26:59.468] Packages needed by the future expression (n = 0): <none>
[10:26:59.468] Packages needed by future strategies (n = 0): <none>
[10:26:59.469] {
[10:26:59.469]     {
[10:26:59.469]         {
[10:26:59.469]             ...future.startTime <- base::Sys.time()
[10:26:59.469]             {
[10:26:59.469]                 {
[10:26:59.469]                   {
[10:26:59.469]                     base::local({
[10:26:59.469]                       has_future <- base::requireNamespace("future", 
[10:26:59.469]                         quietly = TRUE)
[10:26:59.469]                       if (has_future) {
[10:26:59.469]                         ns <- base::getNamespace("future")
[10:26:59.469]                         version <- ns[[".package"]][["version"]]
[10:26:59.469]                         if (is.null(version)) 
[10:26:59.469]                           version <- utils::packageVersion("future")
[10:26:59.469]                       }
[10:26:59.469]                       else {
[10:26:59.469]                         version <- NULL
[10:26:59.469]                       }
[10:26:59.469]                       if (!has_future || version < "1.8.0") {
[10:26:59.469]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:59.469]                           "", base::R.version$version.string), 
[10:26:59.469]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:59.469]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:59.469]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:59.469]                             "release", "version")], collapse = " "), 
[10:26:59.469]                           hostname = base::Sys.info()[["nodename"]])
[10:26:59.469]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:59.469]                           info)
[10:26:59.469]                         info <- base::paste(info, collapse = "; ")
[10:26:59.469]                         if (!has_future) {
[10:26:59.469]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:59.469]                             info)
[10:26:59.469]                         }
[10:26:59.469]                         else {
[10:26:59.469]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:59.469]                             info, version)
[10:26:59.469]                         }
[10:26:59.469]                         base::stop(msg)
[10:26:59.469]                       }
[10:26:59.469]                     })
[10:26:59.469]                   }
[10:26:59.469]                   options(future.plan = NULL)
[10:26:59.469]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:59.469]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:59.469]                 }
[10:26:59.469]                 ...future.workdir <- getwd()
[10:26:59.469]             }
[10:26:59.469]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:59.469]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:59.469]         }
[10:26:59.469]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:59.469]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:59.469]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:59.469]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:59.469]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:59.469]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:59.469]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:59.469]             base::names(...future.oldOptions))
[10:26:59.469]     }
[10:26:59.469]     if (FALSE) {
[10:26:59.469]     }
[10:26:59.469]     else {
[10:26:59.469]         if (TRUE) {
[10:26:59.469]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:59.469]                 open = "w")
[10:26:59.469]         }
[10:26:59.469]         else {
[10:26:59.469]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:59.469]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:59.469]         }
[10:26:59.469]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:59.469]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:59.469]             base::sink(type = "output", split = FALSE)
[10:26:59.469]             base::close(...future.stdout)
[10:26:59.469]         }, add = TRUE)
[10:26:59.469]     }
[10:26:59.469]     ...future.frame <- base::sys.nframe()
[10:26:59.469]     ...future.conditions <- base::list()
[10:26:59.469]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:59.469]     if (FALSE) {
[10:26:59.469]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:59.469]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:59.469]     }
[10:26:59.469]     ...future.result <- base::tryCatch({
[10:26:59.469]         base::withCallingHandlers({
[10:26:59.469]             ...future.value <- base::withVisible(base::local({
[10:26:59.469]                 Sys.sleep(0.5)
[10:26:59.469]                 2
[10:26:59.469]             }))
[10:26:59.469]             future::FutureResult(value = ...future.value$value, 
[10:26:59.469]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:59.469]                   ...future.rng), globalenv = if (FALSE) 
[10:26:59.469]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:59.469]                     ...future.globalenv.names))
[10:26:59.469]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:59.469]         }, condition = base::local({
[10:26:59.469]             c <- base::c
[10:26:59.469]             inherits <- base::inherits
[10:26:59.469]             invokeRestart <- base::invokeRestart
[10:26:59.469]             length <- base::length
[10:26:59.469]             list <- base::list
[10:26:59.469]             seq.int <- base::seq.int
[10:26:59.469]             signalCondition <- base::signalCondition
[10:26:59.469]             sys.calls <- base::sys.calls
[10:26:59.469]             `[[` <- base::`[[`
[10:26:59.469]             `+` <- base::`+`
[10:26:59.469]             `<<-` <- base::`<<-`
[10:26:59.469]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:59.469]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:59.469]                   3L)]
[10:26:59.469]             }
[10:26:59.469]             function(cond) {
[10:26:59.469]                 is_error <- inherits(cond, "error")
[10:26:59.469]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:59.469]                   NULL)
[10:26:59.469]                 if (is_error) {
[10:26:59.469]                   sessionInformation <- function() {
[10:26:59.469]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:59.469]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:59.469]                       search = base::search(), system = base::Sys.info())
[10:26:59.469]                   }
[10:26:59.469]                   ...future.conditions[[length(...future.conditions) + 
[10:26:59.469]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:59.469]                     cond$call), session = sessionInformation(), 
[10:26:59.469]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:59.469]                   signalCondition(cond)
[10:26:59.469]                 }
[10:26:59.469]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:59.469]                 "immediateCondition"))) {
[10:26:59.469]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:59.469]                   ...future.conditions[[length(...future.conditions) + 
[10:26:59.469]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:59.469]                   if (TRUE && !signal) {
[10:26:59.469]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:59.469]                     {
[10:26:59.469]                       inherits <- base::inherits
[10:26:59.469]                       invokeRestart <- base::invokeRestart
[10:26:59.469]                       is.null <- base::is.null
[10:26:59.469]                       muffled <- FALSE
[10:26:59.469]                       if (inherits(cond, "message")) {
[10:26:59.469]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:59.469]                         if (muffled) 
[10:26:59.469]                           invokeRestart("muffleMessage")
[10:26:59.469]                       }
[10:26:59.469]                       else if (inherits(cond, "warning")) {
[10:26:59.469]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:59.469]                         if (muffled) 
[10:26:59.469]                           invokeRestart("muffleWarning")
[10:26:59.469]                       }
[10:26:59.469]                       else if (inherits(cond, "condition")) {
[10:26:59.469]                         if (!is.null(pattern)) {
[10:26:59.469]                           computeRestarts <- base::computeRestarts
[10:26:59.469]                           grepl <- base::grepl
[10:26:59.469]                           restarts <- computeRestarts(cond)
[10:26:59.469]                           for (restart in restarts) {
[10:26:59.469]                             name <- restart$name
[10:26:59.469]                             if (is.null(name)) 
[10:26:59.469]                               next
[10:26:59.469]                             if (!grepl(pattern, name)) 
[10:26:59.469]                               next
[10:26:59.469]                             invokeRestart(restart)
[10:26:59.469]                             muffled <- TRUE
[10:26:59.469]                             break
[10:26:59.469]                           }
[10:26:59.469]                         }
[10:26:59.469]                       }
[10:26:59.469]                       invisible(muffled)
[10:26:59.469]                     }
[10:26:59.469]                     muffleCondition(cond, pattern = "^muffle")
[10:26:59.469]                   }
[10:26:59.469]                 }
[10:26:59.469]                 else {
[10:26:59.469]                   if (TRUE) {
[10:26:59.469]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:59.469]                     {
[10:26:59.469]                       inherits <- base::inherits
[10:26:59.469]                       invokeRestart <- base::invokeRestart
[10:26:59.469]                       is.null <- base::is.null
[10:26:59.469]                       muffled <- FALSE
[10:26:59.469]                       if (inherits(cond, "message")) {
[10:26:59.469]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:59.469]                         if (muffled) 
[10:26:59.469]                           invokeRestart("muffleMessage")
[10:26:59.469]                       }
[10:26:59.469]                       else if (inherits(cond, "warning")) {
[10:26:59.469]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:59.469]                         if (muffled) 
[10:26:59.469]                           invokeRestart("muffleWarning")
[10:26:59.469]                       }
[10:26:59.469]                       else if (inherits(cond, "condition")) {
[10:26:59.469]                         if (!is.null(pattern)) {
[10:26:59.469]                           computeRestarts <- base::computeRestarts
[10:26:59.469]                           grepl <- base::grepl
[10:26:59.469]                           restarts <- computeRestarts(cond)
[10:26:59.469]                           for (restart in restarts) {
[10:26:59.469]                             name <- restart$name
[10:26:59.469]                             if (is.null(name)) 
[10:26:59.469]                               next
[10:26:59.469]                             if (!grepl(pattern, name)) 
[10:26:59.469]                               next
[10:26:59.469]                             invokeRestart(restart)
[10:26:59.469]                             muffled <- TRUE
[10:26:59.469]                             break
[10:26:59.469]                           }
[10:26:59.469]                         }
[10:26:59.469]                       }
[10:26:59.469]                       invisible(muffled)
[10:26:59.469]                     }
[10:26:59.469]                     muffleCondition(cond, pattern = "^muffle")
[10:26:59.469]                   }
[10:26:59.469]                 }
[10:26:59.469]             }
[10:26:59.469]         }))
[10:26:59.469]     }, error = function(ex) {
[10:26:59.469]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:59.469]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:59.469]                 ...future.rng), started = ...future.startTime, 
[10:26:59.469]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:59.469]             version = "1.8"), class = "FutureResult")
[10:26:59.469]     }, finally = {
[10:26:59.469]         if (!identical(...future.workdir, getwd())) 
[10:26:59.469]             setwd(...future.workdir)
[10:26:59.469]         {
[10:26:59.469]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:59.469]                 ...future.oldOptions$nwarnings <- NULL
[10:26:59.469]             }
[10:26:59.469]             base::options(...future.oldOptions)
[10:26:59.469]             if (.Platform$OS.type == "windows") {
[10:26:59.469]                 old_names <- names(...future.oldEnvVars)
[10:26:59.469]                 envs <- base::Sys.getenv()
[10:26:59.469]                 names <- names(envs)
[10:26:59.469]                 common <- intersect(names, old_names)
[10:26:59.469]                 added <- setdiff(names, old_names)
[10:26:59.469]                 removed <- setdiff(old_names, names)
[10:26:59.469]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:59.469]                   envs[common]]
[10:26:59.469]                 NAMES <- toupper(changed)
[10:26:59.469]                 args <- list()
[10:26:59.469]                 for (kk in seq_along(NAMES)) {
[10:26:59.469]                   name <- changed[[kk]]
[10:26:59.469]                   NAME <- NAMES[[kk]]
[10:26:59.469]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:59.469]                     next
[10:26:59.469]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:59.469]                 }
[10:26:59.469]                 NAMES <- toupper(added)
[10:26:59.469]                 for (kk in seq_along(NAMES)) {
[10:26:59.469]                   name <- added[[kk]]
[10:26:59.469]                   NAME <- NAMES[[kk]]
[10:26:59.469]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:59.469]                     next
[10:26:59.469]                   args[[name]] <- ""
[10:26:59.469]                 }
[10:26:59.469]                 NAMES <- toupper(removed)
[10:26:59.469]                 for (kk in seq_along(NAMES)) {
[10:26:59.469]                   name <- removed[[kk]]
[10:26:59.469]                   NAME <- NAMES[[kk]]
[10:26:59.469]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:59.469]                     next
[10:26:59.469]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:59.469]                 }
[10:26:59.469]                 if (length(args) > 0) 
[10:26:59.469]                   base::do.call(base::Sys.setenv, args = args)
[10:26:59.469]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:59.469]             }
[10:26:59.469]             else {
[10:26:59.469]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:59.469]             }
[10:26:59.469]             {
[10:26:59.469]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:59.469]                   0L) {
[10:26:59.469]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:59.469]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:59.469]                   base::options(opts)
[10:26:59.469]                 }
[10:26:59.469]                 {
[10:26:59.469]                   {
[10:26:59.469]                     NULL
[10:26:59.469]                     RNGkind("Mersenne-Twister")
[10:26:59.469]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:59.469]                       inherits = FALSE)
[10:26:59.469]                   }
[10:26:59.469]                   options(future.plan = NULL)
[10:26:59.469]                   if (is.na(NA_character_)) 
[10:26:59.469]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:59.469]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:59.469]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:59.469]                   {
[10:26:59.469]                     future <- SequentialFuture(..., envir = envir)
[10:26:59.469]                     if (!future$lazy) 
[10:26:59.469]                       future <- run(future)
[10:26:59.469]                     invisible(future)
[10:26:59.469]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:59.469]                 }
[10:26:59.469]             }
[10:26:59.469]         }
[10:26:59.469]     })
[10:26:59.469]     if (TRUE) {
[10:26:59.469]         base::sink(type = "output", split = FALSE)
[10:26:59.469]         if (TRUE) {
[10:26:59.469]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:59.469]         }
[10:26:59.469]         else {
[10:26:59.469]             ...future.result["stdout"] <- base::list(NULL)
[10:26:59.469]         }
[10:26:59.469]         base::close(...future.stdout)
[10:26:59.469]         ...future.stdout <- NULL
[10:26:59.469]     }
[10:26:59.469]     ...future.result$conditions <- ...future.conditions
[10:26:59.469]     ...future.result$finished <- base::Sys.time()
[10:26:59.469]     ...future.result
[10:26:59.469] }
[10:26:59.471] plan(): Setting new future strategy stack:
[10:26:59.471] List of future strategies:
[10:26:59.471] 1. sequential:
[10:26:59.471]    - args: function (..., envir = parent.frame())
[10:26:59.471]    - tweaked: FALSE
[10:26:59.471]    - call: NULL
[10:26:59.471] plan(): nbrOfWorkers() = 1
[10:26:59.973] plan(): Setting new future strategy stack:
[10:26:59.973] List of future strategies:
[10:26:59.973] 1. sequential:
[10:26:59.973]    - args: function (..., envir = parent.frame())
[10:26:59.973]    - tweaked: FALSE
[10:26:59.973]    - call: plan(strategy)
[10:26:59.974] plan(): nbrOfWorkers() = 1
[10:26:59.974] SequentialFuture started (and completed)
[10:26:59.974] - Launch lazy future ... done
[10:26:59.974] run() for ‘SequentialFuture’ ... done
[10:26:59.975] resolve() on list ...
[10:26:59.975]  recursive: 0
[10:26:59.975]  length: 1
[10:26:59.975] 
[10:26:59.975] resolved() for ‘SequentialFuture’ ...
[10:26:59.975] - state: ‘finished’
[10:26:59.975] - run: TRUE
[10:26:59.975] - result: ‘FutureResult’
[10:26:59.976] resolved() for ‘SequentialFuture’ ... done
[10:26:59.976] Future #1
[10:26:59.976]  length: 0 (resolved future 1)
[10:26:59.976] resolve() on list ... DONE
[10:26:59.976] resolved() for ‘SequentialFuture’ ...
[10:26:59.976] - state: ‘finished’
[10:26:59.976] - run: TRUE
[10:26:59.976] - result: ‘FutureResult’
[10:26:59.976] resolved() for ‘SequentialFuture’ ... done
[10:26:59.977] resolve() on list ...
[10:26:59.977]  recursive: 0
[10:26:59.977]  length: 1
[10:26:59.977] 
[10:26:59.977] resolved() for ‘SequentialFuture’ ...
[10:26:59.977] - state: ‘finished’
[10:26:59.977] - run: TRUE
[10:26:59.977] - result: ‘FutureResult’
[10:26:59.977] resolved() for ‘SequentialFuture’ ... done
[10:26:59.977] Future #1
[10:26:59.978]  length: 0 (resolved future 1)
[10:26:59.978] resolve() on list ... DONE
[10:26:59.978] resolved() for ‘SequentialFuture’ ...
[10:26:59.978] - state: ‘finished’
[10:26:59.978] - run: TRUE
[10:26:59.978] - result: ‘FutureResult’
[10:26:59.978] resolved() for ‘SequentialFuture’ ... done
[10:26:59.978] resolve() on list ...
[10:26:59.978]  recursive: 0
[10:26:59.978]  length: 1
[10:26:59.979] 
[10:26:59.979]  length: 0 (resolved future 1)
[10:26:59.979] resolve() on list ... DONE
[10:26:59.979] resolve() on list ...
[10:26:59.979]  recursive: 0
[10:26:59.979]  length: 4
[10:26:59.979] 
[10:26:59.979] resolved() for ‘SequentialFuture’ ...
[10:26:59.979] - state: ‘finished’
[10:26:59.979] - run: TRUE
[10:26:59.980] - result: ‘FutureResult’
[10:26:59.980] resolved() for ‘SequentialFuture’ ... done
[10:26:59.980] Future #1
[10:26:59.982]  length: 3 (resolved future 1)
[10:26:59.982] resolved() for ‘SequentialFuture’ ...
[10:26:59.982] - state: ‘finished’
[10:26:59.982] - run: TRUE
[10:26:59.982] - result: ‘FutureResult’
[10:26:59.982] resolved() for ‘SequentialFuture’ ... done
[10:26:59.982] Future #2
[10:26:59.983]  length: 2 (resolved future 2)
[10:26:59.983]  length: 1 (resolved future 3)
[10:26:59.983]  length: 0 (resolved future 4)
[10:26:59.983] resolve() on list ... DONE
[10:26:59.983] resolve() on list ...
[10:26:59.983]  recursive: 0
[10:26:59.983]  length: 4
[10:26:59.983] 
[10:26:59.983] resolved() for ‘SequentialFuture’ ...
[10:26:59.984] - state: ‘finished’
[10:26:59.984] - run: TRUE
[10:26:59.984] - result: ‘FutureResult’
[10:26:59.984] resolved() for ‘SequentialFuture’ ... done
[10:26:59.984] Future #1
[10:26:59.984]  length: 3 (resolved future 1)
[10:26:59.984] resolved() for ‘SequentialFuture’ ...
[10:26:59.984] - state: ‘finished’
[10:26:59.984] - run: TRUE
[10:26:59.984] - result: ‘FutureResult’
[10:26:59.984] resolved() for ‘SequentialFuture’ ... done
[10:26:59.985] Future #2
[10:26:59.985]  length: 2 (resolved future 2)
[10:26:59.985]  length: 1 (resolved future 3)
[10:26:59.985]  length: 0 (resolved future 4)
[10:26:59.985] resolve() on list ... DONE
[10:26:59.985] resolve() on list ...
[10:26:59.985]  recursive: 0
[10:26:59.986]  length: 1
[10:26:59.986] 
[10:26:59.986]  length: 0 (resolved future 1)
[10:26:59.986] resolve() on list ... DONE
[10:26:59.986] getGlobalsAndPackages() ...
[10:26:59.986] Searching for globals...
[10:26:59.987] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:26:59.987] Searching for globals ... DONE
[10:26:59.987] Resolving globals: FALSE
[10:26:59.988] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:59.988] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[10:26:59.989] - globals: [1] ‘kk’
[10:26:59.989] 
[10:26:59.989] getGlobalsAndPackages() ... DONE
[10:26:59.989] run() for ‘Future’ ...
[10:26:59.989] - state: ‘created’
[10:26:59.989] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:59.990] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:59.990] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:59.990]   - Field: ‘label’
[10:26:59.990]   - Field: ‘local’
[10:26:59.990]   - Field: ‘owner’
[10:26:59.990]   - Field: ‘envir’
[10:26:59.990]   - Field: ‘packages’
[10:26:59.990]   - Field: ‘gc’
[10:26:59.990]   - Field: ‘conditions’
[10:26:59.990]   - Field: ‘expr’
[10:26:59.991]   - Field: ‘uuid’
[10:26:59.991]   - Field: ‘seed’
[10:26:59.991]   - Field: ‘version’
[10:26:59.991]   - Field: ‘result’
[10:26:59.991]   - Field: ‘asynchronous’
[10:26:59.991]   - Field: ‘calls’
[10:26:59.991]   - Field: ‘globals’
[10:26:59.991]   - Field: ‘stdout’
[10:26:59.991]   - Field: ‘earlySignal’
[10:26:59.991]   - Field: ‘lazy’
[10:26:59.991]   - Field: ‘state’
[10:26:59.992] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:59.992] - Launch lazy future ...
[10:26:59.992] Packages needed by the future expression (n = 0): <none>
[10:26:59.992] Packages needed by future strategies (n = 0): <none>
[10:26:59.992] {
[10:26:59.992]     {
[10:26:59.992]         {
[10:26:59.992]             ...future.startTime <- base::Sys.time()
[10:26:59.992]             {
[10:26:59.992]                 {
[10:26:59.992]                   {
[10:26:59.992]                     base::local({
[10:26:59.992]                       has_future <- base::requireNamespace("future", 
[10:26:59.992]                         quietly = TRUE)
[10:26:59.992]                       if (has_future) {
[10:26:59.992]                         ns <- base::getNamespace("future")
[10:26:59.992]                         version <- ns[[".package"]][["version"]]
[10:26:59.992]                         if (is.null(version)) 
[10:26:59.992]                           version <- utils::packageVersion("future")
[10:26:59.992]                       }
[10:26:59.992]                       else {
[10:26:59.992]                         version <- NULL
[10:26:59.992]                       }
[10:26:59.992]                       if (!has_future || version < "1.8.0") {
[10:26:59.992]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:59.992]                           "", base::R.version$version.string), 
[10:26:59.992]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:59.992]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:59.992]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:59.992]                             "release", "version")], collapse = " "), 
[10:26:59.992]                           hostname = base::Sys.info()[["nodename"]])
[10:26:59.992]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:59.992]                           info)
[10:26:59.992]                         info <- base::paste(info, collapse = "; ")
[10:26:59.992]                         if (!has_future) {
[10:26:59.992]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:59.992]                             info)
[10:26:59.992]                         }
[10:26:59.992]                         else {
[10:26:59.992]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:59.992]                             info, version)
[10:26:59.992]                         }
[10:26:59.992]                         base::stop(msg)
[10:26:59.992]                       }
[10:26:59.992]                     })
[10:26:59.992]                   }
[10:26:59.992]                   options(future.plan = NULL)
[10:26:59.992]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:59.992]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:59.992]                 }
[10:26:59.992]                 ...future.workdir <- getwd()
[10:26:59.992]             }
[10:26:59.992]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:59.992]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:59.992]         }
[10:26:59.992]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:59.992]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:59.992]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:59.992]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:59.992]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:59.992]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:59.992]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:59.992]             base::names(...future.oldOptions))
[10:26:59.992]     }
[10:26:59.992]     if (FALSE) {
[10:26:59.992]     }
[10:26:59.992]     else {
[10:26:59.992]         if (TRUE) {
[10:26:59.992]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:59.992]                 open = "w")
[10:26:59.992]         }
[10:26:59.992]         else {
[10:26:59.992]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:59.992]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:59.992]         }
[10:26:59.992]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:59.992]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:59.992]             base::sink(type = "output", split = FALSE)
[10:26:59.992]             base::close(...future.stdout)
[10:26:59.992]         }, add = TRUE)
[10:26:59.992]     }
[10:26:59.992]     ...future.frame <- base::sys.nframe()
[10:26:59.992]     ...future.conditions <- base::list()
[10:26:59.992]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:59.992]     if (FALSE) {
[10:26:59.992]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:59.992]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:59.992]     }
[10:26:59.992]     ...future.result <- base::tryCatch({
[10:26:59.992]         base::withCallingHandlers({
[10:26:59.992]             ...future.value <- base::withVisible(base::local({
[10:26:59.992]                 Sys.sleep(0.1)
[10:26:59.992]                 kk
[10:26:59.992]             }))
[10:26:59.992]             future::FutureResult(value = ...future.value$value, 
[10:26:59.992]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:59.992]                   ...future.rng), globalenv = if (FALSE) 
[10:26:59.992]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:59.992]                     ...future.globalenv.names))
[10:26:59.992]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:59.992]         }, condition = base::local({
[10:26:59.992]             c <- base::c
[10:26:59.992]             inherits <- base::inherits
[10:26:59.992]             invokeRestart <- base::invokeRestart
[10:26:59.992]             length <- base::length
[10:26:59.992]             list <- base::list
[10:26:59.992]             seq.int <- base::seq.int
[10:26:59.992]             signalCondition <- base::signalCondition
[10:26:59.992]             sys.calls <- base::sys.calls
[10:26:59.992]             `[[` <- base::`[[`
[10:26:59.992]             `+` <- base::`+`
[10:26:59.992]             `<<-` <- base::`<<-`
[10:26:59.992]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:59.992]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:59.992]                   3L)]
[10:26:59.992]             }
[10:26:59.992]             function(cond) {
[10:26:59.992]                 is_error <- inherits(cond, "error")
[10:26:59.992]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:59.992]                   NULL)
[10:26:59.992]                 if (is_error) {
[10:26:59.992]                   sessionInformation <- function() {
[10:26:59.992]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:59.992]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:59.992]                       search = base::search(), system = base::Sys.info())
[10:26:59.992]                   }
[10:26:59.992]                   ...future.conditions[[length(...future.conditions) + 
[10:26:59.992]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:59.992]                     cond$call), session = sessionInformation(), 
[10:26:59.992]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:59.992]                   signalCondition(cond)
[10:26:59.992]                 }
[10:26:59.992]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:59.992]                 "immediateCondition"))) {
[10:26:59.992]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:59.992]                   ...future.conditions[[length(...future.conditions) + 
[10:26:59.992]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:59.992]                   if (TRUE && !signal) {
[10:26:59.992]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:59.992]                     {
[10:26:59.992]                       inherits <- base::inherits
[10:26:59.992]                       invokeRestart <- base::invokeRestart
[10:26:59.992]                       is.null <- base::is.null
[10:26:59.992]                       muffled <- FALSE
[10:26:59.992]                       if (inherits(cond, "message")) {
[10:26:59.992]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:59.992]                         if (muffled) 
[10:26:59.992]                           invokeRestart("muffleMessage")
[10:26:59.992]                       }
[10:26:59.992]                       else if (inherits(cond, "warning")) {
[10:26:59.992]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:59.992]                         if (muffled) 
[10:26:59.992]                           invokeRestart("muffleWarning")
[10:26:59.992]                       }
[10:26:59.992]                       else if (inherits(cond, "condition")) {
[10:26:59.992]                         if (!is.null(pattern)) {
[10:26:59.992]                           computeRestarts <- base::computeRestarts
[10:26:59.992]                           grepl <- base::grepl
[10:26:59.992]                           restarts <- computeRestarts(cond)
[10:26:59.992]                           for (restart in restarts) {
[10:26:59.992]                             name <- restart$name
[10:26:59.992]                             if (is.null(name)) 
[10:26:59.992]                               next
[10:26:59.992]                             if (!grepl(pattern, name)) 
[10:26:59.992]                               next
[10:26:59.992]                             invokeRestart(restart)
[10:26:59.992]                             muffled <- TRUE
[10:26:59.992]                             break
[10:26:59.992]                           }
[10:26:59.992]                         }
[10:26:59.992]                       }
[10:26:59.992]                       invisible(muffled)
[10:26:59.992]                     }
[10:26:59.992]                     muffleCondition(cond, pattern = "^muffle")
[10:26:59.992]                   }
[10:26:59.992]                 }
[10:26:59.992]                 else {
[10:26:59.992]                   if (TRUE) {
[10:26:59.992]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:59.992]                     {
[10:26:59.992]                       inherits <- base::inherits
[10:26:59.992]                       invokeRestart <- base::invokeRestart
[10:26:59.992]                       is.null <- base::is.null
[10:26:59.992]                       muffled <- FALSE
[10:26:59.992]                       if (inherits(cond, "message")) {
[10:26:59.992]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:59.992]                         if (muffled) 
[10:26:59.992]                           invokeRestart("muffleMessage")
[10:26:59.992]                       }
[10:26:59.992]                       else if (inherits(cond, "warning")) {
[10:26:59.992]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:59.992]                         if (muffled) 
[10:26:59.992]                           invokeRestart("muffleWarning")
[10:26:59.992]                       }
[10:26:59.992]                       else if (inherits(cond, "condition")) {
[10:26:59.992]                         if (!is.null(pattern)) {
[10:26:59.992]                           computeRestarts <- base::computeRestarts
[10:26:59.992]                           grepl <- base::grepl
[10:26:59.992]                           restarts <- computeRestarts(cond)
[10:26:59.992]                           for (restart in restarts) {
[10:26:59.992]                             name <- restart$name
[10:26:59.992]                             if (is.null(name)) 
[10:26:59.992]                               next
[10:26:59.992]                             if (!grepl(pattern, name)) 
[10:26:59.992]                               next
[10:26:59.992]                             invokeRestart(restart)
[10:26:59.992]                             muffled <- TRUE
[10:26:59.992]                             break
[10:26:59.992]                           }
[10:26:59.992]                         }
[10:26:59.992]                       }
[10:26:59.992]                       invisible(muffled)
[10:26:59.992]                     }
[10:26:59.992]                     muffleCondition(cond, pattern = "^muffle")
[10:26:59.992]                   }
[10:26:59.992]                 }
[10:26:59.992]             }
[10:26:59.992]         }))
[10:26:59.992]     }, error = function(ex) {
[10:26:59.992]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:59.992]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:59.992]                 ...future.rng), started = ...future.startTime, 
[10:26:59.992]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:59.992]             version = "1.8"), class = "FutureResult")
[10:26:59.992]     }, finally = {
[10:26:59.992]         if (!identical(...future.workdir, getwd())) 
[10:26:59.992]             setwd(...future.workdir)
[10:26:59.992]         {
[10:26:59.992]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:59.992]                 ...future.oldOptions$nwarnings <- NULL
[10:26:59.992]             }
[10:26:59.992]             base::options(...future.oldOptions)
[10:26:59.992]             if (.Platform$OS.type == "windows") {
[10:26:59.992]                 old_names <- names(...future.oldEnvVars)
[10:26:59.992]                 envs <- base::Sys.getenv()
[10:26:59.992]                 names <- names(envs)
[10:26:59.992]                 common <- intersect(names, old_names)
[10:26:59.992]                 added <- setdiff(names, old_names)
[10:26:59.992]                 removed <- setdiff(old_names, names)
[10:26:59.992]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:59.992]                   envs[common]]
[10:26:59.992]                 NAMES <- toupper(changed)
[10:26:59.992]                 args <- list()
[10:26:59.992]                 for (kk in seq_along(NAMES)) {
[10:26:59.992]                   name <- changed[[kk]]
[10:26:59.992]                   NAME <- NAMES[[kk]]
[10:26:59.992]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:59.992]                     next
[10:26:59.992]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:59.992]                 }
[10:26:59.992]                 NAMES <- toupper(added)
[10:26:59.992]                 for (kk in seq_along(NAMES)) {
[10:26:59.992]                   name <- added[[kk]]
[10:26:59.992]                   NAME <- NAMES[[kk]]
[10:26:59.992]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:59.992]                     next
[10:26:59.992]                   args[[name]] <- ""
[10:26:59.992]                 }
[10:26:59.992]                 NAMES <- toupper(removed)
[10:26:59.992]                 for (kk in seq_along(NAMES)) {
[10:26:59.992]                   name <- removed[[kk]]
[10:26:59.992]                   NAME <- NAMES[[kk]]
[10:26:59.992]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:59.992]                     next
[10:26:59.992]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:59.992]                 }
[10:26:59.992]                 if (length(args) > 0) 
[10:26:59.992]                   base::do.call(base::Sys.setenv, args = args)
[10:26:59.992]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:59.992]             }
[10:26:59.992]             else {
[10:26:59.992]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:59.992]             }
[10:26:59.992]             {
[10:26:59.992]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:59.992]                   0L) {
[10:26:59.992]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:59.992]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:59.992]                   base::options(opts)
[10:26:59.992]                 }
[10:26:59.992]                 {
[10:26:59.992]                   {
[10:26:59.992]                     NULL
[10:26:59.992]                     RNGkind("Mersenne-Twister")
[10:26:59.992]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:59.992]                       inherits = FALSE)
[10:26:59.992]                   }
[10:26:59.992]                   options(future.plan = NULL)
[10:26:59.992]                   if (is.na(NA_character_)) 
[10:26:59.992]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:59.992]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:59.992]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:59.992]                   {
[10:26:59.992]                     future <- SequentialFuture(..., envir = envir)
[10:26:59.992]                     if (!future$lazy) 
[10:26:59.992]                       future <- run(future)
[10:26:59.992]                     invisible(future)
[10:26:59.992]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:59.992]                 }
[10:26:59.992]             }
[10:26:59.992]         }
[10:26:59.992]     })
[10:26:59.992]     if (TRUE) {
[10:26:59.992]         base::sink(type = "output", split = FALSE)
[10:26:59.992]         if (TRUE) {
[10:26:59.992]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:59.992]         }
[10:26:59.992]         else {
[10:26:59.992]             ...future.result["stdout"] <- base::list(NULL)
[10:26:59.992]         }
[10:26:59.992]         base::close(...future.stdout)
[10:26:59.992]         ...future.stdout <- NULL
[10:26:59.992]     }
[10:26:59.992]     ...future.result$conditions <- ...future.conditions
[10:26:59.992]     ...future.result$finished <- base::Sys.time()
[10:26:59.992]     ...future.result
[10:26:59.992] }
[10:26:59.994] assign_globals() ...
[10:26:59.994] List of 1
[10:26:59.994]  $ kk: int 1
[10:26:59.994]  - attr(*, "where")=List of 1
[10:26:59.994]   ..$ kk:<environment: R_EmptyEnv> 
[10:26:59.994]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:59.994]  - attr(*, "resolved")= logi FALSE
[10:26:59.994]  - attr(*, "total_size")= num 56
[10:26:59.994]  - attr(*, "already-done")= logi TRUE
[10:26:59.999] - copied ‘kk’ to environment
[10:26:59.999] assign_globals() ... done
[10:27:00.000] plan(): Setting new future strategy stack:
[10:27:00.000] List of future strategies:
[10:27:00.000] 1. sequential:
[10:27:00.000]    - args: function (..., envir = parent.frame())
[10:27:00.000]    - tweaked: FALSE
[10:27:00.000]    - call: NULL
[10:27:00.000] plan(): nbrOfWorkers() = 1
[10:27:00.101] plan(): Setting new future strategy stack:
[10:27:00.101] List of future strategies:
[10:27:00.101] 1. sequential:
[10:27:00.101]    - args: function (..., envir = parent.frame())
[10:27:00.101]    - tweaked: FALSE
[10:27:00.101]    - call: plan(strategy)
[10:27:00.102] plan(): nbrOfWorkers() = 1
[10:27:00.102] SequentialFuture started (and completed)
[10:27:00.102] - Launch lazy future ... done
[10:27:00.102] run() for ‘SequentialFuture’ ... done
[10:27:00.102] getGlobalsAndPackages() ...
[10:27:00.103] Searching for globals...
[10:27:00.104] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:27:00.104] Searching for globals ... DONE
[10:27:00.104] Resolving globals: FALSE
[10:27:00.104] The total size of the 1 globals is 56 bytes (56 bytes)
[10:27:00.105] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[10:27:00.105] - globals: [1] ‘kk’
[10:27:00.105] 
[10:27:00.105] getGlobalsAndPackages() ... DONE
[10:27:00.105] run() for ‘Future’ ...
[10:27:00.105] - state: ‘created’
[10:27:00.105] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:27:00.106] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:27:00.106] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:27:00.106]   - Field: ‘label’
[10:27:00.106]   - Field: ‘local’
[10:27:00.106]   - Field: ‘owner’
[10:27:00.106]   - Field: ‘envir’
[10:27:00.106]   - Field: ‘packages’
[10:27:00.107]   - Field: ‘gc’
[10:27:00.107]   - Field: ‘conditions’
[10:27:00.107]   - Field: ‘expr’
[10:27:00.107]   - Field: ‘uuid’
[10:27:00.107]   - Field: ‘seed’
[10:27:00.107]   - Field: ‘version’
[10:27:00.107]   - Field: ‘result’
[10:27:00.107]   - Field: ‘asynchronous’
[10:27:00.107]   - Field: ‘calls’
[10:27:00.107]   - Field: ‘globals’
[10:27:00.107]   - Field: ‘stdout’
[10:27:00.108]   - Field: ‘earlySignal’
[10:27:00.108]   - Field: ‘lazy’
[10:27:00.108]   - Field: ‘state’
[10:27:00.108] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:27:00.108] - Launch lazy future ...
[10:27:00.108] Packages needed by the future expression (n = 0): <none>
[10:27:00.108] Packages needed by future strategies (n = 0): <none>
[10:27:00.109] {
[10:27:00.109]     {
[10:27:00.109]         {
[10:27:00.109]             ...future.startTime <- base::Sys.time()
[10:27:00.109]             {
[10:27:00.109]                 {
[10:27:00.109]                   {
[10:27:00.109]                     base::local({
[10:27:00.109]                       has_future <- base::requireNamespace("future", 
[10:27:00.109]                         quietly = TRUE)
[10:27:00.109]                       if (has_future) {
[10:27:00.109]                         ns <- base::getNamespace("future")
[10:27:00.109]                         version <- ns[[".package"]][["version"]]
[10:27:00.109]                         if (is.null(version)) 
[10:27:00.109]                           version <- utils::packageVersion("future")
[10:27:00.109]                       }
[10:27:00.109]                       else {
[10:27:00.109]                         version <- NULL
[10:27:00.109]                       }
[10:27:00.109]                       if (!has_future || version < "1.8.0") {
[10:27:00.109]                         info <- base::c(r_version = base::gsub("R version ", 
[10:27:00.109]                           "", base::R.version$version.string), 
[10:27:00.109]                           platform = base::sprintf("%s (%s-bit)", 
[10:27:00.109]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:00.109]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:00.109]                             "release", "version")], collapse = " "), 
[10:27:00.109]                           hostname = base::Sys.info()[["nodename"]])
[10:27:00.109]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:27:00.109]                           info)
[10:27:00.109]                         info <- base::paste(info, collapse = "; ")
[10:27:00.109]                         if (!has_future) {
[10:27:00.109]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:00.109]                             info)
[10:27:00.109]                         }
[10:27:00.109]                         else {
[10:27:00.109]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:00.109]                             info, version)
[10:27:00.109]                         }
[10:27:00.109]                         base::stop(msg)
[10:27:00.109]                       }
[10:27:00.109]                     })
[10:27:00.109]                   }
[10:27:00.109]                   options(future.plan = NULL)
[10:27:00.109]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:00.109]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:00.109]                 }
[10:27:00.109]                 ...future.workdir <- getwd()
[10:27:00.109]             }
[10:27:00.109]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:00.109]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:00.109]         }
[10:27:00.109]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:00.109]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:00.109]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:00.109]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:00.109]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:00.109]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:00.109]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:00.109]             base::names(...future.oldOptions))
[10:27:00.109]     }
[10:27:00.109]     if (FALSE) {
[10:27:00.109]     }
[10:27:00.109]     else {
[10:27:00.109]         if (TRUE) {
[10:27:00.109]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:00.109]                 open = "w")
[10:27:00.109]         }
[10:27:00.109]         else {
[10:27:00.109]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:00.109]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:00.109]         }
[10:27:00.109]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:00.109]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:00.109]             base::sink(type = "output", split = FALSE)
[10:27:00.109]             base::close(...future.stdout)
[10:27:00.109]         }, add = TRUE)
[10:27:00.109]     }
[10:27:00.109]     ...future.frame <- base::sys.nframe()
[10:27:00.109]     ...future.conditions <- base::list()
[10:27:00.109]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:00.109]     if (FALSE) {
[10:27:00.109]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:00.109]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:00.109]     }
[10:27:00.109]     ...future.result <- base::tryCatch({
[10:27:00.109]         base::withCallingHandlers({
[10:27:00.109]             ...future.value <- base::withVisible(base::local({
[10:27:00.109]                 Sys.sleep(0.1)
[10:27:00.109]                 kk
[10:27:00.109]             }))
[10:27:00.109]             future::FutureResult(value = ...future.value$value, 
[10:27:00.109]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:00.109]                   ...future.rng), globalenv = if (FALSE) 
[10:27:00.109]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:00.109]                     ...future.globalenv.names))
[10:27:00.109]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:00.109]         }, condition = base::local({
[10:27:00.109]             c <- base::c
[10:27:00.109]             inherits <- base::inherits
[10:27:00.109]             invokeRestart <- base::invokeRestart
[10:27:00.109]             length <- base::length
[10:27:00.109]             list <- base::list
[10:27:00.109]             seq.int <- base::seq.int
[10:27:00.109]             signalCondition <- base::signalCondition
[10:27:00.109]             sys.calls <- base::sys.calls
[10:27:00.109]             `[[` <- base::`[[`
[10:27:00.109]             `+` <- base::`+`
[10:27:00.109]             `<<-` <- base::`<<-`
[10:27:00.109]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:00.109]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:00.109]                   3L)]
[10:27:00.109]             }
[10:27:00.109]             function(cond) {
[10:27:00.109]                 is_error <- inherits(cond, "error")
[10:27:00.109]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:00.109]                   NULL)
[10:27:00.109]                 if (is_error) {
[10:27:00.109]                   sessionInformation <- function() {
[10:27:00.109]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:00.109]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:00.109]                       search = base::search(), system = base::Sys.info())
[10:27:00.109]                   }
[10:27:00.109]                   ...future.conditions[[length(...future.conditions) + 
[10:27:00.109]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:00.109]                     cond$call), session = sessionInformation(), 
[10:27:00.109]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:00.109]                   signalCondition(cond)
[10:27:00.109]                 }
[10:27:00.109]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:00.109]                 "immediateCondition"))) {
[10:27:00.109]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:00.109]                   ...future.conditions[[length(...future.conditions) + 
[10:27:00.109]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:00.109]                   if (TRUE && !signal) {
[10:27:00.109]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:00.109]                     {
[10:27:00.109]                       inherits <- base::inherits
[10:27:00.109]                       invokeRestart <- base::invokeRestart
[10:27:00.109]                       is.null <- base::is.null
[10:27:00.109]                       muffled <- FALSE
[10:27:00.109]                       if (inherits(cond, "message")) {
[10:27:00.109]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:00.109]                         if (muffled) 
[10:27:00.109]                           invokeRestart("muffleMessage")
[10:27:00.109]                       }
[10:27:00.109]                       else if (inherits(cond, "warning")) {
[10:27:00.109]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:00.109]                         if (muffled) 
[10:27:00.109]                           invokeRestart("muffleWarning")
[10:27:00.109]                       }
[10:27:00.109]                       else if (inherits(cond, "condition")) {
[10:27:00.109]                         if (!is.null(pattern)) {
[10:27:00.109]                           computeRestarts <- base::computeRestarts
[10:27:00.109]                           grepl <- base::grepl
[10:27:00.109]                           restarts <- computeRestarts(cond)
[10:27:00.109]                           for (restart in restarts) {
[10:27:00.109]                             name <- restart$name
[10:27:00.109]                             if (is.null(name)) 
[10:27:00.109]                               next
[10:27:00.109]                             if (!grepl(pattern, name)) 
[10:27:00.109]                               next
[10:27:00.109]                             invokeRestart(restart)
[10:27:00.109]                             muffled <- TRUE
[10:27:00.109]                             break
[10:27:00.109]                           }
[10:27:00.109]                         }
[10:27:00.109]                       }
[10:27:00.109]                       invisible(muffled)
[10:27:00.109]                     }
[10:27:00.109]                     muffleCondition(cond, pattern = "^muffle")
[10:27:00.109]                   }
[10:27:00.109]                 }
[10:27:00.109]                 else {
[10:27:00.109]                   if (TRUE) {
[10:27:00.109]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:00.109]                     {
[10:27:00.109]                       inherits <- base::inherits
[10:27:00.109]                       invokeRestart <- base::invokeRestart
[10:27:00.109]                       is.null <- base::is.null
[10:27:00.109]                       muffled <- FALSE
[10:27:00.109]                       if (inherits(cond, "message")) {
[10:27:00.109]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:00.109]                         if (muffled) 
[10:27:00.109]                           invokeRestart("muffleMessage")
[10:27:00.109]                       }
[10:27:00.109]                       else if (inherits(cond, "warning")) {
[10:27:00.109]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:00.109]                         if (muffled) 
[10:27:00.109]                           invokeRestart("muffleWarning")
[10:27:00.109]                       }
[10:27:00.109]                       else if (inherits(cond, "condition")) {
[10:27:00.109]                         if (!is.null(pattern)) {
[10:27:00.109]                           computeRestarts <- base::computeRestarts
[10:27:00.109]                           grepl <- base::grepl
[10:27:00.109]                           restarts <- computeRestarts(cond)
[10:27:00.109]                           for (restart in restarts) {
[10:27:00.109]                             name <- restart$name
[10:27:00.109]                             if (is.null(name)) 
[10:27:00.109]                               next
[10:27:00.109]                             if (!grepl(pattern, name)) 
[10:27:00.109]                               next
[10:27:00.109]                             invokeRestart(restart)
[10:27:00.109]                             muffled <- TRUE
[10:27:00.109]                             break
[10:27:00.109]                           }
[10:27:00.109]                         }
[10:27:00.109]                       }
[10:27:00.109]                       invisible(muffled)
[10:27:00.109]                     }
[10:27:00.109]                     muffleCondition(cond, pattern = "^muffle")
[10:27:00.109]                   }
[10:27:00.109]                 }
[10:27:00.109]             }
[10:27:00.109]         }))
[10:27:00.109]     }, error = function(ex) {
[10:27:00.109]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:00.109]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:00.109]                 ...future.rng), started = ...future.startTime, 
[10:27:00.109]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:00.109]             version = "1.8"), class = "FutureResult")
[10:27:00.109]     }, finally = {
[10:27:00.109]         if (!identical(...future.workdir, getwd())) 
[10:27:00.109]             setwd(...future.workdir)
[10:27:00.109]         {
[10:27:00.109]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:00.109]                 ...future.oldOptions$nwarnings <- NULL
[10:27:00.109]             }
[10:27:00.109]             base::options(...future.oldOptions)
[10:27:00.109]             if (.Platform$OS.type == "windows") {
[10:27:00.109]                 old_names <- names(...future.oldEnvVars)
[10:27:00.109]                 envs <- base::Sys.getenv()
[10:27:00.109]                 names <- names(envs)
[10:27:00.109]                 common <- intersect(names, old_names)
[10:27:00.109]                 added <- setdiff(names, old_names)
[10:27:00.109]                 removed <- setdiff(old_names, names)
[10:27:00.109]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:00.109]                   envs[common]]
[10:27:00.109]                 NAMES <- toupper(changed)
[10:27:00.109]                 args <- list()
[10:27:00.109]                 for (kk in seq_along(NAMES)) {
[10:27:00.109]                   name <- changed[[kk]]
[10:27:00.109]                   NAME <- NAMES[[kk]]
[10:27:00.109]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.109]                     next
[10:27:00.109]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:00.109]                 }
[10:27:00.109]                 NAMES <- toupper(added)
[10:27:00.109]                 for (kk in seq_along(NAMES)) {
[10:27:00.109]                   name <- added[[kk]]
[10:27:00.109]                   NAME <- NAMES[[kk]]
[10:27:00.109]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.109]                     next
[10:27:00.109]                   args[[name]] <- ""
[10:27:00.109]                 }
[10:27:00.109]                 NAMES <- toupper(removed)
[10:27:00.109]                 for (kk in seq_along(NAMES)) {
[10:27:00.109]                   name <- removed[[kk]]
[10:27:00.109]                   NAME <- NAMES[[kk]]
[10:27:00.109]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.109]                     next
[10:27:00.109]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:00.109]                 }
[10:27:00.109]                 if (length(args) > 0) 
[10:27:00.109]                   base::do.call(base::Sys.setenv, args = args)
[10:27:00.109]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:00.109]             }
[10:27:00.109]             else {
[10:27:00.109]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:00.109]             }
[10:27:00.109]             {
[10:27:00.109]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:00.109]                   0L) {
[10:27:00.109]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:00.109]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:00.109]                   base::options(opts)
[10:27:00.109]                 }
[10:27:00.109]                 {
[10:27:00.109]                   {
[10:27:00.109]                     NULL
[10:27:00.109]                     RNGkind("Mersenne-Twister")
[10:27:00.109]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:27:00.109]                       inherits = FALSE)
[10:27:00.109]                   }
[10:27:00.109]                   options(future.plan = NULL)
[10:27:00.109]                   if (is.na(NA_character_)) 
[10:27:00.109]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:00.109]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:00.109]                   future::plan(list(function (..., envir = parent.frame()) 
[10:27:00.109]                   {
[10:27:00.109]                     future <- SequentialFuture(..., envir = envir)
[10:27:00.109]                     if (!future$lazy) 
[10:27:00.109]                       future <- run(future)
[10:27:00.109]                     invisible(future)
[10:27:00.109]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:00.109]                 }
[10:27:00.109]             }
[10:27:00.109]         }
[10:27:00.109]     })
[10:27:00.109]     if (TRUE) {
[10:27:00.109]         base::sink(type = "output", split = FALSE)
[10:27:00.109]         if (TRUE) {
[10:27:00.109]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:00.109]         }
[10:27:00.109]         else {
[10:27:00.109]             ...future.result["stdout"] <- base::list(NULL)
[10:27:00.109]         }
[10:27:00.109]         base::close(...future.stdout)
[10:27:00.109]         ...future.stdout <- NULL
[10:27:00.109]     }
[10:27:00.109]     ...future.result$conditions <- ...future.conditions
[10:27:00.109]     ...future.result$finished <- base::Sys.time()
[10:27:00.109]     ...future.result
[10:27:00.109] }
[10:27:00.110] assign_globals() ...
[10:27:00.111] List of 1
[10:27:00.111]  $ kk: int 2
[10:27:00.111]  - attr(*, "where")=List of 1
[10:27:00.111]   ..$ kk:<environment: R_EmptyEnv> 
[10:27:00.111]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:27:00.111]  - attr(*, "resolved")= logi FALSE
[10:27:00.111]  - attr(*, "total_size")= num 56
[10:27:00.111]  - attr(*, "already-done")= logi TRUE
[10:27:00.113] - copied ‘kk’ to environment
[10:27:00.116] assign_globals() ... done
[10:27:00.116] plan(): Setting new future strategy stack:
[10:27:00.116] List of future strategies:
[10:27:00.116] 1. sequential:
[10:27:00.116]    - args: function (..., envir = parent.frame())
[10:27:00.116]    - tweaked: FALSE
[10:27:00.116]    - call: NULL
[10:27:00.116] plan(): nbrOfWorkers() = 1
[10:27:00.218] plan(): Setting new future strategy stack:
[10:27:00.218] List of future strategies:
[10:27:00.218] 1. sequential:
[10:27:00.218]    - args: function (..., envir = parent.frame())
[10:27:00.218]    - tweaked: FALSE
[10:27:00.218]    - call: plan(strategy)
[10:27:00.218] plan(): nbrOfWorkers() = 1
[10:27:00.218] SequentialFuture started (and completed)
[10:27:00.219] - Launch lazy future ... done
[10:27:00.219] run() for ‘SequentialFuture’ ... done
[10:27:00.219] getGlobalsAndPackages() ...
[10:27:00.219] Searching for globals...
[10:27:00.220] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:27:00.220] Searching for globals ... DONE
[10:27:00.220] Resolving globals: FALSE
[10:27:00.221] The total size of the 1 globals is 56 bytes (56 bytes)
[10:27:00.221] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[10:27:00.221] - globals: [1] ‘kk’
[10:27:00.221] 
[10:27:00.221] getGlobalsAndPackages() ... DONE
[10:27:00.222] run() for ‘Future’ ...
[10:27:00.222] - state: ‘created’
[10:27:00.222] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:27:00.222] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:27:00.222] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:27:00.222]   - Field: ‘label’
[10:27:00.222]   - Field: ‘local’
[10:27:00.223]   - Field: ‘owner’
[10:27:00.223]   - Field: ‘envir’
[10:27:00.223]   - Field: ‘packages’
[10:27:00.223]   - Field: ‘gc’
[10:27:00.223]   - Field: ‘conditions’
[10:27:00.223]   - Field: ‘expr’
[10:27:00.223]   - Field: ‘uuid’
[10:27:00.223]   - Field: ‘seed’
[10:27:00.223]   - Field: ‘version’
[10:27:00.223]   - Field: ‘result’
[10:27:00.223]   - Field: ‘asynchronous’
[10:27:00.224]   - Field: ‘calls’
[10:27:00.224]   - Field: ‘globals’
[10:27:00.224]   - Field: ‘stdout’
[10:27:00.224]   - Field: ‘earlySignal’
[10:27:00.224]   - Field: ‘lazy’
[10:27:00.224]   - Field: ‘state’
[10:27:00.224] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:27:00.224] - Launch lazy future ...
[10:27:00.224] Packages needed by the future expression (n = 0): <none>
[10:27:00.225] Packages needed by future strategies (n = 0): <none>
[10:27:00.225] {
[10:27:00.225]     {
[10:27:00.225]         {
[10:27:00.225]             ...future.startTime <- base::Sys.time()
[10:27:00.225]             {
[10:27:00.225]                 {
[10:27:00.225]                   {
[10:27:00.225]                     base::local({
[10:27:00.225]                       has_future <- base::requireNamespace("future", 
[10:27:00.225]                         quietly = TRUE)
[10:27:00.225]                       if (has_future) {
[10:27:00.225]                         ns <- base::getNamespace("future")
[10:27:00.225]                         version <- ns[[".package"]][["version"]]
[10:27:00.225]                         if (is.null(version)) 
[10:27:00.225]                           version <- utils::packageVersion("future")
[10:27:00.225]                       }
[10:27:00.225]                       else {
[10:27:00.225]                         version <- NULL
[10:27:00.225]                       }
[10:27:00.225]                       if (!has_future || version < "1.8.0") {
[10:27:00.225]                         info <- base::c(r_version = base::gsub("R version ", 
[10:27:00.225]                           "", base::R.version$version.string), 
[10:27:00.225]                           platform = base::sprintf("%s (%s-bit)", 
[10:27:00.225]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:00.225]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:00.225]                             "release", "version")], collapse = " "), 
[10:27:00.225]                           hostname = base::Sys.info()[["nodename"]])
[10:27:00.225]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:27:00.225]                           info)
[10:27:00.225]                         info <- base::paste(info, collapse = "; ")
[10:27:00.225]                         if (!has_future) {
[10:27:00.225]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:00.225]                             info)
[10:27:00.225]                         }
[10:27:00.225]                         else {
[10:27:00.225]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:00.225]                             info, version)
[10:27:00.225]                         }
[10:27:00.225]                         base::stop(msg)
[10:27:00.225]                       }
[10:27:00.225]                     })
[10:27:00.225]                   }
[10:27:00.225]                   options(future.plan = NULL)
[10:27:00.225]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:00.225]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:00.225]                 }
[10:27:00.225]                 ...future.workdir <- getwd()
[10:27:00.225]             }
[10:27:00.225]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:00.225]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:00.225]         }
[10:27:00.225]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:00.225]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:00.225]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:00.225]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:00.225]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:00.225]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:00.225]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:00.225]             base::names(...future.oldOptions))
[10:27:00.225]     }
[10:27:00.225]     if (FALSE) {
[10:27:00.225]     }
[10:27:00.225]     else {
[10:27:00.225]         if (TRUE) {
[10:27:00.225]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:00.225]                 open = "w")
[10:27:00.225]         }
[10:27:00.225]         else {
[10:27:00.225]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:00.225]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:00.225]         }
[10:27:00.225]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:00.225]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:00.225]             base::sink(type = "output", split = FALSE)
[10:27:00.225]             base::close(...future.stdout)
[10:27:00.225]         }, add = TRUE)
[10:27:00.225]     }
[10:27:00.225]     ...future.frame <- base::sys.nframe()
[10:27:00.225]     ...future.conditions <- base::list()
[10:27:00.225]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:00.225]     if (FALSE) {
[10:27:00.225]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:00.225]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:00.225]     }
[10:27:00.225]     ...future.result <- base::tryCatch({
[10:27:00.225]         base::withCallingHandlers({
[10:27:00.225]             ...future.value <- base::withVisible(base::local({
[10:27:00.225]                 Sys.sleep(0.1)
[10:27:00.225]                 kk
[10:27:00.225]             }))
[10:27:00.225]             future::FutureResult(value = ...future.value$value, 
[10:27:00.225]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:00.225]                   ...future.rng), globalenv = if (FALSE) 
[10:27:00.225]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:00.225]                     ...future.globalenv.names))
[10:27:00.225]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:00.225]         }, condition = base::local({
[10:27:00.225]             c <- base::c
[10:27:00.225]             inherits <- base::inherits
[10:27:00.225]             invokeRestart <- base::invokeRestart
[10:27:00.225]             length <- base::length
[10:27:00.225]             list <- base::list
[10:27:00.225]             seq.int <- base::seq.int
[10:27:00.225]             signalCondition <- base::signalCondition
[10:27:00.225]             sys.calls <- base::sys.calls
[10:27:00.225]             `[[` <- base::`[[`
[10:27:00.225]             `+` <- base::`+`
[10:27:00.225]             `<<-` <- base::`<<-`
[10:27:00.225]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:00.225]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:00.225]                   3L)]
[10:27:00.225]             }
[10:27:00.225]             function(cond) {
[10:27:00.225]                 is_error <- inherits(cond, "error")
[10:27:00.225]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:00.225]                   NULL)
[10:27:00.225]                 if (is_error) {
[10:27:00.225]                   sessionInformation <- function() {
[10:27:00.225]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:00.225]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:00.225]                       search = base::search(), system = base::Sys.info())
[10:27:00.225]                   }
[10:27:00.225]                   ...future.conditions[[length(...future.conditions) + 
[10:27:00.225]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:00.225]                     cond$call), session = sessionInformation(), 
[10:27:00.225]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:00.225]                   signalCondition(cond)
[10:27:00.225]                 }
[10:27:00.225]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:00.225]                 "immediateCondition"))) {
[10:27:00.225]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:00.225]                   ...future.conditions[[length(...future.conditions) + 
[10:27:00.225]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:00.225]                   if (TRUE && !signal) {
[10:27:00.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:00.225]                     {
[10:27:00.225]                       inherits <- base::inherits
[10:27:00.225]                       invokeRestart <- base::invokeRestart
[10:27:00.225]                       is.null <- base::is.null
[10:27:00.225]                       muffled <- FALSE
[10:27:00.225]                       if (inherits(cond, "message")) {
[10:27:00.225]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:00.225]                         if (muffled) 
[10:27:00.225]                           invokeRestart("muffleMessage")
[10:27:00.225]                       }
[10:27:00.225]                       else if (inherits(cond, "warning")) {
[10:27:00.225]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:00.225]                         if (muffled) 
[10:27:00.225]                           invokeRestart("muffleWarning")
[10:27:00.225]                       }
[10:27:00.225]                       else if (inherits(cond, "condition")) {
[10:27:00.225]                         if (!is.null(pattern)) {
[10:27:00.225]                           computeRestarts <- base::computeRestarts
[10:27:00.225]                           grepl <- base::grepl
[10:27:00.225]                           restarts <- computeRestarts(cond)
[10:27:00.225]                           for (restart in restarts) {
[10:27:00.225]                             name <- restart$name
[10:27:00.225]                             if (is.null(name)) 
[10:27:00.225]                               next
[10:27:00.225]                             if (!grepl(pattern, name)) 
[10:27:00.225]                               next
[10:27:00.225]                             invokeRestart(restart)
[10:27:00.225]                             muffled <- TRUE
[10:27:00.225]                             break
[10:27:00.225]                           }
[10:27:00.225]                         }
[10:27:00.225]                       }
[10:27:00.225]                       invisible(muffled)
[10:27:00.225]                     }
[10:27:00.225]                     muffleCondition(cond, pattern = "^muffle")
[10:27:00.225]                   }
[10:27:00.225]                 }
[10:27:00.225]                 else {
[10:27:00.225]                   if (TRUE) {
[10:27:00.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:00.225]                     {
[10:27:00.225]                       inherits <- base::inherits
[10:27:00.225]                       invokeRestart <- base::invokeRestart
[10:27:00.225]                       is.null <- base::is.null
[10:27:00.225]                       muffled <- FALSE
[10:27:00.225]                       if (inherits(cond, "message")) {
[10:27:00.225]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:00.225]                         if (muffled) 
[10:27:00.225]                           invokeRestart("muffleMessage")
[10:27:00.225]                       }
[10:27:00.225]                       else if (inherits(cond, "warning")) {
[10:27:00.225]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:00.225]                         if (muffled) 
[10:27:00.225]                           invokeRestart("muffleWarning")
[10:27:00.225]                       }
[10:27:00.225]                       else if (inherits(cond, "condition")) {
[10:27:00.225]                         if (!is.null(pattern)) {
[10:27:00.225]                           computeRestarts <- base::computeRestarts
[10:27:00.225]                           grepl <- base::grepl
[10:27:00.225]                           restarts <- computeRestarts(cond)
[10:27:00.225]                           for (restart in restarts) {
[10:27:00.225]                             name <- restart$name
[10:27:00.225]                             if (is.null(name)) 
[10:27:00.225]                               next
[10:27:00.225]                             if (!grepl(pattern, name)) 
[10:27:00.225]                               next
[10:27:00.225]                             invokeRestart(restart)
[10:27:00.225]                             muffled <- TRUE
[10:27:00.225]                             break
[10:27:00.225]                           }
[10:27:00.225]                         }
[10:27:00.225]                       }
[10:27:00.225]                       invisible(muffled)
[10:27:00.225]                     }
[10:27:00.225]                     muffleCondition(cond, pattern = "^muffle")
[10:27:00.225]                   }
[10:27:00.225]                 }
[10:27:00.225]             }
[10:27:00.225]         }))
[10:27:00.225]     }, error = function(ex) {
[10:27:00.225]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:00.225]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:00.225]                 ...future.rng), started = ...future.startTime, 
[10:27:00.225]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:00.225]             version = "1.8"), class = "FutureResult")
[10:27:00.225]     }, finally = {
[10:27:00.225]         if (!identical(...future.workdir, getwd())) 
[10:27:00.225]             setwd(...future.workdir)
[10:27:00.225]         {
[10:27:00.225]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:00.225]                 ...future.oldOptions$nwarnings <- NULL
[10:27:00.225]             }
[10:27:00.225]             base::options(...future.oldOptions)
[10:27:00.225]             if (.Platform$OS.type == "windows") {
[10:27:00.225]                 old_names <- names(...future.oldEnvVars)
[10:27:00.225]                 envs <- base::Sys.getenv()
[10:27:00.225]                 names <- names(envs)
[10:27:00.225]                 common <- intersect(names, old_names)
[10:27:00.225]                 added <- setdiff(names, old_names)
[10:27:00.225]                 removed <- setdiff(old_names, names)
[10:27:00.225]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:00.225]                   envs[common]]
[10:27:00.225]                 NAMES <- toupper(changed)
[10:27:00.225]                 args <- list()
[10:27:00.225]                 for (kk in seq_along(NAMES)) {
[10:27:00.225]                   name <- changed[[kk]]
[10:27:00.225]                   NAME <- NAMES[[kk]]
[10:27:00.225]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.225]                     next
[10:27:00.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:00.225]                 }
[10:27:00.225]                 NAMES <- toupper(added)
[10:27:00.225]                 for (kk in seq_along(NAMES)) {
[10:27:00.225]                   name <- added[[kk]]
[10:27:00.225]                   NAME <- NAMES[[kk]]
[10:27:00.225]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.225]                     next
[10:27:00.225]                   args[[name]] <- ""
[10:27:00.225]                 }
[10:27:00.225]                 NAMES <- toupper(removed)
[10:27:00.225]                 for (kk in seq_along(NAMES)) {
[10:27:00.225]                   name <- removed[[kk]]
[10:27:00.225]                   NAME <- NAMES[[kk]]
[10:27:00.225]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.225]                     next
[10:27:00.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:00.225]                 }
[10:27:00.225]                 if (length(args) > 0) 
[10:27:00.225]                   base::do.call(base::Sys.setenv, args = args)
[10:27:00.225]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:00.225]             }
[10:27:00.225]             else {
[10:27:00.225]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:00.225]             }
[10:27:00.225]             {
[10:27:00.225]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:00.225]                   0L) {
[10:27:00.225]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:00.225]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:00.225]                   base::options(opts)
[10:27:00.225]                 }
[10:27:00.225]                 {
[10:27:00.225]                   {
[10:27:00.225]                     NULL
[10:27:00.225]                     RNGkind("Mersenne-Twister")
[10:27:00.225]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:27:00.225]                       inherits = FALSE)
[10:27:00.225]                   }
[10:27:00.225]                   options(future.plan = NULL)
[10:27:00.225]                   if (is.na(NA_character_)) 
[10:27:00.225]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:00.225]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:00.225]                   future::plan(list(function (..., envir = parent.frame()) 
[10:27:00.225]                   {
[10:27:00.225]                     future <- SequentialFuture(..., envir = envir)
[10:27:00.225]                     if (!future$lazy) 
[10:27:00.225]                       future <- run(future)
[10:27:00.225]                     invisible(future)
[10:27:00.225]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:00.225]                 }
[10:27:00.225]             }
[10:27:00.225]         }
[10:27:00.225]     })
[10:27:00.225]     if (TRUE) {
[10:27:00.225]         base::sink(type = "output", split = FALSE)
[10:27:00.225]         if (TRUE) {
[10:27:00.225]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:00.225]         }
[10:27:00.225]         else {
[10:27:00.225]             ...future.result["stdout"] <- base::list(NULL)
[10:27:00.225]         }
[10:27:00.225]         base::close(...future.stdout)
[10:27:00.225]         ...future.stdout <- NULL
[10:27:00.225]     }
[10:27:00.225]     ...future.result$conditions <- ...future.conditions
[10:27:00.225]     ...future.result$finished <- base::Sys.time()
[10:27:00.225]     ...future.result
[10:27:00.225] }
[10:27:00.227] assign_globals() ...
[10:27:00.227] List of 1
[10:27:00.227]  $ kk: int 3
[10:27:00.227]  - attr(*, "where")=List of 1
[10:27:00.227]   ..$ kk:<environment: R_EmptyEnv> 
[10:27:00.227]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:27:00.227]  - attr(*, "resolved")= logi FALSE
[10:27:00.227]  - attr(*, "total_size")= num 56
[10:27:00.227]  - attr(*, "already-done")= logi TRUE
[10:27:00.229] - copied ‘kk’ to environment
[10:27:00.229] assign_globals() ... done
[10:27:00.230] plan(): Setting new future strategy stack:
[10:27:00.230] List of future strategies:
[10:27:00.230] 1. sequential:
[10:27:00.230]    - args: function (..., envir = parent.frame())
[10:27:00.230]    - tweaked: FALSE
[10:27:00.230]    - call: NULL
[10:27:00.230] plan(): nbrOfWorkers() = 1
[10:27:00.331] plan(): Setting new future strategy stack:
[10:27:00.331] List of future strategies:
[10:27:00.331] 1. sequential:
[10:27:00.331]    - args: function (..., envir = parent.frame())
[10:27:00.331]    - tweaked: FALSE
[10:27:00.331]    - call: plan(strategy)
[10:27:00.332] plan(): nbrOfWorkers() = 1
[10:27:00.332] SequentialFuture started (and completed)
[10:27:00.332] - Launch lazy future ... done
[10:27:00.332] run() for ‘SequentialFuture’ ... done
[10:27:00.333] resolve() on list ...
[10:27:00.333]  recursive: 0
[10:27:00.333]  length: 3
[10:27:00.333] 
[10:27:00.333] resolved() for ‘SequentialFuture’ ...
[10:27:00.333] - state: ‘finished’
[10:27:00.333] - run: TRUE
[10:27:00.333] - result: ‘FutureResult’
[10:27:00.333] resolved() for ‘SequentialFuture’ ... done
[10:27:00.333] Future #1
[10:27:00.334]  length: 2 (resolved future 1)
[10:27:00.334] resolved() for ‘SequentialFuture’ ...
[10:27:00.334] - state: ‘finished’
[10:27:00.334] - run: TRUE
[10:27:00.334] - result: ‘FutureResult’
[10:27:00.334] resolved() for ‘SequentialFuture’ ... done
[10:27:00.334] Future #2
[10:27:00.334]  length: 1 (resolved future 2)
[10:27:00.334] resolved() for ‘SequentialFuture’ ...
[10:27:00.334] - state: ‘finished’
[10:27:00.335] - run: TRUE
[10:27:00.335] - result: ‘FutureResult’
[10:27:00.335] resolved() for ‘SequentialFuture’ ... done
[10:27:00.335] Future #3
[10:27:00.335]  length: 0 (resolved future 3)
[10:27:00.335] resolve() on list ... DONE
[10:27:00.335] getGlobalsAndPackages() ...
[10:27:00.335] Searching for globals...
[10:27:00.336] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:27:00.336] Searching for globals ... DONE
[10:27:00.336] Resolving globals: FALSE
[10:27:00.337] The total size of the 1 globals is 56 bytes (56 bytes)
[10:27:00.337] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[10:27:00.337] - globals: [1] ‘kk’
[10:27:00.337] 
[10:27:00.338] getGlobalsAndPackages() ... DONE
[10:27:00.338] getGlobalsAndPackages() ...
[10:27:00.338] Searching for globals...
[10:27:00.339] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:27:00.339] Searching for globals ... DONE
[10:27:00.339] Resolving globals: FALSE
[10:27:00.340] The total size of the 1 globals is 56 bytes (56 bytes)
[10:27:00.340] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[10:27:00.340] - globals: [1] ‘kk’
[10:27:00.340] 
[10:27:00.340] getGlobalsAndPackages() ... DONE
[10:27:00.341] getGlobalsAndPackages() ...
[10:27:00.341] Searching for globals...
[10:27:00.342] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:27:00.342] Searching for globals ... DONE
[10:27:00.342] Resolving globals: FALSE
[10:27:00.342] The total size of the 1 globals is 56 bytes (56 bytes)
[10:27:00.342] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[10:27:00.343] - globals: [1] ‘kk’
[10:27:00.343] 
[10:27:00.343] getGlobalsAndPackages() ... DONE
[10:27:00.343] resolve() on list ...
[10:27:00.343]  recursive: 0
[10:27:00.343]  length: 3
[10:27:00.343] 
[10:27:00.343] run() for ‘Future’ ...
[10:27:00.343] - state: ‘created’
[10:27:00.344] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:27:00.346] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:27:00.346] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:27:00.346]   - Field: ‘label’
[10:27:00.346]   - Field: ‘local’
[10:27:00.346]   - Field: ‘owner’
[10:27:00.346]   - Field: ‘envir’
[10:27:00.346]   - Field: ‘packages’
[10:27:00.347]   - Field: ‘gc’
[10:27:00.347]   - Field: ‘conditions’
[10:27:00.347]   - Field: ‘expr’
[10:27:00.347]   - Field: ‘uuid’
[10:27:00.347]   - Field: ‘seed’
[10:27:00.347]   - Field: ‘version’
[10:27:00.347]   - Field: ‘result’
[10:27:00.347]   - Field: ‘asynchronous’
[10:27:00.347]   - Field: ‘calls’
[10:27:00.347]   - Field: ‘globals’
[10:27:00.348]   - Field: ‘stdout’
[10:27:00.348]   - Field: ‘earlySignal’
[10:27:00.348]   - Field: ‘lazy’
[10:27:00.348]   - Field: ‘state’
[10:27:00.348] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:27:00.348] - Launch lazy future ...
[10:27:00.348] Packages needed by the future expression (n = 0): <none>
[10:27:00.348] Packages needed by future strategies (n = 0): <none>
[10:27:00.349] {
[10:27:00.349]     {
[10:27:00.349]         {
[10:27:00.349]             ...future.startTime <- base::Sys.time()
[10:27:00.349]             {
[10:27:00.349]                 {
[10:27:00.349]                   {
[10:27:00.349]                     base::local({
[10:27:00.349]                       has_future <- base::requireNamespace("future", 
[10:27:00.349]                         quietly = TRUE)
[10:27:00.349]                       if (has_future) {
[10:27:00.349]                         ns <- base::getNamespace("future")
[10:27:00.349]                         version <- ns[[".package"]][["version"]]
[10:27:00.349]                         if (is.null(version)) 
[10:27:00.349]                           version <- utils::packageVersion("future")
[10:27:00.349]                       }
[10:27:00.349]                       else {
[10:27:00.349]                         version <- NULL
[10:27:00.349]                       }
[10:27:00.349]                       if (!has_future || version < "1.8.0") {
[10:27:00.349]                         info <- base::c(r_version = base::gsub("R version ", 
[10:27:00.349]                           "", base::R.version$version.string), 
[10:27:00.349]                           platform = base::sprintf("%s (%s-bit)", 
[10:27:00.349]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:00.349]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:00.349]                             "release", "version")], collapse = " "), 
[10:27:00.349]                           hostname = base::Sys.info()[["nodename"]])
[10:27:00.349]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:27:00.349]                           info)
[10:27:00.349]                         info <- base::paste(info, collapse = "; ")
[10:27:00.349]                         if (!has_future) {
[10:27:00.349]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:00.349]                             info)
[10:27:00.349]                         }
[10:27:00.349]                         else {
[10:27:00.349]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:00.349]                             info, version)
[10:27:00.349]                         }
[10:27:00.349]                         base::stop(msg)
[10:27:00.349]                       }
[10:27:00.349]                     })
[10:27:00.349]                   }
[10:27:00.349]                   options(future.plan = NULL)
[10:27:00.349]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:00.349]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:00.349]                 }
[10:27:00.349]                 ...future.workdir <- getwd()
[10:27:00.349]             }
[10:27:00.349]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:00.349]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:00.349]         }
[10:27:00.349]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:00.349]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:00.349]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:00.349]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:00.349]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:00.349]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:00.349]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:00.349]             base::names(...future.oldOptions))
[10:27:00.349]     }
[10:27:00.349]     if (FALSE) {
[10:27:00.349]     }
[10:27:00.349]     else {
[10:27:00.349]         if (TRUE) {
[10:27:00.349]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:00.349]                 open = "w")
[10:27:00.349]         }
[10:27:00.349]         else {
[10:27:00.349]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:00.349]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:00.349]         }
[10:27:00.349]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:00.349]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:00.349]             base::sink(type = "output", split = FALSE)
[10:27:00.349]             base::close(...future.stdout)
[10:27:00.349]         }, add = TRUE)
[10:27:00.349]     }
[10:27:00.349]     ...future.frame <- base::sys.nframe()
[10:27:00.349]     ...future.conditions <- base::list()
[10:27:00.349]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:00.349]     if (FALSE) {
[10:27:00.349]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:00.349]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:00.349]     }
[10:27:00.349]     ...future.result <- base::tryCatch({
[10:27:00.349]         base::withCallingHandlers({
[10:27:00.349]             ...future.value <- base::withVisible(base::local({
[10:27:00.349]                 Sys.sleep(0.1)
[10:27:00.349]                 kk
[10:27:00.349]             }))
[10:27:00.349]             future::FutureResult(value = ...future.value$value, 
[10:27:00.349]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:00.349]                   ...future.rng), globalenv = if (FALSE) 
[10:27:00.349]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:00.349]                     ...future.globalenv.names))
[10:27:00.349]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:00.349]         }, condition = base::local({
[10:27:00.349]             c <- base::c
[10:27:00.349]             inherits <- base::inherits
[10:27:00.349]             invokeRestart <- base::invokeRestart
[10:27:00.349]             length <- base::length
[10:27:00.349]             list <- base::list
[10:27:00.349]             seq.int <- base::seq.int
[10:27:00.349]             signalCondition <- base::signalCondition
[10:27:00.349]             sys.calls <- base::sys.calls
[10:27:00.349]             `[[` <- base::`[[`
[10:27:00.349]             `+` <- base::`+`
[10:27:00.349]             `<<-` <- base::`<<-`
[10:27:00.349]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:00.349]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:00.349]                   3L)]
[10:27:00.349]             }
[10:27:00.349]             function(cond) {
[10:27:00.349]                 is_error <- inherits(cond, "error")
[10:27:00.349]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:00.349]                   NULL)
[10:27:00.349]                 if (is_error) {
[10:27:00.349]                   sessionInformation <- function() {
[10:27:00.349]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:00.349]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:00.349]                       search = base::search(), system = base::Sys.info())
[10:27:00.349]                   }
[10:27:00.349]                   ...future.conditions[[length(...future.conditions) + 
[10:27:00.349]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:00.349]                     cond$call), session = sessionInformation(), 
[10:27:00.349]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:00.349]                   signalCondition(cond)
[10:27:00.349]                 }
[10:27:00.349]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:00.349]                 "immediateCondition"))) {
[10:27:00.349]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:00.349]                   ...future.conditions[[length(...future.conditions) + 
[10:27:00.349]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:00.349]                   if (TRUE && !signal) {
[10:27:00.349]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:00.349]                     {
[10:27:00.349]                       inherits <- base::inherits
[10:27:00.349]                       invokeRestart <- base::invokeRestart
[10:27:00.349]                       is.null <- base::is.null
[10:27:00.349]                       muffled <- FALSE
[10:27:00.349]                       if (inherits(cond, "message")) {
[10:27:00.349]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:00.349]                         if (muffled) 
[10:27:00.349]                           invokeRestart("muffleMessage")
[10:27:00.349]                       }
[10:27:00.349]                       else if (inherits(cond, "warning")) {
[10:27:00.349]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:00.349]                         if (muffled) 
[10:27:00.349]                           invokeRestart("muffleWarning")
[10:27:00.349]                       }
[10:27:00.349]                       else if (inherits(cond, "condition")) {
[10:27:00.349]                         if (!is.null(pattern)) {
[10:27:00.349]                           computeRestarts <- base::computeRestarts
[10:27:00.349]                           grepl <- base::grepl
[10:27:00.349]                           restarts <- computeRestarts(cond)
[10:27:00.349]                           for (restart in restarts) {
[10:27:00.349]                             name <- restart$name
[10:27:00.349]                             if (is.null(name)) 
[10:27:00.349]                               next
[10:27:00.349]                             if (!grepl(pattern, name)) 
[10:27:00.349]                               next
[10:27:00.349]                             invokeRestart(restart)
[10:27:00.349]                             muffled <- TRUE
[10:27:00.349]                             break
[10:27:00.349]                           }
[10:27:00.349]                         }
[10:27:00.349]                       }
[10:27:00.349]                       invisible(muffled)
[10:27:00.349]                     }
[10:27:00.349]                     muffleCondition(cond, pattern = "^muffle")
[10:27:00.349]                   }
[10:27:00.349]                 }
[10:27:00.349]                 else {
[10:27:00.349]                   if (TRUE) {
[10:27:00.349]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:00.349]                     {
[10:27:00.349]                       inherits <- base::inherits
[10:27:00.349]                       invokeRestart <- base::invokeRestart
[10:27:00.349]                       is.null <- base::is.null
[10:27:00.349]                       muffled <- FALSE
[10:27:00.349]                       if (inherits(cond, "message")) {
[10:27:00.349]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:00.349]                         if (muffled) 
[10:27:00.349]                           invokeRestart("muffleMessage")
[10:27:00.349]                       }
[10:27:00.349]                       else if (inherits(cond, "warning")) {
[10:27:00.349]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:00.349]                         if (muffled) 
[10:27:00.349]                           invokeRestart("muffleWarning")
[10:27:00.349]                       }
[10:27:00.349]                       else if (inherits(cond, "condition")) {
[10:27:00.349]                         if (!is.null(pattern)) {
[10:27:00.349]                           computeRestarts <- base::computeRestarts
[10:27:00.349]                           grepl <- base::grepl
[10:27:00.349]                           restarts <- computeRestarts(cond)
[10:27:00.349]                           for (restart in restarts) {
[10:27:00.349]                             name <- restart$name
[10:27:00.349]                             if (is.null(name)) 
[10:27:00.349]                               next
[10:27:00.349]                             if (!grepl(pattern, name)) 
[10:27:00.349]                               next
[10:27:00.349]                             invokeRestart(restart)
[10:27:00.349]                             muffled <- TRUE
[10:27:00.349]                             break
[10:27:00.349]                           }
[10:27:00.349]                         }
[10:27:00.349]                       }
[10:27:00.349]                       invisible(muffled)
[10:27:00.349]                     }
[10:27:00.349]                     muffleCondition(cond, pattern = "^muffle")
[10:27:00.349]                   }
[10:27:00.349]                 }
[10:27:00.349]             }
[10:27:00.349]         }))
[10:27:00.349]     }, error = function(ex) {
[10:27:00.349]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:00.349]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:00.349]                 ...future.rng), started = ...future.startTime, 
[10:27:00.349]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:00.349]             version = "1.8"), class = "FutureResult")
[10:27:00.349]     }, finally = {
[10:27:00.349]         if (!identical(...future.workdir, getwd())) 
[10:27:00.349]             setwd(...future.workdir)
[10:27:00.349]         {
[10:27:00.349]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:00.349]                 ...future.oldOptions$nwarnings <- NULL
[10:27:00.349]             }
[10:27:00.349]             base::options(...future.oldOptions)
[10:27:00.349]             if (.Platform$OS.type == "windows") {
[10:27:00.349]                 old_names <- names(...future.oldEnvVars)
[10:27:00.349]                 envs <- base::Sys.getenv()
[10:27:00.349]                 names <- names(envs)
[10:27:00.349]                 common <- intersect(names, old_names)
[10:27:00.349]                 added <- setdiff(names, old_names)
[10:27:00.349]                 removed <- setdiff(old_names, names)
[10:27:00.349]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:00.349]                   envs[common]]
[10:27:00.349]                 NAMES <- toupper(changed)
[10:27:00.349]                 args <- list()
[10:27:00.349]                 for (kk in seq_along(NAMES)) {
[10:27:00.349]                   name <- changed[[kk]]
[10:27:00.349]                   NAME <- NAMES[[kk]]
[10:27:00.349]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.349]                     next
[10:27:00.349]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:00.349]                 }
[10:27:00.349]                 NAMES <- toupper(added)
[10:27:00.349]                 for (kk in seq_along(NAMES)) {
[10:27:00.349]                   name <- added[[kk]]
[10:27:00.349]                   NAME <- NAMES[[kk]]
[10:27:00.349]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.349]                     next
[10:27:00.349]                   args[[name]] <- ""
[10:27:00.349]                 }
[10:27:00.349]                 NAMES <- toupper(removed)
[10:27:00.349]                 for (kk in seq_along(NAMES)) {
[10:27:00.349]                   name <- removed[[kk]]
[10:27:00.349]                   NAME <- NAMES[[kk]]
[10:27:00.349]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.349]                     next
[10:27:00.349]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:00.349]                 }
[10:27:00.349]                 if (length(args) > 0) 
[10:27:00.349]                   base::do.call(base::Sys.setenv, args = args)
[10:27:00.349]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:00.349]             }
[10:27:00.349]             else {
[10:27:00.349]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:00.349]             }
[10:27:00.349]             {
[10:27:00.349]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:00.349]                   0L) {
[10:27:00.349]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:00.349]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:00.349]                   base::options(opts)
[10:27:00.349]                 }
[10:27:00.349]                 {
[10:27:00.349]                   {
[10:27:00.349]                     NULL
[10:27:00.349]                     RNGkind("Mersenne-Twister")
[10:27:00.349]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:27:00.349]                       inherits = FALSE)
[10:27:00.349]                   }
[10:27:00.349]                   options(future.plan = NULL)
[10:27:00.349]                   if (is.na(NA_character_)) 
[10:27:00.349]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:00.349]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:00.349]                   future::plan(list(function (..., envir = parent.frame()) 
[10:27:00.349]                   {
[10:27:00.349]                     future <- SequentialFuture(..., envir = envir)
[10:27:00.349]                     if (!future$lazy) 
[10:27:00.349]                       future <- run(future)
[10:27:00.349]                     invisible(future)
[10:27:00.349]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:00.349]                 }
[10:27:00.349]             }
[10:27:00.349]         }
[10:27:00.349]     })
[10:27:00.349]     if (TRUE) {
[10:27:00.349]         base::sink(type = "output", split = FALSE)
[10:27:00.349]         if (TRUE) {
[10:27:00.349]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:00.349]         }
[10:27:00.349]         else {
[10:27:00.349]             ...future.result["stdout"] <- base::list(NULL)
[10:27:00.349]         }
[10:27:00.349]         base::close(...future.stdout)
[10:27:00.349]         ...future.stdout <- NULL
[10:27:00.349]     }
[10:27:00.349]     ...future.result$conditions <- ...future.conditions
[10:27:00.349]     ...future.result$finished <- base::Sys.time()
[10:27:00.349]     ...future.result
[10:27:00.349] }
[10:27:00.350] assign_globals() ...
[10:27:00.351] List of 1
[10:27:00.351]  $ kk: int 1
[10:27:00.351]  - attr(*, "where")=List of 1
[10:27:00.351]   ..$ kk:<environment: R_EmptyEnv> 
[10:27:00.351]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:27:00.351]  - attr(*, "resolved")= logi FALSE
[10:27:00.351]  - attr(*, "total_size")= num 56
[10:27:00.351]  - attr(*, "already-done")= logi TRUE
[10:27:00.353] - copied ‘kk’ to environment
[10:27:00.353] assign_globals() ... done
[10:27:00.354] plan(): Setting new future strategy stack:
[10:27:00.354] List of future strategies:
[10:27:00.354] 1. sequential:
[10:27:00.354]    - args: function (..., envir = parent.frame())
[10:27:00.354]    - tweaked: FALSE
[10:27:00.354]    - call: NULL
[10:27:00.354] plan(): nbrOfWorkers() = 1
[10:27:00.455] plan(): Setting new future strategy stack:
[10:27:00.456] List of future strategies:
[10:27:00.456] 1. sequential:
[10:27:00.456]    - args: function (..., envir = parent.frame())
[10:27:00.456]    - tweaked: FALSE
[10:27:00.456]    - call: plan(strategy)
[10:27:00.457] plan(): nbrOfWorkers() = 1
[10:27:00.457] SequentialFuture started (and completed)
[10:27:00.457] - Launch lazy future ... done
[10:27:00.457] run() for ‘SequentialFuture’ ... done
[10:27:00.457] resolved() for ‘SequentialFuture’ ...
[10:27:00.457] - state: ‘finished’
[10:27:00.458] - run: TRUE
[10:27:00.458] - result: ‘FutureResult’
[10:27:00.458] resolved() for ‘SequentialFuture’ ... done
[10:27:00.458] Future #1
[10:27:00.458]  length: 2 (resolved future 1)
[10:27:00.458] run() for ‘Future’ ...
[10:27:00.458] - state: ‘created’
[10:27:00.458] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:27:00.459] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:27:00.459] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:27:00.459]   - Field: ‘label’
[10:27:00.459]   - Field: ‘local’
[10:27:00.459]   - Field: ‘owner’
[10:27:00.459]   - Field: ‘envir’
[10:27:00.459]   - Field: ‘packages’
[10:27:00.459]   - Field: ‘gc’
[10:27:00.460]   - Field: ‘conditions’
[10:27:00.460]   - Field: ‘expr’
[10:27:00.460]   - Field: ‘uuid’
[10:27:00.460]   - Field: ‘seed’
[10:27:00.460]   - Field: ‘version’
[10:27:00.460]   - Field: ‘result’
[10:27:00.460]   - Field: ‘asynchronous’
[10:27:00.460]   - Field: ‘calls’
[10:27:00.460]   - Field: ‘globals’
[10:27:00.460]   - Field: ‘stdout’
[10:27:00.461]   - Field: ‘earlySignal’
[10:27:00.461]   - Field: ‘lazy’
[10:27:00.461]   - Field: ‘state’
[10:27:00.461] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:27:00.461] - Launch lazy future ...
[10:27:00.461] Packages needed by the future expression (n = 0): <none>
[10:27:00.461] Packages needed by future strategies (n = 0): <none>
[10:27:00.462] {
[10:27:00.462]     {
[10:27:00.462]         {
[10:27:00.462]             ...future.startTime <- base::Sys.time()
[10:27:00.462]             {
[10:27:00.462]                 {
[10:27:00.462]                   {
[10:27:00.462]                     base::local({
[10:27:00.462]                       has_future <- base::requireNamespace("future", 
[10:27:00.462]                         quietly = TRUE)
[10:27:00.462]                       if (has_future) {
[10:27:00.462]                         ns <- base::getNamespace("future")
[10:27:00.462]                         version <- ns[[".package"]][["version"]]
[10:27:00.462]                         if (is.null(version)) 
[10:27:00.462]                           version <- utils::packageVersion("future")
[10:27:00.462]                       }
[10:27:00.462]                       else {
[10:27:00.462]                         version <- NULL
[10:27:00.462]                       }
[10:27:00.462]                       if (!has_future || version < "1.8.0") {
[10:27:00.462]                         info <- base::c(r_version = base::gsub("R version ", 
[10:27:00.462]                           "", base::R.version$version.string), 
[10:27:00.462]                           platform = base::sprintf("%s (%s-bit)", 
[10:27:00.462]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:00.462]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:00.462]                             "release", "version")], collapse = " "), 
[10:27:00.462]                           hostname = base::Sys.info()[["nodename"]])
[10:27:00.462]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:27:00.462]                           info)
[10:27:00.462]                         info <- base::paste(info, collapse = "; ")
[10:27:00.462]                         if (!has_future) {
[10:27:00.462]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:00.462]                             info)
[10:27:00.462]                         }
[10:27:00.462]                         else {
[10:27:00.462]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:00.462]                             info, version)
[10:27:00.462]                         }
[10:27:00.462]                         base::stop(msg)
[10:27:00.462]                       }
[10:27:00.462]                     })
[10:27:00.462]                   }
[10:27:00.462]                   options(future.plan = NULL)
[10:27:00.462]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:00.462]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:00.462]                 }
[10:27:00.462]                 ...future.workdir <- getwd()
[10:27:00.462]             }
[10:27:00.462]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:00.462]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:00.462]         }
[10:27:00.462]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:00.462]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:00.462]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:00.462]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:00.462]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:00.462]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:00.462]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:00.462]             base::names(...future.oldOptions))
[10:27:00.462]     }
[10:27:00.462]     if (FALSE) {
[10:27:00.462]     }
[10:27:00.462]     else {
[10:27:00.462]         if (TRUE) {
[10:27:00.462]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:00.462]                 open = "w")
[10:27:00.462]         }
[10:27:00.462]         else {
[10:27:00.462]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:00.462]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:00.462]         }
[10:27:00.462]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:00.462]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:00.462]             base::sink(type = "output", split = FALSE)
[10:27:00.462]             base::close(...future.stdout)
[10:27:00.462]         }, add = TRUE)
[10:27:00.462]     }
[10:27:00.462]     ...future.frame <- base::sys.nframe()
[10:27:00.462]     ...future.conditions <- base::list()
[10:27:00.462]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:00.462]     if (FALSE) {
[10:27:00.462]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:00.462]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:00.462]     }
[10:27:00.462]     ...future.result <- base::tryCatch({
[10:27:00.462]         base::withCallingHandlers({
[10:27:00.462]             ...future.value <- base::withVisible(base::local({
[10:27:00.462]                 Sys.sleep(0.1)
[10:27:00.462]                 kk
[10:27:00.462]             }))
[10:27:00.462]             future::FutureResult(value = ...future.value$value, 
[10:27:00.462]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:00.462]                   ...future.rng), globalenv = if (FALSE) 
[10:27:00.462]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:00.462]                     ...future.globalenv.names))
[10:27:00.462]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:00.462]         }, condition = base::local({
[10:27:00.462]             c <- base::c
[10:27:00.462]             inherits <- base::inherits
[10:27:00.462]             invokeRestart <- base::invokeRestart
[10:27:00.462]             length <- base::length
[10:27:00.462]             list <- base::list
[10:27:00.462]             seq.int <- base::seq.int
[10:27:00.462]             signalCondition <- base::signalCondition
[10:27:00.462]             sys.calls <- base::sys.calls
[10:27:00.462]             `[[` <- base::`[[`
[10:27:00.462]             `+` <- base::`+`
[10:27:00.462]             `<<-` <- base::`<<-`
[10:27:00.462]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:00.462]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:00.462]                   3L)]
[10:27:00.462]             }
[10:27:00.462]             function(cond) {
[10:27:00.462]                 is_error <- inherits(cond, "error")
[10:27:00.462]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:00.462]                   NULL)
[10:27:00.462]                 if (is_error) {
[10:27:00.462]                   sessionInformation <- function() {
[10:27:00.462]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:00.462]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:00.462]                       search = base::search(), system = base::Sys.info())
[10:27:00.462]                   }
[10:27:00.462]                   ...future.conditions[[length(...future.conditions) + 
[10:27:00.462]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:00.462]                     cond$call), session = sessionInformation(), 
[10:27:00.462]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:00.462]                   signalCondition(cond)
[10:27:00.462]                 }
[10:27:00.462]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:00.462]                 "immediateCondition"))) {
[10:27:00.462]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:00.462]                   ...future.conditions[[length(...future.conditions) + 
[10:27:00.462]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:00.462]                   if (TRUE && !signal) {
[10:27:00.462]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:00.462]                     {
[10:27:00.462]                       inherits <- base::inherits
[10:27:00.462]                       invokeRestart <- base::invokeRestart
[10:27:00.462]                       is.null <- base::is.null
[10:27:00.462]                       muffled <- FALSE
[10:27:00.462]                       if (inherits(cond, "message")) {
[10:27:00.462]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:00.462]                         if (muffled) 
[10:27:00.462]                           invokeRestart("muffleMessage")
[10:27:00.462]                       }
[10:27:00.462]                       else if (inherits(cond, "warning")) {
[10:27:00.462]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:00.462]                         if (muffled) 
[10:27:00.462]                           invokeRestart("muffleWarning")
[10:27:00.462]                       }
[10:27:00.462]                       else if (inherits(cond, "condition")) {
[10:27:00.462]                         if (!is.null(pattern)) {
[10:27:00.462]                           computeRestarts <- base::computeRestarts
[10:27:00.462]                           grepl <- base::grepl
[10:27:00.462]                           restarts <- computeRestarts(cond)
[10:27:00.462]                           for (restart in restarts) {
[10:27:00.462]                             name <- restart$name
[10:27:00.462]                             if (is.null(name)) 
[10:27:00.462]                               next
[10:27:00.462]                             if (!grepl(pattern, name)) 
[10:27:00.462]                               next
[10:27:00.462]                             invokeRestart(restart)
[10:27:00.462]                             muffled <- TRUE
[10:27:00.462]                             break
[10:27:00.462]                           }
[10:27:00.462]                         }
[10:27:00.462]                       }
[10:27:00.462]                       invisible(muffled)
[10:27:00.462]                     }
[10:27:00.462]                     muffleCondition(cond, pattern = "^muffle")
[10:27:00.462]                   }
[10:27:00.462]                 }
[10:27:00.462]                 else {
[10:27:00.462]                   if (TRUE) {
[10:27:00.462]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:00.462]                     {
[10:27:00.462]                       inherits <- base::inherits
[10:27:00.462]                       invokeRestart <- base::invokeRestart
[10:27:00.462]                       is.null <- base::is.null
[10:27:00.462]                       muffled <- FALSE
[10:27:00.462]                       if (inherits(cond, "message")) {
[10:27:00.462]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:00.462]                         if (muffled) 
[10:27:00.462]                           invokeRestart("muffleMessage")
[10:27:00.462]                       }
[10:27:00.462]                       else if (inherits(cond, "warning")) {
[10:27:00.462]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:00.462]                         if (muffled) 
[10:27:00.462]                           invokeRestart("muffleWarning")
[10:27:00.462]                       }
[10:27:00.462]                       else if (inherits(cond, "condition")) {
[10:27:00.462]                         if (!is.null(pattern)) {
[10:27:00.462]                           computeRestarts <- base::computeRestarts
[10:27:00.462]                           grepl <- base::grepl
[10:27:00.462]                           restarts <- computeRestarts(cond)
[10:27:00.462]                           for (restart in restarts) {
[10:27:00.462]                             name <- restart$name
[10:27:00.462]                             if (is.null(name)) 
[10:27:00.462]                               next
[10:27:00.462]                             if (!grepl(pattern, name)) 
[10:27:00.462]                               next
[10:27:00.462]                             invokeRestart(restart)
[10:27:00.462]                             muffled <- TRUE
[10:27:00.462]                             break
[10:27:00.462]                           }
[10:27:00.462]                         }
[10:27:00.462]                       }
[10:27:00.462]                       invisible(muffled)
[10:27:00.462]                     }
[10:27:00.462]                     muffleCondition(cond, pattern = "^muffle")
[10:27:00.462]                   }
[10:27:00.462]                 }
[10:27:00.462]             }
[10:27:00.462]         }))
[10:27:00.462]     }, error = function(ex) {
[10:27:00.462]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:00.462]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:00.462]                 ...future.rng), started = ...future.startTime, 
[10:27:00.462]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:00.462]             version = "1.8"), class = "FutureResult")
[10:27:00.462]     }, finally = {
[10:27:00.462]         if (!identical(...future.workdir, getwd())) 
[10:27:00.462]             setwd(...future.workdir)
[10:27:00.462]         {
[10:27:00.462]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:00.462]                 ...future.oldOptions$nwarnings <- NULL
[10:27:00.462]             }
[10:27:00.462]             base::options(...future.oldOptions)
[10:27:00.462]             if (.Platform$OS.type == "windows") {
[10:27:00.462]                 old_names <- names(...future.oldEnvVars)
[10:27:00.462]                 envs <- base::Sys.getenv()
[10:27:00.462]                 names <- names(envs)
[10:27:00.462]                 common <- intersect(names, old_names)
[10:27:00.462]                 added <- setdiff(names, old_names)
[10:27:00.462]                 removed <- setdiff(old_names, names)
[10:27:00.462]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:00.462]                   envs[common]]
[10:27:00.462]                 NAMES <- toupper(changed)
[10:27:00.462]                 args <- list()
[10:27:00.462]                 for (kk in seq_along(NAMES)) {
[10:27:00.462]                   name <- changed[[kk]]
[10:27:00.462]                   NAME <- NAMES[[kk]]
[10:27:00.462]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.462]                     next
[10:27:00.462]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:00.462]                 }
[10:27:00.462]                 NAMES <- toupper(added)
[10:27:00.462]                 for (kk in seq_along(NAMES)) {
[10:27:00.462]                   name <- added[[kk]]
[10:27:00.462]                   NAME <- NAMES[[kk]]
[10:27:00.462]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.462]                     next
[10:27:00.462]                   args[[name]] <- ""
[10:27:00.462]                 }
[10:27:00.462]                 NAMES <- toupper(removed)
[10:27:00.462]                 for (kk in seq_along(NAMES)) {
[10:27:00.462]                   name <- removed[[kk]]
[10:27:00.462]                   NAME <- NAMES[[kk]]
[10:27:00.462]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.462]                     next
[10:27:00.462]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:00.462]                 }
[10:27:00.462]                 if (length(args) > 0) 
[10:27:00.462]                   base::do.call(base::Sys.setenv, args = args)
[10:27:00.462]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:00.462]             }
[10:27:00.462]             else {
[10:27:00.462]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:00.462]             }
[10:27:00.462]             {
[10:27:00.462]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:00.462]                   0L) {
[10:27:00.462]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:00.462]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:00.462]                   base::options(opts)
[10:27:00.462]                 }
[10:27:00.462]                 {
[10:27:00.462]                   {
[10:27:00.462]                     NULL
[10:27:00.462]                     RNGkind("Mersenne-Twister")
[10:27:00.462]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:27:00.462]                       inherits = FALSE)
[10:27:00.462]                   }
[10:27:00.462]                   options(future.plan = NULL)
[10:27:00.462]                   if (is.na(NA_character_)) 
[10:27:00.462]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:00.462]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:00.462]                   future::plan(list(function (..., envir = parent.frame()) 
[10:27:00.462]                   {
[10:27:00.462]                     future <- SequentialFuture(..., envir = envir)
[10:27:00.462]                     if (!future$lazy) 
[10:27:00.462]                       future <- run(future)
[10:27:00.462]                     invisible(future)
[10:27:00.462]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:00.462]                 }
[10:27:00.462]             }
[10:27:00.462]         }
[10:27:00.462]     })
[10:27:00.462]     if (TRUE) {
[10:27:00.462]         base::sink(type = "output", split = FALSE)
[10:27:00.462]         if (TRUE) {
[10:27:00.462]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:00.462]         }
[10:27:00.462]         else {
[10:27:00.462]             ...future.result["stdout"] <- base::list(NULL)
[10:27:00.462]         }
[10:27:00.462]         base::close(...future.stdout)
[10:27:00.462]         ...future.stdout <- NULL
[10:27:00.462]     }
[10:27:00.462]     ...future.result$conditions <- ...future.conditions
[10:27:00.462]     ...future.result$finished <- base::Sys.time()
[10:27:00.462]     ...future.result
[10:27:00.462] }
[10:27:00.463] assign_globals() ...
[10:27:00.464] List of 1
[10:27:00.464]  $ kk: int 2
[10:27:00.464]  - attr(*, "where")=List of 1
[10:27:00.464]   ..$ kk:<environment: R_EmptyEnv> 
[10:27:00.464]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:27:00.464]  - attr(*, "resolved")= logi FALSE
[10:27:00.464]  - attr(*, "total_size")= num 56
[10:27:00.464]  - attr(*, "already-done")= logi TRUE
[10:27:00.466] - copied ‘kk’ to environment
[10:27:00.466] assign_globals() ... done
[10:27:00.467] plan(): Setting new future strategy stack:
[10:27:00.467] List of future strategies:
[10:27:00.467] 1. sequential:
[10:27:00.467]    - args: function (..., envir = parent.frame())
[10:27:00.467]    - tweaked: FALSE
[10:27:00.467]    - call: NULL
[10:27:00.467] plan(): nbrOfWorkers() = 1
[10:27:00.568] plan(): Setting new future strategy stack:
[10:27:00.569] List of future strategies:
[10:27:00.569] 1. sequential:
[10:27:00.569]    - args: function (..., envir = parent.frame())
[10:27:00.569]    - tweaked: FALSE
[10:27:00.569]    - call: plan(strategy)
[10:27:00.569] plan(): nbrOfWorkers() = 1
[10:27:00.569] SequentialFuture started (and completed)
[10:27:00.569] - Launch lazy future ... done
[10:27:00.570] run() for ‘SequentialFuture’ ... done
[10:27:00.570] resolved() for ‘SequentialFuture’ ...
[10:27:00.570] - state: ‘finished’
[10:27:00.570] - run: TRUE
[10:27:00.570] - result: ‘FutureResult’
[10:27:00.570] resolved() for ‘SequentialFuture’ ... done
[10:27:00.570] Future #2
[10:27:00.570]  length: 1 (resolved future 2)
[10:27:00.570] run() for ‘Future’ ...
[10:27:00.571] - state: ‘created’
[10:27:00.571] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:27:00.571] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:27:00.571] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:27:00.571]   - Field: ‘label’
[10:27:00.571]   - Field: ‘local’
[10:27:00.571]   - Field: ‘owner’
[10:27:00.572]   - Field: ‘envir’
[10:27:00.572]   - Field: ‘packages’
[10:27:00.572]   - Field: ‘gc’
[10:27:00.572]   - Field: ‘conditions’
[10:27:00.572]   - Field: ‘expr’
[10:27:00.572]   - Field: ‘uuid’
[10:27:00.572]   - Field: ‘seed’
[10:27:00.572]   - Field: ‘version’
[10:27:00.572]   - Field: ‘result’
[10:27:00.572]   - Field: ‘asynchronous’
[10:27:00.572]   - Field: ‘calls’
[10:27:00.573]   - Field: ‘globals’
[10:27:00.573]   - Field: ‘stdout’
[10:27:00.573]   - Field: ‘earlySignal’
[10:27:00.573]   - Field: ‘lazy’
[10:27:00.573]   - Field: ‘state’
[10:27:00.573] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:27:00.573] - Launch lazy future ...
[10:27:00.573] Packages needed by the future expression (n = 0): <none>
[10:27:00.573] Packages needed by future strategies (n = 0): <none>
[10:27:00.574] {
[10:27:00.574]     {
[10:27:00.574]         {
[10:27:00.574]             ...future.startTime <- base::Sys.time()
[10:27:00.574]             {
[10:27:00.574]                 {
[10:27:00.574]                   {
[10:27:00.574]                     base::local({
[10:27:00.574]                       has_future <- base::requireNamespace("future", 
[10:27:00.574]                         quietly = TRUE)
[10:27:00.574]                       if (has_future) {
[10:27:00.574]                         ns <- base::getNamespace("future")
[10:27:00.574]                         version <- ns[[".package"]][["version"]]
[10:27:00.574]                         if (is.null(version)) 
[10:27:00.574]                           version <- utils::packageVersion("future")
[10:27:00.574]                       }
[10:27:00.574]                       else {
[10:27:00.574]                         version <- NULL
[10:27:00.574]                       }
[10:27:00.574]                       if (!has_future || version < "1.8.0") {
[10:27:00.574]                         info <- base::c(r_version = base::gsub("R version ", 
[10:27:00.574]                           "", base::R.version$version.string), 
[10:27:00.574]                           platform = base::sprintf("%s (%s-bit)", 
[10:27:00.574]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:00.574]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:00.574]                             "release", "version")], collapse = " "), 
[10:27:00.574]                           hostname = base::Sys.info()[["nodename"]])
[10:27:00.574]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:27:00.574]                           info)
[10:27:00.574]                         info <- base::paste(info, collapse = "; ")
[10:27:00.574]                         if (!has_future) {
[10:27:00.574]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:00.574]                             info)
[10:27:00.574]                         }
[10:27:00.574]                         else {
[10:27:00.574]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:00.574]                             info, version)
[10:27:00.574]                         }
[10:27:00.574]                         base::stop(msg)
[10:27:00.574]                       }
[10:27:00.574]                     })
[10:27:00.574]                   }
[10:27:00.574]                   options(future.plan = NULL)
[10:27:00.574]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:00.574]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:00.574]                 }
[10:27:00.574]                 ...future.workdir <- getwd()
[10:27:00.574]             }
[10:27:00.574]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:00.574]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:00.574]         }
[10:27:00.574]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:00.574]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:00.574]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:00.574]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:00.574]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:00.574]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:00.574]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:00.574]             base::names(...future.oldOptions))
[10:27:00.574]     }
[10:27:00.574]     if (FALSE) {
[10:27:00.574]     }
[10:27:00.574]     else {
[10:27:00.574]         if (TRUE) {
[10:27:00.574]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:00.574]                 open = "w")
[10:27:00.574]         }
[10:27:00.574]         else {
[10:27:00.574]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:00.574]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:00.574]         }
[10:27:00.574]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:00.574]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:00.574]             base::sink(type = "output", split = FALSE)
[10:27:00.574]             base::close(...future.stdout)
[10:27:00.574]         }, add = TRUE)
[10:27:00.574]     }
[10:27:00.574]     ...future.frame <- base::sys.nframe()
[10:27:00.574]     ...future.conditions <- base::list()
[10:27:00.574]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:00.574]     if (FALSE) {
[10:27:00.574]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:00.574]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:00.574]     }
[10:27:00.574]     ...future.result <- base::tryCatch({
[10:27:00.574]         base::withCallingHandlers({
[10:27:00.574]             ...future.value <- base::withVisible(base::local({
[10:27:00.574]                 Sys.sleep(0.1)
[10:27:00.574]                 kk
[10:27:00.574]             }))
[10:27:00.574]             future::FutureResult(value = ...future.value$value, 
[10:27:00.574]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:00.574]                   ...future.rng), globalenv = if (FALSE) 
[10:27:00.574]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:00.574]                     ...future.globalenv.names))
[10:27:00.574]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:00.574]         }, condition = base::local({
[10:27:00.574]             c <- base::c
[10:27:00.574]             inherits <- base::inherits
[10:27:00.574]             invokeRestart <- base::invokeRestart
[10:27:00.574]             length <- base::length
[10:27:00.574]             list <- base::list
[10:27:00.574]             seq.int <- base::seq.int
[10:27:00.574]             signalCondition <- base::signalCondition
[10:27:00.574]             sys.calls <- base::sys.calls
[10:27:00.574]             `[[` <- base::`[[`
[10:27:00.574]             `+` <- base::`+`
[10:27:00.574]             `<<-` <- base::`<<-`
[10:27:00.574]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:00.574]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:00.574]                   3L)]
[10:27:00.574]             }
[10:27:00.574]             function(cond) {
[10:27:00.574]                 is_error <- inherits(cond, "error")
[10:27:00.574]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:00.574]                   NULL)
[10:27:00.574]                 if (is_error) {
[10:27:00.574]                   sessionInformation <- function() {
[10:27:00.574]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:00.574]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:00.574]                       search = base::search(), system = base::Sys.info())
[10:27:00.574]                   }
[10:27:00.574]                   ...future.conditions[[length(...future.conditions) + 
[10:27:00.574]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:00.574]                     cond$call), session = sessionInformation(), 
[10:27:00.574]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:00.574]                   signalCondition(cond)
[10:27:00.574]                 }
[10:27:00.574]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:00.574]                 "immediateCondition"))) {
[10:27:00.574]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:00.574]                   ...future.conditions[[length(...future.conditions) + 
[10:27:00.574]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:00.574]                   if (TRUE && !signal) {
[10:27:00.574]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:00.574]                     {
[10:27:00.574]                       inherits <- base::inherits
[10:27:00.574]                       invokeRestart <- base::invokeRestart
[10:27:00.574]                       is.null <- base::is.null
[10:27:00.574]                       muffled <- FALSE
[10:27:00.574]                       if (inherits(cond, "message")) {
[10:27:00.574]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:00.574]                         if (muffled) 
[10:27:00.574]                           invokeRestart("muffleMessage")
[10:27:00.574]                       }
[10:27:00.574]                       else if (inherits(cond, "warning")) {
[10:27:00.574]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:00.574]                         if (muffled) 
[10:27:00.574]                           invokeRestart("muffleWarning")
[10:27:00.574]                       }
[10:27:00.574]                       else if (inherits(cond, "condition")) {
[10:27:00.574]                         if (!is.null(pattern)) {
[10:27:00.574]                           computeRestarts <- base::computeRestarts
[10:27:00.574]                           grepl <- base::grepl
[10:27:00.574]                           restarts <- computeRestarts(cond)
[10:27:00.574]                           for (restart in restarts) {
[10:27:00.574]                             name <- restart$name
[10:27:00.574]                             if (is.null(name)) 
[10:27:00.574]                               next
[10:27:00.574]                             if (!grepl(pattern, name)) 
[10:27:00.574]                               next
[10:27:00.574]                             invokeRestart(restart)
[10:27:00.574]                             muffled <- TRUE
[10:27:00.574]                             break
[10:27:00.574]                           }
[10:27:00.574]                         }
[10:27:00.574]                       }
[10:27:00.574]                       invisible(muffled)
[10:27:00.574]                     }
[10:27:00.574]                     muffleCondition(cond, pattern = "^muffle")
[10:27:00.574]                   }
[10:27:00.574]                 }
[10:27:00.574]                 else {
[10:27:00.574]                   if (TRUE) {
[10:27:00.574]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:00.574]                     {
[10:27:00.574]                       inherits <- base::inherits
[10:27:00.574]                       invokeRestart <- base::invokeRestart
[10:27:00.574]                       is.null <- base::is.null
[10:27:00.574]                       muffled <- FALSE
[10:27:00.574]                       if (inherits(cond, "message")) {
[10:27:00.574]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:00.574]                         if (muffled) 
[10:27:00.574]                           invokeRestart("muffleMessage")
[10:27:00.574]                       }
[10:27:00.574]                       else if (inherits(cond, "warning")) {
[10:27:00.574]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:00.574]                         if (muffled) 
[10:27:00.574]                           invokeRestart("muffleWarning")
[10:27:00.574]                       }
[10:27:00.574]                       else if (inherits(cond, "condition")) {
[10:27:00.574]                         if (!is.null(pattern)) {
[10:27:00.574]                           computeRestarts <- base::computeRestarts
[10:27:00.574]                           grepl <- base::grepl
[10:27:00.574]                           restarts <- computeRestarts(cond)
[10:27:00.574]                           for (restart in restarts) {
[10:27:00.574]                             name <- restart$name
[10:27:00.574]                             if (is.null(name)) 
[10:27:00.574]                               next
[10:27:00.574]                             if (!grepl(pattern, name)) 
[10:27:00.574]                               next
[10:27:00.574]                             invokeRestart(restart)
[10:27:00.574]                             muffled <- TRUE
[10:27:00.574]                             break
[10:27:00.574]                           }
[10:27:00.574]                         }
[10:27:00.574]                       }
[10:27:00.574]                       invisible(muffled)
[10:27:00.574]                     }
[10:27:00.574]                     muffleCondition(cond, pattern = "^muffle")
[10:27:00.574]                   }
[10:27:00.574]                 }
[10:27:00.574]             }
[10:27:00.574]         }))
[10:27:00.574]     }, error = function(ex) {
[10:27:00.574]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:00.574]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:00.574]                 ...future.rng), started = ...future.startTime, 
[10:27:00.574]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:00.574]             version = "1.8"), class = "FutureResult")
[10:27:00.574]     }, finally = {
[10:27:00.574]         if (!identical(...future.workdir, getwd())) 
[10:27:00.574]             setwd(...future.workdir)
[10:27:00.574]         {
[10:27:00.574]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:00.574]                 ...future.oldOptions$nwarnings <- NULL
[10:27:00.574]             }
[10:27:00.574]             base::options(...future.oldOptions)
[10:27:00.574]             if (.Platform$OS.type == "windows") {
[10:27:00.574]                 old_names <- names(...future.oldEnvVars)
[10:27:00.574]                 envs <- base::Sys.getenv()
[10:27:00.574]                 names <- names(envs)
[10:27:00.574]                 common <- intersect(names, old_names)
[10:27:00.574]                 added <- setdiff(names, old_names)
[10:27:00.574]                 removed <- setdiff(old_names, names)
[10:27:00.574]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:00.574]                   envs[common]]
[10:27:00.574]                 NAMES <- toupper(changed)
[10:27:00.574]                 args <- list()
[10:27:00.574]                 for (kk in seq_along(NAMES)) {
[10:27:00.574]                   name <- changed[[kk]]
[10:27:00.574]                   NAME <- NAMES[[kk]]
[10:27:00.574]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.574]                     next
[10:27:00.574]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:00.574]                 }
[10:27:00.574]                 NAMES <- toupper(added)
[10:27:00.574]                 for (kk in seq_along(NAMES)) {
[10:27:00.574]                   name <- added[[kk]]
[10:27:00.574]                   NAME <- NAMES[[kk]]
[10:27:00.574]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.574]                     next
[10:27:00.574]                   args[[name]] <- ""
[10:27:00.574]                 }
[10:27:00.574]                 NAMES <- toupper(removed)
[10:27:00.574]                 for (kk in seq_along(NAMES)) {
[10:27:00.574]                   name <- removed[[kk]]
[10:27:00.574]                   NAME <- NAMES[[kk]]
[10:27:00.574]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.574]                     next
[10:27:00.574]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:00.574]                 }
[10:27:00.574]                 if (length(args) > 0) 
[10:27:00.574]                   base::do.call(base::Sys.setenv, args = args)
[10:27:00.574]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:00.574]             }
[10:27:00.574]             else {
[10:27:00.574]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:00.574]             }
[10:27:00.574]             {
[10:27:00.574]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:00.574]                   0L) {
[10:27:00.574]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:00.574]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:00.574]                   base::options(opts)
[10:27:00.574]                 }
[10:27:00.574]                 {
[10:27:00.574]                   {
[10:27:00.574]                     NULL
[10:27:00.574]                     RNGkind("Mersenne-Twister")
[10:27:00.574]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:27:00.574]                       inherits = FALSE)
[10:27:00.574]                   }
[10:27:00.574]                   options(future.plan = NULL)
[10:27:00.574]                   if (is.na(NA_character_)) 
[10:27:00.574]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:00.574]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:00.574]                   future::plan(list(function (..., envir = parent.frame()) 
[10:27:00.574]                   {
[10:27:00.574]                     future <- SequentialFuture(..., envir = envir)
[10:27:00.574]                     if (!future$lazy) 
[10:27:00.574]                       future <- run(future)
[10:27:00.574]                     invisible(future)
[10:27:00.574]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:00.574]                 }
[10:27:00.574]             }
[10:27:00.574]         }
[10:27:00.574]     })
[10:27:00.574]     if (TRUE) {
[10:27:00.574]         base::sink(type = "output", split = FALSE)
[10:27:00.574]         if (TRUE) {
[10:27:00.574]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:00.574]         }
[10:27:00.574]         else {
[10:27:00.574]             ...future.result["stdout"] <- base::list(NULL)
[10:27:00.574]         }
[10:27:00.574]         base::close(...future.stdout)
[10:27:00.574]         ...future.stdout <- NULL
[10:27:00.574]     }
[10:27:00.574]     ...future.result$conditions <- ...future.conditions
[10:27:00.574]     ...future.result$finished <- base::Sys.time()
[10:27:00.574]     ...future.result
[10:27:00.574] }
[10:27:00.575] assign_globals() ...
[10:27:00.576] List of 1
[10:27:00.576]  $ kk: int 3
[10:27:00.576]  - attr(*, "where")=List of 1
[10:27:00.576]   ..$ kk:<environment: R_EmptyEnv> 
[10:27:00.576]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:27:00.576]  - attr(*, "resolved")= logi FALSE
[10:27:00.576]  - attr(*, "total_size")= num 56
[10:27:00.576]  - attr(*, "already-done")= logi TRUE
[10:27:00.580] - copied ‘kk’ to environment
[10:27:00.580] assign_globals() ... done
[10:27:00.580] plan(): Setting new future strategy stack:
[10:27:00.580] List of future strategies:
[10:27:00.580] 1. sequential:
[10:27:00.580]    - args: function (..., envir = parent.frame())
[10:27:00.580]    - tweaked: FALSE
[10:27:00.580]    - call: NULL
[10:27:00.581] plan(): nbrOfWorkers() = 1
[10:27:00.682] plan(): Setting new future strategy stack:
[10:27:00.682] List of future strategies:
[10:27:00.682] 1. sequential:
[10:27:00.682]    - args: function (..., envir = parent.frame())
[10:27:00.682]    - tweaked: FALSE
[10:27:00.682]    - call: plan(strategy)
[10:27:00.683] plan(): nbrOfWorkers() = 1
[10:27:00.683] SequentialFuture started (and completed)
[10:27:00.683] - Launch lazy future ... done
[10:27:00.683] run() for ‘SequentialFuture’ ... done
[10:27:00.683] resolved() for ‘SequentialFuture’ ...
[10:27:00.683] - state: ‘finished’
[10:27:00.684] - run: TRUE
[10:27:00.684] - result: ‘FutureResult’
[10:27:00.684] resolved() for ‘SequentialFuture’ ... done
[10:27:00.684] Future #3
[10:27:00.684]  length: 0 (resolved future 3)
[10:27:00.684] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[10:27:00.685] resolve() on environment ...
[10:27:00.685]  recursive: 0
[10:27:00.686]  elements: [2] ‘a’, ‘b’
[10:27:00.686]  length: 1 (resolved future 1)
[10:27:00.687]  length: 0 (resolved future 2)
[10:27:00.687] resolve() on environment ... DONE
[10:27:00.687] getGlobalsAndPackages() ...
[10:27:00.687] Searching for globals...
[10:27:00.691] 
[10:27:00.692] Searching for globals ... DONE
[10:27:00.692] - globals: [0] <none>
[10:27:00.692] getGlobalsAndPackages() ... DONE
[10:27:00.692] run() for ‘Future’ ...
[10:27:00.692] - state: ‘created’
[10:27:00.692] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:27:00.693] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:27:00.693] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:27:00.693]   - Field: ‘label’
[10:27:00.693]   - Field: ‘local’
[10:27:00.693]   - Field: ‘owner’
[10:27:00.693]   - Field: ‘envir’
[10:27:00.693]   - Field: ‘packages’
[10:27:00.693]   - Field: ‘gc’
[10:27:00.693]   - Field: ‘conditions’
[10:27:00.693]   - Field: ‘expr’
[10:27:00.694]   - Field: ‘uuid’
[10:27:00.694]   - Field: ‘seed’
[10:27:00.694]   - Field: ‘version’
[10:27:00.694]   - Field: ‘result’
[10:27:00.694]   - Field: ‘asynchronous’
[10:27:00.694]   - Field: ‘calls’
[10:27:00.694]   - Field: ‘globals’
[10:27:00.694]   - Field: ‘stdout’
[10:27:00.694]   - Field: ‘earlySignal’
[10:27:00.694]   - Field: ‘lazy’
[10:27:00.695]   - Field: ‘state’
[10:27:00.695] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:27:00.695] - Launch lazy future ...
[10:27:00.695] Packages needed by the future expression (n = 0): <none>
[10:27:00.695] Packages needed by future strategies (n = 0): <none>
[10:27:00.695] {
[10:27:00.695]     {
[10:27:00.695]         {
[10:27:00.695]             ...future.startTime <- base::Sys.time()
[10:27:00.695]             {
[10:27:00.695]                 {
[10:27:00.695]                   {
[10:27:00.695]                     base::local({
[10:27:00.695]                       has_future <- base::requireNamespace("future", 
[10:27:00.695]                         quietly = TRUE)
[10:27:00.695]                       if (has_future) {
[10:27:00.695]                         ns <- base::getNamespace("future")
[10:27:00.695]                         version <- ns[[".package"]][["version"]]
[10:27:00.695]                         if (is.null(version)) 
[10:27:00.695]                           version <- utils::packageVersion("future")
[10:27:00.695]                       }
[10:27:00.695]                       else {
[10:27:00.695]                         version <- NULL
[10:27:00.695]                       }
[10:27:00.695]                       if (!has_future || version < "1.8.0") {
[10:27:00.695]                         info <- base::c(r_version = base::gsub("R version ", 
[10:27:00.695]                           "", base::R.version$version.string), 
[10:27:00.695]                           platform = base::sprintf("%s (%s-bit)", 
[10:27:00.695]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:00.695]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:00.695]                             "release", "version")], collapse = " "), 
[10:27:00.695]                           hostname = base::Sys.info()[["nodename"]])
[10:27:00.695]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:27:00.695]                           info)
[10:27:00.695]                         info <- base::paste(info, collapse = "; ")
[10:27:00.695]                         if (!has_future) {
[10:27:00.695]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:00.695]                             info)
[10:27:00.695]                         }
[10:27:00.695]                         else {
[10:27:00.695]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:00.695]                             info, version)
[10:27:00.695]                         }
[10:27:00.695]                         base::stop(msg)
[10:27:00.695]                       }
[10:27:00.695]                     })
[10:27:00.695]                   }
[10:27:00.695]                   options(future.plan = NULL)
[10:27:00.695]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:00.695]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:00.695]                 }
[10:27:00.695]                 ...future.workdir <- getwd()
[10:27:00.695]             }
[10:27:00.695]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:00.695]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:00.695]         }
[10:27:00.695]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:00.695]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:00.695]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:00.695]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:00.695]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:00.695]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:00.695]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:00.695]             base::names(...future.oldOptions))
[10:27:00.695]     }
[10:27:00.695]     if (FALSE) {
[10:27:00.695]     }
[10:27:00.695]     else {
[10:27:00.695]         if (TRUE) {
[10:27:00.695]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:00.695]                 open = "w")
[10:27:00.695]         }
[10:27:00.695]         else {
[10:27:00.695]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:00.695]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:00.695]         }
[10:27:00.695]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:00.695]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:00.695]             base::sink(type = "output", split = FALSE)
[10:27:00.695]             base::close(...future.stdout)
[10:27:00.695]         }, add = TRUE)
[10:27:00.695]     }
[10:27:00.695]     ...future.frame <- base::sys.nframe()
[10:27:00.695]     ...future.conditions <- base::list()
[10:27:00.695]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:00.695]     if (FALSE) {
[10:27:00.695]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:00.695]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:00.695]     }
[10:27:00.695]     ...future.result <- base::tryCatch({
[10:27:00.695]         base::withCallingHandlers({
[10:27:00.695]             ...future.value <- base::withVisible(base::local(1))
[10:27:00.695]             future::FutureResult(value = ...future.value$value, 
[10:27:00.695]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:00.695]                   ...future.rng), globalenv = if (FALSE) 
[10:27:00.695]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:00.695]                     ...future.globalenv.names))
[10:27:00.695]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:00.695]         }, condition = base::local({
[10:27:00.695]             c <- base::c
[10:27:00.695]             inherits <- base::inherits
[10:27:00.695]             invokeRestart <- base::invokeRestart
[10:27:00.695]             length <- base::length
[10:27:00.695]             list <- base::list
[10:27:00.695]             seq.int <- base::seq.int
[10:27:00.695]             signalCondition <- base::signalCondition
[10:27:00.695]             sys.calls <- base::sys.calls
[10:27:00.695]             `[[` <- base::`[[`
[10:27:00.695]             `+` <- base::`+`
[10:27:00.695]             `<<-` <- base::`<<-`
[10:27:00.695]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:00.695]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:00.695]                   3L)]
[10:27:00.695]             }
[10:27:00.695]             function(cond) {
[10:27:00.695]                 is_error <- inherits(cond, "error")
[10:27:00.695]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:00.695]                   NULL)
[10:27:00.695]                 if (is_error) {
[10:27:00.695]                   sessionInformation <- function() {
[10:27:00.695]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:00.695]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:00.695]                       search = base::search(), system = base::Sys.info())
[10:27:00.695]                   }
[10:27:00.695]                   ...future.conditions[[length(...future.conditions) + 
[10:27:00.695]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:00.695]                     cond$call), session = sessionInformation(), 
[10:27:00.695]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:00.695]                   signalCondition(cond)
[10:27:00.695]                 }
[10:27:00.695]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:00.695]                 "immediateCondition"))) {
[10:27:00.695]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:00.695]                   ...future.conditions[[length(...future.conditions) + 
[10:27:00.695]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:00.695]                   if (TRUE && !signal) {
[10:27:00.695]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:00.695]                     {
[10:27:00.695]                       inherits <- base::inherits
[10:27:00.695]                       invokeRestart <- base::invokeRestart
[10:27:00.695]                       is.null <- base::is.null
[10:27:00.695]                       muffled <- FALSE
[10:27:00.695]                       if (inherits(cond, "message")) {
[10:27:00.695]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:00.695]                         if (muffled) 
[10:27:00.695]                           invokeRestart("muffleMessage")
[10:27:00.695]                       }
[10:27:00.695]                       else if (inherits(cond, "warning")) {
[10:27:00.695]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:00.695]                         if (muffled) 
[10:27:00.695]                           invokeRestart("muffleWarning")
[10:27:00.695]                       }
[10:27:00.695]                       else if (inherits(cond, "condition")) {
[10:27:00.695]                         if (!is.null(pattern)) {
[10:27:00.695]                           computeRestarts <- base::computeRestarts
[10:27:00.695]                           grepl <- base::grepl
[10:27:00.695]                           restarts <- computeRestarts(cond)
[10:27:00.695]                           for (restart in restarts) {
[10:27:00.695]                             name <- restart$name
[10:27:00.695]                             if (is.null(name)) 
[10:27:00.695]                               next
[10:27:00.695]                             if (!grepl(pattern, name)) 
[10:27:00.695]                               next
[10:27:00.695]                             invokeRestart(restart)
[10:27:00.695]                             muffled <- TRUE
[10:27:00.695]                             break
[10:27:00.695]                           }
[10:27:00.695]                         }
[10:27:00.695]                       }
[10:27:00.695]                       invisible(muffled)
[10:27:00.695]                     }
[10:27:00.695]                     muffleCondition(cond, pattern = "^muffle")
[10:27:00.695]                   }
[10:27:00.695]                 }
[10:27:00.695]                 else {
[10:27:00.695]                   if (TRUE) {
[10:27:00.695]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:00.695]                     {
[10:27:00.695]                       inherits <- base::inherits
[10:27:00.695]                       invokeRestart <- base::invokeRestart
[10:27:00.695]                       is.null <- base::is.null
[10:27:00.695]                       muffled <- FALSE
[10:27:00.695]                       if (inherits(cond, "message")) {
[10:27:00.695]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:00.695]                         if (muffled) 
[10:27:00.695]                           invokeRestart("muffleMessage")
[10:27:00.695]                       }
[10:27:00.695]                       else if (inherits(cond, "warning")) {
[10:27:00.695]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:00.695]                         if (muffled) 
[10:27:00.695]                           invokeRestart("muffleWarning")
[10:27:00.695]                       }
[10:27:00.695]                       else if (inherits(cond, "condition")) {
[10:27:00.695]                         if (!is.null(pattern)) {
[10:27:00.695]                           computeRestarts <- base::computeRestarts
[10:27:00.695]                           grepl <- base::grepl
[10:27:00.695]                           restarts <- computeRestarts(cond)
[10:27:00.695]                           for (restart in restarts) {
[10:27:00.695]                             name <- restart$name
[10:27:00.695]                             if (is.null(name)) 
[10:27:00.695]                               next
[10:27:00.695]                             if (!grepl(pattern, name)) 
[10:27:00.695]                               next
[10:27:00.695]                             invokeRestart(restart)
[10:27:00.695]                             muffled <- TRUE
[10:27:00.695]                             break
[10:27:00.695]                           }
[10:27:00.695]                         }
[10:27:00.695]                       }
[10:27:00.695]                       invisible(muffled)
[10:27:00.695]                     }
[10:27:00.695]                     muffleCondition(cond, pattern = "^muffle")
[10:27:00.695]                   }
[10:27:00.695]                 }
[10:27:00.695]             }
[10:27:00.695]         }))
[10:27:00.695]     }, error = function(ex) {
[10:27:00.695]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:00.695]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:00.695]                 ...future.rng), started = ...future.startTime, 
[10:27:00.695]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:00.695]             version = "1.8"), class = "FutureResult")
[10:27:00.695]     }, finally = {
[10:27:00.695]         if (!identical(...future.workdir, getwd())) 
[10:27:00.695]             setwd(...future.workdir)
[10:27:00.695]         {
[10:27:00.695]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:00.695]                 ...future.oldOptions$nwarnings <- NULL
[10:27:00.695]             }
[10:27:00.695]             base::options(...future.oldOptions)
[10:27:00.695]             if (.Platform$OS.type == "windows") {
[10:27:00.695]                 old_names <- names(...future.oldEnvVars)
[10:27:00.695]                 envs <- base::Sys.getenv()
[10:27:00.695]                 names <- names(envs)
[10:27:00.695]                 common <- intersect(names, old_names)
[10:27:00.695]                 added <- setdiff(names, old_names)
[10:27:00.695]                 removed <- setdiff(old_names, names)
[10:27:00.695]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:00.695]                   envs[common]]
[10:27:00.695]                 NAMES <- toupper(changed)
[10:27:00.695]                 args <- list()
[10:27:00.695]                 for (kk in seq_along(NAMES)) {
[10:27:00.695]                   name <- changed[[kk]]
[10:27:00.695]                   NAME <- NAMES[[kk]]
[10:27:00.695]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.695]                     next
[10:27:00.695]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:00.695]                 }
[10:27:00.695]                 NAMES <- toupper(added)
[10:27:00.695]                 for (kk in seq_along(NAMES)) {
[10:27:00.695]                   name <- added[[kk]]
[10:27:00.695]                   NAME <- NAMES[[kk]]
[10:27:00.695]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.695]                     next
[10:27:00.695]                   args[[name]] <- ""
[10:27:00.695]                 }
[10:27:00.695]                 NAMES <- toupper(removed)
[10:27:00.695]                 for (kk in seq_along(NAMES)) {
[10:27:00.695]                   name <- removed[[kk]]
[10:27:00.695]                   NAME <- NAMES[[kk]]
[10:27:00.695]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.695]                     next
[10:27:00.695]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:00.695]                 }
[10:27:00.695]                 if (length(args) > 0) 
[10:27:00.695]                   base::do.call(base::Sys.setenv, args = args)
[10:27:00.695]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:00.695]             }
[10:27:00.695]             else {
[10:27:00.695]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:00.695]             }
[10:27:00.695]             {
[10:27:00.695]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:00.695]                   0L) {
[10:27:00.695]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:00.695]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:00.695]                   base::options(opts)
[10:27:00.695]                 }
[10:27:00.695]                 {
[10:27:00.695]                   {
[10:27:00.695]                     NULL
[10:27:00.695]                     RNGkind("Mersenne-Twister")
[10:27:00.695]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:27:00.695]                       inherits = FALSE)
[10:27:00.695]                   }
[10:27:00.695]                   options(future.plan = NULL)
[10:27:00.695]                   if (is.na(NA_character_)) 
[10:27:00.695]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:00.695]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:00.695]                   future::plan(list(function (..., envir = parent.frame()) 
[10:27:00.695]                   {
[10:27:00.695]                     future <- SequentialFuture(..., envir = envir)
[10:27:00.695]                     if (!future$lazy) 
[10:27:00.695]                       future <- run(future)
[10:27:00.695]                     invisible(future)
[10:27:00.695]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:00.695]                 }
[10:27:00.695]             }
[10:27:00.695]         }
[10:27:00.695]     })
[10:27:00.695]     if (TRUE) {
[10:27:00.695]         base::sink(type = "output", split = FALSE)
[10:27:00.695]         if (TRUE) {
[10:27:00.695]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:00.695]         }
[10:27:00.695]         else {
[10:27:00.695]             ...future.result["stdout"] <- base::list(NULL)
[10:27:00.695]         }
[10:27:00.695]         base::close(...future.stdout)
[10:27:00.695]         ...future.stdout <- NULL
[10:27:00.695]     }
[10:27:00.695]     ...future.result$conditions <- ...future.conditions
[10:27:00.695]     ...future.result$finished <- base::Sys.time()
[10:27:00.695]     ...future.result
[10:27:00.695] }
[10:27:00.697] plan(): Setting new future strategy stack:
[10:27:00.697] List of future strategies:
[10:27:00.697] 1. sequential:
[10:27:00.697]    - args: function (..., envir = parent.frame())
[10:27:00.697]    - tweaked: FALSE
[10:27:00.697]    - call: NULL
[10:27:00.698] plan(): nbrOfWorkers() = 1
[10:27:00.699] plan(): Setting new future strategy stack:
[10:27:00.699] List of future strategies:
[10:27:00.699] 1. sequential:
[10:27:00.699]    - args: function (..., envir = parent.frame())
[10:27:00.699]    - tweaked: FALSE
[10:27:00.699]    - call: plan(strategy)
[10:27:00.699] plan(): nbrOfWorkers() = 1
[10:27:00.699] SequentialFuture started (and completed)
[10:27:00.699] - Launch lazy future ... done
[10:27:00.699] run() for ‘SequentialFuture’ ... done
[10:27:00.700] getGlobalsAndPackages() ...
[10:27:00.700] Searching for globals...
[10:27:00.700] 
[10:27:00.700] Searching for globals ... DONE
[10:27:00.700] - globals: [0] <none>
[10:27:00.700] getGlobalsAndPackages() ... DONE
[10:27:00.700] run() for ‘Future’ ...
[10:27:00.701] - state: ‘created’
[10:27:00.701] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:27:00.701] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:27:00.701] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:27:00.701]   - Field: ‘label’
[10:27:00.701]   - Field: ‘local’
[10:27:00.701]   - Field: ‘owner’
[10:27:00.702]   - Field: ‘envir’
[10:27:00.702]   - Field: ‘packages’
[10:27:00.702]   - Field: ‘gc’
[10:27:00.702]   - Field: ‘conditions’
[10:27:00.702]   - Field: ‘expr’
[10:27:00.702]   - Field: ‘uuid’
[10:27:00.702]   - Field: ‘seed’
[10:27:00.702]   - Field: ‘version’
[10:27:00.702]   - Field: ‘result’
[10:27:00.702]   - Field: ‘asynchronous’
[10:27:00.702]   - Field: ‘calls’
[10:27:00.703]   - Field: ‘globals’
[10:27:00.703]   - Field: ‘stdout’
[10:27:00.703]   - Field: ‘earlySignal’
[10:27:00.703]   - Field: ‘lazy’
[10:27:00.703]   - Field: ‘state’
[10:27:00.703] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:27:00.703] - Launch lazy future ...
[10:27:00.703] Packages needed by the future expression (n = 0): <none>
[10:27:00.703] Packages needed by future strategies (n = 0): <none>
[10:27:00.704] {
[10:27:00.704]     {
[10:27:00.704]         {
[10:27:00.704]             ...future.startTime <- base::Sys.time()
[10:27:00.704]             {
[10:27:00.704]                 {
[10:27:00.704]                   {
[10:27:00.704]                     base::local({
[10:27:00.704]                       has_future <- base::requireNamespace("future", 
[10:27:00.704]                         quietly = TRUE)
[10:27:00.704]                       if (has_future) {
[10:27:00.704]                         ns <- base::getNamespace("future")
[10:27:00.704]                         version <- ns[[".package"]][["version"]]
[10:27:00.704]                         if (is.null(version)) 
[10:27:00.704]                           version <- utils::packageVersion("future")
[10:27:00.704]                       }
[10:27:00.704]                       else {
[10:27:00.704]                         version <- NULL
[10:27:00.704]                       }
[10:27:00.704]                       if (!has_future || version < "1.8.0") {
[10:27:00.704]                         info <- base::c(r_version = base::gsub("R version ", 
[10:27:00.704]                           "", base::R.version$version.string), 
[10:27:00.704]                           platform = base::sprintf("%s (%s-bit)", 
[10:27:00.704]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:00.704]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:00.704]                             "release", "version")], collapse = " "), 
[10:27:00.704]                           hostname = base::Sys.info()[["nodename"]])
[10:27:00.704]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:27:00.704]                           info)
[10:27:00.704]                         info <- base::paste(info, collapse = "; ")
[10:27:00.704]                         if (!has_future) {
[10:27:00.704]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:00.704]                             info)
[10:27:00.704]                         }
[10:27:00.704]                         else {
[10:27:00.704]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:00.704]                             info, version)
[10:27:00.704]                         }
[10:27:00.704]                         base::stop(msg)
[10:27:00.704]                       }
[10:27:00.704]                     })
[10:27:00.704]                   }
[10:27:00.704]                   options(future.plan = NULL)
[10:27:00.704]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:00.704]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:00.704]                 }
[10:27:00.704]                 ...future.workdir <- getwd()
[10:27:00.704]             }
[10:27:00.704]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:00.704]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:00.704]         }
[10:27:00.704]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:00.704]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:00.704]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:00.704]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:00.704]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:00.704]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:00.704]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:00.704]             base::names(...future.oldOptions))
[10:27:00.704]     }
[10:27:00.704]     if (FALSE) {
[10:27:00.704]     }
[10:27:00.704]     else {
[10:27:00.704]         if (TRUE) {
[10:27:00.704]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:00.704]                 open = "w")
[10:27:00.704]         }
[10:27:00.704]         else {
[10:27:00.704]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:00.704]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:00.704]         }
[10:27:00.704]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:00.704]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:00.704]             base::sink(type = "output", split = FALSE)
[10:27:00.704]             base::close(...future.stdout)
[10:27:00.704]         }, add = TRUE)
[10:27:00.704]     }
[10:27:00.704]     ...future.frame <- base::sys.nframe()
[10:27:00.704]     ...future.conditions <- base::list()
[10:27:00.704]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:00.704]     if (FALSE) {
[10:27:00.704]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:00.704]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:00.704]     }
[10:27:00.704]     ...future.result <- base::tryCatch({
[10:27:00.704]         base::withCallingHandlers({
[10:27:00.704]             ...future.value <- base::withVisible(base::local(2))
[10:27:00.704]             future::FutureResult(value = ...future.value$value, 
[10:27:00.704]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:00.704]                   ...future.rng), globalenv = if (FALSE) 
[10:27:00.704]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:00.704]                     ...future.globalenv.names))
[10:27:00.704]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:00.704]         }, condition = base::local({
[10:27:00.704]             c <- base::c
[10:27:00.704]             inherits <- base::inherits
[10:27:00.704]             invokeRestart <- base::invokeRestart
[10:27:00.704]             length <- base::length
[10:27:00.704]             list <- base::list
[10:27:00.704]             seq.int <- base::seq.int
[10:27:00.704]             signalCondition <- base::signalCondition
[10:27:00.704]             sys.calls <- base::sys.calls
[10:27:00.704]             `[[` <- base::`[[`
[10:27:00.704]             `+` <- base::`+`
[10:27:00.704]             `<<-` <- base::`<<-`
[10:27:00.704]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:00.704]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:00.704]                   3L)]
[10:27:00.704]             }
[10:27:00.704]             function(cond) {
[10:27:00.704]                 is_error <- inherits(cond, "error")
[10:27:00.704]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:00.704]                   NULL)
[10:27:00.704]                 if (is_error) {
[10:27:00.704]                   sessionInformation <- function() {
[10:27:00.704]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:00.704]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:00.704]                       search = base::search(), system = base::Sys.info())
[10:27:00.704]                   }
[10:27:00.704]                   ...future.conditions[[length(...future.conditions) + 
[10:27:00.704]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:00.704]                     cond$call), session = sessionInformation(), 
[10:27:00.704]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:00.704]                   signalCondition(cond)
[10:27:00.704]                 }
[10:27:00.704]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:00.704]                 "immediateCondition"))) {
[10:27:00.704]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:00.704]                   ...future.conditions[[length(...future.conditions) + 
[10:27:00.704]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:00.704]                   if (TRUE && !signal) {
[10:27:00.704]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:00.704]                     {
[10:27:00.704]                       inherits <- base::inherits
[10:27:00.704]                       invokeRestart <- base::invokeRestart
[10:27:00.704]                       is.null <- base::is.null
[10:27:00.704]                       muffled <- FALSE
[10:27:00.704]                       if (inherits(cond, "message")) {
[10:27:00.704]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:00.704]                         if (muffled) 
[10:27:00.704]                           invokeRestart("muffleMessage")
[10:27:00.704]                       }
[10:27:00.704]                       else if (inherits(cond, "warning")) {
[10:27:00.704]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:00.704]                         if (muffled) 
[10:27:00.704]                           invokeRestart("muffleWarning")
[10:27:00.704]                       }
[10:27:00.704]                       else if (inherits(cond, "condition")) {
[10:27:00.704]                         if (!is.null(pattern)) {
[10:27:00.704]                           computeRestarts <- base::computeRestarts
[10:27:00.704]                           grepl <- base::grepl
[10:27:00.704]                           restarts <- computeRestarts(cond)
[10:27:00.704]                           for (restart in restarts) {
[10:27:00.704]                             name <- restart$name
[10:27:00.704]                             if (is.null(name)) 
[10:27:00.704]                               next
[10:27:00.704]                             if (!grepl(pattern, name)) 
[10:27:00.704]                               next
[10:27:00.704]                             invokeRestart(restart)
[10:27:00.704]                             muffled <- TRUE
[10:27:00.704]                             break
[10:27:00.704]                           }
[10:27:00.704]                         }
[10:27:00.704]                       }
[10:27:00.704]                       invisible(muffled)
[10:27:00.704]                     }
[10:27:00.704]                     muffleCondition(cond, pattern = "^muffle")
[10:27:00.704]                   }
[10:27:00.704]                 }
[10:27:00.704]                 else {
[10:27:00.704]                   if (TRUE) {
[10:27:00.704]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:00.704]                     {
[10:27:00.704]                       inherits <- base::inherits
[10:27:00.704]                       invokeRestart <- base::invokeRestart
[10:27:00.704]                       is.null <- base::is.null
[10:27:00.704]                       muffled <- FALSE
[10:27:00.704]                       if (inherits(cond, "message")) {
[10:27:00.704]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:00.704]                         if (muffled) 
[10:27:00.704]                           invokeRestart("muffleMessage")
[10:27:00.704]                       }
[10:27:00.704]                       else if (inherits(cond, "warning")) {
[10:27:00.704]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:00.704]                         if (muffled) 
[10:27:00.704]                           invokeRestart("muffleWarning")
[10:27:00.704]                       }
[10:27:00.704]                       else if (inherits(cond, "condition")) {
[10:27:00.704]                         if (!is.null(pattern)) {
[10:27:00.704]                           computeRestarts <- base::computeRestarts
[10:27:00.704]                           grepl <- base::grepl
[10:27:00.704]                           restarts <- computeRestarts(cond)
[10:27:00.704]                           for (restart in restarts) {
[10:27:00.704]                             name <- restart$name
[10:27:00.704]                             if (is.null(name)) 
[10:27:00.704]                               next
[10:27:00.704]                             if (!grepl(pattern, name)) 
[10:27:00.704]                               next
[10:27:00.704]                             invokeRestart(restart)
[10:27:00.704]                             muffled <- TRUE
[10:27:00.704]                             break
[10:27:00.704]                           }
[10:27:00.704]                         }
[10:27:00.704]                       }
[10:27:00.704]                       invisible(muffled)
[10:27:00.704]                     }
[10:27:00.704]                     muffleCondition(cond, pattern = "^muffle")
[10:27:00.704]                   }
[10:27:00.704]                 }
[10:27:00.704]             }
[10:27:00.704]         }))
[10:27:00.704]     }, error = function(ex) {
[10:27:00.704]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:00.704]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:00.704]                 ...future.rng), started = ...future.startTime, 
[10:27:00.704]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:00.704]             version = "1.8"), class = "FutureResult")
[10:27:00.704]     }, finally = {
[10:27:00.704]         if (!identical(...future.workdir, getwd())) 
[10:27:00.704]             setwd(...future.workdir)
[10:27:00.704]         {
[10:27:00.704]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:00.704]                 ...future.oldOptions$nwarnings <- NULL
[10:27:00.704]             }
[10:27:00.704]             base::options(...future.oldOptions)
[10:27:00.704]             if (.Platform$OS.type == "windows") {
[10:27:00.704]                 old_names <- names(...future.oldEnvVars)
[10:27:00.704]                 envs <- base::Sys.getenv()
[10:27:00.704]                 names <- names(envs)
[10:27:00.704]                 common <- intersect(names, old_names)
[10:27:00.704]                 added <- setdiff(names, old_names)
[10:27:00.704]                 removed <- setdiff(old_names, names)
[10:27:00.704]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:00.704]                   envs[common]]
[10:27:00.704]                 NAMES <- toupper(changed)
[10:27:00.704]                 args <- list()
[10:27:00.704]                 for (kk in seq_along(NAMES)) {
[10:27:00.704]                   name <- changed[[kk]]
[10:27:00.704]                   NAME <- NAMES[[kk]]
[10:27:00.704]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.704]                     next
[10:27:00.704]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:00.704]                 }
[10:27:00.704]                 NAMES <- toupper(added)
[10:27:00.704]                 for (kk in seq_along(NAMES)) {
[10:27:00.704]                   name <- added[[kk]]
[10:27:00.704]                   NAME <- NAMES[[kk]]
[10:27:00.704]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.704]                     next
[10:27:00.704]                   args[[name]] <- ""
[10:27:00.704]                 }
[10:27:00.704]                 NAMES <- toupper(removed)
[10:27:00.704]                 for (kk in seq_along(NAMES)) {
[10:27:00.704]                   name <- removed[[kk]]
[10:27:00.704]                   NAME <- NAMES[[kk]]
[10:27:00.704]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.704]                     next
[10:27:00.704]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:00.704]                 }
[10:27:00.704]                 if (length(args) > 0) 
[10:27:00.704]                   base::do.call(base::Sys.setenv, args = args)
[10:27:00.704]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:00.704]             }
[10:27:00.704]             else {
[10:27:00.704]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:00.704]             }
[10:27:00.704]             {
[10:27:00.704]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:00.704]                   0L) {
[10:27:00.704]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:00.704]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:00.704]                   base::options(opts)
[10:27:00.704]                 }
[10:27:00.704]                 {
[10:27:00.704]                   {
[10:27:00.704]                     NULL
[10:27:00.704]                     RNGkind("Mersenne-Twister")
[10:27:00.704]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:27:00.704]                       inherits = FALSE)
[10:27:00.704]                   }
[10:27:00.704]                   options(future.plan = NULL)
[10:27:00.704]                   if (is.na(NA_character_)) 
[10:27:00.704]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:00.704]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:00.704]                   future::plan(list(function (..., envir = parent.frame()) 
[10:27:00.704]                   {
[10:27:00.704]                     future <- SequentialFuture(..., envir = envir)
[10:27:00.704]                     if (!future$lazy) 
[10:27:00.704]                       future <- run(future)
[10:27:00.704]                     invisible(future)
[10:27:00.704]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:00.704]                 }
[10:27:00.704]             }
[10:27:00.704]         }
[10:27:00.704]     })
[10:27:00.704]     if (TRUE) {
[10:27:00.704]         base::sink(type = "output", split = FALSE)
[10:27:00.704]         if (TRUE) {
[10:27:00.704]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:00.704]         }
[10:27:00.704]         else {
[10:27:00.704]             ...future.result["stdout"] <- base::list(NULL)
[10:27:00.704]         }
[10:27:00.704]         base::close(...future.stdout)
[10:27:00.704]         ...future.stdout <- NULL
[10:27:00.704]     }
[10:27:00.704]     ...future.result$conditions <- ...future.conditions
[10:27:00.704]     ...future.result$finished <- base::Sys.time()
[10:27:00.704]     ...future.result
[10:27:00.704] }
[10:27:00.706] plan(): Setting new future strategy stack:
[10:27:00.706] List of future strategies:
[10:27:00.706] 1. sequential:
[10:27:00.706]    - args: function (..., envir = parent.frame())
[10:27:00.706]    - tweaked: FALSE
[10:27:00.706]    - call: NULL
[10:27:00.706] plan(): nbrOfWorkers() = 1
[10:27:00.707] plan(): Setting new future strategy stack:
[10:27:00.707] List of future strategies:
[10:27:00.707] 1. sequential:
[10:27:00.707]    - args: function (..., envir = parent.frame())
[10:27:00.707]    - tweaked: FALSE
[10:27:00.707]    - call: plan(strategy)
[10:27:00.707] plan(): nbrOfWorkers() = 1
[10:27:00.707] SequentialFuture started (and completed)
[10:27:00.707] - Launch lazy future ... done
[10:27:00.708] run() for ‘SequentialFuture’ ... done
[10:27:00.708] resolve() on environment ...
[10:27:00.708]  recursive: 0
[10:27:00.709]  elements: [3] ‘a’, ‘b’, ‘c’
[10:27:00.709] resolved() for ‘SequentialFuture’ ...
[10:27:00.709] - state: ‘finished’
[10:27:00.709] - run: TRUE
[10:27:00.709] - result: ‘FutureResult’
[10:27:00.709] resolved() for ‘SequentialFuture’ ... done
[10:27:00.709] Future #1
[10:27:00.709]  length: 2 (resolved future 1)
[10:27:00.709] resolved() for ‘SequentialFuture’ ...
[10:27:00.710] - state: ‘finished’
[10:27:00.710] - run: TRUE
[10:27:00.710] - result: ‘FutureResult’
[10:27:00.710] resolved() for ‘SequentialFuture’ ... done
[10:27:00.710] Future #2
[10:27:00.710]  length: 1 (resolved future 2)
[10:27:00.710]  length: 0 (resolved future 3)
[10:27:00.710] resolve() on environment ... DONE
[10:27:00.710] resolved() for ‘SequentialFuture’ ...
[10:27:00.710] - state: ‘finished’
[10:27:00.710] - run: TRUE
[10:27:00.711] - result: ‘FutureResult’
[10:27:00.711] resolved() for ‘SequentialFuture’ ... done
[10:27:00.711] resolved() for ‘SequentialFuture’ ...
[10:27:00.711] - state: ‘finished’
[10:27:00.711] - run: TRUE
[10:27:00.711] - result: ‘FutureResult’
[10:27:00.711] resolved() for ‘SequentialFuture’ ... done
[10:27:00.712] getGlobalsAndPackages() ...
[10:27:00.712] Searching for globals...
[10:27:00.713] - globals found: [1] ‘{’
[10:27:00.713] Searching for globals ... DONE
[10:27:00.715] Resolving globals: FALSE
[10:27:00.715] 
[10:27:00.715] 
[10:27:00.715] getGlobalsAndPackages() ... DONE
[10:27:00.715] run() for ‘Future’ ...
[10:27:00.716] - state: ‘created’
[10:27:00.716] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:27:00.716] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:27:00.716] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:27:00.716]   - Field: ‘label’
[10:27:00.716]   - Field: ‘local’
[10:27:00.716]   - Field: ‘owner’
[10:27:00.716]   - Field: ‘envir’
[10:27:00.717]   - Field: ‘packages’
[10:27:00.717]   - Field: ‘gc’
[10:27:00.717]   - Field: ‘conditions’
[10:27:00.717]   - Field: ‘expr’
[10:27:00.717]   - Field: ‘uuid’
[10:27:00.717]   - Field: ‘seed’
[10:27:00.717]   - Field: ‘version’
[10:27:00.717]   - Field: ‘result’
[10:27:00.717]   - Field: ‘asynchronous’
[10:27:00.718]   - Field: ‘calls’
[10:27:00.718]   - Field: ‘globals’
[10:27:00.718]   - Field: ‘stdout’
[10:27:00.718]   - Field: ‘earlySignal’
[10:27:00.718]   - Field: ‘lazy’
[10:27:00.718]   - Field: ‘state’
[10:27:00.718] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:27:00.718] - Launch lazy future ...
[10:27:00.719] Packages needed by the future expression (n = 0): <none>
[10:27:00.719] Packages needed by future strategies (n = 0): <none>
[10:27:00.719] {
[10:27:00.719]     {
[10:27:00.719]         {
[10:27:00.719]             ...future.startTime <- base::Sys.time()
[10:27:00.719]             {
[10:27:00.719]                 {
[10:27:00.719]                   {
[10:27:00.719]                     base::local({
[10:27:00.719]                       has_future <- base::requireNamespace("future", 
[10:27:00.719]                         quietly = TRUE)
[10:27:00.719]                       if (has_future) {
[10:27:00.719]                         ns <- base::getNamespace("future")
[10:27:00.719]                         version <- ns[[".package"]][["version"]]
[10:27:00.719]                         if (is.null(version)) 
[10:27:00.719]                           version <- utils::packageVersion("future")
[10:27:00.719]                       }
[10:27:00.719]                       else {
[10:27:00.719]                         version <- NULL
[10:27:00.719]                       }
[10:27:00.719]                       if (!has_future || version < "1.8.0") {
[10:27:00.719]                         info <- base::c(r_version = base::gsub("R version ", 
[10:27:00.719]                           "", base::R.version$version.string), 
[10:27:00.719]                           platform = base::sprintf("%s (%s-bit)", 
[10:27:00.719]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:00.719]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:00.719]                             "release", "version")], collapse = " "), 
[10:27:00.719]                           hostname = base::Sys.info()[["nodename"]])
[10:27:00.719]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:27:00.719]                           info)
[10:27:00.719]                         info <- base::paste(info, collapse = "; ")
[10:27:00.719]                         if (!has_future) {
[10:27:00.719]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:00.719]                             info)
[10:27:00.719]                         }
[10:27:00.719]                         else {
[10:27:00.719]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:00.719]                             info, version)
[10:27:00.719]                         }
[10:27:00.719]                         base::stop(msg)
[10:27:00.719]                       }
[10:27:00.719]                     })
[10:27:00.719]                   }
[10:27:00.719]                   options(future.plan = NULL)
[10:27:00.719]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:00.719]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:00.719]                 }
[10:27:00.719]                 ...future.workdir <- getwd()
[10:27:00.719]             }
[10:27:00.719]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:00.719]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:00.719]         }
[10:27:00.719]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:00.719]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:00.719]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:00.719]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:00.719]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:00.719]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:00.719]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:00.719]             base::names(...future.oldOptions))
[10:27:00.719]     }
[10:27:00.719]     if (FALSE) {
[10:27:00.719]     }
[10:27:00.719]     else {
[10:27:00.719]         if (TRUE) {
[10:27:00.719]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:00.719]                 open = "w")
[10:27:00.719]         }
[10:27:00.719]         else {
[10:27:00.719]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:00.719]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:00.719]         }
[10:27:00.719]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:00.719]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:00.719]             base::sink(type = "output", split = FALSE)
[10:27:00.719]             base::close(...future.stdout)
[10:27:00.719]         }, add = TRUE)
[10:27:00.719]     }
[10:27:00.719]     ...future.frame <- base::sys.nframe()
[10:27:00.719]     ...future.conditions <- base::list()
[10:27:00.719]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:00.719]     if (FALSE) {
[10:27:00.719]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:00.719]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:00.719]     }
[10:27:00.719]     ...future.result <- base::tryCatch({
[10:27:00.719]         base::withCallingHandlers({
[10:27:00.719]             ...future.value <- base::withVisible(base::local({
[10:27:00.719]                 1
[10:27:00.719]             }))
[10:27:00.719]             future::FutureResult(value = ...future.value$value, 
[10:27:00.719]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:00.719]                   ...future.rng), globalenv = if (FALSE) 
[10:27:00.719]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:00.719]                     ...future.globalenv.names))
[10:27:00.719]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:00.719]         }, condition = base::local({
[10:27:00.719]             c <- base::c
[10:27:00.719]             inherits <- base::inherits
[10:27:00.719]             invokeRestart <- base::invokeRestart
[10:27:00.719]             length <- base::length
[10:27:00.719]             list <- base::list
[10:27:00.719]             seq.int <- base::seq.int
[10:27:00.719]             signalCondition <- base::signalCondition
[10:27:00.719]             sys.calls <- base::sys.calls
[10:27:00.719]             `[[` <- base::`[[`
[10:27:00.719]             `+` <- base::`+`
[10:27:00.719]             `<<-` <- base::`<<-`
[10:27:00.719]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:00.719]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:00.719]                   3L)]
[10:27:00.719]             }
[10:27:00.719]             function(cond) {
[10:27:00.719]                 is_error <- inherits(cond, "error")
[10:27:00.719]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:00.719]                   NULL)
[10:27:00.719]                 if (is_error) {
[10:27:00.719]                   sessionInformation <- function() {
[10:27:00.719]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:00.719]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:00.719]                       search = base::search(), system = base::Sys.info())
[10:27:00.719]                   }
[10:27:00.719]                   ...future.conditions[[length(...future.conditions) + 
[10:27:00.719]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:00.719]                     cond$call), session = sessionInformation(), 
[10:27:00.719]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:00.719]                   signalCondition(cond)
[10:27:00.719]                 }
[10:27:00.719]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:00.719]                 "immediateCondition"))) {
[10:27:00.719]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:00.719]                   ...future.conditions[[length(...future.conditions) + 
[10:27:00.719]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:00.719]                   if (TRUE && !signal) {
[10:27:00.719]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:00.719]                     {
[10:27:00.719]                       inherits <- base::inherits
[10:27:00.719]                       invokeRestart <- base::invokeRestart
[10:27:00.719]                       is.null <- base::is.null
[10:27:00.719]                       muffled <- FALSE
[10:27:00.719]                       if (inherits(cond, "message")) {
[10:27:00.719]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:00.719]                         if (muffled) 
[10:27:00.719]                           invokeRestart("muffleMessage")
[10:27:00.719]                       }
[10:27:00.719]                       else if (inherits(cond, "warning")) {
[10:27:00.719]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:00.719]                         if (muffled) 
[10:27:00.719]                           invokeRestart("muffleWarning")
[10:27:00.719]                       }
[10:27:00.719]                       else if (inherits(cond, "condition")) {
[10:27:00.719]                         if (!is.null(pattern)) {
[10:27:00.719]                           computeRestarts <- base::computeRestarts
[10:27:00.719]                           grepl <- base::grepl
[10:27:00.719]                           restarts <- computeRestarts(cond)
[10:27:00.719]                           for (restart in restarts) {
[10:27:00.719]                             name <- restart$name
[10:27:00.719]                             if (is.null(name)) 
[10:27:00.719]                               next
[10:27:00.719]                             if (!grepl(pattern, name)) 
[10:27:00.719]                               next
[10:27:00.719]                             invokeRestart(restart)
[10:27:00.719]                             muffled <- TRUE
[10:27:00.719]                             break
[10:27:00.719]                           }
[10:27:00.719]                         }
[10:27:00.719]                       }
[10:27:00.719]                       invisible(muffled)
[10:27:00.719]                     }
[10:27:00.719]                     muffleCondition(cond, pattern = "^muffle")
[10:27:00.719]                   }
[10:27:00.719]                 }
[10:27:00.719]                 else {
[10:27:00.719]                   if (TRUE) {
[10:27:00.719]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:00.719]                     {
[10:27:00.719]                       inherits <- base::inherits
[10:27:00.719]                       invokeRestart <- base::invokeRestart
[10:27:00.719]                       is.null <- base::is.null
[10:27:00.719]                       muffled <- FALSE
[10:27:00.719]                       if (inherits(cond, "message")) {
[10:27:00.719]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:00.719]                         if (muffled) 
[10:27:00.719]                           invokeRestart("muffleMessage")
[10:27:00.719]                       }
[10:27:00.719]                       else if (inherits(cond, "warning")) {
[10:27:00.719]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:00.719]                         if (muffled) 
[10:27:00.719]                           invokeRestart("muffleWarning")
[10:27:00.719]                       }
[10:27:00.719]                       else if (inherits(cond, "condition")) {
[10:27:00.719]                         if (!is.null(pattern)) {
[10:27:00.719]                           computeRestarts <- base::computeRestarts
[10:27:00.719]                           grepl <- base::grepl
[10:27:00.719]                           restarts <- computeRestarts(cond)
[10:27:00.719]                           for (restart in restarts) {
[10:27:00.719]                             name <- restart$name
[10:27:00.719]                             if (is.null(name)) 
[10:27:00.719]                               next
[10:27:00.719]                             if (!grepl(pattern, name)) 
[10:27:00.719]                               next
[10:27:00.719]                             invokeRestart(restart)
[10:27:00.719]                             muffled <- TRUE
[10:27:00.719]                             break
[10:27:00.719]                           }
[10:27:00.719]                         }
[10:27:00.719]                       }
[10:27:00.719]                       invisible(muffled)
[10:27:00.719]                     }
[10:27:00.719]                     muffleCondition(cond, pattern = "^muffle")
[10:27:00.719]                   }
[10:27:00.719]                 }
[10:27:00.719]             }
[10:27:00.719]         }))
[10:27:00.719]     }, error = function(ex) {
[10:27:00.719]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:00.719]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:00.719]                 ...future.rng), started = ...future.startTime, 
[10:27:00.719]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:00.719]             version = "1.8"), class = "FutureResult")
[10:27:00.719]     }, finally = {
[10:27:00.719]         if (!identical(...future.workdir, getwd())) 
[10:27:00.719]             setwd(...future.workdir)
[10:27:00.719]         {
[10:27:00.719]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:00.719]                 ...future.oldOptions$nwarnings <- NULL
[10:27:00.719]             }
[10:27:00.719]             base::options(...future.oldOptions)
[10:27:00.719]             if (.Platform$OS.type == "windows") {
[10:27:00.719]                 old_names <- names(...future.oldEnvVars)
[10:27:00.719]                 envs <- base::Sys.getenv()
[10:27:00.719]                 names <- names(envs)
[10:27:00.719]                 common <- intersect(names, old_names)
[10:27:00.719]                 added <- setdiff(names, old_names)
[10:27:00.719]                 removed <- setdiff(old_names, names)
[10:27:00.719]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:00.719]                   envs[common]]
[10:27:00.719]                 NAMES <- toupper(changed)
[10:27:00.719]                 args <- list()
[10:27:00.719]                 for (kk in seq_along(NAMES)) {
[10:27:00.719]                   name <- changed[[kk]]
[10:27:00.719]                   NAME <- NAMES[[kk]]
[10:27:00.719]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.719]                     next
[10:27:00.719]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:00.719]                 }
[10:27:00.719]                 NAMES <- toupper(added)
[10:27:00.719]                 for (kk in seq_along(NAMES)) {
[10:27:00.719]                   name <- added[[kk]]
[10:27:00.719]                   NAME <- NAMES[[kk]]
[10:27:00.719]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.719]                     next
[10:27:00.719]                   args[[name]] <- ""
[10:27:00.719]                 }
[10:27:00.719]                 NAMES <- toupper(removed)
[10:27:00.719]                 for (kk in seq_along(NAMES)) {
[10:27:00.719]                   name <- removed[[kk]]
[10:27:00.719]                   NAME <- NAMES[[kk]]
[10:27:00.719]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.719]                     next
[10:27:00.719]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:00.719]                 }
[10:27:00.719]                 if (length(args) > 0) 
[10:27:00.719]                   base::do.call(base::Sys.setenv, args = args)
[10:27:00.719]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:00.719]             }
[10:27:00.719]             else {
[10:27:00.719]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:00.719]             }
[10:27:00.719]             {
[10:27:00.719]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:00.719]                   0L) {
[10:27:00.719]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:00.719]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:00.719]                   base::options(opts)
[10:27:00.719]                 }
[10:27:00.719]                 {
[10:27:00.719]                   {
[10:27:00.719]                     NULL
[10:27:00.719]                     RNGkind("Mersenne-Twister")
[10:27:00.719]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:27:00.719]                       inherits = FALSE)
[10:27:00.719]                   }
[10:27:00.719]                   options(future.plan = NULL)
[10:27:00.719]                   if (is.na(NA_character_)) 
[10:27:00.719]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:00.719]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:00.719]                   future::plan(list(function (..., envir = parent.frame()) 
[10:27:00.719]                   {
[10:27:00.719]                     future <- SequentialFuture(..., envir = envir)
[10:27:00.719]                     if (!future$lazy) 
[10:27:00.719]                       future <- run(future)
[10:27:00.719]                     invisible(future)
[10:27:00.719]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:00.719]                 }
[10:27:00.719]             }
[10:27:00.719]         }
[10:27:00.719]     })
[10:27:00.719]     if (TRUE) {
[10:27:00.719]         base::sink(type = "output", split = FALSE)
[10:27:00.719]         if (TRUE) {
[10:27:00.719]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:00.719]         }
[10:27:00.719]         else {
[10:27:00.719]             ...future.result["stdout"] <- base::list(NULL)
[10:27:00.719]         }
[10:27:00.719]         base::close(...future.stdout)
[10:27:00.719]         ...future.stdout <- NULL
[10:27:00.719]     }
[10:27:00.719]     ...future.result$conditions <- ...future.conditions
[10:27:00.719]     ...future.result$finished <- base::Sys.time()
[10:27:00.719]     ...future.result
[10:27:00.719] }
[10:27:00.721] plan(): Setting new future strategy stack:
[10:27:00.721] List of future strategies:
[10:27:00.721] 1. sequential:
[10:27:00.721]    - args: function (..., envir = parent.frame())
[10:27:00.721]    - tweaked: FALSE
[10:27:00.721]    - call: NULL
[10:27:00.721] plan(): nbrOfWorkers() = 1
[10:27:00.722] plan(): Setting new future strategy stack:
[10:27:00.722] List of future strategies:
[10:27:00.722] 1. sequential:
[10:27:00.722]    - args: function (..., envir = parent.frame())
[10:27:00.722]    - tweaked: FALSE
[10:27:00.722]    - call: plan(strategy)
[10:27:00.723] plan(): nbrOfWorkers() = 1
[10:27:00.723] SequentialFuture started (and completed)
[10:27:00.723] - Launch lazy future ... done
[10:27:00.723] run() for ‘SequentialFuture’ ... done
[10:27:00.723] getGlobalsAndPackages() ...
[10:27:00.723] Searching for globals...
[10:27:00.724] - globals found: [1] ‘{’
[10:27:00.724] Searching for globals ... DONE
[10:27:00.724] Resolving globals: FALSE
[10:27:00.725] 
[10:27:00.725] 
[10:27:00.725] getGlobalsAndPackages() ... DONE
[10:27:00.725] run() for ‘Future’ ...
[10:27:00.725] - state: ‘created’
[10:27:00.725] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:27:00.725] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:27:00.726] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:27:00.726]   - Field: ‘label’
[10:27:00.726]   - Field: ‘local’
[10:27:00.726]   - Field: ‘owner’
[10:27:00.726]   - Field: ‘envir’
[10:27:00.726]   - Field: ‘packages’
[10:27:00.726]   - Field: ‘gc’
[10:27:00.726]   - Field: ‘conditions’
[10:27:00.726]   - Field: ‘expr’
[10:27:00.726]   - Field: ‘uuid’
[10:27:00.727]   - Field: ‘seed’
[10:27:00.727]   - Field: ‘version’
[10:27:00.727]   - Field: ‘result’
[10:27:00.727]   - Field: ‘asynchronous’
[10:27:00.727]   - Field: ‘calls’
[10:27:00.727]   - Field: ‘globals’
[10:27:00.727]   - Field: ‘stdout’
[10:27:00.727]   - Field: ‘earlySignal’
[10:27:00.727]   - Field: ‘lazy’
[10:27:00.727]   - Field: ‘state’
[10:27:00.727] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:27:00.728] - Launch lazy future ...
[10:27:00.728] Packages needed by the future expression (n = 0): <none>
[10:27:00.728] Packages needed by future strategies (n = 0): <none>
[10:27:00.728] {
[10:27:00.728]     {
[10:27:00.728]         {
[10:27:00.728]             ...future.startTime <- base::Sys.time()
[10:27:00.728]             {
[10:27:00.728]                 {
[10:27:00.728]                   {
[10:27:00.728]                     base::local({
[10:27:00.728]                       has_future <- base::requireNamespace("future", 
[10:27:00.728]                         quietly = TRUE)
[10:27:00.728]                       if (has_future) {
[10:27:00.728]                         ns <- base::getNamespace("future")
[10:27:00.728]                         version <- ns[[".package"]][["version"]]
[10:27:00.728]                         if (is.null(version)) 
[10:27:00.728]                           version <- utils::packageVersion("future")
[10:27:00.728]                       }
[10:27:00.728]                       else {
[10:27:00.728]                         version <- NULL
[10:27:00.728]                       }
[10:27:00.728]                       if (!has_future || version < "1.8.0") {
[10:27:00.728]                         info <- base::c(r_version = base::gsub("R version ", 
[10:27:00.728]                           "", base::R.version$version.string), 
[10:27:00.728]                           platform = base::sprintf("%s (%s-bit)", 
[10:27:00.728]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:00.728]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:00.728]                             "release", "version")], collapse = " "), 
[10:27:00.728]                           hostname = base::Sys.info()[["nodename"]])
[10:27:00.728]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:27:00.728]                           info)
[10:27:00.728]                         info <- base::paste(info, collapse = "; ")
[10:27:00.728]                         if (!has_future) {
[10:27:00.728]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:00.728]                             info)
[10:27:00.728]                         }
[10:27:00.728]                         else {
[10:27:00.728]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:00.728]                             info, version)
[10:27:00.728]                         }
[10:27:00.728]                         base::stop(msg)
[10:27:00.728]                       }
[10:27:00.728]                     })
[10:27:00.728]                   }
[10:27:00.728]                   options(future.plan = NULL)
[10:27:00.728]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:00.728]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:00.728]                 }
[10:27:00.728]                 ...future.workdir <- getwd()
[10:27:00.728]             }
[10:27:00.728]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:00.728]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:00.728]         }
[10:27:00.728]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:00.728]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:00.728]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:00.728]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:00.728]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:00.728]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:00.728]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:00.728]             base::names(...future.oldOptions))
[10:27:00.728]     }
[10:27:00.728]     if (FALSE) {
[10:27:00.728]     }
[10:27:00.728]     else {
[10:27:00.728]         if (TRUE) {
[10:27:00.728]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:00.728]                 open = "w")
[10:27:00.728]         }
[10:27:00.728]         else {
[10:27:00.728]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:00.728]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:00.728]         }
[10:27:00.728]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:00.728]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:00.728]             base::sink(type = "output", split = FALSE)
[10:27:00.728]             base::close(...future.stdout)
[10:27:00.728]         }, add = TRUE)
[10:27:00.728]     }
[10:27:00.728]     ...future.frame <- base::sys.nframe()
[10:27:00.728]     ...future.conditions <- base::list()
[10:27:00.728]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:00.728]     if (FALSE) {
[10:27:00.728]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:00.728]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:00.728]     }
[10:27:00.728]     ...future.result <- base::tryCatch({
[10:27:00.728]         base::withCallingHandlers({
[10:27:00.728]             ...future.value <- base::withVisible(base::local({
[10:27:00.728]                 2
[10:27:00.728]             }))
[10:27:00.728]             future::FutureResult(value = ...future.value$value, 
[10:27:00.728]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:00.728]                   ...future.rng), globalenv = if (FALSE) 
[10:27:00.728]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:00.728]                     ...future.globalenv.names))
[10:27:00.728]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:00.728]         }, condition = base::local({
[10:27:00.728]             c <- base::c
[10:27:00.728]             inherits <- base::inherits
[10:27:00.728]             invokeRestart <- base::invokeRestart
[10:27:00.728]             length <- base::length
[10:27:00.728]             list <- base::list
[10:27:00.728]             seq.int <- base::seq.int
[10:27:00.728]             signalCondition <- base::signalCondition
[10:27:00.728]             sys.calls <- base::sys.calls
[10:27:00.728]             `[[` <- base::`[[`
[10:27:00.728]             `+` <- base::`+`
[10:27:00.728]             `<<-` <- base::`<<-`
[10:27:00.728]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:00.728]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:00.728]                   3L)]
[10:27:00.728]             }
[10:27:00.728]             function(cond) {
[10:27:00.728]                 is_error <- inherits(cond, "error")
[10:27:00.728]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:00.728]                   NULL)
[10:27:00.728]                 if (is_error) {
[10:27:00.728]                   sessionInformation <- function() {
[10:27:00.728]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:00.728]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:00.728]                       search = base::search(), system = base::Sys.info())
[10:27:00.728]                   }
[10:27:00.728]                   ...future.conditions[[length(...future.conditions) + 
[10:27:00.728]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:00.728]                     cond$call), session = sessionInformation(), 
[10:27:00.728]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:00.728]                   signalCondition(cond)
[10:27:00.728]                 }
[10:27:00.728]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:00.728]                 "immediateCondition"))) {
[10:27:00.728]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:00.728]                   ...future.conditions[[length(...future.conditions) + 
[10:27:00.728]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:00.728]                   if (TRUE && !signal) {
[10:27:00.728]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:00.728]                     {
[10:27:00.728]                       inherits <- base::inherits
[10:27:00.728]                       invokeRestart <- base::invokeRestart
[10:27:00.728]                       is.null <- base::is.null
[10:27:00.728]                       muffled <- FALSE
[10:27:00.728]                       if (inherits(cond, "message")) {
[10:27:00.728]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:00.728]                         if (muffled) 
[10:27:00.728]                           invokeRestart("muffleMessage")
[10:27:00.728]                       }
[10:27:00.728]                       else if (inherits(cond, "warning")) {
[10:27:00.728]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:00.728]                         if (muffled) 
[10:27:00.728]                           invokeRestart("muffleWarning")
[10:27:00.728]                       }
[10:27:00.728]                       else if (inherits(cond, "condition")) {
[10:27:00.728]                         if (!is.null(pattern)) {
[10:27:00.728]                           computeRestarts <- base::computeRestarts
[10:27:00.728]                           grepl <- base::grepl
[10:27:00.728]                           restarts <- computeRestarts(cond)
[10:27:00.728]                           for (restart in restarts) {
[10:27:00.728]                             name <- restart$name
[10:27:00.728]                             if (is.null(name)) 
[10:27:00.728]                               next
[10:27:00.728]                             if (!grepl(pattern, name)) 
[10:27:00.728]                               next
[10:27:00.728]                             invokeRestart(restart)
[10:27:00.728]                             muffled <- TRUE
[10:27:00.728]                             break
[10:27:00.728]                           }
[10:27:00.728]                         }
[10:27:00.728]                       }
[10:27:00.728]                       invisible(muffled)
[10:27:00.728]                     }
[10:27:00.728]                     muffleCondition(cond, pattern = "^muffle")
[10:27:00.728]                   }
[10:27:00.728]                 }
[10:27:00.728]                 else {
[10:27:00.728]                   if (TRUE) {
[10:27:00.728]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:00.728]                     {
[10:27:00.728]                       inherits <- base::inherits
[10:27:00.728]                       invokeRestart <- base::invokeRestart
[10:27:00.728]                       is.null <- base::is.null
[10:27:00.728]                       muffled <- FALSE
[10:27:00.728]                       if (inherits(cond, "message")) {
[10:27:00.728]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:00.728]                         if (muffled) 
[10:27:00.728]                           invokeRestart("muffleMessage")
[10:27:00.728]                       }
[10:27:00.728]                       else if (inherits(cond, "warning")) {
[10:27:00.728]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:00.728]                         if (muffled) 
[10:27:00.728]                           invokeRestart("muffleWarning")
[10:27:00.728]                       }
[10:27:00.728]                       else if (inherits(cond, "condition")) {
[10:27:00.728]                         if (!is.null(pattern)) {
[10:27:00.728]                           computeRestarts <- base::computeRestarts
[10:27:00.728]                           grepl <- base::grepl
[10:27:00.728]                           restarts <- computeRestarts(cond)
[10:27:00.728]                           for (restart in restarts) {
[10:27:00.728]                             name <- restart$name
[10:27:00.728]                             if (is.null(name)) 
[10:27:00.728]                               next
[10:27:00.728]                             if (!grepl(pattern, name)) 
[10:27:00.728]                               next
[10:27:00.728]                             invokeRestart(restart)
[10:27:00.728]                             muffled <- TRUE
[10:27:00.728]                             break
[10:27:00.728]                           }
[10:27:00.728]                         }
[10:27:00.728]                       }
[10:27:00.728]                       invisible(muffled)
[10:27:00.728]                     }
[10:27:00.728]                     muffleCondition(cond, pattern = "^muffle")
[10:27:00.728]                   }
[10:27:00.728]                 }
[10:27:00.728]             }
[10:27:00.728]         }))
[10:27:00.728]     }, error = function(ex) {
[10:27:00.728]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:00.728]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:00.728]                 ...future.rng), started = ...future.startTime, 
[10:27:00.728]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:00.728]             version = "1.8"), class = "FutureResult")
[10:27:00.728]     }, finally = {
[10:27:00.728]         if (!identical(...future.workdir, getwd())) 
[10:27:00.728]             setwd(...future.workdir)
[10:27:00.728]         {
[10:27:00.728]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:00.728]                 ...future.oldOptions$nwarnings <- NULL
[10:27:00.728]             }
[10:27:00.728]             base::options(...future.oldOptions)
[10:27:00.728]             if (.Platform$OS.type == "windows") {
[10:27:00.728]                 old_names <- names(...future.oldEnvVars)
[10:27:00.728]                 envs <- base::Sys.getenv()
[10:27:00.728]                 names <- names(envs)
[10:27:00.728]                 common <- intersect(names, old_names)
[10:27:00.728]                 added <- setdiff(names, old_names)
[10:27:00.728]                 removed <- setdiff(old_names, names)
[10:27:00.728]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:00.728]                   envs[common]]
[10:27:00.728]                 NAMES <- toupper(changed)
[10:27:00.728]                 args <- list()
[10:27:00.728]                 for (kk in seq_along(NAMES)) {
[10:27:00.728]                   name <- changed[[kk]]
[10:27:00.728]                   NAME <- NAMES[[kk]]
[10:27:00.728]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.728]                     next
[10:27:00.728]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:00.728]                 }
[10:27:00.728]                 NAMES <- toupper(added)
[10:27:00.728]                 for (kk in seq_along(NAMES)) {
[10:27:00.728]                   name <- added[[kk]]
[10:27:00.728]                   NAME <- NAMES[[kk]]
[10:27:00.728]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.728]                     next
[10:27:00.728]                   args[[name]] <- ""
[10:27:00.728]                 }
[10:27:00.728]                 NAMES <- toupper(removed)
[10:27:00.728]                 for (kk in seq_along(NAMES)) {
[10:27:00.728]                   name <- removed[[kk]]
[10:27:00.728]                   NAME <- NAMES[[kk]]
[10:27:00.728]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.728]                     next
[10:27:00.728]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:00.728]                 }
[10:27:00.728]                 if (length(args) > 0) 
[10:27:00.728]                   base::do.call(base::Sys.setenv, args = args)
[10:27:00.728]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:00.728]             }
[10:27:00.728]             else {
[10:27:00.728]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:00.728]             }
[10:27:00.728]             {
[10:27:00.728]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:00.728]                   0L) {
[10:27:00.728]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:00.728]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:00.728]                   base::options(opts)
[10:27:00.728]                 }
[10:27:00.728]                 {
[10:27:00.728]                   {
[10:27:00.728]                     NULL
[10:27:00.728]                     RNGkind("Mersenne-Twister")
[10:27:00.728]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:27:00.728]                       inherits = FALSE)
[10:27:00.728]                   }
[10:27:00.728]                   options(future.plan = NULL)
[10:27:00.728]                   if (is.na(NA_character_)) 
[10:27:00.728]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:00.728]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:00.728]                   future::plan(list(function (..., envir = parent.frame()) 
[10:27:00.728]                   {
[10:27:00.728]                     future <- SequentialFuture(..., envir = envir)
[10:27:00.728]                     if (!future$lazy) 
[10:27:00.728]                       future <- run(future)
[10:27:00.728]                     invisible(future)
[10:27:00.728]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:00.728]                 }
[10:27:00.728]             }
[10:27:00.728]         }
[10:27:00.728]     })
[10:27:00.728]     if (TRUE) {
[10:27:00.728]         base::sink(type = "output", split = FALSE)
[10:27:00.728]         if (TRUE) {
[10:27:00.728]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:00.728]         }
[10:27:00.728]         else {
[10:27:00.728]             ...future.result["stdout"] <- base::list(NULL)
[10:27:00.728]         }
[10:27:00.728]         base::close(...future.stdout)
[10:27:00.728]         ...future.stdout <- NULL
[10:27:00.728]     }
[10:27:00.728]     ...future.result$conditions <- ...future.conditions
[10:27:00.728]     ...future.result$finished <- base::Sys.time()
[10:27:00.728]     ...future.result
[10:27:00.728] }
[10:27:00.730] plan(): Setting new future strategy stack:
[10:27:00.730] List of future strategies:
[10:27:00.730] 1. sequential:
[10:27:00.730]    - args: function (..., envir = parent.frame())
[10:27:00.730]    - tweaked: FALSE
[10:27:00.730]    - call: NULL
[10:27:00.730] plan(): nbrOfWorkers() = 1
[10:27:00.731] plan(): Setting new future strategy stack:
[10:27:00.731] List of future strategies:
[10:27:00.731] 1. sequential:
[10:27:00.731]    - args: function (..., envir = parent.frame())
[10:27:00.731]    - tweaked: FALSE
[10:27:00.731]    - call: plan(strategy)
[10:27:00.732] plan(): nbrOfWorkers() = 1
[10:27:00.732] SequentialFuture started (and completed)
[10:27:00.732] - Launch lazy future ... done
[10:27:00.732] run() for ‘SequentialFuture’ ... done
[10:27:00.733] resolve() on environment ...
[10:27:00.733]  recursive: 0
[10:27:00.733]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[10:27:00.733] resolved() for ‘SequentialFuture’ ...
[10:27:00.733] - state: ‘finished’
[10:27:00.733] - run: TRUE
[10:27:00.733] - result: ‘FutureResult’
[10:27:00.734] resolved() for ‘SequentialFuture’ ... done
[10:27:00.734] Future #1
[10:27:00.734]  length: 2 (resolved future 1)
[10:27:00.734] resolved() for ‘SequentialFuture’ ...
[10:27:00.734] - state: ‘finished’
[10:27:00.734] - run: TRUE
[10:27:00.734] - result: ‘FutureResult’
[10:27:00.734] resolved() for ‘SequentialFuture’ ... done
[10:27:00.734] Future #2
[10:27:00.734]  length: 1 (resolved future 2)
[10:27:00.735]  length: 0 (resolved future 3)
[10:27:00.735] resolve() on environment ... DONE
[10:27:00.735] getGlobalsAndPackages() ...
[10:27:00.735] Searching for globals...
[10:27:00.736] - globals found: [1] ‘{’
[10:27:00.736] Searching for globals ... DONE
[10:27:00.736] Resolving globals: FALSE
[10:27:00.736] 
[10:27:00.736] 
[10:27:00.736] getGlobalsAndPackages() ... DONE
[10:27:00.737] run() for ‘Future’ ...
[10:27:00.737] - state: ‘created’
[10:27:00.737] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:27:00.737] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:27:00.737] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:27:00.737]   - Field: ‘label’
[10:27:00.737]   - Field: ‘local’
[10:27:00.737]   - Field: ‘owner’
[10:27:00.738]   - Field: ‘envir’
[10:27:00.738]   - Field: ‘packages’
[10:27:00.738]   - Field: ‘gc’
[10:27:00.738]   - Field: ‘conditions’
[10:27:00.738]   - Field: ‘expr’
[10:27:00.738]   - Field: ‘uuid’
[10:27:00.738]   - Field: ‘seed’
[10:27:00.738]   - Field: ‘version’
[10:27:00.738]   - Field: ‘result’
[10:27:00.738]   - Field: ‘asynchronous’
[10:27:00.738]   - Field: ‘calls’
[10:27:00.739]   - Field: ‘globals’
[10:27:00.739]   - Field: ‘stdout’
[10:27:00.739]   - Field: ‘earlySignal’
[10:27:00.739]   - Field: ‘lazy’
[10:27:00.739]   - Field: ‘state’
[10:27:00.739] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:27:00.739] - Launch lazy future ...
[10:27:00.739] Packages needed by the future expression (n = 0): <none>
[10:27:00.739] Packages needed by future strategies (n = 0): <none>
[10:27:00.740] {
[10:27:00.740]     {
[10:27:00.740]         {
[10:27:00.740]             ...future.startTime <- base::Sys.time()
[10:27:00.740]             {
[10:27:00.740]                 {
[10:27:00.740]                   {
[10:27:00.740]                     base::local({
[10:27:00.740]                       has_future <- base::requireNamespace("future", 
[10:27:00.740]                         quietly = TRUE)
[10:27:00.740]                       if (has_future) {
[10:27:00.740]                         ns <- base::getNamespace("future")
[10:27:00.740]                         version <- ns[[".package"]][["version"]]
[10:27:00.740]                         if (is.null(version)) 
[10:27:00.740]                           version <- utils::packageVersion("future")
[10:27:00.740]                       }
[10:27:00.740]                       else {
[10:27:00.740]                         version <- NULL
[10:27:00.740]                       }
[10:27:00.740]                       if (!has_future || version < "1.8.0") {
[10:27:00.740]                         info <- base::c(r_version = base::gsub("R version ", 
[10:27:00.740]                           "", base::R.version$version.string), 
[10:27:00.740]                           platform = base::sprintf("%s (%s-bit)", 
[10:27:00.740]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:00.740]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:00.740]                             "release", "version")], collapse = " "), 
[10:27:00.740]                           hostname = base::Sys.info()[["nodename"]])
[10:27:00.740]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:27:00.740]                           info)
[10:27:00.740]                         info <- base::paste(info, collapse = "; ")
[10:27:00.740]                         if (!has_future) {
[10:27:00.740]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:00.740]                             info)
[10:27:00.740]                         }
[10:27:00.740]                         else {
[10:27:00.740]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:00.740]                             info, version)
[10:27:00.740]                         }
[10:27:00.740]                         base::stop(msg)
[10:27:00.740]                       }
[10:27:00.740]                     })
[10:27:00.740]                   }
[10:27:00.740]                   options(future.plan = NULL)
[10:27:00.740]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:00.740]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:00.740]                 }
[10:27:00.740]                 ...future.workdir <- getwd()
[10:27:00.740]             }
[10:27:00.740]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:00.740]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:00.740]         }
[10:27:00.740]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:00.740]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:00.740]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:00.740]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:00.740]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:00.740]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:00.740]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:00.740]             base::names(...future.oldOptions))
[10:27:00.740]     }
[10:27:00.740]     if (FALSE) {
[10:27:00.740]     }
[10:27:00.740]     else {
[10:27:00.740]         if (TRUE) {
[10:27:00.740]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:00.740]                 open = "w")
[10:27:00.740]         }
[10:27:00.740]         else {
[10:27:00.740]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:00.740]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:00.740]         }
[10:27:00.740]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:00.740]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:00.740]             base::sink(type = "output", split = FALSE)
[10:27:00.740]             base::close(...future.stdout)
[10:27:00.740]         }, add = TRUE)
[10:27:00.740]     }
[10:27:00.740]     ...future.frame <- base::sys.nframe()
[10:27:00.740]     ...future.conditions <- base::list()
[10:27:00.740]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:00.740]     if (FALSE) {
[10:27:00.740]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:00.740]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:00.740]     }
[10:27:00.740]     ...future.result <- base::tryCatch({
[10:27:00.740]         base::withCallingHandlers({
[10:27:00.740]             ...future.value <- base::withVisible(base::local({
[10:27:00.740]                 1
[10:27:00.740]             }))
[10:27:00.740]             future::FutureResult(value = ...future.value$value, 
[10:27:00.740]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:00.740]                   ...future.rng), globalenv = if (FALSE) 
[10:27:00.740]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:00.740]                     ...future.globalenv.names))
[10:27:00.740]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:00.740]         }, condition = base::local({
[10:27:00.740]             c <- base::c
[10:27:00.740]             inherits <- base::inherits
[10:27:00.740]             invokeRestart <- base::invokeRestart
[10:27:00.740]             length <- base::length
[10:27:00.740]             list <- base::list
[10:27:00.740]             seq.int <- base::seq.int
[10:27:00.740]             signalCondition <- base::signalCondition
[10:27:00.740]             sys.calls <- base::sys.calls
[10:27:00.740]             `[[` <- base::`[[`
[10:27:00.740]             `+` <- base::`+`
[10:27:00.740]             `<<-` <- base::`<<-`
[10:27:00.740]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:00.740]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:00.740]                   3L)]
[10:27:00.740]             }
[10:27:00.740]             function(cond) {
[10:27:00.740]                 is_error <- inherits(cond, "error")
[10:27:00.740]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:00.740]                   NULL)
[10:27:00.740]                 if (is_error) {
[10:27:00.740]                   sessionInformation <- function() {
[10:27:00.740]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:00.740]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:00.740]                       search = base::search(), system = base::Sys.info())
[10:27:00.740]                   }
[10:27:00.740]                   ...future.conditions[[length(...future.conditions) + 
[10:27:00.740]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:00.740]                     cond$call), session = sessionInformation(), 
[10:27:00.740]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:00.740]                   signalCondition(cond)
[10:27:00.740]                 }
[10:27:00.740]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:00.740]                 "immediateCondition"))) {
[10:27:00.740]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:00.740]                   ...future.conditions[[length(...future.conditions) + 
[10:27:00.740]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:00.740]                   if (TRUE && !signal) {
[10:27:00.740]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:00.740]                     {
[10:27:00.740]                       inherits <- base::inherits
[10:27:00.740]                       invokeRestart <- base::invokeRestart
[10:27:00.740]                       is.null <- base::is.null
[10:27:00.740]                       muffled <- FALSE
[10:27:00.740]                       if (inherits(cond, "message")) {
[10:27:00.740]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:00.740]                         if (muffled) 
[10:27:00.740]                           invokeRestart("muffleMessage")
[10:27:00.740]                       }
[10:27:00.740]                       else if (inherits(cond, "warning")) {
[10:27:00.740]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:00.740]                         if (muffled) 
[10:27:00.740]                           invokeRestart("muffleWarning")
[10:27:00.740]                       }
[10:27:00.740]                       else if (inherits(cond, "condition")) {
[10:27:00.740]                         if (!is.null(pattern)) {
[10:27:00.740]                           computeRestarts <- base::computeRestarts
[10:27:00.740]                           grepl <- base::grepl
[10:27:00.740]                           restarts <- computeRestarts(cond)
[10:27:00.740]                           for (restart in restarts) {
[10:27:00.740]                             name <- restart$name
[10:27:00.740]                             if (is.null(name)) 
[10:27:00.740]                               next
[10:27:00.740]                             if (!grepl(pattern, name)) 
[10:27:00.740]                               next
[10:27:00.740]                             invokeRestart(restart)
[10:27:00.740]                             muffled <- TRUE
[10:27:00.740]                             break
[10:27:00.740]                           }
[10:27:00.740]                         }
[10:27:00.740]                       }
[10:27:00.740]                       invisible(muffled)
[10:27:00.740]                     }
[10:27:00.740]                     muffleCondition(cond, pattern = "^muffle")
[10:27:00.740]                   }
[10:27:00.740]                 }
[10:27:00.740]                 else {
[10:27:00.740]                   if (TRUE) {
[10:27:00.740]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:00.740]                     {
[10:27:00.740]                       inherits <- base::inherits
[10:27:00.740]                       invokeRestart <- base::invokeRestart
[10:27:00.740]                       is.null <- base::is.null
[10:27:00.740]                       muffled <- FALSE
[10:27:00.740]                       if (inherits(cond, "message")) {
[10:27:00.740]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:00.740]                         if (muffled) 
[10:27:00.740]                           invokeRestart("muffleMessage")
[10:27:00.740]                       }
[10:27:00.740]                       else if (inherits(cond, "warning")) {
[10:27:00.740]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:00.740]                         if (muffled) 
[10:27:00.740]                           invokeRestart("muffleWarning")
[10:27:00.740]                       }
[10:27:00.740]                       else if (inherits(cond, "condition")) {
[10:27:00.740]                         if (!is.null(pattern)) {
[10:27:00.740]                           computeRestarts <- base::computeRestarts
[10:27:00.740]                           grepl <- base::grepl
[10:27:00.740]                           restarts <- computeRestarts(cond)
[10:27:00.740]                           for (restart in restarts) {
[10:27:00.740]                             name <- restart$name
[10:27:00.740]                             if (is.null(name)) 
[10:27:00.740]                               next
[10:27:00.740]                             if (!grepl(pattern, name)) 
[10:27:00.740]                               next
[10:27:00.740]                             invokeRestart(restart)
[10:27:00.740]                             muffled <- TRUE
[10:27:00.740]                             break
[10:27:00.740]                           }
[10:27:00.740]                         }
[10:27:00.740]                       }
[10:27:00.740]                       invisible(muffled)
[10:27:00.740]                     }
[10:27:00.740]                     muffleCondition(cond, pattern = "^muffle")
[10:27:00.740]                   }
[10:27:00.740]                 }
[10:27:00.740]             }
[10:27:00.740]         }))
[10:27:00.740]     }, error = function(ex) {
[10:27:00.740]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:00.740]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:00.740]                 ...future.rng), started = ...future.startTime, 
[10:27:00.740]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:00.740]             version = "1.8"), class = "FutureResult")
[10:27:00.740]     }, finally = {
[10:27:00.740]         if (!identical(...future.workdir, getwd())) 
[10:27:00.740]             setwd(...future.workdir)
[10:27:00.740]         {
[10:27:00.740]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:00.740]                 ...future.oldOptions$nwarnings <- NULL
[10:27:00.740]             }
[10:27:00.740]             base::options(...future.oldOptions)
[10:27:00.740]             if (.Platform$OS.type == "windows") {
[10:27:00.740]                 old_names <- names(...future.oldEnvVars)
[10:27:00.740]                 envs <- base::Sys.getenv()
[10:27:00.740]                 names <- names(envs)
[10:27:00.740]                 common <- intersect(names, old_names)
[10:27:00.740]                 added <- setdiff(names, old_names)
[10:27:00.740]                 removed <- setdiff(old_names, names)
[10:27:00.740]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:00.740]                   envs[common]]
[10:27:00.740]                 NAMES <- toupper(changed)
[10:27:00.740]                 args <- list()
[10:27:00.740]                 for (kk in seq_along(NAMES)) {
[10:27:00.740]                   name <- changed[[kk]]
[10:27:00.740]                   NAME <- NAMES[[kk]]
[10:27:00.740]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.740]                     next
[10:27:00.740]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:00.740]                 }
[10:27:00.740]                 NAMES <- toupper(added)
[10:27:00.740]                 for (kk in seq_along(NAMES)) {
[10:27:00.740]                   name <- added[[kk]]
[10:27:00.740]                   NAME <- NAMES[[kk]]
[10:27:00.740]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.740]                     next
[10:27:00.740]                   args[[name]] <- ""
[10:27:00.740]                 }
[10:27:00.740]                 NAMES <- toupper(removed)
[10:27:00.740]                 for (kk in seq_along(NAMES)) {
[10:27:00.740]                   name <- removed[[kk]]
[10:27:00.740]                   NAME <- NAMES[[kk]]
[10:27:00.740]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.740]                     next
[10:27:00.740]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:00.740]                 }
[10:27:00.740]                 if (length(args) > 0) 
[10:27:00.740]                   base::do.call(base::Sys.setenv, args = args)
[10:27:00.740]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:00.740]             }
[10:27:00.740]             else {
[10:27:00.740]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:00.740]             }
[10:27:00.740]             {
[10:27:00.740]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:00.740]                   0L) {
[10:27:00.740]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:00.740]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:00.740]                   base::options(opts)
[10:27:00.740]                 }
[10:27:00.740]                 {
[10:27:00.740]                   {
[10:27:00.740]                     NULL
[10:27:00.740]                     RNGkind("Mersenne-Twister")
[10:27:00.740]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:27:00.740]                       inherits = FALSE)
[10:27:00.740]                   }
[10:27:00.740]                   options(future.plan = NULL)
[10:27:00.740]                   if (is.na(NA_character_)) 
[10:27:00.740]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:00.740]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:00.740]                   future::plan(list(function (..., envir = parent.frame()) 
[10:27:00.740]                   {
[10:27:00.740]                     future <- SequentialFuture(..., envir = envir)
[10:27:00.740]                     if (!future$lazy) 
[10:27:00.740]                       future <- run(future)
[10:27:00.740]                     invisible(future)
[10:27:00.740]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:00.740]                 }
[10:27:00.740]             }
[10:27:00.740]         }
[10:27:00.740]     })
[10:27:00.740]     if (TRUE) {
[10:27:00.740]         base::sink(type = "output", split = FALSE)
[10:27:00.740]         if (TRUE) {
[10:27:00.740]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:00.740]         }
[10:27:00.740]         else {
[10:27:00.740]             ...future.result["stdout"] <- base::list(NULL)
[10:27:00.740]         }
[10:27:00.740]         base::close(...future.stdout)
[10:27:00.740]         ...future.stdout <- NULL
[10:27:00.740]     }
[10:27:00.740]     ...future.result$conditions <- ...future.conditions
[10:27:00.740]     ...future.result$finished <- base::Sys.time()
[10:27:00.740]     ...future.result
[10:27:00.740] }
[10:27:00.742] plan(): Setting new future strategy stack:
[10:27:00.742] List of future strategies:
[10:27:00.742] 1. sequential:
[10:27:00.742]    - args: function (..., envir = parent.frame())
[10:27:00.742]    - tweaked: FALSE
[10:27:00.742]    - call: NULL
[10:27:00.742] plan(): nbrOfWorkers() = 1
[10:27:00.745] plan(): Setting new future strategy stack:
[10:27:00.745] List of future strategies:
[10:27:00.745] 1. sequential:
[10:27:00.745]    - args: function (..., envir = parent.frame())
[10:27:00.745]    - tweaked: FALSE
[10:27:00.745]    - call: plan(strategy)
[10:27:00.745] plan(): nbrOfWorkers() = 1
[10:27:00.745] SequentialFuture started (and completed)
[10:27:00.745] - Launch lazy future ... done
[10:27:00.745] run() for ‘SequentialFuture’ ... done
[10:27:00.746] getGlobalsAndPackages() ...
[10:27:00.746] Searching for globals...
[10:27:00.746] - globals found: [1] ‘{’
[10:27:00.747] Searching for globals ... DONE
[10:27:00.747] Resolving globals: FALSE
[10:27:00.747] 
[10:27:00.747] 
[10:27:00.747] getGlobalsAndPackages() ... DONE
[10:27:00.747] run() for ‘Future’ ...
[10:27:00.747] - state: ‘created’
[10:27:00.748] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:27:00.748] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:27:00.748] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:27:00.748]   - Field: ‘label’
[10:27:00.748]   - Field: ‘local’
[10:27:00.748]   - Field: ‘owner’
[10:27:00.748]   - Field: ‘envir’
[10:27:00.748]   - Field: ‘packages’
[10:27:00.749]   - Field: ‘gc’
[10:27:00.749]   - Field: ‘conditions’
[10:27:00.749]   - Field: ‘expr’
[10:27:00.749]   - Field: ‘uuid’
[10:27:00.749]   - Field: ‘seed’
[10:27:00.749]   - Field: ‘version’
[10:27:00.749]   - Field: ‘result’
[10:27:00.749]   - Field: ‘asynchronous’
[10:27:00.749]   - Field: ‘calls’
[10:27:00.750]   - Field: ‘globals’
[10:27:00.750]   - Field: ‘stdout’
[10:27:00.750]   - Field: ‘earlySignal’
[10:27:00.750]   - Field: ‘lazy’
[10:27:00.750]   - Field: ‘state’
[10:27:00.750] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:27:00.750] - Launch lazy future ...
[10:27:00.750] Packages needed by the future expression (n = 0): <none>
[10:27:00.751] Packages needed by future strategies (n = 0): <none>
[10:27:00.751] {
[10:27:00.751]     {
[10:27:00.751]         {
[10:27:00.751]             ...future.startTime <- base::Sys.time()
[10:27:00.751]             {
[10:27:00.751]                 {
[10:27:00.751]                   {
[10:27:00.751]                     base::local({
[10:27:00.751]                       has_future <- base::requireNamespace("future", 
[10:27:00.751]                         quietly = TRUE)
[10:27:00.751]                       if (has_future) {
[10:27:00.751]                         ns <- base::getNamespace("future")
[10:27:00.751]                         version <- ns[[".package"]][["version"]]
[10:27:00.751]                         if (is.null(version)) 
[10:27:00.751]                           version <- utils::packageVersion("future")
[10:27:00.751]                       }
[10:27:00.751]                       else {
[10:27:00.751]                         version <- NULL
[10:27:00.751]                       }
[10:27:00.751]                       if (!has_future || version < "1.8.0") {
[10:27:00.751]                         info <- base::c(r_version = base::gsub("R version ", 
[10:27:00.751]                           "", base::R.version$version.string), 
[10:27:00.751]                           platform = base::sprintf("%s (%s-bit)", 
[10:27:00.751]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:00.751]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:00.751]                             "release", "version")], collapse = " "), 
[10:27:00.751]                           hostname = base::Sys.info()[["nodename"]])
[10:27:00.751]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:27:00.751]                           info)
[10:27:00.751]                         info <- base::paste(info, collapse = "; ")
[10:27:00.751]                         if (!has_future) {
[10:27:00.751]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:00.751]                             info)
[10:27:00.751]                         }
[10:27:00.751]                         else {
[10:27:00.751]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:00.751]                             info, version)
[10:27:00.751]                         }
[10:27:00.751]                         base::stop(msg)
[10:27:00.751]                       }
[10:27:00.751]                     })
[10:27:00.751]                   }
[10:27:00.751]                   options(future.plan = NULL)
[10:27:00.751]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:00.751]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:00.751]                 }
[10:27:00.751]                 ...future.workdir <- getwd()
[10:27:00.751]             }
[10:27:00.751]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:00.751]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:00.751]         }
[10:27:00.751]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:00.751]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:00.751]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:00.751]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:00.751]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:00.751]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:00.751]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:00.751]             base::names(...future.oldOptions))
[10:27:00.751]     }
[10:27:00.751]     if (FALSE) {
[10:27:00.751]     }
[10:27:00.751]     else {
[10:27:00.751]         if (TRUE) {
[10:27:00.751]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:00.751]                 open = "w")
[10:27:00.751]         }
[10:27:00.751]         else {
[10:27:00.751]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:00.751]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:00.751]         }
[10:27:00.751]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:00.751]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:00.751]             base::sink(type = "output", split = FALSE)
[10:27:00.751]             base::close(...future.stdout)
[10:27:00.751]         }, add = TRUE)
[10:27:00.751]     }
[10:27:00.751]     ...future.frame <- base::sys.nframe()
[10:27:00.751]     ...future.conditions <- base::list()
[10:27:00.751]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:00.751]     if (FALSE) {
[10:27:00.751]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:00.751]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:00.751]     }
[10:27:00.751]     ...future.result <- base::tryCatch({
[10:27:00.751]         base::withCallingHandlers({
[10:27:00.751]             ...future.value <- base::withVisible(base::local({
[10:27:00.751]                 2
[10:27:00.751]             }))
[10:27:00.751]             future::FutureResult(value = ...future.value$value, 
[10:27:00.751]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:00.751]                   ...future.rng), globalenv = if (FALSE) 
[10:27:00.751]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:00.751]                     ...future.globalenv.names))
[10:27:00.751]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:00.751]         }, condition = base::local({
[10:27:00.751]             c <- base::c
[10:27:00.751]             inherits <- base::inherits
[10:27:00.751]             invokeRestart <- base::invokeRestart
[10:27:00.751]             length <- base::length
[10:27:00.751]             list <- base::list
[10:27:00.751]             seq.int <- base::seq.int
[10:27:00.751]             signalCondition <- base::signalCondition
[10:27:00.751]             sys.calls <- base::sys.calls
[10:27:00.751]             `[[` <- base::`[[`
[10:27:00.751]             `+` <- base::`+`
[10:27:00.751]             `<<-` <- base::`<<-`
[10:27:00.751]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:00.751]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:00.751]                   3L)]
[10:27:00.751]             }
[10:27:00.751]             function(cond) {
[10:27:00.751]                 is_error <- inherits(cond, "error")
[10:27:00.751]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:00.751]                   NULL)
[10:27:00.751]                 if (is_error) {
[10:27:00.751]                   sessionInformation <- function() {
[10:27:00.751]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:00.751]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:00.751]                       search = base::search(), system = base::Sys.info())
[10:27:00.751]                   }
[10:27:00.751]                   ...future.conditions[[length(...future.conditions) + 
[10:27:00.751]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:00.751]                     cond$call), session = sessionInformation(), 
[10:27:00.751]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:00.751]                   signalCondition(cond)
[10:27:00.751]                 }
[10:27:00.751]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:00.751]                 "immediateCondition"))) {
[10:27:00.751]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:00.751]                   ...future.conditions[[length(...future.conditions) + 
[10:27:00.751]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:00.751]                   if (TRUE && !signal) {
[10:27:00.751]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:00.751]                     {
[10:27:00.751]                       inherits <- base::inherits
[10:27:00.751]                       invokeRestart <- base::invokeRestart
[10:27:00.751]                       is.null <- base::is.null
[10:27:00.751]                       muffled <- FALSE
[10:27:00.751]                       if (inherits(cond, "message")) {
[10:27:00.751]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:00.751]                         if (muffled) 
[10:27:00.751]                           invokeRestart("muffleMessage")
[10:27:00.751]                       }
[10:27:00.751]                       else if (inherits(cond, "warning")) {
[10:27:00.751]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:00.751]                         if (muffled) 
[10:27:00.751]                           invokeRestart("muffleWarning")
[10:27:00.751]                       }
[10:27:00.751]                       else if (inherits(cond, "condition")) {
[10:27:00.751]                         if (!is.null(pattern)) {
[10:27:00.751]                           computeRestarts <- base::computeRestarts
[10:27:00.751]                           grepl <- base::grepl
[10:27:00.751]                           restarts <- computeRestarts(cond)
[10:27:00.751]                           for (restart in restarts) {
[10:27:00.751]                             name <- restart$name
[10:27:00.751]                             if (is.null(name)) 
[10:27:00.751]                               next
[10:27:00.751]                             if (!grepl(pattern, name)) 
[10:27:00.751]                               next
[10:27:00.751]                             invokeRestart(restart)
[10:27:00.751]                             muffled <- TRUE
[10:27:00.751]                             break
[10:27:00.751]                           }
[10:27:00.751]                         }
[10:27:00.751]                       }
[10:27:00.751]                       invisible(muffled)
[10:27:00.751]                     }
[10:27:00.751]                     muffleCondition(cond, pattern = "^muffle")
[10:27:00.751]                   }
[10:27:00.751]                 }
[10:27:00.751]                 else {
[10:27:00.751]                   if (TRUE) {
[10:27:00.751]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:00.751]                     {
[10:27:00.751]                       inherits <- base::inherits
[10:27:00.751]                       invokeRestart <- base::invokeRestart
[10:27:00.751]                       is.null <- base::is.null
[10:27:00.751]                       muffled <- FALSE
[10:27:00.751]                       if (inherits(cond, "message")) {
[10:27:00.751]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:00.751]                         if (muffled) 
[10:27:00.751]                           invokeRestart("muffleMessage")
[10:27:00.751]                       }
[10:27:00.751]                       else if (inherits(cond, "warning")) {
[10:27:00.751]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:00.751]                         if (muffled) 
[10:27:00.751]                           invokeRestart("muffleWarning")
[10:27:00.751]                       }
[10:27:00.751]                       else if (inherits(cond, "condition")) {
[10:27:00.751]                         if (!is.null(pattern)) {
[10:27:00.751]                           computeRestarts <- base::computeRestarts
[10:27:00.751]                           grepl <- base::grepl
[10:27:00.751]                           restarts <- computeRestarts(cond)
[10:27:00.751]                           for (restart in restarts) {
[10:27:00.751]                             name <- restart$name
[10:27:00.751]                             if (is.null(name)) 
[10:27:00.751]                               next
[10:27:00.751]                             if (!grepl(pattern, name)) 
[10:27:00.751]                               next
[10:27:00.751]                             invokeRestart(restart)
[10:27:00.751]                             muffled <- TRUE
[10:27:00.751]                             break
[10:27:00.751]                           }
[10:27:00.751]                         }
[10:27:00.751]                       }
[10:27:00.751]                       invisible(muffled)
[10:27:00.751]                     }
[10:27:00.751]                     muffleCondition(cond, pattern = "^muffle")
[10:27:00.751]                   }
[10:27:00.751]                 }
[10:27:00.751]             }
[10:27:00.751]         }))
[10:27:00.751]     }, error = function(ex) {
[10:27:00.751]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:00.751]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:00.751]                 ...future.rng), started = ...future.startTime, 
[10:27:00.751]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:00.751]             version = "1.8"), class = "FutureResult")
[10:27:00.751]     }, finally = {
[10:27:00.751]         if (!identical(...future.workdir, getwd())) 
[10:27:00.751]             setwd(...future.workdir)
[10:27:00.751]         {
[10:27:00.751]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:00.751]                 ...future.oldOptions$nwarnings <- NULL
[10:27:00.751]             }
[10:27:00.751]             base::options(...future.oldOptions)
[10:27:00.751]             if (.Platform$OS.type == "windows") {
[10:27:00.751]                 old_names <- names(...future.oldEnvVars)
[10:27:00.751]                 envs <- base::Sys.getenv()
[10:27:00.751]                 names <- names(envs)
[10:27:00.751]                 common <- intersect(names, old_names)
[10:27:00.751]                 added <- setdiff(names, old_names)
[10:27:00.751]                 removed <- setdiff(old_names, names)
[10:27:00.751]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:00.751]                   envs[common]]
[10:27:00.751]                 NAMES <- toupper(changed)
[10:27:00.751]                 args <- list()
[10:27:00.751]                 for (kk in seq_along(NAMES)) {
[10:27:00.751]                   name <- changed[[kk]]
[10:27:00.751]                   NAME <- NAMES[[kk]]
[10:27:00.751]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.751]                     next
[10:27:00.751]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:00.751]                 }
[10:27:00.751]                 NAMES <- toupper(added)
[10:27:00.751]                 for (kk in seq_along(NAMES)) {
[10:27:00.751]                   name <- added[[kk]]
[10:27:00.751]                   NAME <- NAMES[[kk]]
[10:27:00.751]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.751]                     next
[10:27:00.751]                   args[[name]] <- ""
[10:27:00.751]                 }
[10:27:00.751]                 NAMES <- toupper(removed)
[10:27:00.751]                 for (kk in seq_along(NAMES)) {
[10:27:00.751]                   name <- removed[[kk]]
[10:27:00.751]                   NAME <- NAMES[[kk]]
[10:27:00.751]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.751]                     next
[10:27:00.751]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:00.751]                 }
[10:27:00.751]                 if (length(args) > 0) 
[10:27:00.751]                   base::do.call(base::Sys.setenv, args = args)
[10:27:00.751]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:00.751]             }
[10:27:00.751]             else {
[10:27:00.751]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:00.751]             }
[10:27:00.751]             {
[10:27:00.751]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:00.751]                   0L) {
[10:27:00.751]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:00.751]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:00.751]                   base::options(opts)
[10:27:00.751]                 }
[10:27:00.751]                 {
[10:27:00.751]                   {
[10:27:00.751]                     NULL
[10:27:00.751]                     RNGkind("Mersenne-Twister")
[10:27:00.751]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:27:00.751]                       inherits = FALSE)
[10:27:00.751]                   }
[10:27:00.751]                   options(future.plan = NULL)
[10:27:00.751]                   if (is.na(NA_character_)) 
[10:27:00.751]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:00.751]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:00.751]                   future::plan(list(function (..., envir = parent.frame()) 
[10:27:00.751]                   {
[10:27:00.751]                     future <- SequentialFuture(..., envir = envir)
[10:27:00.751]                     if (!future$lazy) 
[10:27:00.751]                       future <- run(future)
[10:27:00.751]                     invisible(future)
[10:27:00.751]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:00.751]                 }
[10:27:00.751]             }
[10:27:00.751]         }
[10:27:00.751]     })
[10:27:00.751]     if (TRUE) {
[10:27:00.751]         base::sink(type = "output", split = FALSE)
[10:27:00.751]         if (TRUE) {
[10:27:00.751]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:00.751]         }
[10:27:00.751]         else {
[10:27:00.751]             ...future.result["stdout"] <- base::list(NULL)
[10:27:00.751]         }
[10:27:00.751]         base::close(...future.stdout)
[10:27:00.751]         ...future.stdout <- NULL
[10:27:00.751]     }
[10:27:00.751]     ...future.result$conditions <- ...future.conditions
[10:27:00.751]     ...future.result$finished <- base::Sys.time()
[10:27:00.751]     ...future.result
[10:27:00.751] }
[10:27:00.753] plan(): Setting new future strategy stack:
[10:27:00.753] List of future strategies:
[10:27:00.753] 1. sequential:
[10:27:00.753]    - args: function (..., envir = parent.frame())
[10:27:00.753]    - tweaked: FALSE
[10:27:00.753]    - call: NULL
[10:27:00.753] plan(): nbrOfWorkers() = 1
[10:27:00.754] plan(): Setting new future strategy stack:
[10:27:00.754] List of future strategies:
[10:27:00.754] 1. sequential:
[10:27:00.754]    - args: function (..., envir = parent.frame())
[10:27:00.754]    - tweaked: FALSE
[10:27:00.754]    - call: plan(strategy)
[10:27:00.754] plan(): nbrOfWorkers() = 1
[10:27:00.755] SequentialFuture started (and completed)
[10:27:00.755] - Launch lazy future ... done
[10:27:00.755] run() for ‘SequentialFuture’ ... done
[10:27:00.755] resolve() on environment ...
[10:27:00.755]  recursive: 0
[10:27:00.756]  elements: [3] ‘a’
[10:27:00.756] resolved() for ‘SequentialFuture’ ...
[10:27:00.756] - state: ‘finished’
[10:27:00.756] - run: TRUE
[10:27:00.756] - result: ‘FutureResult’
[10:27:00.756] resolved() for ‘SequentialFuture’ ... done
[10:27:00.757] Future #1
[10:27:00.757]  length: 2 (resolved future 1)
[10:27:00.757] resolved() for ‘SequentialFuture’ ...
[10:27:00.757] - state: ‘finished’
[10:27:00.757] - run: TRUE
[10:27:00.757] - result: ‘FutureResult’
[10:27:00.757] resolved() for ‘SequentialFuture’ ... done
[10:27:00.757] Future #2
[10:27:00.757]  length: 1 (resolved future 2)
[10:27:00.757]  length: 0 (resolved future 3)
[10:27:00.758] resolve() on environment ... DONE
[10:27:00.758] resolved() for ‘SequentialFuture’ ...
[10:27:00.758] - state: ‘finished’
[10:27:00.758] - run: TRUE
[10:27:00.758] - result: ‘FutureResult’
[10:27:00.758] resolved() for ‘SequentialFuture’ ... done
[10:27:00.759] resolve() on environment ...
[10:27:00.759]  recursive: 0
[10:27:00.759]  elements: [3] ‘b’
[10:27:00.759] resolved() for ‘SequentialFuture’ ...
[10:27:00.759] - state: ‘finished’
[10:27:00.759] - run: TRUE
[10:27:00.760] - result: ‘FutureResult’
[10:27:00.760] resolved() for ‘SequentialFuture’ ... done
[10:27:00.760] Future #1
[10:27:00.760]  length: 2 (resolved future 1)
[10:27:00.760] resolved() for ‘SequentialFuture’ ...
[10:27:00.760] - state: ‘finished’
[10:27:00.760] - run: TRUE
[10:27:00.760] - result: ‘FutureResult’
[10:27:00.760] resolved() for ‘SequentialFuture’ ... done
[10:27:00.760] Future #2
[10:27:00.760]  length: 1 (resolved future 2)
[10:27:00.761]  length: 0 (resolved future 3)
[10:27:00.761] resolve() on environment ... DONE
[10:27:00.761] resolve() on environment ...
[10:27:00.761]  recursive: 0
[10:27:00.762]  elements: [3] ‘c’
[10:27:00.762] resolved() for ‘SequentialFuture’ ...
[10:27:00.762] - state: ‘finished’
[10:27:00.762] - run: TRUE
[10:27:00.762] - result: ‘FutureResult’
[10:27:00.762] resolved() for ‘SequentialFuture’ ... done
[10:27:00.762] Future #1
[10:27:00.762]  length: 2 (resolved future 1)
[10:27:00.763] resolved() for ‘SequentialFuture’ ...
[10:27:00.763] - state: ‘finished’
[10:27:00.763] - run: TRUE
[10:27:00.763] - result: ‘FutureResult’
[10:27:00.763] resolved() for ‘SequentialFuture’ ... done
[10:27:00.763] Future #2
[10:27:00.763]  length: 1 (resolved future 2)
[10:27:00.763]  length: 0 (resolved future 3)
[10:27:00.763] resolve() on environment ... DONE
[10:27:00.764] resolve() on environment ...
[10:27:00.764]  recursive: 0
[10:27:00.764]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[10:27:00.764] resolved() for ‘SequentialFuture’ ...
[10:27:00.764] - state: ‘finished’
[10:27:00.765] - run: TRUE
[10:27:00.765] - result: ‘FutureResult’
[10:27:00.765] resolved() for ‘SequentialFuture’ ... done
[10:27:00.765] Future #1
[10:27:00.765]  length: 2 (resolved future 1)
[10:27:00.766] resolved() for ‘SequentialFuture’ ...
[10:27:00.766] - state: ‘finished’
[10:27:00.766] - run: TRUE
[10:27:00.766] - result: ‘FutureResult’
[10:27:00.766] resolved() for ‘SequentialFuture’ ... done
[10:27:00.766] Future #2
[10:27:00.766]  length: 1 (resolved future 2)
[10:27:00.766]  length: 0 (resolved future 3)
[10:27:00.766] resolve() on environment ... DONE
[10:27:00.767] resolve() on environment ...
[10:27:00.767]  recursive: 99
[10:27:00.767]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[10:27:00.767] resolved() for ‘SequentialFuture’ ...
[10:27:00.768] - state: ‘finished’
[10:27:00.768] - run: TRUE
[10:27:00.768] - result: ‘FutureResult’
[10:27:00.768] resolved() for ‘SequentialFuture’ ... done
[10:27:00.768] Future #1
[10:27:00.768] resolved() for ‘SequentialFuture’ ...
[10:27:00.768] - state: ‘finished’
[10:27:00.768] - run: TRUE
[10:27:00.768] - result: ‘FutureResult’
[10:27:00.768] resolved() for ‘SequentialFuture’ ... done
[10:27:00.769] A SequentialFuture was resolved
[10:27:00.769]  length: 2 (resolved future 1)
[10:27:00.769] resolved() for ‘SequentialFuture’ ...
[10:27:00.771] - state: ‘finished’
[10:27:00.771] - run: TRUE
[10:27:00.771] - result: ‘FutureResult’
[10:27:00.771] resolved() for ‘SequentialFuture’ ... done
[10:27:00.771] Future #2
[10:27:00.772] resolved() for ‘SequentialFuture’ ...
[10:27:00.772] - state: ‘finished’
[10:27:00.772] - run: TRUE
[10:27:00.772] - result: ‘FutureResult’
[10:27:00.772] resolved() for ‘SequentialFuture’ ... done
[10:27:00.772] A SequentialFuture was resolved
[10:27:00.772]  length: 1 (resolved future 2)
[10:27:00.772]  length: 0 (resolved future 3)
[10:27:00.772] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[10:27:00.774] resolve() on list environment ...
[10:27:00.774]  recursive: 0
[10:27:00.775]  length: 2
[10:27:00.775]  elements: ‘a’, ‘b’
[10:27:00.775]  length: 1 (resolved future 1)
[10:27:00.775]  length: 0 (resolved future 2)
[10:27:00.775] resolve() on list environment ... DONE
[10:27:00.775] getGlobalsAndPackages() ...
[10:27:00.775] Searching for globals...
[10:27:00.776] 
[10:27:00.776] Searching for globals ... DONE
[10:27:00.776] - globals: [0] <none>
[10:27:00.776] getGlobalsAndPackages() ... DONE
[10:27:00.776] run() for ‘Future’ ...
[10:27:00.776] - state: ‘created’
[10:27:00.777] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:27:00.777] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:27:00.777] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:27:00.777]   - Field: ‘label’
[10:27:00.777]   - Field: ‘local’
[10:27:00.777]   - Field: ‘owner’
[10:27:00.777]   - Field: ‘envir’
[10:27:00.777]   - Field: ‘packages’
[10:27:00.778]   - Field: ‘gc’
[10:27:00.778]   - Field: ‘conditions’
[10:27:00.778]   - Field: ‘expr’
[10:27:00.778]   - Field: ‘uuid’
[10:27:00.778]   - Field: ‘seed’
[10:27:00.778]   - Field: ‘version’
[10:27:00.778]   - Field: ‘result’
[10:27:00.778]   - Field: ‘asynchronous’
[10:27:00.778]   - Field: ‘calls’
[10:27:00.778]   - Field: ‘globals’
[10:27:00.778]   - Field: ‘stdout’
[10:27:00.779]   - Field: ‘earlySignal’
[10:27:00.779]   - Field: ‘lazy’
[10:27:00.779]   - Field: ‘state’
[10:27:00.779] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:27:00.779] - Launch lazy future ...
[10:27:00.779] Packages needed by the future expression (n = 0): <none>
[10:27:00.779] Packages needed by future strategies (n = 0): <none>
[10:27:00.780] {
[10:27:00.780]     {
[10:27:00.780]         {
[10:27:00.780]             ...future.startTime <- base::Sys.time()
[10:27:00.780]             {
[10:27:00.780]                 {
[10:27:00.780]                   {
[10:27:00.780]                     base::local({
[10:27:00.780]                       has_future <- base::requireNamespace("future", 
[10:27:00.780]                         quietly = TRUE)
[10:27:00.780]                       if (has_future) {
[10:27:00.780]                         ns <- base::getNamespace("future")
[10:27:00.780]                         version <- ns[[".package"]][["version"]]
[10:27:00.780]                         if (is.null(version)) 
[10:27:00.780]                           version <- utils::packageVersion("future")
[10:27:00.780]                       }
[10:27:00.780]                       else {
[10:27:00.780]                         version <- NULL
[10:27:00.780]                       }
[10:27:00.780]                       if (!has_future || version < "1.8.0") {
[10:27:00.780]                         info <- base::c(r_version = base::gsub("R version ", 
[10:27:00.780]                           "", base::R.version$version.string), 
[10:27:00.780]                           platform = base::sprintf("%s (%s-bit)", 
[10:27:00.780]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:00.780]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:00.780]                             "release", "version")], collapse = " "), 
[10:27:00.780]                           hostname = base::Sys.info()[["nodename"]])
[10:27:00.780]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:27:00.780]                           info)
[10:27:00.780]                         info <- base::paste(info, collapse = "; ")
[10:27:00.780]                         if (!has_future) {
[10:27:00.780]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:00.780]                             info)
[10:27:00.780]                         }
[10:27:00.780]                         else {
[10:27:00.780]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:00.780]                             info, version)
[10:27:00.780]                         }
[10:27:00.780]                         base::stop(msg)
[10:27:00.780]                       }
[10:27:00.780]                     })
[10:27:00.780]                   }
[10:27:00.780]                   options(future.plan = NULL)
[10:27:00.780]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:00.780]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:00.780]                 }
[10:27:00.780]                 ...future.workdir <- getwd()
[10:27:00.780]             }
[10:27:00.780]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:00.780]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:00.780]         }
[10:27:00.780]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:00.780]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:00.780]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:00.780]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:00.780]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:00.780]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:00.780]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:00.780]             base::names(...future.oldOptions))
[10:27:00.780]     }
[10:27:00.780]     if (FALSE) {
[10:27:00.780]     }
[10:27:00.780]     else {
[10:27:00.780]         if (TRUE) {
[10:27:00.780]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:00.780]                 open = "w")
[10:27:00.780]         }
[10:27:00.780]         else {
[10:27:00.780]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:00.780]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:00.780]         }
[10:27:00.780]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:00.780]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:00.780]             base::sink(type = "output", split = FALSE)
[10:27:00.780]             base::close(...future.stdout)
[10:27:00.780]         }, add = TRUE)
[10:27:00.780]     }
[10:27:00.780]     ...future.frame <- base::sys.nframe()
[10:27:00.780]     ...future.conditions <- base::list()
[10:27:00.780]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:00.780]     if (FALSE) {
[10:27:00.780]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:00.780]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:00.780]     }
[10:27:00.780]     ...future.result <- base::tryCatch({
[10:27:00.780]         base::withCallingHandlers({
[10:27:00.780]             ...future.value <- base::withVisible(base::local(1))
[10:27:00.780]             future::FutureResult(value = ...future.value$value, 
[10:27:00.780]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:00.780]                   ...future.rng), globalenv = if (FALSE) 
[10:27:00.780]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:00.780]                     ...future.globalenv.names))
[10:27:00.780]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:00.780]         }, condition = base::local({
[10:27:00.780]             c <- base::c
[10:27:00.780]             inherits <- base::inherits
[10:27:00.780]             invokeRestart <- base::invokeRestart
[10:27:00.780]             length <- base::length
[10:27:00.780]             list <- base::list
[10:27:00.780]             seq.int <- base::seq.int
[10:27:00.780]             signalCondition <- base::signalCondition
[10:27:00.780]             sys.calls <- base::sys.calls
[10:27:00.780]             `[[` <- base::`[[`
[10:27:00.780]             `+` <- base::`+`
[10:27:00.780]             `<<-` <- base::`<<-`
[10:27:00.780]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:00.780]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:00.780]                   3L)]
[10:27:00.780]             }
[10:27:00.780]             function(cond) {
[10:27:00.780]                 is_error <- inherits(cond, "error")
[10:27:00.780]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:00.780]                   NULL)
[10:27:00.780]                 if (is_error) {
[10:27:00.780]                   sessionInformation <- function() {
[10:27:00.780]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:00.780]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:00.780]                       search = base::search(), system = base::Sys.info())
[10:27:00.780]                   }
[10:27:00.780]                   ...future.conditions[[length(...future.conditions) + 
[10:27:00.780]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:00.780]                     cond$call), session = sessionInformation(), 
[10:27:00.780]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:00.780]                   signalCondition(cond)
[10:27:00.780]                 }
[10:27:00.780]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:00.780]                 "immediateCondition"))) {
[10:27:00.780]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:00.780]                   ...future.conditions[[length(...future.conditions) + 
[10:27:00.780]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:00.780]                   if (TRUE && !signal) {
[10:27:00.780]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:00.780]                     {
[10:27:00.780]                       inherits <- base::inherits
[10:27:00.780]                       invokeRestart <- base::invokeRestart
[10:27:00.780]                       is.null <- base::is.null
[10:27:00.780]                       muffled <- FALSE
[10:27:00.780]                       if (inherits(cond, "message")) {
[10:27:00.780]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:00.780]                         if (muffled) 
[10:27:00.780]                           invokeRestart("muffleMessage")
[10:27:00.780]                       }
[10:27:00.780]                       else if (inherits(cond, "warning")) {
[10:27:00.780]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:00.780]                         if (muffled) 
[10:27:00.780]                           invokeRestart("muffleWarning")
[10:27:00.780]                       }
[10:27:00.780]                       else if (inherits(cond, "condition")) {
[10:27:00.780]                         if (!is.null(pattern)) {
[10:27:00.780]                           computeRestarts <- base::computeRestarts
[10:27:00.780]                           grepl <- base::grepl
[10:27:00.780]                           restarts <- computeRestarts(cond)
[10:27:00.780]                           for (restart in restarts) {
[10:27:00.780]                             name <- restart$name
[10:27:00.780]                             if (is.null(name)) 
[10:27:00.780]                               next
[10:27:00.780]                             if (!grepl(pattern, name)) 
[10:27:00.780]                               next
[10:27:00.780]                             invokeRestart(restart)
[10:27:00.780]                             muffled <- TRUE
[10:27:00.780]                             break
[10:27:00.780]                           }
[10:27:00.780]                         }
[10:27:00.780]                       }
[10:27:00.780]                       invisible(muffled)
[10:27:00.780]                     }
[10:27:00.780]                     muffleCondition(cond, pattern = "^muffle")
[10:27:00.780]                   }
[10:27:00.780]                 }
[10:27:00.780]                 else {
[10:27:00.780]                   if (TRUE) {
[10:27:00.780]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:00.780]                     {
[10:27:00.780]                       inherits <- base::inherits
[10:27:00.780]                       invokeRestart <- base::invokeRestart
[10:27:00.780]                       is.null <- base::is.null
[10:27:00.780]                       muffled <- FALSE
[10:27:00.780]                       if (inherits(cond, "message")) {
[10:27:00.780]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:00.780]                         if (muffled) 
[10:27:00.780]                           invokeRestart("muffleMessage")
[10:27:00.780]                       }
[10:27:00.780]                       else if (inherits(cond, "warning")) {
[10:27:00.780]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:00.780]                         if (muffled) 
[10:27:00.780]                           invokeRestart("muffleWarning")
[10:27:00.780]                       }
[10:27:00.780]                       else if (inherits(cond, "condition")) {
[10:27:00.780]                         if (!is.null(pattern)) {
[10:27:00.780]                           computeRestarts <- base::computeRestarts
[10:27:00.780]                           grepl <- base::grepl
[10:27:00.780]                           restarts <- computeRestarts(cond)
[10:27:00.780]                           for (restart in restarts) {
[10:27:00.780]                             name <- restart$name
[10:27:00.780]                             if (is.null(name)) 
[10:27:00.780]                               next
[10:27:00.780]                             if (!grepl(pattern, name)) 
[10:27:00.780]                               next
[10:27:00.780]                             invokeRestart(restart)
[10:27:00.780]                             muffled <- TRUE
[10:27:00.780]                             break
[10:27:00.780]                           }
[10:27:00.780]                         }
[10:27:00.780]                       }
[10:27:00.780]                       invisible(muffled)
[10:27:00.780]                     }
[10:27:00.780]                     muffleCondition(cond, pattern = "^muffle")
[10:27:00.780]                   }
[10:27:00.780]                 }
[10:27:00.780]             }
[10:27:00.780]         }))
[10:27:00.780]     }, error = function(ex) {
[10:27:00.780]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:00.780]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:00.780]                 ...future.rng), started = ...future.startTime, 
[10:27:00.780]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:00.780]             version = "1.8"), class = "FutureResult")
[10:27:00.780]     }, finally = {
[10:27:00.780]         if (!identical(...future.workdir, getwd())) 
[10:27:00.780]             setwd(...future.workdir)
[10:27:00.780]         {
[10:27:00.780]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:00.780]                 ...future.oldOptions$nwarnings <- NULL
[10:27:00.780]             }
[10:27:00.780]             base::options(...future.oldOptions)
[10:27:00.780]             if (.Platform$OS.type == "windows") {
[10:27:00.780]                 old_names <- names(...future.oldEnvVars)
[10:27:00.780]                 envs <- base::Sys.getenv()
[10:27:00.780]                 names <- names(envs)
[10:27:00.780]                 common <- intersect(names, old_names)
[10:27:00.780]                 added <- setdiff(names, old_names)
[10:27:00.780]                 removed <- setdiff(old_names, names)
[10:27:00.780]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:00.780]                   envs[common]]
[10:27:00.780]                 NAMES <- toupper(changed)
[10:27:00.780]                 args <- list()
[10:27:00.780]                 for (kk in seq_along(NAMES)) {
[10:27:00.780]                   name <- changed[[kk]]
[10:27:00.780]                   NAME <- NAMES[[kk]]
[10:27:00.780]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.780]                     next
[10:27:00.780]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:00.780]                 }
[10:27:00.780]                 NAMES <- toupper(added)
[10:27:00.780]                 for (kk in seq_along(NAMES)) {
[10:27:00.780]                   name <- added[[kk]]
[10:27:00.780]                   NAME <- NAMES[[kk]]
[10:27:00.780]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.780]                     next
[10:27:00.780]                   args[[name]] <- ""
[10:27:00.780]                 }
[10:27:00.780]                 NAMES <- toupper(removed)
[10:27:00.780]                 for (kk in seq_along(NAMES)) {
[10:27:00.780]                   name <- removed[[kk]]
[10:27:00.780]                   NAME <- NAMES[[kk]]
[10:27:00.780]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.780]                     next
[10:27:00.780]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:00.780]                 }
[10:27:00.780]                 if (length(args) > 0) 
[10:27:00.780]                   base::do.call(base::Sys.setenv, args = args)
[10:27:00.780]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:00.780]             }
[10:27:00.780]             else {
[10:27:00.780]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:00.780]             }
[10:27:00.780]             {
[10:27:00.780]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:00.780]                   0L) {
[10:27:00.780]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:00.780]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:00.780]                   base::options(opts)
[10:27:00.780]                 }
[10:27:00.780]                 {
[10:27:00.780]                   {
[10:27:00.780]                     NULL
[10:27:00.780]                     RNGkind("Mersenne-Twister")
[10:27:00.780]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:27:00.780]                       inherits = FALSE)
[10:27:00.780]                   }
[10:27:00.780]                   options(future.plan = NULL)
[10:27:00.780]                   if (is.na(NA_character_)) 
[10:27:00.780]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:00.780]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:00.780]                   future::plan(list(function (..., envir = parent.frame()) 
[10:27:00.780]                   {
[10:27:00.780]                     future <- SequentialFuture(..., envir = envir)
[10:27:00.780]                     if (!future$lazy) 
[10:27:00.780]                       future <- run(future)
[10:27:00.780]                     invisible(future)
[10:27:00.780]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:00.780]                 }
[10:27:00.780]             }
[10:27:00.780]         }
[10:27:00.780]     })
[10:27:00.780]     if (TRUE) {
[10:27:00.780]         base::sink(type = "output", split = FALSE)
[10:27:00.780]         if (TRUE) {
[10:27:00.780]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:00.780]         }
[10:27:00.780]         else {
[10:27:00.780]             ...future.result["stdout"] <- base::list(NULL)
[10:27:00.780]         }
[10:27:00.780]         base::close(...future.stdout)
[10:27:00.780]         ...future.stdout <- NULL
[10:27:00.780]     }
[10:27:00.780]     ...future.result$conditions <- ...future.conditions
[10:27:00.780]     ...future.result$finished <- base::Sys.time()
[10:27:00.780]     ...future.result
[10:27:00.780] }
[10:27:00.782] plan(): Setting new future strategy stack:
[10:27:00.782] List of future strategies:
[10:27:00.782] 1. sequential:
[10:27:00.782]    - args: function (..., envir = parent.frame())
[10:27:00.782]    - tweaked: FALSE
[10:27:00.782]    - call: NULL
[10:27:00.782] plan(): nbrOfWorkers() = 1
[10:27:00.783] plan(): Setting new future strategy stack:
[10:27:00.783] List of future strategies:
[10:27:00.783] 1. sequential:
[10:27:00.783]    - args: function (..., envir = parent.frame())
[10:27:00.783]    - tweaked: FALSE
[10:27:00.783]    - call: plan(strategy)
[10:27:00.783] plan(): nbrOfWorkers() = 1
[10:27:00.783] SequentialFuture started (and completed)
[10:27:00.784] - Launch lazy future ... done
[10:27:00.784] run() for ‘SequentialFuture’ ... done
[10:27:00.784] getGlobalsAndPackages() ...
[10:27:00.784] Searching for globals...
[10:27:00.784] 
[10:27:00.784] Searching for globals ... DONE
[10:27:00.784] - globals: [0] <none>
[10:27:00.785] getGlobalsAndPackages() ... DONE
[10:27:00.785] run() for ‘Future’ ...
[10:27:00.785] - state: ‘created’
[10:27:00.785] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:27:00.785] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:27:00.785] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:27:00.785]   - Field: ‘label’
[10:27:00.786]   - Field: ‘local’
[10:27:00.786]   - Field: ‘owner’
[10:27:00.786]   - Field: ‘envir’
[10:27:00.786]   - Field: ‘packages’
[10:27:00.786]   - Field: ‘gc’
[10:27:00.786]   - Field: ‘conditions’
[10:27:00.786]   - Field: ‘expr’
[10:27:00.786]   - Field: ‘uuid’
[10:27:00.786]   - Field: ‘seed’
[10:27:00.786]   - Field: ‘version’
[10:27:00.787]   - Field: ‘result’
[10:27:00.787]   - Field: ‘asynchronous’
[10:27:00.787]   - Field: ‘calls’
[10:27:00.787]   - Field: ‘globals’
[10:27:00.787]   - Field: ‘stdout’
[10:27:00.787]   - Field: ‘earlySignal’
[10:27:00.787]   - Field: ‘lazy’
[10:27:00.787]   - Field: ‘state’
[10:27:00.787] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:27:00.787] - Launch lazy future ...
[10:27:00.788] Packages needed by the future expression (n = 0): <none>
[10:27:00.788] Packages needed by future strategies (n = 0): <none>
[10:27:00.788] {
[10:27:00.788]     {
[10:27:00.788]         {
[10:27:00.788]             ...future.startTime <- base::Sys.time()
[10:27:00.788]             {
[10:27:00.788]                 {
[10:27:00.788]                   {
[10:27:00.788]                     base::local({
[10:27:00.788]                       has_future <- base::requireNamespace("future", 
[10:27:00.788]                         quietly = TRUE)
[10:27:00.788]                       if (has_future) {
[10:27:00.788]                         ns <- base::getNamespace("future")
[10:27:00.788]                         version <- ns[[".package"]][["version"]]
[10:27:00.788]                         if (is.null(version)) 
[10:27:00.788]                           version <- utils::packageVersion("future")
[10:27:00.788]                       }
[10:27:00.788]                       else {
[10:27:00.788]                         version <- NULL
[10:27:00.788]                       }
[10:27:00.788]                       if (!has_future || version < "1.8.0") {
[10:27:00.788]                         info <- base::c(r_version = base::gsub("R version ", 
[10:27:00.788]                           "", base::R.version$version.string), 
[10:27:00.788]                           platform = base::sprintf("%s (%s-bit)", 
[10:27:00.788]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:00.788]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:00.788]                             "release", "version")], collapse = " "), 
[10:27:00.788]                           hostname = base::Sys.info()[["nodename"]])
[10:27:00.788]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:27:00.788]                           info)
[10:27:00.788]                         info <- base::paste(info, collapse = "; ")
[10:27:00.788]                         if (!has_future) {
[10:27:00.788]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:00.788]                             info)
[10:27:00.788]                         }
[10:27:00.788]                         else {
[10:27:00.788]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:00.788]                             info, version)
[10:27:00.788]                         }
[10:27:00.788]                         base::stop(msg)
[10:27:00.788]                       }
[10:27:00.788]                     })
[10:27:00.788]                   }
[10:27:00.788]                   options(future.plan = NULL)
[10:27:00.788]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:00.788]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:00.788]                 }
[10:27:00.788]                 ...future.workdir <- getwd()
[10:27:00.788]             }
[10:27:00.788]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:00.788]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:00.788]         }
[10:27:00.788]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:00.788]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:00.788]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:00.788]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:00.788]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:00.788]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:00.788]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:00.788]             base::names(...future.oldOptions))
[10:27:00.788]     }
[10:27:00.788]     if (FALSE) {
[10:27:00.788]     }
[10:27:00.788]     else {
[10:27:00.788]         if (TRUE) {
[10:27:00.788]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:00.788]                 open = "w")
[10:27:00.788]         }
[10:27:00.788]         else {
[10:27:00.788]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:00.788]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:00.788]         }
[10:27:00.788]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:00.788]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:00.788]             base::sink(type = "output", split = FALSE)
[10:27:00.788]             base::close(...future.stdout)
[10:27:00.788]         }, add = TRUE)
[10:27:00.788]     }
[10:27:00.788]     ...future.frame <- base::sys.nframe()
[10:27:00.788]     ...future.conditions <- base::list()
[10:27:00.788]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:00.788]     if (FALSE) {
[10:27:00.788]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:00.788]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:00.788]     }
[10:27:00.788]     ...future.result <- base::tryCatch({
[10:27:00.788]         base::withCallingHandlers({
[10:27:00.788]             ...future.value <- base::withVisible(base::local(2))
[10:27:00.788]             future::FutureResult(value = ...future.value$value, 
[10:27:00.788]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:00.788]                   ...future.rng), globalenv = if (FALSE) 
[10:27:00.788]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:00.788]                     ...future.globalenv.names))
[10:27:00.788]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:00.788]         }, condition = base::local({
[10:27:00.788]             c <- base::c
[10:27:00.788]             inherits <- base::inherits
[10:27:00.788]             invokeRestart <- base::invokeRestart
[10:27:00.788]             length <- base::length
[10:27:00.788]             list <- base::list
[10:27:00.788]             seq.int <- base::seq.int
[10:27:00.788]             signalCondition <- base::signalCondition
[10:27:00.788]             sys.calls <- base::sys.calls
[10:27:00.788]             `[[` <- base::`[[`
[10:27:00.788]             `+` <- base::`+`
[10:27:00.788]             `<<-` <- base::`<<-`
[10:27:00.788]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:00.788]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:00.788]                   3L)]
[10:27:00.788]             }
[10:27:00.788]             function(cond) {
[10:27:00.788]                 is_error <- inherits(cond, "error")
[10:27:00.788]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:00.788]                   NULL)
[10:27:00.788]                 if (is_error) {
[10:27:00.788]                   sessionInformation <- function() {
[10:27:00.788]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:00.788]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:00.788]                       search = base::search(), system = base::Sys.info())
[10:27:00.788]                   }
[10:27:00.788]                   ...future.conditions[[length(...future.conditions) + 
[10:27:00.788]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:00.788]                     cond$call), session = sessionInformation(), 
[10:27:00.788]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:00.788]                   signalCondition(cond)
[10:27:00.788]                 }
[10:27:00.788]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:00.788]                 "immediateCondition"))) {
[10:27:00.788]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:00.788]                   ...future.conditions[[length(...future.conditions) + 
[10:27:00.788]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:00.788]                   if (TRUE && !signal) {
[10:27:00.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:00.788]                     {
[10:27:00.788]                       inherits <- base::inherits
[10:27:00.788]                       invokeRestart <- base::invokeRestart
[10:27:00.788]                       is.null <- base::is.null
[10:27:00.788]                       muffled <- FALSE
[10:27:00.788]                       if (inherits(cond, "message")) {
[10:27:00.788]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:00.788]                         if (muffled) 
[10:27:00.788]                           invokeRestart("muffleMessage")
[10:27:00.788]                       }
[10:27:00.788]                       else if (inherits(cond, "warning")) {
[10:27:00.788]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:00.788]                         if (muffled) 
[10:27:00.788]                           invokeRestart("muffleWarning")
[10:27:00.788]                       }
[10:27:00.788]                       else if (inherits(cond, "condition")) {
[10:27:00.788]                         if (!is.null(pattern)) {
[10:27:00.788]                           computeRestarts <- base::computeRestarts
[10:27:00.788]                           grepl <- base::grepl
[10:27:00.788]                           restarts <- computeRestarts(cond)
[10:27:00.788]                           for (restart in restarts) {
[10:27:00.788]                             name <- restart$name
[10:27:00.788]                             if (is.null(name)) 
[10:27:00.788]                               next
[10:27:00.788]                             if (!grepl(pattern, name)) 
[10:27:00.788]                               next
[10:27:00.788]                             invokeRestart(restart)
[10:27:00.788]                             muffled <- TRUE
[10:27:00.788]                             break
[10:27:00.788]                           }
[10:27:00.788]                         }
[10:27:00.788]                       }
[10:27:00.788]                       invisible(muffled)
[10:27:00.788]                     }
[10:27:00.788]                     muffleCondition(cond, pattern = "^muffle")
[10:27:00.788]                   }
[10:27:00.788]                 }
[10:27:00.788]                 else {
[10:27:00.788]                   if (TRUE) {
[10:27:00.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:00.788]                     {
[10:27:00.788]                       inherits <- base::inherits
[10:27:00.788]                       invokeRestart <- base::invokeRestart
[10:27:00.788]                       is.null <- base::is.null
[10:27:00.788]                       muffled <- FALSE
[10:27:00.788]                       if (inherits(cond, "message")) {
[10:27:00.788]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:00.788]                         if (muffled) 
[10:27:00.788]                           invokeRestart("muffleMessage")
[10:27:00.788]                       }
[10:27:00.788]                       else if (inherits(cond, "warning")) {
[10:27:00.788]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:00.788]                         if (muffled) 
[10:27:00.788]                           invokeRestart("muffleWarning")
[10:27:00.788]                       }
[10:27:00.788]                       else if (inherits(cond, "condition")) {
[10:27:00.788]                         if (!is.null(pattern)) {
[10:27:00.788]                           computeRestarts <- base::computeRestarts
[10:27:00.788]                           grepl <- base::grepl
[10:27:00.788]                           restarts <- computeRestarts(cond)
[10:27:00.788]                           for (restart in restarts) {
[10:27:00.788]                             name <- restart$name
[10:27:00.788]                             if (is.null(name)) 
[10:27:00.788]                               next
[10:27:00.788]                             if (!grepl(pattern, name)) 
[10:27:00.788]                               next
[10:27:00.788]                             invokeRestart(restart)
[10:27:00.788]                             muffled <- TRUE
[10:27:00.788]                             break
[10:27:00.788]                           }
[10:27:00.788]                         }
[10:27:00.788]                       }
[10:27:00.788]                       invisible(muffled)
[10:27:00.788]                     }
[10:27:00.788]                     muffleCondition(cond, pattern = "^muffle")
[10:27:00.788]                   }
[10:27:00.788]                 }
[10:27:00.788]             }
[10:27:00.788]         }))
[10:27:00.788]     }, error = function(ex) {
[10:27:00.788]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:00.788]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:00.788]                 ...future.rng), started = ...future.startTime, 
[10:27:00.788]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:00.788]             version = "1.8"), class = "FutureResult")
[10:27:00.788]     }, finally = {
[10:27:00.788]         if (!identical(...future.workdir, getwd())) 
[10:27:00.788]             setwd(...future.workdir)
[10:27:00.788]         {
[10:27:00.788]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:00.788]                 ...future.oldOptions$nwarnings <- NULL
[10:27:00.788]             }
[10:27:00.788]             base::options(...future.oldOptions)
[10:27:00.788]             if (.Platform$OS.type == "windows") {
[10:27:00.788]                 old_names <- names(...future.oldEnvVars)
[10:27:00.788]                 envs <- base::Sys.getenv()
[10:27:00.788]                 names <- names(envs)
[10:27:00.788]                 common <- intersect(names, old_names)
[10:27:00.788]                 added <- setdiff(names, old_names)
[10:27:00.788]                 removed <- setdiff(old_names, names)
[10:27:00.788]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:00.788]                   envs[common]]
[10:27:00.788]                 NAMES <- toupper(changed)
[10:27:00.788]                 args <- list()
[10:27:00.788]                 for (kk in seq_along(NAMES)) {
[10:27:00.788]                   name <- changed[[kk]]
[10:27:00.788]                   NAME <- NAMES[[kk]]
[10:27:00.788]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.788]                     next
[10:27:00.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:00.788]                 }
[10:27:00.788]                 NAMES <- toupper(added)
[10:27:00.788]                 for (kk in seq_along(NAMES)) {
[10:27:00.788]                   name <- added[[kk]]
[10:27:00.788]                   NAME <- NAMES[[kk]]
[10:27:00.788]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.788]                     next
[10:27:00.788]                   args[[name]] <- ""
[10:27:00.788]                 }
[10:27:00.788]                 NAMES <- toupper(removed)
[10:27:00.788]                 for (kk in seq_along(NAMES)) {
[10:27:00.788]                   name <- removed[[kk]]
[10:27:00.788]                   NAME <- NAMES[[kk]]
[10:27:00.788]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.788]                     next
[10:27:00.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:00.788]                 }
[10:27:00.788]                 if (length(args) > 0) 
[10:27:00.788]                   base::do.call(base::Sys.setenv, args = args)
[10:27:00.788]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:00.788]             }
[10:27:00.788]             else {
[10:27:00.788]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:00.788]             }
[10:27:00.788]             {
[10:27:00.788]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:00.788]                   0L) {
[10:27:00.788]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:00.788]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:00.788]                   base::options(opts)
[10:27:00.788]                 }
[10:27:00.788]                 {
[10:27:00.788]                   {
[10:27:00.788]                     NULL
[10:27:00.788]                     RNGkind("Mersenne-Twister")
[10:27:00.788]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:27:00.788]                       inherits = FALSE)
[10:27:00.788]                   }
[10:27:00.788]                   options(future.plan = NULL)
[10:27:00.788]                   if (is.na(NA_character_)) 
[10:27:00.788]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:00.788]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:00.788]                   future::plan(list(function (..., envir = parent.frame()) 
[10:27:00.788]                   {
[10:27:00.788]                     future <- SequentialFuture(..., envir = envir)
[10:27:00.788]                     if (!future$lazy) 
[10:27:00.788]                       future <- run(future)
[10:27:00.788]                     invisible(future)
[10:27:00.788]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:00.788]                 }
[10:27:00.788]             }
[10:27:00.788]         }
[10:27:00.788]     })
[10:27:00.788]     if (TRUE) {
[10:27:00.788]         base::sink(type = "output", split = FALSE)
[10:27:00.788]         if (TRUE) {
[10:27:00.788]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:00.788]         }
[10:27:00.788]         else {
[10:27:00.788]             ...future.result["stdout"] <- base::list(NULL)
[10:27:00.788]         }
[10:27:00.788]         base::close(...future.stdout)
[10:27:00.788]         ...future.stdout <- NULL
[10:27:00.788]     }
[10:27:00.788]     ...future.result$conditions <- ...future.conditions
[10:27:00.788]     ...future.result$finished <- base::Sys.time()
[10:27:00.788]     ...future.result
[10:27:00.788] }
[10:27:00.790] plan(): Setting new future strategy stack:
[10:27:00.790] List of future strategies:
[10:27:00.790] 1. sequential:
[10:27:00.790]    - args: function (..., envir = parent.frame())
[10:27:00.790]    - tweaked: FALSE
[10:27:00.790]    - call: NULL
[10:27:00.790] plan(): nbrOfWorkers() = 1
[10:27:00.791] plan(): Setting new future strategy stack:
[10:27:00.791] List of future strategies:
[10:27:00.791] 1. sequential:
[10:27:00.791]    - args: function (..., envir = parent.frame())
[10:27:00.791]    - tweaked: FALSE
[10:27:00.791]    - call: plan(strategy)
[10:27:00.792] plan(): nbrOfWorkers() = 1
[10:27:00.792] SequentialFuture started (and completed)
[10:27:00.792] - Launch lazy future ... done
[10:27:00.792] run() for ‘SequentialFuture’ ... done
[10:27:00.793] resolve() on list environment ...
[10:27:00.793]  recursive: 0
[10:27:00.794]  length: 3
[10:27:00.794]  elements: ‘a’, ‘b’, ‘c’
[10:27:00.794] resolved() for ‘SequentialFuture’ ...
[10:27:00.794] - state: ‘finished’
[10:27:00.794] - run: TRUE
[10:27:00.794] - result: ‘FutureResult’
[10:27:00.794] resolved() for ‘SequentialFuture’ ... done
[10:27:00.794] Future #1
[10:27:00.794]  length: 2 (resolved future 1)
[10:27:00.795] resolved() for ‘SequentialFuture’ ...
[10:27:00.795] - state: ‘finished’
[10:27:00.795] - run: TRUE
[10:27:00.795] - result: ‘FutureResult’
[10:27:00.795] resolved() for ‘SequentialFuture’ ... done
[10:27:00.795] Future #2
[10:27:00.795]  length: 1 (resolved future 2)
[10:27:00.795]  length: 0 (resolved future 3)
[10:27:00.795] resolve() on list environment ... DONE
[10:27:00.796] getGlobalsAndPackages() ...
[10:27:00.796] Searching for globals...
[10:27:00.797] - globals found: [1] ‘{’
[10:27:00.797] Searching for globals ... DONE
[10:27:00.797] Resolving globals: FALSE
[10:27:00.798] 
[10:27:00.798] 
[10:27:00.798] getGlobalsAndPackages() ... DONE
[10:27:00.798] run() for ‘Future’ ...
[10:27:00.798] - state: ‘created’
[10:27:00.801] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:27:00.801] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:27:00.801] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:27:00.801]   - Field: ‘label’
[10:27:00.801]   - Field: ‘local’
[10:27:00.802]   - Field: ‘owner’
[10:27:00.802]   - Field: ‘envir’
[10:27:00.802]   - Field: ‘packages’
[10:27:00.802]   - Field: ‘gc’
[10:27:00.802]   - Field: ‘conditions’
[10:27:00.802]   - Field: ‘expr’
[10:27:00.802]   - Field: ‘uuid’
[10:27:00.802]   - Field: ‘seed’
[10:27:00.802]   - Field: ‘version’
[10:27:00.802]   - Field: ‘result’
[10:27:00.803]   - Field: ‘asynchronous’
[10:27:00.803]   - Field: ‘calls’
[10:27:00.803]   - Field: ‘globals’
[10:27:00.803]   - Field: ‘stdout’
[10:27:00.803]   - Field: ‘earlySignal’
[10:27:00.803]   - Field: ‘lazy’
[10:27:00.803]   - Field: ‘state’
[10:27:00.803] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:27:00.803] - Launch lazy future ...
[10:27:00.804] Packages needed by the future expression (n = 0): <none>
[10:27:00.804] Packages needed by future strategies (n = 0): <none>
[10:27:00.804] {
[10:27:00.804]     {
[10:27:00.804]         {
[10:27:00.804]             ...future.startTime <- base::Sys.time()
[10:27:00.804]             {
[10:27:00.804]                 {
[10:27:00.804]                   {
[10:27:00.804]                     base::local({
[10:27:00.804]                       has_future <- base::requireNamespace("future", 
[10:27:00.804]                         quietly = TRUE)
[10:27:00.804]                       if (has_future) {
[10:27:00.804]                         ns <- base::getNamespace("future")
[10:27:00.804]                         version <- ns[[".package"]][["version"]]
[10:27:00.804]                         if (is.null(version)) 
[10:27:00.804]                           version <- utils::packageVersion("future")
[10:27:00.804]                       }
[10:27:00.804]                       else {
[10:27:00.804]                         version <- NULL
[10:27:00.804]                       }
[10:27:00.804]                       if (!has_future || version < "1.8.0") {
[10:27:00.804]                         info <- base::c(r_version = base::gsub("R version ", 
[10:27:00.804]                           "", base::R.version$version.string), 
[10:27:00.804]                           platform = base::sprintf("%s (%s-bit)", 
[10:27:00.804]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:00.804]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:00.804]                             "release", "version")], collapse = " "), 
[10:27:00.804]                           hostname = base::Sys.info()[["nodename"]])
[10:27:00.804]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:27:00.804]                           info)
[10:27:00.804]                         info <- base::paste(info, collapse = "; ")
[10:27:00.804]                         if (!has_future) {
[10:27:00.804]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:00.804]                             info)
[10:27:00.804]                         }
[10:27:00.804]                         else {
[10:27:00.804]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:00.804]                             info, version)
[10:27:00.804]                         }
[10:27:00.804]                         base::stop(msg)
[10:27:00.804]                       }
[10:27:00.804]                     })
[10:27:00.804]                   }
[10:27:00.804]                   options(future.plan = NULL)
[10:27:00.804]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:00.804]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:00.804]                 }
[10:27:00.804]                 ...future.workdir <- getwd()
[10:27:00.804]             }
[10:27:00.804]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:00.804]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:00.804]         }
[10:27:00.804]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:00.804]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:00.804]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:00.804]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:00.804]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:00.804]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:00.804]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:00.804]             base::names(...future.oldOptions))
[10:27:00.804]     }
[10:27:00.804]     if (FALSE) {
[10:27:00.804]     }
[10:27:00.804]     else {
[10:27:00.804]         if (TRUE) {
[10:27:00.804]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:00.804]                 open = "w")
[10:27:00.804]         }
[10:27:00.804]         else {
[10:27:00.804]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:00.804]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:00.804]         }
[10:27:00.804]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:00.804]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:00.804]             base::sink(type = "output", split = FALSE)
[10:27:00.804]             base::close(...future.stdout)
[10:27:00.804]         }, add = TRUE)
[10:27:00.804]     }
[10:27:00.804]     ...future.frame <- base::sys.nframe()
[10:27:00.804]     ...future.conditions <- base::list()
[10:27:00.804]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:00.804]     if (FALSE) {
[10:27:00.804]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:00.804]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:00.804]     }
[10:27:00.804]     ...future.result <- base::tryCatch({
[10:27:00.804]         base::withCallingHandlers({
[10:27:00.804]             ...future.value <- base::withVisible(base::local({
[10:27:00.804]                 1
[10:27:00.804]             }))
[10:27:00.804]             future::FutureResult(value = ...future.value$value, 
[10:27:00.804]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:00.804]                   ...future.rng), globalenv = if (FALSE) 
[10:27:00.804]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:00.804]                     ...future.globalenv.names))
[10:27:00.804]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:00.804]         }, condition = base::local({
[10:27:00.804]             c <- base::c
[10:27:00.804]             inherits <- base::inherits
[10:27:00.804]             invokeRestart <- base::invokeRestart
[10:27:00.804]             length <- base::length
[10:27:00.804]             list <- base::list
[10:27:00.804]             seq.int <- base::seq.int
[10:27:00.804]             signalCondition <- base::signalCondition
[10:27:00.804]             sys.calls <- base::sys.calls
[10:27:00.804]             `[[` <- base::`[[`
[10:27:00.804]             `+` <- base::`+`
[10:27:00.804]             `<<-` <- base::`<<-`
[10:27:00.804]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:00.804]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:00.804]                   3L)]
[10:27:00.804]             }
[10:27:00.804]             function(cond) {
[10:27:00.804]                 is_error <- inherits(cond, "error")
[10:27:00.804]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:00.804]                   NULL)
[10:27:00.804]                 if (is_error) {
[10:27:00.804]                   sessionInformation <- function() {
[10:27:00.804]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:00.804]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:00.804]                       search = base::search(), system = base::Sys.info())
[10:27:00.804]                   }
[10:27:00.804]                   ...future.conditions[[length(...future.conditions) + 
[10:27:00.804]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:00.804]                     cond$call), session = sessionInformation(), 
[10:27:00.804]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:00.804]                   signalCondition(cond)
[10:27:00.804]                 }
[10:27:00.804]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:00.804]                 "immediateCondition"))) {
[10:27:00.804]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:00.804]                   ...future.conditions[[length(...future.conditions) + 
[10:27:00.804]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:00.804]                   if (TRUE && !signal) {
[10:27:00.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:00.804]                     {
[10:27:00.804]                       inherits <- base::inherits
[10:27:00.804]                       invokeRestart <- base::invokeRestart
[10:27:00.804]                       is.null <- base::is.null
[10:27:00.804]                       muffled <- FALSE
[10:27:00.804]                       if (inherits(cond, "message")) {
[10:27:00.804]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:00.804]                         if (muffled) 
[10:27:00.804]                           invokeRestart("muffleMessage")
[10:27:00.804]                       }
[10:27:00.804]                       else if (inherits(cond, "warning")) {
[10:27:00.804]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:00.804]                         if (muffled) 
[10:27:00.804]                           invokeRestart("muffleWarning")
[10:27:00.804]                       }
[10:27:00.804]                       else if (inherits(cond, "condition")) {
[10:27:00.804]                         if (!is.null(pattern)) {
[10:27:00.804]                           computeRestarts <- base::computeRestarts
[10:27:00.804]                           grepl <- base::grepl
[10:27:00.804]                           restarts <- computeRestarts(cond)
[10:27:00.804]                           for (restart in restarts) {
[10:27:00.804]                             name <- restart$name
[10:27:00.804]                             if (is.null(name)) 
[10:27:00.804]                               next
[10:27:00.804]                             if (!grepl(pattern, name)) 
[10:27:00.804]                               next
[10:27:00.804]                             invokeRestart(restart)
[10:27:00.804]                             muffled <- TRUE
[10:27:00.804]                             break
[10:27:00.804]                           }
[10:27:00.804]                         }
[10:27:00.804]                       }
[10:27:00.804]                       invisible(muffled)
[10:27:00.804]                     }
[10:27:00.804]                     muffleCondition(cond, pattern = "^muffle")
[10:27:00.804]                   }
[10:27:00.804]                 }
[10:27:00.804]                 else {
[10:27:00.804]                   if (TRUE) {
[10:27:00.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:00.804]                     {
[10:27:00.804]                       inherits <- base::inherits
[10:27:00.804]                       invokeRestart <- base::invokeRestart
[10:27:00.804]                       is.null <- base::is.null
[10:27:00.804]                       muffled <- FALSE
[10:27:00.804]                       if (inherits(cond, "message")) {
[10:27:00.804]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:00.804]                         if (muffled) 
[10:27:00.804]                           invokeRestart("muffleMessage")
[10:27:00.804]                       }
[10:27:00.804]                       else if (inherits(cond, "warning")) {
[10:27:00.804]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:00.804]                         if (muffled) 
[10:27:00.804]                           invokeRestart("muffleWarning")
[10:27:00.804]                       }
[10:27:00.804]                       else if (inherits(cond, "condition")) {
[10:27:00.804]                         if (!is.null(pattern)) {
[10:27:00.804]                           computeRestarts <- base::computeRestarts
[10:27:00.804]                           grepl <- base::grepl
[10:27:00.804]                           restarts <- computeRestarts(cond)
[10:27:00.804]                           for (restart in restarts) {
[10:27:00.804]                             name <- restart$name
[10:27:00.804]                             if (is.null(name)) 
[10:27:00.804]                               next
[10:27:00.804]                             if (!grepl(pattern, name)) 
[10:27:00.804]                               next
[10:27:00.804]                             invokeRestart(restart)
[10:27:00.804]                             muffled <- TRUE
[10:27:00.804]                             break
[10:27:00.804]                           }
[10:27:00.804]                         }
[10:27:00.804]                       }
[10:27:00.804]                       invisible(muffled)
[10:27:00.804]                     }
[10:27:00.804]                     muffleCondition(cond, pattern = "^muffle")
[10:27:00.804]                   }
[10:27:00.804]                 }
[10:27:00.804]             }
[10:27:00.804]         }))
[10:27:00.804]     }, error = function(ex) {
[10:27:00.804]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:00.804]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:00.804]                 ...future.rng), started = ...future.startTime, 
[10:27:00.804]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:00.804]             version = "1.8"), class = "FutureResult")
[10:27:00.804]     }, finally = {
[10:27:00.804]         if (!identical(...future.workdir, getwd())) 
[10:27:00.804]             setwd(...future.workdir)
[10:27:00.804]         {
[10:27:00.804]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:00.804]                 ...future.oldOptions$nwarnings <- NULL
[10:27:00.804]             }
[10:27:00.804]             base::options(...future.oldOptions)
[10:27:00.804]             if (.Platform$OS.type == "windows") {
[10:27:00.804]                 old_names <- names(...future.oldEnvVars)
[10:27:00.804]                 envs <- base::Sys.getenv()
[10:27:00.804]                 names <- names(envs)
[10:27:00.804]                 common <- intersect(names, old_names)
[10:27:00.804]                 added <- setdiff(names, old_names)
[10:27:00.804]                 removed <- setdiff(old_names, names)
[10:27:00.804]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:00.804]                   envs[common]]
[10:27:00.804]                 NAMES <- toupper(changed)
[10:27:00.804]                 args <- list()
[10:27:00.804]                 for (kk in seq_along(NAMES)) {
[10:27:00.804]                   name <- changed[[kk]]
[10:27:00.804]                   NAME <- NAMES[[kk]]
[10:27:00.804]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.804]                     next
[10:27:00.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:00.804]                 }
[10:27:00.804]                 NAMES <- toupper(added)
[10:27:00.804]                 for (kk in seq_along(NAMES)) {
[10:27:00.804]                   name <- added[[kk]]
[10:27:00.804]                   NAME <- NAMES[[kk]]
[10:27:00.804]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.804]                     next
[10:27:00.804]                   args[[name]] <- ""
[10:27:00.804]                 }
[10:27:00.804]                 NAMES <- toupper(removed)
[10:27:00.804]                 for (kk in seq_along(NAMES)) {
[10:27:00.804]                   name <- removed[[kk]]
[10:27:00.804]                   NAME <- NAMES[[kk]]
[10:27:00.804]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.804]                     next
[10:27:00.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:00.804]                 }
[10:27:00.804]                 if (length(args) > 0) 
[10:27:00.804]                   base::do.call(base::Sys.setenv, args = args)
[10:27:00.804]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:00.804]             }
[10:27:00.804]             else {
[10:27:00.804]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:00.804]             }
[10:27:00.804]             {
[10:27:00.804]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:00.804]                   0L) {
[10:27:00.804]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:00.804]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:00.804]                   base::options(opts)
[10:27:00.804]                 }
[10:27:00.804]                 {
[10:27:00.804]                   {
[10:27:00.804]                     NULL
[10:27:00.804]                     RNGkind("Mersenne-Twister")
[10:27:00.804]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:27:00.804]                       inherits = FALSE)
[10:27:00.804]                   }
[10:27:00.804]                   options(future.plan = NULL)
[10:27:00.804]                   if (is.na(NA_character_)) 
[10:27:00.804]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:00.804]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:00.804]                   future::plan(list(function (..., envir = parent.frame()) 
[10:27:00.804]                   {
[10:27:00.804]                     future <- SequentialFuture(..., envir = envir)
[10:27:00.804]                     if (!future$lazy) 
[10:27:00.804]                       future <- run(future)
[10:27:00.804]                     invisible(future)
[10:27:00.804]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:00.804]                 }
[10:27:00.804]             }
[10:27:00.804]         }
[10:27:00.804]     })
[10:27:00.804]     if (TRUE) {
[10:27:00.804]         base::sink(type = "output", split = FALSE)
[10:27:00.804]         if (TRUE) {
[10:27:00.804]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:00.804]         }
[10:27:00.804]         else {
[10:27:00.804]             ...future.result["stdout"] <- base::list(NULL)
[10:27:00.804]         }
[10:27:00.804]         base::close(...future.stdout)
[10:27:00.804]         ...future.stdout <- NULL
[10:27:00.804]     }
[10:27:00.804]     ...future.result$conditions <- ...future.conditions
[10:27:00.804]     ...future.result$finished <- base::Sys.time()
[10:27:00.804]     ...future.result
[10:27:00.804] }
[10:27:00.806] plan(): Setting new future strategy stack:
[10:27:00.806] List of future strategies:
[10:27:00.806] 1. sequential:
[10:27:00.806]    - args: function (..., envir = parent.frame())
[10:27:00.806]    - tweaked: FALSE
[10:27:00.806]    - call: NULL
[10:27:00.807] plan(): nbrOfWorkers() = 1
[10:27:00.807] plan(): Setting new future strategy stack:
[10:27:00.808] List of future strategies:
[10:27:00.808] 1. sequential:
[10:27:00.808]    - args: function (..., envir = parent.frame())
[10:27:00.808]    - tweaked: FALSE
[10:27:00.808]    - call: plan(strategy)
[10:27:00.808] plan(): nbrOfWorkers() = 1
[10:27:00.808] SequentialFuture started (and completed)
[10:27:00.808] - Launch lazy future ... done
[10:27:00.808] run() for ‘SequentialFuture’ ... done
[10:27:00.809] getGlobalsAndPackages() ...
[10:27:00.809] Searching for globals...
[10:27:00.810] - globals found: [1] ‘{’
[10:27:00.810] Searching for globals ... DONE
[10:27:00.810] Resolving globals: FALSE
[10:27:00.810] 
[10:27:00.810] 
[10:27:00.810] getGlobalsAndPackages() ... DONE
[10:27:00.811] run() for ‘Future’ ...
[10:27:00.811] - state: ‘created’
[10:27:00.811] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:27:00.811] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:27:00.811] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:27:00.811]   - Field: ‘label’
[10:27:00.811]   - Field: ‘local’
[10:27:00.812]   - Field: ‘owner’
[10:27:00.812]   - Field: ‘envir’
[10:27:00.812]   - Field: ‘packages’
[10:27:00.812]   - Field: ‘gc’
[10:27:00.812]   - Field: ‘conditions’
[10:27:00.812]   - Field: ‘expr’
[10:27:00.812]   - Field: ‘uuid’
[10:27:00.812]   - Field: ‘seed’
[10:27:00.812]   - Field: ‘version’
[10:27:00.812]   - Field: ‘result’
[10:27:00.813]   - Field: ‘asynchronous’
[10:27:00.813]   - Field: ‘calls’
[10:27:00.813]   - Field: ‘globals’
[10:27:00.813]   - Field: ‘stdout’
[10:27:00.813]   - Field: ‘earlySignal’
[10:27:00.813]   - Field: ‘lazy’
[10:27:00.813]   - Field: ‘state’
[10:27:00.813] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:27:00.813] - Launch lazy future ...
[10:27:00.814] Packages needed by the future expression (n = 0): <none>
[10:27:00.814] Packages needed by future strategies (n = 0): <none>
[10:27:00.814] {
[10:27:00.814]     {
[10:27:00.814]         {
[10:27:00.814]             ...future.startTime <- base::Sys.time()
[10:27:00.814]             {
[10:27:00.814]                 {
[10:27:00.814]                   {
[10:27:00.814]                     base::local({
[10:27:00.814]                       has_future <- base::requireNamespace("future", 
[10:27:00.814]                         quietly = TRUE)
[10:27:00.814]                       if (has_future) {
[10:27:00.814]                         ns <- base::getNamespace("future")
[10:27:00.814]                         version <- ns[[".package"]][["version"]]
[10:27:00.814]                         if (is.null(version)) 
[10:27:00.814]                           version <- utils::packageVersion("future")
[10:27:00.814]                       }
[10:27:00.814]                       else {
[10:27:00.814]                         version <- NULL
[10:27:00.814]                       }
[10:27:00.814]                       if (!has_future || version < "1.8.0") {
[10:27:00.814]                         info <- base::c(r_version = base::gsub("R version ", 
[10:27:00.814]                           "", base::R.version$version.string), 
[10:27:00.814]                           platform = base::sprintf("%s (%s-bit)", 
[10:27:00.814]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:00.814]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:00.814]                             "release", "version")], collapse = " "), 
[10:27:00.814]                           hostname = base::Sys.info()[["nodename"]])
[10:27:00.814]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:27:00.814]                           info)
[10:27:00.814]                         info <- base::paste(info, collapse = "; ")
[10:27:00.814]                         if (!has_future) {
[10:27:00.814]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:00.814]                             info)
[10:27:00.814]                         }
[10:27:00.814]                         else {
[10:27:00.814]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:00.814]                             info, version)
[10:27:00.814]                         }
[10:27:00.814]                         base::stop(msg)
[10:27:00.814]                       }
[10:27:00.814]                     })
[10:27:00.814]                   }
[10:27:00.814]                   options(future.plan = NULL)
[10:27:00.814]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:00.814]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:00.814]                 }
[10:27:00.814]                 ...future.workdir <- getwd()
[10:27:00.814]             }
[10:27:00.814]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:00.814]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:00.814]         }
[10:27:00.814]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:00.814]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:00.814]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:00.814]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:00.814]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:00.814]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:00.814]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:00.814]             base::names(...future.oldOptions))
[10:27:00.814]     }
[10:27:00.814]     if (FALSE) {
[10:27:00.814]     }
[10:27:00.814]     else {
[10:27:00.814]         if (TRUE) {
[10:27:00.814]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:00.814]                 open = "w")
[10:27:00.814]         }
[10:27:00.814]         else {
[10:27:00.814]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:00.814]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:00.814]         }
[10:27:00.814]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:00.814]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:00.814]             base::sink(type = "output", split = FALSE)
[10:27:00.814]             base::close(...future.stdout)
[10:27:00.814]         }, add = TRUE)
[10:27:00.814]     }
[10:27:00.814]     ...future.frame <- base::sys.nframe()
[10:27:00.814]     ...future.conditions <- base::list()
[10:27:00.814]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:00.814]     if (FALSE) {
[10:27:00.814]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:00.814]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:00.814]     }
[10:27:00.814]     ...future.result <- base::tryCatch({
[10:27:00.814]         base::withCallingHandlers({
[10:27:00.814]             ...future.value <- base::withVisible(base::local({
[10:27:00.814]                 2
[10:27:00.814]             }))
[10:27:00.814]             future::FutureResult(value = ...future.value$value, 
[10:27:00.814]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:00.814]                   ...future.rng), globalenv = if (FALSE) 
[10:27:00.814]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:00.814]                     ...future.globalenv.names))
[10:27:00.814]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:00.814]         }, condition = base::local({
[10:27:00.814]             c <- base::c
[10:27:00.814]             inherits <- base::inherits
[10:27:00.814]             invokeRestart <- base::invokeRestart
[10:27:00.814]             length <- base::length
[10:27:00.814]             list <- base::list
[10:27:00.814]             seq.int <- base::seq.int
[10:27:00.814]             signalCondition <- base::signalCondition
[10:27:00.814]             sys.calls <- base::sys.calls
[10:27:00.814]             `[[` <- base::`[[`
[10:27:00.814]             `+` <- base::`+`
[10:27:00.814]             `<<-` <- base::`<<-`
[10:27:00.814]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:00.814]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:00.814]                   3L)]
[10:27:00.814]             }
[10:27:00.814]             function(cond) {
[10:27:00.814]                 is_error <- inherits(cond, "error")
[10:27:00.814]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:00.814]                   NULL)
[10:27:00.814]                 if (is_error) {
[10:27:00.814]                   sessionInformation <- function() {
[10:27:00.814]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:00.814]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:00.814]                       search = base::search(), system = base::Sys.info())
[10:27:00.814]                   }
[10:27:00.814]                   ...future.conditions[[length(...future.conditions) + 
[10:27:00.814]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:00.814]                     cond$call), session = sessionInformation(), 
[10:27:00.814]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:00.814]                   signalCondition(cond)
[10:27:00.814]                 }
[10:27:00.814]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:00.814]                 "immediateCondition"))) {
[10:27:00.814]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:00.814]                   ...future.conditions[[length(...future.conditions) + 
[10:27:00.814]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:00.814]                   if (TRUE && !signal) {
[10:27:00.814]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:00.814]                     {
[10:27:00.814]                       inherits <- base::inherits
[10:27:00.814]                       invokeRestart <- base::invokeRestart
[10:27:00.814]                       is.null <- base::is.null
[10:27:00.814]                       muffled <- FALSE
[10:27:00.814]                       if (inherits(cond, "message")) {
[10:27:00.814]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:00.814]                         if (muffled) 
[10:27:00.814]                           invokeRestart("muffleMessage")
[10:27:00.814]                       }
[10:27:00.814]                       else if (inherits(cond, "warning")) {
[10:27:00.814]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:00.814]                         if (muffled) 
[10:27:00.814]                           invokeRestart("muffleWarning")
[10:27:00.814]                       }
[10:27:00.814]                       else if (inherits(cond, "condition")) {
[10:27:00.814]                         if (!is.null(pattern)) {
[10:27:00.814]                           computeRestarts <- base::computeRestarts
[10:27:00.814]                           grepl <- base::grepl
[10:27:00.814]                           restarts <- computeRestarts(cond)
[10:27:00.814]                           for (restart in restarts) {
[10:27:00.814]                             name <- restart$name
[10:27:00.814]                             if (is.null(name)) 
[10:27:00.814]                               next
[10:27:00.814]                             if (!grepl(pattern, name)) 
[10:27:00.814]                               next
[10:27:00.814]                             invokeRestart(restart)
[10:27:00.814]                             muffled <- TRUE
[10:27:00.814]                             break
[10:27:00.814]                           }
[10:27:00.814]                         }
[10:27:00.814]                       }
[10:27:00.814]                       invisible(muffled)
[10:27:00.814]                     }
[10:27:00.814]                     muffleCondition(cond, pattern = "^muffle")
[10:27:00.814]                   }
[10:27:00.814]                 }
[10:27:00.814]                 else {
[10:27:00.814]                   if (TRUE) {
[10:27:00.814]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:00.814]                     {
[10:27:00.814]                       inherits <- base::inherits
[10:27:00.814]                       invokeRestart <- base::invokeRestart
[10:27:00.814]                       is.null <- base::is.null
[10:27:00.814]                       muffled <- FALSE
[10:27:00.814]                       if (inherits(cond, "message")) {
[10:27:00.814]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:00.814]                         if (muffled) 
[10:27:00.814]                           invokeRestart("muffleMessage")
[10:27:00.814]                       }
[10:27:00.814]                       else if (inherits(cond, "warning")) {
[10:27:00.814]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:00.814]                         if (muffled) 
[10:27:00.814]                           invokeRestart("muffleWarning")
[10:27:00.814]                       }
[10:27:00.814]                       else if (inherits(cond, "condition")) {
[10:27:00.814]                         if (!is.null(pattern)) {
[10:27:00.814]                           computeRestarts <- base::computeRestarts
[10:27:00.814]                           grepl <- base::grepl
[10:27:00.814]                           restarts <- computeRestarts(cond)
[10:27:00.814]                           for (restart in restarts) {
[10:27:00.814]                             name <- restart$name
[10:27:00.814]                             if (is.null(name)) 
[10:27:00.814]                               next
[10:27:00.814]                             if (!grepl(pattern, name)) 
[10:27:00.814]                               next
[10:27:00.814]                             invokeRestart(restart)
[10:27:00.814]                             muffled <- TRUE
[10:27:00.814]                             break
[10:27:00.814]                           }
[10:27:00.814]                         }
[10:27:00.814]                       }
[10:27:00.814]                       invisible(muffled)
[10:27:00.814]                     }
[10:27:00.814]                     muffleCondition(cond, pattern = "^muffle")
[10:27:00.814]                   }
[10:27:00.814]                 }
[10:27:00.814]             }
[10:27:00.814]         }))
[10:27:00.814]     }, error = function(ex) {
[10:27:00.814]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:00.814]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:00.814]                 ...future.rng), started = ...future.startTime, 
[10:27:00.814]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:00.814]             version = "1.8"), class = "FutureResult")
[10:27:00.814]     }, finally = {
[10:27:00.814]         if (!identical(...future.workdir, getwd())) 
[10:27:00.814]             setwd(...future.workdir)
[10:27:00.814]         {
[10:27:00.814]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:00.814]                 ...future.oldOptions$nwarnings <- NULL
[10:27:00.814]             }
[10:27:00.814]             base::options(...future.oldOptions)
[10:27:00.814]             if (.Platform$OS.type == "windows") {
[10:27:00.814]                 old_names <- names(...future.oldEnvVars)
[10:27:00.814]                 envs <- base::Sys.getenv()
[10:27:00.814]                 names <- names(envs)
[10:27:00.814]                 common <- intersect(names, old_names)
[10:27:00.814]                 added <- setdiff(names, old_names)
[10:27:00.814]                 removed <- setdiff(old_names, names)
[10:27:00.814]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:00.814]                   envs[common]]
[10:27:00.814]                 NAMES <- toupper(changed)
[10:27:00.814]                 args <- list()
[10:27:00.814]                 for (kk in seq_along(NAMES)) {
[10:27:00.814]                   name <- changed[[kk]]
[10:27:00.814]                   NAME <- NAMES[[kk]]
[10:27:00.814]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.814]                     next
[10:27:00.814]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:00.814]                 }
[10:27:00.814]                 NAMES <- toupper(added)
[10:27:00.814]                 for (kk in seq_along(NAMES)) {
[10:27:00.814]                   name <- added[[kk]]
[10:27:00.814]                   NAME <- NAMES[[kk]]
[10:27:00.814]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.814]                     next
[10:27:00.814]                   args[[name]] <- ""
[10:27:00.814]                 }
[10:27:00.814]                 NAMES <- toupper(removed)
[10:27:00.814]                 for (kk in seq_along(NAMES)) {
[10:27:00.814]                   name <- removed[[kk]]
[10:27:00.814]                   NAME <- NAMES[[kk]]
[10:27:00.814]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.814]                     next
[10:27:00.814]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:00.814]                 }
[10:27:00.814]                 if (length(args) > 0) 
[10:27:00.814]                   base::do.call(base::Sys.setenv, args = args)
[10:27:00.814]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:00.814]             }
[10:27:00.814]             else {
[10:27:00.814]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:00.814]             }
[10:27:00.814]             {
[10:27:00.814]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:00.814]                   0L) {
[10:27:00.814]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:00.814]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:00.814]                   base::options(opts)
[10:27:00.814]                 }
[10:27:00.814]                 {
[10:27:00.814]                   {
[10:27:00.814]                     NULL
[10:27:00.814]                     RNGkind("Mersenne-Twister")
[10:27:00.814]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:27:00.814]                       inherits = FALSE)
[10:27:00.814]                   }
[10:27:00.814]                   options(future.plan = NULL)
[10:27:00.814]                   if (is.na(NA_character_)) 
[10:27:00.814]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:00.814]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:00.814]                   future::plan(list(function (..., envir = parent.frame()) 
[10:27:00.814]                   {
[10:27:00.814]                     future <- SequentialFuture(..., envir = envir)
[10:27:00.814]                     if (!future$lazy) 
[10:27:00.814]                       future <- run(future)
[10:27:00.814]                     invisible(future)
[10:27:00.814]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:00.814]                 }
[10:27:00.814]             }
[10:27:00.814]         }
[10:27:00.814]     })
[10:27:00.814]     if (TRUE) {
[10:27:00.814]         base::sink(type = "output", split = FALSE)
[10:27:00.814]         if (TRUE) {
[10:27:00.814]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:00.814]         }
[10:27:00.814]         else {
[10:27:00.814]             ...future.result["stdout"] <- base::list(NULL)
[10:27:00.814]         }
[10:27:00.814]         base::close(...future.stdout)
[10:27:00.814]         ...future.stdout <- NULL
[10:27:00.814]     }
[10:27:00.814]     ...future.result$conditions <- ...future.conditions
[10:27:00.814]     ...future.result$finished <- base::Sys.time()
[10:27:00.814]     ...future.result
[10:27:00.814] }
[10:27:00.816] plan(): Setting new future strategy stack:
[10:27:00.816] List of future strategies:
[10:27:00.816] 1. sequential:
[10:27:00.816]    - args: function (..., envir = parent.frame())
[10:27:00.816]    - tweaked: FALSE
[10:27:00.816]    - call: NULL
[10:27:00.816] plan(): nbrOfWorkers() = 1
[10:27:00.817] plan(): Setting new future strategy stack:
[10:27:00.817] List of future strategies:
[10:27:00.817] 1. sequential:
[10:27:00.817]    - args: function (..., envir = parent.frame())
[10:27:00.817]    - tweaked: FALSE
[10:27:00.817]    - call: plan(strategy)
[10:27:00.818] plan(): nbrOfWorkers() = 1
[10:27:00.818] SequentialFuture started (and completed)
[10:27:00.818] - Launch lazy future ... done
[10:27:00.818] run() for ‘SequentialFuture’ ... done
[10:27:00.819] resolve() on list environment ...
[10:27:00.819]  recursive: 0
[10:27:00.819]  length: 3
[10:27:00.819]  elements: ‘a’, ‘b’, ‘c’
[10:27:00.819] resolved() for ‘SequentialFuture’ ...
[10:27:00.820] - state: ‘finished’
[10:27:00.820] - run: TRUE
[10:27:00.820] - result: ‘FutureResult’
[10:27:00.820] resolved() for ‘SequentialFuture’ ... done
[10:27:00.820] Future #1
[10:27:00.820]  length: 2 (resolved future 1)
[10:27:00.820] resolved() for ‘SequentialFuture’ ...
[10:27:00.820] - state: ‘finished’
[10:27:00.820] - run: TRUE
[10:27:00.820] - result: ‘FutureResult’
[10:27:00.820] resolved() for ‘SequentialFuture’ ... done
[10:27:00.821] Future #2
[10:27:00.821]  length: 1 (resolved future 2)
[10:27:00.821]  length: 0 (resolved future 3)
[10:27:00.821] resolve() on list environment ... DONE
[10:27:00.821] getGlobalsAndPackages() ...
[10:27:00.821] Searching for globals...
[10:27:00.822] - globals found: [1] ‘{’
[10:27:00.822] Searching for globals ... DONE
[10:27:00.822] Resolving globals: FALSE
[10:27:00.823] 
[10:27:00.823] 
[10:27:00.823] getGlobalsAndPackages() ... DONE
[10:27:00.823] run() for ‘Future’ ...
[10:27:00.823] - state: ‘created’
[10:27:00.823] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:27:00.823] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:27:00.824] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:27:00.824]   - Field: ‘label’
[10:27:00.824]   - Field: ‘local’
[10:27:00.824]   - Field: ‘owner’
[10:27:00.824]   - Field: ‘envir’
[10:27:00.824]   - Field: ‘packages’
[10:27:00.824]   - Field: ‘gc’
[10:27:00.824]   - Field: ‘conditions’
[10:27:00.824]   - Field: ‘expr’
[10:27:00.824]   - Field: ‘uuid’
[10:27:00.825]   - Field: ‘seed’
[10:27:00.825]   - Field: ‘version’
[10:27:00.825]   - Field: ‘result’
[10:27:00.825]   - Field: ‘asynchronous’
[10:27:00.825]   - Field: ‘calls’
[10:27:00.825]   - Field: ‘globals’
[10:27:00.825]   - Field: ‘stdout’
[10:27:00.825]   - Field: ‘earlySignal’
[10:27:00.825]   - Field: ‘lazy’
[10:27:00.826]   - Field: ‘state’
[10:27:00.826] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:27:00.826] - Launch lazy future ...
[10:27:00.826] Packages needed by the future expression (n = 0): <none>
[10:27:00.826] Packages needed by future strategies (n = 0): <none>
[10:27:00.826] {
[10:27:00.826]     {
[10:27:00.826]         {
[10:27:00.826]             ...future.startTime <- base::Sys.time()
[10:27:00.826]             {
[10:27:00.826]                 {
[10:27:00.826]                   {
[10:27:00.826]                     base::local({
[10:27:00.826]                       has_future <- base::requireNamespace("future", 
[10:27:00.826]                         quietly = TRUE)
[10:27:00.826]                       if (has_future) {
[10:27:00.826]                         ns <- base::getNamespace("future")
[10:27:00.826]                         version <- ns[[".package"]][["version"]]
[10:27:00.826]                         if (is.null(version)) 
[10:27:00.826]                           version <- utils::packageVersion("future")
[10:27:00.826]                       }
[10:27:00.826]                       else {
[10:27:00.826]                         version <- NULL
[10:27:00.826]                       }
[10:27:00.826]                       if (!has_future || version < "1.8.0") {
[10:27:00.826]                         info <- base::c(r_version = base::gsub("R version ", 
[10:27:00.826]                           "", base::R.version$version.string), 
[10:27:00.826]                           platform = base::sprintf("%s (%s-bit)", 
[10:27:00.826]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:00.826]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:00.826]                             "release", "version")], collapse = " "), 
[10:27:00.826]                           hostname = base::Sys.info()[["nodename"]])
[10:27:00.826]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:27:00.826]                           info)
[10:27:00.826]                         info <- base::paste(info, collapse = "; ")
[10:27:00.826]                         if (!has_future) {
[10:27:00.826]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:00.826]                             info)
[10:27:00.826]                         }
[10:27:00.826]                         else {
[10:27:00.826]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:00.826]                             info, version)
[10:27:00.826]                         }
[10:27:00.826]                         base::stop(msg)
[10:27:00.826]                       }
[10:27:00.826]                     })
[10:27:00.826]                   }
[10:27:00.826]                   options(future.plan = NULL)
[10:27:00.826]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:00.826]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:00.826]                 }
[10:27:00.826]                 ...future.workdir <- getwd()
[10:27:00.826]             }
[10:27:00.826]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:00.826]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:00.826]         }
[10:27:00.826]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:00.826]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:00.826]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:00.826]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:00.826]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:00.826]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:00.826]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:00.826]             base::names(...future.oldOptions))
[10:27:00.826]     }
[10:27:00.826]     if (FALSE) {
[10:27:00.826]     }
[10:27:00.826]     else {
[10:27:00.826]         if (TRUE) {
[10:27:00.826]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:00.826]                 open = "w")
[10:27:00.826]         }
[10:27:00.826]         else {
[10:27:00.826]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:00.826]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:00.826]         }
[10:27:00.826]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:00.826]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:00.826]             base::sink(type = "output", split = FALSE)
[10:27:00.826]             base::close(...future.stdout)
[10:27:00.826]         }, add = TRUE)
[10:27:00.826]     }
[10:27:00.826]     ...future.frame <- base::sys.nframe()
[10:27:00.826]     ...future.conditions <- base::list()
[10:27:00.826]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:00.826]     if (FALSE) {
[10:27:00.826]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:00.826]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:00.826]     }
[10:27:00.826]     ...future.result <- base::tryCatch({
[10:27:00.826]         base::withCallingHandlers({
[10:27:00.826]             ...future.value <- base::withVisible(base::local({
[10:27:00.826]                 1
[10:27:00.826]             }))
[10:27:00.826]             future::FutureResult(value = ...future.value$value, 
[10:27:00.826]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:00.826]                   ...future.rng), globalenv = if (FALSE) 
[10:27:00.826]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:00.826]                     ...future.globalenv.names))
[10:27:00.826]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:00.826]         }, condition = base::local({
[10:27:00.826]             c <- base::c
[10:27:00.826]             inherits <- base::inherits
[10:27:00.826]             invokeRestart <- base::invokeRestart
[10:27:00.826]             length <- base::length
[10:27:00.826]             list <- base::list
[10:27:00.826]             seq.int <- base::seq.int
[10:27:00.826]             signalCondition <- base::signalCondition
[10:27:00.826]             sys.calls <- base::sys.calls
[10:27:00.826]             `[[` <- base::`[[`
[10:27:00.826]             `+` <- base::`+`
[10:27:00.826]             `<<-` <- base::`<<-`
[10:27:00.826]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:00.826]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:00.826]                   3L)]
[10:27:00.826]             }
[10:27:00.826]             function(cond) {
[10:27:00.826]                 is_error <- inherits(cond, "error")
[10:27:00.826]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:00.826]                   NULL)
[10:27:00.826]                 if (is_error) {
[10:27:00.826]                   sessionInformation <- function() {
[10:27:00.826]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:00.826]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:00.826]                       search = base::search(), system = base::Sys.info())
[10:27:00.826]                   }
[10:27:00.826]                   ...future.conditions[[length(...future.conditions) + 
[10:27:00.826]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:00.826]                     cond$call), session = sessionInformation(), 
[10:27:00.826]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:00.826]                   signalCondition(cond)
[10:27:00.826]                 }
[10:27:00.826]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:00.826]                 "immediateCondition"))) {
[10:27:00.826]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:00.826]                   ...future.conditions[[length(...future.conditions) + 
[10:27:00.826]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:00.826]                   if (TRUE && !signal) {
[10:27:00.826]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:00.826]                     {
[10:27:00.826]                       inherits <- base::inherits
[10:27:00.826]                       invokeRestart <- base::invokeRestart
[10:27:00.826]                       is.null <- base::is.null
[10:27:00.826]                       muffled <- FALSE
[10:27:00.826]                       if (inherits(cond, "message")) {
[10:27:00.826]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:00.826]                         if (muffled) 
[10:27:00.826]                           invokeRestart("muffleMessage")
[10:27:00.826]                       }
[10:27:00.826]                       else if (inherits(cond, "warning")) {
[10:27:00.826]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:00.826]                         if (muffled) 
[10:27:00.826]                           invokeRestart("muffleWarning")
[10:27:00.826]                       }
[10:27:00.826]                       else if (inherits(cond, "condition")) {
[10:27:00.826]                         if (!is.null(pattern)) {
[10:27:00.826]                           computeRestarts <- base::computeRestarts
[10:27:00.826]                           grepl <- base::grepl
[10:27:00.826]                           restarts <- computeRestarts(cond)
[10:27:00.826]                           for (restart in restarts) {
[10:27:00.826]                             name <- restart$name
[10:27:00.826]                             if (is.null(name)) 
[10:27:00.826]                               next
[10:27:00.826]                             if (!grepl(pattern, name)) 
[10:27:00.826]                               next
[10:27:00.826]                             invokeRestart(restart)
[10:27:00.826]                             muffled <- TRUE
[10:27:00.826]                             break
[10:27:00.826]                           }
[10:27:00.826]                         }
[10:27:00.826]                       }
[10:27:00.826]                       invisible(muffled)
[10:27:00.826]                     }
[10:27:00.826]                     muffleCondition(cond, pattern = "^muffle")
[10:27:00.826]                   }
[10:27:00.826]                 }
[10:27:00.826]                 else {
[10:27:00.826]                   if (TRUE) {
[10:27:00.826]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:00.826]                     {
[10:27:00.826]                       inherits <- base::inherits
[10:27:00.826]                       invokeRestart <- base::invokeRestart
[10:27:00.826]                       is.null <- base::is.null
[10:27:00.826]                       muffled <- FALSE
[10:27:00.826]                       if (inherits(cond, "message")) {
[10:27:00.826]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:00.826]                         if (muffled) 
[10:27:00.826]                           invokeRestart("muffleMessage")
[10:27:00.826]                       }
[10:27:00.826]                       else if (inherits(cond, "warning")) {
[10:27:00.826]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:00.826]                         if (muffled) 
[10:27:00.826]                           invokeRestart("muffleWarning")
[10:27:00.826]                       }
[10:27:00.826]                       else if (inherits(cond, "condition")) {
[10:27:00.826]                         if (!is.null(pattern)) {
[10:27:00.826]                           computeRestarts <- base::computeRestarts
[10:27:00.826]                           grepl <- base::grepl
[10:27:00.826]                           restarts <- computeRestarts(cond)
[10:27:00.826]                           for (restart in restarts) {
[10:27:00.826]                             name <- restart$name
[10:27:00.826]                             if (is.null(name)) 
[10:27:00.826]                               next
[10:27:00.826]                             if (!grepl(pattern, name)) 
[10:27:00.826]                               next
[10:27:00.826]                             invokeRestart(restart)
[10:27:00.826]                             muffled <- TRUE
[10:27:00.826]                             break
[10:27:00.826]                           }
[10:27:00.826]                         }
[10:27:00.826]                       }
[10:27:00.826]                       invisible(muffled)
[10:27:00.826]                     }
[10:27:00.826]                     muffleCondition(cond, pattern = "^muffle")
[10:27:00.826]                   }
[10:27:00.826]                 }
[10:27:00.826]             }
[10:27:00.826]         }))
[10:27:00.826]     }, error = function(ex) {
[10:27:00.826]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:00.826]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:00.826]                 ...future.rng), started = ...future.startTime, 
[10:27:00.826]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:00.826]             version = "1.8"), class = "FutureResult")
[10:27:00.826]     }, finally = {
[10:27:00.826]         if (!identical(...future.workdir, getwd())) 
[10:27:00.826]             setwd(...future.workdir)
[10:27:00.826]         {
[10:27:00.826]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:00.826]                 ...future.oldOptions$nwarnings <- NULL
[10:27:00.826]             }
[10:27:00.826]             base::options(...future.oldOptions)
[10:27:00.826]             if (.Platform$OS.type == "windows") {
[10:27:00.826]                 old_names <- names(...future.oldEnvVars)
[10:27:00.826]                 envs <- base::Sys.getenv()
[10:27:00.826]                 names <- names(envs)
[10:27:00.826]                 common <- intersect(names, old_names)
[10:27:00.826]                 added <- setdiff(names, old_names)
[10:27:00.826]                 removed <- setdiff(old_names, names)
[10:27:00.826]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:00.826]                   envs[common]]
[10:27:00.826]                 NAMES <- toupper(changed)
[10:27:00.826]                 args <- list()
[10:27:00.826]                 for (kk in seq_along(NAMES)) {
[10:27:00.826]                   name <- changed[[kk]]
[10:27:00.826]                   NAME <- NAMES[[kk]]
[10:27:00.826]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.826]                     next
[10:27:00.826]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:00.826]                 }
[10:27:00.826]                 NAMES <- toupper(added)
[10:27:00.826]                 for (kk in seq_along(NAMES)) {
[10:27:00.826]                   name <- added[[kk]]
[10:27:00.826]                   NAME <- NAMES[[kk]]
[10:27:00.826]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.826]                     next
[10:27:00.826]                   args[[name]] <- ""
[10:27:00.826]                 }
[10:27:00.826]                 NAMES <- toupper(removed)
[10:27:00.826]                 for (kk in seq_along(NAMES)) {
[10:27:00.826]                   name <- removed[[kk]]
[10:27:00.826]                   NAME <- NAMES[[kk]]
[10:27:00.826]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.826]                     next
[10:27:00.826]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:00.826]                 }
[10:27:00.826]                 if (length(args) > 0) 
[10:27:00.826]                   base::do.call(base::Sys.setenv, args = args)
[10:27:00.826]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:00.826]             }
[10:27:00.826]             else {
[10:27:00.826]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:00.826]             }
[10:27:00.826]             {
[10:27:00.826]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:00.826]                   0L) {
[10:27:00.826]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:00.826]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:00.826]                   base::options(opts)
[10:27:00.826]                 }
[10:27:00.826]                 {
[10:27:00.826]                   {
[10:27:00.826]                     NULL
[10:27:00.826]                     RNGkind("Mersenne-Twister")
[10:27:00.826]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:27:00.826]                       inherits = FALSE)
[10:27:00.826]                   }
[10:27:00.826]                   options(future.plan = NULL)
[10:27:00.826]                   if (is.na(NA_character_)) 
[10:27:00.826]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:00.826]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:00.826]                   future::plan(list(function (..., envir = parent.frame()) 
[10:27:00.826]                   {
[10:27:00.826]                     future <- SequentialFuture(..., envir = envir)
[10:27:00.826]                     if (!future$lazy) 
[10:27:00.826]                       future <- run(future)
[10:27:00.826]                     invisible(future)
[10:27:00.826]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:00.826]                 }
[10:27:00.826]             }
[10:27:00.826]         }
[10:27:00.826]     })
[10:27:00.826]     if (TRUE) {
[10:27:00.826]         base::sink(type = "output", split = FALSE)
[10:27:00.826]         if (TRUE) {
[10:27:00.826]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:00.826]         }
[10:27:00.826]         else {
[10:27:00.826]             ...future.result["stdout"] <- base::list(NULL)
[10:27:00.826]         }
[10:27:00.826]         base::close(...future.stdout)
[10:27:00.826]         ...future.stdout <- NULL
[10:27:00.826]     }
[10:27:00.826]     ...future.result$conditions <- ...future.conditions
[10:27:00.826]     ...future.result$finished <- base::Sys.time()
[10:27:00.826]     ...future.result
[10:27:00.826] }
[10:27:00.828] plan(): Setting new future strategy stack:
[10:27:00.828] List of future strategies:
[10:27:00.828] 1. sequential:
[10:27:00.828]    - args: function (..., envir = parent.frame())
[10:27:00.828]    - tweaked: FALSE
[10:27:00.828]    - call: NULL
[10:27:00.831] plan(): nbrOfWorkers() = 1
[10:27:00.832] plan(): Setting new future strategy stack:
[10:27:00.832] List of future strategies:
[10:27:00.832] 1. sequential:
[10:27:00.832]    - args: function (..., envir = parent.frame())
[10:27:00.832]    - tweaked: FALSE
[10:27:00.832]    - call: plan(strategy)
[10:27:00.832] plan(): nbrOfWorkers() = 1
[10:27:00.833] SequentialFuture started (and completed)
[10:27:00.833] - Launch lazy future ... done
[10:27:00.833] run() for ‘SequentialFuture’ ... done
[10:27:00.833] getGlobalsAndPackages() ...
[10:27:00.833] Searching for globals...
[10:27:00.834] - globals found: [2] ‘{’, ‘Sys.sleep’
[10:27:00.835] Searching for globals ... DONE
[10:27:00.835] Resolving globals: FALSE
[10:27:00.835] 
[10:27:00.835] 
[10:27:00.835] getGlobalsAndPackages() ... DONE
[10:27:00.835] run() for ‘Future’ ...
[10:27:00.835] - state: ‘created’
[10:27:00.836] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:27:00.836] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:27:00.836] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:27:00.836]   - Field: ‘label’
[10:27:00.836]   - Field: ‘local’
[10:27:00.836]   - Field: ‘owner’
[10:27:00.836]   - Field: ‘envir’
[10:27:00.837]   - Field: ‘packages’
[10:27:00.837]   - Field: ‘gc’
[10:27:00.837]   - Field: ‘conditions’
[10:27:00.837]   - Field: ‘expr’
[10:27:00.837]   - Field: ‘uuid’
[10:27:00.837]   - Field: ‘seed’
[10:27:00.837]   - Field: ‘version’
[10:27:00.837]   - Field: ‘result’
[10:27:00.837]   - Field: ‘asynchronous’
[10:27:00.837]   - Field: ‘calls’
[10:27:00.838]   - Field: ‘globals’
[10:27:00.838]   - Field: ‘stdout’
[10:27:00.838]   - Field: ‘earlySignal’
[10:27:00.838]   - Field: ‘lazy’
[10:27:00.838]   - Field: ‘state’
[10:27:00.838] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:27:00.838] - Launch lazy future ...
[10:27:00.838] Packages needed by the future expression (n = 0): <none>
[10:27:00.838] Packages needed by future strategies (n = 0): <none>
[10:27:00.839] {
[10:27:00.839]     {
[10:27:00.839]         {
[10:27:00.839]             ...future.startTime <- base::Sys.time()
[10:27:00.839]             {
[10:27:00.839]                 {
[10:27:00.839]                   {
[10:27:00.839]                     base::local({
[10:27:00.839]                       has_future <- base::requireNamespace("future", 
[10:27:00.839]                         quietly = TRUE)
[10:27:00.839]                       if (has_future) {
[10:27:00.839]                         ns <- base::getNamespace("future")
[10:27:00.839]                         version <- ns[[".package"]][["version"]]
[10:27:00.839]                         if (is.null(version)) 
[10:27:00.839]                           version <- utils::packageVersion("future")
[10:27:00.839]                       }
[10:27:00.839]                       else {
[10:27:00.839]                         version <- NULL
[10:27:00.839]                       }
[10:27:00.839]                       if (!has_future || version < "1.8.0") {
[10:27:00.839]                         info <- base::c(r_version = base::gsub("R version ", 
[10:27:00.839]                           "", base::R.version$version.string), 
[10:27:00.839]                           platform = base::sprintf("%s (%s-bit)", 
[10:27:00.839]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:00.839]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:00.839]                             "release", "version")], collapse = " "), 
[10:27:00.839]                           hostname = base::Sys.info()[["nodename"]])
[10:27:00.839]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:27:00.839]                           info)
[10:27:00.839]                         info <- base::paste(info, collapse = "; ")
[10:27:00.839]                         if (!has_future) {
[10:27:00.839]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:00.839]                             info)
[10:27:00.839]                         }
[10:27:00.839]                         else {
[10:27:00.839]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:00.839]                             info, version)
[10:27:00.839]                         }
[10:27:00.839]                         base::stop(msg)
[10:27:00.839]                       }
[10:27:00.839]                     })
[10:27:00.839]                   }
[10:27:00.839]                   options(future.plan = NULL)
[10:27:00.839]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:00.839]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:00.839]                 }
[10:27:00.839]                 ...future.workdir <- getwd()
[10:27:00.839]             }
[10:27:00.839]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:00.839]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:00.839]         }
[10:27:00.839]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:00.839]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:00.839]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:00.839]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:00.839]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:00.839]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:00.839]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:00.839]             base::names(...future.oldOptions))
[10:27:00.839]     }
[10:27:00.839]     if (FALSE) {
[10:27:00.839]     }
[10:27:00.839]     else {
[10:27:00.839]         if (TRUE) {
[10:27:00.839]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:00.839]                 open = "w")
[10:27:00.839]         }
[10:27:00.839]         else {
[10:27:00.839]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:00.839]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:00.839]         }
[10:27:00.839]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:00.839]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:00.839]             base::sink(type = "output", split = FALSE)
[10:27:00.839]             base::close(...future.stdout)
[10:27:00.839]         }, add = TRUE)
[10:27:00.839]     }
[10:27:00.839]     ...future.frame <- base::sys.nframe()
[10:27:00.839]     ...future.conditions <- base::list()
[10:27:00.839]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:00.839]     if (FALSE) {
[10:27:00.839]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:00.839]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:00.839]     }
[10:27:00.839]     ...future.result <- base::tryCatch({
[10:27:00.839]         base::withCallingHandlers({
[10:27:00.839]             ...future.value <- base::withVisible(base::local({
[10:27:00.839]                 Sys.sleep(0.5)
[10:27:00.839]                 2
[10:27:00.839]             }))
[10:27:00.839]             future::FutureResult(value = ...future.value$value, 
[10:27:00.839]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:00.839]                   ...future.rng), globalenv = if (FALSE) 
[10:27:00.839]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:00.839]                     ...future.globalenv.names))
[10:27:00.839]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:00.839]         }, condition = base::local({
[10:27:00.839]             c <- base::c
[10:27:00.839]             inherits <- base::inherits
[10:27:00.839]             invokeRestart <- base::invokeRestart
[10:27:00.839]             length <- base::length
[10:27:00.839]             list <- base::list
[10:27:00.839]             seq.int <- base::seq.int
[10:27:00.839]             signalCondition <- base::signalCondition
[10:27:00.839]             sys.calls <- base::sys.calls
[10:27:00.839]             `[[` <- base::`[[`
[10:27:00.839]             `+` <- base::`+`
[10:27:00.839]             `<<-` <- base::`<<-`
[10:27:00.839]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:00.839]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:00.839]                   3L)]
[10:27:00.839]             }
[10:27:00.839]             function(cond) {
[10:27:00.839]                 is_error <- inherits(cond, "error")
[10:27:00.839]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:00.839]                   NULL)
[10:27:00.839]                 if (is_error) {
[10:27:00.839]                   sessionInformation <- function() {
[10:27:00.839]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:00.839]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:00.839]                       search = base::search(), system = base::Sys.info())
[10:27:00.839]                   }
[10:27:00.839]                   ...future.conditions[[length(...future.conditions) + 
[10:27:00.839]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:00.839]                     cond$call), session = sessionInformation(), 
[10:27:00.839]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:00.839]                   signalCondition(cond)
[10:27:00.839]                 }
[10:27:00.839]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:00.839]                 "immediateCondition"))) {
[10:27:00.839]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:00.839]                   ...future.conditions[[length(...future.conditions) + 
[10:27:00.839]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:00.839]                   if (TRUE && !signal) {
[10:27:00.839]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:00.839]                     {
[10:27:00.839]                       inherits <- base::inherits
[10:27:00.839]                       invokeRestart <- base::invokeRestart
[10:27:00.839]                       is.null <- base::is.null
[10:27:00.839]                       muffled <- FALSE
[10:27:00.839]                       if (inherits(cond, "message")) {
[10:27:00.839]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:00.839]                         if (muffled) 
[10:27:00.839]                           invokeRestart("muffleMessage")
[10:27:00.839]                       }
[10:27:00.839]                       else if (inherits(cond, "warning")) {
[10:27:00.839]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:00.839]                         if (muffled) 
[10:27:00.839]                           invokeRestart("muffleWarning")
[10:27:00.839]                       }
[10:27:00.839]                       else if (inherits(cond, "condition")) {
[10:27:00.839]                         if (!is.null(pattern)) {
[10:27:00.839]                           computeRestarts <- base::computeRestarts
[10:27:00.839]                           grepl <- base::grepl
[10:27:00.839]                           restarts <- computeRestarts(cond)
[10:27:00.839]                           for (restart in restarts) {
[10:27:00.839]                             name <- restart$name
[10:27:00.839]                             if (is.null(name)) 
[10:27:00.839]                               next
[10:27:00.839]                             if (!grepl(pattern, name)) 
[10:27:00.839]                               next
[10:27:00.839]                             invokeRestart(restart)
[10:27:00.839]                             muffled <- TRUE
[10:27:00.839]                             break
[10:27:00.839]                           }
[10:27:00.839]                         }
[10:27:00.839]                       }
[10:27:00.839]                       invisible(muffled)
[10:27:00.839]                     }
[10:27:00.839]                     muffleCondition(cond, pattern = "^muffle")
[10:27:00.839]                   }
[10:27:00.839]                 }
[10:27:00.839]                 else {
[10:27:00.839]                   if (TRUE) {
[10:27:00.839]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:00.839]                     {
[10:27:00.839]                       inherits <- base::inherits
[10:27:00.839]                       invokeRestart <- base::invokeRestart
[10:27:00.839]                       is.null <- base::is.null
[10:27:00.839]                       muffled <- FALSE
[10:27:00.839]                       if (inherits(cond, "message")) {
[10:27:00.839]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:00.839]                         if (muffled) 
[10:27:00.839]                           invokeRestart("muffleMessage")
[10:27:00.839]                       }
[10:27:00.839]                       else if (inherits(cond, "warning")) {
[10:27:00.839]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:00.839]                         if (muffled) 
[10:27:00.839]                           invokeRestart("muffleWarning")
[10:27:00.839]                       }
[10:27:00.839]                       else if (inherits(cond, "condition")) {
[10:27:00.839]                         if (!is.null(pattern)) {
[10:27:00.839]                           computeRestarts <- base::computeRestarts
[10:27:00.839]                           grepl <- base::grepl
[10:27:00.839]                           restarts <- computeRestarts(cond)
[10:27:00.839]                           for (restart in restarts) {
[10:27:00.839]                             name <- restart$name
[10:27:00.839]                             if (is.null(name)) 
[10:27:00.839]                               next
[10:27:00.839]                             if (!grepl(pattern, name)) 
[10:27:00.839]                               next
[10:27:00.839]                             invokeRestart(restart)
[10:27:00.839]                             muffled <- TRUE
[10:27:00.839]                             break
[10:27:00.839]                           }
[10:27:00.839]                         }
[10:27:00.839]                       }
[10:27:00.839]                       invisible(muffled)
[10:27:00.839]                     }
[10:27:00.839]                     muffleCondition(cond, pattern = "^muffle")
[10:27:00.839]                   }
[10:27:00.839]                 }
[10:27:00.839]             }
[10:27:00.839]         }))
[10:27:00.839]     }, error = function(ex) {
[10:27:00.839]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:00.839]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:00.839]                 ...future.rng), started = ...future.startTime, 
[10:27:00.839]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:00.839]             version = "1.8"), class = "FutureResult")
[10:27:00.839]     }, finally = {
[10:27:00.839]         if (!identical(...future.workdir, getwd())) 
[10:27:00.839]             setwd(...future.workdir)
[10:27:00.839]         {
[10:27:00.839]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:00.839]                 ...future.oldOptions$nwarnings <- NULL
[10:27:00.839]             }
[10:27:00.839]             base::options(...future.oldOptions)
[10:27:00.839]             if (.Platform$OS.type == "windows") {
[10:27:00.839]                 old_names <- names(...future.oldEnvVars)
[10:27:00.839]                 envs <- base::Sys.getenv()
[10:27:00.839]                 names <- names(envs)
[10:27:00.839]                 common <- intersect(names, old_names)
[10:27:00.839]                 added <- setdiff(names, old_names)
[10:27:00.839]                 removed <- setdiff(old_names, names)
[10:27:00.839]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:00.839]                   envs[common]]
[10:27:00.839]                 NAMES <- toupper(changed)
[10:27:00.839]                 args <- list()
[10:27:00.839]                 for (kk in seq_along(NAMES)) {
[10:27:00.839]                   name <- changed[[kk]]
[10:27:00.839]                   NAME <- NAMES[[kk]]
[10:27:00.839]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.839]                     next
[10:27:00.839]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:00.839]                 }
[10:27:00.839]                 NAMES <- toupper(added)
[10:27:00.839]                 for (kk in seq_along(NAMES)) {
[10:27:00.839]                   name <- added[[kk]]
[10:27:00.839]                   NAME <- NAMES[[kk]]
[10:27:00.839]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.839]                     next
[10:27:00.839]                   args[[name]] <- ""
[10:27:00.839]                 }
[10:27:00.839]                 NAMES <- toupper(removed)
[10:27:00.839]                 for (kk in seq_along(NAMES)) {
[10:27:00.839]                   name <- removed[[kk]]
[10:27:00.839]                   NAME <- NAMES[[kk]]
[10:27:00.839]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:00.839]                     next
[10:27:00.839]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:00.839]                 }
[10:27:00.839]                 if (length(args) > 0) 
[10:27:00.839]                   base::do.call(base::Sys.setenv, args = args)
[10:27:00.839]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:00.839]             }
[10:27:00.839]             else {
[10:27:00.839]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:00.839]             }
[10:27:00.839]             {
[10:27:00.839]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:00.839]                   0L) {
[10:27:00.839]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:00.839]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:00.839]                   base::options(opts)
[10:27:00.839]                 }
[10:27:00.839]                 {
[10:27:00.839]                   {
[10:27:00.839]                     NULL
[10:27:00.839]                     RNGkind("Mersenne-Twister")
[10:27:00.839]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:27:00.839]                       inherits = FALSE)
[10:27:00.839]                   }
[10:27:00.839]                   options(future.plan = NULL)
[10:27:00.839]                   if (is.na(NA_character_)) 
[10:27:00.839]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:00.839]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:00.839]                   future::plan(list(function (..., envir = parent.frame()) 
[10:27:00.839]                   {
[10:27:00.839]                     future <- SequentialFuture(..., envir = envir)
[10:27:00.839]                     if (!future$lazy) 
[10:27:00.839]                       future <- run(future)
[10:27:00.839]                     invisible(future)
[10:27:00.839]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:00.839]                 }
[10:27:00.839]             }
[10:27:00.839]         }
[10:27:00.839]     })
[10:27:00.839]     if (TRUE) {
[10:27:00.839]         base::sink(type = "output", split = FALSE)
[10:27:00.839]         if (TRUE) {
[10:27:00.839]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:00.839]         }
[10:27:00.839]         else {
[10:27:00.839]             ...future.result["stdout"] <- base::list(NULL)
[10:27:00.839]         }
[10:27:00.839]         base::close(...future.stdout)
[10:27:00.839]         ...future.stdout <- NULL
[10:27:00.839]     }
[10:27:00.839]     ...future.result$conditions <- ...future.conditions
[10:27:00.839]     ...future.result$finished <- base::Sys.time()
[10:27:00.839]     ...future.result
[10:27:00.839] }
[10:27:00.841] plan(): Setting new future strategy stack:
[10:27:00.841] List of future strategies:
[10:27:00.841] 1. sequential:
[10:27:00.841]    - args: function (..., envir = parent.frame())
[10:27:00.841]    - tweaked: FALSE
[10:27:00.841]    - call: NULL
[10:27:00.841] plan(): nbrOfWorkers() = 1
[10:27:01.343] plan(): Setting new future strategy stack:
[10:27:01.343] List of future strategies:
[10:27:01.343] 1. sequential:
[10:27:01.343]    - args: function (..., envir = parent.frame())
[10:27:01.343]    - tweaked: FALSE
[10:27:01.343]    - call: plan(strategy)
[10:27:01.344] plan(): nbrOfWorkers() = 1
[10:27:01.344] SequentialFuture started (and completed)
[10:27:01.344] - Launch lazy future ... done
[10:27:01.344] run() for ‘SequentialFuture’ ... done
[10:27:01.345] getGlobalsAndPackages() ...
[10:27:01.345] Searching for globals...
[10:27:01.345] - globals found: [1] ‘{’
[10:27:01.346] Searching for globals ... DONE
[10:27:01.346] Resolving globals: FALSE
[10:27:01.346] 
[10:27:01.346] 
[10:27:01.346] getGlobalsAndPackages() ... DONE
[10:27:01.346] run() for ‘Future’ ...
[10:27:01.347] - state: ‘created’
[10:27:01.347] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:27:01.347] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:27:01.347] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:27:01.347]   - Field: ‘label’
[10:27:01.347]   - Field: ‘local’
[10:27:01.347]   - Field: ‘owner’
[10:27:01.347]   - Field: ‘envir’
[10:27:01.348]   - Field: ‘packages’
[10:27:01.348]   - Field: ‘gc’
[10:27:01.348]   - Field: ‘conditions’
[10:27:01.348]   - Field: ‘expr’
[10:27:01.348]   - Field: ‘uuid’
[10:27:01.348]   - Field: ‘seed’
[10:27:01.348]   - Field: ‘version’
[10:27:01.348]   - Field: ‘result’
[10:27:01.348]   - Field: ‘asynchronous’
[10:27:01.348]   - Field: ‘calls’
[10:27:01.349]   - Field: ‘globals’
[10:27:01.349]   - Field: ‘stdout’
[10:27:01.349]   - Field: ‘earlySignal’
[10:27:01.349]   - Field: ‘lazy’
[10:27:01.349]   - Field: ‘state’
[10:27:01.349] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:27:01.349] - Launch lazy future ...
[10:27:01.349] Packages needed by the future expression (n = 0): <none>
[10:27:01.349] Packages needed by future strategies (n = 0): <none>
[10:27:01.350] {
[10:27:01.350]     {
[10:27:01.350]         {
[10:27:01.350]             ...future.startTime <- base::Sys.time()
[10:27:01.350]             {
[10:27:01.350]                 {
[10:27:01.350]                   {
[10:27:01.350]                     base::local({
[10:27:01.350]                       has_future <- base::requireNamespace("future", 
[10:27:01.350]                         quietly = TRUE)
[10:27:01.350]                       if (has_future) {
[10:27:01.350]                         ns <- base::getNamespace("future")
[10:27:01.350]                         version <- ns[[".package"]][["version"]]
[10:27:01.350]                         if (is.null(version)) 
[10:27:01.350]                           version <- utils::packageVersion("future")
[10:27:01.350]                       }
[10:27:01.350]                       else {
[10:27:01.350]                         version <- NULL
[10:27:01.350]                       }
[10:27:01.350]                       if (!has_future || version < "1.8.0") {
[10:27:01.350]                         info <- base::c(r_version = base::gsub("R version ", 
[10:27:01.350]                           "", base::R.version$version.string), 
[10:27:01.350]                           platform = base::sprintf("%s (%s-bit)", 
[10:27:01.350]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:01.350]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:01.350]                             "release", "version")], collapse = " "), 
[10:27:01.350]                           hostname = base::Sys.info()[["nodename"]])
[10:27:01.350]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:27:01.350]                           info)
[10:27:01.350]                         info <- base::paste(info, collapse = "; ")
[10:27:01.350]                         if (!has_future) {
[10:27:01.350]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:01.350]                             info)
[10:27:01.350]                         }
[10:27:01.350]                         else {
[10:27:01.350]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:01.350]                             info, version)
[10:27:01.350]                         }
[10:27:01.350]                         base::stop(msg)
[10:27:01.350]                       }
[10:27:01.350]                     })
[10:27:01.350]                   }
[10:27:01.350]                   options(future.plan = NULL)
[10:27:01.350]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:01.350]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:01.350]                 }
[10:27:01.350]                 ...future.workdir <- getwd()
[10:27:01.350]             }
[10:27:01.350]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:01.350]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:01.350]         }
[10:27:01.350]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:01.350]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:01.350]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:01.350]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:01.350]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:01.350]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:01.350]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:01.350]             base::names(...future.oldOptions))
[10:27:01.350]     }
[10:27:01.350]     if (FALSE) {
[10:27:01.350]     }
[10:27:01.350]     else {
[10:27:01.350]         if (TRUE) {
[10:27:01.350]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:01.350]                 open = "w")
[10:27:01.350]         }
[10:27:01.350]         else {
[10:27:01.350]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:01.350]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:01.350]         }
[10:27:01.350]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:01.350]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:01.350]             base::sink(type = "output", split = FALSE)
[10:27:01.350]             base::close(...future.stdout)
[10:27:01.350]         }, add = TRUE)
[10:27:01.350]     }
[10:27:01.350]     ...future.frame <- base::sys.nframe()
[10:27:01.350]     ...future.conditions <- base::list()
[10:27:01.350]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:01.350]     if (FALSE) {
[10:27:01.350]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:01.350]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:01.350]     }
[10:27:01.350]     ...future.result <- base::tryCatch({
[10:27:01.350]         base::withCallingHandlers({
[10:27:01.350]             ...future.value <- base::withVisible(base::local({
[10:27:01.350]                 3
[10:27:01.350]             }))
[10:27:01.350]             future::FutureResult(value = ...future.value$value, 
[10:27:01.350]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:01.350]                   ...future.rng), globalenv = if (FALSE) 
[10:27:01.350]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:01.350]                     ...future.globalenv.names))
[10:27:01.350]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:01.350]         }, condition = base::local({
[10:27:01.350]             c <- base::c
[10:27:01.350]             inherits <- base::inherits
[10:27:01.350]             invokeRestart <- base::invokeRestart
[10:27:01.350]             length <- base::length
[10:27:01.350]             list <- base::list
[10:27:01.350]             seq.int <- base::seq.int
[10:27:01.350]             signalCondition <- base::signalCondition
[10:27:01.350]             sys.calls <- base::sys.calls
[10:27:01.350]             `[[` <- base::`[[`
[10:27:01.350]             `+` <- base::`+`
[10:27:01.350]             `<<-` <- base::`<<-`
[10:27:01.350]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:01.350]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:01.350]                   3L)]
[10:27:01.350]             }
[10:27:01.350]             function(cond) {
[10:27:01.350]                 is_error <- inherits(cond, "error")
[10:27:01.350]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:01.350]                   NULL)
[10:27:01.350]                 if (is_error) {
[10:27:01.350]                   sessionInformation <- function() {
[10:27:01.350]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:01.350]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:01.350]                       search = base::search(), system = base::Sys.info())
[10:27:01.350]                   }
[10:27:01.350]                   ...future.conditions[[length(...future.conditions) + 
[10:27:01.350]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:01.350]                     cond$call), session = sessionInformation(), 
[10:27:01.350]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:01.350]                   signalCondition(cond)
[10:27:01.350]                 }
[10:27:01.350]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:01.350]                 "immediateCondition"))) {
[10:27:01.350]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:01.350]                   ...future.conditions[[length(...future.conditions) + 
[10:27:01.350]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:01.350]                   if (TRUE && !signal) {
[10:27:01.350]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:01.350]                     {
[10:27:01.350]                       inherits <- base::inherits
[10:27:01.350]                       invokeRestart <- base::invokeRestart
[10:27:01.350]                       is.null <- base::is.null
[10:27:01.350]                       muffled <- FALSE
[10:27:01.350]                       if (inherits(cond, "message")) {
[10:27:01.350]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:01.350]                         if (muffled) 
[10:27:01.350]                           invokeRestart("muffleMessage")
[10:27:01.350]                       }
[10:27:01.350]                       else if (inherits(cond, "warning")) {
[10:27:01.350]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:01.350]                         if (muffled) 
[10:27:01.350]                           invokeRestart("muffleWarning")
[10:27:01.350]                       }
[10:27:01.350]                       else if (inherits(cond, "condition")) {
[10:27:01.350]                         if (!is.null(pattern)) {
[10:27:01.350]                           computeRestarts <- base::computeRestarts
[10:27:01.350]                           grepl <- base::grepl
[10:27:01.350]                           restarts <- computeRestarts(cond)
[10:27:01.350]                           for (restart in restarts) {
[10:27:01.350]                             name <- restart$name
[10:27:01.350]                             if (is.null(name)) 
[10:27:01.350]                               next
[10:27:01.350]                             if (!grepl(pattern, name)) 
[10:27:01.350]                               next
[10:27:01.350]                             invokeRestart(restart)
[10:27:01.350]                             muffled <- TRUE
[10:27:01.350]                             break
[10:27:01.350]                           }
[10:27:01.350]                         }
[10:27:01.350]                       }
[10:27:01.350]                       invisible(muffled)
[10:27:01.350]                     }
[10:27:01.350]                     muffleCondition(cond, pattern = "^muffle")
[10:27:01.350]                   }
[10:27:01.350]                 }
[10:27:01.350]                 else {
[10:27:01.350]                   if (TRUE) {
[10:27:01.350]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:01.350]                     {
[10:27:01.350]                       inherits <- base::inherits
[10:27:01.350]                       invokeRestart <- base::invokeRestart
[10:27:01.350]                       is.null <- base::is.null
[10:27:01.350]                       muffled <- FALSE
[10:27:01.350]                       if (inherits(cond, "message")) {
[10:27:01.350]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:01.350]                         if (muffled) 
[10:27:01.350]                           invokeRestart("muffleMessage")
[10:27:01.350]                       }
[10:27:01.350]                       else if (inherits(cond, "warning")) {
[10:27:01.350]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:01.350]                         if (muffled) 
[10:27:01.350]                           invokeRestart("muffleWarning")
[10:27:01.350]                       }
[10:27:01.350]                       else if (inherits(cond, "condition")) {
[10:27:01.350]                         if (!is.null(pattern)) {
[10:27:01.350]                           computeRestarts <- base::computeRestarts
[10:27:01.350]                           grepl <- base::grepl
[10:27:01.350]                           restarts <- computeRestarts(cond)
[10:27:01.350]                           for (restart in restarts) {
[10:27:01.350]                             name <- restart$name
[10:27:01.350]                             if (is.null(name)) 
[10:27:01.350]                               next
[10:27:01.350]                             if (!grepl(pattern, name)) 
[10:27:01.350]                               next
[10:27:01.350]                             invokeRestart(restart)
[10:27:01.350]                             muffled <- TRUE
[10:27:01.350]                             break
[10:27:01.350]                           }
[10:27:01.350]                         }
[10:27:01.350]                       }
[10:27:01.350]                       invisible(muffled)
[10:27:01.350]                     }
[10:27:01.350]                     muffleCondition(cond, pattern = "^muffle")
[10:27:01.350]                   }
[10:27:01.350]                 }
[10:27:01.350]             }
[10:27:01.350]         }))
[10:27:01.350]     }, error = function(ex) {
[10:27:01.350]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:01.350]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:01.350]                 ...future.rng), started = ...future.startTime, 
[10:27:01.350]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:01.350]             version = "1.8"), class = "FutureResult")
[10:27:01.350]     }, finally = {
[10:27:01.350]         if (!identical(...future.workdir, getwd())) 
[10:27:01.350]             setwd(...future.workdir)
[10:27:01.350]         {
[10:27:01.350]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:01.350]                 ...future.oldOptions$nwarnings <- NULL
[10:27:01.350]             }
[10:27:01.350]             base::options(...future.oldOptions)
[10:27:01.350]             if (.Platform$OS.type == "windows") {
[10:27:01.350]                 old_names <- names(...future.oldEnvVars)
[10:27:01.350]                 envs <- base::Sys.getenv()
[10:27:01.350]                 names <- names(envs)
[10:27:01.350]                 common <- intersect(names, old_names)
[10:27:01.350]                 added <- setdiff(names, old_names)
[10:27:01.350]                 removed <- setdiff(old_names, names)
[10:27:01.350]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:01.350]                   envs[common]]
[10:27:01.350]                 NAMES <- toupper(changed)
[10:27:01.350]                 args <- list()
[10:27:01.350]                 for (kk in seq_along(NAMES)) {
[10:27:01.350]                   name <- changed[[kk]]
[10:27:01.350]                   NAME <- NAMES[[kk]]
[10:27:01.350]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:01.350]                     next
[10:27:01.350]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:01.350]                 }
[10:27:01.350]                 NAMES <- toupper(added)
[10:27:01.350]                 for (kk in seq_along(NAMES)) {
[10:27:01.350]                   name <- added[[kk]]
[10:27:01.350]                   NAME <- NAMES[[kk]]
[10:27:01.350]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:01.350]                     next
[10:27:01.350]                   args[[name]] <- ""
[10:27:01.350]                 }
[10:27:01.350]                 NAMES <- toupper(removed)
[10:27:01.350]                 for (kk in seq_along(NAMES)) {
[10:27:01.350]                   name <- removed[[kk]]
[10:27:01.350]                   NAME <- NAMES[[kk]]
[10:27:01.350]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:01.350]                     next
[10:27:01.350]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:01.350]                 }
[10:27:01.350]                 if (length(args) > 0) 
[10:27:01.350]                   base::do.call(base::Sys.setenv, args = args)
[10:27:01.350]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:01.350]             }
[10:27:01.350]             else {
[10:27:01.350]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:01.350]             }
[10:27:01.350]             {
[10:27:01.350]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:01.350]                   0L) {
[10:27:01.350]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:01.350]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:01.350]                   base::options(opts)
[10:27:01.350]                 }
[10:27:01.350]                 {
[10:27:01.350]                   {
[10:27:01.350]                     NULL
[10:27:01.350]                     RNGkind("Mersenne-Twister")
[10:27:01.350]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:27:01.350]                       inherits = FALSE)
[10:27:01.350]                   }
[10:27:01.350]                   options(future.plan = NULL)
[10:27:01.350]                   if (is.na(NA_character_)) 
[10:27:01.350]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:01.350]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:01.350]                   future::plan(list(function (..., envir = parent.frame()) 
[10:27:01.350]                   {
[10:27:01.350]                     future <- SequentialFuture(..., envir = envir)
[10:27:01.350]                     if (!future$lazy) 
[10:27:01.350]                       future <- run(future)
[10:27:01.350]                     invisible(future)
[10:27:01.350]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:01.350]                 }
[10:27:01.350]             }
[10:27:01.350]         }
[10:27:01.350]     })
[10:27:01.350]     if (TRUE) {
[10:27:01.350]         base::sink(type = "output", split = FALSE)
[10:27:01.350]         if (TRUE) {
[10:27:01.350]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:01.350]         }
[10:27:01.350]         else {
[10:27:01.350]             ...future.result["stdout"] <- base::list(NULL)
[10:27:01.350]         }
[10:27:01.350]         base::close(...future.stdout)
[10:27:01.350]         ...future.stdout <- NULL
[10:27:01.350]     }
[10:27:01.350]     ...future.result$conditions <- ...future.conditions
[10:27:01.350]     ...future.result$finished <- base::Sys.time()
[10:27:01.350]     ...future.result
[10:27:01.350] }
[10:27:01.352] plan(): Setting new future strategy stack:
[10:27:01.352] List of future strategies:
[10:27:01.352] 1. sequential:
[10:27:01.352]    - args: function (..., envir = parent.frame())
[10:27:01.352]    - tweaked: FALSE
[10:27:01.352]    - call: NULL
[10:27:01.352] plan(): nbrOfWorkers() = 1
[10:27:01.353] plan(): Setting new future strategy stack:
[10:27:01.353] List of future strategies:
[10:27:01.353] 1. sequential:
[10:27:01.353]    - args: function (..., envir = parent.frame())
[10:27:01.353]    - tweaked: FALSE
[10:27:01.353]    - call: plan(strategy)
[10:27:01.354] plan(): nbrOfWorkers() = 1
[10:27:01.354] SequentialFuture started (and completed)
[10:27:01.354] - Launch lazy future ... done
[10:27:01.354] run() for ‘SequentialFuture’ ... done
[10:27:01.355] resolve() on list environment ...
[10:27:01.355]  recursive: 0
[10:27:01.355]  length: 4
[10:27:01.355]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:27:01.356] resolved() for ‘SequentialFuture’ ...
[10:27:01.356] - state: ‘finished’
[10:27:01.356] - run: TRUE
[10:27:01.356] - result: ‘FutureResult’
[10:27:01.356] resolved() for ‘SequentialFuture’ ... done
[10:27:01.356] Future #1
[10:27:01.356]  length: 3 (resolved future 1)
[10:27:01.356] resolved() for ‘SequentialFuture’ ...
[10:27:01.356] - state: ‘finished’
[10:27:01.357] - run: TRUE
[10:27:01.357] - result: ‘FutureResult’
[10:27:01.357] resolved() for ‘SequentialFuture’ ... done
[10:27:01.357] Future #2
[10:27:01.357]  length: 2 (resolved future 2)
[10:27:01.357] resolved() for ‘SequentialFuture’ ...
[10:27:01.357] - state: ‘finished’
[10:27:01.357] - run: TRUE
[10:27:01.357] - result: ‘FutureResult’
[10:27:01.357] resolved() for ‘SequentialFuture’ ... done
[10:27:01.358] Future #3
[10:27:01.358]  length: 1 (resolved future 3)
[10:27:01.358]  length: 0 (resolved future 4)
[10:27:01.358] resolve() on list environment ... DONE
[10:27:01.358] resolved() for ‘SequentialFuture’ ...
[10:27:01.358] - state: ‘finished’
[10:27:01.358] - run: TRUE
[10:27:01.361] - result: ‘FutureResult’
[10:27:01.361] resolved() for ‘SequentialFuture’ ... done
[10:27:01.361] resolve() on list environment ...
[10:27:01.361]  recursive: 0
[10:27:01.362]  length: 4
[10:27:01.362]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:27:01.362] resolved() for ‘SequentialFuture’ ...
[10:27:01.362] - state: ‘finished’
[10:27:01.362] - run: TRUE
[10:27:01.362] - result: ‘FutureResult’
[10:27:01.362] resolved() for ‘SequentialFuture’ ... done
[10:27:01.363] Future #1
[10:27:01.363]  length: 3 (resolved future 1)
[10:27:01.363] resolved() for ‘SequentialFuture’ ...
[10:27:01.363] - state: ‘finished’
[10:27:01.363] - run: TRUE
[10:27:01.363] - result: ‘FutureResult’
[10:27:01.363] resolved() for ‘SequentialFuture’ ... done
[10:27:01.363] Future #2
[10:27:01.363]  length: 2 (resolved future 2)
[10:27:01.364] resolved() for ‘SequentialFuture’ ...
[10:27:01.364] - state: ‘finished’
[10:27:01.364] - run: TRUE
[10:27:01.364] - result: ‘FutureResult’
[10:27:01.364] resolved() for ‘SequentialFuture’ ... done
[10:27:01.364] Future #3
[10:27:01.364]  length: 1 (resolved future 3)
[10:27:01.364]  length: 0 (resolved future 4)
[10:27:01.364] resolve() on list environment ... DONE
[10:27:01.365] resolve() on list environment ...
[10:27:01.365]  recursive: 0
[10:27:01.366]  length: 4
[10:27:01.366]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:27:01.366] resolved() for ‘SequentialFuture’ ...
[10:27:01.366] - state: ‘finished’
[10:27:01.366] - run: TRUE
[10:27:01.366] - result: ‘FutureResult’
[10:27:01.366] resolved() for ‘SequentialFuture’ ... done
[10:27:01.366] Future #1
[10:27:01.367]  length: 3 (resolved future 1)
[10:27:01.367] resolved() for ‘SequentialFuture’ ...
[10:27:01.367] - state: ‘finished’
[10:27:01.367] - run: TRUE
[10:27:01.367] - result: ‘FutureResult’
[10:27:01.367] resolved() for ‘SequentialFuture’ ... done
[10:27:01.367] Future #2
[10:27:01.367]  length: 2 (resolved future 2)
[10:27:01.367] resolved() for ‘SequentialFuture’ ...
[10:27:01.367] - state: ‘finished’
[10:27:01.368] - run: TRUE
[10:27:01.368] - result: ‘FutureResult’
[10:27:01.368] resolved() for ‘SequentialFuture’ ... done
[10:27:01.368] Future #3
[10:27:01.368]  length: 1 (resolved future 3)
[10:27:01.368]  length: 0 (resolved future 4)
[10:27:01.368] resolve() on list environment ... DONE
[10:27:01.369] resolve() on list environment ...
[10:27:01.369]  recursive: 0
[10:27:01.369]  length: 4
[10:27:01.369]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:27:01.370] resolved() for ‘SequentialFuture’ ...
[10:27:01.370] - state: ‘finished’
[10:27:01.370] - run: TRUE
[10:27:01.370] - result: ‘FutureResult’
[10:27:01.370] resolved() for ‘SequentialFuture’ ... done
[10:27:01.370] Future #1
[10:27:01.370]  length: 3 (resolved future 1)
[10:27:01.370] resolved() for ‘SequentialFuture’ ...
[10:27:01.370] - state: ‘finished’
[10:27:01.370] - run: TRUE
[10:27:01.371] - result: ‘FutureResult’
[10:27:01.371] resolved() for ‘SequentialFuture’ ... done
[10:27:01.371] Future #2
[10:27:01.371]  length: 2 (resolved future 2)
[10:27:01.371] resolved() for ‘SequentialFuture’ ...
[10:27:01.371] - state: ‘finished’
[10:27:01.371] - run: TRUE
[10:27:01.371] - result: ‘FutureResult’
[10:27:01.371] resolved() for ‘SequentialFuture’ ... done
[10:27:01.371] Future #3
[10:27:01.372]  length: 1 (resolved future 3)
[10:27:01.372]  length: 0 (resolved future 4)
[10:27:01.372] resolve() on list environment ... DONE
[10:27:01.372] resolve() on list environment ...
[10:27:01.372]  recursive: 0
[10:27:01.373]  length: 4
[10:27:01.373]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:27:01.373] resolved() for ‘SequentialFuture’ ...
[10:27:01.373] - state: ‘finished’
[10:27:01.373] - run: TRUE
[10:27:01.374] - result: ‘FutureResult’
[10:27:01.374] resolved() for ‘SequentialFuture’ ... done
[10:27:01.374] Future #1
[10:27:01.374]  length: 3 (resolved future 1)
[10:27:01.374] resolved() for ‘SequentialFuture’ ...
[10:27:01.374] - state: ‘finished’
[10:27:01.374] - run: TRUE
[10:27:01.374] - result: ‘FutureResult’
[10:27:01.374] resolved() for ‘SequentialFuture’ ... done
[10:27:01.375] Future #2
[10:27:01.375]  length: 2 (resolved future 2)
[10:27:01.375] resolved() for ‘SequentialFuture’ ...
[10:27:01.375] - state: ‘finished’
[10:27:01.375] - run: TRUE
[10:27:01.375] - result: ‘FutureResult’
[10:27:01.375] resolved() for ‘SequentialFuture’ ... done
[10:27:01.375] Future #3
[10:27:01.375]  length: 1 (resolved future 3)
[10:27:01.376]  length: 0 (resolved future 4)
[10:27:01.376] resolve() on list environment ... DONE
[10:27:01.376] resolve() on list environment ...
[10:27:01.376]  recursive: 99
[10:27:01.377]  length: 4
[10:27:01.377]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:27:01.377] resolved() for ‘SequentialFuture’ ...
[10:27:01.377] - state: ‘finished’
[10:27:01.377] - run: TRUE
[10:27:01.377] - result: ‘FutureResult’
[10:27:01.378] resolved() for ‘SequentialFuture’ ... done
[10:27:01.378] Future #1
[10:27:01.378] resolved() for ‘SequentialFuture’ ...
[10:27:01.378] - state: ‘finished’
[10:27:01.378] - run: TRUE
[10:27:01.378] - result: ‘FutureResult’
[10:27:01.378] resolved() for ‘SequentialFuture’ ... done
[10:27:01.378] A SequentialFuture was resolved
[10:27:01.378]  length: 3 (resolved future 1)
[10:27:01.378] resolved() for ‘SequentialFuture’ ...
[10:27:01.379] - state: ‘finished’
[10:27:01.379] - run: TRUE
[10:27:01.379] - result: ‘FutureResult’
[10:27:01.379] resolved() for ‘SequentialFuture’ ... done
[10:27:01.379] Future #2
[10:27:01.379] resolved() for ‘SequentialFuture’ ...
[10:27:01.379] - state: ‘finished’
[10:27:01.379] - run: TRUE
[10:27:01.379] - result: ‘FutureResult’
[10:27:01.379] resolved() for ‘SequentialFuture’ ... done
[10:27:01.380] A SequentialFuture was resolved
[10:27:01.380]  length: 2 (resolved future 2)
[10:27:01.380] resolved() for ‘SequentialFuture’ ...
[10:27:01.380] - state: ‘finished’
[10:27:01.380] - run: TRUE
[10:27:01.380] - result: ‘FutureResult’
[10:27:01.380] resolved() for ‘SequentialFuture’ ... done
[10:27:01.380] Future #3
[10:27:01.380] resolved() for ‘SequentialFuture’ ...
[10:27:01.381] - state: ‘finished’
[10:27:01.381] - run: TRUE
[10:27:01.381] - result: ‘FutureResult’
[10:27:01.412] resolved() for ‘SequentialFuture’ ... done
[10:27:01.413] A SequentialFuture was resolved
[10:27:01.413]  length: 1 (resolved future 3)
[10:27:01.413]  length: 0 (resolved future 4)
[10:27:01.413] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('sequential') ...
- plan('multicore') ...
[10:27:01.414] plan(): Setting new future strategy stack:
[10:27:01.414] List of future strategies:
[10:27:01.414] 1. multicore:
[10:27:01.414]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:27:01.414]    - tweaked: FALSE
[10:27:01.414]    - call: plan(strategy)
[10:27:01.418] plan(): nbrOfWorkers() = 2
*** resolve() for lists ...
[10:27:01.419] resolve() on list ...
[10:27:01.419]  recursive: 0
[10:27:01.419]  length: 2
[10:27:01.419]  elements: ‘a’, ‘b’
[10:27:01.419]  length: 1 (resolved future 1)
[10:27:01.419]  length: 0 (resolved future 2)
[10:27:01.420] resolve() on list ... DONE
[10:27:01.420] getGlobalsAndPackages() ...
[10:27:01.420] Searching for globals...
[10:27:01.420] 
[10:27:01.420] Searching for globals ... DONE
[10:27:01.420] - globals: [0] <none>
[10:27:01.421] getGlobalsAndPackages() ... DONE
[10:27:01.421] run() for ‘Future’ ...
[10:27:01.421] - state: ‘created’
[10:27:01.421] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:27:01.427] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:01.427] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:27:01.427]   - Field: ‘label’
[10:27:01.427]   - Field: ‘local’
[10:27:01.427]   - Field: ‘owner’
[10:27:01.427]   - Field: ‘envir’
[10:27:01.428]   - Field: ‘workers’
[10:27:01.428]   - Field: ‘packages’
[10:27:01.428]   - Field: ‘gc’
[10:27:01.428]   - Field: ‘job’
[10:27:01.428]   - Field: ‘conditions’
[10:27:01.428]   - Field: ‘expr’
[10:27:01.428]   - Field: ‘uuid’
[10:27:01.428]   - Field: ‘seed’
[10:27:01.428]   - Field: ‘version’
[10:27:01.428]   - Field: ‘result’
[10:27:01.429]   - Field: ‘asynchronous’
[10:27:01.429]   - Field: ‘calls’
[10:27:01.429]   - Field: ‘globals’
[10:27:01.429]   - Field: ‘stdout’
[10:27:01.429]   - Field: ‘earlySignal’
[10:27:01.429]   - Field: ‘lazy’
[10:27:01.429]   - Field: ‘state’
[10:27:01.429] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:27:01.429] - Launch lazy future ...
[10:27:01.432] Packages needed by the future expression (n = 0): <none>
[10:27:01.432] Packages needed by future strategies (n = 0): <none>
[10:27:01.432] {
[10:27:01.432]     {
[10:27:01.432]         {
[10:27:01.432]             ...future.startTime <- base::Sys.time()
[10:27:01.432]             {
[10:27:01.432]                 {
[10:27:01.432]                   {
[10:27:01.432]                     {
[10:27:01.432]                       base::local({
[10:27:01.432]                         has_future <- base::requireNamespace("future", 
[10:27:01.432]                           quietly = TRUE)
[10:27:01.432]                         if (has_future) {
[10:27:01.432]                           ns <- base::getNamespace("future")
[10:27:01.432]                           version <- ns[[".package"]][["version"]]
[10:27:01.432]                           if (is.null(version)) 
[10:27:01.432]                             version <- utils::packageVersion("future")
[10:27:01.432]                         }
[10:27:01.432]                         else {
[10:27:01.432]                           version <- NULL
[10:27:01.432]                         }
[10:27:01.432]                         if (!has_future || version < "1.8.0") {
[10:27:01.432]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:01.432]                             "", base::R.version$version.string), 
[10:27:01.432]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:01.432]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:01.432]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:01.432]                               "release", "version")], collapse = " "), 
[10:27:01.432]                             hostname = base::Sys.info()[["nodename"]])
[10:27:01.432]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:01.432]                             info)
[10:27:01.432]                           info <- base::paste(info, collapse = "; ")
[10:27:01.432]                           if (!has_future) {
[10:27:01.432]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:01.432]                               info)
[10:27:01.432]                           }
[10:27:01.432]                           else {
[10:27:01.432]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:01.432]                               info, version)
[10:27:01.432]                           }
[10:27:01.432]                           base::stop(msg)
[10:27:01.432]                         }
[10:27:01.432]                       })
[10:27:01.432]                     }
[10:27:01.432]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:01.432]                     base::options(mc.cores = 1L)
[10:27:01.432]                   }
[10:27:01.432]                   options(future.plan = NULL)
[10:27:01.432]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:01.432]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:01.432]                 }
[10:27:01.432]                 ...future.workdir <- getwd()
[10:27:01.432]             }
[10:27:01.432]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:01.432]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:01.432]         }
[10:27:01.432]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:01.432]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:01.432]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:01.432]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:01.432]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:01.432]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:01.432]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:01.432]             base::names(...future.oldOptions))
[10:27:01.432]     }
[10:27:01.432]     if (FALSE) {
[10:27:01.432]     }
[10:27:01.432]     else {
[10:27:01.432]         if (TRUE) {
[10:27:01.432]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:01.432]                 open = "w")
[10:27:01.432]         }
[10:27:01.432]         else {
[10:27:01.432]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:01.432]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:01.432]         }
[10:27:01.432]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:01.432]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:01.432]             base::sink(type = "output", split = FALSE)
[10:27:01.432]             base::close(...future.stdout)
[10:27:01.432]         }, add = TRUE)
[10:27:01.432]     }
[10:27:01.432]     ...future.frame <- base::sys.nframe()
[10:27:01.432]     ...future.conditions <- base::list()
[10:27:01.432]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:01.432]     if (FALSE) {
[10:27:01.432]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:01.432]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:01.432]     }
[10:27:01.432]     ...future.result <- base::tryCatch({
[10:27:01.432]         base::withCallingHandlers({
[10:27:01.432]             ...future.value <- base::withVisible(base::local({
[10:27:01.432]                 withCallingHandlers({
[10:27:01.432]                   1
[10:27:01.432]                 }, immediateCondition = function(cond) {
[10:27:01.432]                   save_rds <- function (object, pathname, ...) 
[10:27:01.432]                   {
[10:27:01.432]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:27:01.432]                     if (file_test("-f", pathname_tmp)) {
[10:27:01.432]                       fi_tmp <- file.info(pathname_tmp)
[10:27:01.432]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:27:01.432]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:01.432]                         fi_tmp[["mtime"]])
[10:27:01.432]                     }
[10:27:01.432]                     tryCatch({
[10:27:01.432]                       saveRDS(object, file = pathname_tmp, ...)
[10:27:01.432]                     }, error = function(ex) {
[10:27:01.432]                       msg <- conditionMessage(ex)
[10:27:01.432]                       fi_tmp <- file.info(pathname_tmp)
[10:27:01.432]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:27:01.432]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:01.432]                         fi_tmp[["mtime"]], msg)
[10:27:01.432]                       ex$message <- msg
[10:27:01.432]                       stop(ex)
[10:27:01.432]                     })
[10:27:01.432]                     stopifnot(file_test("-f", pathname_tmp))
[10:27:01.432]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:27:01.432]                     if (!res || file_test("-f", pathname_tmp)) {
[10:27:01.432]                       fi_tmp <- file.info(pathname_tmp)
[10:27:01.432]                       fi <- file.info(pathname)
[10:27:01.432]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:27:01.432]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:01.432]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:27:01.432]                         fi[["size"]], fi[["mtime"]])
[10:27:01.432]                       stop(msg)
[10:27:01.432]                     }
[10:27:01.432]                     invisible(pathname)
[10:27:01.432]                   }
[10:27:01.432]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:27:01.432]                     rootPath = tempdir()) 
[10:27:01.432]                   {
[10:27:01.432]                     obj <- list(time = Sys.time(), condition = cond)
[10:27:01.432]                     file <- tempfile(pattern = class(cond)[1], 
[10:27:01.432]                       tmpdir = path, fileext = ".rds")
[10:27:01.432]                     save_rds(obj, file)
[10:27:01.432]                   }
[10:27:01.432]                   saveImmediateCondition(cond, path = "/tmp/RtmpisxSDE/.future/immediateConditions")
[10:27:01.432]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:01.432]                   {
[10:27:01.432]                     inherits <- base::inherits
[10:27:01.432]                     invokeRestart <- base::invokeRestart
[10:27:01.432]                     is.null <- base::is.null
[10:27:01.432]                     muffled <- FALSE
[10:27:01.432]                     if (inherits(cond, "message")) {
[10:27:01.432]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:01.432]                       if (muffled) 
[10:27:01.432]                         invokeRestart("muffleMessage")
[10:27:01.432]                     }
[10:27:01.432]                     else if (inherits(cond, "warning")) {
[10:27:01.432]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:01.432]                       if (muffled) 
[10:27:01.432]                         invokeRestart("muffleWarning")
[10:27:01.432]                     }
[10:27:01.432]                     else if (inherits(cond, "condition")) {
[10:27:01.432]                       if (!is.null(pattern)) {
[10:27:01.432]                         computeRestarts <- base::computeRestarts
[10:27:01.432]                         grepl <- base::grepl
[10:27:01.432]                         restarts <- computeRestarts(cond)
[10:27:01.432]                         for (restart in restarts) {
[10:27:01.432]                           name <- restart$name
[10:27:01.432]                           if (is.null(name)) 
[10:27:01.432]                             next
[10:27:01.432]                           if (!grepl(pattern, name)) 
[10:27:01.432]                             next
[10:27:01.432]                           invokeRestart(restart)
[10:27:01.432]                           muffled <- TRUE
[10:27:01.432]                           break
[10:27:01.432]                         }
[10:27:01.432]                       }
[10:27:01.432]                     }
[10:27:01.432]                     invisible(muffled)
[10:27:01.432]                   }
[10:27:01.432]                   muffleCondition(cond)
[10:27:01.432]                 })
[10:27:01.432]             }))
[10:27:01.432]             future::FutureResult(value = ...future.value$value, 
[10:27:01.432]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:01.432]                   ...future.rng), globalenv = if (FALSE) 
[10:27:01.432]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:01.432]                     ...future.globalenv.names))
[10:27:01.432]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:01.432]         }, condition = base::local({
[10:27:01.432]             c <- base::c
[10:27:01.432]             inherits <- base::inherits
[10:27:01.432]             invokeRestart <- base::invokeRestart
[10:27:01.432]             length <- base::length
[10:27:01.432]             list <- base::list
[10:27:01.432]             seq.int <- base::seq.int
[10:27:01.432]             signalCondition <- base::signalCondition
[10:27:01.432]             sys.calls <- base::sys.calls
[10:27:01.432]             `[[` <- base::`[[`
[10:27:01.432]             `+` <- base::`+`
[10:27:01.432]             `<<-` <- base::`<<-`
[10:27:01.432]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:01.432]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:01.432]                   3L)]
[10:27:01.432]             }
[10:27:01.432]             function(cond) {
[10:27:01.432]                 is_error <- inherits(cond, "error")
[10:27:01.432]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:01.432]                   NULL)
[10:27:01.432]                 if (is_error) {
[10:27:01.432]                   sessionInformation <- function() {
[10:27:01.432]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:01.432]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:01.432]                       search = base::search(), system = base::Sys.info())
[10:27:01.432]                   }
[10:27:01.432]                   ...future.conditions[[length(...future.conditions) + 
[10:27:01.432]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:01.432]                     cond$call), session = sessionInformation(), 
[10:27:01.432]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:01.432]                   signalCondition(cond)
[10:27:01.432]                 }
[10:27:01.432]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:01.432]                 "immediateCondition"))) {
[10:27:01.432]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:01.432]                   ...future.conditions[[length(...future.conditions) + 
[10:27:01.432]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:01.432]                   if (TRUE && !signal) {
[10:27:01.432]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:01.432]                     {
[10:27:01.432]                       inherits <- base::inherits
[10:27:01.432]                       invokeRestart <- base::invokeRestart
[10:27:01.432]                       is.null <- base::is.null
[10:27:01.432]                       muffled <- FALSE
[10:27:01.432]                       if (inherits(cond, "message")) {
[10:27:01.432]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:01.432]                         if (muffled) 
[10:27:01.432]                           invokeRestart("muffleMessage")
[10:27:01.432]                       }
[10:27:01.432]                       else if (inherits(cond, "warning")) {
[10:27:01.432]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:01.432]                         if (muffled) 
[10:27:01.432]                           invokeRestart("muffleWarning")
[10:27:01.432]                       }
[10:27:01.432]                       else if (inherits(cond, "condition")) {
[10:27:01.432]                         if (!is.null(pattern)) {
[10:27:01.432]                           computeRestarts <- base::computeRestarts
[10:27:01.432]                           grepl <- base::grepl
[10:27:01.432]                           restarts <- computeRestarts(cond)
[10:27:01.432]                           for (restart in restarts) {
[10:27:01.432]                             name <- restart$name
[10:27:01.432]                             if (is.null(name)) 
[10:27:01.432]                               next
[10:27:01.432]                             if (!grepl(pattern, name)) 
[10:27:01.432]                               next
[10:27:01.432]                             invokeRestart(restart)
[10:27:01.432]                             muffled <- TRUE
[10:27:01.432]                             break
[10:27:01.432]                           }
[10:27:01.432]                         }
[10:27:01.432]                       }
[10:27:01.432]                       invisible(muffled)
[10:27:01.432]                     }
[10:27:01.432]                     muffleCondition(cond, pattern = "^muffle")
[10:27:01.432]                   }
[10:27:01.432]                 }
[10:27:01.432]                 else {
[10:27:01.432]                   if (TRUE) {
[10:27:01.432]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:01.432]                     {
[10:27:01.432]                       inherits <- base::inherits
[10:27:01.432]                       invokeRestart <- base::invokeRestart
[10:27:01.432]                       is.null <- base::is.null
[10:27:01.432]                       muffled <- FALSE
[10:27:01.432]                       if (inherits(cond, "message")) {
[10:27:01.432]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:01.432]                         if (muffled) 
[10:27:01.432]                           invokeRestart("muffleMessage")
[10:27:01.432]                       }
[10:27:01.432]                       else if (inherits(cond, "warning")) {
[10:27:01.432]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:01.432]                         if (muffled) 
[10:27:01.432]                           invokeRestart("muffleWarning")
[10:27:01.432]                       }
[10:27:01.432]                       else if (inherits(cond, "condition")) {
[10:27:01.432]                         if (!is.null(pattern)) {
[10:27:01.432]                           computeRestarts <- base::computeRestarts
[10:27:01.432]                           grepl <- base::grepl
[10:27:01.432]                           restarts <- computeRestarts(cond)
[10:27:01.432]                           for (restart in restarts) {
[10:27:01.432]                             name <- restart$name
[10:27:01.432]                             if (is.null(name)) 
[10:27:01.432]                               next
[10:27:01.432]                             if (!grepl(pattern, name)) 
[10:27:01.432]                               next
[10:27:01.432]                             invokeRestart(restart)
[10:27:01.432]                             muffled <- TRUE
[10:27:01.432]                             break
[10:27:01.432]                           }
[10:27:01.432]                         }
[10:27:01.432]                       }
[10:27:01.432]                       invisible(muffled)
[10:27:01.432]                     }
[10:27:01.432]                     muffleCondition(cond, pattern = "^muffle")
[10:27:01.432]                   }
[10:27:01.432]                 }
[10:27:01.432]             }
[10:27:01.432]         }))
[10:27:01.432]     }, error = function(ex) {
[10:27:01.432]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:01.432]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:01.432]                 ...future.rng), started = ...future.startTime, 
[10:27:01.432]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:01.432]             version = "1.8"), class = "FutureResult")
[10:27:01.432]     }, finally = {
[10:27:01.432]         if (!identical(...future.workdir, getwd())) 
[10:27:01.432]             setwd(...future.workdir)
[10:27:01.432]         {
[10:27:01.432]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:01.432]                 ...future.oldOptions$nwarnings <- NULL
[10:27:01.432]             }
[10:27:01.432]             base::options(...future.oldOptions)
[10:27:01.432]             if (.Platform$OS.type == "windows") {
[10:27:01.432]                 old_names <- names(...future.oldEnvVars)
[10:27:01.432]                 envs <- base::Sys.getenv()
[10:27:01.432]                 names <- names(envs)
[10:27:01.432]                 common <- intersect(names, old_names)
[10:27:01.432]                 added <- setdiff(names, old_names)
[10:27:01.432]                 removed <- setdiff(old_names, names)
[10:27:01.432]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:01.432]                   envs[common]]
[10:27:01.432]                 NAMES <- toupper(changed)
[10:27:01.432]                 args <- list()
[10:27:01.432]                 for (kk in seq_along(NAMES)) {
[10:27:01.432]                   name <- changed[[kk]]
[10:27:01.432]                   NAME <- NAMES[[kk]]
[10:27:01.432]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:01.432]                     next
[10:27:01.432]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:01.432]                 }
[10:27:01.432]                 NAMES <- toupper(added)
[10:27:01.432]                 for (kk in seq_along(NAMES)) {
[10:27:01.432]                   name <- added[[kk]]
[10:27:01.432]                   NAME <- NAMES[[kk]]
[10:27:01.432]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:01.432]                     next
[10:27:01.432]                   args[[name]] <- ""
[10:27:01.432]                 }
[10:27:01.432]                 NAMES <- toupper(removed)
[10:27:01.432]                 for (kk in seq_along(NAMES)) {
[10:27:01.432]                   name <- removed[[kk]]
[10:27:01.432]                   NAME <- NAMES[[kk]]
[10:27:01.432]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:01.432]                     next
[10:27:01.432]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:01.432]                 }
[10:27:01.432]                 if (length(args) > 0) 
[10:27:01.432]                   base::do.call(base::Sys.setenv, args = args)
[10:27:01.432]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:01.432]             }
[10:27:01.432]             else {
[10:27:01.432]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:01.432]             }
[10:27:01.432]             {
[10:27:01.432]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:01.432]                   0L) {
[10:27:01.432]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:01.432]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:01.432]                   base::options(opts)
[10:27:01.432]                 }
[10:27:01.432]                 {
[10:27:01.432]                   {
[10:27:01.432]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:01.432]                     NULL
[10:27:01.432]                   }
[10:27:01.432]                   options(future.plan = NULL)
[10:27:01.432]                   if (is.na(NA_character_)) 
[10:27:01.432]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:01.432]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:01.432]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:27:01.432]                     envir = parent.frame()) 
[10:27:01.432]                   {
[10:27:01.432]                     default_workers <- missing(workers)
[10:27:01.432]                     if (is.function(workers)) 
[10:27:01.432]                       workers <- workers()
[10:27:01.432]                     workers <- structure(as.integer(workers), 
[10:27:01.432]                       class = class(workers))
[10:27:01.432]                     stop_if_not(is.finite(workers), workers >= 
[10:27:01.432]                       1L)
[10:27:01.432]                     if ((workers == 1L && !inherits(workers, 
[10:27:01.432]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:27:01.432]                       if (default_workers) 
[10:27:01.432]                         supportsMulticore(warn = TRUE)
[10:27:01.432]                       return(sequential(..., envir = envir))
[10:27:01.432]                     }
[10:27:01.432]                     oopts <- options(mc.cores = workers)
[10:27:01.432]                     on.exit(options(oopts))
[10:27:01.432]                     future <- MulticoreFuture(..., workers = workers, 
[10:27:01.432]                       envir = envir)
[10:27:01.432]                     if (!future$lazy) 
[10:27:01.432]                       future <- run(future)
[10:27:01.432]                     invisible(future)
[10:27:01.432]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:01.432]                 }
[10:27:01.432]             }
[10:27:01.432]         }
[10:27:01.432]     })
[10:27:01.432]     if (TRUE) {
[10:27:01.432]         base::sink(type = "output", split = FALSE)
[10:27:01.432]         if (TRUE) {
[10:27:01.432]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:01.432]         }
[10:27:01.432]         else {
[10:27:01.432]             ...future.result["stdout"] <- base::list(NULL)
[10:27:01.432]         }
[10:27:01.432]         base::close(...future.stdout)
[10:27:01.432]         ...future.stdout <- NULL
[10:27:01.432]     }
[10:27:01.432]     ...future.result$conditions <- ...future.conditions
[10:27:01.432]     ...future.result$finished <- base::Sys.time()
[10:27:01.432]     ...future.result
[10:27:01.432] }
[10:27:01.435] requestCore(): workers = 2
[10:27:01.438] MulticoreFuture started
[10:27:01.439] - Launch lazy future ... done
[10:27:01.439] plan(): Setting new future strategy stack:
[10:27:01.439] run() for ‘MulticoreFuture’ ... done
[10:27:01.439] getGlobalsAndPackages() ...
[10:27:01.440] Searching for globals...
[10:27:01.439] List of future strategies:
[10:27:01.439] 1. sequential:
[10:27:01.439]    - args: function (..., envir = parent.frame())
[10:27:01.439]    - tweaked: FALSE
[10:27:01.439]    - call: NULL
[10:27:01.440] plan(): nbrOfWorkers() = 1
[10:27:01.441] 
[10:27:01.441] Searching for globals ... DONE
[10:27:01.441] - globals: [0] <none>
[10:27:01.441] getGlobalsAndPackages() ... DONE
[10:27:01.442] run() for ‘Future’ ...
[10:27:01.442] - state: ‘created’
[10:27:01.442] plan(): Setting new future strategy stack:
[10:27:01.443] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:27:01.442] List of future strategies:
[10:27:01.442] 1. multicore:
[10:27:01.442]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:27:01.442]    - tweaked: FALSE
[10:27:01.442]    - call: plan(strategy)
[10:27:01.448] plan(): nbrOfWorkers() = 2
[10:27:01.448] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:01.449] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:27:01.449]   - Field: ‘label’
[10:27:01.449]   - Field: ‘local’
[10:27:01.449]   - Field: ‘owner’
[10:27:01.449]   - Field: ‘envir’
[10:27:01.449]   - Field: ‘workers’
[10:27:01.450]   - Field: ‘packages’
[10:27:01.450]   - Field: ‘gc’
[10:27:01.450]   - Field: ‘job’
[10:27:01.450]   - Field: ‘conditions’
[10:27:01.450]   - Field: ‘expr’
[10:27:01.450]   - Field: ‘uuid’
[10:27:01.451]   - Field: ‘seed’
[10:27:01.451]   - Field: ‘version’
[10:27:01.451]   - Field: ‘result’
[10:27:01.451]   - Field: ‘asynchronous’
[10:27:01.451]   - Field: ‘calls’
[10:27:01.451]   - Field: ‘globals’
[10:27:01.451]   - Field: ‘stdout’
[10:27:01.452]   - Field: ‘earlySignal’
[10:27:01.452]   - Field: ‘lazy’
[10:27:01.452]   - Field: ‘state’
[10:27:01.452] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:27:01.452] - Launch lazy future ...
[10:27:01.453] Packages needed by the future expression (n = 0): <none>
[10:27:01.453] Packages needed by future strategies (n = 0): <none>
[10:27:01.454] {
[10:27:01.454]     {
[10:27:01.454]         {
[10:27:01.454]             ...future.startTime <- base::Sys.time()
[10:27:01.454]             {
[10:27:01.454]                 {
[10:27:01.454]                   {
[10:27:01.454]                     {
[10:27:01.454]                       base::local({
[10:27:01.454]                         has_future <- base::requireNamespace("future", 
[10:27:01.454]                           quietly = TRUE)
[10:27:01.454]                         if (has_future) {
[10:27:01.454]                           ns <- base::getNamespace("future")
[10:27:01.454]                           version <- ns[[".package"]][["version"]]
[10:27:01.454]                           if (is.null(version)) 
[10:27:01.454]                             version <- utils::packageVersion("future")
[10:27:01.454]                         }
[10:27:01.454]                         else {
[10:27:01.454]                           version <- NULL
[10:27:01.454]                         }
[10:27:01.454]                         if (!has_future || version < "1.8.0") {
[10:27:01.454]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:01.454]                             "", base::R.version$version.string), 
[10:27:01.454]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:01.454]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:01.454]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:01.454]                               "release", "version")], collapse = " "), 
[10:27:01.454]                             hostname = base::Sys.info()[["nodename"]])
[10:27:01.454]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:01.454]                             info)
[10:27:01.454]                           info <- base::paste(info, collapse = "; ")
[10:27:01.454]                           if (!has_future) {
[10:27:01.454]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:01.454]                               info)
[10:27:01.454]                           }
[10:27:01.454]                           else {
[10:27:01.454]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:01.454]                               info, version)
[10:27:01.454]                           }
[10:27:01.454]                           base::stop(msg)
[10:27:01.454]                         }
[10:27:01.454]                       })
[10:27:01.454]                     }
[10:27:01.454]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:01.454]                     base::options(mc.cores = 1L)
[10:27:01.454]                   }
[10:27:01.454]                   options(future.plan = NULL)
[10:27:01.454]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:01.454]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:01.454]                 }
[10:27:01.454]                 ...future.workdir <- getwd()
[10:27:01.454]             }
[10:27:01.454]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:01.454]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:01.454]         }
[10:27:01.454]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:01.454]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:01.454]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:01.454]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:01.454]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:01.454]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:01.454]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:01.454]             base::names(...future.oldOptions))
[10:27:01.454]     }
[10:27:01.454]     if (FALSE) {
[10:27:01.454]     }
[10:27:01.454]     else {
[10:27:01.454]         if (TRUE) {
[10:27:01.454]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:01.454]                 open = "w")
[10:27:01.454]         }
[10:27:01.454]         else {
[10:27:01.454]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:01.454]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:01.454]         }
[10:27:01.454]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:01.454]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:01.454]             base::sink(type = "output", split = FALSE)
[10:27:01.454]             base::close(...future.stdout)
[10:27:01.454]         }, add = TRUE)
[10:27:01.454]     }
[10:27:01.454]     ...future.frame <- base::sys.nframe()
[10:27:01.454]     ...future.conditions <- base::list()
[10:27:01.454]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:01.454]     if (FALSE) {
[10:27:01.454]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:01.454]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:01.454]     }
[10:27:01.454]     ...future.result <- base::tryCatch({
[10:27:01.454]         base::withCallingHandlers({
[10:27:01.454]             ...future.value <- base::withVisible(base::local({
[10:27:01.454]                 withCallingHandlers({
[10:27:01.454]                   2
[10:27:01.454]                 }, immediateCondition = function(cond) {
[10:27:01.454]                   save_rds <- function (object, pathname, ...) 
[10:27:01.454]                   {
[10:27:01.454]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:27:01.454]                     if (file_test("-f", pathname_tmp)) {
[10:27:01.454]                       fi_tmp <- file.info(pathname_tmp)
[10:27:01.454]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:27:01.454]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:01.454]                         fi_tmp[["mtime"]])
[10:27:01.454]                     }
[10:27:01.454]                     tryCatch({
[10:27:01.454]                       saveRDS(object, file = pathname_tmp, ...)
[10:27:01.454]                     }, error = function(ex) {
[10:27:01.454]                       msg <- conditionMessage(ex)
[10:27:01.454]                       fi_tmp <- file.info(pathname_tmp)
[10:27:01.454]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:27:01.454]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:01.454]                         fi_tmp[["mtime"]], msg)
[10:27:01.454]                       ex$message <- msg
[10:27:01.454]                       stop(ex)
[10:27:01.454]                     })
[10:27:01.454]                     stopifnot(file_test("-f", pathname_tmp))
[10:27:01.454]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:27:01.454]                     if (!res || file_test("-f", pathname_tmp)) {
[10:27:01.454]                       fi_tmp <- file.info(pathname_tmp)
[10:27:01.454]                       fi <- file.info(pathname)
[10:27:01.454]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:27:01.454]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:01.454]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:27:01.454]                         fi[["size"]], fi[["mtime"]])
[10:27:01.454]                       stop(msg)
[10:27:01.454]                     }
[10:27:01.454]                     invisible(pathname)
[10:27:01.454]                   }
[10:27:01.454]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:27:01.454]                     rootPath = tempdir()) 
[10:27:01.454]                   {
[10:27:01.454]                     obj <- list(time = Sys.time(), condition = cond)
[10:27:01.454]                     file <- tempfile(pattern = class(cond)[1], 
[10:27:01.454]                       tmpdir = path, fileext = ".rds")
[10:27:01.454]                     save_rds(obj, file)
[10:27:01.454]                   }
[10:27:01.454]                   saveImmediateCondition(cond, path = "/tmp/RtmpisxSDE/.future/immediateConditions")
[10:27:01.454]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:01.454]                   {
[10:27:01.454]                     inherits <- base::inherits
[10:27:01.454]                     invokeRestart <- base::invokeRestart
[10:27:01.454]                     is.null <- base::is.null
[10:27:01.454]                     muffled <- FALSE
[10:27:01.454]                     if (inherits(cond, "message")) {
[10:27:01.454]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:01.454]                       if (muffled) 
[10:27:01.454]                         invokeRestart("muffleMessage")
[10:27:01.454]                     }
[10:27:01.454]                     else if (inherits(cond, "warning")) {
[10:27:01.454]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:01.454]                       if (muffled) 
[10:27:01.454]                         invokeRestart("muffleWarning")
[10:27:01.454]                     }
[10:27:01.454]                     else if (inherits(cond, "condition")) {
[10:27:01.454]                       if (!is.null(pattern)) {
[10:27:01.454]                         computeRestarts <- base::computeRestarts
[10:27:01.454]                         grepl <- base::grepl
[10:27:01.454]                         restarts <- computeRestarts(cond)
[10:27:01.454]                         for (restart in restarts) {
[10:27:01.454]                           name <- restart$name
[10:27:01.454]                           if (is.null(name)) 
[10:27:01.454]                             next
[10:27:01.454]                           if (!grepl(pattern, name)) 
[10:27:01.454]                             next
[10:27:01.454]                           invokeRestart(restart)
[10:27:01.454]                           muffled <- TRUE
[10:27:01.454]                           break
[10:27:01.454]                         }
[10:27:01.454]                       }
[10:27:01.454]                     }
[10:27:01.454]                     invisible(muffled)
[10:27:01.454]                   }
[10:27:01.454]                   muffleCondition(cond)
[10:27:01.454]                 })
[10:27:01.454]             }))
[10:27:01.454]             future::FutureResult(value = ...future.value$value, 
[10:27:01.454]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:01.454]                   ...future.rng), globalenv = if (FALSE) 
[10:27:01.454]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:01.454]                     ...future.globalenv.names))
[10:27:01.454]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:01.454]         }, condition = base::local({
[10:27:01.454]             c <- base::c
[10:27:01.454]             inherits <- base::inherits
[10:27:01.454]             invokeRestart <- base::invokeRestart
[10:27:01.454]             length <- base::length
[10:27:01.454]             list <- base::list
[10:27:01.454]             seq.int <- base::seq.int
[10:27:01.454]             signalCondition <- base::signalCondition
[10:27:01.454]             sys.calls <- base::sys.calls
[10:27:01.454]             `[[` <- base::`[[`
[10:27:01.454]             `+` <- base::`+`
[10:27:01.454]             `<<-` <- base::`<<-`
[10:27:01.454]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:01.454]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:01.454]                   3L)]
[10:27:01.454]             }
[10:27:01.454]             function(cond) {
[10:27:01.454]                 is_error <- inherits(cond, "error")
[10:27:01.454]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:01.454]                   NULL)
[10:27:01.454]                 if (is_error) {
[10:27:01.454]                   sessionInformation <- function() {
[10:27:01.454]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:01.454]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:01.454]                       search = base::search(), system = base::Sys.info())
[10:27:01.454]                   }
[10:27:01.454]                   ...future.conditions[[length(...future.conditions) + 
[10:27:01.454]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:01.454]                     cond$call), session = sessionInformation(), 
[10:27:01.454]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:01.454]                   signalCondition(cond)
[10:27:01.454]                 }
[10:27:01.454]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:01.454]                 "immediateCondition"))) {
[10:27:01.454]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:01.454]                   ...future.conditions[[length(...future.conditions) + 
[10:27:01.454]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:01.454]                   if (TRUE && !signal) {
[10:27:01.454]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:01.454]                     {
[10:27:01.454]                       inherits <- base::inherits
[10:27:01.454]                       invokeRestart <- base::invokeRestart
[10:27:01.454]                       is.null <- base::is.null
[10:27:01.454]                       muffled <- FALSE
[10:27:01.454]                       if (inherits(cond, "message")) {
[10:27:01.454]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:01.454]                         if (muffled) 
[10:27:01.454]                           invokeRestart("muffleMessage")
[10:27:01.454]                       }
[10:27:01.454]                       else if (inherits(cond, "warning")) {
[10:27:01.454]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:01.454]                         if (muffled) 
[10:27:01.454]                           invokeRestart("muffleWarning")
[10:27:01.454]                       }
[10:27:01.454]                       else if (inherits(cond, "condition")) {
[10:27:01.454]                         if (!is.null(pattern)) {
[10:27:01.454]                           computeRestarts <- base::computeRestarts
[10:27:01.454]                           grepl <- base::grepl
[10:27:01.454]                           restarts <- computeRestarts(cond)
[10:27:01.454]                           for (restart in restarts) {
[10:27:01.454]                             name <- restart$name
[10:27:01.454]                             if (is.null(name)) 
[10:27:01.454]                               next
[10:27:01.454]                             if (!grepl(pattern, name)) 
[10:27:01.454]                               next
[10:27:01.454]                             invokeRestart(restart)
[10:27:01.454]                             muffled <- TRUE
[10:27:01.454]                             break
[10:27:01.454]                           }
[10:27:01.454]                         }
[10:27:01.454]                       }
[10:27:01.454]                       invisible(muffled)
[10:27:01.454]                     }
[10:27:01.454]                     muffleCondition(cond, pattern = "^muffle")
[10:27:01.454]                   }
[10:27:01.454]                 }
[10:27:01.454]                 else {
[10:27:01.454]                   if (TRUE) {
[10:27:01.454]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:01.454]                     {
[10:27:01.454]                       inherits <- base::inherits
[10:27:01.454]                       invokeRestart <- base::invokeRestart
[10:27:01.454]                       is.null <- base::is.null
[10:27:01.454]                       muffled <- FALSE
[10:27:01.454]                       if (inherits(cond, "message")) {
[10:27:01.454]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:01.454]                         if (muffled) 
[10:27:01.454]                           invokeRestart("muffleMessage")
[10:27:01.454]                       }
[10:27:01.454]                       else if (inherits(cond, "warning")) {
[10:27:01.454]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:01.454]                         if (muffled) 
[10:27:01.454]                           invokeRestart("muffleWarning")
[10:27:01.454]                       }
[10:27:01.454]                       else if (inherits(cond, "condition")) {
[10:27:01.454]                         if (!is.null(pattern)) {
[10:27:01.454]                           computeRestarts <- base::computeRestarts
[10:27:01.454]                           grepl <- base::grepl
[10:27:01.454]                           restarts <- computeRestarts(cond)
[10:27:01.454]                           for (restart in restarts) {
[10:27:01.454]                             name <- restart$name
[10:27:01.454]                             if (is.null(name)) 
[10:27:01.454]                               next
[10:27:01.454]                             if (!grepl(pattern, name)) 
[10:27:01.454]                               next
[10:27:01.454]                             invokeRestart(restart)
[10:27:01.454]                             muffled <- TRUE
[10:27:01.454]                             break
[10:27:01.454]                           }
[10:27:01.454]                         }
[10:27:01.454]                       }
[10:27:01.454]                       invisible(muffled)
[10:27:01.454]                     }
[10:27:01.454]                     muffleCondition(cond, pattern = "^muffle")
[10:27:01.454]                   }
[10:27:01.454]                 }
[10:27:01.454]             }
[10:27:01.454]         }))
[10:27:01.454]     }, error = function(ex) {
[10:27:01.454]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:01.454]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:01.454]                 ...future.rng), started = ...future.startTime, 
[10:27:01.454]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:01.454]             version = "1.8"), class = "FutureResult")
[10:27:01.454]     }, finally = {
[10:27:01.454]         if (!identical(...future.workdir, getwd())) 
[10:27:01.454]             setwd(...future.workdir)
[10:27:01.454]         {
[10:27:01.454]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:01.454]                 ...future.oldOptions$nwarnings <- NULL
[10:27:01.454]             }
[10:27:01.454]             base::options(...future.oldOptions)
[10:27:01.454]             if (.Platform$OS.type == "windows") {
[10:27:01.454]                 old_names <- names(...future.oldEnvVars)
[10:27:01.454]                 envs <- base::Sys.getenv()
[10:27:01.454]                 names <- names(envs)
[10:27:01.454]                 common <- intersect(names, old_names)
[10:27:01.454]                 added <- setdiff(names, old_names)
[10:27:01.454]                 removed <- setdiff(old_names, names)
[10:27:01.454]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:01.454]                   envs[common]]
[10:27:01.454]                 NAMES <- toupper(changed)
[10:27:01.454]                 args <- list()
[10:27:01.454]                 for (kk in seq_along(NAMES)) {
[10:27:01.454]                   name <- changed[[kk]]
[10:27:01.454]                   NAME <- NAMES[[kk]]
[10:27:01.454]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:01.454]                     next
[10:27:01.454]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:01.454]                 }
[10:27:01.454]                 NAMES <- toupper(added)
[10:27:01.454]                 for (kk in seq_along(NAMES)) {
[10:27:01.454]                   name <- added[[kk]]
[10:27:01.454]                   NAME <- NAMES[[kk]]
[10:27:01.454]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:01.454]                     next
[10:27:01.454]                   args[[name]] <- ""
[10:27:01.454]                 }
[10:27:01.454]                 NAMES <- toupper(removed)
[10:27:01.454]                 for (kk in seq_along(NAMES)) {
[10:27:01.454]                   name <- removed[[kk]]
[10:27:01.454]                   NAME <- NAMES[[kk]]
[10:27:01.454]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:01.454]                     next
[10:27:01.454]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:01.454]                 }
[10:27:01.454]                 if (length(args) > 0) 
[10:27:01.454]                   base::do.call(base::Sys.setenv, args = args)
[10:27:01.454]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:01.454]             }
[10:27:01.454]             else {
[10:27:01.454]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:01.454]             }
[10:27:01.454]             {
[10:27:01.454]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:01.454]                   0L) {
[10:27:01.454]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:01.454]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:01.454]                   base::options(opts)
[10:27:01.454]                 }
[10:27:01.454]                 {
[10:27:01.454]                   {
[10:27:01.454]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:01.454]                     NULL
[10:27:01.454]                   }
[10:27:01.454]                   options(future.plan = NULL)
[10:27:01.454]                   if (is.na(NA_character_)) 
[10:27:01.454]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:01.454]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:01.454]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:27:01.454]                     envir = parent.frame()) 
[10:27:01.454]                   {
[10:27:01.454]                     default_workers <- missing(workers)
[10:27:01.454]                     if (is.function(workers)) 
[10:27:01.454]                       workers <- workers()
[10:27:01.454]                     workers <- structure(as.integer(workers), 
[10:27:01.454]                       class = class(workers))
[10:27:01.454]                     stop_if_not(is.finite(workers), workers >= 
[10:27:01.454]                       1L)
[10:27:01.454]                     if ((workers == 1L && !inherits(workers, 
[10:27:01.454]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:27:01.454]                       if (default_workers) 
[10:27:01.454]                         supportsMulticore(warn = TRUE)
[10:27:01.454]                       return(sequential(..., envir = envir))
[10:27:01.454]                     }
[10:27:01.454]                     oopts <- options(mc.cores = workers)
[10:27:01.454]                     on.exit(options(oopts))
[10:27:01.454]                     future <- MulticoreFuture(..., workers = workers, 
[10:27:01.454]                       envir = envir)
[10:27:01.454]                     if (!future$lazy) 
[10:27:01.454]                       future <- run(future)
[10:27:01.454]                     invisible(future)
[10:27:01.454]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:01.454]                 }
[10:27:01.454]             }
[10:27:01.454]         }
[10:27:01.454]     })
[10:27:01.454]     if (TRUE) {
[10:27:01.454]         base::sink(type = "output", split = FALSE)
[10:27:01.454]         if (TRUE) {
[10:27:01.454]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:01.454]         }
[10:27:01.454]         else {
[10:27:01.454]             ...future.result["stdout"] <- base::list(NULL)
[10:27:01.454]         }
[10:27:01.454]         base::close(...future.stdout)
[10:27:01.454]         ...future.stdout <- NULL
[10:27:01.454]     }
[10:27:01.454]     ...future.result$conditions <- ...future.conditions
[10:27:01.454]     ...future.result$finished <- base::Sys.time()
[10:27:01.454]     ...future.result
[10:27:01.454] }
[10:27:01.457] requestCore(): workers = 2
[10:27:01.464] MulticoreFuture started
[10:27:01.464] - Launch lazy future ... done
[10:27:01.464] run() for ‘MulticoreFuture’ ... done
[10:27:01.465] resolve() on list ...
[10:27:01.465]  recursive: 0
[10:27:01.465] plan(): Setting new future strategy stack:
[10:27:01.465]  length: 3
[10:27:01.465]  elements: ‘a’, ‘b’, ‘’
[10:27:01.465] List of future strategies:
[10:27:01.465] 1. sequential:
[10:27:01.465]    - args: function (..., envir = parent.frame())
[10:27:01.465]    - tweaked: FALSE
[10:27:01.465]    - call: NULL
[10:27:01.466] plan(): nbrOfWorkers() = 1
[10:27:01.467] Future #1
[10:27:01.467]  length: 2 (resolved future 1)
[10:27:01.468] plan(): Setting new future strategy stack:
[10:27:01.468] List of future strategies:
[10:27:01.468] 1. multicore:
[10:27:01.468]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:27:01.468]    - tweaked: FALSE
[10:27:01.468]    - call: plan(strategy)
[10:27:01.476] plan(): nbrOfWorkers() = 2
[10:27:01.479] Future #2
[10:27:01.479]  length: 1 (resolved future 2)
[10:27:01.479]  length: 0 (resolved future 3)
[10:27:01.480] resolve() on list ... DONE
[10:27:01.480] getGlobalsAndPackages() ...
[10:27:01.480] Searching for globals...
[10:27:01.481] 
[10:27:01.481] Searching for globals ... DONE
[10:27:01.482] - globals: [0] <none>
[10:27:01.482] getGlobalsAndPackages() ... DONE
[10:27:01.482] getGlobalsAndPackages() ...
[10:27:01.482] Searching for globals...
[10:27:01.483] 
[10:27:01.483] Searching for globals ... DONE
[10:27:01.483] - globals: [0] <none>
[10:27:01.483] getGlobalsAndPackages() ... DONE
[10:27:01.484] run() for ‘Future’ ...
[10:27:01.484] - state: ‘created’
[10:27:01.484] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:27:01.489] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:01.490] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:27:01.490]   - Field: ‘label’
[10:27:01.490]   - Field: ‘local’
[10:27:01.490]   - Field: ‘owner’
[10:27:01.496]   - Field: ‘envir’
[10:27:01.496]   - Field: ‘workers’
[10:27:01.496]   - Field: ‘packages’
[10:27:01.497]   - Field: ‘gc’
[10:27:01.497]   - Field: ‘job’
[10:27:01.497]   - Field: ‘conditions’
[10:27:01.498]   - Field: ‘expr’
[10:27:01.498]   - Field: ‘uuid’
[10:27:01.498]   - Field: ‘seed’
[10:27:01.498]   - Field: ‘version’
[10:27:01.499]   - Field: ‘result’
[10:27:01.499]   - Field: ‘asynchronous’
[10:27:01.499]   - Field: ‘calls’
[10:27:01.500]   - Field: ‘globals’
[10:27:01.500]   - Field: ‘stdout’
[10:27:01.500]   - Field: ‘earlySignal’
[10:27:01.500]   - Field: ‘lazy’
[10:27:01.500]   - Field: ‘state’
[10:27:01.501] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:27:01.501] - Launch lazy future ...
[10:27:01.501] Packages needed by the future expression (n = 0): <none>
[10:27:01.501] Packages needed by future strategies (n = 0): <none>
[10:27:01.502] {
[10:27:01.502]     {
[10:27:01.502]         {
[10:27:01.502]             ...future.startTime <- base::Sys.time()
[10:27:01.502]             {
[10:27:01.502]                 {
[10:27:01.502]                   {
[10:27:01.502]                     {
[10:27:01.502]                       base::local({
[10:27:01.502]                         has_future <- base::requireNamespace("future", 
[10:27:01.502]                           quietly = TRUE)
[10:27:01.502]                         if (has_future) {
[10:27:01.502]                           ns <- base::getNamespace("future")
[10:27:01.502]                           version <- ns[[".package"]][["version"]]
[10:27:01.502]                           if (is.null(version)) 
[10:27:01.502]                             version <- utils::packageVersion("future")
[10:27:01.502]                         }
[10:27:01.502]                         else {
[10:27:01.502]                           version <- NULL
[10:27:01.502]                         }
[10:27:01.502]                         if (!has_future || version < "1.8.0") {
[10:27:01.502]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:01.502]                             "", base::R.version$version.string), 
[10:27:01.502]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:01.502]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:01.502]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:01.502]                               "release", "version")], collapse = " "), 
[10:27:01.502]                             hostname = base::Sys.info()[["nodename"]])
[10:27:01.502]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:01.502]                             info)
[10:27:01.502]                           info <- base::paste(info, collapse = "; ")
[10:27:01.502]                           if (!has_future) {
[10:27:01.502]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:01.502]                               info)
[10:27:01.502]                           }
[10:27:01.502]                           else {
[10:27:01.502]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:01.502]                               info, version)
[10:27:01.502]                           }
[10:27:01.502]                           base::stop(msg)
[10:27:01.502]                         }
[10:27:01.502]                       })
[10:27:01.502]                     }
[10:27:01.502]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:01.502]                     base::options(mc.cores = 1L)
[10:27:01.502]                   }
[10:27:01.502]                   options(future.plan = NULL)
[10:27:01.502]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:01.502]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:01.502]                 }
[10:27:01.502]                 ...future.workdir <- getwd()
[10:27:01.502]             }
[10:27:01.502]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:01.502]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:01.502]         }
[10:27:01.502]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:01.502]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:01.502]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:01.502]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:01.502]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:01.502]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:01.502]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:01.502]             base::names(...future.oldOptions))
[10:27:01.502]     }
[10:27:01.502]     if (FALSE) {
[10:27:01.502]     }
[10:27:01.502]     else {
[10:27:01.502]         if (TRUE) {
[10:27:01.502]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:01.502]                 open = "w")
[10:27:01.502]         }
[10:27:01.502]         else {
[10:27:01.502]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:01.502]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:01.502]         }
[10:27:01.502]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:01.502]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:01.502]             base::sink(type = "output", split = FALSE)
[10:27:01.502]             base::close(...future.stdout)
[10:27:01.502]         }, add = TRUE)
[10:27:01.502]     }
[10:27:01.502]     ...future.frame <- base::sys.nframe()
[10:27:01.502]     ...future.conditions <- base::list()
[10:27:01.502]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:01.502]     if (FALSE) {
[10:27:01.502]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:01.502]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:01.502]     }
[10:27:01.502]     ...future.result <- base::tryCatch({
[10:27:01.502]         base::withCallingHandlers({
[10:27:01.502]             ...future.value <- base::withVisible(base::local({
[10:27:01.502]                 withCallingHandlers({
[10:27:01.502]                   2
[10:27:01.502]                 }, immediateCondition = function(cond) {
[10:27:01.502]                   save_rds <- function (object, pathname, ...) 
[10:27:01.502]                   {
[10:27:01.502]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:27:01.502]                     if (file_test("-f", pathname_tmp)) {
[10:27:01.502]                       fi_tmp <- file.info(pathname_tmp)
[10:27:01.502]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:27:01.502]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:01.502]                         fi_tmp[["mtime"]])
[10:27:01.502]                     }
[10:27:01.502]                     tryCatch({
[10:27:01.502]                       saveRDS(object, file = pathname_tmp, ...)
[10:27:01.502]                     }, error = function(ex) {
[10:27:01.502]                       msg <- conditionMessage(ex)
[10:27:01.502]                       fi_tmp <- file.info(pathname_tmp)
[10:27:01.502]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:27:01.502]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:01.502]                         fi_tmp[["mtime"]], msg)
[10:27:01.502]                       ex$message <- msg
[10:27:01.502]                       stop(ex)
[10:27:01.502]                     })
[10:27:01.502]                     stopifnot(file_test("-f", pathname_tmp))
[10:27:01.502]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:27:01.502]                     if (!res || file_test("-f", pathname_tmp)) {
[10:27:01.502]                       fi_tmp <- file.info(pathname_tmp)
[10:27:01.502]                       fi <- file.info(pathname)
[10:27:01.502]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:27:01.502]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:01.502]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:27:01.502]                         fi[["size"]], fi[["mtime"]])
[10:27:01.502]                       stop(msg)
[10:27:01.502]                     }
[10:27:01.502]                     invisible(pathname)
[10:27:01.502]                   }
[10:27:01.502]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:27:01.502]                     rootPath = tempdir()) 
[10:27:01.502]                   {
[10:27:01.502]                     obj <- list(time = Sys.time(), condition = cond)
[10:27:01.502]                     file <- tempfile(pattern = class(cond)[1], 
[10:27:01.502]                       tmpdir = path, fileext = ".rds")
[10:27:01.502]                     save_rds(obj, file)
[10:27:01.502]                   }
[10:27:01.502]                   saveImmediateCondition(cond, path = "/tmp/RtmpisxSDE/.future/immediateConditions")
[10:27:01.502]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:01.502]                   {
[10:27:01.502]                     inherits <- base::inherits
[10:27:01.502]                     invokeRestart <- base::invokeRestart
[10:27:01.502]                     is.null <- base::is.null
[10:27:01.502]                     muffled <- FALSE
[10:27:01.502]                     if (inherits(cond, "message")) {
[10:27:01.502]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:01.502]                       if (muffled) 
[10:27:01.502]                         invokeRestart("muffleMessage")
[10:27:01.502]                     }
[10:27:01.502]                     else if (inherits(cond, "warning")) {
[10:27:01.502]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:01.502]                       if (muffled) 
[10:27:01.502]                         invokeRestart("muffleWarning")
[10:27:01.502]                     }
[10:27:01.502]                     else if (inherits(cond, "condition")) {
[10:27:01.502]                       if (!is.null(pattern)) {
[10:27:01.502]                         computeRestarts <- base::computeRestarts
[10:27:01.502]                         grepl <- base::grepl
[10:27:01.502]                         restarts <- computeRestarts(cond)
[10:27:01.502]                         for (restart in restarts) {
[10:27:01.502]                           name <- restart$name
[10:27:01.502]                           if (is.null(name)) 
[10:27:01.502]                             next
[10:27:01.502]                           if (!grepl(pattern, name)) 
[10:27:01.502]                             next
[10:27:01.502]                           invokeRestart(restart)
[10:27:01.502]                           muffled <- TRUE
[10:27:01.502]                           break
[10:27:01.502]                         }
[10:27:01.502]                       }
[10:27:01.502]                     }
[10:27:01.502]                     invisible(muffled)
[10:27:01.502]                   }
[10:27:01.502]                   muffleCondition(cond)
[10:27:01.502]                 })
[10:27:01.502]             }))
[10:27:01.502]             future::FutureResult(value = ...future.value$value, 
[10:27:01.502]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:01.502]                   ...future.rng), globalenv = if (FALSE) 
[10:27:01.502]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:01.502]                     ...future.globalenv.names))
[10:27:01.502]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:01.502]         }, condition = base::local({
[10:27:01.502]             c <- base::c
[10:27:01.502]             inherits <- base::inherits
[10:27:01.502]             invokeRestart <- base::invokeRestart
[10:27:01.502]             length <- base::length
[10:27:01.502]             list <- base::list
[10:27:01.502]             seq.int <- base::seq.int
[10:27:01.502]             signalCondition <- base::signalCondition
[10:27:01.502]             sys.calls <- base::sys.calls
[10:27:01.502]             `[[` <- base::`[[`
[10:27:01.502]             `+` <- base::`+`
[10:27:01.502]             `<<-` <- base::`<<-`
[10:27:01.502]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:01.502]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:01.502]                   3L)]
[10:27:01.502]             }
[10:27:01.502]             function(cond) {
[10:27:01.502]                 is_error <- inherits(cond, "error")
[10:27:01.502]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:01.502]                   NULL)
[10:27:01.502]                 if (is_error) {
[10:27:01.502]                   sessionInformation <- function() {
[10:27:01.502]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:01.502]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:01.502]                       search = base::search(), system = base::Sys.info())
[10:27:01.502]                   }
[10:27:01.502]                   ...future.conditions[[length(...future.conditions) + 
[10:27:01.502]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:01.502]                     cond$call), session = sessionInformation(), 
[10:27:01.502]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:01.502]                   signalCondition(cond)
[10:27:01.502]                 }
[10:27:01.502]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:01.502]                 "immediateCondition"))) {
[10:27:01.502]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:01.502]                   ...future.conditions[[length(...future.conditions) + 
[10:27:01.502]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:01.502]                   if (TRUE && !signal) {
[10:27:01.502]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:01.502]                     {
[10:27:01.502]                       inherits <- base::inherits
[10:27:01.502]                       invokeRestart <- base::invokeRestart
[10:27:01.502]                       is.null <- base::is.null
[10:27:01.502]                       muffled <- FALSE
[10:27:01.502]                       if (inherits(cond, "message")) {
[10:27:01.502]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:01.502]                         if (muffled) 
[10:27:01.502]                           invokeRestart("muffleMessage")
[10:27:01.502]                       }
[10:27:01.502]                       else if (inherits(cond, "warning")) {
[10:27:01.502]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:01.502]                         if (muffled) 
[10:27:01.502]                           invokeRestart("muffleWarning")
[10:27:01.502]                       }
[10:27:01.502]                       else if (inherits(cond, "condition")) {
[10:27:01.502]                         if (!is.null(pattern)) {
[10:27:01.502]                           computeRestarts <- base::computeRestarts
[10:27:01.502]                           grepl <- base::grepl
[10:27:01.502]                           restarts <- computeRestarts(cond)
[10:27:01.502]                           for (restart in restarts) {
[10:27:01.502]                             name <- restart$name
[10:27:01.502]                             if (is.null(name)) 
[10:27:01.502]                               next
[10:27:01.502]                             if (!grepl(pattern, name)) 
[10:27:01.502]                               next
[10:27:01.502]                             invokeRestart(restart)
[10:27:01.502]                             muffled <- TRUE
[10:27:01.502]                             break
[10:27:01.502]                           }
[10:27:01.502]                         }
[10:27:01.502]                       }
[10:27:01.502]                       invisible(muffled)
[10:27:01.502]                     }
[10:27:01.502]                     muffleCondition(cond, pattern = "^muffle")
[10:27:01.502]                   }
[10:27:01.502]                 }
[10:27:01.502]                 else {
[10:27:01.502]                   if (TRUE) {
[10:27:01.502]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:01.502]                     {
[10:27:01.502]                       inherits <- base::inherits
[10:27:01.502]                       invokeRestart <- base::invokeRestart
[10:27:01.502]                       is.null <- base::is.null
[10:27:01.502]                       muffled <- FALSE
[10:27:01.502]                       if (inherits(cond, "message")) {
[10:27:01.502]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:01.502]                         if (muffled) 
[10:27:01.502]                           invokeRestart("muffleMessage")
[10:27:01.502]                       }
[10:27:01.502]                       else if (inherits(cond, "warning")) {
[10:27:01.502]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:01.502]                         if (muffled) 
[10:27:01.502]                           invokeRestart("muffleWarning")
[10:27:01.502]                       }
[10:27:01.502]                       else if (inherits(cond, "condition")) {
[10:27:01.502]                         if (!is.null(pattern)) {
[10:27:01.502]                           computeRestarts <- base::computeRestarts
[10:27:01.502]                           grepl <- base::grepl
[10:27:01.502]                           restarts <- computeRestarts(cond)
[10:27:01.502]                           for (restart in restarts) {
[10:27:01.502]                             name <- restart$name
[10:27:01.502]                             if (is.null(name)) 
[10:27:01.502]                               next
[10:27:01.502]                             if (!grepl(pattern, name)) 
[10:27:01.502]                               next
[10:27:01.502]                             invokeRestart(restart)
[10:27:01.502]                             muffled <- TRUE
[10:27:01.502]                             break
[10:27:01.502]                           }
[10:27:01.502]                         }
[10:27:01.502]                       }
[10:27:01.502]                       invisible(muffled)
[10:27:01.502]                     }
[10:27:01.502]                     muffleCondition(cond, pattern = "^muffle")
[10:27:01.502]                   }
[10:27:01.502]                 }
[10:27:01.502]             }
[10:27:01.502]         }))
[10:27:01.502]     }, error = function(ex) {
[10:27:01.502]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:01.502]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:01.502]                 ...future.rng), started = ...future.startTime, 
[10:27:01.502]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:01.502]             version = "1.8"), class = "FutureResult")
[10:27:01.502]     }, finally = {
[10:27:01.502]         if (!identical(...future.workdir, getwd())) 
[10:27:01.502]             setwd(...future.workdir)
[10:27:01.502]         {
[10:27:01.502]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:01.502]                 ...future.oldOptions$nwarnings <- NULL
[10:27:01.502]             }
[10:27:01.502]             base::options(...future.oldOptions)
[10:27:01.502]             if (.Platform$OS.type == "windows") {
[10:27:01.502]                 old_names <- names(...future.oldEnvVars)
[10:27:01.502]                 envs <- base::Sys.getenv()
[10:27:01.502]                 names <- names(envs)
[10:27:01.502]                 common <- intersect(names, old_names)
[10:27:01.502]                 added <- setdiff(names, old_names)
[10:27:01.502]                 removed <- setdiff(old_names, names)
[10:27:01.502]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:01.502]                   envs[common]]
[10:27:01.502]                 NAMES <- toupper(changed)
[10:27:01.502]                 args <- list()
[10:27:01.502]                 for (kk in seq_along(NAMES)) {
[10:27:01.502]                   name <- changed[[kk]]
[10:27:01.502]                   NAME <- NAMES[[kk]]
[10:27:01.502]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:01.502]                     next
[10:27:01.502]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:01.502]                 }
[10:27:01.502]                 NAMES <- toupper(added)
[10:27:01.502]                 for (kk in seq_along(NAMES)) {
[10:27:01.502]                   name <- added[[kk]]
[10:27:01.502]                   NAME <- NAMES[[kk]]
[10:27:01.502]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:01.502]                     next
[10:27:01.502]                   args[[name]] <- ""
[10:27:01.502]                 }
[10:27:01.502]                 NAMES <- toupper(removed)
[10:27:01.502]                 for (kk in seq_along(NAMES)) {
[10:27:01.502]                   name <- removed[[kk]]
[10:27:01.502]                   NAME <- NAMES[[kk]]
[10:27:01.502]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:01.502]                     next
[10:27:01.502]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:01.502]                 }
[10:27:01.502]                 if (length(args) > 0) 
[10:27:01.502]                   base::do.call(base::Sys.setenv, args = args)
[10:27:01.502]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:01.502]             }
[10:27:01.502]             else {
[10:27:01.502]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:01.502]             }
[10:27:01.502]             {
[10:27:01.502]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:01.502]                   0L) {
[10:27:01.502]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:01.502]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:01.502]                   base::options(opts)
[10:27:01.502]                 }
[10:27:01.502]                 {
[10:27:01.502]                   {
[10:27:01.502]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:01.502]                     NULL
[10:27:01.502]                   }
[10:27:01.502]                   options(future.plan = NULL)
[10:27:01.502]                   if (is.na(NA_character_)) 
[10:27:01.502]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:01.502]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:01.502]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:27:01.502]                     envir = parent.frame()) 
[10:27:01.502]                   {
[10:27:01.502]                     default_workers <- missing(workers)
[10:27:01.502]                     if (is.function(workers)) 
[10:27:01.502]                       workers <- workers()
[10:27:01.502]                     workers <- structure(as.integer(workers), 
[10:27:01.502]                       class = class(workers))
[10:27:01.502]                     stop_if_not(is.finite(workers), workers >= 
[10:27:01.502]                       1L)
[10:27:01.502]                     if ((workers == 1L && !inherits(workers, 
[10:27:01.502]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:27:01.502]                       if (default_workers) 
[10:27:01.502]                         supportsMulticore(warn = TRUE)
[10:27:01.502]                       return(sequential(..., envir = envir))
[10:27:01.502]                     }
[10:27:01.502]                     oopts <- options(mc.cores = workers)
[10:27:01.502]                     on.exit(options(oopts))
[10:27:01.502]                     future <- MulticoreFuture(..., workers = workers, 
[10:27:01.502]                       envir = envir)
[10:27:01.502]                     if (!future$lazy) 
[10:27:01.502]                       future <- run(future)
[10:27:01.502]                     invisible(future)
[10:27:01.502]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:01.502]                 }
[10:27:01.502]             }
[10:27:01.502]         }
[10:27:01.502]     })
[10:27:01.502]     if (TRUE) {
[10:27:01.502]         base::sink(type = "output", split = FALSE)
[10:27:01.502]         if (TRUE) {
[10:27:01.502]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:01.502]         }
[10:27:01.502]         else {
[10:27:01.502]             ...future.result["stdout"] <- base::list(NULL)
[10:27:01.502]         }
[10:27:01.502]         base::close(...future.stdout)
[10:27:01.502]         ...future.stdout <- NULL
[10:27:01.502]     }
[10:27:01.502]     ...future.result$conditions <- ...future.conditions
[10:27:01.502]     ...future.result$finished <- base::Sys.time()
[10:27:01.502]     ...future.result
[10:27:01.502] }
[10:27:01.505] requestCore(): workers = 2
[10:27:01.506] Poll #1 (0): usedCores() = 2, workers = 2
[10:27:01.517] result() for MulticoreFuture ...
[10:27:01.519] result() for MulticoreFuture ...
[10:27:01.519] result() for MulticoreFuture ... done
[10:27:01.520] result() for MulticoreFuture ... done
[10:27:01.520] result() for MulticoreFuture ...
[10:27:01.520] result() for MulticoreFuture ... done
[10:27:01.523] MulticoreFuture started
[10:27:01.524] - Launch lazy future ... done
[10:27:01.524] run() for ‘MulticoreFuture’ ... done
[10:27:01.524] resolve() on list ...
[10:27:01.524]  recursive: 0
[10:27:01.525]  length: 3
[10:27:01.525]  elements: ‘a’, ‘b’, ‘’
[10:27:01.525] plan(): Setting new future strategy stack:
[10:27:01.525] run() for ‘Future’ ...
[10:27:01.525] - state: ‘created’
[10:27:01.526] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:27:01.525] List of future strategies:
[10:27:01.525] 1. sequential:
[10:27:01.525]    - args: function (..., envir = parent.frame())
[10:27:01.525]    - tweaked: FALSE
[10:27:01.525]    - call: NULL
[10:27:01.526] plan(): nbrOfWorkers() = 1
[10:27:01.529] plan(): Setting new future strategy stack:
[10:27:01.529] List of future strategies:
[10:27:01.529] 1. multicore:
[10:27:01.529]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:27:01.529]    - tweaked: FALSE
[10:27:01.529]    - call: plan(strategy)
[10:27:01.532] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:01.532] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:27:01.532]   - Field: ‘label’
[10:27:01.532]   - Field: ‘local’
[10:27:01.532]   - Field: ‘owner’
[10:27:01.533]   - Field: ‘envir’
[10:27:01.533]   - Field: ‘workers’
[10:27:01.533]   - Field: ‘packages’
[10:27:01.533]   - Field: ‘gc’
[10:27:01.533]   - Field: ‘job’
[10:27:01.533]   - Field: ‘conditions’
[10:27:01.534] plan(): nbrOfWorkers() = 2
[10:27:01.534]   - Field: ‘expr’
[10:27:01.534]   - Field: ‘uuid’
[10:27:01.534]   - Field: ‘seed’
[10:27:01.534]   - Field: ‘version’
[10:27:01.534]   - Field: ‘result’
[10:27:01.534]   - Field: ‘asynchronous’
[10:27:01.535]   - Field: ‘calls’
[10:27:01.535]   - Field: ‘globals’
[10:27:01.535]   - Field: ‘stdout’
[10:27:01.535]   - Field: ‘earlySignal’
[10:27:01.535]   - Field: ‘lazy’
[10:27:01.535]   - Field: ‘state’
[10:27:01.535] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:27:01.536] - Launch lazy future ...
[10:27:01.536] Packages needed by the future expression (n = 0): <none>
[10:27:01.536] Packages needed by future strategies (n = 0): <none>
[10:27:01.537] {
[10:27:01.537]     {
[10:27:01.537]         {
[10:27:01.537]             ...future.startTime <- base::Sys.time()
[10:27:01.537]             {
[10:27:01.537]                 {
[10:27:01.537]                   {
[10:27:01.537]                     {
[10:27:01.537]                       base::local({
[10:27:01.537]                         has_future <- base::requireNamespace("future", 
[10:27:01.537]                           quietly = TRUE)
[10:27:01.537]                         if (has_future) {
[10:27:01.537]                           ns <- base::getNamespace("future")
[10:27:01.537]                           version <- ns[[".package"]][["version"]]
[10:27:01.537]                           if (is.null(version)) 
[10:27:01.537]                             version <- utils::packageVersion("future")
[10:27:01.537]                         }
[10:27:01.537]                         else {
[10:27:01.537]                           version <- NULL
[10:27:01.537]                         }
[10:27:01.537]                         if (!has_future || version < "1.8.0") {
[10:27:01.537]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:01.537]                             "", base::R.version$version.string), 
[10:27:01.537]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:01.537]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:01.537]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:01.537]                               "release", "version")], collapse = " "), 
[10:27:01.537]                             hostname = base::Sys.info()[["nodename"]])
[10:27:01.537]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:01.537]                             info)
[10:27:01.537]                           info <- base::paste(info, collapse = "; ")
[10:27:01.537]                           if (!has_future) {
[10:27:01.537]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:01.537]                               info)
[10:27:01.537]                           }
[10:27:01.537]                           else {
[10:27:01.537]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:01.537]                               info, version)
[10:27:01.537]                           }
[10:27:01.537]                           base::stop(msg)
[10:27:01.537]                         }
[10:27:01.537]                       })
[10:27:01.537]                     }
[10:27:01.537]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:01.537]                     base::options(mc.cores = 1L)
[10:27:01.537]                   }
[10:27:01.537]                   options(future.plan = NULL)
[10:27:01.537]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:01.537]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:01.537]                 }
[10:27:01.537]                 ...future.workdir <- getwd()
[10:27:01.537]             }
[10:27:01.537]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:01.537]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:01.537]         }
[10:27:01.537]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:01.537]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:01.537]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:01.537]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:01.537]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:01.537]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:01.537]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:01.537]             base::names(...future.oldOptions))
[10:27:01.537]     }
[10:27:01.537]     if (FALSE) {
[10:27:01.537]     }
[10:27:01.537]     else {
[10:27:01.537]         if (TRUE) {
[10:27:01.537]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:01.537]                 open = "w")
[10:27:01.537]         }
[10:27:01.537]         else {
[10:27:01.537]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:01.537]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:01.537]         }
[10:27:01.537]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:01.537]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:01.537]             base::sink(type = "output", split = FALSE)
[10:27:01.537]             base::close(...future.stdout)
[10:27:01.537]         }, add = TRUE)
[10:27:01.537]     }
[10:27:01.537]     ...future.frame <- base::sys.nframe()
[10:27:01.537]     ...future.conditions <- base::list()
[10:27:01.537]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:01.537]     if (FALSE) {
[10:27:01.537]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:01.537]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:01.537]     }
[10:27:01.537]     ...future.result <- base::tryCatch({
[10:27:01.537]         base::withCallingHandlers({
[10:27:01.537]             ...future.value <- base::withVisible(base::local({
[10:27:01.537]                 withCallingHandlers({
[10:27:01.537]                   1
[10:27:01.537]                 }, immediateCondition = function(cond) {
[10:27:01.537]                   save_rds <- function (object, pathname, ...) 
[10:27:01.537]                   {
[10:27:01.537]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:27:01.537]                     if (file_test("-f", pathname_tmp)) {
[10:27:01.537]                       fi_tmp <- file.info(pathname_tmp)
[10:27:01.537]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:27:01.537]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:01.537]                         fi_tmp[["mtime"]])
[10:27:01.537]                     }
[10:27:01.537]                     tryCatch({
[10:27:01.537]                       saveRDS(object, file = pathname_tmp, ...)
[10:27:01.537]                     }, error = function(ex) {
[10:27:01.537]                       msg <- conditionMessage(ex)
[10:27:01.537]                       fi_tmp <- file.info(pathname_tmp)
[10:27:01.537]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:27:01.537]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:01.537]                         fi_tmp[["mtime"]], msg)
[10:27:01.537]                       ex$message <- msg
[10:27:01.537]                       stop(ex)
[10:27:01.537]                     })
[10:27:01.537]                     stopifnot(file_test("-f", pathname_tmp))
[10:27:01.537]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:27:01.537]                     if (!res || file_test("-f", pathname_tmp)) {
[10:27:01.537]                       fi_tmp <- file.info(pathname_tmp)
[10:27:01.537]                       fi <- file.info(pathname)
[10:27:01.537]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:27:01.537]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:01.537]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:27:01.537]                         fi[["size"]], fi[["mtime"]])
[10:27:01.537]                       stop(msg)
[10:27:01.537]                     }
[10:27:01.537]                     invisible(pathname)
[10:27:01.537]                   }
[10:27:01.537]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:27:01.537]                     rootPath = tempdir()) 
[10:27:01.537]                   {
[10:27:01.537]                     obj <- list(time = Sys.time(), condition = cond)
[10:27:01.537]                     file <- tempfile(pattern = class(cond)[1], 
[10:27:01.537]                       tmpdir = path, fileext = ".rds")
[10:27:01.537]                     save_rds(obj, file)
[10:27:01.537]                   }
[10:27:01.537]                   saveImmediateCondition(cond, path = "/tmp/RtmpisxSDE/.future/immediateConditions")
[10:27:01.537]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:01.537]                   {
[10:27:01.537]                     inherits <- base::inherits
[10:27:01.537]                     invokeRestart <- base::invokeRestart
[10:27:01.537]                     is.null <- base::is.null
[10:27:01.537]                     muffled <- FALSE
[10:27:01.537]                     if (inherits(cond, "message")) {
[10:27:01.537]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:01.537]                       if (muffled) 
[10:27:01.537]                         invokeRestart("muffleMessage")
[10:27:01.537]                     }
[10:27:01.537]                     else if (inherits(cond, "warning")) {
[10:27:01.537]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:01.537]                       if (muffled) 
[10:27:01.537]                         invokeRestart("muffleWarning")
[10:27:01.537]                     }
[10:27:01.537]                     else if (inherits(cond, "condition")) {
[10:27:01.537]                       if (!is.null(pattern)) {
[10:27:01.537]                         computeRestarts <- base::computeRestarts
[10:27:01.537]                         grepl <- base::grepl
[10:27:01.537]                         restarts <- computeRestarts(cond)
[10:27:01.537]                         for (restart in restarts) {
[10:27:01.537]                           name <- restart$name
[10:27:01.537]                           if (is.null(name)) 
[10:27:01.537]                             next
[10:27:01.537]                           if (!grepl(pattern, name)) 
[10:27:01.537]                             next
[10:27:01.537]                           invokeRestart(restart)
[10:27:01.537]                           muffled <- TRUE
[10:27:01.537]                           break
[10:27:01.537]                         }
[10:27:01.537]                       }
[10:27:01.537]                     }
[10:27:01.537]                     invisible(muffled)
[10:27:01.537]                   }
[10:27:01.537]                   muffleCondition(cond)
[10:27:01.537]                 })
[10:27:01.537]             }))
[10:27:01.537]             future::FutureResult(value = ...future.value$value, 
[10:27:01.537]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:01.537]                   ...future.rng), globalenv = if (FALSE) 
[10:27:01.537]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:01.537]                     ...future.globalenv.names))
[10:27:01.537]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:01.537]         }, condition = base::local({
[10:27:01.537]             c <- base::c
[10:27:01.537]             inherits <- base::inherits
[10:27:01.537]             invokeRestart <- base::invokeRestart
[10:27:01.537]             length <- base::length
[10:27:01.537]             list <- base::list
[10:27:01.537]             seq.int <- base::seq.int
[10:27:01.537]             signalCondition <- base::signalCondition
[10:27:01.537]             sys.calls <- base::sys.calls
[10:27:01.537]             `[[` <- base::`[[`
[10:27:01.537]             `+` <- base::`+`
[10:27:01.537]             `<<-` <- base::`<<-`
[10:27:01.537]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:01.537]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:01.537]                   3L)]
[10:27:01.537]             }
[10:27:01.537]             function(cond) {
[10:27:01.537]                 is_error <- inherits(cond, "error")
[10:27:01.537]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:01.537]                   NULL)
[10:27:01.537]                 if (is_error) {
[10:27:01.537]                   sessionInformation <- function() {
[10:27:01.537]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:01.537]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:01.537]                       search = base::search(), system = base::Sys.info())
[10:27:01.537]                   }
[10:27:01.537]                   ...future.conditions[[length(...future.conditions) + 
[10:27:01.537]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:01.537]                     cond$call), session = sessionInformation(), 
[10:27:01.537]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:01.537]                   signalCondition(cond)
[10:27:01.537]                 }
[10:27:01.537]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:01.537]                 "immediateCondition"))) {
[10:27:01.537]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:01.537]                   ...future.conditions[[length(...future.conditions) + 
[10:27:01.537]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:01.537]                   if (TRUE && !signal) {
[10:27:01.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:01.537]                     {
[10:27:01.537]                       inherits <- base::inherits
[10:27:01.537]                       invokeRestart <- base::invokeRestart
[10:27:01.537]                       is.null <- base::is.null
[10:27:01.537]                       muffled <- FALSE
[10:27:01.537]                       if (inherits(cond, "message")) {
[10:27:01.537]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:01.537]                         if (muffled) 
[10:27:01.537]                           invokeRestart("muffleMessage")
[10:27:01.537]                       }
[10:27:01.537]                       else if (inherits(cond, "warning")) {
[10:27:01.537]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:01.537]                         if (muffled) 
[10:27:01.537]                           invokeRestart("muffleWarning")
[10:27:01.537]                       }
[10:27:01.537]                       else if (inherits(cond, "condition")) {
[10:27:01.537]                         if (!is.null(pattern)) {
[10:27:01.537]                           computeRestarts <- base::computeRestarts
[10:27:01.537]                           grepl <- base::grepl
[10:27:01.537]                           restarts <- computeRestarts(cond)
[10:27:01.537]                           for (restart in restarts) {
[10:27:01.537]                             name <- restart$name
[10:27:01.537]                             if (is.null(name)) 
[10:27:01.537]                               next
[10:27:01.537]                             if (!grepl(pattern, name)) 
[10:27:01.537]                               next
[10:27:01.537]                             invokeRestart(restart)
[10:27:01.537]                             muffled <- TRUE
[10:27:01.537]                             break
[10:27:01.537]                           }
[10:27:01.537]                         }
[10:27:01.537]                       }
[10:27:01.537]                       invisible(muffled)
[10:27:01.537]                     }
[10:27:01.537]                     muffleCondition(cond, pattern = "^muffle")
[10:27:01.537]                   }
[10:27:01.537]                 }
[10:27:01.537]                 else {
[10:27:01.537]                   if (TRUE) {
[10:27:01.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:01.537]                     {
[10:27:01.537]                       inherits <- base::inherits
[10:27:01.537]                       invokeRestart <- base::invokeRestart
[10:27:01.537]                       is.null <- base::is.null
[10:27:01.537]                       muffled <- FALSE
[10:27:01.537]                       if (inherits(cond, "message")) {
[10:27:01.537]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:01.537]                         if (muffled) 
[10:27:01.537]                           invokeRestart("muffleMessage")
[10:27:01.537]                       }
[10:27:01.537]                       else if (inherits(cond, "warning")) {
[10:27:01.537]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:01.537]                         if (muffled) 
[10:27:01.537]                           invokeRestart("muffleWarning")
[10:27:01.537]                       }
[10:27:01.537]                       else if (inherits(cond, "condition")) {
[10:27:01.537]                         if (!is.null(pattern)) {
[10:27:01.537]                           computeRestarts <- base::computeRestarts
[10:27:01.537]                           grepl <- base::grepl
[10:27:01.537]                           restarts <- computeRestarts(cond)
[10:27:01.537]                           for (restart in restarts) {
[10:27:01.537]                             name <- restart$name
[10:27:01.537]                             if (is.null(name)) 
[10:27:01.537]                               next
[10:27:01.537]                             if (!grepl(pattern, name)) 
[10:27:01.537]                               next
[10:27:01.537]                             invokeRestart(restart)
[10:27:01.537]                             muffled <- TRUE
[10:27:01.537]                             break
[10:27:01.537]                           }
[10:27:01.537]                         }
[10:27:01.537]                       }
[10:27:01.537]                       invisible(muffled)
[10:27:01.537]                     }
[10:27:01.537]                     muffleCondition(cond, pattern = "^muffle")
[10:27:01.537]                   }
[10:27:01.537]                 }
[10:27:01.537]             }
[10:27:01.537]         }))
[10:27:01.537]     }, error = function(ex) {
[10:27:01.537]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:01.537]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:01.537]                 ...future.rng), started = ...future.startTime, 
[10:27:01.537]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:01.537]             version = "1.8"), class = "FutureResult")
[10:27:01.537]     }, finally = {
[10:27:01.537]         if (!identical(...future.workdir, getwd())) 
[10:27:01.537]             setwd(...future.workdir)
[10:27:01.537]         {
[10:27:01.537]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:01.537]                 ...future.oldOptions$nwarnings <- NULL
[10:27:01.537]             }
[10:27:01.537]             base::options(...future.oldOptions)
[10:27:01.537]             if (.Platform$OS.type == "windows") {
[10:27:01.537]                 old_names <- names(...future.oldEnvVars)
[10:27:01.537]                 envs <- base::Sys.getenv()
[10:27:01.537]                 names <- names(envs)
[10:27:01.537]                 common <- intersect(names, old_names)
[10:27:01.537]                 added <- setdiff(names, old_names)
[10:27:01.537]                 removed <- setdiff(old_names, names)
[10:27:01.537]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:01.537]                   envs[common]]
[10:27:01.537]                 NAMES <- toupper(changed)
[10:27:01.537]                 args <- list()
[10:27:01.537]                 for (kk in seq_along(NAMES)) {
[10:27:01.537]                   name <- changed[[kk]]
[10:27:01.537]                   NAME <- NAMES[[kk]]
[10:27:01.537]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:01.537]                     next
[10:27:01.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:01.537]                 }
[10:27:01.537]                 NAMES <- toupper(added)
[10:27:01.537]                 for (kk in seq_along(NAMES)) {
[10:27:01.537]                   name <- added[[kk]]
[10:27:01.537]                   NAME <- NAMES[[kk]]
[10:27:01.537]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:01.537]                     next
[10:27:01.537]                   args[[name]] <- ""
[10:27:01.537]                 }
[10:27:01.537]                 NAMES <- toupper(removed)
[10:27:01.537]                 for (kk in seq_along(NAMES)) {
[10:27:01.537]                   name <- removed[[kk]]
[10:27:01.537]                   NAME <- NAMES[[kk]]
[10:27:01.537]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:01.537]                     next
[10:27:01.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:01.537]                 }
[10:27:01.537]                 if (length(args) > 0) 
[10:27:01.537]                   base::do.call(base::Sys.setenv, args = args)
[10:27:01.537]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:01.537]             }
[10:27:01.537]             else {
[10:27:01.537]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:01.537]             }
[10:27:01.537]             {
[10:27:01.537]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:01.537]                   0L) {
[10:27:01.537]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:01.537]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:01.537]                   base::options(opts)
[10:27:01.537]                 }
[10:27:01.537]                 {
[10:27:01.537]                   {
[10:27:01.537]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:01.537]                     NULL
[10:27:01.537]                   }
[10:27:01.537]                   options(future.plan = NULL)
[10:27:01.537]                   if (is.na(NA_character_)) 
[10:27:01.537]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:01.537]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:01.537]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:27:01.537]                     envir = parent.frame()) 
[10:27:01.537]                   {
[10:27:01.537]                     default_workers <- missing(workers)
[10:27:01.537]                     if (is.function(workers)) 
[10:27:01.537]                       workers <- workers()
[10:27:01.537]                     workers <- structure(as.integer(workers), 
[10:27:01.537]                       class = class(workers))
[10:27:01.537]                     stop_if_not(is.finite(workers), workers >= 
[10:27:01.537]                       1L)
[10:27:01.537]                     if ((workers == 1L && !inherits(workers, 
[10:27:01.537]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:27:01.537]                       if (default_workers) 
[10:27:01.537]                         supportsMulticore(warn = TRUE)
[10:27:01.537]                       return(sequential(..., envir = envir))
[10:27:01.537]                     }
[10:27:01.537]                     oopts <- options(mc.cores = workers)
[10:27:01.537]                     on.exit(options(oopts))
[10:27:01.537]                     future <- MulticoreFuture(..., workers = workers, 
[10:27:01.537]                       envir = envir)
[10:27:01.537]                     if (!future$lazy) 
[10:27:01.537]                       future <- run(future)
[10:27:01.537]                     invisible(future)
[10:27:01.537]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:01.537]                 }
[10:27:01.537]             }
[10:27:01.537]         }
[10:27:01.537]     })
[10:27:01.537]     if (TRUE) {
[10:27:01.537]         base::sink(type = "output", split = FALSE)
[10:27:01.537]         if (TRUE) {
[10:27:01.537]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:01.537]         }
[10:27:01.537]         else {
[10:27:01.537]             ...future.result["stdout"] <- base::list(NULL)
[10:27:01.537]         }
[10:27:01.537]         base::close(...future.stdout)
[10:27:01.537]         ...future.stdout <- NULL
[10:27:01.537]     }
[10:27:01.537]     ...future.result$conditions <- ...future.conditions
[10:27:01.537]     ...future.result$finished <- base::Sys.time()
[10:27:01.537]     ...future.result
[10:27:01.537] }
[10:27:01.541] requestCore(): workers = 2
[10:27:01.542] Poll #1 (0): usedCores() = 2, workers = 2
[10:27:01.566] result() for MulticoreFuture ...
[10:27:01.567] result() for MulticoreFuture ...
[10:27:01.567] result() for MulticoreFuture ... done
[10:27:01.567] result() for MulticoreFuture ... done
[10:27:01.568] result() for MulticoreFuture ...
[10:27:01.568] result() for MulticoreFuture ... done
[10:27:01.570] MulticoreFuture started
[10:27:01.571] - Launch lazy future ... done
[10:27:01.571] run() for ‘MulticoreFuture’ ... done
[10:27:01.572] plan(): Setting new future strategy stack:
[10:27:01.572] List of future strategies:
[10:27:01.572] 1. sequential:
[10:27:01.572]    - args: function (..., envir = parent.frame())
[10:27:01.572]    - tweaked: FALSE
[10:27:01.572]    - call: NULL
[10:27:01.573] plan(): nbrOfWorkers() = 1
[10:27:01.575] plan(): Setting new future strategy stack:
[10:27:01.575] List of future strategies:
[10:27:01.575] 1. multicore:
[10:27:01.575]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:27:01.575]    - tweaked: FALSE
[10:27:01.575]    - call: plan(strategy)
[10:27:01.582] Future #2
[10:27:01.583]  length: 2 (resolved future 2)
[10:27:01.583]  length: 1 (resolved future 3)
[10:27:01.589] plan(): nbrOfWorkers() = 2
[10:27:01.594] Future #1
[10:27:01.594]  length: 0 (resolved future 1)
[10:27:01.594] resolve() on list ... DONE
[10:27:01.595] getGlobalsAndPackages() ...
[10:27:01.599] Searching for globals...
[10:27:01.600] 
[10:27:01.600] Searching for globals ... DONE
[10:27:01.601] - globals: [0] <none>
[10:27:01.601] getGlobalsAndPackages() ... DONE
[10:27:01.602] getGlobalsAndPackages() ...
[10:27:01.602] Searching for globals...
[10:27:01.603] 
[10:27:01.603] Searching for globals ... DONE
[10:27:01.603] - globals: [0] <none>
[10:27:01.604] getGlobalsAndPackages() ... DONE
[10:27:01.604] resolve() on list ...
[10:27:01.604]  recursive: 0
[10:27:01.604]  length: 3
[10:27:01.605]  elements: ‘a’, ‘b’, ‘’
[10:27:01.605] run() for ‘Future’ ...
[10:27:01.605] - state: ‘created’
[10:27:01.605] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:27:01.610] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:01.610] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:27:01.610]   - Field: ‘label’
[10:27:01.611]   - Field: ‘local’
[10:27:01.611]   - Field: ‘owner’
[10:27:01.611]   - Field: ‘envir’
[10:27:01.611]   - Field: ‘workers’
[10:27:01.612]   - Field: ‘packages’
[10:27:01.612]   - Field: ‘gc’
[10:27:01.612]   - Field: ‘job’
[10:27:01.612]   - Field: ‘conditions’
[10:27:01.612]   - Field: ‘expr’
[10:27:01.612]   - Field: ‘uuid’
[10:27:01.613]   - Field: ‘seed’
[10:27:01.613]   - Field: ‘version’
[10:27:01.613]   - Field: ‘result’
[10:27:01.613]   - Field: ‘asynchronous’
[10:27:01.613]   - Field: ‘calls’
[10:27:01.613]   - Field: ‘globals’
[10:27:01.613]   - Field: ‘stdout’
[10:27:01.614]   - Field: ‘earlySignal’
[10:27:01.614]   - Field: ‘lazy’
[10:27:01.614]   - Field: ‘state’
[10:27:01.614] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:27:01.614] - Launch lazy future ...
[10:27:01.615] Packages needed by the future expression (n = 0): <none>
[10:27:01.615] Packages needed by future strategies (n = 0): <none>
[10:27:01.615] {
[10:27:01.615]     {
[10:27:01.615]         {
[10:27:01.615]             ...future.startTime <- base::Sys.time()
[10:27:01.615]             {
[10:27:01.615]                 {
[10:27:01.615]                   {
[10:27:01.615]                     {
[10:27:01.615]                       base::local({
[10:27:01.615]                         has_future <- base::requireNamespace("future", 
[10:27:01.615]                           quietly = TRUE)
[10:27:01.615]                         if (has_future) {
[10:27:01.615]                           ns <- base::getNamespace("future")
[10:27:01.615]                           version <- ns[[".package"]][["version"]]
[10:27:01.615]                           if (is.null(version)) 
[10:27:01.615]                             version <- utils::packageVersion("future")
[10:27:01.615]                         }
[10:27:01.615]                         else {
[10:27:01.615]                           version <- NULL
[10:27:01.615]                         }
[10:27:01.615]                         if (!has_future || version < "1.8.0") {
[10:27:01.615]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:01.615]                             "", base::R.version$version.string), 
[10:27:01.615]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:01.615]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:01.615]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:01.615]                               "release", "version")], collapse = " "), 
[10:27:01.615]                             hostname = base::Sys.info()[["nodename"]])
[10:27:01.615]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:01.615]                             info)
[10:27:01.615]                           info <- base::paste(info, collapse = "; ")
[10:27:01.615]                           if (!has_future) {
[10:27:01.615]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:01.615]                               info)
[10:27:01.615]                           }
[10:27:01.615]                           else {
[10:27:01.615]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:01.615]                               info, version)
[10:27:01.615]                           }
[10:27:01.615]                           base::stop(msg)
[10:27:01.615]                         }
[10:27:01.615]                       })
[10:27:01.615]                     }
[10:27:01.615]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:01.615]                     base::options(mc.cores = 1L)
[10:27:01.615]                   }
[10:27:01.615]                   options(future.plan = NULL)
[10:27:01.615]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:01.615]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:01.615]                 }
[10:27:01.615]                 ...future.workdir <- getwd()
[10:27:01.615]             }
[10:27:01.615]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:01.615]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:01.615]         }
[10:27:01.615]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:01.615]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:01.615]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:01.615]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:01.615]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:01.615]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:01.615]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:01.615]             base::names(...future.oldOptions))
[10:27:01.615]     }
[10:27:01.615]     if (FALSE) {
[10:27:01.615]     }
[10:27:01.615]     else {
[10:27:01.615]         if (TRUE) {
[10:27:01.615]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:01.615]                 open = "w")
[10:27:01.615]         }
[10:27:01.615]         else {
[10:27:01.615]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:01.615]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:01.615]         }
[10:27:01.615]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:01.615]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:01.615]             base::sink(type = "output", split = FALSE)
[10:27:01.615]             base::close(...future.stdout)
[10:27:01.615]         }, add = TRUE)
[10:27:01.615]     }
[10:27:01.615]     ...future.frame <- base::sys.nframe()
[10:27:01.615]     ...future.conditions <- base::list()
[10:27:01.615]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:01.615]     if (FALSE) {
[10:27:01.615]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:01.615]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:01.615]     }
[10:27:01.615]     ...future.result <- base::tryCatch({
[10:27:01.615]         base::withCallingHandlers({
[10:27:01.615]             ...future.value <- base::withVisible(base::local({
[10:27:01.615]                 withCallingHandlers({
[10:27:01.615]                   1
[10:27:01.615]                 }, immediateCondition = function(cond) {
[10:27:01.615]                   save_rds <- function (object, pathname, ...) 
[10:27:01.615]                   {
[10:27:01.615]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:27:01.615]                     if (file_test("-f", pathname_tmp)) {
[10:27:01.615]                       fi_tmp <- file.info(pathname_tmp)
[10:27:01.615]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:27:01.615]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:01.615]                         fi_tmp[["mtime"]])
[10:27:01.615]                     }
[10:27:01.615]                     tryCatch({
[10:27:01.615]                       saveRDS(object, file = pathname_tmp, ...)
[10:27:01.615]                     }, error = function(ex) {
[10:27:01.615]                       msg <- conditionMessage(ex)
[10:27:01.615]                       fi_tmp <- file.info(pathname_tmp)
[10:27:01.615]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:27:01.615]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:01.615]                         fi_tmp[["mtime"]], msg)
[10:27:01.615]                       ex$message <- msg
[10:27:01.615]                       stop(ex)
[10:27:01.615]                     })
[10:27:01.615]                     stopifnot(file_test("-f", pathname_tmp))
[10:27:01.615]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:27:01.615]                     if (!res || file_test("-f", pathname_tmp)) {
[10:27:01.615]                       fi_tmp <- file.info(pathname_tmp)
[10:27:01.615]                       fi <- file.info(pathname)
[10:27:01.615]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:27:01.615]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:01.615]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:27:01.615]                         fi[["size"]], fi[["mtime"]])
[10:27:01.615]                       stop(msg)
[10:27:01.615]                     }
[10:27:01.615]                     invisible(pathname)
[10:27:01.615]                   }
[10:27:01.615]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:27:01.615]                     rootPath = tempdir()) 
[10:27:01.615]                   {
[10:27:01.615]                     obj <- list(time = Sys.time(), condition = cond)
[10:27:01.615]                     file <- tempfile(pattern = class(cond)[1], 
[10:27:01.615]                       tmpdir = path, fileext = ".rds")
[10:27:01.615]                     save_rds(obj, file)
[10:27:01.615]                   }
[10:27:01.615]                   saveImmediateCondition(cond, path = "/tmp/RtmpisxSDE/.future/immediateConditions")
[10:27:01.615]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:01.615]                   {
[10:27:01.615]                     inherits <- base::inherits
[10:27:01.615]                     invokeRestart <- base::invokeRestart
[10:27:01.615]                     is.null <- base::is.null
[10:27:01.615]                     muffled <- FALSE
[10:27:01.615]                     if (inherits(cond, "message")) {
[10:27:01.615]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:01.615]                       if (muffled) 
[10:27:01.615]                         invokeRestart("muffleMessage")
[10:27:01.615]                     }
[10:27:01.615]                     else if (inherits(cond, "warning")) {
[10:27:01.615]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:01.615]                       if (muffled) 
[10:27:01.615]                         invokeRestart("muffleWarning")
[10:27:01.615]                     }
[10:27:01.615]                     else if (inherits(cond, "condition")) {
[10:27:01.615]                       if (!is.null(pattern)) {
[10:27:01.615]                         computeRestarts <- base::computeRestarts
[10:27:01.615]                         grepl <- base::grepl
[10:27:01.615]                         restarts <- computeRestarts(cond)
[10:27:01.615]                         for (restart in restarts) {
[10:27:01.615]                           name <- restart$name
[10:27:01.615]                           if (is.null(name)) 
[10:27:01.615]                             next
[10:27:01.615]                           if (!grepl(pattern, name)) 
[10:27:01.615]                             next
[10:27:01.615]                           invokeRestart(restart)
[10:27:01.615]                           muffled <- TRUE
[10:27:01.615]                           break
[10:27:01.615]                         }
[10:27:01.615]                       }
[10:27:01.615]                     }
[10:27:01.615]                     invisible(muffled)
[10:27:01.615]                   }
[10:27:01.615]                   muffleCondition(cond)
[10:27:01.615]                 })
[10:27:01.615]             }))
[10:27:01.615]             future::FutureResult(value = ...future.value$value, 
[10:27:01.615]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:01.615]                   ...future.rng), globalenv = if (FALSE) 
[10:27:01.615]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:01.615]                     ...future.globalenv.names))
[10:27:01.615]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:01.615]         }, condition = base::local({
[10:27:01.615]             c <- base::c
[10:27:01.615]             inherits <- base::inherits
[10:27:01.615]             invokeRestart <- base::invokeRestart
[10:27:01.615]             length <- base::length
[10:27:01.615]             list <- base::list
[10:27:01.615]             seq.int <- base::seq.int
[10:27:01.615]             signalCondition <- base::signalCondition
[10:27:01.615]             sys.calls <- base::sys.calls
[10:27:01.615]             `[[` <- base::`[[`
[10:27:01.615]             `+` <- base::`+`
[10:27:01.615]             `<<-` <- base::`<<-`
[10:27:01.615]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:01.615]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:01.615]                   3L)]
[10:27:01.615]             }
[10:27:01.615]             function(cond) {
[10:27:01.615]                 is_error <- inherits(cond, "error")
[10:27:01.615]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:01.615]                   NULL)
[10:27:01.615]                 if (is_error) {
[10:27:01.615]                   sessionInformation <- function() {
[10:27:01.615]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:01.615]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:01.615]                       search = base::search(), system = base::Sys.info())
[10:27:01.615]                   }
[10:27:01.615]                   ...future.conditions[[length(...future.conditions) + 
[10:27:01.615]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:01.615]                     cond$call), session = sessionInformation(), 
[10:27:01.615]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:01.615]                   signalCondition(cond)
[10:27:01.615]                 }
[10:27:01.615]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:01.615]                 "immediateCondition"))) {
[10:27:01.615]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:01.615]                   ...future.conditions[[length(...future.conditions) + 
[10:27:01.615]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:01.615]                   if (TRUE && !signal) {
[10:27:01.615]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:01.615]                     {
[10:27:01.615]                       inherits <- base::inherits
[10:27:01.615]                       invokeRestart <- base::invokeRestart
[10:27:01.615]                       is.null <- base::is.null
[10:27:01.615]                       muffled <- FALSE
[10:27:01.615]                       if (inherits(cond, "message")) {
[10:27:01.615]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:01.615]                         if (muffled) 
[10:27:01.615]                           invokeRestart("muffleMessage")
[10:27:01.615]                       }
[10:27:01.615]                       else if (inherits(cond, "warning")) {
[10:27:01.615]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:01.615]                         if (muffled) 
[10:27:01.615]                           invokeRestart("muffleWarning")
[10:27:01.615]                       }
[10:27:01.615]                       else if (inherits(cond, "condition")) {
[10:27:01.615]                         if (!is.null(pattern)) {
[10:27:01.615]                           computeRestarts <- base::computeRestarts
[10:27:01.615]                           grepl <- base::grepl
[10:27:01.615]                           restarts <- computeRestarts(cond)
[10:27:01.615]                           for (restart in restarts) {
[10:27:01.615]                             name <- restart$name
[10:27:01.615]                             if (is.null(name)) 
[10:27:01.615]                               next
[10:27:01.615]                             if (!grepl(pattern, name)) 
[10:27:01.615]                               next
[10:27:01.615]                             invokeRestart(restart)
[10:27:01.615]                             muffled <- TRUE
[10:27:01.615]                             break
[10:27:01.615]                           }
[10:27:01.615]                         }
[10:27:01.615]                       }
[10:27:01.615]                       invisible(muffled)
[10:27:01.615]                     }
[10:27:01.615]                     muffleCondition(cond, pattern = "^muffle")
[10:27:01.615]                   }
[10:27:01.615]                 }
[10:27:01.615]                 else {
[10:27:01.615]                   if (TRUE) {
[10:27:01.615]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:01.615]                     {
[10:27:01.615]                       inherits <- base::inherits
[10:27:01.615]                       invokeRestart <- base::invokeRestart
[10:27:01.615]                       is.null <- base::is.null
[10:27:01.615]                       muffled <- FALSE
[10:27:01.615]                       if (inherits(cond, "message")) {
[10:27:01.615]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:01.615]                         if (muffled) 
[10:27:01.615]                           invokeRestart("muffleMessage")
[10:27:01.615]                       }
[10:27:01.615]                       else if (inherits(cond, "warning")) {
[10:27:01.615]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:01.615]                         if (muffled) 
[10:27:01.615]                           invokeRestart("muffleWarning")
[10:27:01.615]                       }
[10:27:01.615]                       else if (inherits(cond, "condition")) {
[10:27:01.615]                         if (!is.null(pattern)) {
[10:27:01.615]                           computeRestarts <- base::computeRestarts
[10:27:01.615]                           grepl <- base::grepl
[10:27:01.615]                           restarts <- computeRestarts(cond)
[10:27:01.615]                           for (restart in restarts) {
[10:27:01.615]                             name <- restart$name
[10:27:01.615]                             if (is.null(name)) 
[10:27:01.615]                               next
[10:27:01.615]                             if (!grepl(pattern, name)) 
[10:27:01.615]                               next
[10:27:01.615]                             invokeRestart(restart)
[10:27:01.615]                             muffled <- TRUE
[10:27:01.615]                             break
[10:27:01.615]                           }
[10:27:01.615]                         }
[10:27:01.615]                       }
[10:27:01.615]                       invisible(muffled)
[10:27:01.615]                     }
[10:27:01.615]                     muffleCondition(cond, pattern = "^muffle")
[10:27:01.615]                   }
[10:27:01.615]                 }
[10:27:01.615]             }
[10:27:01.615]         }))
[10:27:01.615]     }, error = function(ex) {
[10:27:01.615]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:01.615]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:01.615]                 ...future.rng), started = ...future.startTime, 
[10:27:01.615]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:01.615]             version = "1.8"), class = "FutureResult")
[10:27:01.615]     }, finally = {
[10:27:01.615]         if (!identical(...future.workdir, getwd())) 
[10:27:01.615]             setwd(...future.workdir)
[10:27:01.615]         {
[10:27:01.615]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:01.615]                 ...future.oldOptions$nwarnings <- NULL
[10:27:01.615]             }
[10:27:01.615]             base::options(...future.oldOptions)
[10:27:01.615]             if (.Platform$OS.type == "windows") {
[10:27:01.615]                 old_names <- names(...future.oldEnvVars)
[10:27:01.615]                 envs <- base::Sys.getenv()
[10:27:01.615]                 names <- names(envs)
[10:27:01.615]                 common <- intersect(names, old_names)
[10:27:01.615]                 added <- setdiff(names, old_names)
[10:27:01.615]                 removed <- setdiff(old_names, names)
[10:27:01.615]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:01.615]                   envs[common]]
[10:27:01.615]                 NAMES <- toupper(changed)
[10:27:01.615]                 args <- list()
[10:27:01.615]                 for (kk in seq_along(NAMES)) {
[10:27:01.615]                   name <- changed[[kk]]
[10:27:01.615]                   NAME <- NAMES[[kk]]
[10:27:01.615]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:01.615]                     next
[10:27:01.615]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:01.615]                 }
[10:27:01.615]                 NAMES <- toupper(added)
[10:27:01.615]                 for (kk in seq_along(NAMES)) {
[10:27:01.615]                   name <- added[[kk]]
[10:27:01.615]                   NAME <- NAMES[[kk]]
[10:27:01.615]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:01.615]                     next
[10:27:01.615]                   args[[name]] <- ""
[10:27:01.615]                 }
[10:27:01.615]                 NAMES <- toupper(removed)
[10:27:01.615]                 for (kk in seq_along(NAMES)) {
[10:27:01.615]                   name <- removed[[kk]]
[10:27:01.615]                   NAME <- NAMES[[kk]]
[10:27:01.615]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:01.615]                     next
[10:27:01.615]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:01.615]                 }
[10:27:01.615]                 if (length(args) > 0) 
[10:27:01.615]                   base::do.call(base::Sys.setenv, args = args)
[10:27:01.615]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:01.615]             }
[10:27:01.615]             else {
[10:27:01.615]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:01.615]             }
[10:27:01.615]             {
[10:27:01.615]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:01.615]                   0L) {
[10:27:01.615]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:01.615]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:01.615]                   base::options(opts)
[10:27:01.615]                 }
[10:27:01.615]                 {
[10:27:01.615]                   {
[10:27:01.615]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:01.615]                     NULL
[10:27:01.615]                   }
[10:27:01.615]                   options(future.plan = NULL)
[10:27:01.615]                   if (is.na(NA_character_)) 
[10:27:01.615]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:01.615]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:01.615]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:27:01.615]                     envir = parent.frame()) 
[10:27:01.615]                   {
[10:27:01.615]                     default_workers <- missing(workers)
[10:27:01.615]                     if (is.function(workers)) 
[10:27:01.615]                       workers <- workers()
[10:27:01.615]                     workers <- structure(as.integer(workers), 
[10:27:01.615]                       class = class(workers))
[10:27:01.615]                     stop_if_not(is.finite(workers), workers >= 
[10:27:01.615]                       1L)
[10:27:01.615]                     if ((workers == 1L && !inherits(workers, 
[10:27:01.615]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:27:01.615]                       if (default_workers) 
[10:27:01.615]                         supportsMulticore(warn = TRUE)
[10:27:01.615]                       return(sequential(..., envir = envir))
[10:27:01.615]                     }
[10:27:01.615]                     oopts <- options(mc.cores = workers)
[10:27:01.615]                     on.exit(options(oopts))
[10:27:01.615]                     future <- MulticoreFuture(..., workers = workers, 
[10:27:01.615]                       envir = envir)
[10:27:01.615]                     if (!future$lazy) 
[10:27:01.615]                       future <- run(future)
[10:27:01.615]                     invisible(future)
[10:27:01.615]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:01.615]                 }
[10:27:01.615]             }
[10:27:01.615]         }
[10:27:01.615]     })
[10:27:01.615]     if (TRUE) {
[10:27:01.615]         base::sink(type = "output", split = FALSE)
[10:27:01.615]         if (TRUE) {
[10:27:01.615]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:01.615]         }
[10:27:01.615]         else {
[10:27:01.615]             ...future.result["stdout"] <- base::list(NULL)
[10:27:01.615]         }
[10:27:01.615]         base::close(...future.stdout)
[10:27:01.615]         ...future.stdout <- NULL
[10:27:01.615]     }
[10:27:01.615]     ...future.result$conditions <- ...future.conditions
[10:27:01.615]     ...future.result$finished <- base::Sys.time()
[10:27:01.615]     ...future.result
[10:27:01.615] }
[10:27:01.618] requestCore(): workers = 2
[10:27:01.619] Poll #1 (0): usedCores() = 2, workers = 2
[10:27:01.629] result() for MulticoreFuture ...
[10:27:01.630] result() for MulticoreFuture ...
[10:27:01.630] result() for MulticoreFuture ... done
[10:27:01.631] result() for MulticoreFuture ... done
[10:27:01.631] result() for MulticoreFuture ...
[10:27:01.631] result() for MulticoreFuture ... done
[10:27:01.634] MulticoreFuture started
[10:27:01.634] - Launch lazy future ... done
[10:27:01.635] run() for ‘MulticoreFuture’ ... done
[10:27:01.635] plan(): Setting new future strategy stack:
[10:27:01.635] List of future strategies:
[10:27:01.635] 1. sequential:
[10:27:01.635]    - args: function (..., envir = parent.frame())
[10:27:01.635]    - tweaked: FALSE
[10:27:01.635]    - call: NULL
[10:27:01.637] plan(): nbrOfWorkers() = 1
[10:27:01.640] plan(): Setting new future strategy stack:
[10:27:01.640] List of future strategies:
[10:27:01.640] 1. multicore:
[10:27:01.640]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:27:01.640]    - tweaked: FALSE
[10:27:01.640]    - call: plan(strategy)
[10:27:01.647] run() for ‘Future’ ...
[10:27:01.647] - state: ‘created’
[10:27:01.648] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:27:01.649] plan(): nbrOfWorkers() = 2
[10:27:01.653] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:01.653] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:27:01.653]   - Field: ‘label’
[10:27:01.653]   - Field: ‘local’
[10:27:01.653]   - Field: ‘owner’
[10:27:01.654]   - Field: ‘envir’
[10:27:01.654]   - Field: ‘workers’
[10:27:01.654]   - Field: ‘packages’
[10:27:01.654]   - Field: ‘gc’
[10:27:01.654]   - Field: ‘job’
[10:27:01.654]   - Field: ‘conditions’
[10:27:01.654]   - Field: ‘expr’
[10:27:01.655]   - Field: ‘uuid’
[10:27:01.655]   - Field: ‘seed’
[10:27:01.655]   - Field: ‘version’
[10:27:01.655]   - Field: ‘result’
[10:27:01.655]   - Field: ‘asynchronous’
[10:27:01.655]   - Field: ‘calls’
[10:27:01.656]   - Field: ‘globals’
[10:27:01.656]   - Field: ‘stdout’
[10:27:01.656]   - Field: ‘earlySignal’
[10:27:01.656]   - Field: ‘lazy’
[10:27:01.656]   - Field: ‘state’
[10:27:01.656] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:27:01.656] - Launch lazy future ...
[10:27:01.657] Packages needed by the future expression (n = 0): <none>
[10:27:01.657] Packages needed by future strategies (n = 0): <none>
[10:27:01.658] {
[10:27:01.658]     {
[10:27:01.658]         {
[10:27:01.658]             ...future.startTime <- base::Sys.time()
[10:27:01.658]             {
[10:27:01.658]                 {
[10:27:01.658]                   {
[10:27:01.658]                     {
[10:27:01.658]                       base::local({
[10:27:01.658]                         has_future <- base::requireNamespace("future", 
[10:27:01.658]                           quietly = TRUE)
[10:27:01.658]                         if (has_future) {
[10:27:01.658]                           ns <- base::getNamespace("future")
[10:27:01.658]                           version <- ns[[".package"]][["version"]]
[10:27:01.658]                           if (is.null(version)) 
[10:27:01.658]                             version <- utils::packageVersion("future")
[10:27:01.658]                         }
[10:27:01.658]                         else {
[10:27:01.658]                           version <- NULL
[10:27:01.658]                         }
[10:27:01.658]                         if (!has_future || version < "1.8.0") {
[10:27:01.658]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:01.658]                             "", base::R.version$version.string), 
[10:27:01.658]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:01.658]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:01.658]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:01.658]                               "release", "version")], collapse = " "), 
[10:27:01.658]                             hostname = base::Sys.info()[["nodename"]])
[10:27:01.658]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:01.658]                             info)
[10:27:01.658]                           info <- base::paste(info, collapse = "; ")
[10:27:01.658]                           if (!has_future) {
[10:27:01.658]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:01.658]                               info)
[10:27:01.658]                           }
[10:27:01.658]                           else {
[10:27:01.658]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:01.658]                               info, version)
[10:27:01.658]                           }
[10:27:01.658]                           base::stop(msg)
[10:27:01.658]                         }
[10:27:01.658]                       })
[10:27:01.658]                     }
[10:27:01.658]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:01.658]                     base::options(mc.cores = 1L)
[10:27:01.658]                   }
[10:27:01.658]                   options(future.plan = NULL)
[10:27:01.658]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:01.658]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:01.658]                 }
[10:27:01.658]                 ...future.workdir <- getwd()
[10:27:01.658]             }
[10:27:01.658]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:01.658]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:01.658]         }
[10:27:01.658]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:01.658]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:01.658]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:01.658]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:01.658]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:01.658]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:01.658]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:01.658]             base::names(...future.oldOptions))
[10:27:01.658]     }
[10:27:01.658]     if (FALSE) {
[10:27:01.658]     }
[10:27:01.658]     else {
[10:27:01.658]         if (TRUE) {
[10:27:01.658]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:01.658]                 open = "w")
[10:27:01.658]         }
[10:27:01.658]         else {
[10:27:01.658]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:01.658]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:01.658]         }
[10:27:01.658]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:01.658]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:01.658]             base::sink(type = "output", split = FALSE)
[10:27:01.658]             base::close(...future.stdout)
[10:27:01.658]         }, add = TRUE)
[10:27:01.658]     }
[10:27:01.658]     ...future.frame <- base::sys.nframe()
[10:27:01.658]     ...future.conditions <- base::list()
[10:27:01.658]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:01.658]     if (FALSE) {
[10:27:01.658]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:01.658]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:01.658]     }
[10:27:01.658]     ...future.result <- base::tryCatch({
[10:27:01.658]         base::withCallingHandlers({
[10:27:01.658]             ...future.value <- base::withVisible(base::local({
[10:27:01.658]                 withCallingHandlers({
[10:27:01.658]                   2
[10:27:01.658]                 }, immediateCondition = function(cond) {
[10:27:01.658]                   save_rds <- function (object, pathname, ...) 
[10:27:01.658]                   {
[10:27:01.658]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:27:01.658]                     if (file_test("-f", pathname_tmp)) {
[10:27:01.658]                       fi_tmp <- file.info(pathname_tmp)
[10:27:01.658]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:27:01.658]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:01.658]                         fi_tmp[["mtime"]])
[10:27:01.658]                     }
[10:27:01.658]                     tryCatch({
[10:27:01.658]                       saveRDS(object, file = pathname_tmp, ...)
[10:27:01.658]                     }, error = function(ex) {
[10:27:01.658]                       msg <- conditionMessage(ex)
[10:27:01.658]                       fi_tmp <- file.info(pathname_tmp)
[10:27:01.658]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:27:01.658]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:01.658]                         fi_tmp[["mtime"]], msg)
[10:27:01.658]                       ex$message <- msg
[10:27:01.658]                       stop(ex)
[10:27:01.658]                     })
[10:27:01.658]                     stopifnot(file_test("-f", pathname_tmp))
[10:27:01.658]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:27:01.658]                     if (!res || file_test("-f", pathname_tmp)) {
[10:27:01.658]                       fi_tmp <- file.info(pathname_tmp)
[10:27:01.658]                       fi <- file.info(pathname)
[10:27:01.658]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:27:01.658]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:01.658]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:27:01.658]                         fi[["size"]], fi[["mtime"]])
[10:27:01.658]                       stop(msg)
[10:27:01.658]                     }
[10:27:01.658]                     invisible(pathname)
[10:27:01.658]                   }
[10:27:01.658]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:27:01.658]                     rootPath = tempdir()) 
[10:27:01.658]                   {
[10:27:01.658]                     obj <- list(time = Sys.time(), condition = cond)
[10:27:01.658]                     file <- tempfile(pattern = class(cond)[1], 
[10:27:01.658]                       tmpdir = path, fileext = ".rds")
[10:27:01.658]                     save_rds(obj, file)
[10:27:01.658]                   }
[10:27:01.658]                   saveImmediateCondition(cond, path = "/tmp/RtmpisxSDE/.future/immediateConditions")
[10:27:01.658]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:01.658]                   {
[10:27:01.658]                     inherits <- base::inherits
[10:27:01.658]                     invokeRestart <- base::invokeRestart
[10:27:01.658]                     is.null <- base::is.null
[10:27:01.658]                     muffled <- FALSE
[10:27:01.658]                     if (inherits(cond, "message")) {
[10:27:01.658]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:01.658]                       if (muffled) 
[10:27:01.658]                         invokeRestart("muffleMessage")
[10:27:01.658]                     }
[10:27:01.658]                     else if (inherits(cond, "warning")) {
[10:27:01.658]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:01.658]                       if (muffled) 
[10:27:01.658]                         invokeRestart("muffleWarning")
[10:27:01.658]                     }
[10:27:01.658]                     else if (inherits(cond, "condition")) {
[10:27:01.658]                       if (!is.null(pattern)) {
[10:27:01.658]                         computeRestarts <- base::computeRestarts
[10:27:01.658]                         grepl <- base::grepl
[10:27:01.658]                         restarts <- computeRestarts(cond)
[10:27:01.658]                         for (restart in restarts) {
[10:27:01.658]                           name <- restart$name
[10:27:01.658]                           if (is.null(name)) 
[10:27:01.658]                             next
[10:27:01.658]                           if (!grepl(pattern, name)) 
[10:27:01.658]                             next
[10:27:01.658]                           invokeRestart(restart)
[10:27:01.658]                           muffled <- TRUE
[10:27:01.658]                           break
[10:27:01.658]                         }
[10:27:01.658]                       }
[10:27:01.658]                     }
[10:27:01.658]                     invisible(muffled)
[10:27:01.658]                   }
[10:27:01.658]                   muffleCondition(cond)
[10:27:01.658]                 })
[10:27:01.658]             }))
[10:27:01.658]             future::FutureResult(value = ...future.value$value, 
[10:27:01.658]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:01.658]                   ...future.rng), globalenv = if (FALSE) 
[10:27:01.658]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:01.658]                     ...future.globalenv.names))
[10:27:01.658]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:01.658]         }, condition = base::local({
[10:27:01.658]             c <- base::c
[10:27:01.658]             inherits <- base::inherits
[10:27:01.658]             invokeRestart <- base::invokeRestart
[10:27:01.658]             length <- base::length
[10:27:01.658]             list <- base::list
[10:27:01.658]             seq.int <- base::seq.int
[10:27:01.658]             signalCondition <- base::signalCondition
[10:27:01.658]             sys.calls <- base::sys.calls
[10:27:01.658]             `[[` <- base::`[[`
[10:27:01.658]             `+` <- base::`+`
[10:27:01.658]             `<<-` <- base::`<<-`
[10:27:01.658]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:01.658]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:01.658]                   3L)]
[10:27:01.658]             }
[10:27:01.658]             function(cond) {
[10:27:01.658]                 is_error <- inherits(cond, "error")
[10:27:01.658]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:01.658]                   NULL)
[10:27:01.658]                 if (is_error) {
[10:27:01.658]                   sessionInformation <- function() {
[10:27:01.658]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:01.658]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:01.658]                       search = base::search(), system = base::Sys.info())
[10:27:01.658]                   }
[10:27:01.658]                   ...future.conditions[[length(...future.conditions) + 
[10:27:01.658]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:01.658]                     cond$call), session = sessionInformation(), 
[10:27:01.658]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:01.658]                   signalCondition(cond)
[10:27:01.658]                 }
[10:27:01.658]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:01.658]                 "immediateCondition"))) {
[10:27:01.658]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:01.658]                   ...future.conditions[[length(...future.conditions) + 
[10:27:01.658]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:01.658]                   if (TRUE && !signal) {
[10:27:01.658]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:01.658]                     {
[10:27:01.658]                       inherits <- base::inherits
[10:27:01.658]                       invokeRestart <- base::invokeRestart
[10:27:01.658]                       is.null <- base::is.null
[10:27:01.658]                       muffled <- FALSE
[10:27:01.658]                       if (inherits(cond, "message")) {
[10:27:01.658]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:01.658]                         if (muffled) 
[10:27:01.658]                           invokeRestart("muffleMessage")
[10:27:01.658]                       }
[10:27:01.658]                       else if (inherits(cond, "warning")) {
[10:27:01.658]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:01.658]                         if (muffled) 
[10:27:01.658]                           invokeRestart("muffleWarning")
[10:27:01.658]                       }
[10:27:01.658]                       else if (inherits(cond, "condition")) {
[10:27:01.658]                         if (!is.null(pattern)) {
[10:27:01.658]                           computeRestarts <- base::computeRestarts
[10:27:01.658]                           grepl <- base::grepl
[10:27:01.658]                           restarts <- computeRestarts(cond)
[10:27:01.658]                           for (restart in restarts) {
[10:27:01.658]                             name <- restart$name
[10:27:01.658]                             if (is.null(name)) 
[10:27:01.658]                               next
[10:27:01.658]                             if (!grepl(pattern, name)) 
[10:27:01.658]                               next
[10:27:01.658]                             invokeRestart(restart)
[10:27:01.658]                             muffled <- TRUE
[10:27:01.658]                             break
[10:27:01.658]                           }
[10:27:01.658]                         }
[10:27:01.658]                       }
[10:27:01.658]                       invisible(muffled)
[10:27:01.658]                     }
[10:27:01.658]                     muffleCondition(cond, pattern = "^muffle")
[10:27:01.658]                   }
[10:27:01.658]                 }
[10:27:01.658]                 else {
[10:27:01.658]                   if (TRUE) {
[10:27:01.658]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:01.658]                     {
[10:27:01.658]                       inherits <- base::inherits
[10:27:01.658]                       invokeRestart <- base::invokeRestart
[10:27:01.658]                       is.null <- base::is.null
[10:27:01.658]                       muffled <- FALSE
[10:27:01.658]                       if (inherits(cond, "message")) {
[10:27:01.658]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:01.658]                         if (muffled) 
[10:27:01.658]                           invokeRestart("muffleMessage")
[10:27:01.658]                       }
[10:27:01.658]                       else if (inherits(cond, "warning")) {
[10:27:01.658]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:01.658]                         if (muffled) 
[10:27:01.658]                           invokeRestart("muffleWarning")
[10:27:01.658]                       }
[10:27:01.658]                       else if (inherits(cond, "condition")) {
[10:27:01.658]                         if (!is.null(pattern)) {
[10:27:01.658]                           computeRestarts <- base::computeRestarts
[10:27:01.658]                           grepl <- base::grepl
[10:27:01.658]                           restarts <- computeRestarts(cond)
[10:27:01.658]                           for (restart in restarts) {
[10:27:01.658]                             name <- restart$name
[10:27:01.658]                             if (is.null(name)) 
[10:27:01.658]                               next
[10:27:01.658]                             if (!grepl(pattern, name)) 
[10:27:01.658]                               next
[10:27:01.658]                             invokeRestart(restart)
[10:27:01.658]                             muffled <- TRUE
[10:27:01.658]                             break
[10:27:01.658]                           }
[10:27:01.658]                         }
[10:27:01.658]                       }
[10:27:01.658]                       invisible(muffled)
[10:27:01.658]                     }
[10:27:01.658]                     muffleCondition(cond, pattern = "^muffle")
[10:27:01.658]                   }
[10:27:01.658]                 }
[10:27:01.658]             }
[10:27:01.658]         }))
[10:27:01.658]     }, error = function(ex) {
[10:27:01.658]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:01.658]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:01.658]                 ...future.rng), started = ...future.startTime, 
[10:27:01.658]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:01.658]             version = "1.8"), class = "FutureResult")
[10:27:01.658]     }, finally = {
[10:27:01.658]         if (!identical(...future.workdir, getwd())) 
[10:27:01.658]             setwd(...future.workdir)
[10:27:01.658]         {
[10:27:01.658]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:01.658]                 ...future.oldOptions$nwarnings <- NULL
[10:27:01.658]             }
[10:27:01.658]             base::options(...future.oldOptions)
[10:27:01.658]             if (.Platform$OS.type == "windows") {
[10:27:01.658]                 old_names <- names(...future.oldEnvVars)
[10:27:01.658]                 envs <- base::Sys.getenv()
[10:27:01.658]                 names <- names(envs)
[10:27:01.658]                 common <- intersect(names, old_names)
[10:27:01.658]                 added <- setdiff(names, old_names)
[10:27:01.658]                 removed <- setdiff(old_names, names)
[10:27:01.658]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:01.658]                   envs[common]]
[10:27:01.658]                 NAMES <- toupper(changed)
[10:27:01.658]                 args <- list()
[10:27:01.658]                 for (kk in seq_along(NAMES)) {
[10:27:01.658]                   name <- changed[[kk]]
[10:27:01.658]                   NAME <- NAMES[[kk]]
[10:27:01.658]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:01.658]                     next
[10:27:01.658]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:01.658]                 }
[10:27:01.658]                 NAMES <- toupper(added)
[10:27:01.658]                 for (kk in seq_along(NAMES)) {
[10:27:01.658]                   name <- added[[kk]]
[10:27:01.658]                   NAME <- NAMES[[kk]]
[10:27:01.658]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:01.658]                     next
[10:27:01.658]                   args[[name]] <- ""
[10:27:01.658]                 }
[10:27:01.658]                 NAMES <- toupper(removed)
[10:27:01.658]                 for (kk in seq_along(NAMES)) {
[10:27:01.658]                   name <- removed[[kk]]
[10:27:01.658]                   NAME <- NAMES[[kk]]
[10:27:01.658]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:01.658]                     next
[10:27:01.658]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:01.658]                 }
[10:27:01.658]                 if (length(args) > 0) 
[10:27:01.658]                   base::do.call(base::Sys.setenv, args = args)
[10:27:01.658]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:01.658]             }
[10:27:01.658]             else {
[10:27:01.658]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:01.658]             }
[10:27:01.658]             {
[10:27:01.658]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:01.658]                   0L) {
[10:27:01.658]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:01.658]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:01.658]                   base::options(opts)
[10:27:01.658]                 }
[10:27:01.658]                 {
[10:27:01.658]                   {
[10:27:01.658]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:01.658]                     NULL
[10:27:01.658]                   }
[10:27:01.658]                   options(future.plan = NULL)
[10:27:01.658]                   if (is.na(NA_character_)) 
[10:27:01.658]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:01.658]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:01.658]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:27:01.658]                     envir = parent.frame()) 
[10:27:01.658]                   {
[10:27:01.658]                     default_workers <- missing(workers)
[10:27:01.658]                     if (is.function(workers)) 
[10:27:01.658]                       workers <- workers()
[10:27:01.658]                     workers <- structure(as.integer(workers), 
[10:27:01.658]                       class = class(workers))
[10:27:01.658]                     stop_if_not(is.finite(workers), workers >= 
[10:27:01.658]                       1L)
[10:27:01.658]                     if ((workers == 1L && !inherits(workers, 
[10:27:01.658]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:27:01.658]                       if (default_workers) 
[10:27:01.658]                         supportsMulticore(warn = TRUE)
[10:27:01.658]                       return(sequential(..., envir = envir))
[10:27:01.658]                     }
[10:27:01.658]                     oopts <- options(mc.cores = workers)
[10:27:01.658]                     on.exit(options(oopts))
[10:27:01.658]                     future <- MulticoreFuture(..., workers = workers, 
[10:27:01.658]                       envir = envir)
[10:27:01.658]                     if (!future$lazy) 
[10:27:01.658]                       future <- run(future)
[10:27:01.658]                     invisible(future)
[10:27:01.658]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:01.658]                 }
[10:27:01.658]             }
[10:27:01.658]         }
[10:27:01.658]     })
[10:27:01.658]     if (TRUE) {
[10:27:01.658]         base::sink(type = "output", split = FALSE)
[10:27:01.658]         if (TRUE) {
[10:27:01.658]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:01.658]         }
[10:27:01.658]         else {
[10:27:01.658]             ...future.result["stdout"] <- base::list(NULL)
[10:27:01.658]         }
[10:27:01.658]         base::close(...future.stdout)
[10:27:01.658]         ...future.stdout <- NULL
[10:27:01.658]     }
[10:27:01.658]     ...future.result$conditions <- ...future.conditions
[10:27:01.658]     ...future.result$finished <- base::Sys.time()
[10:27:01.658]     ...future.result
[10:27:01.658] }
[10:27:01.662] requestCore(): workers = 2
[10:27:01.662] Poll #1 (0): usedCores() = 2, workers = 2
[10:27:01.675] result() for MulticoreFuture ...
[10:27:01.676] result() for MulticoreFuture ...
[10:27:01.676] result() for MulticoreFuture ... done
[10:27:01.677] result() for MulticoreFuture ... done
[10:27:01.677] result() for MulticoreFuture ...
[10:27:01.677] result() for MulticoreFuture ... done
[10:27:01.680] MulticoreFuture started
[10:27:01.681] - Launch lazy future ... done
[10:27:01.681] run() for ‘MulticoreFuture’ ... done
[10:27:01.681] plan(): Setting new future strategy stack:
[10:27:01.682] List of future strategies:
[10:27:01.682] 1. sequential:
[10:27:01.682]    - args: function (..., envir = parent.frame())
[10:27:01.682]    - tweaked: FALSE
[10:27:01.682]    - call: NULL
[10:27:01.683] plan(): nbrOfWorkers() = 1
[10:27:01.686] plan(): Setting new future strategy stack:
[10:27:01.686] List of future strategies:
[10:27:01.686] 1. multicore:
[10:27:01.686]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:27:01.686]    - tweaked: FALSE
[10:27:01.686]    - call: plan(strategy)
[10:27:01.692]  length: 2 (resolved future 3)
[10:27:01.693] plan(): nbrOfWorkers() = 2
[10:27:01.702] Future #1
[10:27:01.703]  length: 1 (resolved future 1)
[10:27:01.703] Future #2
[10:27:01.703]  length: 0 (resolved future 2)
[10:27:01.703] resolve() on list ... DONE
[10:27:01.704] getGlobalsAndPackages() ...
[10:27:01.704] Searching for globals...
[10:27:01.705] 
[10:27:01.705] Searching for globals ... DONE
[10:27:01.705] - globals: [0] <none>
[10:27:01.705] getGlobalsAndPackages() ... DONE
[10:27:01.706] run() for ‘Future’ ...
[10:27:01.706] - state: ‘created’
[10:27:01.706] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:27:01.711] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:01.711] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:27:01.712]   - Field: ‘label’
[10:27:01.712]   - Field: ‘local’
[10:27:01.712]   - Field: ‘owner’
[10:27:01.712]   - Field: ‘envir’
[10:27:01.712]   - Field: ‘workers’
[10:27:01.712]   - Field: ‘packages’
[10:27:01.713]   - Field: ‘gc’
[10:27:01.713]   - Field: ‘job’
[10:27:01.713]   - Field: ‘conditions’
[10:27:01.713]   - Field: ‘expr’
[10:27:01.713]   - Field: ‘uuid’
[10:27:01.713]   - Field: ‘seed’
[10:27:01.713]   - Field: ‘version’
[10:27:01.714]   - Field: ‘result’
[10:27:01.714]   - Field: ‘asynchronous’
[10:27:01.714]   - Field: ‘calls’
[10:27:01.714]   - Field: ‘globals’
[10:27:01.714]   - Field: ‘stdout’
[10:27:01.714]   - Field: ‘earlySignal’
[10:27:01.714]   - Field: ‘lazy’
[10:27:01.715]   - Field: ‘state’
[10:27:01.715] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:27:01.715] - Launch lazy future ...
[10:27:01.715] Packages needed by the future expression (n = 0): <none>
[10:27:01.716] Packages needed by future strategies (n = 0): <none>
[10:27:01.716] {
[10:27:01.716]     {
[10:27:01.716]         {
[10:27:01.716]             ...future.startTime <- base::Sys.time()
[10:27:01.716]             {
[10:27:01.716]                 {
[10:27:01.716]                   {
[10:27:01.716]                     {
[10:27:01.716]                       base::local({
[10:27:01.716]                         has_future <- base::requireNamespace("future", 
[10:27:01.716]                           quietly = TRUE)
[10:27:01.716]                         if (has_future) {
[10:27:01.716]                           ns <- base::getNamespace("future")
[10:27:01.716]                           version <- ns[[".package"]][["version"]]
[10:27:01.716]                           if (is.null(version)) 
[10:27:01.716]                             version <- utils::packageVersion("future")
[10:27:01.716]                         }
[10:27:01.716]                         else {
[10:27:01.716]                           version <- NULL
[10:27:01.716]                         }
[10:27:01.716]                         if (!has_future || version < "1.8.0") {
[10:27:01.716]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:01.716]                             "", base::R.version$version.string), 
[10:27:01.716]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:01.716]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:01.716]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:01.716]                               "release", "version")], collapse = " "), 
[10:27:01.716]                             hostname = base::Sys.info()[["nodename"]])
[10:27:01.716]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:01.716]                             info)
[10:27:01.716]                           info <- base::paste(info, collapse = "; ")
[10:27:01.716]                           if (!has_future) {
[10:27:01.716]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:01.716]                               info)
[10:27:01.716]                           }
[10:27:01.716]                           else {
[10:27:01.716]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:01.716]                               info, version)
[10:27:01.716]                           }
[10:27:01.716]                           base::stop(msg)
[10:27:01.716]                         }
[10:27:01.716]                       })
[10:27:01.716]                     }
[10:27:01.716]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:01.716]                     base::options(mc.cores = 1L)
[10:27:01.716]                   }
[10:27:01.716]                   options(future.plan = NULL)
[10:27:01.716]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:01.716]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:01.716]                 }
[10:27:01.716]                 ...future.workdir <- getwd()
[10:27:01.716]             }
[10:27:01.716]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:01.716]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:01.716]         }
[10:27:01.716]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:01.716]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:01.716]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:01.716]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:01.716]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:01.716]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:01.716]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:01.716]             base::names(...future.oldOptions))
[10:27:01.716]     }
[10:27:01.716]     if (FALSE) {
[10:27:01.716]     }
[10:27:01.716]     else {
[10:27:01.716]         if (TRUE) {
[10:27:01.716]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:01.716]                 open = "w")
[10:27:01.716]         }
[10:27:01.716]         else {
[10:27:01.716]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:01.716]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:01.716]         }
[10:27:01.716]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:01.716]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:01.716]             base::sink(type = "output", split = FALSE)
[10:27:01.716]             base::close(...future.stdout)
[10:27:01.716]         }, add = TRUE)
[10:27:01.716]     }
[10:27:01.716]     ...future.frame <- base::sys.nframe()
[10:27:01.716]     ...future.conditions <- base::list()
[10:27:01.716]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:01.716]     if (FALSE) {
[10:27:01.716]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:01.716]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:01.716]     }
[10:27:01.716]     ...future.result <- base::tryCatch({
[10:27:01.716]         base::withCallingHandlers({
[10:27:01.716]             ...future.value <- base::withVisible(base::local({
[10:27:01.716]                 withCallingHandlers({
[10:27:01.716]                   1
[10:27:01.716]                 }, immediateCondition = function(cond) {
[10:27:01.716]                   save_rds <- function (object, pathname, ...) 
[10:27:01.716]                   {
[10:27:01.716]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:27:01.716]                     if (file_test("-f", pathname_tmp)) {
[10:27:01.716]                       fi_tmp <- file.info(pathname_tmp)
[10:27:01.716]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:27:01.716]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:01.716]                         fi_tmp[["mtime"]])
[10:27:01.716]                     }
[10:27:01.716]                     tryCatch({
[10:27:01.716]                       saveRDS(object, file = pathname_tmp, ...)
[10:27:01.716]                     }, error = function(ex) {
[10:27:01.716]                       msg <- conditionMessage(ex)
[10:27:01.716]                       fi_tmp <- file.info(pathname_tmp)
[10:27:01.716]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:27:01.716]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:01.716]                         fi_tmp[["mtime"]], msg)
[10:27:01.716]                       ex$message <- msg
[10:27:01.716]                       stop(ex)
[10:27:01.716]                     })
[10:27:01.716]                     stopifnot(file_test("-f", pathname_tmp))
[10:27:01.716]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:27:01.716]                     if (!res || file_test("-f", pathname_tmp)) {
[10:27:01.716]                       fi_tmp <- file.info(pathname_tmp)
[10:27:01.716]                       fi <- file.info(pathname)
[10:27:01.716]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:27:01.716]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:01.716]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:27:01.716]                         fi[["size"]], fi[["mtime"]])
[10:27:01.716]                       stop(msg)
[10:27:01.716]                     }
[10:27:01.716]                     invisible(pathname)
[10:27:01.716]                   }
[10:27:01.716]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:27:01.716]                     rootPath = tempdir()) 
[10:27:01.716]                   {
[10:27:01.716]                     obj <- list(time = Sys.time(), condition = cond)
[10:27:01.716]                     file <- tempfile(pattern = class(cond)[1], 
[10:27:01.716]                       tmpdir = path, fileext = ".rds")
[10:27:01.716]                     save_rds(obj, file)
[10:27:01.716]                   }
[10:27:01.716]                   saveImmediateCondition(cond, path = "/tmp/RtmpisxSDE/.future/immediateConditions")
[10:27:01.716]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:01.716]                   {
[10:27:01.716]                     inherits <- base::inherits
[10:27:01.716]                     invokeRestart <- base::invokeRestart
[10:27:01.716]                     is.null <- base::is.null
[10:27:01.716]                     muffled <- FALSE
[10:27:01.716]                     if (inherits(cond, "message")) {
[10:27:01.716]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:01.716]                       if (muffled) 
[10:27:01.716]                         invokeRestart("muffleMessage")
[10:27:01.716]                     }
[10:27:01.716]                     else if (inherits(cond, "warning")) {
[10:27:01.716]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:01.716]                       if (muffled) 
[10:27:01.716]                         invokeRestart("muffleWarning")
[10:27:01.716]                     }
[10:27:01.716]                     else if (inherits(cond, "condition")) {
[10:27:01.716]                       if (!is.null(pattern)) {
[10:27:01.716]                         computeRestarts <- base::computeRestarts
[10:27:01.716]                         grepl <- base::grepl
[10:27:01.716]                         restarts <- computeRestarts(cond)
[10:27:01.716]                         for (restart in restarts) {
[10:27:01.716]                           name <- restart$name
[10:27:01.716]                           if (is.null(name)) 
[10:27:01.716]                             next
[10:27:01.716]                           if (!grepl(pattern, name)) 
[10:27:01.716]                             next
[10:27:01.716]                           invokeRestart(restart)
[10:27:01.716]                           muffled <- TRUE
[10:27:01.716]                           break
[10:27:01.716]                         }
[10:27:01.716]                       }
[10:27:01.716]                     }
[10:27:01.716]                     invisible(muffled)
[10:27:01.716]                   }
[10:27:01.716]                   muffleCondition(cond)
[10:27:01.716]                 })
[10:27:01.716]             }))
[10:27:01.716]             future::FutureResult(value = ...future.value$value, 
[10:27:01.716]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:01.716]                   ...future.rng), globalenv = if (FALSE) 
[10:27:01.716]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:01.716]                     ...future.globalenv.names))
[10:27:01.716]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:01.716]         }, condition = base::local({
[10:27:01.716]             c <- base::c
[10:27:01.716]             inherits <- base::inherits
[10:27:01.716]             invokeRestart <- base::invokeRestart
[10:27:01.716]             length <- base::length
[10:27:01.716]             list <- base::list
[10:27:01.716]             seq.int <- base::seq.int
[10:27:01.716]             signalCondition <- base::signalCondition
[10:27:01.716]             sys.calls <- base::sys.calls
[10:27:01.716]             `[[` <- base::`[[`
[10:27:01.716]             `+` <- base::`+`
[10:27:01.716]             `<<-` <- base::`<<-`
[10:27:01.716]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:01.716]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:01.716]                   3L)]
[10:27:01.716]             }
[10:27:01.716]             function(cond) {
[10:27:01.716]                 is_error <- inherits(cond, "error")
[10:27:01.716]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:01.716]                   NULL)
[10:27:01.716]                 if (is_error) {
[10:27:01.716]                   sessionInformation <- function() {
[10:27:01.716]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:01.716]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:01.716]                       search = base::search(), system = base::Sys.info())
[10:27:01.716]                   }
[10:27:01.716]                   ...future.conditions[[length(...future.conditions) + 
[10:27:01.716]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:01.716]                     cond$call), session = sessionInformation(), 
[10:27:01.716]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:01.716]                   signalCondition(cond)
[10:27:01.716]                 }
[10:27:01.716]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:01.716]                 "immediateCondition"))) {
[10:27:01.716]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:01.716]                   ...future.conditions[[length(...future.conditions) + 
[10:27:01.716]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:01.716]                   if (TRUE && !signal) {
[10:27:01.716]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:01.716]                     {
[10:27:01.716]                       inherits <- base::inherits
[10:27:01.716]                       invokeRestart <- base::invokeRestart
[10:27:01.716]                       is.null <- base::is.null
[10:27:01.716]                       muffled <- FALSE
[10:27:01.716]                       if (inherits(cond, "message")) {
[10:27:01.716]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:01.716]                         if (muffled) 
[10:27:01.716]                           invokeRestart("muffleMessage")
[10:27:01.716]                       }
[10:27:01.716]                       else if (inherits(cond, "warning")) {
[10:27:01.716]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:01.716]                         if (muffled) 
[10:27:01.716]                           invokeRestart("muffleWarning")
[10:27:01.716]                       }
[10:27:01.716]                       else if (inherits(cond, "condition")) {
[10:27:01.716]                         if (!is.null(pattern)) {
[10:27:01.716]                           computeRestarts <- base::computeRestarts
[10:27:01.716]                           grepl <- base::grepl
[10:27:01.716]                           restarts <- computeRestarts(cond)
[10:27:01.716]                           for (restart in restarts) {
[10:27:01.716]                             name <- restart$name
[10:27:01.716]                             if (is.null(name)) 
[10:27:01.716]                               next
[10:27:01.716]                             if (!grepl(pattern, name)) 
[10:27:01.716]                               next
[10:27:01.716]                             invokeRestart(restart)
[10:27:01.716]                             muffled <- TRUE
[10:27:01.716]                             break
[10:27:01.716]                           }
[10:27:01.716]                         }
[10:27:01.716]                       }
[10:27:01.716]                       invisible(muffled)
[10:27:01.716]                     }
[10:27:01.716]                     muffleCondition(cond, pattern = "^muffle")
[10:27:01.716]                   }
[10:27:01.716]                 }
[10:27:01.716]                 else {
[10:27:01.716]                   if (TRUE) {
[10:27:01.716]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:01.716]                     {
[10:27:01.716]                       inherits <- base::inherits
[10:27:01.716]                       invokeRestart <- base::invokeRestart
[10:27:01.716]                       is.null <- base::is.null
[10:27:01.716]                       muffled <- FALSE
[10:27:01.716]                       if (inherits(cond, "message")) {
[10:27:01.716]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:01.716]                         if (muffled) 
[10:27:01.716]                           invokeRestart("muffleMessage")
[10:27:01.716]                       }
[10:27:01.716]                       else if (inherits(cond, "warning")) {
[10:27:01.716]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:01.716]                         if (muffled) 
[10:27:01.716]                           invokeRestart("muffleWarning")
[10:27:01.716]                       }
[10:27:01.716]                       else if (inherits(cond, "condition")) {
[10:27:01.716]                         if (!is.null(pattern)) {
[10:27:01.716]                           computeRestarts <- base::computeRestarts
[10:27:01.716]                           grepl <- base::grepl
[10:27:01.716]                           restarts <- computeRestarts(cond)
[10:27:01.716]                           for (restart in restarts) {
[10:27:01.716]                             name <- restart$name
[10:27:01.716]                             if (is.null(name)) 
[10:27:01.716]                               next
[10:27:01.716]                             if (!grepl(pattern, name)) 
[10:27:01.716]                               next
[10:27:01.716]                             invokeRestart(restart)
[10:27:01.716]                             muffled <- TRUE
[10:27:01.716]                             break
[10:27:01.716]                           }
[10:27:01.716]                         }
[10:27:01.716]                       }
[10:27:01.716]                       invisible(muffled)
[10:27:01.716]                     }
[10:27:01.716]                     muffleCondition(cond, pattern = "^muffle")
[10:27:01.716]                   }
[10:27:01.716]                 }
[10:27:01.716]             }
[10:27:01.716]         }))
[10:27:01.716]     }, error = function(ex) {
[10:27:01.716]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:01.716]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:01.716]                 ...future.rng), started = ...future.startTime, 
[10:27:01.716]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:01.716]             version = "1.8"), class = "FutureResult")
[10:27:01.716]     }, finally = {
[10:27:01.716]         if (!identical(...future.workdir, getwd())) 
[10:27:01.716]             setwd(...future.workdir)
[10:27:01.716]         {
[10:27:01.716]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:01.716]                 ...future.oldOptions$nwarnings <- NULL
[10:27:01.716]             }
[10:27:01.716]             base::options(...future.oldOptions)
[10:27:01.716]             if (.Platform$OS.type == "windows") {
[10:27:01.716]                 old_names <- names(...future.oldEnvVars)
[10:27:01.716]                 envs <- base::Sys.getenv()
[10:27:01.716]                 names <- names(envs)
[10:27:01.716]                 common <- intersect(names, old_names)
[10:27:01.716]                 added <- setdiff(names, old_names)
[10:27:01.716]                 removed <- setdiff(old_names, names)
[10:27:01.716]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:01.716]                   envs[common]]
[10:27:01.716]                 NAMES <- toupper(changed)
[10:27:01.716]                 args <- list()
[10:27:01.716]                 for (kk in seq_along(NAMES)) {
[10:27:01.716]                   name <- changed[[kk]]
[10:27:01.716]                   NAME <- NAMES[[kk]]
[10:27:01.716]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:01.716]                     next
[10:27:01.716]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:01.716]                 }
[10:27:01.716]                 NAMES <- toupper(added)
[10:27:01.716]                 for (kk in seq_along(NAMES)) {
[10:27:01.716]                   name <- added[[kk]]
[10:27:01.716]                   NAME <- NAMES[[kk]]
[10:27:01.716]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:01.716]                     next
[10:27:01.716]                   args[[name]] <- ""
[10:27:01.716]                 }
[10:27:01.716]                 NAMES <- toupper(removed)
[10:27:01.716]                 for (kk in seq_along(NAMES)) {
[10:27:01.716]                   name <- removed[[kk]]
[10:27:01.716]                   NAME <- NAMES[[kk]]
[10:27:01.716]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:01.716]                     next
[10:27:01.716]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:01.716]                 }
[10:27:01.716]                 if (length(args) > 0) 
[10:27:01.716]                   base::do.call(base::Sys.setenv, args = args)
[10:27:01.716]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:01.716]             }
[10:27:01.716]             else {
[10:27:01.716]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:01.716]             }
[10:27:01.716]             {
[10:27:01.716]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:01.716]                   0L) {
[10:27:01.716]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:01.716]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:01.716]                   base::options(opts)
[10:27:01.716]                 }
[10:27:01.716]                 {
[10:27:01.716]                   {
[10:27:01.716]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:01.716]                     NULL
[10:27:01.716]                   }
[10:27:01.716]                   options(future.plan = NULL)
[10:27:01.716]                   if (is.na(NA_character_)) 
[10:27:01.716]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:01.716]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:01.716]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:27:01.716]                     envir = parent.frame()) 
[10:27:01.716]                   {
[10:27:01.716]                     default_workers <- missing(workers)
[10:27:01.716]                     if (is.function(workers)) 
[10:27:01.716]                       workers <- workers()
[10:27:01.716]                     workers <- structure(as.integer(workers), 
[10:27:01.716]                       class = class(workers))
[10:27:01.716]                     stop_if_not(is.finite(workers), workers >= 
[10:27:01.716]                       1L)
[10:27:01.716]                     if ((workers == 1L && !inherits(workers, 
[10:27:01.716]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:27:01.716]                       if (default_workers) 
[10:27:01.716]                         supportsMulticore(warn = TRUE)
[10:27:01.716]                       return(sequential(..., envir = envir))
[10:27:01.716]                     }
[10:27:01.716]                     oopts <- options(mc.cores = workers)
[10:27:01.716]                     on.exit(options(oopts))
[10:27:01.716]                     future <- MulticoreFuture(..., workers = workers, 
[10:27:01.716]                       envir = envir)
[10:27:01.716]                     if (!future$lazy) 
[10:27:01.716]                       future <- run(future)
[10:27:01.716]                     invisible(future)
[10:27:01.716]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:01.716]                 }
[10:27:01.716]             }
[10:27:01.716]         }
[10:27:01.716]     })
[10:27:01.716]     if (TRUE) {
[10:27:01.716]         base::sink(type = "output", split = FALSE)
[10:27:01.716]         if (TRUE) {
[10:27:01.716]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:01.716]         }
[10:27:01.716]         else {
[10:27:01.716]             ...future.result["stdout"] <- base::list(NULL)
[10:27:01.716]         }
[10:27:01.716]         base::close(...future.stdout)
[10:27:01.716]         ...future.stdout <- NULL
[10:27:01.716]     }
[10:27:01.716]     ...future.result$conditions <- ...future.conditions
[10:27:01.716]     ...future.result$finished <- base::Sys.time()
[10:27:01.716]     ...future.result
[10:27:01.716] }
[10:27:01.720] requestCore(): workers = 2
[10:27:01.720] Poll #1 (0): usedCores() = 2, workers = 2
[10:27:01.731] result() for MulticoreFuture ...
[10:27:01.736] result() for MulticoreFuture ...
[10:27:01.736] result() for MulticoreFuture ... done
[10:27:01.736] result() for MulticoreFuture ... done
[10:27:01.737] result() for MulticoreFuture ...
[10:27:01.737] result() for MulticoreFuture ... done
[10:27:01.740] MulticoreFuture started
[10:27:01.741] - Launch lazy future ... done
[10:27:01.742] run() for ‘MulticoreFuture’ ... done
[10:27:01.742] plan(): Setting new future strategy stack:
[10:27:01.742] getGlobalsAndPackages() ...
[10:27:01.743] Searching for globals...
[10:27:01.743] List of future strategies:
[10:27:01.743] 1. sequential:
[10:27:01.743]    - args: function (..., envir = parent.frame())
[10:27:01.743]    - tweaked: FALSE
[10:27:01.743]    - call: NULL
[10:27:01.744] plan(): nbrOfWorkers() = 1
[10:27:01.746] - globals found: [2] ‘{’, ‘Sys.sleep’
[10:27:01.747] Searching for globals ... DONE
[10:27:01.747] Resolving globals: FALSE
[10:27:01.747] plan(): Setting new future strategy stack:
[10:27:01.748] 
[10:27:01.748] 
[10:27:01.748] List of future strategies:
[10:27:01.748] 1. multicore:
[10:27:01.748]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:27:01.748]    - tweaked: FALSE
[10:27:01.748]    - call: plan(strategy)
[10:27:01.748] getGlobalsAndPackages() ... DONE
[10:27:01.749] run() for ‘Future’ ...
[10:27:01.749] - state: ‘created’
[10:27:01.749] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:27:01.753] plan(): nbrOfWorkers() = 2
[10:27:01.758] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:01.758] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:27:01.759]   - Field: ‘label’
[10:27:01.759]   - Field: ‘local’
[10:27:01.759]   - Field: ‘owner’
[10:27:01.759]   - Field: ‘envir’
[10:27:01.759]   - Field: ‘workers’
[10:27:01.759]   - Field: ‘packages’
[10:27:01.760]   - Field: ‘gc’
[10:27:01.760]   - Field: ‘job’
[10:27:01.760]   - Field: ‘conditions’
[10:27:01.760]   - Field: ‘expr’
[10:27:01.760]   - Field: ‘uuid’
[10:27:01.760]   - Field: ‘seed’
[10:27:01.761]   - Field: ‘version’
[10:27:01.761]   - Field: ‘result’
[10:27:01.761]   - Field: ‘asynchronous’
[10:27:01.761]   - Field: ‘calls’
[10:27:01.761]   - Field: ‘globals’
[10:27:01.761]   - Field: ‘stdout’
[10:27:01.762]   - Field: ‘earlySignal’
[10:27:01.762]   - Field: ‘lazy’
[10:27:01.762]   - Field: ‘state’
[10:27:01.762] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:27:01.762] - Launch lazy future ...
[10:27:01.763] Packages needed by the future expression (n = 0): <none>
[10:27:01.763] Packages needed by future strategies (n = 0): <none>
[10:27:01.764] {
[10:27:01.764]     {
[10:27:01.764]         {
[10:27:01.764]             ...future.startTime <- base::Sys.time()
[10:27:01.764]             {
[10:27:01.764]                 {
[10:27:01.764]                   {
[10:27:01.764]                     {
[10:27:01.764]                       base::local({
[10:27:01.764]                         has_future <- base::requireNamespace("future", 
[10:27:01.764]                           quietly = TRUE)
[10:27:01.764]                         if (has_future) {
[10:27:01.764]                           ns <- base::getNamespace("future")
[10:27:01.764]                           version <- ns[[".package"]][["version"]]
[10:27:01.764]                           if (is.null(version)) 
[10:27:01.764]                             version <- utils::packageVersion("future")
[10:27:01.764]                         }
[10:27:01.764]                         else {
[10:27:01.764]                           version <- NULL
[10:27:01.764]                         }
[10:27:01.764]                         if (!has_future || version < "1.8.0") {
[10:27:01.764]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:01.764]                             "", base::R.version$version.string), 
[10:27:01.764]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:01.764]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:01.764]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:01.764]                               "release", "version")], collapse = " "), 
[10:27:01.764]                             hostname = base::Sys.info()[["nodename"]])
[10:27:01.764]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:01.764]                             info)
[10:27:01.764]                           info <- base::paste(info, collapse = "; ")
[10:27:01.764]                           if (!has_future) {
[10:27:01.764]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:01.764]                               info)
[10:27:01.764]                           }
[10:27:01.764]                           else {
[10:27:01.764]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:01.764]                               info, version)
[10:27:01.764]                           }
[10:27:01.764]                           base::stop(msg)
[10:27:01.764]                         }
[10:27:01.764]                       })
[10:27:01.764]                     }
[10:27:01.764]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:01.764]                     base::options(mc.cores = 1L)
[10:27:01.764]                   }
[10:27:01.764]                   options(future.plan = NULL)
[10:27:01.764]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:01.764]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:01.764]                 }
[10:27:01.764]                 ...future.workdir <- getwd()
[10:27:01.764]             }
[10:27:01.764]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:01.764]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:01.764]         }
[10:27:01.764]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:01.764]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:01.764]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:01.764]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:01.764]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:01.764]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:01.764]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:01.764]             base::names(...future.oldOptions))
[10:27:01.764]     }
[10:27:01.764]     if (FALSE) {
[10:27:01.764]     }
[10:27:01.764]     else {
[10:27:01.764]         if (TRUE) {
[10:27:01.764]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:01.764]                 open = "w")
[10:27:01.764]         }
[10:27:01.764]         else {
[10:27:01.764]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:01.764]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:01.764]         }
[10:27:01.764]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:01.764]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:01.764]             base::sink(type = "output", split = FALSE)
[10:27:01.764]             base::close(...future.stdout)
[10:27:01.764]         }, add = TRUE)
[10:27:01.764]     }
[10:27:01.764]     ...future.frame <- base::sys.nframe()
[10:27:01.764]     ...future.conditions <- base::list()
[10:27:01.764]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:01.764]     if (FALSE) {
[10:27:01.764]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:01.764]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:01.764]     }
[10:27:01.764]     ...future.result <- base::tryCatch({
[10:27:01.764]         base::withCallingHandlers({
[10:27:01.764]             ...future.value <- base::withVisible(base::local({
[10:27:01.764]                 withCallingHandlers({
[10:27:01.764]                   {
[10:27:01.764]                     Sys.sleep(0.5)
[10:27:01.764]                     2
[10:27:01.764]                   }
[10:27:01.764]                 }, immediateCondition = function(cond) {
[10:27:01.764]                   save_rds <- function (object, pathname, ...) 
[10:27:01.764]                   {
[10:27:01.764]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:27:01.764]                     if (file_test("-f", pathname_tmp)) {
[10:27:01.764]                       fi_tmp <- file.info(pathname_tmp)
[10:27:01.764]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:27:01.764]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:01.764]                         fi_tmp[["mtime"]])
[10:27:01.764]                     }
[10:27:01.764]                     tryCatch({
[10:27:01.764]                       saveRDS(object, file = pathname_tmp, ...)
[10:27:01.764]                     }, error = function(ex) {
[10:27:01.764]                       msg <- conditionMessage(ex)
[10:27:01.764]                       fi_tmp <- file.info(pathname_tmp)
[10:27:01.764]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:27:01.764]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:01.764]                         fi_tmp[["mtime"]], msg)
[10:27:01.764]                       ex$message <- msg
[10:27:01.764]                       stop(ex)
[10:27:01.764]                     })
[10:27:01.764]                     stopifnot(file_test("-f", pathname_tmp))
[10:27:01.764]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:27:01.764]                     if (!res || file_test("-f", pathname_tmp)) {
[10:27:01.764]                       fi_tmp <- file.info(pathname_tmp)
[10:27:01.764]                       fi <- file.info(pathname)
[10:27:01.764]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:27:01.764]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:01.764]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:27:01.764]                         fi[["size"]], fi[["mtime"]])
[10:27:01.764]                       stop(msg)
[10:27:01.764]                     }
[10:27:01.764]                     invisible(pathname)
[10:27:01.764]                   }
[10:27:01.764]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:27:01.764]                     rootPath = tempdir()) 
[10:27:01.764]                   {
[10:27:01.764]                     obj <- list(time = Sys.time(), condition = cond)
[10:27:01.764]                     file <- tempfile(pattern = class(cond)[1], 
[10:27:01.764]                       tmpdir = path, fileext = ".rds")
[10:27:01.764]                     save_rds(obj, file)
[10:27:01.764]                   }
[10:27:01.764]                   saveImmediateCondition(cond, path = "/tmp/RtmpisxSDE/.future/immediateConditions")
[10:27:01.764]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:01.764]                   {
[10:27:01.764]                     inherits <- base::inherits
[10:27:01.764]                     invokeRestart <- base::invokeRestart
[10:27:01.764]                     is.null <- base::is.null
[10:27:01.764]                     muffled <- FALSE
[10:27:01.764]                     if (inherits(cond, "message")) {
[10:27:01.764]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:01.764]                       if (muffled) 
[10:27:01.764]                         invokeRestart("muffleMessage")
[10:27:01.764]                     }
[10:27:01.764]                     else if (inherits(cond, "warning")) {
[10:27:01.764]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:01.764]                       if (muffled) 
[10:27:01.764]                         invokeRestart("muffleWarning")
[10:27:01.764]                     }
[10:27:01.764]                     else if (inherits(cond, "condition")) {
[10:27:01.764]                       if (!is.null(pattern)) {
[10:27:01.764]                         computeRestarts <- base::computeRestarts
[10:27:01.764]                         grepl <- base::grepl
[10:27:01.764]                         restarts <- computeRestarts(cond)
[10:27:01.764]                         for (restart in restarts) {
[10:27:01.764]                           name <- restart$name
[10:27:01.764]                           if (is.null(name)) 
[10:27:01.764]                             next
[10:27:01.764]                           if (!grepl(pattern, name)) 
[10:27:01.764]                             next
[10:27:01.764]                           invokeRestart(restart)
[10:27:01.764]                           muffled <- TRUE
[10:27:01.764]                           break
[10:27:01.764]                         }
[10:27:01.764]                       }
[10:27:01.764]                     }
[10:27:01.764]                     invisible(muffled)
[10:27:01.764]                   }
[10:27:01.764]                   muffleCondition(cond)
[10:27:01.764]                 })
[10:27:01.764]             }))
[10:27:01.764]             future::FutureResult(value = ...future.value$value, 
[10:27:01.764]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:01.764]                   ...future.rng), globalenv = if (FALSE) 
[10:27:01.764]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:01.764]                     ...future.globalenv.names))
[10:27:01.764]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:01.764]         }, condition = base::local({
[10:27:01.764]             c <- base::c
[10:27:01.764]             inherits <- base::inherits
[10:27:01.764]             invokeRestart <- base::invokeRestart
[10:27:01.764]             length <- base::length
[10:27:01.764]             list <- base::list
[10:27:01.764]             seq.int <- base::seq.int
[10:27:01.764]             signalCondition <- base::signalCondition
[10:27:01.764]             sys.calls <- base::sys.calls
[10:27:01.764]             `[[` <- base::`[[`
[10:27:01.764]             `+` <- base::`+`
[10:27:01.764]             `<<-` <- base::`<<-`
[10:27:01.764]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:01.764]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:01.764]                   3L)]
[10:27:01.764]             }
[10:27:01.764]             function(cond) {
[10:27:01.764]                 is_error <- inherits(cond, "error")
[10:27:01.764]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:01.764]                   NULL)
[10:27:01.764]                 if (is_error) {
[10:27:01.764]                   sessionInformation <- function() {
[10:27:01.764]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:01.764]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:01.764]                       search = base::search(), system = base::Sys.info())
[10:27:01.764]                   }
[10:27:01.764]                   ...future.conditions[[length(...future.conditions) + 
[10:27:01.764]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:01.764]                     cond$call), session = sessionInformation(), 
[10:27:01.764]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:01.764]                   signalCondition(cond)
[10:27:01.764]                 }
[10:27:01.764]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:01.764]                 "immediateCondition"))) {
[10:27:01.764]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:01.764]                   ...future.conditions[[length(...future.conditions) + 
[10:27:01.764]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:01.764]                   if (TRUE && !signal) {
[10:27:01.764]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:01.764]                     {
[10:27:01.764]                       inherits <- base::inherits
[10:27:01.764]                       invokeRestart <- base::invokeRestart
[10:27:01.764]                       is.null <- base::is.null
[10:27:01.764]                       muffled <- FALSE
[10:27:01.764]                       if (inherits(cond, "message")) {
[10:27:01.764]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:01.764]                         if (muffled) 
[10:27:01.764]                           invokeRestart("muffleMessage")
[10:27:01.764]                       }
[10:27:01.764]                       else if (inherits(cond, "warning")) {
[10:27:01.764]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:01.764]                         if (muffled) 
[10:27:01.764]                           invokeRestart("muffleWarning")
[10:27:01.764]                       }
[10:27:01.764]                       else if (inherits(cond, "condition")) {
[10:27:01.764]                         if (!is.null(pattern)) {
[10:27:01.764]                           computeRestarts <- base::computeRestarts
[10:27:01.764]                           grepl <- base::grepl
[10:27:01.764]                           restarts <- computeRestarts(cond)
[10:27:01.764]                           for (restart in restarts) {
[10:27:01.764]                             name <- restart$name
[10:27:01.764]                             if (is.null(name)) 
[10:27:01.764]                               next
[10:27:01.764]                             if (!grepl(pattern, name)) 
[10:27:01.764]                               next
[10:27:01.764]                             invokeRestart(restart)
[10:27:01.764]                             muffled <- TRUE
[10:27:01.764]                             break
[10:27:01.764]                           }
[10:27:01.764]                         }
[10:27:01.764]                       }
[10:27:01.764]                       invisible(muffled)
[10:27:01.764]                     }
[10:27:01.764]                     muffleCondition(cond, pattern = "^muffle")
[10:27:01.764]                   }
[10:27:01.764]                 }
[10:27:01.764]                 else {
[10:27:01.764]                   if (TRUE) {
[10:27:01.764]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:01.764]                     {
[10:27:01.764]                       inherits <- base::inherits
[10:27:01.764]                       invokeRestart <- base::invokeRestart
[10:27:01.764]                       is.null <- base::is.null
[10:27:01.764]                       muffled <- FALSE
[10:27:01.764]                       if (inherits(cond, "message")) {
[10:27:01.764]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:01.764]                         if (muffled) 
[10:27:01.764]                           invokeRestart("muffleMessage")
[10:27:01.764]                       }
[10:27:01.764]                       else if (inherits(cond, "warning")) {
[10:27:01.764]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:01.764]                         if (muffled) 
[10:27:01.764]                           invokeRestart("muffleWarning")
[10:27:01.764]                       }
[10:27:01.764]                       else if (inherits(cond, "condition")) {
[10:27:01.764]                         if (!is.null(pattern)) {
[10:27:01.764]                           computeRestarts <- base::computeRestarts
[10:27:01.764]                           grepl <- base::grepl
[10:27:01.764]                           restarts <- computeRestarts(cond)
[10:27:01.764]                           for (restart in restarts) {
[10:27:01.764]                             name <- restart$name
[10:27:01.764]                             if (is.null(name)) 
[10:27:01.764]                               next
[10:27:01.764]                             if (!grepl(pattern, name)) 
[10:27:01.764]                               next
[10:27:01.764]                             invokeRestart(restart)
[10:27:01.764]                             muffled <- TRUE
[10:27:01.764]                             break
[10:27:01.764]                           }
[10:27:01.764]                         }
[10:27:01.764]                       }
[10:27:01.764]                       invisible(muffled)
[10:27:01.764]                     }
[10:27:01.764]                     muffleCondition(cond, pattern = "^muffle")
[10:27:01.764]                   }
[10:27:01.764]                 }
[10:27:01.764]             }
[10:27:01.764]         }))
[10:27:01.764]     }, error = function(ex) {
[10:27:01.764]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:01.764]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:01.764]                 ...future.rng), started = ...future.startTime, 
[10:27:01.764]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:01.764]             version = "1.8"), class = "FutureResult")
[10:27:01.764]     }, finally = {
[10:27:01.764]         if (!identical(...future.workdir, getwd())) 
[10:27:01.764]             setwd(...future.workdir)
[10:27:01.764]         {
[10:27:01.764]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:01.764]                 ...future.oldOptions$nwarnings <- NULL
[10:27:01.764]             }
[10:27:01.764]             base::options(...future.oldOptions)
[10:27:01.764]             if (.Platform$OS.type == "windows") {
[10:27:01.764]                 old_names <- names(...future.oldEnvVars)
[10:27:01.764]                 envs <- base::Sys.getenv()
[10:27:01.764]                 names <- names(envs)
[10:27:01.764]                 common <- intersect(names, old_names)
[10:27:01.764]                 added <- setdiff(names, old_names)
[10:27:01.764]                 removed <- setdiff(old_names, names)
[10:27:01.764]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:01.764]                   envs[common]]
[10:27:01.764]                 NAMES <- toupper(changed)
[10:27:01.764]                 args <- list()
[10:27:01.764]                 for (kk in seq_along(NAMES)) {
[10:27:01.764]                   name <- changed[[kk]]
[10:27:01.764]                   NAME <- NAMES[[kk]]
[10:27:01.764]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:01.764]                     next
[10:27:01.764]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:01.764]                 }
[10:27:01.764]                 NAMES <- toupper(added)
[10:27:01.764]                 for (kk in seq_along(NAMES)) {
[10:27:01.764]                   name <- added[[kk]]
[10:27:01.764]                   NAME <- NAMES[[kk]]
[10:27:01.764]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:01.764]                     next
[10:27:01.764]                   args[[name]] <- ""
[10:27:01.764]                 }
[10:27:01.764]                 NAMES <- toupper(removed)
[10:27:01.764]                 for (kk in seq_along(NAMES)) {
[10:27:01.764]                   name <- removed[[kk]]
[10:27:01.764]                   NAME <- NAMES[[kk]]
[10:27:01.764]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:01.764]                     next
[10:27:01.764]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:01.764]                 }
[10:27:01.764]                 if (length(args) > 0) 
[10:27:01.764]                   base::do.call(base::Sys.setenv, args = args)
[10:27:01.764]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:01.764]             }
[10:27:01.764]             else {
[10:27:01.764]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:01.764]             }
[10:27:01.764]             {
[10:27:01.764]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:01.764]                   0L) {
[10:27:01.764]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:01.764]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:01.764]                   base::options(opts)
[10:27:01.764]                 }
[10:27:01.764]                 {
[10:27:01.764]                   {
[10:27:01.764]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:01.764]                     NULL
[10:27:01.764]                   }
[10:27:01.764]                   options(future.plan = NULL)
[10:27:01.764]                   if (is.na(NA_character_)) 
[10:27:01.764]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:01.764]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:01.764]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:27:01.764]                     envir = parent.frame()) 
[10:27:01.764]                   {
[10:27:01.764]                     default_workers <- missing(workers)
[10:27:01.764]                     if (is.function(workers)) 
[10:27:01.764]                       workers <- workers()
[10:27:01.764]                     workers <- structure(as.integer(workers), 
[10:27:01.764]                       class = class(workers))
[10:27:01.764]                     stop_if_not(is.finite(workers), workers >= 
[10:27:01.764]                       1L)
[10:27:01.764]                     if ((workers == 1L && !inherits(workers, 
[10:27:01.764]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:27:01.764]                       if (default_workers) 
[10:27:01.764]                         supportsMulticore(warn = TRUE)
[10:27:01.764]                       return(sequential(..., envir = envir))
[10:27:01.764]                     }
[10:27:01.764]                     oopts <- options(mc.cores = workers)
[10:27:01.764]                     on.exit(options(oopts))
[10:27:01.764]                     future <- MulticoreFuture(..., workers = workers, 
[10:27:01.764]                       envir = envir)
[10:27:01.764]                     if (!future$lazy) 
[10:27:01.764]                       future <- run(future)
[10:27:01.764]                     invisible(future)
[10:27:01.764]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:01.764]                 }
[10:27:01.764]             }
[10:27:01.764]         }
[10:27:01.764]     })
[10:27:01.764]     if (TRUE) {
[10:27:01.764]         base::sink(type = "output", split = FALSE)
[10:27:01.764]         if (TRUE) {
[10:27:01.764]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:01.764]         }
[10:27:01.764]         else {
[10:27:01.764]             ...future.result["stdout"] <- base::list(NULL)
[10:27:01.764]         }
[10:27:01.764]         base::close(...future.stdout)
[10:27:01.764]         ...future.stdout <- NULL
[10:27:01.764]     }
[10:27:01.764]     ...future.result$conditions <- ...future.conditions
[10:27:01.764]     ...future.result$finished <- base::Sys.time()
[10:27:01.764]     ...future.result
[10:27:01.764] }
[10:27:01.767] requestCore(): workers = 2
[10:27:01.768] Poll #1 (0): usedCores() = 2, workers = 2
[10:27:01.779] result() for MulticoreFuture ...
[10:27:01.780] result() for MulticoreFuture ...
[10:27:01.780] result() for MulticoreFuture ... done
[10:27:01.780] result() for MulticoreFuture ... done
[10:27:01.780] result() for MulticoreFuture ...
[10:27:01.780] result() for MulticoreFuture ... done
[10:27:01.783] MulticoreFuture started
[10:27:01.784] - Launch lazy future ... done
[10:27:01.784] run() for ‘MulticoreFuture’ ... done
[10:27:01.785] plan(): Setting new future strategy stack:
[10:27:01.786] resolve() on list ...
[10:27:01.786]  recursive: 0
[10:27:01.786]  length: 1
[10:27:01.786] 
[10:27:01.785] List of future strategies:
[10:27:01.785] 1. sequential:
[10:27:01.785]    - args: function (..., envir = parent.frame())
[10:27:01.785]    - tweaked: FALSE
[10:27:01.785]    - call: NULL
[10:27:01.787] plan(): nbrOfWorkers() = 1
[10:27:01.787] Future #1
[10:27:01.787]  length: 0 (resolved future 1)
[10:27:01.788] resolve() on list ... DONE
[10:27:01.788] resolve() on list ...
[10:27:01.789]  recursive: 0
[10:27:01.789]  length: 1
[10:27:01.789] 
[10:27:02.290] plan(): Setting new future strategy stack:
[10:27:02.291] List of future strategies:
[10:27:02.291] 1. multicore:
[10:27:02.291]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:27:02.291]    - tweaked: FALSE
[10:27:02.291]    - call: plan(strategy)
[10:27:02.297] plan(): nbrOfWorkers() = 2
[10:27:02.304] Future #1
[10:27:02.304]  length: 0 (resolved future 1)
[10:27:02.305] resolve() on list ... DONE
[10:27:02.305] resolve() on list ...
[10:27:02.305]  recursive: 0
[10:27:02.306]  length: 1
[10:27:02.306] 
[10:27:02.306]  length: 0 (resolved future 1)
[10:27:02.306] resolve() on list ... DONE
[10:27:02.306] resolve() on list ...
[10:27:02.307]  recursive: 0
[10:27:02.307]  length: 4
[10:27:02.307] 
[10:27:02.307] Future #1
[10:27:02.308]  length: 3 (resolved future 1)
[10:27:02.308] Future #2
[10:27:02.308]  length: 2 (resolved future 2)
[10:27:02.308]  length: 1 (resolved future 3)
[10:27:02.309]  length: 0 (resolved future 4)
[10:27:02.309] resolve() on list ... DONE
[10:27:02.309] resolve() on list ...
[10:27:02.309]  recursive: 0
[10:27:02.310]  length: 4
[10:27:02.310] 
[10:27:02.310] Future #1
[10:27:02.310]  length: 3 (resolved future 1)
[10:27:02.310] Future #2
[10:27:02.311]  length: 2 (resolved future 2)
[10:27:02.311]  length: 1 (resolved future 3)
[10:27:02.311]  length: 0 (resolved future 4)
[10:27:02.311] resolve() on list ... DONE
[10:27:02.311] resolve() on list ...
[10:27:02.312]  recursive: 0
[10:27:02.312]  length: 1
[10:27:02.312] 
[10:27:02.312]  length: 0 (resolved future 1)
[10:27:02.312] resolve() on list ... DONE
[10:27:02.312] getGlobalsAndPackages() ...
[10:27:02.313] Searching for globals...
[10:27:02.315] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:27:02.315] Searching for globals ... DONE
[10:27:02.315] Resolving globals: FALSE
[10:27:02.316] The total size of the 1 globals is 56 bytes (56 bytes)
[10:27:02.316] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[10:27:02.316] - globals: [1] ‘kk’
[10:27:02.317] 
[10:27:02.317] getGlobalsAndPackages() ... DONE
[10:27:02.317] run() for ‘Future’ ...
[10:27:02.317] - state: ‘created’
[10:27:02.318] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:27:02.323] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:02.324] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:27:02.324]   - Field: ‘label’
[10:27:02.324]   - Field: ‘local’
[10:27:02.324]   - Field: ‘owner’
[10:27:02.325]   - Field: ‘envir’
[10:27:02.325]   - Field: ‘workers’
[10:27:02.325]   - Field: ‘packages’
[10:27:02.325]   - Field: ‘gc’
[10:27:02.325]   - Field: ‘job’
[10:27:02.325]   - Field: ‘conditions’
[10:27:02.326]   - Field: ‘expr’
[10:27:02.326]   - Field: ‘uuid’
[10:27:02.326]   - Field: ‘seed’
[10:27:02.326]   - Field: ‘version’
[10:27:02.326]   - Field: ‘result’
[10:27:02.329]   - Field: ‘asynchronous’
[10:27:02.330]   - Field: ‘calls’
[10:27:02.330]   - Field: ‘globals’
[10:27:02.330]   - Field: ‘stdout’
[10:27:02.331]   - Field: ‘earlySignal’
[10:27:02.331]   - Field: ‘lazy’
[10:27:02.331]   - Field: ‘state’
[10:27:02.331] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:27:02.332] - Launch lazy future ...
[10:27:02.332] Packages needed by the future expression (n = 0): <none>
[10:27:02.333] Packages needed by future strategies (n = 0): <none>
[10:27:02.334] {
[10:27:02.334]     {
[10:27:02.334]         {
[10:27:02.334]             ...future.startTime <- base::Sys.time()
[10:27:02.334]             {
[10:27:02.334]                 {
[10:27:02.334]                   {
[10:27:02.334]                     {
[10:27:02.334]                       base::local({
[10:27:02.334]                         has_future <- base::requireNamespace("future", 
[10:27:02.334]                           quietly = TRUE)
[10:27:02.334]                         if (has_future) {
[10:27:02.334]                           ns <- base::getNamespace("future")
[10:27:02.334]                           version <- ns[[".package"]][["version"]]
[10:27:02.334]                           if (is.null(version)) 
[10:27:02.334]                             version <- utils::packageVersion("future")
[10:27:02.334]                         }
[10:27:02.334]                         else {
[10:27:02.334]                           version <- NULL
[10:27:02.334]                         }
[10:27:02.334]                         if (!has_future || version < "1.8.0") {
[10:27:02.334]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:02.334]                             "", base::R.version$version.string), 
[10:27:02.334]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:02.334]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:02.334]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:02.334]                               "release", "version")], collapse = " "), 
[10:27:02.334]                             hostname = base::Sys.info()[["nodename"]])
[10:27:02.334]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:02.334]                             info)
[10:27:02.334]                           info <- base::paste(info, collapse = "; ")
[10:27:02.334]                           if (!has_future) {
[10:27:02.334]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:02.334]                               info)
[10:27:02.334]                           }
[10:27:02.334]                           else {
[10:27:02.334]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:02.334]                               info, version)
[10:27:02.334]                           }
[10:27:02.334]                           base::stop(msg)
[10:27:02.334]                         }
[10:27:02.334]                       })
[10:27:02.334]                     }
[10:27:02.334]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:02.334]                     base::options(mc.cores = 1L)
[10:27:02.334]                   }
[10:27:02.334]                   options(future.plan = NULL)
[10:27:02.334]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:02.334]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:02.334]                 }
[10:27:02.334]                 ...future.workdir <- getwd()
[10:27:02.334]             }
[10:27:02.334]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:02.334]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:02.334]         }
[10:27:02.334]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:02.334]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:02.334]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:02.334]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:02.334]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:02.334]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:02.334]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:02.334]             base::names(...future.oldOptions))
[10:27:02.334]     }
[10:27:02.334]     if (FALSE) {
[10:27:02.334]     }
[10:27:02.334]     else {
[10:27:02.334]         if (TRUE) {
[10:27:02.334]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:02.334]                 open = "w")
[10:27:02.334]         }
[10:27:02.334]         else {
[10:27:02.334]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:02.334]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:02.334]         }
[10:27:02.334]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:02.334]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:02.334]             base::sink(type = "output", split = FALSE)
[10:27:02.334]             base::close(...future.stdout)
[10:27:02.334]         }, add = TRUE)
[10:27:02.334]     }
[10:27:02.334]     ...future.frame <- base::sys.nframe()
[10:27:02.334]     ...future.conditions <- base::list()
[10:27:02.334]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:02.334]     if (FALSE) {
[10:27:02.334]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:02.334]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:02.334]     }
[10:27:02.334]     ...future.result <- base::tryCatch({
[10:27:02.334]         base::withCallingHandlers({
[10:27:02.334]             ...future.value <- base::withVisible(base::local({
[10:27:02.334]                 withCallingHandlers({
[10:27:02.334]                   {
[10:27:02.334]                     Sys.sleep(0.1)
[10:27:02.334]                     kk
[10:27:02.334]                   }
[10:27:02.334]                 }, immediateCondition = function(cond) {
[10:27:02.334]                   save_rds <- function (object, pathname, ...) 
[10:27:02.334]                   {
[10:27:02.334]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:27:02.334]                     if (file_test("-f", pathname_tmp)) {
[10:27:02.334]                       fi_tmp <- file.info(pathname_tmp)
[10:27:02.334]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:27:02.334]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:02.334]                         fi_tmp[["mtime"]])
[10:27:02.334]                     }
[10:27:02.334]                     tryCatch({
[10:27:02.334]                       saveRDS(object, file = pathname_tmp, ...)
[10:27:02.334]                     }, error = function(ex) {
[10:27:02.334]                       msg <- conditionMessage(ex)
[10:27:02.334]                       fi_tmp <- file.info(pathname_tmp)
[10:27:02.334]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:27:02.334]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:02.334]                         fi_tmp[["mtime"]], msg)
[10:27:02.334]                       ex$message <- msg
[10:27:02.334]                       stop(ex)
[10:27:02.334]                     })
[10:27:02.334]                     stopifnot(file_test("-f", pathname_tmp))
[10:27:02.334]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:27:02.334]                     if (!res || file_test("-f", pathname_tmp)) {
[10:27:02.334]                       fi_tmp <- file.info(pathname_tmp)
[10:27:02.334]                       fi <- file.info(pathname)
[10:27:02.334]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:27:02.334]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:02.334]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:27:02.334]                         fi[["size"]], fi[["mtime"]])
[10:27:02.334]                       stop(msg)
[10:27:02.334]                     }
[10:27:02.334]                     invisible(pathname)
[10:27:02.334]                   }
[10:27:02.334]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:27:02.334]                     rootPath = tempdir()) 
[10:27:02.334]                   {
[10:27:02.334]                     obj <- list(time = Sys.time(), condition = cond)
[10:27:02.334]                     file <- tempfile(pattern = class(cond)[1], 
[10:27:02.334]                       tmpdir = path, fileext = ".rds")
[10:27:02.334]                     save_rds(obj, file)
[10:27:02.334]                   }
[10:27:02.334]                   saveImmediateCondition(cond, path = "/tmp/RtmpisxSDE/.future/immediateConditions")
[10:27:02.334]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:02.334]                   {
[10:27:02.334]                     inherits <- base::inherits
[10:27:02.334]                     invokeRestart <- base::invokeRestart
[10:27:02.334]                     is.null <- base::is.null
[10:27:02.334]                     muffled <- FALSE
[10:27:02.334]                     if (inherits(cond, "message")) {
[10:27:02.334]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:02.334]                       if (muffled) 
[10:27:02.334]                         invokeRestart("muffleMessage")
[10:27:02.334]                     }
[10:27:02.334]                     else if (inherits(cond, "warning")) {
[10:27:02.334]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:02.334]                       if (muffled) 
[10:27:02.334]                         invokeRestart("muffleWarning")
[10:27:02.334]                     }
[10:27:02.334]                     else if (inherits(cond, "condition")) {
[10:27:02.334]                       if (!is.null(pattern)) {
[10:27:02.334]                         computeRestarts <- base::computeRestarts
[10:27:02.334]                         grepl <- base::grepl
[10:27:02.334]                         restarts <- computeRestarts(cond)
[10:27:02.334]                         for (restart in restarts) {
[10:27:02.334]                           name <- restart$name
[10:27:02.334]                           if (is.null(name)) 
[10:27:02.334]                             next
[10:27:02.334]                           if (!grepl(pattern, name)) 
[10:27:02.334]                             next
[10:27:02.334]                           invokeRestart(restart)
[10:27:02.334]                           muffled <- TRUE
[10:27:02.334]                           break
[10:27:02.334]                         }
[10:27:02.334]                       }
[10:27:02.334]                     }
[10:27:02.334]                     invisible(muffled)
[10:27:02.334]                   }
[10:27:02.334]                   muffleCondition(cond)
[10:27:02.334]                 })
[10:27:02.334]             }))
[10:27:02.334]             future::FutureResult(value = ...future.value$value, 
[10:27:02.334]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:02.334]                   ...future.rng), globalenv = if (FALSE) 
[10:27:02.334]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:02.334]                     ...future.globalenv.names))
[10:27:02.334]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:02.334]         }, condition = base::local({
[10:27:02.334]             c <- base::c
[10:27:02.334]             inherits <- base::inherits
[10:27:02.334]             invokeRestart <- base::invokeRestart
[10:27:02.334]             length <- base::length
[10:27:02.334]             list <- base::list
[10:27:02.334]             seq.int <- base::seq.int
[10:27:02.334]             signalCondition <- base::signalCondition
[10:27:02.334]             sys.calls <- base::sys.calls
[10:27:02.334]             `[[` <- base::`[[`
[10:27:02.334]             `+` <- base::`+`
[10:27:02.334]             `<<-` <- base::`<<-`
[10:27:02.334]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:02.334]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:02.334]                   3L)]
[10:27:02.334]             }
[10:27:02.334]             function(cond) {
[10:27:02.334]                 is_error <- inherits(cond, "error")
[10:27:02.334]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:02.334]                   NULL)
[10:27:02.334]                 if (is_error) {
[10:27:02.334]                   sessionInformation <- function() {
[10:27:02.334]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:02.334]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:02.334]                       search = base::search(), system = base::Sys.info())
[10:27:02.334]                   }
[10:27:02.334]                   ...future.conditions[[length(...future.conditions) + 
[10:27:02.334]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:02.334]                     cond$call), session = sessionInformation(), 
[10:27:02.334]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:02.334]                   signalCondition(cond)
[10:27:02.334]                 }
[10:27:02.334]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:02.334]                 "immediateCondition"))) {
[10:27:02.334]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:02.334]                   ...future.conditions[[length(...future.conditions) + 
[10:27:02.334]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:02.334]                   if (TRUE && !signal) {
[10:27:02.334]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:02.334]                     {
[10:27:02.334]                       inherits <- base::inherits
[10:27:02.334]                       invokeRestart <- base::invokeRestart
[10:27:02.334]                       is.null <- base::is.null
[10:27:02.334]                       muffled <- FALSE
[10:27:02.334]                       if (inherits(cond, "message")) {
[10:27:02.334]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:02.334]                         if (muffled) 
[10:27:02.334]                           invokeRestart("muffleMessage")
[10:27:02.334]                       }
[10:27:02.334]                       else if (inherits(cond, "warning")) {
[10:27:02.334]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:02.334]                         if (muffled) 
[10:27:02.334]                           invokeRestart("muffleWarning")
[10:27:02.334]                       }
[10:27:02.334]                       else if (inherits(cond, "condition")) {
[10:27:02.334]                         if (!is.null(pattern)) {
[10:27:02.334]                           computeRestarts <- base::computeRestarts
[10:27:02.334]                           grepl <- base::grepl
[10:27:02.334]                           restarts <- computeRestarts(cond)
[10:27:02.334]                           for (restart in restarts) {
[10:27:02.334]                             name <- restart$name
[10:27:02.334]                             if (is.null(name)) 
[10:27:02.334]                               next
[10:27:02.334]                             if (!grepl(pattern, name)) 
[10:27:02.334]                               next
[10:27:02.334]                             invokeRestart(restart)
[10:27:02.334]                             muffled <- TRUE
[10:27:02.334]                             break
[10:27:02.334]                           }
[10:27:02.334]                         }
[10:27:02.334]                       }
[10:27:02.334]                       invisible(muffled)
[10:27:02.334]                     }
[10:27:02.334]                     muffleCondition(cond, pattern = "^muffle")
[10:27:02.334]                   }
[10:27:02.334]                 }
[10:27:02.334]                 else {
[10:27:02.334]                   if (TRUE) {
[10:27:02.334]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:02.334]                     {
[10:27:02.334]                       inherits <- base::inherits
[10:27:02.334]                       invokeRestart <- base::invokeRestart
[10:27:02.334]                       is.null <- base::is.null
[10:27:02.334]                       muffled <- FALSE
[10:27:02.334]                       if (inherits(cond, "message")) {
[10:27:02.334]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:02.334]                         if (muffled) 
[10:27:02.334]                           invokeRestart("muffleMessage")
[10:27:02.334]                       }
[10:27:02.334]                       else if (inherits(cond, "warning")) {
[10:27:02.334]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:02.334]                         if (muffled) 
[10:27:02.334]                           invokeRestart("muffleWarning")
[10:27:02.334]                       }
[10:27:02.334]                       else if (inherits(cond, "condition")) {
[10:27:02.334]                         if (!is.null(pattern)) {
[10:27:02.334]                           computeRestarts <- base::computeRestarts
[10:27:02.334]                           grepl <- base::grepl
[10:27:02.334]                           restarts <- computeRestarts(cond)
[10:27:02.334]                           for (restart in restarts) {
[10:27:02.334]                             name <- restart$name
[10:27:02.334]                             if (is.null(name)) 
[10:27:02.334]                               next
[10:27:02.334]                             if (!grepl(pattern, name)) 
[10:27:02.334]                               next
[10:27:02.334]                             invokeRestart(restart)
[10:27:02.334]                             muffled <- TRUE
[10:27:02.334]                             break
[10:27:02.334]                           }
[10:27:02.334]                         }
[10:27:02.334]                       }
[10:27:02.334]                       invisible(muffled)
[10:27:02.334]                     }
[10:27:02.334]                     muffleCondition(cond, pattern = "^muffle")
[10:27:02.334]                   }
[10:27:02.334]                 }
[10:27:02.334]             }
[10:27:02.334]         }))
[10:27:02.334]     }, error = function(ex) {
[10:27:02.334]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:02.334]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:02.334]                 ...future.rng), started = ...future.startTime, 
[10:27:02.334]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:02.334]             version = "1.8"), class = "FutureResult")
[10:27:02.334]     }, finally = {
[10:27:02.334]         if (!identical(...future.workdir, getwd())) 
[10:27:02.334]             setwd(...future.workdir)
[10:27:02.334]         {
[10:27:02.334]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:02.334]                 ...future.oldOptions$nwarnings <- NULL
[10:27:02.334]             }
[10:27:02.334]             base::options(...future.oldOptions)
[10:27:02.334]             if (.Platform$OS.type == "windows") {
[10:27:02.334]                 old_names <- names(...future.oldEnvVars)
[10:27:02.334]                 envs <- base::Sys.getenv()
[10:27:02.334]                 names <- names(envs)
[10:27:02.334]                 common <- intersect(names, old_names)
[10:27:02.334]                 added <- setdiff(names, old_names)
[10:27:02.334]                 removed <- setdiff(old_names, names)
[10:27:02.334]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:02.334]                   envs[common]]
[10:27:02.334]                 NAMES <- toupper(changed)
[10:27:02.334]                 args <- list()
[10:27:02.334]                 for (kk in seq_along(NAMES)) {
[10:27:02.334]                   name <- changed[[kk]]
[10:27:02.334]                   NAME <- NAMES[[kk]]
[10:27:02.334]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:02.334]                     next
[10:27:02.334]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:02.334]                 }
[10:27:02.334]                 NAMES <- toupper(added)
[10:27:02.334]                 for (kk in seq_along(NAMES)) {
[10:27:02.334]                   name <- added[[kk]]
[10:27:02.334]                   NAME <- NAMES[[kk]]
[10:27:02.334]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:02.334]                     next
[10:27:02.334]                   args[[name]] <- ""
[10:27:02.334]                 }
[10:27:02.334]                 NAMES <- toupper(removed)
[10:27:02.334]                 for (kk in seq_along(NAMES)) {
[10:27:02.334]                   name <- removed[[kk]]
[10:27:02.334]                   NAME <- NAMES[[kk]]
[10:27:02.334]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:02.334]                     next
[10:27:02.334]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:02.334]                 }
[10:27:02.334]                 if (length(args) > 0) 
[10:27:02.334]                   base::do.call(base::Sys.setenv, args = args)
[10:27:02.334]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:02.334]             }
[10:27:02.334]             else {
[10:27:02.334]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:02.334]             }
[10:27:02.334]             {
[10:27:02.334]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:02.334]                   0L) {
[10:27:02.334]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:02.334]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:02.334]                   base::options(opts)
[10:27:02.334]                 }
[10:27:02.334]                 {
[10:27:02.334]                   {
[10:27:02.334]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:02.334]                     NULL
[10:27:02.334]                   }
[10:27:02.334]                   options(future.plan = NULL)
[10:27:02.334]                   if (is.na(NA_character_)) 
[10:27:02.334]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:02.334]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:02.334]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:27:02.334]                     envir = parent.frame()) 
[10:27:02.334]                   {
[10:27:02.334]                     default_workers <- missing(workers)
[10:27:02.334]                     if (is.function(workers)) 
[10:27:02.334]                       workers <- workers()
[10:27:02.334]                     workers <- structure(as.integer(workers), 
[10:27:02.334]                       class = class(workers))
[10:27:02.334]                     stop_if_not(is.finite(workers), workers >= 
[10:27:02.334]                       1L)
[10:27:02.334]                     if ((workers == 1L && !inherits(workers, 
[10:27:02.334]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:27:02.334]                       if (default_workers) 
[10:27:02.334]                         supportsMulticore(warn = TRUE)
[10:27:02.334]                       return(sequential(..., envir = envir))
[10:27:02.334]                     }
[10:27:02.334]                     oopts <- options(mc.cores = workers)
[10:27:02.334]                     on.exit(options(oopts))
[10:27:02.334]                     future <- MulticoreFuture(..., workers = workers, 
[10:27:02.334]                       envir = envir)
[10:27:02.334]                     if (!future$lazy) 
[10:27:02.334]                       future <- run(future)
[10:27:02.334]                     invisible(future)
[10:27:02.334]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:02.334]                 }
[10:27:02.334]             }
[10:27:02.334]         }
[10:27:02.334]     })
[10:27:02.334]     if (TRUE) {
[10:27:02.334]         base::sink(type = "output", split = FALSE)
[10:27:02.334]         if (TRUE) {
[10:27:02.334]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:02.334]         }
[10:27:02.334]         else {
[10:27:02.334]             ...future.result["stdout"] <- base::list(NULL)
[10:27:02.334]         }
[10:27:02.334]         base::close(...future.stdout)
[10:27:02.334]         ...future.stdout <- NULL
[10:27:02.334]     }
[10:27:02.334]     ...future.result$conditions <- ...future.conditions
[10:27:02.334]     ...future.result$finished <- base::Sys.time()
[10:27:02.334]     ...future.result
[10:27:02.334] }
[10:27:02.336] assign_globals() ...
[10:27:02.337] List of 1
[10:27:02.337]  $ kk: int 1
[10:27:02.337]  - attr(*, "where")=List of 1
[10:27:02.337]   ..$ kk:<environment: R_EmptyEnv> 
[10:27:02.337]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:27:02.337]  - attr(*, "resolved")= logi FALSE
[10:27:02.337]  - attr(*, "total_size")= num 56
[10:27:02.337]  - attr(*, "already-done")= logi TRUE
[10:27:02.341] - copied ‘kk’ to environment
[10:27:02.341] assign_globals() ... done
[10:27:02.342] requestCore(): workers = 2
[10:27:02.342] Poll #1 (0): usedCores() = 2, workers = 2
[10:27:02.354] result() for MulticoreFuture ...
[10:27:02.356] result() for MulticoreFuture ...
[10:27:02.356] result() for MulticoreFuture ... done
[10:27:02.357] result() for MulticoreFuture ... done
[10:27:02.357] result() for MulticoreFuture ...
[10:27:02.358] result() for MulticoreFuture ... done
[10:27:02.361] MulticoreFuture started
[10:27:02.361] - Launch lazy future ... done
[10:27:02.361] run() for ‘MulticoreFuture’ ... done
[10:27:02.362] getGlobalsAndPackages() ...
[10:27:02.362] Searching for globals...
[10:27:02.362] plan(): Setting new future strategy stack:
[10:27:02.362] List of future strategies:
[10:27:02.362] 1. sequential:
[10:27:02.362]    - args: function (..., envir = parent.frame())
[10:27:02.362]    - tweaked: FALSE
[10:27:02.362]    - call: NULL
[10:27:02.363] plan(): nbrOfWorkers() = 1
[10:27:02.364] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:27:02.365] Searching for globals ... DONE
[10:27:02.365] Resolving globals: FALSE
[10:27:02.366] The total size of the 1 globals is 56 bytes (56 bytes)
[10:27:02.367] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[10:27:02.367] - globals: [1] ‘kk’
[10:27:02.367] 
[10:27:02.367] getGlobalsAndPackages() ... DONE
[10:27:02.368] run() for ‘Future’ ...
[10:27:02.368] - state: ‘created’
[10:27:02.368] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:27:02.375] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:02.375] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:27:02.375]   - Field: ‘label’
[10:27:02.375]   - Field: ‘local’
[10:27:02.376]   - Field: ‘owner’
[10:27:02.376]   - Field: ‘envir’
[10:27:02.376]   - Field: ‘workers’
[10:27:02.376]   - Field: ‘packages’
[10:27:02.376]   - Field: ‘gc’
[10:27:02.376]   - Field: ‘job’
[10:27:02.377]   - Field: ‘conditions’
[10:27:02.377]   - Field: ‘expr’
[10:27:02.378]   - Field: ‘uuid’
[10:27:02.378]   - Field: ‘seed’
[10:27:02.378]   - Field: ‘version’
[10:27:02.379]   - Field: ‘result’
[10:27:02.379]   - Field: ‘asynchronous’
[10:27:02.379]   - Field: ‘calls’
[10:27:02.379]   - Field: ‘globals’
[10:27:02.379]   - Field: ‘stdout’
[10:27:02.379]   - Field: ‘earlySignal’
[10:27:02.380]   - Field: ‘lazy’
[10:27:02.380]   - Field: ‘state’
[10:27:02.380] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:27:02.380] - Launch lazy future ...
[10:27:02.381] Packages needed by the future expression (n = 0): <none>
[10:27:02.381] Packages needed by future strategies (n = 0): <none>
[10:27:02.382] {
[10:27:02.382]     {
[10:27:02.382]         {
[10:27:02.382]             ...future.startTime <- base::Sys.time()
[10:27:02.382]             {
[10:27:02.382]                 {
[10:27:02.382]                   {
[10:27:02.382]                     {
[10:27:02.382]                       base::local({
[10:27:02.382]                         has_future <- base::requireNamespace("future", 
[10:27:02.382]                           quietly = TRUE)
[10:27:02.382]                         if (has_future) {
[10:27:02.382]                           ns <- base::getNamespace("future")
[10:27:02.382]                           version <- ns[[".package"]][["version"]]
[10:27:02.382]                           if (is.null(version)) 
[10:27:02.382]                             version <- utils::packageVersion("future")
[10:27:02.382]                         }
[10:27:02.382]                         else {
[10:27:02.382]                           version <- NULL
[10:27:02.382]                         }
[10:27:02.382]                         if (!has_future || version < "1.8.0") {
[10:27:02.382]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:02.382]                             "", base::R.version$version.string), 
[10:27:02.382]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:02.382]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:02.382]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:02.382]                               "release", "version")], collapse = " "), 
[10:27:02.382]                             hostname = base::Sys.info()[["nodename"]])
[10:27:02.382]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:02.382]                             info)
[10:27:02.382]                           info <- base::paste(info, collapse = "; ")
[10:27:02.382]                           if (!has_future) {
[10:27:02.382]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:02.382]                               info)
[10:27:02.382]                           }
[10:27:02.382]                           else {
[10:27:02.382]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:02.382]                               info, version)
[10:27:02.382]                           }
[10:27:02.382]                           base::stop(msg)
[10:27:02.382]                         }
[10:27:02.382]                       })
[10:27:02.382]                     }
[10:27:02.382]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:02.382]                     base::options(mc.cores = 1L)
[10:27:02.382]                   }
[10:27:02.382]                   options(future.plan = NULL)
[10:27:02.382]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:02.382]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:02.382]                 }
[10:27:02.382]                 ...future.workdir <- getwd()
[10:27:02.382]             }
[10:27:02.382]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:02.382]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:02.382]         }
[10:27:02.382]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:02.382]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:02.382]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:02.382]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:02.382]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:02.382]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:02.382]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:02.382]             base::names(...future.oldOptions))
[10:27:02.382]     }
[10:27:02.382]     if (FALSE) {
[10:27:02.382]     }
[10:27:02.382]     else {
[10:27:02.382]         if (TRUE) {
[10:27:02.382]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:02.382]                 open = "w")
[10:27:02.382]         }
[10:27:02.382]         else {
[10:27:02.382]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:02.382]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:02.382]         }
[10:27:02.382]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:02.382]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:02.382]             base::sink(type = "output", split = FALSE)
[10:27:02.382]             base::close(...future.stdout)
[10:27:02.382]         }, add = TRUE)
[10:27:02.382]     }
[10:27:02.382]     ...future.frame <- base::sys.nframe()
[10:27:02.382]     ...future.conditions <- base::list()
[10:27:02.382]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:02.382]     if (FALSE) {
[10:27:02.382]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:02.382]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:02.382]     }
[10:27:02.382]     ...future.result <- base::tryCatch({
[10:27:02.382]         base::withCallingHandlers({
[10:27:02.382]             ...future.value <- base::withVisible(base::local({
[10:27:02.382]                 withCallingHandlers({
[10:27:02.382]                   {
[10:27:02.382]                     Sys.sleep(0.1)
[10:27:02.382]                     kk
[10:27:02.382]                   }
[10:27:02.382]                 }, immediateCondition = function(cond) {
[10:27:02.382]                   save_rds <- function (object, pathname, ...) 
[10:27:02.382]                   {
[10:27:02.382]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:27:02.382]                     if (file_test("-f", pathname_tmp)) {
[10:27:02.382]                       fi_tmp <- file.info(pathname_tmp)
[10:27:02.382]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:27:02.382]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:02.382]                         fi_tmp[["mtime"]])
[10:27:02.382]                     }
[10:27:02.382]                     tryCatch({
[10:27:02.382]                       saveRDS(object, file = pathname_tmp, ...)
[10:27:02.382]                     }, error = function(ex) {
[10:27:02.382]                       msg <- conditionMessage(ex)
[10:27:02.382]                       fi_tmp <- file.info(pathname_tmp)
[10:27:02.382]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:27:02.382]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:02.382]                         fi_tmp[["mtime"]], msg)
[10:27:02.382]                       ex$message <- msg
[10:27:02.382]                       stop(ex)
[10:27:02.382]                     })
[10:27:02.382]                     stopifnot(file_test("-f", pathname_tmp))
[10:27:02.382]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:27:02.382]                     if (!res || file_test("-f", pathname_tmp)) {
[10:27:02.382]                       fi_tmp <- file.info(pathname_tmp)
[10:27:02.382]                       fi <- file.info(pathname)
[10:27:02.382]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:27:02.382]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:02.382]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:27:02.382]                         fi[["size"]], fi[["mtime"]])
[10:27:02.382]                       stop(msg)
[10:27:02.382]                     }
[10:27:02.382]                     invisible(pathname)
[10:27:02.382]                   }
[10:27:02.382]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:27:02.382]                     rootPath = tempdir()) 
[10:27:02.382]                   {
[10:27:02.382]                     obj <- list(time = Sys.time(), condition = cond)
[10:27:02.382]                     file <- tempfile(pattern = class(cond)[1], 
[10:27:02.382]                       tmpdir = path, fileext = ".rds")
[10:27:02.382]                     save_rds(obj, file)
[10:27:02.382]                   }
[10:27:02.382]                   saveImmediateCondition(cond, path = "/tmp/RtmpisxSDE/.future/immediateConditions")
[10:27:02.382]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:02.382]                   {
[10:27:02.382]                     inherits <- base::inherits
[10:27:02.382]                     invokeRestart <- base::invokeRestart
[10:27:02.382]                     is.null <- base::is.null
[10:27:02.382]                     muffled <- FALSE
[10:27:02.382]                     if (inherits(cond, "message")) {
[10:27:02.382]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:02.382]                       if (muffled) 
[10:27:02.382]                         invokeRestart("muffleMessage")
[10:27:02.382]                     }
[10:27:02.382]                     else if (inherits(cond, "warning")) {
[10:27:02.382]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:02.382]                       if (muffled) 
[10:27:02.382]                         invokeRestart("muffleWarning")
[10:27:02.382]                     }
[10:27:02.382]                     else if (inherits(cond, "condition")) {
[10:27:02.382]                       if (!is.null(pattern)) {
[10:27:02.382]                         computeRestarts <- base::computeRestarts
[10:27:02.382]                         grepl <- base::grepl
[10:27:02.382]                         restarts <- computeRestarts(cond)
[10:27:02.382]                         for (restart in restarts) {
[10:27:02.382]                           name <- restart$name
[10:27:02.382]                           if (is.null(name)) 
[10:27:02.382]                             next
[10:27:02.382]                           if (!grepl(pattern, name)) 
[10:27:02.382]                             next
[10:27:02.382]                           invokeRestart(restart)
[10:27:02.382]                           muffled <- TRUE
[10:27:02.382]                           break
[10:27:02.382]                         }
[10:27:02.382]                       }
[10:27:02.382]                     }
[10:27:02.382]                     invisible(muffled)
[10:27:02.382]                   }
[10:27:02.382]                   muffleCondition(cond)
[10:27:02.382]                 })
[10:27:02.382]             }))
[10:27:02.382]             future::FutureResult(value = ...future.value$value, 
[10:27:02.382]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:02.382]                   ...future.rng), globalenv = if (FALSE) 
[10:27:02.382]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:02.382]                     ...future.globalenv.names))
[10:27:02.382]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:02.382]         }, condition = base::local({
[10:27:02.382]             c <- base::c
[10:27:02.382]             inherits <- base::inherits
[10:27:02.382]             invokeRestart <- base::invokeRestart
[10:27:02.382]             length <- base::length
[10:27:02.382]             list <- base::list
[10:27:02.382]             seq.int <- base::seq.int
[10:27:02.382]             signalCondition <- base::signalCondition
[10:27:02.382]             sys.calls <- base::sys.calls
[10:27:02.382]             `[[` <- base::`[[`
[10:27:02.382]             `+` <- base::`+`
[10:27:02.382]             `<<-` <- base::`<<-`
[10:27:02.382]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:02.382]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:02.382]                   3L)]
[10:27:02.382]             }
[10:27:02.382]             function(cond) {
[10:27:02.382]                 is_error <- inherits(cond, "error")
[10:27:02.382]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:02.382]                   NULL)
[10:27:02.382]                 if (is_error) {
[10:27:02.382]                   sessionInformation <- function() {
[10:27:02.382]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:02.382]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:02.382]                       search = base::search(), system = base::Sys.info())
[10:27:02.382]                   }
[10:27:02.382]                   ...future.conditions[[length(...future.conditions) + 
[10:27:02.382]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:02.382]                     cond$call), session = sessionInformation(), 
[10:27:02.382]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:02.382]                   signalCondition(cond)
[10:27:02.382]                 }
[10:27:02.382]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:02.382]                 "immediateCondition"))) {
[10:27:02.382]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:02.382]                   ...future.conditions[[length(...future.conditions) + 
[10:27:02.382]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:02.382]                   if (TRUE && !signal) {
[10:27:02.382]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:02.382]                     {
[10:27:02.382]                       inherits <- base::inherits
[10:27:02.382]                       invokeRestart <- base::invokeRestart
[10:27:02.382]                       is.null <- base::is.null
[10:27:02.382]                       muffled <- FALSE
[10:27:02.382]                       if (inherits(cond, "message")) {
[10:27:02.382]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:02.382]                         if (muffled) 
[10:27:02.382]                           invokeRestart("muffleMessage")
[10:27:02.382]                       }
[10:27:02.382]                       else if (inherits(cond, "warning")) {
[10:27:02.382]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:02.382]                         if (muffled) 
[10:27:02.382]                           invokeRestart("muffleWarning")
[10:27:02.382]                       }
[10:27:02.382]                       else if (inherits(cond, "condition")) {
[10:27:02.382]                         if (!is.null(pattern)) {
[10:27:02.382]                           computeRestarts <- base::computeRestarts
[10:27:02.382]                           grepl <- base::grepl
[10:27:02.382]                           restarts <- computeRestarts(cond)
[10:27:02.382]                           for (restart in restarts) {
[10:27:02.382]                             name <- restart$name
[10:27:02.382]                             if (is.null(name)) 
[10:27:02.382]                               next
[10:27:02.382]                             if (!grepl(pattern, name)) 
[10:27:02.382]                               next
[10:27:02.382]                             invokeRestart(restart)
[10:27:02.382]                             muffled <- TRUE
[10:27:02.382]                             break
[10:27:02.382]                           }
[10:27:02.382]                         }
[10:27:02.382]                       }
[10:27:02.382]                       invisible(muffled)
[10:27:02.382]                     }
[10:27:02.382]                     muffleCondition(cond, pattern = "^muffle")
[10:27:02.382]                   }
[10:27:02.382]                 }
[10:27:02.382]                 else {
[10:27:02.382]                   if (TRUE) {
[10:27:02.382]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:02.382]                     {
[10:27:02.382]                       inherits <- base::inherits
[10:27:02.382]                       invokeRestart <- base::invokeRestart
[10:27:02.382]                       is.null <- base::is.null
[10:27:02.382]                       muffled <- FALSE
[10:27:02.382]                       if (inherits(cond, "message")) {
[10:27:02.382]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:02.382]                         if (muffled) 
[10:27:02.382]                           invokeRestart("muffleMessage")
[10:27:02.382]                       }
[10:27:02.382]                       else if (inherits(cond, "warning")) {
[10:27:02.382]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:02.382]                         if (muffled) 
[10:27:02.382]                           invokeRestart("muffleWarning")
[10:27:02.382]                       }
[10:27:02.382]                       else if (inherits(cond, "condition")) {
[10:27:02.382]                         if (!is.null(pattern)) {
[10:27:02.382]                           computeRestarts <- base::computeRestarts
[10:27:02.382]                           grepl <- base::grepl
[10:27:02.382]                           restarts <- computeRestarts(cond)
[10:27:02.382]                           for (restart in restarts) {
[10:27:02.382]                             name <- restart$name
[10:27:02.382]                             if (is.null(name)) 
[10:27:02.382]                               next
[10:27:02.382]                             if (!grepl(pattern, name)) 
[10:27:02.382]                               next
[10:27:02.382]                             invokeRestart(restart)
[10:27:02.382]                             muffled <- TRUE
[10:27:02.382]                             break
[10:27:02.382]                           }
[10:27:02.382]                         }
[10:27:02.382]                       }
[10:27:02.382]                       invisible(muffled)
[10:27:02.382]                     }
[10:27:02.382]                     muffleCondition(cond, pattern = "^muffle")
[10:27:02.382]                   }
[10:27:02.382]                 }
[10:27:02.382]             }
[10:27:02.382]         }))
[10:27:02.382]     }, error = function(ex) {
[10:27:02.382]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:02.382]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:02.382]                 ...future.rng), started = ...future.startTime, 
[10:27:02.382]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:02.382]             version = "1.8"), class = "FutureResult")
[10:27:02.382]     }, finally = {
[10:27:02.382]         if (!identical(...future.workdir, getwd())) 
[10:27:02.382]             setwd(...future.workdir)
[10:27:02.382]         {
[10:27:02.382]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:02.382]                 ...future.oldOptions$nwarnings <- NULL
[10:27:02.382]             }
[10:27:02.382]             base::options(...future.oldOptions)
[10:27:02.382]             if (.Platform$OS.type == "windows") {
[10:27:02.382]                 old_names <- names(...future.oldEnvVars)
[10:27:02.382]                 envs <- base::Sys.getenv()
[10:27:02.382]                 names <- names(envs)
[10:27:02.382]                 common <- intersect(names, old_names)
[10:27:02.382]                 added <- setdiff(names, old_names)
[10:27:02.382]                 removed <- setdiff(old_names, names)
[10:27:02.382]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:02.382]                   envs[common]]
[10:27:02.382]                 NAMES <- toupper(changed)
[10:27:02.382]                 args <- list()
[10:27:02.382]                 for (kk in seq_along(NAMES)) {
[10:27:02.382]                   name <- changed[[kk]]
[10:27:02.382]                   NAME <- NAMES[[kk]]
[10:27:02.382]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:02.382]                     next
[10:27:02.382]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:02.382]                 }
[10:27:02.382]                 NAMES <- toupper(added)
[10:27:02.382]                 for (kk in seq_along(NAMES)) {
[10:27:02.382]                   name <- added[[kk]]
[10:27:02.382]                   NAME <- NAMES[[kk]]
[10:27:02.382]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:02.382]                     next
[10:27:02.382]                   args[[name]] <- ""
[10:27:02.382]                 }
[10:27:02.382]                 NAMES <- toupper(removed)
[10:27:02.382]                 for (kk in seq_along(NAMES)) {
[10:27:02.382]                   name <- removed[[kk]]
[10:27:02.382]                   NAME <- NAMES[[kk]]
[10:27:02.382]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:02.382]                     next
[10:27:02.382]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:02.382]                 }
[10:27:02.382]                 if (length(args) > 0) 
[10:27:02.382]                   base::do.call(base::Sys.setenv, args = args)
[10:27:02.382]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:02.382]             }
[10:27:02.382]             else {
[10:27:02.382]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:02.382]             }
[10:27:02.382]             {
[10:27:02.382]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:02.382]                   0L) {
[10:27:02.382]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:02.382]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:02.382]                   base::options(opts)
[10:27:02.382]                 }
[10:27:02.382]                 {
[10:27:02.382]                   {
[10:27:02.382]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:02.382]                     NULL
[10:27:02.382]                   }
[10:27:02.382]                   options(future.plan = NULL)
[10:27:02.382]                   if (is.na(NA_character_)) 
[10:27:02.382]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:02.382]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:02.382]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:27:02.382]                     envir = parent.frame()) 
[10:27:02.382]                   {
[10:27:02.382]                     default_workers <- missing(workers)
[10:27:02.382]                     if (is.function(workers)) 
[10:27:02.382]                       workers <- workers()
[10:27:02.382]                     workers <- structure(as.integer(workers), 
[10:27:02.382]                       class = class(workers))
[10:27:02.382]                     stop_if_not(is.finite(workers), workers >= 
[10:27:02.382]                       1L)
[10:27:02.382]                     if ((workers == 1L && !inherits(workers, 
[10:27:02.382]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:27:02.382]                       if (default_workers) 
[10:27:02.382]                         supportsMulticore(warn = TRUE)
[10:27:02.382]                       return(sequential(..., envir = envir))
[10:27:02.382]                     }
[10:27:02.382]                     oopts <- options(mc.cores = workers)
[10:27:02.382]                     on.exit(options(oopts))
[10:27:02.382]                     future <- MulticoreFuture(..., workers = workers, 
[10:27:02.382]                       envir = envir)
[10:27:02.382]                     if (!future$lazy) 
[10:27:02.382]                       future <- run(future)
[10:27:02.382]                     invisible(future)
[10:27:02.382]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:02.382]                 }
[10:27:02.382]             }
[10:27:02.382]         }
[10:27:02.382]     })
[10:27:02.382]     if (TRUE) {
[10:27:02.382]         base::sink(type = "output", split = FALSE)
[10:27:02.382]         if (TRUE) {
[10:27:02.382]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:02.382]         }
[10:27:02.382]         else {
[10:27:02.382]             ...future.result["stdout"] <- base::list(NULL)
[10:27:02.382]         }
[10:27:02.382]         base::close(...future.stdout)
[10:27:02.382]         ...future.stdout <- NULL
[10:27:02.382]     }
[10:27:02.382]     ...future.result$conditions <- ...future.conditions
[10:27:02.382]     ...future.result$finished <- base::Sys.time()
[10:27:02.382]     ...future.result
[10:27:02.382] }
[10:27:02.385] assign_globals() ...
[10:27:02.385] List of 1
[10:27:02.385]  $ kk: int 2
[10:27:02.385]  - attr(*, "where")=List of 1
[10:27:02.385]   ..$ kk:<environment: R_EmptyEnv> 
[10:27:02.385]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:27:02.385]  - attr(*, "resolved")= logi FALSE
[10:27:02.385]  - attr(*, "total_size")= num 56
[10:27:02.385]  - attr(*, "already-done")= logi TRUE
[10:27:02.389] - copied ‘kk’ to environment
[10:27:02.390] assign_globals() ... done
[10:27:02.390] requestCore(): workers = 2
[10:27:02.390] Poll #1 (0): usedCores() = 2, workers = 2
[10:27:02.401] result() for MulticoreFuture ...
[10:27:02.402] result() for MulticoreFuture ...
[10:27:02.402] result() for MulticoreFuture ... done
[10:27:02.402] result() for MulticoreFuture ... done
[10:27:02.402] result() for MulticoreFuture ...
[10:27:02.402] result() for MulticoreFuture ... done
[10:27:02.407] MulticoreFuture started
[10:27:02.407] - Launch lazy future ... done
[10:27:02.408] run() for ‘MulticoreFuture’ ... done
[10:27:02.408] plan(): Setting new future strategy stack:
[10:27:02.408] getGlobalsAndPackages() ...
[10:27:02.409] Searching for globals...
[10:27:02.408] List of future strategies:
[10:27:02.408] 1. sequential:
[10:27:02.408]    - args: function (..., envir = parent.frame())
[10:27:02.408]    - tweaked: FALSE
[10:27:02.408]    - call: NULL
[10:27:02.411] plan(): nbrOfWorkers() = 1
[10:27:02.411] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:27:02.411] Searching for globals ... DONE
[10:27:02.411] Resolving globals: FALSE
[10:27:02.412] The total size of the 1 globals is 56 bytes (56 bytes)
[10:27:02.413] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[10:27:02.413] - globals: [1] ‘kk’
[10:27:02.414] 
[10:27:02.414] getGlobalsAndPackages() ... DONE
[10:27:02.414] run() for ‘Future’ ...
[10:27:02.414] - state: ‘created’
[10:27:02.415] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:27:02.421] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:02.429] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:27:02.429]   - Field: ‘label’
[10:27:02.430]   - Field: ‘local’
[10:27:02.430]   - Field: ‘owner’
[10:27:02.430]   - Field: ‘envir’
[10:27:02.431]   - Field: ‘workers’
[10:27:02.431]   - Field: ‘packages’
[10:27:02.431]   - Field: ‘gc’
[10:27:02.432]   - Field: ‘job’
[10:27:02.432]   - Field: ‘conditions’
[10:27:02.432]   - Field: ‘expr’
[10:27:02.433]   - Field: ‘uuid’
[10:27:02.433]   - Field: ‘seed’
[10:27:02.433]   - Field: ‘version’
[10:27:02.434]   - Field: ‘result’
[10:27:02.434]   - Field: ‘asynchronous’
[10:27:02.434]   - Field: ‘calls’
[10:27:02.434]   - Field: ‘globals’
[10:27:02.434]   - Field: ‘stdout’
[10:27:02.434]   - Field: ‘earlySignal’
[10:27:02.435]   - Field: ‘lazy’
[10:27:02.435]   - Field: ‘state’
[10:27:02.435] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:27:02.435] - Launch lazy future ...
[10:27:02.436] Packages needed by the future expression (n = 0): <none>
[10:27:02.436] Packages needed by future strategies (n = 0): <none>
[10:27:02.437] {
[10:27:02.437]     {
[10:27:02.437]         {
[10:27:02.437]             ...future.startTime <- base::Sys.time()
[10:27:02.437]             {
[10:27:02.437]                 {
[10:27:02.437]                   {
[10:27:02.437]                     {
[10:27:02.437]                       base::local({
[10:27:02.437]                         has_future <- base::requireNamespace("future", 
[10:27:02.437]                           quietly = TRUE)
[10:27:02.437]                         if (has_future) {
[10:27:02.437]                           ns <- base::getNamespace("future")
[10:27:02.437]                           version <- ns[[".package"]][["version"]]
[10:27:02.437]                           if (is.null(version)) 
[10:27:02.437]                             version <- utils::packageVersion("future")
[10:27:02.437]                         }
[10:27:02.437]                         else {
[10:27:02.437]                           version <- NULL
[10:27:02.437]                         }
[10:27:02.437]                         if (!has_future || version < "1.8.0") {
[10:27:02.437]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:02.437]                             "", base::R.version$version.string), 
[10:27:02.437]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:02.437]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:02.437]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:02.437]                               "release", "version")], collapse = " "), 
[10:27:02.437]                             hostname = base::Sys.info()[["nodename"]])
[10:27:02.437]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:02.437]                             info)
[10:27:02.437]                           info <- base::paste(info, collapse = "; ")
[10:27:02.437]                           if (!has_future) {
[10:27:02.437]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:02.437]                               info)
[10:27:02.437]                           }
[10:27:02.437]                           else {
[10:27:02.437]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:02.437]                               info, version)
[10:27:02.437]                           }
[10:27:02.437]                           base::stop(msg)
[10:27:02.437]                         }
[10:27:02.437]                       })
[10:27:02.437]                     }
[10:27:02.437]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:02.437]                     base::options(mc.cores = 1L)
[10:27:02.437]                   }
[10:27:02.437]                   options(future.plan = NULL)
[10:27:02.437]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:02.437]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:02.437]                 }
[10:27:02.437]                 ...future.workdir <- getwd()
[10:27:02.437]             }
[10:27:02.437]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:02.437]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:02.437]         }
[10:27:02.437]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:02.437]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:02.437]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:02.437]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:02.437]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:02.437]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:02.437]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:02.437]             base::names(...future.oldOptions))
[10:27:02.437]     }
[10:27:02.437]     if (FALSE) {
[10:27:02.437]     }
[10:27:02.437]     else {
[10:27:02.437]         if (TRUE) {
[10:27:02.437]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:02.437]                 open = "w")
[10:27:02.437]         }
[10:27:02.437]         else {
[10:27:02.437]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:02.437]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:02.437]         }
[10:27:02.437]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:02.437]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:02.437]             base::sink(type = "output", split = FALSE)
[10:27:02.437]             base::close(...future.stdout)
[10:27:02.437]         }, add = TRUE)
[10:27:02.437]     }
[10:27:02.437]     ...future.frame <- base::sys.nframe()
[10:27:02.437]     ...future.conditions <- base::list()
[10:27:02.437]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:02.437]     if (FALSE) {
[10:27:02.437]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:02.437]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:02.437]     }
[10:27:02.437]     ...future.result <- base::tryCatch({
[10:27:02.437]         base::withCallingHandlers({
[10:27:02.437]             ...future.value <- base::withVisible(base::local({
[10:27:02.437]                 withCallingHandlers({
[10:27:02.437]                   {
[10:27:02.437]                     Sys.sleep(0.1)
[10:27:02.437]                     kk
[10:27:02.437]                   }
[10:27:02.437]                 }, immediateCondition = function(cond) {
[10:27:02.437]                   save_rds <- function (object, pathname, ...) 
[10:27:02.437]                   {
[10:27:02.437]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:27:02.437]                     if (file_test("-f", pathname_tmp)) {
[10:27:02.437]                       fi_tmp <- file.info(pathname_tmp)
[10:27:02.437]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:27:02.437]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:02.437]                         fi_tmp[["mtime"]])
[10:27:02.437]                     }
[10:27:02.437]                     tryCatch({
[10:27:02.437]                       saveRDS(object, file = pathname_tmp, ...)
[10:27:02.437]                     }, error = function(ex) {
[10:27:02.437]                       msg <- conditionMessage(ex)
[10:27:02.437]                       fi_tmp <- file.info(pathname_tmp)
[10:27:02.437]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:27:02.437]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:02.437]                         fi_tmp[["mtime"]], msg)
[10:27:02.437]                       ex$message <- msg
[10:27:02.437]                       stop(ex)
[10:27:02.437]                     })
[10:27:02.437]                     stopifnot(file_test("-f", pathname_tmp))
[10:27:02.437]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:27:02.437]                     if (!res || file_test("-f", pathname_tmp)) {
[10:27:02.437]                       fi_tmp <- file.info(pathname_tmp)
[10:27:02.437]                       fi <- file.info(pathname)
[10:27:02.437]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:27:02.437]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:02.437]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:27:02.437]                         fi[["size"]], fi[["mtime"]])
[10:27:02.437]                       stop(msg)
[10:27:02.437]                     }
[10:27:02.437]                     invisible(pathname)
[10:27:02.437]                   }
[10:27:02.437]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:27:02.437]                     rootPath = tempdir()) 
[10:27:02.437]                   {
[10:27:02.437]                     obj <- list(time = Sys.time(), condition = cond)
[10:27:02.437]                     file <- tempfile(pattern = class(cond)[1], 
[10:27:02.437]                       tmpdir = path, fileext = ".rds")
[10:27:02.437]                     save_rds(obj, file)
[10:27:02.437]                   }
[10:27:02.437]                   saveImmediateCondition(cond, path = "/tmp/RtmpisxSDE/.future/immediateConditions")
[10:27:02.437]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:02.437]                   {
[10:27:02.437]                     inherits <- base::inherits
[10:27:02.437]                     invokeRestart <- base::invokeRestart
[10:27:02.437]                     is.null <- base::is.null
[10:27:02.437]                     muffled <- FALSE
[10:27:02.437]                     if (inherits(cond, "message")) {
[10:27:02.437]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:02.437]                       if (muffled) 
[10:27:02.437]                         invokeRestart("muffleMessage")
[10:27:02.437]                     }
[10:27:02.437]                     else if (inherits(cond, "warning")) {
[10:27:02.437]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:02.437]                       if (muffled) 
[10:27:02.437]                         invokeRestart("muffleWarning")
[10:27:02.437]                     }
[10:27:02.437]                     else if (inherits(cond, "condition")) {
[10:27:02.437]                       if (!is.null(pattern)) {
[10:27:02.437]                         computeRestarts <- base::computeRestarts
[10:27:02.437]                         grepl <- base::grepl
[10:27:02.437]                         restarts <- computeRestarts(cond)
[10:27:02.437]                         for (restart in restarts) {
[10:27:02.437]                           name <- restart$name
[10:27:02.437]                           if (is.null(name)) 
[10:27:02.437]                             next
[10:27:02.437]                           if (!grepl(pattern, name)) 
[10:27:02.437]                             next
[10:27:02.437]                           invokeRestart(restart)
[10:27:02.437]                           muffled <- TRUE
[10:27:02.437]                           break
[10:27:02.437]                         }
[10:27:02.437]                       }
[10:27:02.437]                     }
[10:27:02.437]                     invisible(muffled)
[10:27:02.437]                   }
[10:27:02.437]                   muffleCondition(cond)
[10:27:02.437]                 })
[10:27:02.437]             }))
[10:27:02.437]             future::FutureResult(value = ...future.value$value, 
[10:27:02.437]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:02.437]                   ...future.rng), globalenv = if (FALSE) 
[10:27:02.437]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:02.437]                     ...future.globalenv.names))
[10:27:02.437]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:02.437]         }, condition = base::local({
[10:27:02.437]             c <- base::c
[10:27:02.437]             inherits <- base::inherits
[10:27:02.437]             invokeRestart <- base::invokeRestart
[10:27:02.437]             length <- base::length
[10:27:02.437]             list <- base::list
[10:27:02.437]             seq.int <- base::seq.int
[10:27:02.437]             signalCondition <- base::signalCondition
[10:27:02.437]             sys.calls <- base::sys.calls
[10:27:02.437]             `[[` <- base::`[[`
[10:27:02.437]             `+` <- base::`+`
[10:27:02.437]             `<<-` <- base::`<<-`
[10:27:02.437]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:02.437]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:02.437]                   3L)]
[10:27:02.437]             }
[10:27:02.437]             function(cond) {
[10:27:02.437]                 is_error <- inherits(cond, "error")
[10:27:02.437]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:02.437]                   NULL)
[10:27:02.437]                 if (is_error) {
[10:27:02.437]                   sessionInformation <- function() {
[10:27:02.437]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:02.437]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:02.437]                       search = base::search(), system = base::Sys.info())
[10:27:02.437]                   }
[10:27:02.437]                   ...future.conditions[[length(...future.conditions) + 
[10:27:02.437]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:02.437]                     cond$call), session = sessionInformation(), 
[10:27:02.437]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:02.437]                   signalCondition(cond)
[10:27:02.437]                 }
[10:27:02.437]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:02.437]                 "immediateCondition"))) {
[10:27:02.437]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:02.437]                   ...future.conditions[[length(...future.conditions) + 
[10:27:02.437]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:02.437]                   if (TRUE && !signal) {
[10:27:02.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:02.437]                     {
[10:27:02.437]                       inherits <- base::inherits
[10:27:02.437]                       invokeRestart <- base::invokeRestart
[10:27:02.437]                       is.null <- base::is.null
[10:27:02.437]                       muffled <- FALSE
[10:27:02.437]                       if (inherits(cond, "message")) {
[10:27:02.437]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:02.437]                         if (muffled) 
[10:27:02.437]                           invokeRestart("muffleMessage")
[10:27:02.437]                       }
[10:27:02.437]                       else if (inherits(cond, "warning")) {
[10:27:02.437]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:02.437]                         if (muffled) 
[10:27:02.437]                           invokeRestart("muffleWarning")
[10:27:02.437]                       }
[10:27:02.437]                       else if (inherits(cond, "condition")) {
[10:27:02.437]                         if (!is.null(pattern)) {
[10:27:02.437]                           computeRestarts <- base::computeRestarts
[10:27:02.437]                           grepl <- base::grepl
[10:27:02.437]                           restarts <- computeRestarts(cond)
[10:27:02.437]                           for (restart in restarts) {
[10:27:02.437]                             name <- restart$name
[10:27:02.437]                             if (is.null(name)) 
[10:27:02.437]                               next
[10:27:02.437]                             if (!grepl(pattern, name)) 
[10:27:02.437]                               next
[10:27:02.437]                             invokeRestart(restart)
[10:27:02.437]                             muffled <- TRUE
[10:27:02.437]                             break
[10:27:02.437]                           }
[10:27:02.437]                         }
[10:27:02.437]                       }
[10:27:02.437]                       invisible(muffled)
[10:27:02.437]                     }
[10:27:02.437]                     muffleCondition(cond, pattern = "^muffle")
[10:27:02.437]                   }
[10:27:02.437]                 }
[10:27:02.437]                 else {
[10:27:02.437]                   if (TRUE) {
[10:27:02.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:02.437]                     {
[10:27:02.437]                       inherits <- base::inherits
[10:27:02.437]                       invokeRestart <- base::invokeRestart
[10:27:02.437]                       is.null <- base::is.null
[10:27:02.437]                       muffled <- FALSE
[10:27:02.437]                       if (inherits(cond, "message")) {
[10:27:02.437]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:02.437]                         if (muffled) 
[10:27:02.437]                           invokeRestart("muffleMessage")
[10:27:02.437]                       }
[10:27:02.437]                       else if (inherits(cond, "warning")) {
[10:27:02.437]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:02.437]                         if (muffled) 
[10:27:02.437]                           invokeRestart("muffleWarning")
[10:27:02.437]                       }
[10:27:02.437]                       else if (inherits(cond, "condition")) {
[10:27:02.437]                         if (!is.null(pattern)) {
[10:27:02.437]                           computeRestarts <- base::computeRestarts
[10:27:02.437]                           grepl <- base::grepl
[10:27:02.437]                           restarts <- computeRestarts(cond)
[10:27:02.437]                           for (restart in restarts) {
[10:27:02.437]                             name <- restart$name
[10:27:02.437]                             if (is.null(name)) 
[10:27:02.437]                               next
[10:27:02.437]                             if (!grepl(pattern, name)) 
[10:27:02.437]                               next
[10:27:02.437]                             invokeRestart(restart)
[10:27:02.437]                             muffled <- TRUE
[10:27:02.437]                             break
[10:27:02.437]                           }
[10:27:02.437]                         }
[10:27:02.437]                       }
[10:27:02.437]                       invisible(muffled)
[10:27:02.437]                     }
[10:27:02.437]                     muffleCondition(cond, pattern = "^muffle")
[10:27:02.437]                   }
[10:27:02.437]                 }
[10:27:02.437]             }
[10:27:02.437]         }))
[10:27:02.437]     }, error = function(ex) {
[10:27:02.437]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:02.437]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:02.437]                 ...future.rng), started = ...future.startTime, 
[10:27:02.437]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:02.437]             version = "1.8"), class = "FutureResult")
[10:27:02.437]     }, finally = {
[10:27:02.437]         if (!identical(...future.workdir, getwd())) 
[10:27:02.437]             setwd(...future.workdir)
[10:27:02.437]         {
[10:27:02.437]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:02.437]                 ...future.oldOptions$nwarnings <- NULL
[10:27:02.437]             }
[10:27:02.437]             base::options(...future.oldOptions)
[10:27:02.437]             if (.Platform$OS.type == "windows") {
[10:27:02.437]                 old_names <- names(...future.oldEnvVars)
[10:27:02.437]                 envs <- base::Sys.getenv()
[10:27:02.437]                 names <- names(envs)
[10:27:02.437]                 common <- intersect(names, old_names)
[10:27:02.437]                 added <- setdiff(names, old_names)
[10:27:02.437]                 removed <- setdiff(old_names, names)
[10:27:02.437]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:02.437]                   envs[common]]
[10:27:02.437]                 NAMES <- toupper(changed)
[10:27:02.437]                 args <- list()
[10:27:02.437]                 for (kk in seq_along(NAMES)) {
[10:27:02.437]                   name <- changed[[kk]]
[10:27:02.437]                   NAME <- NAMES[[kk]]
[10:27:02.437]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:02.437]                     next
[10:27:02.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:02.437]                 }
[10:27:02.437]                 NAMES <- toupper(added)
[10:27:02.437]                 for (kk in seq_along(NAMES)) {
[10:27:02.437]                   name <- added[[kk]]
[10:27:02.437]                   NAME <- NAMES[[kk]]
[10:27:02.437]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:02.437]                     next
[10:27:02.437]                   args[[name]] <- ""
[10:27:02.437]                 }
[10:27:02.437]                 NAMES <- toupper(removed)
[10:27:02.437]                 for (kk in seq_along(NAMES)) {
[10:27:02.437]                   name <- removed[[kk]]
[10:27:02.437]                   NAME <- NAMES[[kk]]
[10:27:02.437]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:02.437]                     next
[10:27:02.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:02.437]                 }
[10:27:02.437]                 if (length(args) > 0) 
[10:27:02.437]                   base::do.call(base::Sys.setenv, args = args)
[10:27:02.437]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:02.437]             }
[10:27:02.437]             else {
[10:27:02.437]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:02.437]             }
[10:27:02.437]             {
[10:27:02.437]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:02.437]                   0L) {
[10:27:02.437]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:02.437]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:02.437]                   base::options(opts)
[10:27:02.437]                 }
[10:27:02.437]                 {
[10:27:02.437]                   {
[10:27:02.437]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:02.437]                     NULL
[10:27:02.437]                   }
[10:27:02.437]                   options(future.plan = NULL)
[10:27:02.437]                   if (is.na(NA_character_)) 
[10:27:02.437]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:02.437]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:02.437]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:27:02.437]                     envir = parent.frame()) 
[10:27:02.437]                   {
[10:27:02.437]                     default_workers <- missing(workers)
[10:27:02.437]                     if (is.function(workers)) 
[10:27:02.437]                       workers <- workers()
[10:27:02.437]                     workers <- structure(as.integer(workers), 
[10:27:02.437]                       class = class(workers))
[10:27:02.437]                     stop_if_not(is.finite(workers), workers >= 
[10:27:02.437]                       1L)
[10:27:02.437]                     if ((workers == 1L && !inherits(workers, 
[10:27:02.437]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:27:02.437]                       if (default_workers) 
[10:27:02.437]                         supportsMulticore(warn = TRUE)
[10:27:02.437]                       return(sequential(..., envir = envir))
[10:27:02.437]                     }
[10:27:02.437]                     oopts <- options(mc.cores = workers)
[10:27:02.437]                     on.exit(options(oopts))
[10:27:02.437]                     future <- MulticoreFuture(..., workers = workers, 
[10:27:02.437]                       envir = envir)
[10:27:02.437]                     if (!future$lazy) 
[10:27:02.437]                       future <- run(future)
[10:27:02.437]                     invisible(future)
[10:27:02.437]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:02.437]                 }
[10:27:02.437]             }
[10:27:02.437]         }
[10:27:02.437]     })
[10:27:02.437]     if (TRUE) {
[10:27:02.437]         base::sink(type = "output", split = FALSE)
[10:27:02.437]         if (TRUE) {
[10:27:02.437]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:02.437]         }
[10:27:02.437]         else {
[10:27:02.437]             ...future.result["stdout"] <- base::list(NULL)
[10:27:02.437]         }
[10:27:02.437]         base::close(...future.stdout)
[10:27:02.437]         ...future.stdout <- NULL
[10:27:02.437]     }
[10:27:02.437]     ...future.result$conditions <- ...future.conditions
[10:27:02.437]     ...future.result$finished <- base::Sys.time()
[10:27:02.437]     ...future.result
[10:27:02.437] }
[10:27:02.440] assign_globals() ...
[10:27:02.440] List of 1
[10:27:02.440]  $ kk: int 3
[10:27:02.440]  - attr(*, "where")=List of 1
[10:27:02.440]   ..$ kk:<environment: R_EmptyEnv> 
[10:27:02.440]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:27:02.440]  - attr(*, "resolved")= logi FALSE
[10:27:02.440]  - attr(*, "total_size")= num 56
[10:27:02.440]  - attr(*, "already-done")= logi TRUE
[10:27:02.444] - copied ‘kk’ to environment
[10:27:02.445] assign_globals() ... done
[10:27:02.445] requestCore(): workers = 2
[10:27:02.445] Poll #1 (0): usedCores() = 2, workers = 2
[10:27:02.466] plan(): Setting new future strategy stack:
[10:27:02.466] List of future strategies:
[10:27:02.466] 1. multicore:
[10:27:02.466]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:27:02.466]    - tweaked: FALSE
[10:27:02.466]    - call: plan(strategy)
[10:27:02.473] plan(): nbrOfWorkers() = 2
[10:27:02.477] Poll #2 (0.03 secs): usedCores() = 2, workers = 2
[10:27:02.488] result() for MulticoreFuture ...
[10:27:02.489] result() for MulticoreFuture ...
[10:27:02.489] result() for MulticoreFuture ... done
[10:27:02.490] result() for MulticoreFuture ... done
[10:27:02.490] result() for MulticoreFuture ...
[10:27:02.490] result() for MulticoreFuture ... done
[10:27:02.493] MulticoreFuture started
[10:27:02.493] - Launch lazy future ... done
[10:27:02.494] run() for ‘MulticoreFuture’ ... done
[10:27:02.494] resolve() on list ...
[10:27:02.494]  recursive: 0
[10:27:02.494] plan(): Setting new future strategy stack:
[10:27:02.495]  length: 3
[10:27:02.495] 
[10:27:02.495] Future #1
[10:27:02.495] List of future strategies:
[10:27:02.495] 1. sequential:
[10:27:02.495]    - args: function (..., envir = parent.frame())
[10:27:02.495]    - tweaked: FALSE
[10:27:02.495]    - call: NULL
[10:27:02.496]  length: 2 (resolved future 1)
[10:27:02.496] plan(): nbrOfWorkers() = 1
[10:27:02.517] plan(): Setting new future strategy stack:
[10:27:02.517] List of future strategies:
[10:27:02.517] 1. multicore:
[10:27:02.517]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:27:02.517]    - tweaked: FALSE
[10:27:02.517]    - call: plan(strategy)
[10:27:02.522] plan(): nbrOfWorkers() = 2
[10:27:02.528] Future #2
[10:27:02.528]  length: 1 (resolved future 2)
[10:27:02.599] plan(): Setting new future strategy stack:
[10:27:02.599] List of future strategies:
[10:27:02.599] 1. multicore:
[10:27:02.599]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:27:02.599]    - tweaked: FALSE
[10:27:02.599]    - call: plan(strategy)
[10:27:02.609] plan(): nbrOfWorkers() = 2
[10:27:02.612] Future #3
[10:27:02.612]  length: 0 (resolved future 3)
[10:27:02.612] resolve() on list ... DONE
[10:27:02.612] getGlobalsAndPackages() ...
[10:27:02.612] Searching for globals...
[10:27:02.615] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:27:02.615] Searching for globals ... DONE
[10:27:02.615] Resolving globals: FALSE
[10:27:02.616] The total size of the 1 globals is 56 bytes (56 bytes)
[10:27:02.617] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[10:27:02.617] - globals: [1] ‘kk’
[10:27:02.617] 
[10:27:02.617] getGlobalsAndPackages() ... DONE
[10:27:02.618] getGlobalsAndPackages() ...
[10:27:02.618] Searching for globals...
[10:27:02.619] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:27:02.619] Searching for globals ... DONE
[10:27:02.620] Resolving globals: FALSE
[10:27:02.620] The total size of the 1 globals is 56 bytes (56 bytes)
[10:27:02.621] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[10:27:02.621] - globals: [1] ‘kk’
[10:27:02.621] 
[10:27:02.621] getGlobalsAndPackages() ... DONE
[10:27:02.621] getGlobalsAndPackages() ...
[10:27:02.622] Searching for globals...
[10:27:02.623] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:27:02.623] Searching for globals ... DONE
[10:27:02.623] Resolving globals: FALSE
[10:27:02.624] The total size of the 1 globals is 56 bytes (56 bytes)
[10:27:02.624] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[10:27:02.624] - globals: [1] ‘kk’
[10:27:02.625] 
[10:27:02.625] getGlobalsAndPackages() ... DONE
[10:27:02.625] resolve() on list ...
[10:27:02.625]  recursive: 0
[10:27:02.625]  length: 3
[10:27:02.625] 
[10:27:02.626] run() for ‘Future’ ...
[10:27:02.626] - state: ‘created’
[10:27:02.626] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:27:02.633] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:02.633] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:27:02.633]   - Field: ‘label’
[10:27:02.633]   - Field: ‘local’
[10:27:02.633]   - Field: ‘owner’
[10:27:02.634]   - Field: ‘envir’
[10:27:02.634]   - Field: ‘workers’
[10:27:02.634]   - Field: ‘packages’
[10:27:02.634]   - Field: ‘gc’
[10:27:02.634]   - Field: ‘job’
[10:27:02.634]   - Field: ‘conditions’
[10:27:02.634]   - Field: ‘expr’
[10:27:02.635]   - Field: ‘uuid’
[10:27:02.635]   - Field: ‘seed’
[10:27:02.635]   - Field: ‘version’
[10:27:02.635]   - Field: ‘result’
[10:27:02.635]   - Field: ‘asynchronous’
[10:27:02.635]   - Field: ‘calls’
[10:27:02.636]   - Field: ‘globals’
[10:27:02.636]   - Field: ‘stdout’
[10:27:02.636]   - Field: ‘earlySignal’
[10:27:02.636]   - Field: ‘lazy’
[10:27:02.636]   - Field: ‘state’
[10:27:02.636] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:27:02.636] - Launch lazy future ...
[10:27:02.637] Packages needed by the future expression (n = 0): <none>
[10:27:02.637] Packages needed by future strategies (n = 0): <none>
[10:27:02.641] {
[10:27:02.641]     {
[10:27:02.641]         {
[10:27:02.641]             ...future.startTime <- base::Sys.time()
[10:27:02.641]             {
[10:27:02.641]                 {
[10:27:02.641]                   {
[10:27:02.641]                     {
[10:27:02.641]                       base::local({
[10:27:02.641]                         has_future <- base::requireNamespace("future", 
[10:27:02.641]                           quietly = TRUE)
[10:27:02.641]                         if (has_future) {
[10:27:02.641]                           ns <- base::getNamespace("future")
[10:27:02.641]                           version <- ns[[".package"]][["version"]]
[10:27:02.641]                           if (is.null(version)) 
[10:27:02.641]                             version <- utils::packageVersion("future")
[10:27:02.641]                         }
[10:27:02.641]                         else {
[10:27:02.641]                           version <- NULL
[10:27:02.641]                         }
[10:27:02.641]                         if (!has_future || version < "1.8.0") {
[10:27:02.641]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:02.641]                             "", base::R.version$version.string), 
[10:27:02.641]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:02.641]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:02.641]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:02.641]                               "release", "version")], collapse = " "), 
[10:27:02.641]                             hostname = base::Sys.info()[["nodename"]])
[10:27:02.641]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:02.641]                             info)
[10:27:02.641]                           info <- base::paste(info, collapse = "; ")
[10:27:02.641]                           if (!has_future) {
[10:27:02.641]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:02.641]                               info)
[10:27:02.641]                           }
[10:27:02.641]                           else {
[10:27:02.641]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:02.641]                               info, version)
[10:27:02.641]                           }
[10:27:02.641]                           base::stop(msg)
[10:27:02.641]                         }
[10:27:02.641]                       })
[10:27:02.641]                     }
[10:27:02.641]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:02.641]                     base::options(mc.cores = 1L)
[10:27:02.641]                   }
[10:27:02.641]                   options(future.plan = NULL)
[10:27:02.641]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:02.641]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:02.641]                 }
[10:27:02.641]                 ...future.workdir <- getwd()
[10:27:02.641]             }
[10:27:02.641]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:02.641]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:02.641]         }
[10:27:02.641]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:02.641]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:02.641]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:02.641]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:02.641]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:02.641]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:02.641]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:02.641]             base::names(...future.oldOptions))
[10:27:02.641]     }
[10:27:02.641]     if (FALSE) {
[10:27:02.641]     }
[10:27:02.641]     else {
[10:27:02.641]         if (TRUE) {
[10:27:02.641]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:02.641]                 open = "w")
[10:27:02.641]         }
[10:27:02.641]         else {
[10:27:02.641]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:02.641]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:02.641]         }
[10:27:02.641]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:02.641]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:02.641]             base::sink(type = "output", split = FALSE)
[10:27:02.641]             base::close(...future.stdout)
[10:27:02.641]         }, add = TRUE)
[10:27:02.641]     }
[10:27:02.641]     ...future.frame <- base::sys.nframe()
[10:27:02.641]     ...future.conditions <- base::list()
[10:27:02.641]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:02.641]     if (FALSE) {
[10:27:02.641]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:02.641]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:02.641]     }
[10:27:02.641]     ...future.result <- base::tryCatch({
[10:27:02.641]         base::withCallingHandlers({
[10:27:02.641]             ...future.value <- base::withVisible(base::local({
[10:27:02.641]                 withCallingHandlers({
[10:27:02.641]                   {
[10:27:02.641]                     Sys.sleep(0.1)
[10:27:02.641]                     kk
[10:27:02.641]                   }
[10:27:02.641]                 }, immediateCondition = function(cond) {
[10:27:02.641]                   save_rds <- function (object, pathname, ...) 
[10:27:02.641]                   {
[10:27:02.641]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:27:02.641]                     if (file_test("-f", pathname_tmp)) {
[10:27:02.641]                       fi_tmp <- file.info(pathname_tmp)
[10:27:02.641]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:27:02.641]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:02.641]                         fi_tmp[["mtime"]])
[10:27:02.641]                     }
[10:27:02.641]                     tryCatch({
[10:27:02.641]                       saveRDS(object, file = pathname_tmp, ...)
[10:27:02.641]                     }, error = function(ex) {
[10:27:02.641]                       msg <- conditionMessage(ex)
[10:27:02.641]                       fi_tmp <- file.info(pathname_tmp)
[10:27:02.641]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:27:02.641]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:02.641]                         fi_tmp[["mtime"]], msg)
[10:27:02.641]                       ex$message <- msg
[10:27:02.641]                       stop(ex)
[10:27:02.641]                     })
[10:27:02.641]                     stopifnot(file_test("-f", pathname_tmp))
[10:27:02.641]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:27:02.641]                     if (!res || file_test("-f", pathname_tmp)) {
[10:27:02.641]                       fi_tmp <- file.info(pathname_tmp)
[10:27:02.641]                       fi <- file.info(pathname)
[10:27:02.641]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:27:02.641]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:02.641]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:27:02.641]                         fi[["size"]], fi[["mtime"]])
[10:27:02.641]                       stop(msg)
[10:27:02.641]                     }
[10:27:02.641]                     invisible(pathname)
[10:27:02.641]                   }
[10:27:02.641]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:27:02.641]                     rootPath = tempdir()) 
[10:27:02.641]                   {
[10:27:02.641]                     obj <- list(time = Sys.time(), condition = cond)
[10:27:02.641]                     file <- tempfile(pattern = class(cond)[1], 
[10:27:02.641]                       tmpdir = path, fileext = ".rds")
[10:27:02.641]                     save_rds(obj, file)
[10:27:02.641]                   }
[10:27:02.641]                   saveImmediateCondition(cond, path = "/tmp/RtmpisxSDE/.future/immediateConditions")
[10:27:02.641]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:02.641]                   {
[10:27:02.641]                     inherits <- base::inherits
[10:27:02.641]                     invokeRestart <- base::invokeRestart
[10:27:02.641]                     is.null <- base::is.null
[10:27:02.641]                     muffled <- FALSE
[10:27:02.641]                     if (inherits(cond, "message")) {
[10:27:02.641]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:02.641]                       if (muffled) 
[10:27:02.641]                         invokeRestart("muffleMessage")
[10:27:02.641]                     }
[10:27:02.641]                     else if (inherits(cond, "warning")) {
[10:27:02.641]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:02.641]                       if (muffled) 
[10:27:02.641]                         invokeRestart("muffleWarning")
[10:27:02.641]                     }
[10:27:02.641]                     else if (inherits(cond, "condition")) {
[10:27:02.641]                       if (!is.null(pattern)) {
[10:27:02.641]                         computeRestarts <- base::computeRestarts
[10:27:02.641]                         grepl <- base::grepl
[10:27:02.641]                         restarts <- computeRestarts(cond)
[10:27:02.641]                         for (restart in restarts) {
[10:27:02.641]                           name <- restart$name
[10:27:02.641]                           if (is.null(name)) 
[10:27:02.641]                             next
[10:27:02.641]                           if (!grepl(pattern, name)) 
[10:27:02.641]                             next
[10:27:02.641]                           invokeRestart(restart)
[10:27:02.641]                           muffled <- TRUE
[10:27:02.641]                           break
[10:27:02.641]                         }
[10:27:02.641]                       }
[10:27:02.641]                     }
[10:27:02.641]                     invisible(muffled)
[10:27:02.641]                   }
[10:27:02.641]                   muffleCondition(cond)
[10:27:02.641]                 })
[10:27:02.641]             }))
[10:27:02.641]             future::FutureResult(value = ...future.value$value, 
[10:27:02.641]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:02.641]                   ...future.rng), globalenv = if (FALSE) 
[10:27:02.641]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:02.641]                     ...future.globalenv.names))
[10:27:02.641]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:02.641]         }, condition = base::local({
[10:27:02.641]             c <- base::c
[10:27:02.641]             inherits <- base::inherits
[10:27:02.641]             invokeRestart <- base::invokeRestart
[10:27:02.641]             length <- base::length
[10:27:02.641]             list <- base::list
[10:27:02.641]             seq.int <- base::seq.int
[10:27:02.641]             signalCondition <- base::signalCondition
[10:27:02.641]             sys.calls <- base::sys.calls
[10:27:02.641]             `[[` <- base::`[[`
[10:27:02.641]             `+` <- base::`+`
[10:27:02.641]             `<<-` <- base::`<<-`
[10:27:02.641]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:02.641]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:02.641]                   3L)]
[10:27:02.641]             }
[10:27:02.641]             function(cond) {
[10:27:02.641]                 is_error <- inherits(cond, "error")
[10:27:02.641]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:02.641]                   NULL)
[10:27:02.641]                 if (is_error) {
[10:27:02.641]                   sessionInformation <- function() {
[10:27:02.641]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:02.641]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:02.641]                       search = base::search(), system = base::Sys.info())
[10:27:02.641]                   }
[10:27:02.641]                   ...future.conditions[[length(...future.conditions) + 
[10:27:02.641]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:02.641]                     cond$call), session = sessionInformation(), 
[10:27:02.641]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:02.641]                   signalCondition(cond)
[10:27:02.641]                 }
[10:27:02.641]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:02.641]                 "immediateCondition"))) {
[10:27:02.641]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:02.641]                   ...future.conditions[[length(...future.conditions) + 
[10:27:02.641]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:02.641]                   if (TRUE && !signal) {
[10:27:02.641]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:02.641]                     {
[10:27:02.641]                       inherits <- base::inherits
[10:27:02.641]                       invokeRestart <- base::invokeRestart
[10:27:02.641]                       is.null <- base::is.null
[10:27:02.641]                       muffled <- FALSE
[10:27:02.641]                       if (inherits(cond, "message")) {
[10:27:02.641]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:02.641]                         if (muffled) 
[10:27:02.641]                           invokeRestart("muffleMessage")
[10:27:02.641]                       }
[10:27:02.641]                       else if (inherits(cond, "warning")) {
[10:27:02.641]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:02.641]                         if (muffled) 
[10:27:02.641]                           invokeRestart("muffleWarning")
[10:27:02.641]                       }
[10:27:02.641]                       else if (inherits(cond, "condition")) {
[10:27:02.641]                         if (!is.null(pattern)) {
[10:27:02.641]                           computeRestarts <- base::computeRestarts
[10:27:02.641]                           grepl <- base::grepl
[10:27:02.641]                           restarts <- computeRestarts(cond)
[10:27:02.641]                           for (restart in restarts) {
[10:27:02.641]                             name <- restart$name
[10:27:02.641]                             if (is.null(name)) 
[10:27:02.641]                               next
[10:27:02.641]                             if (!grepl(pattern, name)) 
[10:27:02.641]                               next
[10:27:02.641]                             invokeRestart(restart)
[10:27:02.641]                             muffled <- TRUE
[10:27:02.641]                             break
[10:27:02.641]                           }
[10:27:02.641]                         }
[10:27:02.641]                       }
[10:27:02.641]                       invisible(muffled)
[10:27:02.641]                     }
[10:27:02.641]                     muffleCondition(cond, pattern = "^muffle")
[10:27:02.641]                   }
[10:27:02.641]                 }
[10:27:02.641]                 else {
[10:27:02.641]                   if (TRUE) {
[10:27:02.641]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:02.641]                     {
[10:27:02.641]                       inherits <- base::inherits
[10:27:02.641]                       invokeRestart <- base::invokeRestart
[10:27:02.641]                       is.null <- base::is.null
[10:27:02.641]                       muffled <- FALSE
[10:27:02.641]                       if (inherits(cond, "message")) {
[10:27:02.641]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:02.641]                         if (muffled) 
[10:27:02.641]                           invokeRestart("muffleMessage")
[10:27:02.641]                       }
[10:27:02.641]                       else if (inherits(cond, "warning")) {
[10:27:02.641]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:02.641]                         if (muffled) 
[10:27:02.641]                           invokeRestart("muffleWarning")
[10:27:02.641]                       }
[10:27:02.641]                       else if (inherits(cond, "condition")) {
[10:27:02.641]                         if (!is.null(pattern)) {
[10:27:02.641]                           computeRestarts <- base::computeRestarts
[10:27:02.641]                           grepl <- base::grepl
[10:27:02.641]                           restarts <- computeRestarts(cond)
[10:27:02.641]                           for (restart in restarts) {
[10:27:02.641]                             name <- restart$name
[10:27:02.641]                             if (is.null(name)) 
[10:27:02.641]                               next
[10:27:02.641]                             if (!grepl(pattern, name)) 
[10:27:02.641]                               next
[10:27:02.641]                             invokeRestart(restart)
[10:27:02.641]                             muffled <- TRUE
[10:27:02.641]                             break
[10:27:02.641]                           }
[10:27:02.641]                         }
[10:27:02.641]                       }
[10:27:02.641]                       invisible(muffled)
[10:27:02.641]                     }
[10:27:02.641]                     muffleCondition(cond, pattern = "^muffle")
[10:27:02.641]                   }
[10:27:02.641]                 }
[10:27:02.641]             }
[10:27:02.641]         }))
[10:27:02.641]     }, error = function(ex) {
[10:27:02.641]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:02.641]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:02.641]                 ...future.rng), started = ...future.startTime, 
[10:27:02.641]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:02.641]             version = "1.8"), class = "FutureResult")
[10:27:02.641]     }, finally = {
[10:27:02.641]         if (!identical(...future.workdir, getwd())) 
[10:27:02.641]             setwd(...future.workdir)
[10:27:02.641]         {
[10:27:02.641]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:02.641]                 ...future.oldOptions$nwarnings <- NULL
[10:27:02.641]             }
[10:27:02.641]             base::options(...future.oldOptions)
[10:27:02.641]             if (.Platform$OS.type == "windows") {
[10:27:02.641]                 old_names <- names(...future.oldEnvVars)
[10:27:02.641]                 envs <- base::Sys.getenv()
[10:27:02.641]                 names <- names(envs)
[10:27:02.641]                 common <- intersect(names, old_names)
[10:27:02.641]                 added <- setdiff(names, old_names)
[10:27:02.641]                 removed <- setdiff(old_names, names)
[10:27:02.641]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:02.641]                   envs[common]]
[10:27:02.641]                 NAMES <- toupper(changed)
[10:27:02.641]                 args <- list()
[10:27:02.641]                 for (kk in seq_along(NAMES)) {
[10:27:02.641]                   name <- changed[[kk]]
[10:27:02.641]                   NAME <- NAMES[[kk]]
[10:27:02.641]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:02.641]                     next
[10:27:02.641]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:02.641]                 }
[10:27:02.641]                 NAMES <- toupper(added)
[10:27:02.641]                 for (kk in seq_along(NAMES)) {
[10:27:02.641]                   name <- added[[kk]]
[10:27:02.641]                   NAME <- NAMES[[kk]]
[10:27:02.641]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:02.641]                     next
[10:27:02.641]                   args[[name]] <- ""
[10:27:02.641]                 }
[10:27:02.641]                 NAMES <- toupper(removed)
[10:27:02.641]                 for (kk in seq_along(NAMES)) {
[10:27:02.641]                   name <- removed[[kk]]
[10:27:02.641]                   NAME <- NAMES[[kk]]
[10:27:02.641]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:02.641]                     next
[10:27:02.641]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:02.641]                 }
[10:27:02.641]                 if (length(args) > 0) 
[10:27:02.641]                   base::do.call(base::Sys.setenv, args = args)
[10:27:02.641]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:02.641]             }
[10:27:02.641]             else {
[10:27:02.641]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:02.641]             }
[10:27:02.641]             {
[10:27:02.641]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:02.641]                   0L) {
[10:27:02.641]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:02.641]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:02.641]                   base::options(opts)
[10:27:02.641]                 }
[10:27:02.641]                 {
[10:27:02.641]                   {
[10:27:02.641]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:02.641]                     NULL
[10:27:02.641]                   }
[10:27:02.641]                   options(future.plan = NULL)
[10:27:02.641]                   if (is.na(NA_character_)) 
[10:27:02.641]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:02.641]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:02.641]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:27:02.641]                     envir = parent.frame()) 
[10:27:02.641]                   {
[10:27:02.641]                     default_workers <- missing(workers)
[10:27:02.641]                     if (is.function(workers)) 
[10:27:02.641]                       workers <- workers()
[10:27:02.641]                     workers <- structure(as.integer(workers), 
[10:27:02.641]                       class = class(workers))
[10:27:02.641]                     stop_if_not(is.finite(workers), workers >= 
[10:27:02.641]                       1L)
[10:27:02.641]                     if ((workers == 1L && !inherits(workers, 
[10:27:02.641]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:27:02.641]                       if (default_workers) 
[10:27:02.641]                         supportsMulticore(warn = TRUE)
[10:27:02.641]                       return(sequential(..., envir = envir))
[10:27:02.641]                     }
[10:27:02.641]                     oopts <- options(mc.cores = workers)
[10:27:02.641]                     on.exit(options(oopts))
[10:27:02.641]                     future <- MulticoreFuture(..., workers = workers, 
[10:27:02.641]                       envir = envir)
[10:27:02.641]                     if (!future$lazy) 
[10:27:02.641]                       future <- run(future)
[10:27:02.641]                     invisible(future)
[10:27:02.641]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:02.641]                 }
[10:27:02.641]             }
[10:27:02.641]         }
[10:27:02.641]     })
[10:27:02.641]     if (TRUE) {
[10:27:02.641]         base::sink(type = "output", split = FALSE)
[10:27:02.641]         if (TRUE) {
[10:27:02.641]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:02.641]         }
[10:27:02.641]         else {
[10:27:02.641]             ...future.result["stdout"] <- base::list(NULL)
[10:27:02.641]         }
[10:27:02.641]         base::close(...future.stdout)
[10:27:02.641]         ...future.stdout <- NULL
[10:27:02.641]     }
[10:27:02.641]     ...future.result$conditions <- ...future.conditions
[10:27:02.641]     ...future.result$finished <- base::Sys.time()
[10:27:02.641]     ...future.result
[10:27:02.641] }
[10:27:02.644] assign_globals() ...
[10:27:02.645] List of 1
[10:27:02.645]  $ kk: int 1
[10:27:02.645]  - attr(*, "where")=List of 1
[10:27:02.645]   ..$ kk:<environment: R_EmptyEnv> 
[10:27:02.645]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:27:02.645]  - attr(*, "resolved")= logi FALSE
[10:27:02.645]  - attr(*, "total_size")= num 56
[10:27:02.645]  - attr(*, "already-done")= logi TRUE
[10:27:02.650] - copied ‘kk’ to environment
[10:27:02.650] assign_globals() ... done
[10:27:02.650] requestCore(): workers = 2
[10:27:02.650] Poll #1 (0): usedCores() = 2, workers = 2
[10:27:02.661] result() for MulticoreFuture ...
[10:27:02.662] result() for MulticoreFuture ...
[10:27:02.662] result() for MulticoreFuture ... done
[10:27:02.662] result() for MulticoreFuture ... done
[10:27:02.663] result() for MulticoreFuture ...
[10:27:02.663] result() for MulticoreFuture ... done
[10:27:02.667] MulticoreFuture started
[10:27:02.668] - Launch lazy future ... done
[10:27:02.668] run() for ‘MulticoreFuture’ ... done
[10:27:02.669] plan(): Setting new future strategy stack:
[10:27:02.669] List of future strategies:
[10:27:02.669] 1. sequential:
[10:27:02.669]    - args: function (..., envir = parent.frame())
[10:27:02.669]    - tweaked: FALSE
[10:27:02.669]    - call: NULL
[10:27:02.670] plan(): nbrOfWorkers() = 1
[10:27:02.679] run() for ‘Future’ ...
[10:27:02.679] - state: ‘created’
[10:27:02.679] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:27:02.688] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:02.688] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:27:02.689]   - Field: ‘label’
[10:27:02.689]   - Field: ‘local’
[10:27:02.689]   - Field: ‘owner’
[10:27:02.689]   - Field: ‘envir’
[10:27:02.689]   - Field: ‘workers’
[10:27:02.690]   - Field: ‘packages’
[10:27:02.690]   - Field: ‘gc’
[10:27:02.690]   - Field: ‘job’
[10:27:02.690]   - Field: ‘conditions’
[10:27:02.690]   - Field: ‘expr’
[10:27:02.690]   - Field: ‘uuid’
[10:27:02.691]   - Field: ‘seed’
[10:27:02.691]   - Field: ‘version’
[10:27:02.691]   - Field: ‘result’
[10:27:02.691]   - Field: ‘asynchronous’
[10:27:02.691]   - Field: ‘calls’
[10:27:02.691]   - Field: ‘globals’
[10:27:02.691]   - Field: ‘stdout’
[10:27:02.692]   - Field: ‘earlySignal’
[10:27:02.692]   - Field: ‘lazy’
[10:27:02.692]   - Field: ‘state’
[10:27:02.692] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:27:02.692] - Launch lazy future ...
[10:27:02.693] Packages needed by the future expression (n = 0): <none>
[10:27:02.693] Packages needed by future strategies (n = 0): <none>
[10:27:02.694] {
[10:27:02.694]     {
[10:27:02.694]         {
[10:27:02.694]             ...future.startTime <- base::Sys.time()
[10:27:02.694]             {
[10:27:02.694]                 {
[10:27:02.694]                   {
[10:27:02.694]                     {
[10:27:02.694]                       base::local({
[10:27:02.694]                         has_future <- base::requireNamespace("future", 
[10:27:02.694]                           quietly = TRUE)
[10:27:02.694]                         if (has_future) {
[10:27:02.694]                           ns <- base::getNamespace("future")
[10:27:02.694]                           version <- ns[[".package"]][["version"]]
[10:27:02.694]                           if (is.null(version)) 
[10:27:02.694]                             version <- utils::packageVersion("future")
[10:27:02.694]                         }
[10:27:02.694]                         else {
[10:27:02.694]                           version <- NULL
[10:27:02.694]                         }
[10:27:02.694]                         if (!has_future || version < "1.8.0") {
[10:27:02.694]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:02.694]                             "", base::R.version$version.string), 
[10:27:02.694]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:02.694]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:02.694]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:02.694]                               "release", "version")], collapse = " "), 
[10:27:02.694]                             hostname = base::Sys.info()[["nodename"]])
[10:27:02.694]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:02.694]                             info)
[10:27:02.694]                           info <- base::paste(info, collapse = "; ")
[10:27:02.694]                           if (!has_future) {
[10:27:02.694]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:02.694]                               info)
[10:27:02.694]                           }
[10:27:02.694]                           else {
[10:27:02.694]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:02.694]                               info, version)
[10:27:02.694]                           }
[10:27:02.694]                           base::stop(msg)
[10:27:02.694]                         }
[10:27:02.694]                       })
[10:27:02.694]                     }
[10:27:02.694]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:02.694]                     base::options(mc.cores = 1L)
[10:27:02.694]                   }
[10:27:02.694]                   options(future.plan = NULL)
[10:27:02.694]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:02.694]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:02.694]                 }
[10:27:02.694]                 ...future.workdir <- getwd()
[10:27:02.694]             }
[10:27:02.694]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:02.694]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:02.694]         }
[10:27:02.694]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:02.694]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:02.694]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:02.694]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:02.694]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:02.694]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:02.694]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:02.694]             base::names(...future.oldOptions))
[10:27:02.694]     }
[10:27:02.694]     if (FALSE) {
[10:27:02.694]     }
[10:27:02.694]     else {
[10:27:02.694]         if (TRUE) {
[10:27:02.694]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:02.694]                 open = "w")
[10:27:02.694]         }
[10:27:02.694]         else {
[10:27:02.694]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:02.694]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:02.694]         }
[10:27:02.694]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:02.694]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:02.694]             base::sink(type = "output", split = FALSE)
[10:27:02.694]             base::close(...future.stdout)
[10:27:02.694]         }, add = TRUE)
[10:27:02.694]     }
[10:27:02.694]     ...future.frame <- base::sys.nframe()
[10:27:02.694]     ...future.conditions <- base::list()
[10:27:02.694]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:02.694]     if (FALSE) {
[10:27:02.694]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:02.694]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:02.694]     }
[10:27:02.694]     ...future.result <- base::tryCatch({
[10:27:02.694]         base::withCallingHandlers({
[10:27:02.694]             ...future.value <- base::withVisible(base::local({
[10:27:02.694]                 withCallingHandlers({
[10:27:02.694]                   {
[10:27:02.694]                     Sys.sleep(0.1)
[10:27:02.694]                     kk
[10:27:02.694]                   }
[10:27:02.694]                 }, immediateCondition = function(cond) {
[10:27:02.694]                   save_rds <- function (object, pathname, ...) 
[10:27:02.694]                   {
[10:27:02.694]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:27:02.694]                     if (file_test("-f", pathname_tmp)) {
[10:27:02.694]                       fi_tmp <- file.info(pathname_tmp)
[10:27:02.694]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:27:02.694]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:02.694]                         fi_tmp[["mtime"]])
[10:27:02.694]                     }
[10:27:02.694]                     tryCatch({
[10:27:02.694]                       saveRDS(object, file = pathname_tmp, ...)
[10:27:02.694]                     }, error = function(ex) {
[10:27:02.694]                       msg <- conditionMessage(ex)
[10:27:02.694]                       fi_tmp <- file.info(pathname_tmp)
[10:27:02.694]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:27:02.694]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:02.694]                         fi_tmp[["mtime"]], msg)
[10:27:02.694]                       ex$message <- msg
[10:27:02.694]                       stop(ex)
[10:27:02.694]                     })
[10:27:02.694]                     stopifnot(file_test("-f", pathname_tmp))
[10:27:02.694]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:27:02.694]                     if (!res || file_test("-f", pathname_tmp)) {
[10:27:02.694]                       fi_tmp <- file.info(pathname_tmp)
[10:27:02.694]                       fi <- file.info(pathname)
[10:27:02.694]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:27:02.694]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:02.694]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:27:02.694]                         fi[["size"]], fi[["mtime"]])
[10:27:02.694]                       stop(msg)
[10:27:02.694]                     }
[10:27:02.694]                     invisible(pathname)
[10:27:02.694]                   }
[10:27:02.694]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:27:02.694]                     rootPath = tempdir()) 
[10:27:02.694]                   {
[10:27:02.694]                     obj <- list(time = Sys.time(), condition = cond)
[10:27:02.694]                     file <- tempfile(pattern = class(cond)[1], 
[10:27:02.694]                       tmpdir = path, fileext = ".rds")
[10:27:02.694]                     save_rds(obj, file)
[10:27:02.694]                   }
[10:27:02.694]                   saveImmediateCondition(cond, path = "/tmp/RtmpisxSDE/.future/immediateConditions")
[10:27:02.694]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:02.694]                   {
[10:27:02.694]                     inherits <- base::inherits
[10:27:02.694]                     invokeRestart <- base::invokeRestart
[10:27:02.694]                     is.null <- base::is.null
[10:27:02.694]                     muffled <- FALSE
[10:27:02.694]                     if (inherits(cond, "message")) {
[10:27:02.694]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:02.694]                       if (muffled) 
[10:27:02.694]                         invokeRestart("muffleMessage")
[10:27:02.694]                     }
[10:27:02.694]                     else if (inherits(cond, "warning")) {
[10:27:02.694]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:02.694]                       if (muffled) 
[10:27:02.694]                         invokeRestart("muffleWarning")
[10:27:02.694]                     }
[10:27:02.694]                     else if (inherits(cond, "condition")) {
[10:27:02.694]                       if (!is.null(pattern)) {
[10:27:02.694]                         computeRestarts <- base::computeRestarts
[10:27:02.694]                         grepl <- base::grepl
[10:27:02.694]                         restarts <- computeRestarts(cond)
[10:27:02.694]                         for (restart in restarts) {
[10:27:02.694]                           name <- restart$name
[10:27:02.694]                           if (is.null(name)) 
[10:27:02.694]                             next
[10:27:02.694]                           if (!grepl(pattern, name)) 
[10:27:02.694]                             next
[10:27:02.694]                           invokeRestart(restart)
[10:27:02.694]                           muffled <- TRUE
[10:27:02.694]                           break
[10:27:02.694]                         }
[10:27:02.694]                       }
[10:27:02.694]                     }
[10:27:02.694]                     invisible(muffled)
[10:27:02.694]                   }
[10:27:02.694]                   muffleCondition(cond)
[10:27:02.694]                 })
[10:27:02.694]             }))
[10:27:02.694]             future::FutureResult(value = ...future.value$value, 
[10:27:02.694]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:02.694]                   ...future.rng), globalenv = if (FALSE) 
[10:27:02.694]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:02.694]                     ...future.globalenv.names))
[10:27:02.694]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:02.694]         }, condition = base::local({
[10:27:02.694]             c <- base::c
[10:27:02.694]             inherits <- base::inherits
[10:27:02.694]             invokeRestart <- base::invokeRestart
[10:27:02.694]             length <- base::length
[10:27:02.694]             list <- base::list
[10:27:02.694]             seq.int <- base::seq.int
[10:27:02.694]             signalCondition <- base::signalCondition
[10:27:02.694]             sys.calls <- base::sys.calls
[10:27:02.694]             `[[` <- base::`[[`
[10:27:02.694]             `+` <- base::`+`
[10:27:02.694]             `<<-` <- base::`<<-`
[10:27:02.694]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:02.694]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:02.694]                   3L)]
[10:27:02.694]             }
[10:27:02.694]             function(cond) {
[10:27:02.694]                 is_error <- inherits(cond, "error")
[10:27:02.694]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:02.694]                   NULL)
[10:27:02.694]                 if (is_error) {
[10:27:02.694]                   sessionInformation <- function() {
[10:27:02.694]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:02.694]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:02.694]                       search = base::search(), system = base::Sys.info())
[10:27:02.694]                   }
[10:27:02.694]                   ...future.conditions[[length(...future.conditions) + 
[10:27:02.694]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:02.694]                     cond$call), session = sessionInformation(), 
[10:27:02.694]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:02.694]                   signalCondition(cond)
[10:27:02.694]                 }
[10:27:02.694]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:02.694]                 "immediateCondition"))) {
[10:27:02.694]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:02.694]                   ...future.conditions[[length(...future.conditions) + 
[10:27:02.694]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:02.694]                   if (TRUE && !signal) {
[10:27:02.694]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:02.694]                     {
[10:27:02.694]                       inherits <- base::inherits
[10:27:02.694]                       invokeRestart <- base::invokeRestart
[10:27:02.694]                       is.null <- base::is.null
[10:27:02.694]                       muffled <- FALSE
[10:27:02.694]                       if (inherits(cond, "message")) {
[10:27:02.694]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:02.694]                         if (muffled) 
[10:27:02.694]                           invokeRestart("muffleMessage")
[10:27:02.694]                       }
[10:27:02.694]                       else if (inherits(cond, "warning")) {
[10:27:02.694]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:02.694]                         if (muffled) 
[10:27:02.694]                           invokeRestart("muffleWarning")
[10:27:02.694]                       }
[10:27:02.694]                       else if (inherits(cond, "condition")) {
[10:27:02.694]                         if (!is.null(pattern)) {
[10:27:02.694]                           computeRestarts <- base::computeRestarts
[10:27:02.694]                           grepl <- base::grepl
[10:27:02.694]                           restarts <- computeRestarts(cond)
[10:27:02.694]                           for (restart in restarts) {
[10:27:02.694]                             name <- restart$name
[10:27:02.694]                             if (is.null(name)) 
[10:27:02.694]                               next
[10:27:02.694]                             if (!grepl(pattern, name)) 
[10:27:02.694]                               next
[10:27:02.694]                             invokeRestart(restart)
[10:27:02.694]                             muffled <- TRUE
[10:27:02.694]                             break
[10:27:02.694]                           }
[10:27:02.694]                         }
[10:27:02.694]                       }
[10:27:02.694]                       invisible(muffled)
[10:27:02.694]                     }
[10:27:02.694]                     muffleCondition(cond, pattern = "^muffle")
[10:27:02.694]                   }
[10:27:02.694]                 }
[10:27:02.694]                 else {
[10:27:02.694]                   if (TRUE) {
[10:27:02.694]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:02.694]                     {
[10:27:02.694]                       inherits <- base::inherits
[10:27:02.694]                       invokeRestart <- base::invokeRestart
[10:27:02.694]                       is.null <- base::is.null
[10:27:02.694]                       muffled <- FALSE
[10:27:02.694]                       if (inherits(cond, "message")) {
[10:27:02.694]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:02.694]                         if (muffled) 
[10:27:02.694]                           invokeRestart("muffleMessage")
[10:27:02.694]                       }
[10:27:02.694]                       else if (inherits(cond, "warning")) {
[10:27:02.694]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:02.694]                         if (muffled) 
[10:27:02.694]                           invokeRestart("muffleWarning")
[10:27:02.694]                       }
[10:27:02.694]                       else if (inherits(cond, "condition")) {
[10:27:02.694]                         if (!is.null(pattern)) {
[10:27:02.694]                           computeRestarts <- base::computeRestarts
[10:27:02.694]                           grepl <- base::grepl
[10:27:02.694]                           restarts <- computeRestarts(cond)
[10:27:02.694]                           for (restart in restarts) {
[10:27:02.694]                             name <- restart$name
[10:27:02.694]                             if (is.null(name)) 
[10:27:02.694]                               next
[10:27:02.694]                             if (!grepl(pattern, name)) 
[10:27:02.694]                               next
[10:27:02.694]                             invokeRestart(restart)
[10:27:02.694]                             muffled <- TRUE
[10:27:02.694]                             break
[10:27:02.694]                           }
[10:27:02.694]                         }
[10:27:02.694]                       }
[10:27:02.694]                       invisible(muffled)
[10:27:02.694]                     }
[10:27:02.694]                     muffleCondition(cond, pattern = "^muffle")
[10:27:02.694]                   }
[10:27:02.694]                 }
[10:27:02.694]             }
[10:27:02.694]         }))
[10:27:02.694]     }, error = function(ex) {
[10:27:02.694]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:02.694]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:02.694]                 ...future.rng), started = ...future.startTime, 
[10:27:02.694]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:02.694]             version = "1.8"), class = "FutureResult")
[10:27:02.694]     }, finally = {
[10:27:02.694]         if (!identical(...future.workdir, getwd())) 
[10:27:02.694]             setwd(...future.workdir)
[10:27:02.694]         {
[10:27:02.694]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:02.694]                 ...future.oldOptions$nwarnings <- NULL
[10:27:02.694]             }
[10:27:02.694]             base::options(...future.oldOptions)
[10:27:02.694]             if (.Platform$OS.type == "windows") {
[10:27:02.694]                 old_names <- names(...future.oldEnvVars)
[10:27:02.694]                 envs <- base::Sys.getenv()
[10:27:02.694]                 names <- names(envs)
[10:27:02.694]                 common <- intersect(names, old_names)
[10:27:02.694]                 added <- setdiff(names, old_names)
[10:27:02.694]                 removed <- setdiff(old_names, names)
[10:27:02.694]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:02.694]                   envs[common]]
[10:27:02.694]                 NAMES <- toupper(changed)
[10:27:02.694]                 args <- list()
[10:27:02.694]                 for (kk in seq_along(NAMES)) {
[10:27:02.694]                   name <- changed[[kk]]
[10:27:02.694]                   NAME <- NAMES[[kk]]
[10:27:02.694]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:02.694]                     next
[10:27:02.694]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:02.694]                 }
[10:27:02.694]                 NAMES <- toupper(added)
[10:27:02.694]                 for (kk in seq_along(NAMES)) {
[10:27:02.694]                   name <- added[[kk]]
[10:27:02.694]                   NAME <- NAMES[[kk]]
[10:27:02.694]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:02.694]                     next
[10:27:02.694]                   args[[name]] <- ""
[10:27:02.694]                 }
[10:27:02.694]                 NAMES <- toupper(removed)
[10:27:02.694]                 for (kk in seq_along(NAMES)) {
[10:27:02.694]                   name <- removed[[kk]]
[10:27:02.694]                   NAME <- NAMES[[kk]]
[10:27:02.694]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:02.694]                     next
[10:27:02.694]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:02.694]                 }
[10:27:02.694]                 if (length(args) > 0) 
[10:27:02.694]                   base::do.call(base::Sys.setenv, args = args)
[10:27:02.694]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:02.694]             }
[10:27:02.694]             else {
[10:27:02.694]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:02.694]             }
[10:27:02.694]             {
[10:27:02.694]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:02.694]                   0L) {
[10:27:02.694]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:02.694]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:02.694]                   base::options(opts)
[10:27:02.694]                 }
[10:27:02.694]                 {
[10:27:02.694]                   {
[10:27:02.694]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:02.694]                     NULL
[10:27:02.694]                   }
[10:27:02.694]                   options(future.plan = NULL)
[10:27:02.694]                   if (is.na(NA_character_)) 
[10:27:02.694]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:02.694]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:02.694]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:27:02.694]                     envir = parent.frame()) 
[10:27:02.694]                   {
[10:27:02.694]                     default_workers <- missing(workers)
[10:27:02.694]                     if (is.function(workers)) 
[10:27:02.694]                       workers <- workers()
[10:27:02.694]                     workers <- structure(as.integer(workers), 
[10:27:02.694]                       class = class(workers))
[10:27:02.694]                     stop_if_not(is.finite(workers), workers >= 
[10:27:02.694]                       1L)
[10:27:02.694]                     if ((workers == 1L && !inherits(workers, 
[10:27:02.694]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:27:02.694]                       if (default_workers) 
[10:27:02.694]                         supportsMulticore(warn = TRUE)
[10:27:02.694]                       return(sequential(..., envir = envir))
[10:27:02.694]                     }
[10:27:02.694]                     oopts <- options(mc.cores = workers)
[10:27:02.694]                     on.exit(options(oopts))
[10:27:02.694]                     future <- MulticoreFuture(..., workers = workers, 
[10:27:02.694]                       envir = envir)
[10:27:02.694]                     if (!future$lazy) 
[10:27:02.694]                       future <- run(future)
[10:27:02.694]                     invisible(future)
[10:27:02.694]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:02.694]                 }
[10:27:02.694]             }
[10:27:02.694]         }
[10:27:02.694]     })
[10:27:02.694]     if (TRUE) {
[10:27:02.694]         base::sink(type = "output", split = FALSE)
[10:27:02.694]         if (TRUE) {
[10:27:02.694]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:02.694]         }
[10:27:02.694]         else {
[10:27:02.694]             ...future.result["stdout"] <- base::list(NULL)
[10:27:02.694]         }
[10:27:02.694]         base::close(...future.stdout)
[10:27:02.694]         ...future.stdout <- NULL
[10:27:02.694]     }
[10:27:02.694]     ...future.result$conditions <- ...future.conditions
[10:27:02.694]     ...future.result$finished <- base::Sys.time()
[10:27:02.694]     ...future.result
[10:27:02.694] }
[10:27:02.698] assign_globals() ...
[10:27:02.698] List of 1
[10:27:02.698]  $ kk: int 2
[10:27:02.698]  - attr(*, "where")=List of 1
[10:27:02.698]   ..$ kk:<environment: R_EmptyEnv> 
[10:27:02.698]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:27:02.698]  - attr(*, "resolved")= logi FALSE
[10:27:02.698]  - attr(*, "total_size")= num 56
[10:27:02.698]  - attr(*, "already-done")= logi TRUE
[10:27:02.702] - copied ‘kk’ to environment
[10:27:02.703] assign_globals() ... done
[10:27:02.703] requestCore(): workers = 2
[10:27:02.703] Poll #1 (0): usedCores() = 2, workers = 2
[10:27:02.714] result() for MulticoreFuture ...
[10:27:02.716] result() for MulticoreFuture ...
[10:27:02.716] result() for MulticoreFuture ... done
[10:27:02.716] result() for MulticoreFuture ... done
[10:27:02.717] result() for MulticoreFuture ...
[10:27:02.717] result() for MulticoreFuture ... done
[10:27:02.720] MulticoreFuture started
[10:27:02.721] - Launch lazy future ... done
[10:27:02.721] run() for ‘MulticoreFuture’ ... done
[10:27:02.721] plan(): Setting new future strategy stack:
[10:27:02.722] List of future strategies:
[10:27:02.722] 1. sequential:
[10:27:02.722]    - args: function (..., envir = parent.frame())
[10:27:02.722]    - tweaked: FALSE
[10:27:02.722]    - call: NULL
[10:27:02.722] plan(): nbrOfWorkers() = 1
[10:27:02.732] run() for ‘Future’ ...
[10:27:02.732] - state: ‘created’
[10:27:02.732] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:27:02.740] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:02.740] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:27:02.740]   - Field: ‘label’
[10:27:02.741]   - Field: ‘local’
[10:27:02.741]   - Field: ‘owner’
[10:27:02.742]   - Field: ‘envir’
[10:27:02.742]   - Field: ‘workers’
[10:27:02.743]   - Field: ‘packages’
[10:27:02.743]   - Field: ‘gc’
[10:27:02.744]   - Field: ‘job’
[10:27:02.745]   - Field: ‘conditions’
[10:27:02.746]   - Field: ‘expr’
[10:27:02.746]   - Field: ‘uuid’
[10:27:02.746]   - Field: ‘seed’
[10:27:02.746]   - Field: ‘version’
[10:27:02.746]   - Field: ‘result’
[10:27:02.747]   - Field: ‘asynchronous’
[10:27:02.747]   - Field: ‘calls’
[10:27:02.747]   - Field: ‘globals’
[10:27:02.747]   - Field: ‘stdout’
[10:27:02.747]   - Field: ‘earlySignal’
[10:27:02.747]   - Field: ‘lazy’
[10:27:02.747]   - Field: ‘state’
[10:27:02.748] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:27:02.748] - Launch lazy future ...
[10:27:02.748] Packages needed by the future expression (n = 0): <none>
[10:27:02.749] Packages needed by future strategies (n = 0): <none>
[10:27:02.749] {
[10:27:02.749]     {
[10:27:02.749]         {
[10:27:02.749]             ...future.startTime <- base::Sys.time()
[10:27:02.749]             {
[10:27:02.749]                 {
[10:27:02.749]                   {
[10:27:02.749]                     {
[10:27:02.749]                       base::local({
[10:27:02.749]                         has_future <- base::requireNamespace("future", 
[10:27:02.749]                           quietly = TRUE)
[10:27:02.749]                         if (has_future) {
[10:27:02.749]                           ns <- base::getNamespace("future")
[10:27:02.749]                           version <- ns[[".package"]][["version"]]
[10:27:02.749]                           if (is.null(version)) 
[10:27:02.749]                             version <- utils::packageVersion("future")
[10:27:02.749]                         }
[10:27:02.749]                         else {
[10:27:02.749]                           version <- NULL
[10:27:02.749]                         }
[10:27:02.749]                         if (!has_future || version < "1.8.0") {
[10:27:02.749]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:02.749]                             "", base::R.version$version.string), 
[10:27:02.749]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:02.749]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:02.749]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:02.749]                               "release", "version")], collapse = " "), 
[10:27:02.749]                             hostname = base::Sys.info()[["nodename"]])
[10:27:02.749]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:02.749]                             info)
[10:27:02.749]                           info <- base::paste(info, collapse = "; ")
[10:27:02.749]                           if (!has_future) {
[10:27:02.749]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:02.749]                               info)
[10:27:02.749]                           }
[10:27:02.749]                           else {
[10:27:02.749]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:02.749]                               info, version)
[10:27:02.749]                           }
[10:27:02.749]                           base::stop(msg)
[10:27:02.749]                         }
[10:27:02.749]                       })
[10:27:02.749]                     }
[10:27:02.749]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:02.749]                     base::options(mc.cores = 1L)
[10:27:02.749]                   }
[10:27:02.749]                   options(future.plan = NULL)
[10:27:02.749]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:02.749]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:02.749]                 }
[10:27:02.749]                 ...future.workdir <- getwd()
[10:27:02.749]             }
[10:27:02.749]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:02.749]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:02.749]         }
[10:27:02.749]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:02.749]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:02.749]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:02.749]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:02.749]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:02.749]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:02.749]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:02.749]             base::names(...future.oldOptions))
[10:27:02.749]     }
[10:27:02.749]     if (FALSE) {
[10:27:02.749]     }
[10:27:02.749]     else {
[10:27:02.749]         if (TRUE) {
[10:27:02.749]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:02.749]                 open = "w")
[10:27:02.749]         }
[10:27:02.749]         else {
[10:27:02.749]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:02.749]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:02.749]         }
[10:27:02.749]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:02.749]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:02.749]             base::sink(type = "output", split = FALSE)
[10:27:02.749]             base::close(...future.stdout)
[10:27:02.749]         }, add = TRUE)
[10:27:02.749]     }
[10:27:02.749]     ...future.frame <- base::sys.nframe()
[10:27:02.749]     ...future.conditions <- base::list()
[10:27:02.749]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:02.749]     if (FALSE) {
[10:27:02.749]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:02.749]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:02.749]     }
[10:27:02.749]     ...future.result <- base::tryCatch({
[10:27:02.749]         base::withCallingHandlers({
[10:27:02.749]             ...future.value <- base::withVisible(base::local({
[10:27:02.749]                 withCallingHandlers({
[10:27:02.749]                   {
[10:27:02.749]                     Sys.sleep(0.1)
[10:27:02.749]                     kk
[10:27:02.749]                   }
[10:27:02.749]                 }, immediateCondition = function(cond) {
[10:27:02.749]                   save_rds <- function (object, pathname, ...) 
[10:27:02.749]                   {
[10:27:02.749]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:27:02.749]                     if (file_test("-f", pathname_tmp)) {
[10:27:02.749]                       fi_tmp <- file.info(pathname_tmp)
[10:27:02.749]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:27:02.749]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:02.749]                         fi_tmp[["mtime"]])
[10:27:02.749]                     }
[10:27:02.749]                     tryCatch({
[10:27:02.749]                       saveRDS(object, file = pathname_tmp, ...)
[10:27:02.749]                     }, error = function(ex) {
[10:27:02.749]                       msg <- conditionMessage(ex)
[10:27:02.749]                       fi_tmp <- file.info(pathname_tmp)
[10:27:02.749]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:27:02.749]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:02.749]                         fi_tmp[["mtime"]], msg)
[10:27:02.749]                       ex$message <- msg
[10:27:02.749]                       stop(ex)
[10:27:02.749]                     })
[10:27:02.749]                     stopifnot(file_test("-f", pathname_tmp))
[10:27:02.749]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:27:02.749]                     if (!res || file_test("-f", pathname_tmp)) {
[10:27:02.749]                       fi_tmp <- file.info(pathname_tmp)
[10:27:02.749]                       fi <- file.info(pathname)
[10:27:02.749]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:27:02.749]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:02.749]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:27:02.749]                         fi[["size"]], fi[["mtime"]])
[10:27:02.749]                       stop(msg)
[10:27:02.749]                     }
[10:27:02.749]                     invisible(pathname)
[10:27:02.749]                   }
[10:27:02.749]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:27:02.749]                     rootPath = tempdir()) 
[10:27:02.749]                   {
[10:27:02.749]                     obj <- list(time = Sys.time(), condition = cond)
[10:27:02.749]                     file <- tempfile(pattern = class(cond)[1], 
[10:27:02.749]                       tmpdir = path, fileext = ".rds")
[10:27:02.749]                     save_rds(obj, file)
[10:27:02.749]                   }
[10:27:02.749]                   saveImmediateCondition(cond, path = "/tmp/RtmpisxSDE/.future/immediateConditions")
[10:27:02.749]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:02.749]                   {
[10:27:02.749]                     inherits <- base::inherits
[10:27:02.749]                     invokeRestart <- base::invokeRestart
[10:27:02.749]                     is.null <- base::is.null
[10:27:02.749]                     muffled <- FALSE
[10:27:02.749]                     if (inherits(cond, "message")) {
[10:27:02.749]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:02.749]                       if (muffled) 
[10:27:02.749]                         invokeRestart("muffleMessage")
[10:27:02.749]                     }
[10:27:02.749]                     else if (inherits(cond, "warning")) {
[10:27:02.749]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:02.749]                       if (muffled) 
[10:27:02.749]                         invokeRestart("muffleWarning")
[10:27:02.749]                     }
[10:27:02.749]                     else if (inherits(cond, "condition")) {
[10:27:02.749]                       if (!is.null(pattern)) {
[10:27:02.749]                         computeRestarts <- base::computeRestarts
[10:27:02.749]                         grepl <- base::grepl
[10:27:02.749]                         restarts <- computeRestarts(cond)
[10:27:02.749]                         for (restart in restarts) {
[10:27:02.749]                           name <- restart$name
[10:27:02.749]                           if (is.null(name)) 
[10:27:02.749]                             next
[10:27:02.749]                           if (!grepl(pattern, name)) 
[10:27:02.749]                             next
[10:27:02.749]                           invokeRestart(restart)
[10:27:02.749]                           muffled <- TRUE
[10:27:02.749]                           break
[10:27:02.749]                         }
[10:27:02.749]                       }
[10:27:02.749]                     }
[10:27:02.749]                     invisible(muffled)
[10:27:02.749]                   }
[10:27:02.749]                   muffleCondition(cond)
[10:27:02.749]                 })
[10:27:02.749]             }))
[10:27:02.749]             future::FutureResult(value = ...future.value$value, 
[10:27:02.749]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:02.749]                   ...future.rng), globalenv = if (FALSE) 
[10:27:02.749]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:02.749]                     ...future.globalenv.names))
[10:27:02.749]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:02.749]         }, condition = base::local({
[10:27:02.749]             c <- base::c
[10:27:02.749]             inherits <- base::inherits
[10:27:02.749]             invokeRestart <- base::invokeRestart
[10:27:02.749]             length <- base::length
[10:27:02.749]             list <- base::list
[10:27:02.749]             seq.int <- base::seq.int
[10:27:02.749]             signalCondition <- base::signalCondition
[10:27:02.749]             sys.calls <- base::sys.calls
[10:27:02.749]             `[[` <- base::`[[`
[10:27:02.749]             `+` <- base::`+`
[10:27:02.749]             `<<-` <- base::`<<-`
[10:27:02.749]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:02.749]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:02.749]                   3L)]
[10:27:02.749]             }
[10:27:02.749]             function(cond) {
[10:27:02.749]                 is_error <- inherits(cond, "error")
[10:27:02.749]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:02.749]                   NULL)
[10:27:02.749]                 if (is_error) {
[10:27:02.749]                   sessionInformation <- function() {
[10:27:02.749]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:02.749]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:02.749]                       search = base::search(), system = base::Sys.info())
[10:27:02.749]                   }
[10:27:02.749]                   ...future.conditions[[length(...future.conditions) + 
[10:27:02.749]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:02.749]                     cond$call), session = sessionInformation(), 
[10:27:02.749]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:02.749]                   signalCondition(cond)
[10:27:02.749]                 }
[10:27:02.749]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:02.749]                 "immediateCondition"))) {
[10:27:02.749]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:02.749]                   ...future.conditions[[length(...future.conditions) + 
[10:27:02.749]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:02.749]                   if (TRUE && !signal) {
[10:27:02.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:02.749]                     {
[10:27:02.749]                       inherits <- base::inherits
[10:27:02.749]                       invokeRestart <- base::invokeRestart
[10:27:02.749]                       is.null <- base::is.null
[10:27:02.749]                       muffled <- FALSE
[10:27:02.749]                       if (inherits(cond, "message")) {
[10:27:02.749]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:02.749]                         if (muffled) 
[10:27:02.749]                           invokeRestart("muffleMessage")
[10:27:02.749]                       }
[10:27:02.749]                       else if (inherits(cond, "warning")) {
[10:27:02.749]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:02.749]                         if (muffled) 
[10:27:02.749]                           invokeRestart("muffleWarning")
[10:27:02.749]                       }
[10:27:02.749]                       else if (inherits(cond, "condition")) {
[10:27:02.749]                         if (!is.null(pattern)) {
[10:27:02.749]                           computeRestarts <- base::computeRestarts
[10:27:02.749]                           grepl <- base::grepl
[10:27:02.749]                           restarts <- computeRestarts(cond)
[10:27:02.749]                           for (restart in restarts) {
[10:27:02.749]                             name <- restart$name
[10:27:02.749]                             if (is.null(name)) 
[10:27:02.749]                               next
[10:27:02.749]                             if (!grepl(pattern, name)) 
[10:27:02.749]                               next
[10:27:02.749]                             invokeRestart(restart)
[10:27:02.749]                             muffled <- TRUE
[10:27:02.749]                             break
[10:27:02.749]                           }
[10:27:02.749]                         }
[10:27:02.749]                       }
[10:27:02.749]                       invisible(muffled)
[10:27:02.749]                     }
[10:27:02.749]                     muffleCondition(cond, pattern = "^muffle")
[10:27:02.749]                   }
[10:27:02.749]                 }
[10:27:02.749]                 else {
[10:27:02.749]                   if (TRUE) {
[10:27:02.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:02.749]                     {
[10:27:02.749]                       inherits <- base::inherits
[10:27:02.749]                       invokeRestart <- base::invokeRestart
[10:27:02.749]                       is.null <- base::is.null
[10:27:02.749]                       muffled <- FALSE
[10:27:02.749]                       if (inherits(cond, "message")) {
[10:27:02.749]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:02.749]                         if (muffled) 
[10:27:02.749]                           invokeRestart("muffleMessage")
[10:27:02.749]                       }
[10:27:02.749]                       else if (inherits(cond, "warning")) {
[10:27:02.749]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:02.749]                         if (muffled) 
[10:27:02.749]                           invokeRestart("muffleWarning")
[10:27:02.749]                       }
[10:27:02.749]                       else if (inherits(cond, "condition")) {
[10:27:02.749]                         if (!is.null(pattern)) {
[10:27:02.749]                           computeRestarts <- base::computeRestarts
[10:27:02.749]                           grepl <- base::grepl
[10:27:02.749]                           restarts <- computeRestarts(cond)
[10:27:02.749]                           for (restart in restarts) {
[10:27:02.749]                             name <- restart$name
[10:27:02.749]                             if (is.null(name)) 
[10:27:02.749]                               next
[10:27:02.749]                             if (!grepl(pattern, name)) 
[10:27:02.749]                               next
[10:27:02.749]                             invokeRestart(restart)
[10:27:02.749]                             muffled <- TRUE
[10:27:02.749]                             break
[10:27:02.749]                           }
[10:27:02.749]                         }
[10:27:02.749]                       }
[10:27:02.749]                       invisible(muffled)
[10:27:02.749]                     }
[10:27:02.749]                     muffleCondition(cond, pattern = "^muffle")
[10:27:02.749]                   }
[10:27:02.749]                 }
[10:27:02.749]             }
[10:27:02.749]         }))
[10:27:02.749]     }, error = function(ex) {
[10:27:02.749]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:02.749]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:02.749]                 ...future.rng), started = ...future.startTime, 
[10:27:02.749]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:02.749]             version = "1.8"), class = "FutureResult")
[10:27:02.749]     }, finally = {
[10:27:02.749]         if (!identical(...future.workdir, getwd())) 
[10:27:02.749]             setwd(...future.workdir)
[10:27:02.749]         {
[10:27:02.749]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:02.749]                 ...future.oldOptions$nwarnings <- NULL
[10:27:02.749]             }
[10:27:02.749]             base::options(...future.oldOptions)
[10:27:02.749]             if (.Platform$OS.type == "windows") {
[10:27:02.749]                 old_names <- names(...future.oldEnvVars)
[10:27:02.749]                 envs <- base::Sys.getenv()
[10:27:02.749]                 names <- names(envs)
[10:27:02.749]                 common <- intersect(names, old_names)
[10:27:02.749]                 added <- setdiff(names, old_names)
[10:27:02.749]                 removed <- setdiff(old_names, names)
[10:27:02.749]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:02.749]                   envs[common]]
[10:27:02.749]                 NAMES <- toupper(changed)
[10:27:02.749]                 args <- list()
[10:27:02.749]                 for (kk in seq_along(NAMES)) {
[10:27:02.749]                   name <- changed[[kk]]
[10:27:02.749]                   NAME <- NAMES[[kk]]
[10:27:02.749]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:02.749]                     next
[10:27:02.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:02.749]                 }
[10:27:02.749]                 NAMES <- toupper(added)
[10:27:02.749]                 for (kk in seq_along(NAMES)) {
[10:27:02.749]                   name <- added[[kk]]
[10:27:02.749]                   NAME <- NAMES[[kk]]
[10:27:02.749]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:02.749]                     next
[10:27:02.749]                   args[[name]] <- ""
[10:27:02.749]                 }
[10:27:02.749]                 NAMES <- toupper(removed)
[10:27:02.749]                 for (kk in seq_along(NAMES)) {
[10:27:02.749]                   name <- removed[[kk]]
[10:27:02.749]                   NAME <- NAMES[[kk]]
[10:27:02.749]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:02.749]                     next
[10:27:02.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:02.749]                 }
[10:27:02.749]                 if (length(args) > 0) 
[10:27:02.749]                   base::do.call(base::Sys.setenv, args = args)
[10:27:02.749]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:02.749]             }
[10:27:02.749]             else {
[10:27:02.749]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:02.749]             }
[10:27:02.749]             {
[10:27:02.749]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:02.749]                   0L) {
[10:27:02.749]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:02.749]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:02.749]                   base::options(opts)
[10:27:02.749]                 }
[10:27:02.749]                 {
[10:27:02.749]                   {
[10:27:02.749]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:02.749]                     NULL
[10:27:02.749]                   }
[10:27:02.749]                   options(future.plan = NULL)
[10:27:02.749]                   if (is.na(NA_character_)) 
[10:27:02.749]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:02.749]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:02.749]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:27:02.749]                     envir = parent.frame()) 
[10:27:02.749]                   {
[10:27:02.749]                     default_workers <- missing(workers)
[10:27:02.749]                     if (is.function(workers)) 
[10:27:02.749]                       workers <- workers()
[10:27:02.749]                     workers <- structure(as.integer(workers), 
[10:27:02.749]                       class = class(workers))
[10:27:02.749]                     stop_if_not(is.finite(workers), workers >= 
[10:27:02.749]                       1L)
[10:27:02.749]                     if ((workers == 1L && !inherits(workers, 
[10:27:02.749]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:27:02.749]                       if (default_workers) 
[10:27:02.749]                         supportsMulticore(warn = TRUE)
[10:27:02.749]                       return(sequential(..., envir = envir))
[10:27:02.749]                     }
[10:27:02.749]                     oopts <- options(mc.cores = workers)
[10:27:02.749]                     on.exit(options(oopts))
[10:27:02.749]                     future <- MulticoreFuture(..., workers = workers, 
[10:27:02.749]                       envir = envir)
[10:27:02.749]                     if (!future$lazy) 
[10:27:02.749]                       future <- run(future)
[10:27:02.749]                     invisible(future)
[10:27:02.749]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:02.749]                 }
[10:27:02.749]             }
[10:27:02.749]         }
[10:27:02.749]     })
[10:27:02.749]     if (TRUE) {
[10:27:02.749]         base::sink(type = "output", split = FALSE)
[10:27:02.749]         if (TRUE) {
[10:27:02.749]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:02.749]         }
[10:27:02.749]         else {
[10:27:02.749]             ...future.result["stdout"] <- base::list(NULL)
[10:27:02.749]         }
[10:27:02.749]         base::close(...future.stdout)
[10:27:02.749]         ...future.stdout <- NULL
[10:27:02.749]     }
[10:27:02.749]     ...future.result$conditions <- ...future.conditions
[10:27:02.749]     ...future.result$finished <- base::Sys.time()
[10:27:02.749]     ...future.result
[10:27:02.749] }
[10:27:02.753] assign_globals() ...
[10:27:02.753] List of 1
[10:27:02.753]  $ kk: int 3
[10:27:02.753]  - attr(*, "where")=List of 1
[10:27:02.753]   ..$ kk:<environment: R_EmptyEnv> 
[10:27:02.753]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:27:02.753]  - attr(*, "resolved")= logi FALSE
[10:27:02.753]  - attr(*, "total_size")= num 56
[10:27:02.753]  - attr(*, "already-done")= logi TRUE
[10:27:02.762] - copied ‘kk’ to environment
[10:27:02.762] assign_globals() ... done
[10:27:02.762] requestCore(): workers = 2
[10:27:02.763] Poll #1 (0): usedCores() = 2, workers = 2
[10:27:02.773] plan(): Setting new future strategy stack:
[10:27:02.773] List of future strategies:
[10:27:02.773] 1. multicore:
[10:27:02.773]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:27:02.773]    - tweaked: FALSE
[10:27:02.773]    - call: plan(strategy)
[10:27:02.779] plan(): nbrOfWorkers() = 2
[10:27:02.780] result() for MulticoreFuture ...
[10:27:02.782] result() for MulticoreFuture ...
[10:27:02.782] result() for MulticoreFuture ... done
[10:27:02.782] result() for MulticoreFuture ... done
[10:27:02.782] result() for MulticoreFuture ...
[10:27:02.783] result() for MulticoreFuture ... done
[10:27:02.786] MulticoreFuture started
[10:27:02.787] - Launch lazy future ... done
[10:27:02.788] run() for ‘MulticoreFuture’ ... done
[10:27:02.789] plan(): Setting new future strategy stack:
[10:27:02.790] List of future strategies:
[10:27:02.790] 1. sequential:
[10:27:02.790]    - args: function (..., envir = parent.frame())
[10:27:02.790]    - tweaked: FALSE
[10:27:02.790]    - call: NULL
[10:27:02.792] plan(): nbrOfWorkers() = 1
[10:27:02.810] Future #1
[10:27:02.810]  length: 2 (resolved future 1)
[10:27:02.826] plan(): Setting new future strategy stack:
[10:27:02.826] List of future strategies:
[10:27:02.826] 1. multicore:
[10:27:02.826]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:27:02.826]    - tweaked: FALSE
[10:27:02.826]    - call: plan(strategy)
[10:27:02.831] plan(): nbrOfWorkers() = 2
[10:27:02.842] Future #2
[10:27:02.842]  length: 1 (resolved future 2)
[10:27:02.897] plan(): Setting new future strategy stack:
[10:27:02.898] List of future strategies:
[10:27:02.898] 1. multicore:
[10:27:02.898]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:27:02.898]    - tweaked: FALSE
[10:27:02.898]    - call: plan(strategy)
[10:27:02.904] plan(): nbrOfWorkers() = 2
[10:27:02.905] Future #3
[10:27:02.905]  length: 0 (resolved future 3)
[10:27:02.905] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[10:27:02.907] resolve() on environment ...
[10:27:02.907]  recursive: 0
[10:27:02.908]  elements: [2] ‘a’, ‘b’
[10:27:02.909]  length: 1 (resolved future 1)
[10:27:02.909]  length: 0 (resolved future 2)
[10:27:02.909] resolve() on environment ... DONE
[10:27:02.910] getGlobalsAndPackages() ...
[10:27:02.910] Searching for globals...
[10:27:02.911] 
[10:27:02.911] Searching for globals ... DONE
[10:27:02.911] - globals: [0] <none>
[10:27:02.911] getGlobalsAndPackages() ... DONE
[10:27:02.912] run() for ‘Future’ ...
[10:27:02.912] - state: ‘created’
[10:27:02.912] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:27:02.922] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:02.922] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:27:02.923]   - Field: ‘label’
[10:27:02.923]   - Field: ‘local’
[10:27:02.923]   - Field: ‘owner’
[10:27:02.923]   - Field: ‘envir’
[10:27:02.924]   - Field: ‘workers’
[10:27:02.924]   - Field: ‘packages’
[10:27:02.924]   - Field: ‘gc’
[10:27:02.924]   - Field: ‘job’
[10:27:02.924]   - Field: ‘conditions’
[10:27:02.924]   - Field: ‘expr’
[10:27:02.924]   - Field: ‘uuid’
[10:27:02.925]   - Field: ‘seed’
[10:27:02.925]   - Field: ‘version’
[10:27:02.925]   - Field: ‘result’
[10:27:02.925]   - Field: ‘asynchronous’
[10:27:02.925]   - Field: ‘calls’
[10:27:02.925]   - Field: ‘globals’
[10:27:02.926]   - Field: ‘stdout’
[10:27:02.926]   - Field: ‘earlySignal’
[10:27:02.926]   - Field: ‘lazy’
[10:27:02.926]   - Field: ‘state’
[10:27:02.926] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:27:02.927] - Launch lazy future ...
[10:27:02.927] Packages needed by the future expression (n = 0): <none>
[10:27:02.927] Packages needed by future strategies (n = 0): <none>
[10:27:02.928] {
[10:27:02.928]     {
[10:27:02.928]         {
[10:27:02.928]             ...future.startTime <- base::Sys.time()
[10:27:02.928]             {
[10:27:02.928]                 {
[10:27:02.928]                   {
[10:27:02.928]                     {
[10:27:02.928]                       base::local({
[10:27:02.928]                         has_future <- base::requireNamespace("future", 
[10:27:02.928]                           quietly = TRUE)
[10:27:02.928]                         if (has_future) {
[10:27:02.928]                           ns <- base::getNamespace("future")
[10:27:02.928]                           version <- ns[[".package"]][["version"]]
[10:27:02.928]                           if (is.null(version)) 
[10:27:02.928]                             version <- utils::packageVersion("future")
[10:27:02.928]                         }
[10:27:02.928]                         else {
[10:27:02.928]                           version <- NULL
[10:27:02.928]                         }
[10:27:02.928]                         if (!has_future || version < "1.8.0") {
[10:27:02.928]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:02.928]                             "", base::R.version$version.string), 
[10:27:02.928]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:02.928]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:02.928]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:02.928]                               "release", "version")], collapse = " "), 
[10:27:02.928]                             hostname = base::Sys.info()[["nodename"]])
[10:27:02.928]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:02.928]                             info)
[10:27:02.928]                           info <- base::paste(info, collapse = "; ")
[10:27:02.928]                           if (!has_future) {
[10:27:02.928]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:02.928]                               info)
[10:27:02.928]                           }
[10:27:02.928]                           else {
[10:27:02.928]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:02.928]                               info, version)
[10:27:02.928]                           }
[10:27:02.928]                           base::stop(msg)
[10:27:02.928]                         }
[10:27:02.928]                       })
[10:27:02.928]                     }
[10:27:02.928]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:02.928]                     base::options(mc.cores = 1L)
[10:27:02.928]                   }
[10:27:02.928]                   options(future.plan = NULL)
[10:27:02.928]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:02.928]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:02.928]                 }
[10:27:02.928]                 ...future.workdir <- getwd()
[10:27:02.928]             }
[10:27:02.928]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:02.928]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:02.928]         }
[10:27:02.928]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:02.928]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:02.928]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:02.928]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:02.928]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:02.928]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:02.928]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:02.928]             base::names(...future.oldOptions))
[10:27:02.928]     }
[10:27:02.928]     if (FALSE) {
[10:27:02.928]     }
[10:27:02.928]     else {
[10:27:02.928]         if (TRUE) {
[10:27:02.928]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:02.928]                 open = "w")
[10:27:02.928]         }
[10:27:02.928]         else {
[10:27:02.928]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:02.928]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:02.928]         }
[10:27:02.928]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:02.928]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:02.928]             base::sink(type = "output", split = FALSE)
[10:27:02.928]             base::close(...future.stdout)
[10:27:02.928]         }, add = TRUE)
[10:27:02.928]     }
[10:27:02.928]     ...future.frame <- base::sys.nframe()
[10:27:02.928]     ...future.conditions <- base::list()
[10:27:02.928]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:02.928]     if (FALSE) {
[10:27:02.928]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:02.928]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:02.928]     }
[10:27:02.928]     ...future.result <- base::tryCatch({
[10:27:02.928]         base::withCallingHandlers({
[10:27:02.928]             ...future.value <- base::withVisible(base::local({
[10:27:02.928]                 withCallingHandlers({
[10:27:02.928]                   1
[10:27:02.928]                 }, immediateCondition = function(cond) {
[10:27:02.928]                   save_rds <- function (object, pathname, ...) 
[10:27:02.928]                   {
[10:27:02.928]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:27:02.928]                     if (file_test("-f", pathname_tmp)) {
[10:27:02.928]                       fi_tmp <- file.info(pathname_tmp)
[10:27:02.928]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:27:02.928]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:02.928]                         fi_tmp[["mtime"]])
[10:27:02.928]                     }
[10:27:02.928]                     tryCatch({
[10:27:02.928]                       saveRDS(object, file = pathname_tmp, ...)
[10:27:02.928]                     }, error = function(ex) {
[10:27:02.928]                       msg <- conditionMessage(ex)
[10:27:02.928]                       fi_tmp <- file.info(pathname_tmp)
[10:27:02.928]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:27:02.928]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:02.928]                         fi_tmp[["mtime"]], msg)
[10:27:02.928]                       ex$message <- msg
[10:27:02.928]                       stop(ex)
[10:27:02.928]                     })
[10:27:02.928]                     stopifnot(file_test("-f", pathname_tmp))
[10:27:02.928]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:27:02.928]                     if (!res || file_test("-f", pathname_tmp)) {
[10:27:02.928]                       fi_tmp <- file.info(pathname_tmp)
[10:27:02.928]                       fi <- file.info(pathname)
[10:27:02.928]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:27:02.928]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:02.928]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:27:02.928]                         fi[["size"]], fi[["mtime"]])
[10:27:02.928]                       stop(msg)
[10:27:02.928]                     }
[10:27:02.928]                     invisible(pathname)
[10:27:02.928]                   }
[10:27:02.928]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:27:02.928]                     rootPath = tempdir()) 
[10:27:02.928]                   {
[10:27:02.928]                     obj <- list(time = Sys.time(), condition = cond)
[10:27:02.928]                     file <- tempfile(pattern = class(cond)[1], 
[10:27:02.928]                       tmpdir = path, fileext = ".rds")
[10:27:02.928]                     save_rds(obj, file)
[10:27:02.928]                   }
[10:27:02.928]                   saveImmediateCondition(cond, path = "/tmp/RtmpisxSDE/.future/immediateConditions")
[10:27:02.928]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:02.928]                   {
[10:27:02.928]                     inherits <- base::inherits
[10:27:02.928]                     invokeRestart <- base::invokeRestart
[10:27:02.928]                     is.null <- base::is.null
[10:27:02.928]                     muffled <- FALSE
[10:27:02.928]                     if (inherits(cond, "message")) {
[10:27:02.928]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:02.928]                       if (muffled) 
[10:27:02.928]                         invokeRestart("muffleMessage")
[10:27:02.928]                     }
[10:27:02.928]                     else if (inherits(cond, "warning")) {
[10:27:02.928]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:02.928]                       if (muffled) 
[10:27:02.928]                         invokeRestart("muffleWarning")
[10:27:02.928]                     }
[10:27:02.928]                     else if (inherits(cond, "condition")) {
[10:27:02.928]                       if (!is.null(pattern)) {
[10:27:02.928]                         computeRestarts <- base::computeRestarts
[10:27:02.928]                         grepl <- base::grepl
[10:27:02.928]                         restarts <- computeRestarts(cond)
[10:27:02.928]                         for (restart in restarts) {
[10:27:02.928]                           name <- restart$name
[10:27:02.928]                           if (is.null(name)) 
[10:27:02.928]                             next
[10:27:02.928]                           if (!grepl(pattern, name)) 
[10:27:02.928]                             next
[10:27:02.928]                           invokeRestart(restart)
[10:27:02.928]                           muffled <- TRUE
[10:27:02.928]                           break
[10:27:02.928]                         }
[10:27:02.928]                       }
[10:27:02.928]                     }
[10:27:02.928]                     invisible(muffled)
[10:27:02.928]                   }
[10:27:02.928]                   muffleCondition(cond)
[10:27:02.928]                 })
[10:27:02.928]             }))
[10:27:02.928]             future::FutureResult(value = ...future.value$value, 
[10:27:02.928]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:02.928]                   ...future.rng), globalenv = if (FALSE) 
[10:27:02.928]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:02.928]                     ...future.globalenv.names))
[10:27:02.928]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:02.928]         }, condition = base::local({
[10:27:02.928]             c <- base::c
[10:27:02.928]             inherits <- base::inherits
[10:27:02.928]             invokeRestart <- base::invokeRestart
[10:27:02.928]             length <- base::length
[10:27:02.928]             list <- base::list
[10:27:02.928]             seq.int <- base::seq.int
[10:27:02.928]             signalCondition <- base::signalCondition
[10:27:02.928]             sys.calls <- base::sys.calls
[10:27:02.928]             `[[` <- base::`[[`
[10:27:02.928]             `+` <- base::`+`
[10:27:02.928]             `<<-` <- base::`<<-`
[10:27:02.928]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:02.928]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:02.928]                   3L)]
[10:27:02.928]             }
[10:27:02.928]             function(cond) {
[10:27:02.928]                 is_error <- inherits(cond, "error")
[10:27:02.928]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:02.928]                   NULL)
[10:27:02.928]                 if (is_error) {
[10:27:02.928]                   sessionInformation <- function() {
[10:27:02.928]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:02.928]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:02.928]                       search = base::search(), system = base::Sys.info())
[10:27:02.928]                   }
[10:27:02.928]                   ...future.conditions[[length(...future.conditions) + 
[10:27:02.928]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:02.928]                     cond$call), session = sessionInformation(), 
[10:27:02.928]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:02.928]                   signalCondition(cond)
[10:27:02.928]                 }
[10:27:02.928]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:02.928]                 "immediateCondition"))) {
[10:27:02.928]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:02.928]                   ...future.conditions[[length(...future.conditions) + 
[10:27:02.928]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:02.928]                   if (TRUE && !signal) {
[10:27:02.928]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:02.928]                     {
[10:27:02.928]                       inherits <- base::inherits
[10:27:02.928]                       invokeRestart <- base::invokeRestart
[10:27:02.928]                       is.null <- base::is.null
[10:27:02.928]                       muffled <- FALSE
[10:27:02.928]                       if (inherits(cond, "message")) {
[10:27:02.928]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:02.928]                         if (muffled) 
[10:27:02.928]                           invokeRestart("muffleMessage")
[10:27:02.928]                       }
[10:27:02.928]                       else if (inherits(cond, "warning")) {
[10:27:02.928]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:02.928]                         if (muffled) 
[10:27:02.928]                           invokeRestart("muffleWarning")
[10:27:02.928]                       }
[10:27:02.928]                       else if (inherits(cond, "condition")) {
[10:27:02.928]                         if (!is.null(pattern)) {
[10:27:02.928]                           computeRestarts <- base::computeRestarts
[10:27:02.928]                           grepl <- base::grepl
[10:27:02.928]                           restarts <- computeRestarts(cond)
[10:27:02.928]                           for (restart in restarts) {
[10:27:02.928]                             name <- restart$name
[10:27:02.928]                             if (is.null(name)) 
[10:27:02.928]                               next
[10:27:02.928]                             if (!grepl(pattern, name)) 
[10:27:02.928]                               next
[10:27:02.928]                             invokeRestart(restart)
[10:27:02.928]                             muffled <- TRUE
[10:27:02.928]                             break
[10:27:02.928]                           }
[10:27:02.928]                         }
[10:27:02.928]                       }
[10:27:02.928]                       invisible(muffled)
[10:27:02.928]                     }
[10:27:02.928]                     muffleCondition(cond, pattern = "^muffle")
[10:27:02.928]                   }
[10:27:02.928]                 }
[10:27:02.928]                 else {
[10:27:02.928]                   if (TRUE) {
[10:27:02.928]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:02.928]                     {
[10:27:02.928]                       inherits <- base::inherits
[10:27:02.928]                       invokeRestart <- base::invokeRestart
[10:27:02.928]                       is.null <- base::is.null
[10:27:02.928]                       muffled <- FALSE
[10:27:02.928]                       if (inherits(cond, "message")) {
[10:27:02.928]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:02.928]                         if (muffled) 
[10:27:02.928]                           invokeRestart("muffleMessage")
[10:27:02.928]                       }
[10:27:02.928]                       else if (inherits(cond, "warning")) {
[10:27:02.928]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:02.928]                         if (muffled) 
[10:27:02.928]                           invokeRestart("muffleWarning")
[10:27:02.928]                       }
[10:27:02.928]                       else if (inherits(cond, "condition")) {
[10:27:02.928]                         if (!is.null(pattern)) {
[10:27:02.928]                           computeRestarts <- base::computeRestarts
[10:27:02.928]                           grepl <- base::grepl
[10:27:02.928]                           restarts <- computeRestarts(cond)
[10:27:02.928]                           for (restart in restarts) {
[10:27:02.928]                             name <- restart$name
[10:27:02.928]                             if (is.null(name)) 
[10:27:02.928]                               next
[10:27:02.928]                             if (!grepl(pattern, name)) 
[10:27:02.928]                               next
[10:27:02.928]                             invokeRestart(restart)
[10:27:02.928]                             muffled <- TRUE
[10:27:02.928]                             break
[10:27:02.928]                           }
[10:27:02.928]                         }
[10:27:02.928]                       }
[10:27:02.928]                       invisible(muffled)
[10:27:02.928]                     }
[10:27:02.928]                     muffleCondition(cond, pattern = "^muffle")
[10:27:02.928]                   }
[10:27:02.928]                 }
[10:27:02.928]             }
[10:27:02.928]         }))
[10:27:02.928]     }, error = function(ex) {
[10:27:02.928]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:02.928]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:02.928]                 ...future.rng), started = ...future.startTime, 
[10:27:02.928]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:02.928]             version = "1.8"), class = "FutureResult")
[10:27:02.928]     }, finally = {
[10:27:02.928]         if (!identical(...future.workdir, getwd())) 
[10:27:02.928]             setwd(...future.workdir)
[10:27:02.928]         {
[10:27:02.928]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:02.928]                 ...future.oldOptions$nwarnings <- NULL
[10:27:02.928]             }
[10:27:02.928]             base::options(...future.oldOptions)
[10:27:02.928]             if (.Platform$OS.type == "windows") {
[10:27:02.928]                 old_names <- names(...future.oldEnvVars)
[10:27:02.928]                 envs <- base::Sys.getenv()
[10:27:02.928]                 names <- names(envs)
[10:27:02.928]                 common <- intersect(names, old_names)
[10:27:02.928]                 added <- setdiff(names, old_names)
[10:27:02.928]                 removed <- setdiff(old_names, names)
[10:27:02.928]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:02.928]                   envs[common]]
[10:27:02.928]                 NAMES <- toupper(changed)
[10:27:02.928]                 args <- list()
[10:27:02.928]                 for (kk in seq_along(NAMES)) {
[10:27:02.928]                   name <- changed[[kk]]
[10:27:02.928]                   NAME <- NAMES[[kk]]
[10:27:02.928]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:02.928]                     next
[10:27:02.928]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:02.928]                 }
[10:27:02.928]                 NAMES <- toupper(added)
[10:27:02.928]                 for (kk in seq_along(NAMES)) {
[10:27:02.928]                   name <- added[[kk]]
[10:27:02.928]                   NAME <- NAMES[[kk]]
[10:27:02.928]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:02.928]                     next
[10:27:02.928]                   args[[name]] <- ""
[10:27:02.928]                 }
[10:27:02.928]                 NAMES <- toupper(removed)
[10:27:02.928]                 for (kk in seq_along(NAMES)) {
[10:27:02.928]                   name <- removed[[kk]]
[10:27:02.928]                   NAME <- NAMES[[kk]]
[10:27:02.928]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:02.928]                     next
[10:27:02.928]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:02.928]                 }
[10:27:02.928]                 if (length(args) > 0) 
[10:27:02.928]                   base::do.call(base::Sys.setenv, args = args)
[10:27:02.928]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:02.928]             }
[10:27:02.928]             else {
[10:27:02.928]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:02.928]             }
[10:27:02.928]             {
[10:27:02.928]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:02.928]                   0L) {
[10:27:02.928]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:02.928]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:02.928]                   base::options(opts)
[10:27:02.928]                 }
[10:27:02.928]                 {
[10:27:02.928]                   {
[10:27:02.928]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:02.928]                     NULL
[10:27:02.928]                   }
[10:27:02.928]                   options(future.plan = NULL)
[10:27:02.928]                   if (is.na(NA_character_)) 
[10:27:02.928]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:02.928]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:02.928]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:27:02.928]                     envir = parent.frame()) 
[10:27:02.928]                   {
[10:27:02.928]                     default_workers <- missing(workers)
[10:27:02.928]                     if (is.function(workers)) 
[10:27:02.928]                       workers <- workers()
[10:27:02.928]                     workers <- structure(as.integer(workers), 
[10:27:02.928]                       class = class(workers))
[10:27:02.928]                     stop_if_not(is.finite(workers), workers >= 
[10:27:02.928]                       1L)
[10:27:02.928]                     if ((workers == 1L && !inherits(workers, 
[10:27:02.928]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:27:02.928]                       if (default_workers) 
[10:27:02.928]                         supportsMulticore(warn = TRUE)
[10:27:02.928]                       return(sequential(..., envir = envir))
[10:27:02.928]                     }
[10:27:02.928]                     oopts <- options(mc.cores = workers)
[10:27:02.928]                     on.exit(options(oopts))
[10:27:02.928]                     future <- MulticoreFuture(..., workers = workers, 
[10:27:02.928]                       envir = envir)
[10:27:02.928]                     if (!future$lazy) 
[10:27:02.928]                       future <- run(future)
[10:27:02.928]                     invisible(future)
[10:27:02.928]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:02.928]                 }
[10:27:02.928]             }
[10:27:02.928]         }
[10:27:02.928]     })
[10:27:02.928]     if (TRUE) {
[10:27:02.928]         base::sink(type = "output", split = FALSE)
[10:27:02.928]         if (TRUE) {
[10:27:02.928]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:02.928]         }
[10:27:02.928]         else {
[10:27:02.928]             ...future.result["stdout"] <- base::list(NULL)
[10:27:02.928]         }
[10:27:02.928]         base::close(...future.stdout)
[10:27:02.928]         ...future.stdout <- NULL
[10:27:02.928]     }
[10:27:02.928]     ...future.result$conditions <- ...future.conditions
[10:27:02.928]     ...future.result$finished <- base::Sys.time()
[10:27:02.928]     ...future.result
[10:27:02.928] }
[10:27:02.932] requestCore(): workers = 2
[10:27:02.932] Poll #1 (0): usedCores() = 2, workers = 2
[10:27:02.943] result() for MulticoreFuture ...
[10:27:02.944] result() for MulticoreFuture ...
[10:27:02.944] result() for MulticoreFuture ... done
[10:27:02.944] result() for MulticoreFuture ... done
[10:27:02.944] result() for MulticoreFuture ...
[10:27:02.944] result() for MulticoreFuture ... done
[10:27:02.947] MulticoreFuture started
[10:27:02.948] - Launch lazy future ... done
[10:27:02.948] run() for ‘MulticoreFuture’ ... done
[10:27:02.949] getGlobalsAndPackages() ...
[10:27:02.949] Searching for globals...
[10:27:02.949] plan(): Setting new future strategy stack:
[10:27:02.950] List of future strategies:
[10:27:02.950] 1. sequential:
[10:27:02.950]    - args: function (..., envir = parent.frame())
[10:27:02.950]    - tweaked: FALSE
[10:27:02.950]    - call: NULL
[10:27:02.950] 
[10:27:02.951] Searching for globals ... DONE
[10:27:02.951] plan(): nbrOfWorkers() = 1
[10:27:02.951] - globals: [0] <none>
[10:27:02.951] getGlobalsAndPackages() ... DONE
[10:27:02.952] run() for ‘Future’ ...
[10:27:02.952] - state: ‘created’
[10:27:02.953] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:27:02.954] plan(): Setting new future strategy stack:
[10:27:02.954] List of future strategies:
[10:27:02.954] 1. multicore:
[10:27:02.954]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:27:02.954]    - tweaked: FALSE
[10:27:02.954]    - call: plan(strategy)
[10:27:02.960] plan(): nbrOfWorkers() = 2
[10:27:02.960] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:02.960] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:27:02.960]   - Field: ‘label’
[10:27:02.961]   - Field: ‘local’
[10:27:02.961]   - Field: ‘owner’
[10:27:02.961]   - Field: ‘envir’
[10:27:02.961]   - Field: ‘workers’
[10:27:02.961]   - Field: ‘packages’
[10:27:02.962]   - Field: ‘gc’
[10:27:02.962]   - Field: ‘job’
[10:27:02.962]   - Field: ‘conditions’
[10:27:02.962]   - Field: ‘expr’
[10:27:02.962]   - Field: ‘uuid’
[10:27:02.962]   - Field: ‘seed’
[10:27:02.962]   - Field: ‘version’
[10:27:02.963]   - Field: ‘result’
[10:27:02.963]   - Field: ‘asynchronous’
[10:27:02.963]   - Field: ‘calls’
[10:27:02.963]   - Field: ‘globals’
[10:27:02.963]   - Field: ‘stdout’
[10:27:02.963]   - Field: ‘earlySignal’
[10:27:02.963]   - Field: ‘lazy’
[10:27:02.964]   - Field: ‘state’
[10:27:02.964] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:27:02.964] - Launch lazy future ...
[10:27:02.964] Packages needed by the future expression (n = 0): <none>
[10:27:02.965] Packages needed by future strategies (n = 0): <none>
[10:27:02.965] {
[10:27:02.965]     {
[10:27:02.965]         {
[10:27:02.965]             ...future.startTime <- base::Sys.time()
[10:27:02.965]             {
[10:27:02.965]                 {
[10:27:02.965]                   {
[10:27:02.965]                     {
[10:27:02.965]                       base::local({
[10:27:02.965]                         has_future <- base::requireNamespace("future", 
[10:27:02.965]                           quietly = TRUE)
[10:27:02.965]                         if (has_future) {
[10:27:02.965]                           ns <- base::getNamespace("future")
[10:27:02.965]                           version <- ns[[".package"]][["version"]]
[10:27:02.965]                           if (is.null(version)) 
[10:27:02.965]                             version <- utils::packageVersion("future")
[10:27:02.965]                         }
[10:27:02.965]                         else {
[10:27:02.965]                           version <- NULL
[10:27:02.965]                         }
[10:27:02.965]                         if (!has_future || version < "1.8.0") {
[10:27:02.965]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:02.965]                             "", base::R.version$version.string), 
[10:27:02.965]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:02.965]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:02.965]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:02.965]                               "release", "version")], collapse = " "), 
[10:27:02.965]                             hostname = base::Sys.info()[["nodename"]])
[10:27:02.965]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:02.965]                             info)
[10:27:02.965]                           info <- base::paste(info, collapse = "; ")
[10:27:02.965]                           if (!has_future) {
[10:27:02.965]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:02.965]                               info)
[10:27:02.965]                           }
[10:27:02.965]                           else {
[10:27:02.965]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:02.965]                               info, version)
[10:27:02.965]                           }
[10:27:02.965]                           base::stop(msg)
[10:27:02.965]                         }
[10:27:02.965]                       })
[10:27:02.965]                     }
[10:27:02.965]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:02.965]                     base::options(mc.cores = 1L)
[10:27:02.965]                   }
[10:27:02.965]                   options(future.plan = NULL)
[10:27:02.965]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:02.965]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:02.965]                 }
[10:27:02.965]                 ...future.workdir <- getwd()
[10:27:02.965]             }
[10:27:02.965]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:02.965]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:02.965]         }
[10:27:02.965]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:02.965]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:02.965]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:02.965]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:02.965]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:02.965]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:02.965]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:02.965]             base::names(...future.oldOptions))
[10:27:02.965]     }
[10:27:02.965]     if (FALSE) {
[10:27:02.965]     }
[10:27:02.965]     else {
[10:27:02.965]         if (TRUE) {
[10:27:02.965]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:02.965]                 open = "w")
[10:27:02.965]         }
[10:27:02.965]         else {
[10:27:02.965]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:02.965]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:02.965]         }
[10:27:02.965]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:02.965]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:02.965]             base::sink(type = "output", split = FALSE)
[10:27:02.965]             base::close(...future.stdout)
[10:27:02.965]         }, add = TRUE)
[10:27:02.965]     }
[10:27:02.965]     ...future.frame <- base::sys.nframe()
[10:27:02.965]     ...future.conditions <- base::list()
[10:27:02.965]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:02.965]     if (FALSE) {
[10:27:02.965]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:02.965]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:02.965]     }
[10:27:02.965]     ...future.result <- base::tryCatch({
[10:27:02.965]         base::withCallingHandlers({
[10:27:02.965]             ...future.value <- base::withVisible(base::local({
[10:27:02.965]                 withCallingHandlers({
[10:27:02.965]                   2
[10:27:02.965]                 }, immediateCondition = function(cond) {
[10:27:02.965]                   save_rds <- function (object, pathname, ...) 
[10:27:02.965]                   {
[10:27:02.965]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:27:02.965]                     if (file_test("-f", pathname_tmp)) {
[10:27:02.965]                       fi_tmp <- file.info(pathname_tmp)
[10:27:02.965]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:27:02.965]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:02.965]                         fi_tmp[["mtime"]])
[10:27:02.965]                     }
[10:27:02.965]                     tryCatch({
[10:27:02.965]                       saveRDS(object, file = pathname_tmp, ...)
[10:27:02.965]                     }, error = function(ex) {
[10:27:02.965]                       msg <- conditionMessage(ex)
[10:27:02.965]                       fi_tmp <- file.info(pathname_tmp)
[10:27:02.965]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:27:02.965]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:02.965]                         fi_tmp[["mtime"]], msg)
[10:27:02.965]                       ex$message <- msg
[10:27:02.965]                       stop(ex)
[10:27:02.965]                     })
[10:27:02.965]                     stopifnot(file_test("-f", pathname_tmp))
[10:27:02.965]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:27:02.965]                     if (!res || file_test("-f", pathname_tmp)) {
[10:27:02.965]                       fi_tmp <- file.info(pathname_tmp)
[10:27:02.965]                       fi <- file.info(pathname)
[10:27:02.965]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:27:02.965]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:02.965]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:27:02.965]                         fi[["size"]], fi[["mtime"]])
[10:27:02.965]                       stop(msg)
[10:27:02.965]                     }
[10:27:02.965]                     invisible(pathname)
[10:27:02.965]                   }
[10:27:02.965]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:27:02.965]                     rootPath = tempdir()) 
[10:27:02.965]                   {
[10:27:02.965]                     obj <- list(time = Sys.time(), condition = cond)
[10:27:02.965]                     file <- tempfile(pattern = class(cond)[1], 
[10:27:02.965]                       tmpdir = path, fileext = ".rds")
[10:27:02.965]                     save_rds(obj, file)
[10:27:02.965]                   }
[10:27:02.965]                   saveImmediateCondition(cond, path = "/tmp/RtmpisxSDE/.future/immediateConditions")
[10:27:02.965]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:02.965]                   {
[10:27:02.965]                     inherits <- base::inherits
[10:27:02.965]                     invokeRestart <- base::invokeRestart
[10:27:02.965]                     is.null <- base::is.null
[10:27:02.965]                     muffled <- FALSE
[10:27:02.965]                     if (inherits(cond, "message")) {
[10:27:02.965]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:02.965]                       if (muffled) 
[10:27:02.965]                         invokeRestart("muffleMessage")
[10:27:02.965]                     }
[10:27:02.965]                     else if (inherits(cond, "warning")) {
[10:27:02.965]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:02.965]                       if (muffled) 
[10:27:02.965]                         invokeRestart("muffleWarning")
[10:27:02.965]                     }
[10:27:02.965]                     else if (inherits(cond, "condition")) {
[10:27:02.965]                       if (!is.null(pattern)) {
[10:27:02.965]                         computeRestarts <- base::computeRestarts
[10:27:02.965]                         grepl <- base::grepl
[10:27:02.965]                         restarts <- computeRestarts(cond)
[10:27:02.965]                         for (restart in restarts) {
[10:27:02.965]                           name <- restart$name
[10:27:02.965]                           if (is.null(name)) 
[10:27:02.965]                             next
[10:27:02.965]                           if (!grepl(pattern, name)) 
[10:27:02.965]                             next
[10:27:02.965]                           invokeRestart(restart)
[10:27:02.965]                           muffled <- TRUE
[10:27:02.965]                           break
[10:27:02.965]                         }
[10:27:02.965]                       }
[10:27:02.965]                     }
[10:27:02.965]                     invisible(muffled)
[10:27:02.965]                   }
[10:27:02.965]                   muffleCondition(cond)
[10:27:02.965]                 })
[10:27:02.965]             }))
[10:27:02.965]             future::FutureResult(value = ...future.value$value, 
[10:27:02.965]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:02.965]                   ...future.rng), globalenv = if (FALSE) 
[10:27:02.965]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:02.965]                     ...future.globalenv.names))
[10:27:02.965]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:02.965]         }, condition = base::local({
[10:27:02.965]             c <- base::c
[10:27:02.965]             inherits <- base::inherits
[10:27:02.965]             invokeRestart <- base::invokeRestart
[10:27:02.965]             length <- base::length
[10:27:02.965]             list <- base::list
[10:27:02.965]             seq.int <- base::seq.int
[10:27:02.965]             signalCondition <- base::signalCondition
[10:27:02.965]             sys.calls <- base::sys.calls
[10:27:02.965]             `[[` <- base::`[[`
[10:27:02.965]             `+` <- base::`+`
[10:27:02.965]             `<<-` <- base::`<<-`
[10:27:02.965]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:02.965]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:02.965]                   3L)]
[10:27:02.965]             }
[10:27:02.965]             function(cond) {
[10:27:02.965]                 is_error <- inherits(cond, "error")
[10:27:02.965]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:02.965]                   NULL)
[10:27:02.965]                 if (is_error) {
[10:27:02.965]                   sessionInformation <- function() {
[10:27:02.965]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:02.965]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:02.965]                       search = base::search(), system = base::Sys.info())
[10:27:02.965]                   }
[10:27:02.965]                   ...future.conditions[[length(...future.conditions) + 
[10:27:02.965]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:02.965]                     cond$call), session = sessionInformation(), 
[10:27:02.965]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:02.965]                   signalCondition(cond)
[10:27:02.965]                 }
[10:27:02.965]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:02.965]                 "immediateCondition"))) {
[10:27:02.965]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:02.965]                   ...future.conditions[[length(...future.conditions) + 
[10:27:02.965]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:02.965]                   if (TRUE && !signal) {
[10:27:02.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:02.965]                     {
[10:27:02.965]                       inherits <- base::inherits
[10:27:02.965]                       invokeRestart <- base::invokeRestart
[10:27:02.965]                       is.null <- base::is.null
[10:27:02.965]                       muffled <- FALSE
[10:27:02.965]                       if (inherits(cond, "message")) {
[10:27:02.965]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:02.965]                         if (muffled) 
[10:27:02.965]                           invokeRestart("muffleMessage")
[10:27:02.965]                       }
[10:27:02.965]                       else if (inherits(cond, "warning")) {
[10:27:02.965]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:02.965]                         if (muffled) 
[10:27:02.965]                           invokeRestart("muffleWarning")
[10:27:02.965]                       }
[10:27:02.965]                       else if (inherits(cond, "condition")) {
[10:27:02.965]                         if (!is.null(pattern)) {
[10:27:02.965]                           computeRestarts <- base::computeRestarts
[10:27:02.965]                           grepl <- base::grepl
[10:27:02.965]                           restarts <- computeRestarts(cond)
[10:27:02.965]                           for (restart in restarts) {
[10:27:02.965]                             name <- restart$name
[10:27:02.965]                             if (is.null(name)) 
[10:27:02.965]                               next
[10:27:02.965]                             if (!grepl(pattern, name)) 
[10:27:02.965]                               next
[10:27:02.965]                             invokeRestart(restart)
[10:27:02.965]                             muffled <- TRUE
[10:27:02.965]                             break
[10:27:02.965]                           }
[10:27:02.965]                         }
[10:27:02.965]                       }
[10:27:02.965]                       invisible(muffled)
[10:27:02.965]                     }
[10:27:02.965]                     muffleCondition(cond, pattern = "^muffle")
[10:27:02.965]                   }
[10:27:02.965]                 }
[10:27:02.965]                 else {
[10:27:02.965]                   if (TRUE) {
[10:27:02.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:02.965]                     {
[10:27:02.965]                       inherits <- base::inherits
[10:27:02.965]                       invokeRestart <- base::invokeRestart
[10:27:02.965]                       is.null <- base::is.null
[10:27:02.965]                       muffled <- FALSE
[10:27:02.965]                       if (inherits(cond, "message")) {
[10:27:02.965]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:02.965]                         if (muffled) 
[10:27:02.965]                           invokeRestart("muffleMessage")
[10:27:02.965]                       }
[10:27:02.965]                       else if (inherits(cond, "warning")) {
[10:27:02.965]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:02.965]                         if (muffled) 
[10:27:02.965]                           invokeRestart("muffleWarning")
[10:27:02.965]                       }
[10:27:02.965]                       else if (inherits(cond, "condition")) {
[10:27:02.965]                         if (!is.null(pattern)) {
[10:27:02.965]                           computeRestarts <- base::computeRestarts
[10:27:02.965]                           grepl <- base::grepl
[10:27:02.965]                           restarts <- computeRestarts(cond)
[10:27:02.965]                           for (restart in restarts) {
[10:27:02.965]                             name <- restart$name
[10:27:02.965]                             if (is.null(name)) 
[10:27:02.965]                               next
[10:27:02.965]                             if (!grepl(pattern, name)) 
[10:27:02.965]                               next
[10:27:02.965]                             invokeRestart(restart)
[10:27:02.965]                             muffled <- TRUE
[10:27:02.965]                             break
[10:27:02.965]                           }
[10:27:02.965]                         }
[10:27:02.965]                       }
[10:27:02.965]                       invisible(muffled)
[10:27:02.965]                     }
[10:27:02.965]                     muffleCondition(cond, pattern = "^muffle")
[10:27:02.965]                   }
[10:27:02.965]                 }
[10:27:02.965]             }
[10:27:02.965]         }))
[10:27:02.965]     }, error = function(ex) {
[10:27:02.965]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:02.965]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:02.965]                 ...future.rng), started = ...future.startTime, 
[10:27:02.965]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:02.965]             version = "1.8"), class = "FutureResult")
[10:27:02.965]     }, finally = {
[10:27:02.965]         if (!identical(...future.workdir, getwd())) 
[10:27:02.965]             setwd(...future.workdir)
[10:27:02.965]         {
[10:27:02.965]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:02.965]                 ...future.oldOptions$nwarnings <- NULL
[10:27:02.965]             }
[10:27:02.965]             base::options(...future.oldOptions)
[10:27:02.965]             if (.Platform$OS.type == "windows") {
[10:27:02.965]                 old_names <- names(...future.oldEnvVars)
[10:27:02.965]                 envs <- base::Sys.getenv()
[10:27:02.965]                 names <- names(envs)
[10:27:02.965]                 common <- intersect(names, old_names)
[10:27:02.965]                 added <- setdiff(names, old_names)
[10:27:02.965]                 removed <- setdiff(old_names, names)
[10:27:02.965]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:02.965]                   envs[common]]
[10:27:02.965]                 NAMES <- toupper(changed)
[10:27:02.965]                 args <- list()
[10:27:02.965]                 for (kk in seq_along(NAMES)) {
[10:27:02.965]                   name <- changed[[kk]]
[10:27:02.965]                   NAME <- NAMES[[kk]]
[10:27:02.965]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:02.965]                     next
[10:27:02.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:02.965]                 }
[10:27:02.965]                 NAMES <- toupper(added)
[10:27:02.965]                 for (kk in seq_along(NAMES)) {
[10:27:02.965]                   name <- added[[kk]]
[10:27:02.965]                   NAME <- NAMES[[kk]]
[10:27:02.965]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:02.965]                     next
[10:27:02.965]                   args[[name]] <- ""
[10:27:02.965]                 }
[10:27:02.965]                 NAMES <- toupper(removed)
[10:27:02.965]                 for (kk in seq_along(NAMES)) {
[10:27:02.965]                   name <- removed[[kk]]
[10:27:02.965]                   NAME <- NAMES[[kk]]
[10:27:02.965]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:02.965]                     next
[10:27:02.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:02.965]                 }
[10:27:02.965]                 if (length(args) > 0) 
[10:27:02.965]                   base::do.call(base::Sys.setenv, args = args)
[10:27:02.965]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:02.965]             }
[10:27:02.965]             else {
[10:27:02.965]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:02.965]             }
[10:27:02.965]             {
[10:27:02.965]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:02.965]                   0L) {
[10:27:02.965]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:02.965]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:02.965]                   base::options(opts)
[10:27:02.965]                 }
[10:27:02.965]                 {
[10:27:02.965]                   {
[10:27:02.965]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:02.965]                     NULL
[10:27:02.965]                   }
[10:27:02.965]                   options(future.plan = NULL)
[10:27:02.965]                   if (is.na(NA_character_)) 
[10:27:02.965]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:02.965]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:02.965]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:27:02.965]                     envir = parent.frame()) 
[10:27:02.965]                   {
[10:27:02.965]                     default_workers <- missing(workers)
[10:27:02.965]                     if (is.function(workers)) 
[10:27:02.965]                       workers <- workers()
[10:27:02.965]                     workers <- structure(as.integer(workers), 
[10:27:02.965]                       class = class(workers))
[10:27:02.965]                     stop_if_not(is.finite(workers), workers >= 
[10:27:02.965]                       1L)
[10:27:02.965]                     if ((workers == 1L && !inherits(workers, 
[10:27:02.965]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:27:02.965]                       if (default_workers) 
[10:27:02.965]                         supportsMulticore(warn = TRUE)
[10:27:02.965]                       return(sequential(..., envir = envir))
[10:27:02.965]                     }
[10:27:02.965]                     oopts <- options(mc.cores = workers)
[10:27:02.965]                     on.exit(options(oopts))
[10:27:02.965]                     future <- MulticoreFuture(..., workers = workers, 
[10:27:02.965]                       envir = envir)
[10:27:02.965]                     if (!future$lazy) 
[10:27:02.965]                       future <- run(future)
[10:27:02.965]                     invisible(future)
[10:27:02.965]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:02.965]                 }
[10:27:02.965]             }
[10:27:02.965]         }
[10:27:02.965]     })
[10:27:02.965]     if (TRUE) {
[10:27:02.965]         base::sink(type = "output", split = FALSE)
[10:27:02.965]         if (TRUE) {
[10:27:02.965]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:02.965]         }
[10:27:02.965]         else {
[10:27:02.965]             ...future.result["stdout"] <- base::list(NULL)
[10:27:02.965]         }
[10:27:02.965]         base::close(...future.stdout)
[10:27:02.965]         ...future.stdout <- NULL
[10:27:02.965]     }
[10:27:02.965]     ...future.result$conditions <- ...future.conditions
[10:27:02.965]     ...future.result$finished <- base::Sys.time()
[10:27:02.965]     ...future.result
[10:27:02.965] }
[10:27:02.969] requestCore(): workers = 2
[10:27:02.970] Poll #1 (0): usedCores() = 2, workers = 2
[10:27:02.981] result() for MulticoreFuture ...
[10:27:02.982] result() for MulticoreFuture ...
[10:27:02.982] result() for MulticoreFuture ... done
[10:27:02.982] result() for MulticoreFuture ... done
[10:27:02.983] result() for MulticoreFuture ...
[10:27:02.983] result() for MulticoreFuture ... done
[10:27:02.986] MulticoreFuture started
[10:27:02.986] - Launch lazy future ... done
[10:27:02.987] run() for ‘MulticoreFuture’ ... done
[10:27:02.987] plan(): Setting new future strategy stack:
[10:27:02.987] List of future strategies:
[10:27:02.987] 1. sequential:
[10:27:02.987]    - args: function (..., envir = parent.frame())
[10:27:02.987]    - tweaked: FALSE
[10:27:02.987]    - call: NULL
[10:27:02.988] resolve() on environment ...
[10:27:02.988]  recursive: 0
[10:27:02.988] plan(): nbrOfWorkers() = 1
[10:27:02.989]  elements: [3] ‘a’, ‘b’, ‘c’
[10:27:02.990] Future #1
[10:27:02.990]  length: 2 (resolved future 1)
[10:27:02.991] plan(): Setting new future strategy stack:
[10:27:02.991] List of future strategies:
[10:27:02.991] 1. multicore:
[10:27:02.991]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:27:02.991]    - tweaked: FALSE
[10:27:02.991]    - call: plan(strategy)
[10:27:03.001]  length: 1 (resolved future 3)
[10:27:03.005] plan(): nbrOfWorkers() = 2
[10:27:03.012] Future #2
[10:27:03.012]  length: 0 (resolved future 2)
[10:27:03.012] resolve() on environment ... DONE
[10:27:03.023] getGlobalsAndPackages() ...
[10:27:03.023] Searching for globals...
[10:27:03.026] - globals found: [1] ‘{’
[10:27:03.026] Searching for globals ... DONE
[10:27:03.026] Resolving globals: FALSE
[10:27:03.027] 
[10:27:03.027] 
[10:27:03.027] getGlobalsAndPackages() ... DONE
[10:27:03.028] run() for ‘Future’ ...
[10:27:03.028] - state: ‘created’
[10:27:03.028] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:27:03.038] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:03.038] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:27:03.039]   - Field: ‘label’
[10:27:03.039]   - Field: ‘local’
[10:27:03.039]   - Field: ‘owner’
[10:27:03.039]   - Field: ‘envir’
[10:27:03.040]   - Field: ‘workers’
[10:27:03.040]   - Field: ‘packages’
[10:27:03.040]   - Field: ‘gc’
[10:27:03.040]   - Field: ‘job’
[10:27:03.040]   - Field: ‘conditions’
[10:27:03.041]   - Field: ‘expr’
[10:27:03.041]   - Field: ‘uuid’
[10:27:03.041]   - Field: ‘seed’
[10:27:03.041]   - Field: ‘version’
[10:27:03.041]   - Field: ‘result’
[10:27:03.041]   - Field: ‘asynchronous’
[10:27:03.041]   - Field: ‘calls’
[10:27:03.042]   - Field: ‘globals’
[10:27:03.042]   - Field: ‘stdout’
[10:27:03.042]   - Field: ‘earlySignal’
[10:27:03.042]   - Field: ‘lazy’
[10:27:03.042]   - Field: ‘state’
[10:27:03.042] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:27:03.042] - Launch lazy future ...
[10:27:03.043] Packages needed by the future expression (n = 0): <none>
[10:27:03.043] Packages needed by future strategies (n = 0): <none>
[10:27:03.044] {
[10:27:03.044]     {
[10:27:03.044]         {
[10:27:03.044]             ...future.startTime <- base::Sys.time()
[10:27:03.044]             {
[10:27:03.044]                 {
[10:27:03.044]                   {
[10:27:03.044]                     {
[10:27:03.044]                       base::local({
[10:27:03.044]                         has_future <- base::requireNamespace("future", 
[10:27:03.044]                           quietly = TRUE)
[10:27:03.044]                         if (has_future) {
[10:27:03.044]                           ns <- base::getNamespace("future")
[10:27:03.044]                           version <- ns[[".package"]][["version"]]
[10:27:03.044]                           if (is.null(version)) 
[10:27:03.044]                             version <- utils::packageVersion("future")
[10:27:03.044]                         }
[10:27:03.044]                         else {
[10:27:03.044]                           version <- NULL
[10:27:03.044]                         }
[10:27:03.044]                         if (!has_future || version < "1.8.0") {
[10:27:03.044]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:03.044]                             "", base::R.version$version.string), 
[10:27:03.044]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:03.044]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:03.044]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:03.044]                               "release", "version")], collapse = " "), 
[10:27:03.044]                             hostname = base::Sys.info()[["nodename"]])
[10:27:03.044]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:03.044]                             info)
[10:27:03.044]                           info <- base::paste(info, collapse = "; ")
[10:27:03.044]                           if (!has_future) {
[10:27:03.044]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:03.044]                               info)
[10:27:03.044]                           }
[10:27:03.044]                           else {
[10:27:03.044]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:03.044]                               info, version)
[10:27:03.044]                           }
[10:27:03.044]                           base::stop(msg)
[10:27:03.044]                         }
[10:27:03.044]                       })
[10:27:03.044]                     }
[10:27:03.044]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:03.044]                     base::options(mc.cores = 1L)
[10:27:03.044]                   }
[10:27:03.044]                   options(future.plan = NULL)
[10:27:03.044]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:03.044]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:03.044]                 }
[10:27:03.044]                 ...future.workdir <- getwd()
[10:27:03.044]             }
[10:27:03.044]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:03.044]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:03.044]         }
[10:27:03.044]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:03.044]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:03.044]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:03.044]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:03.044]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:03.044]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:03.044]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:03.044]             base::names(...future.oldOptions))
[10:27:03.044]     }
[10:27:03.044]     if (FALSE) {
[10:27:03.044]     }
[10:27:03.044]     else {
[10:27:03.044]         if (TRUE) {
[10:27:03.044]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:03.044]                 open = "w")
[10:27:03.044]         }
[10:27:03.044]         else {
[10:27:03.044]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:03.044]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:03.044]         }
[10:27:03.044]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:03.044]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:03.044]             base::sink(type = "output", split = FALSE)
[10:27:03.044]             base::close(...future.stdout)
[10:27:03.044]         }, add = TRUE)
[10:27:03.044]     }
[10:27:03.044]     ...future.frame <- base::sys.nframe()
[10:27:03.044]     ...future.conditions <- base::list()
[10:27:03.044]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:03.044]     if (FALSE) {
[10:27:03.044]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:03.044]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:03.044]     }
[10:27:03.044]     ...future.result <- base::tryCatch({
[10:27:03.044]         base::withCallingHandlers({
[10:27:03.044]             ...future.value <- base::withVisible(base::local({
[10:27:03.044]                 withCallingHandlers({
[10:27:03.044]                   {
[10:27:03.044]                     1
[10:27:03.044]                   }
[10:27:03.044]                 }, immediateCondition = function(cond) {
[10:27:03.044]                   save_rds <- function (object, pathname, ...) 
[10:27:03.044]                   {
[10:27:03.044]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:27:03.044]                     if (file_test("-f", pathname_tmp)) {
[10:27:03.044]                       fi_tmp <- file.info(pathname_tmp)
[10:27:03.044]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:27:03.044]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:03.044]                         fi_tmp[["mtime"]])
[10:27:03.044]                     }
[10:27:03.044]                     tryCatch({
[10:27:03.044]                       saveRDS(object, file = pathname_tmp, ...)
[10:27:03.044]                     }, error = function(ex) {
[10:27:03.044]                       msg <- conditionMessage(ex)
[10:27:03.044]                       fi_tmp <- file.info(pathname_tmp)
[10:27:03.044]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:27:03.044]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:03.044]                         fi_tmp[["mtime"]], msg)
[10:27:03.044]                       ex$message <- msg
[10:27:03.044]                       stop(ex)
[10:27:03.044]                     })
[10:27:03.044]                     stopifnot(file_test("-f", pathname_tmp))
[10:27:03.044]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:27:03.044]                     if (!res || file_test("-f", pathname_tmp)) {
[10:27:03.044]                       fi_tmp <- file.info(pathname_tmp)
[10:27:03.044]                       fi <- file.info(pathname)
[10:27:03.044]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:27:03.044]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:03.044]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:27:03.044]                         fi[["size"]], fi[["mtime"]])
[10:27:03.044]                       stop(msg)
[10:27:03.044]                     }
[10:27:03.044]                     invisible(pathname)
[10:27:03.044]                   }
[10:27:03.044]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:27:03.044]                     rootPath = tempdir()) 
[10:27:03.044]                   {
[10:27:03.044]                     obj <- list(time = Sys.time(), condition = cond)
[10:27:03.044]                     file <- tempfile(pattern = class(cond)[1], 
[10:27:03.044]                       tmpdir = path, fileext = ".rds")
[10:27:03.044]                     save_rds(obj, file)
[10:27:03.044]                   }
[10:27:03.044]                   saveImmediateCondition(cond, path = "/tmp/RtmpisxSDE/.future/immediateConditions")
[10:27:03.044]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:03.044]                   {
[10:27:03.044]                     inherits <- base::inherits
[10:27:03.044]                     invokeRestart <- base::invokeRestart
[10:27:03.044]                     is.null <- base::is.null
[10:27:03.044]                     muffled <- FALSE
[10:27:03.044]                     if (inherits(cond, "message")) {
[10:27:03.044]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:03.044]                       if (muffled) 
[10:27:03.044]                         invokeRestart("muffleMessage")
[10:27:03.044]                     }
[10:27:03.044]                     else if (inherits(cond, "warning")) {
[10:27:03.044]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:03.044]                       if (muffled) 
[10:27:03.044]                         invokeRestart("muffleWarning")
[10:27:03.044]                     }
[10:27:03.044]                     else if (inherits(cond, "condition")) {
[10:27:03.044]                       if (!is.null(pattern)) {
[10:27:03.044]                         computeRestarts <- base::computeRestarts
[10:27:03.044]                         grepl <- base::grepl
[10:27:03.044]                         restarts <- computeRestarts(cond)
[10:27:03.044]                         for (restart in restarts) {
[10:27:03.044]                           name <- restart$name
[10:27:03.044]                           if (is.null(name)) 
[10:27:03.044]                             next
[10:27:03.044]                           if (!grepl(pattern, name)) 
[10:27:03.044]                             next
[10:27:03.044]                           invokeRestart(restart)
[10:27:03.044]                           muffled <- TRUE
[10:27:03.044]                           break
[10:27:03.044]                         }
[10:27:03.044]                       }
[10:27:03.044]                     }
[10:27:03.044]                     invisible(muffled)
[10:27:03.044]                   }
[10:27:03.044]                   muffleCondition(cond)
[10:27:03.044]                 })
[10:27:03.044]             }))
[10:27:03.044]             future::FutureResult(value = ...future.value$value, 
[10:27:03.044]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:03.044]                   ...future.rng), globalenv = if (FALSE) 
[10:27:03.044]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:03.044]                     ...future.globalenv.names))
[10:27:03.044]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:03.044]         }, condition = base::local({
[10:27:03.044]             c <- base::c
[10:27:03.044]             inherits <- base::inherits
[10:27:03.044]             invokeRestart <- base::invokeRestart
[10:27:03.044]             length <- base::length
[10:27:03.044]             list <- base::list
[10:27:03.044]             seq.int <- base::seq.int
[10:27:03.044]             signalCondition <- base::signalCondition
[10:27:03.044]             sys.calls <- base::sys.calls
[10:27:03.044]             `[[` <- base::`[[`
[10:27:03.044]             `+` <- base::`+`
[10:27:03.044]             `<<-` <- base::`<<-`
[10:27:03.044]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:03.044]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:03.044]                   3L)]
[10:27:03.044]             }
[10:27:03.044]             function(cond) {
[10:27:03.044]                 is_error <- inherits(cond, "error")
[10:27:03.044]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:03.044]                   NULL)
[10:27:03.044]                 if (is_error) {
[10:27:03.044]                   sessionInformation <- function() {
[10:27:03.044]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:03.044]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:03.044]                       search = base::search(), system = base::Sys.info())
[10:27:03.044]                   }
[10:27:03.044]                   ...future.conditions[[length(...future.conditions) + 
[10:27:03.044]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:03.044]                     cond$call), session = sessionInformation(), 
[10:27:03.044]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:03.044]                   signalCondition(cond)
[10:27:03.044]                 }
[10:27:03.044]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:03.044]                 "immediateCondition"))) {
[10:27:03.044]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:03.044]                   ...future.conditions[[length(...future.conditions) + 
[10:27:03.044]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:03.044]                   if (TRUE && !signal) {
[10:27:03.044]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:03.044]                     {
[10:27:03.044]                       inherits <- base::inherits
[10:27:03.044]                       invokeRestart <- base::invokeRestart
[10:27:03.044]                       is.null <- base::is.null
[10:27:03.044]                       muffled <- FALSE
[10:27:03.044]                       if (inherits(cond, "message")) {
[10:27:03.044]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:03.044]                         if (muffled) 
[10:27:03.044]                           invokeRestart("muffleMessage")
[10:27:03.044]                       }
[10:27:03.044]                       else if (inherits(cond, "warning")) {
[10:27:03.044]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:03.044]                         if (muffled) 
[10:27:03.044]                           invokeRestart("muffleWarning")
[10:27:03.044]                       }
[10:27:03.044]                       else if (inherits(cond, "condition")) {
[10:27:03.044]                         if (!is.null(pattern)) {
[10:27:03.044]                           computeRestarts <- base::computeRestarts
[10:27:03.044]                           grepl <- base::grepl
[10:27:03.044]                           restarts <- computeRestarts(cond)
[10:27:03.044]                           for (restart in restarts) {
[10:27:03.044]                             name <- restart$name
[10:27:03.044]                             if (is.null(name)) 
[10:27:03.044]                               next
[10:27:03.044]                             if (!grepl(pattern, name)) 
[10:27:03.044]                               next
[10:27:03.044]                             invokeRestart(restart)
[10:27:03.044]                             muffled <- TRUE
[10:27:03.044]                             break
[10:27:03.044]                           }
[10:27:03.044]                         }
[10:27:03.044]                       }
[10:27:03.044]                       invisible(muffled)
[10:27:03.044]                     }
[10:27:03.044]                     muffleCondition(cond, pattern = "^muffle")
[10:27:03.044]                   }
[10:27:03.044]                 }
[10:27:03.044]                 else {
[10:27:03.044]                   if (TRUE) {
[10:27:03.044]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:03.044]                     {
[10:27:03.044]                       inherits <- base::inherits
[10:27:03.044]                       invokeRestart <- base::invokeRestart
[10:27:03.044]                       is.null <- base::is.null
[10:27:03.044]                       muffled <- FALSE
[10:27:03.044]                       if (inherits(cond, "message")) {
[10:27:03.044]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:03.044]                         if (muffled) 
[10:27:03.044]                           invokeRestart("muffleMessage")
[10:27:03.044]                       }
[10:27:03.044]                       else if (inherits(cond, "warning")) {
[10:27:03.044]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:03.044]                         if (muffled) 
[10:27:03.044]                           invokeRestart("muffleWarning")
[10:27:03.044]                       }
[10:27:03.044]                       else if (inherits(cond, "condition")) {
[10:27:03.044]                         if (!is.null(pattern)) {
[10:27:03.044]                           computeRestarts <- base::computeRestarts
[10:27:03.044]                           grepl <- base::grepl
[10:27:03.044]                           restarts <- computeRestarts(cond)
[10:27:03.044]                           for (restart in restarts) {
[10:27:03.044]                             name <- restart$name
[10:27:03.044]                             if (is.null(name)) 
[10:27:03.044]                               next
[10:27:03.044]                             if (!grepl(pattern, name)) 
[10:27:03.044]                               next
[10:27:03.044]                             invokeRestart(restart)
[10:27:03.044]                             muffled <- TRUE
[10:27:03.044]                             break
[10:27:03.044]                           }
[10:27:03.044]                         }
[10:27:03.044]                       }
[10:27:03.044]                       invisible(muffled)
[10:27:03.044]                     }
[10:27:03.044]                     muffleCondition(cond, pattern = "^muffle")
[10:27:03.044]                   }
[10:27:03.044]                 }
[10:27:03.044]             }
[10:27:03.044]         }))
[10:27:03.044]     }, error = function(ex) {
[10:27:03.044]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:03.044]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:03.044]                 ...future.rng), started = ...future.startTime, 
[10:27:03.044]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:03.044]             version = "1.8"), class = "FutureResult")
[10:27:03.044]     }, finally = {
[10:27:03.044]         if (!identical(...future.workdir, getwd())) 
[10:27:03.044]             setwd(...future.workdir)
[10:27:03.044]         {
[10:27:03.044]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:03.044]                 ...future.oldOptions$nwarnings <- NULL
[10:27:03.044]             }
[10:27:03.044]             base::options(...future.oldOptions)
[10:27:03.044]             if (.Platform$OS.type == "windows") {
[10:27:03.044]                 old_names <- names(...future.oldEnvVars)
[10:27:03.044]                 envs <- base::Sys.getenv()
[10:27:03.044]                 names <- names(envs)
[10:27:03.044]                 common <- intersect(names, old_names)
[10:27:03.044]                 added <- setdiff(names, old_names)
[10:27:03.044]                 removed <- setdiff(old_names, names)
[10:27:03.044]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:03.044]                   envs[common]]
[10:27:03.044]                 NAMES <- toupper(changed)
[10:27:03.044]                 args <- list()
[10:27:03.044]                 for (kk in seq_along(NAMES)) {
[10:27:03.044]                   name <- changed[[kk]]
[10:27:03.044]                   NAME <- NAMES[[kk]]
[10:27:03.044]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:03.044]                     next
[10:27:03.044]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:03.044]                 }
[10:27:03.044]                 NAMES <- toupper(added)
[10:27:03.044]                 for (kk in seq_along(NAMES)) {
[10:27:03.044]                   name <- added[[kk]]
[10:27:03.044]                   NAME <- NAMES[[kk]]
[10:27:03.044]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:03.044]                     next
[10:27:03.044]                   args[[name]] <- ""
[10:27:03.044]                 }
[10:27:03.044]                 NAMES <- toupper(removed)
[10:27:03.044]                 for (kk in seq_along(NAMES)) {
[10:27:03.044]                   name <- removed[[kk]]
[10:27:03.044]                   NAME <- NAMES[[kk]]
[10:27:03.044]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:03.044]                     next
[10:27:03.044]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:03.044]                 }
[10:27:03.044]                 if (length(args) > 0) 
[10:27:03.044]                   base::do.call(base::Sys.setenv, args = args)
[10:27:03.044]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:03.044]             }
[10:27:03.044]             else {
[10:27:03.044]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:03.044]             }
[10:27:03.044]             {
[10:27:03.044]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:03.044]                   0L) {
[10:27:03.044]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:03.044]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:03.044]                   base::options(opts)
[10:27:03.044]                 }
[10:27:03.044]                 {
[10:27:03.044]                   {
[10:27:03.044]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:03.044]                     NULL
[10:27:03.044]                   }
[10:27:03.044]                   options(future.plan = NULL)
[10:27:03.044]                   if (is.na(NA_character_)) 
[10:27:03.044]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:03.044]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:03.044]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:27:03.044]                     envir = parent.frame()) 
[10:27:03.044]                   {
[10:27:03.044]                     default_workers <- missing(workers)
[10:27:03.044]                     if (is.function(workers)) 
[10:27:03.044]                       workers <- workers()
[10:27:03.044]                     workers <- structure(as.integer(workers), 
[10:27:03.044]                       class = class(workers))
[10:27:03.044]                     stop_if_not(is.finite(workers), workers >= 
[10:27:03.044]                       1L)
[10:27:03.044]                     if ((workers == 1L && !inherits(workers, 
[10:27:03.044]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:27:03.044]                       if (default_workers) 
[10:27:03.044]                         supportsMulticore(warn = TRUE)
[10:27:03.044]                       return(sequential(..., envir = envir))
[10:27:03.044]                     }
[10:27:03.044]                     oopts <- options(mc.cores = workers)
[10:27:03.044]                     on.exit(options(oopts))
[10:27:03.044]                     future <- MulticoreFuture(..., workers = workers, 
[10:27:03.044]                       envir = envir)
[10:27:03.044]                     if (!future$lazy) 
[10:27:03.044]                       future <- run(future)
[10:27:03.044]                     invisible(future)
[10:27:03.044]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:03.044]                 }
[10:27:03.044]             }
[10:27:03.044]         }
[10:27:03.044]     })
[10:27:03.044]     if (TRUE) {
[10:27:03.044]         base::sink(type = "output", split = FALSE)
[10:27:03.044]         if (TRUE) {
[10:27:03.044]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:03.044]         }
[10:27:03.044]         else {
[10:27:03.044]             ...future.result["stdout"] <- base::list(NULL)
[10:27:03.044]         }
[10:27:03.044]         base::close(...future.stdout)
[10:27:03.044]         ...future.stdout <- NULL
[10:27:03.044]     }
[10:27:03.044]     ...future.result$conditions <- ...future.conditions
[10:27:03.044]     ...future.result$finished <- base::Sys.time()
[10:27:03.044]     ...future.result
[10:27:03.044] }
[10:27:03.047] requestCore(): workers = 2
[10:27:03.047] Poll #1 (0): usedCores() = 2, workers = 2
[10:27:03.058] result() for MulticoreFuture ...
[10:27:03.059] result() for MulticoreFuture ...
[10:27:03.059] result() for MulticoreFuture ... done
[10:27:03.059] result() for MulticoreFuture ... done
[10:27:03.059] result() for MulticoreFuture ...
[10:27:03.059] result() for MulticoreFuture ... done
[10:27:03.062] MulticoreFuture started
[10:27:03.062] - Launch lazy future ... done
[10:27:03.063] run() for ‘MulticoreFuture’ ... done
[10:27:03.063] plan(): Setting new future strategy stack:
[10:27:03.064] getGlobalsAndPackages() ...
[10:27:03.064] Searching for globals...
[10:27:03.064] List of future strategies:
[10:27:03.064] 1. sequential:
[10:27:03.064]    - args: function (..., envir = parent.frame())
[10:27:03.064]    - tweaked: FALSE
[10:27:03.064]    - call: NULL
[10:27:03.065] plan(): nbrOfWorkers() = 1
[10:27:03.066] - globals found: [1] ‘{’
[10:27:03.067] Searching for globals ... DONE
[10:27:03.067] Resolving globals: FALSE
[10:27:03.068] 
[10:27:03.068] plan(): Setting new future strategy stack:
[10:27:03.068] 
[10:27:03.068] getGlobalsAndPackages() ... DONE
[10:27:03.068] List of future strategies:
[10:27:03.068] 1. multicore:
[10:27:03.068]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:27:03.068]    - tweaked: FALSE
[10:27:03.068]    - call: plan(strategy)
[10:27:03.069] run() for ‘Future’ ...
[10:27:03.069] - state: ‘created’
[10:27:03.070] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:27:03.075] plan(): nbrOfWorkers() = 2
[10:27:03.076] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:03.076] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:27:03.076]   - Field: ‘label’
[10:27:03.076]   - Field: ‘local’
[10:27:03.077]   - Field: ‘owner’
[10:27:03.077]   - Field: ‘envir’
[10:27:03.077]   - Field: ‘workers’
[10:27:03.077]   - Field: ‘packages’
[10:27:03.077]   - Field: ‘gc’
[10:27:03.078]   - Field: ‘job’
[10:27:03.078]   - Field: ‘conditions’
[10:27:03.078]   - Field: ‘expr’
[10:27:03.078]   - Field: ‘uuid’
[10:27:03.078]   - Field: ‘seed’
[10:27:03.078]   - Field: ‘version’
[10:27:03.078]   - Field: ‘result’
[10:27:03.079]   - Field: ‘asynchronous’
[10:27:03.079]   - Field: ‘calls’
[10:27:03.079]   - Field: ‘globals’
[10:27:03.079]   - Field: ‘stdout’
[10:27:03.079]   - Field: ‘earlySignal’
[10:27:03.079]   - Field: ‘lazy’
[10:27:03.079]   - Field: ‘state’
[10:27:03.080] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:27:03.080] - Launch lazy future ...
[10:27:03.080] Packages needed by the future expression (n = 0): <none>
[10:27:03.080] Packages needed by future strategies (n = 0): <none>
[10:27:03.081] {
[10:27:03.081]     {
[10:27:03.081]         {
[10:27:03.081]             ...future.startTime <- base::Sys.time()
[10:27:03.081]             {
[10:27:03.081]                 {
[10:27:03.081]                   {
[10:27:03.081]                     {
[10:27:03.081]                       base::local({
[10:27:03.081]                         has_future <- base::requireNamespace("future", 
[10:27:03.081]                           quietly = TRUE)
[10:27:03.081]                         if (has_future) {
[10:27:03.081]                           ns <- base::getNamespace("future")
[10:27:03.081]                           version <- ns[[".package"]][["version"]]
[10:27:03.081]                           if (is.null(version)) 
[10:27:03.081]                             version <- utils::packageVersion("future")
[10:27:03.081]                         }
[10:27:03.081]                         else {
[10:27:03.081]                           version <- NULL
[10:27:03.081]                         }
[10:27:03.081]                         if (!has_future || version < "1.8.0") {
[10:27:03.081]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:03.081]                             "", base::R.version$version.string), 
[10:27:03.081]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:03.081]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:03.081]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:03.081]                               "release", "version")], collapse = " "), 
[10:27:03.081]                             hostname = base::Sys.info()[["nodename"]])
[10:27:03.081]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:03.081]                             info)
[10:27:03.081]                           info <- base::paste(info, collapse = "; ")
[10:27:03.081]                           if (!has_future) {
[10:27:03.081]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:03.081]                               info)
[10:27:03.081]                           }
[10:27:03.081]                           else {
[10:27:03.081]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:03.081]                               info, version)
[10:27:03.081]                           }
[10:27:03.081]                           base::stop(msg)
[10:27:03.081]                         }
[10:27:03.081]                       })
[10:27:03.081]                     }
[10:27:03.081]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:03.081]                     base::options(mc.cores = 1L)
[10:27:03.081]                   }
[10:27:03.081]                   options(future.plan = NULL)
[10:27:03.081]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:03.081]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:03.081]                 }
[10:27:03.081]                 ...future.workdir <- getwd()
[10:27:03.081]             }
[10:27:03.081]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:03.081]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:03.081]         }
[10:27:03.081]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:03.081]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:03.081]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:03.081]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:03.081]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:03.081]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:03.081]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:03.081]             base::names(...future.oldOptions))
[10:27:03.081]     }
[10:27:03.081]     if (FALSE) {
[10:27:03.081]     }
[10:27:03.081]     else {
[10:27:03.081]         if (TRUE) {
[10:27:03.081]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:03.081]                 open = "w")
[10:27:03.081]         }
[10:27:03.081]         else {
[10:27:03.081]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:03.081]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:03.081]         }
[10:27:03.081]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:03.081]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:03.081]             base::sink(type = "output", split = FALSE)
[10:27:03.081]             base::close(...future.stdout)
[10:27:03.081]         }, add = TRUE)
[10:27:03.081]     }
[10:27:03.081]     ...future.frame <- base::sys.nframe()
[10:27:03.081]     ...future.conditions <- base::list()
[10:27:03.081]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:03.081]     if (FALSE) {
[10:27:03.081]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:03.081]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:03.081]     }
[10:27:03.081]     ...future.result <- base::tryCatch({
[10:27:03.081]         base::withCallingHandlers({
[10:27:03.081]             ...future.value <- base::withVisible(base::local({
[10:27:03.081]                 withCallingHandlers({
[10:27:03.081]                   {
[10:27:03.081]                     2
[10:27:03.081]                   }
[10:27:03.081]                 }, immediateCondition = function(cond) {
[10:27:03.081]                   save_rds <- function (object, pathname, ...) 
[10:27:03.081]                   {
[10:27:03.081]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:27:03.081]                     if (file_test("-f", pathname_tmp)) {
[10:27:03.081]                       fi_tmp <- file.info(pathname_tmp)
[10:27:03.081]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:27:03.081]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:03.081]                         fi_tmp[["mtime"]])
[10:27:03.081]                     }
[10:27:03.081]                     tryCatch({
[10:27:03.081]                       saveRDS(object, file = pathname_tmp, ...)
[10:27:03.081]                     }, error = function(ex) {
[10:27:03.081]                       msg <- conditionMessage(ex)
[10:27:03.081]                       fi_tmp <- file.info(pathname_tmp)
[10:27:03.081]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:27:03.081]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:03.081]                         fi_tmp[["mtime"]], msg)
[10:27:03.081]                       ex$message <- msg
[10:27:03.081]                       stop(ex)
[10:27:03.081]                     })
[10:27:03.081]                     stopifnot(file_test("-f", pathname_tmp))
[10:27:03.081]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:27:03.081]                     if (!res || file_test("-f", pathname_tmp)) {
[10:27:03.081]                       fi_tmp <- file.info(pathname_tmp)
[10:27:03.081]                       fi <- file.info(pathname)
[10:27:03.081]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:27:03.081]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:03.081]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:27:03.081]                         fi[["size"]], fi[["mtime"]])
[10:27:03.081]                       stop(msg)
[10:27:03.081]                     }
[10:27:03.081]                     invisible(pathname)
[10:27:03.081]                   }
[10:27:03.081]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:27:03.081]                     rootPath = tempdir()) 
[10:27:03.081]                   {
[10:27:03.081]                     obj <- list(time = Sys.time(), condition = cond)
[10:27:03.081]                     file <- tempfile(pattern = class(cond)[1], 
[10:27:03.081]                       tmpdir = path, fileext = ".rds")
[10:27:03.081]                     save_rds(obj, file)
[10:27:03.081]                   }
[10:27:03.081]                   saveImmediateCondition(cond, path = "/tmp/RtmpisxSDE/.future/immediateConditions")
[10:27:03.081]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:03.081]                   {
[10:27:03.081]                     inherits <- base::inherits
[10:27:03.081]                     invokeRestart <- base::invokeRestart
[10:27:03.081]                     is.null <- base::is.null
[10:27:03.081]                     muffled <- FALSE
[10:27:03.081]                     if (inherits(cond, "message")) {
[10:27:03.081]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:03.081]                       if (muffled) 
[10:27:03.081]                         invokeRestart("muffleMessage")
[10:27:03.081]                     }
[10:27:03.081]                     else if (inherits(cond, "warning")) {
[10:27:03.081]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:03.081]                       if (muffled) 
[10:27:03.081]                         invokeRestart("muffleWarning")
[10:27:03.081]                     }
[10:27:03.081]                     else if (inherits(cond, "condition")) {
[10:27:03.081]                       if (!is.null(pattern)) {
[10:27:03.081]                         computeRestarts <- base::computeRestarts
[10:27:03.081]                         grepl <- base::grepl
[10:27:03.081]                         restarts <- computeRestarts(cond)
[10:27:03.081]                         for (restart in restarts) {
[10:27:03.081]                           name <- restart$name
[10:27:03.081]                           if (is.null(name)) 
[10:27:03.081]                             next
[10:27:03.081]                           if (!grepl(pattern, name)) 
[10:27:03.081]                             next
[10:27:03.081]                           invokeRestart(restart)
[10:27:03.081]                           muffled <- TRUE
[10:27:03.081]                           break
[10:27:03.081]                         }
[10:27:03.081]                       }
[10:27:03.081]                     }
[10:27:03.081]                     invisible(muffled)
[10:27:03.081]                   }
[10:27:03.081]                   muffleCondition(cond)
[10:27:03.081]                 })
[10:27:03.081]             }))
[10:27:03.081]             future::FutureResult(value = ...future.value$value, 
[10:27:03.081]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:03.081]                   ...future.rng), globalenv = if (FALSE) 
[10:27:03.081]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:03.081]                     ...future.globalenv.names))
[10:27:03.081]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:03.081]         }, condition = base::local({
[10:27:03.081]             c <- base::c
[10:27:03.081]             inherits <- base::inherits
[10:27:03.081]             invokeRestart <- base::invokeRestart
[10:27:03.081]             length <- base::length
[10:27:03.081]             list <- base::list
[10:27:03.081]             seq.int <- base::seq.int
[10:27:03.081]             signalCondition <- base::signalCondition
[10:27:03.081]             sys.calls <- base::sys.calls
[10:27:03.081]             `[[` <- base::`[[`
[10:27:03.081]             `+` <- base::`+`
[10:27:03.081]             `<<-` <- base::`<<-`
[10:27:03.081]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:03.081]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:03.081]                   3L)]
[10:27:03.081]             }
[10:27:03.081]             function(cond) {
[10:27:03.081]                 is_error <- inherits(cond, "error")
[10:27:03.081]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:03.081]                   NULL)
[10:27:03.081]                 if (is_error) {
[10:27:03.081]                   sessionInformation <- function() {
[10:27:03.081]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:03.081]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:03.081]                       search = base::search(), system = base::Sys.info())
[10:27:03.081]                   }
[10:27:03.081]                   ...future.conditions[[length(...future.conditions) + 
[10:27:03.081]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:03.081]                     cond$call), session = sessionInformation(), 
[10:27:03.081]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:03.081]                   signalCondition(cond)
[10:27:03.081]                 }
[10:27:03.081]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:03.081]                 "immediateCondition"))) {
[10:27:03.081]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:03.081]                   ...future.conditions[[length(...future.conditions) + 
[10:27:03.081]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:03.081]                   if (TRUE && !signal) {
[10:27:03.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:03.081]                     {
[10:27:03.081]                       inherits <- base::inherits
[10:27:03.081]                       invokeRestart <- base::invokeRestart
[10:27:03.081]                       is.null <- base::is.null
[10:27:03.081]                       muffled <- FALSE
[10:27:03.081]                       if (inherits(cond, "message")) {
[10:27:03.081]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:03.081]                         if (muffled) 
[10:27:03.081]                           invokeRestart("muffleMessage")
[10:27:03.081]                       }
[10:27:03.081]                       else if (inherits(cond, "warning")) {
[10:27:03.081]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:03.081]                         if (muffled) 
[10:27:03.081]                           invokeRestart("muffleWarning")
[10:27:03.081]                       }
[10:27:03.081]                       else if (inherits(cond, "condition")) {
[10:27:03.081]                         if (!is.null(pattern)) {
[10:27:03.081]                           computeRestarts <- base::computeRestarts
[10:27:03.081]                           grepl <- base::grepl
[10:27:03.081]                           restarts <- computeRestarts(cond)
[10:27:03.081]                           for (restart in restarts) {
[10:27:03.081]                             name <- restart$name
[10:27:03.081]                             if (is.null(name)) 
[10:27:03.081]                               next
[10:27:03.081]                             if (!grepl(pattern, name)) 
[10:27:03.081]                               next
[10:27:03.081]                             invokeRestart(restart)
[10:27:03.081]                             muffled <- TRUE
[10:27:03.081]                             break
[10:27:03.081]                           }
[10:27:03.081]                         }
[10:27:03.081]                       }
[10:27:03.081]                       invisible(muffled)
[10:27:03.081]                     }
[10:27:03.081]                     muffleCondition(cond, pattern = "^muffle")
[10:27:03.081]                   }
[10:27:03.081]                 }
[10:27:03.081]                 else {
[10:27:03.081]                   if (TRUE) {
[10:27:03.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:03.081]                     {
[10:27:03.081]                       inherits <- base::inherits
[10:27:03.081]                       invokeRestart <- base::invokeRestart
[10:27:03.081]                       is.null <- base::is.null
[10:27:03.081]                       muffled <- FALSE
[10:27:03.081]                       if (inherits(cond, "message")) {
[10:27:03.081]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:03.081]                         if (muffled) 
[10:27:03.081]                           invokeRestart("muffleMessage")
[10:27:03.081]                       }
[10:27:03.081]                       else if (inherits(cond, "warning")) {
[10:27:03.081]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:03.081]                         if (muffled) 
[10:27:03.081]                           invokeRestart("muffleWarning")
[10:27:03.081]                       }
[10:27:03.081]                       else if (inherits(cond, "condition")) {
[10:27:03.081]                         if (!is.null(pattern)) {
[10:27:03.081]                           computeRestarts <- base::computeRestarts
[10:27:03.081]                           grepl <- base::grepl
[10:27:03.081]                           restarts <- computeRestarts(cond)
[10:27:03.081]                           for (restart in restarts) {
[10:27:03.081]                             name <- restart$name
[10:27:03.081]                             if (is.null(name)) 
[10:27:03.081]                               next
[10:27:03.081]                             if (!grepl(pattern, name)) 
[10:27:03.081]                               next
[10:27:03.081]                             invokeRestart(restart)
[10:27:03.081]                             muffled <- TRUE
[10:27:03.081]                             break
[10:27:03.081]                           }
[10:27:03.081]                         }
[10:27:03.081]                       }
[10:27:03.081]                       invisible(muffled)
[10:27:03.081]                     }
[10:27:03.081]                     muffleCondition(cond, pattern = "^muffle")
[10:27:03.081]                   }
[10:27:03.081]                 }
[10:27:03.081]             }
[10:27:03.081]         }))
[10:27:03.081]     }, error = function(ex) {
[10:27:03.081]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:03.081]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:03.081]                 ...future.rng), started = ...future.startTime, 
[10:27:03.081]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:03.081]             version = "1.8"), class = "FutureResult")
[10:27:03.081]     }, finally = {
[10:27:03.081]         if (!identical(...future.workdir, getwd())) 
[10:27:03.081]             setwd(...future.workdir)
[10:27:03.081]         {
[10:27:03.081]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:03.081]                 ...future.oldOptions$nwarnings <- NULL
[10:27:03.081]             }
[10:27:03.081]             base::options(...future.oldOptions)
[10:27:03.081]             if (.Platform$OS.type == "windows") {
[10:27:03.081]                 old_names <- names(...future.oldEnvVars)
[10:27:03.081]                 envs <- base::Sys.getenv()
[10:27:03.081]                 names <- names(envs)
[10:27:03.081]                 common <- intersect(names, old_names)
[10:27:03.081]                 added <- setdiff(names, old_names)
[10:27:03.081]                 removed <- setdiff(old_names, names)
[10:27:03.081]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:03.081]                   envs[common]]
[10:27:03.081]                 NAMES <- toupper(changed)
[10:27:03.081]                 args <- list()
[10:27:03.081]                 for (kk in seq_along(NAMES)) {
[10:27:03.081]                   name <- changed[[kk]]
[10:27:03.081]                   NAME <- NAMES[[kk]]
[10:27:03.081]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:03.081]                     next
[10:27:03.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:03.081]                 }
[10:27:03.081]                 NAMES <- toupper(added)
[10:27:03.081]                 for (kk in seq_along(NAMES)) {
[10:27:03.081]                   name <- added[[kk]]
[10:27:03.081]                   NAME <- NAMES[[kk]]
[10:27:03.081]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:03.081]                     next
[10:27:03.081]                   args[[name]] <- ""
[10:27:03.081]                 }
[10:27:03.081]                 NAMES <- toupper(removed)
[10:27:03.081]                 for (kk in seq_along(NAMES)) {
[10:27:03.081]                   name <- removed[[kk]]
[10:27:03.081]                   NAME <- NAMES[[kk]]
[10:27:03.081]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:03.081]                     next
[10:27:03.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:03.081]                 }
[10:27:03.081]                 if (length(args) > 0) 
[10:27:03.081]                   base::do.call(base::Sys.setenv, args = args)
[10:27:03.081]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:03.081]             }
[10:27:03.081]             else {
[10:27:03.081]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:03.081]             }
[10:27:03.081]             {
[10:27:03.081]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:03.081]                   0L) {
[10:27:03.081]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:03.081]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:03.081]                   base::options(opts)
[10:27:03.081]                 }
[10:27:03.081]                 {
[10:27:03.081]                   {
[10:27:03.081]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:03.081]                     NULL
[10:27:03.081]                   }
[10:27:03.081]                   options(future.plan = NULL)
[10:27:03.081]                   if (is.na(NA_character_)) 
[10:27:03.081]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:03.081]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:03.081]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:27:03.081]                     envir = parent.frame()) 
[10:27:03.081]                   {
[10:27:03.081]                     default_workers <- missing(workers)
[10:27:03.081]                     if (is.function(workers)) 
[10:27:03.081]                       workers <- workers()
[10:27:03.081]                     workers <- structure(as.integer(workers), 
[10:27:03.081]                       class = class(workers))
[10:27:03.081]                     stop_if_not(is.finite(workers), workers >= 
[10:27:03.081]                       1L)
[10:27:03.081]                     if ((workers == 1L && !inherits(workers, 
[10:27:03.081]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:27:03.081]                       if (default_workers) 
[10:27:03.081]                         supportsMulticore(warn = TRUE)
[10:27:03.081]                       return(sequential(..., envir = envir))
[10:27:03.081]                     }
[10:27:03.081]                     oopts <- options(mc.cores = workers)
[10:27:03.081]                     on.exit(options(oopts))
[10:27:03.081]                     future <- MulticoreFuture(..., workers = workers, 
[10:27:03.081]                       envir = envir)
[10:27:03.081]                     if (!future$lazy) 
[10:27:03.081]                       future <- run(future)
[10:27:03.081]                     invisible(future)
[10:27:03.081]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:03.081]                 }
[10:27:03.081]             }
[10:27:03.081]         }
[10:27:03.081]     })
[10:27:03.081]     if (TRUE) {
[10:27:03.081]         base::sink(type = "output", split = FALSE)
[10:27:03.081]         if (TRUE) {
[10:27:03.081]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:03.081]         }
[10:27:03.081]         else {
[10:27:03.081]             ...future.result["stdout"] <- base::list(NULL)
[10:27:03.081]         }
[10:27:03.081]         base::close(...future.stdout)
[10:27:03.081]         ...future.stdout <- NULL
[10:27:03.081]     }
[10:27:03.081]     ...future.result$conditions <- ...future.conditions
[10:27:03.081]     ...future.result$finished <- base::Sys.time()
[10:27:03.081]     ...future.result
[10:27:03.081] }
[10:27:03.085] requestCore(): workers = 2
[10:27:03.086] Poll #1 (0): usedCores() = 2, workers = 2
[10:27:03.097] result() for MulticoreFuture ...
[10:27:03.098] result() for MulticoreFuture ...
[10:27:03.098] result() for MulticoreFuture ... done
[10:27:03.098] result() for MulticoreFuture ... done
[10:27:03.098] result() for MulticoreFuture ...
[10:27:03.098] result() for MulticoreFuture ... done
[10:27:03.102] MulticoreFuture started
[10:27:03.102] - Launch lazy future ... done
[10:27:03.103] run() for ‘MulticoreFuture’ ... done
[10:27:03.103] plan(): Setting new future strategy stack:
[10:27:03.103] List of future strategies:
[10:27:03.103] 1. sequential:
[10:27:03.103]    - args: function (..., envir = parent.frame())
[10:27:03.103]    - tweaked: FALSE
[10:27:03.103]    - call: NULL
[10:27:03.105] plan(): nbrOfWorkers() = 1
[10:27:03.105] resolve() on environment ...
[10:27:03.105]  recursive: 0
[10:27:03.106]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[10:27:03.107] Future #1
[10:27:03.107]  length: 2 (resolved future 1)
[10:27:03.108] plan(): Setting new future strategy stack:
[10:27:03.108] List of future strategies:
[10:27:03.108] 1. multicore:
[10:27:03.108]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:27:03.108]    - tweaked: FALSE
[10:27:03.108]    - call: plan(strategy)
[10:27:03.114] plan(): nbrOfWorkers() = 2
[10:27:03.115] Future #2
[10:27:03.116]  length: 1 (resolved future 2)
[10:27:03.116]  length: 0 (resolved future 3)
[10:27:03.116] resolve() on environment ... DONE
[10:27:03.117] getGlobalsAndPackages() ...
[10:27:03.117] Searching for globals...
[10:27:03.118] - globals found: [1] ‘{’
[10:27:03.119] Searching for globals ... DONE
[10:27:03.119] Resolving globals: FALSE
[10:27:03.120] 
[10:27:03.120] 
[10:27:03.120] getGlobalsAndPackages() ... DONE
[10:27:03.120] run() for ‘Future’ ...
[10:27:03.120] - state: ‘created’
[10:27:03.121] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:27:03.132] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:03.132] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:27:03.132]   - Field: ‘label’
[10:27:03.133]   - Field: ‘local’
[10:27:03.133]   - Field: ‘owner’
[10:27:03.134]   - Field: ‘envir’
[10:27:03.134]   - Field: ‘workers’
[10:27:03.134]   - Field: ‘packages’
[10:27:03.135]   - Field: ‘gc’
[10:27:03.135]   - Field: ‘job’
[10:27:03.135]   - Field: ‘conditions’
[10:27:03.135]   - Field: ‘expr’
[10:27:03.135]   - Field: ‘uuid’
[10:27:03.135]   - Field: ‘seed’
[10:27:03.136]   - Field: ‘version’
[10:27:03.136]   - Field: ‘result’
[10:27:03.136]   - Field: ‘asynchronous’
[10:27:03.136]   - Field: ‘calls’
[10:27:03.136]   - Field: ‘globals’
[10:27:03.136]   - Field: ‘stdout’
[10:27:03.137]   - Field: ‘earlySignal’
[10:27:03.137]   - Field: ‘lazy’
[10:27:03.137]   - Field: ‘state’
[10:27:03.137] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:27:03.137] - Launch lazy future ...
[10:27:03.138] Packages needed by the future expression (n = 0): <none>
[10:27:03.138] Packages needed by future strategies (n = 0): <none>
[10:27:03.139] {
[10:27:03.139]     {
[10:27:03.139]         {
[10:27:03.139]             ...future.startTime <- base::Sys.time()
[10:27:03.139]             {
[10:27:03.139]                 {
[10:27:03.139]                   {
[10:27:03.139]                     {
[10:27:03.139]                       base::local({
[10:27:03.139]                         has_future <- base::requireNamespace("future", 
[10:27:03.139]                           quietly = TRUE)
[10:27:03.139]                         if (has_future) {
[10:27:03.139]                           ns <- base::getNamespace("future")
[10:27:03.139]                           version <- ns[[".package"]][["version"]]
[10:27:03.139]                           if (is.null(version)) 
[10:27:03.139]                             version <- utils::packageVersion("future")
[10:27:03.139]                         }
[10:27:03.139]                         else {
[10:27:03.139]                           version <- NULL
[10:27:03.139]                         }
[10:27:03.139]                         if (!has_future || version < "1.8.0") {
[10:27:03.139]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:03.139]                             "", base::R.version$version.string), 
[10:27:03.139]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:03.139]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:03.139]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:03.139]                               "release", "version")], collapse = " "), 
[10:27:03.139]                             hostname = base::Sys.info()[["nodename"]])
[10:27:03.139]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:03.139]                             info)
[10:27:03.139]                           info <- base::paste(info, collapse = "; ")
[10:27:03.139]                           if (!has_future) {
[10:27:03.139]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:03.139]                               info)
[10:27:03.139]                           }
[10:27:03.139]                           else {
[10:27:03.139]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:03.139]                               info, version)
[10:27:03.139]                           }
[10:27:03.139]                           base::stop(msg)
[10:27:03.139]                         }
[10:27:03.139]                       })
[10:27:03.139]                     }
[10:27:03.139]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:03.139]                     base::options(mc.cores = 1L)
[10:27:03.139]                   }
[10:27:03.139]                   options(future.plan = NULL)
[10:27:03.139]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:03.139]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:03.139]                 }
[10:27:03.139]                 ...future.workdir <- getwd()
[10:27:03.139]             }
[10:27:03.139]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:03.139]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:03.139]         }
[10:27:03.139]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:03.139]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:03.139]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:03.139]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:03.139]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:03.139]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:03.139]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:03.139]             base::names(...future.oldOptions))
[10:27:03.139]     }
[10:27:03.139]     if (FALSE) {
[10:27:03.139]     }
[10:27:03.139]     else {
[10:27:03.139]         if (TRUE) {
[10:27:03.139]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:03.139]                 open = "w")
[10:27:03.139]         }
[10:27:03.139]         else {
[10:27:03.139]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:03.139]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:03.139]         }
[10:27:03.139]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:03.139]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:03.139]             base::sink(type = "output", split = FALSE)
[10:27:03.139]             base::close(...future.stdout)
[10:27:03.139]         }, add = TRUE)
[10:27:03.139]     }
[10:27:03.139]     ...future.frame <- base::sys.nframe()
[10:27:03.139]     ...future.conditions <- base::list()
[10:27:03.139]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:03.139]     if (FALSE) {
[10:27:03.139]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:03.139]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:03.139]     }
[10:27:03.139]     ...future.result <- base::tryCatch({
[10:27:03.139]         base::withCallingHandlers({
[10:27:03.139]             ...future.value <- base::withVisible(base::local({
[10:27:03.139]                 withCallingHandlers({
[10:27:03.139]                   {
[10:27:03.139]                     1
[10:27:03.139]                   }
[10:27:03.139]                 }, immediateCondition = function(cond) {
[10:27:03.139]                   save_rds <- function (object, pathname, ...) 
[10:27:03.139]                   {
[10:27:03.139]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:27:03.139]                     if (file_test("-f", pathname_tmp)) {
[10:27:03.139]                       fi_tmp <- file.info(pathname_tmp)
[10:27:03.139]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:27:03.139]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:03.139]                         fi_tmp[["mtime"]])
[10:27:03.139]                     }
[10:27:03.139]                     tryCatch({
[10:27:03.139]                       saveRDS(object, file = pathname_tmp, ...)
[10:27:03.139]                     }, error = function(ex) {
[10:27:03.139]                       msg <- conditionMessage(ex)
[10:27:03.139]                       fi_tmp <- file.info(pathname_tmp)
[10:27:03.139]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:27:03.139]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:03.139]                         fi_tmp[["mtime"]], msg)
[10:27:03.139]                       ex$message <- msg
[10:27:03.139]                       stop(ex)
[10:27:03.139]                     })
[10:27:03.139]                     stopifnot(file_test("-f", pathname_tmp))
[10:27:03.139]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:27:03.139]                     if (!res || file_test("-f", pathname_tmp)) {
[10:27:03.139]                       fi_tmp <- file.info(pathname_tmp)
[10:27:03.139]                       fi <- file.info(pathname)
[10:27:03.139]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:27:03.139]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:03.139]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:27:03.139]                         fi[["size"]], fi[["mtime"]])
[10:27:03.139]                       stop(msg)
[10:27:03.139]                     }
[10:27:03.139]                     invisible(pathname)
[10:27:03.139]                   }
[10:27:03.139]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:27:03.139]                     rootPath = tempdir()) 
[10:27:03.139]                   {
[10:27:03.139]                     obj <- list(time = Sys.time(), condition = cond)
[10:27:03.139]                     file <- tempfile(pattern = class(cond)[1], 
[10:27:03.139]                       tmpdir = path, fileext = ".rds")
[10:27:03.139]                     save_rds(obj, file)
[10:27:03.139]                   }
[10:27:03.139]                   saveImmediateCondition(cond, path = "/tmp/RtmpisxSDE/.future/immediateConditions")
[10:27:03.139]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:03.139]                   {
[10:27:03.139]                     inherits <- base::inherits
[10:27:03.139]                     invokeRestart <- base::invokeRestart
[10:27:03.139]                     is.null <- base::is.null
[10:27:03.139]                     muffled <- FALSE
[10:27:03.139]                     if (inherits(cond, "message")) {
[10:27:03.139]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:03.139]                       if (muffled) 
[10:27:03.139]                         invokeRestart("muffleMessage")
[10:27:03.139]                     }
[10:27:03.139]                     else if (inherits(cond, "warning")) {
[10:27:03.139]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:03.139]                       if (muffled) 
[10:27:03.139]                         invokeRestart("muffleWarning")
[10:27:03.139]                     }
[10:27:03.139]                     else if (inherits(cond, "condition")) {
[10:27:03.139]                       if (!is.null(pattern)) {
[10:27:03.139]                         computeRestarts <- base::computeRestarts
[10:27:03.139]                         grepl <- base::grepl
[10:27:03.139]                         restarts <- computeRestarts(cond)
[10:27:03.139]                         for (restart in restarts) {
[10:27:03.139]                           name <- restart$name
[10:27:03.139]                           if (is.null(name)) 
[10:27:03.139]                             next
[10:27:03.139]                           if (!grepl(pattern, name)) 
[10:27:03.139]                             next
[10:27:03.139]                           invokeRestart(restart)
[10:27:03.139]                           muffled <- TRUE
[10:27:03.139]                           break
[10:27:03.139]                         }
[10:27:03.139]                       }
[10:27:03.139]                     }
[10:27:03.139]                     invisible(muffled)
[10:27:03.139]                   }
[10:27:03.139]                   muffleCondition(cond)
[10:27:03.139]                 })
[10:27:03.139]             }))
[10:27:03.139]             future::FutureResult(value = ...future.value$value, 
[10:27:03.139]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:03.139]                   ...future.rng), globalenv = if (FALSE) 
[10:27:03.139]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:03.139]                     ...future.globalenv.names))
[10:27:03.139]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:03.139]         }, condition = base::local({
[10:27:03.139]             c <- base::c
[10:27:03.139]             inherits <- base::inherits
[10:27:03.139]             invokeRestart <- base::invokeRestart
[10:27:03.139]             length <- base::length
[10:27:03.139]             list <- base::list
[10:27:03.139]             seq.int <- base::seq.int
[10:27:03.139]             signalCondition <- base::signalCondition
[10:27:03.139]             sys.calls <- base::sys.calls
[10:27:03.139]             `[[` <- base::`[[`
[10:27:03.139]             `+` <- base::`+`
[10:27:03.139]             `<<-` <- base::`<<-`
[10:27:03.139]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:03.139]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:03.139]                   3L)]
[10:27:03.139]             }
[10:27:03.139]             function(cond) {
[10:27:03.139]                 is_error <- inherits(cond, "error")
[10:27:03.139]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:03.139]                   NULL)
[10:27:03.139]                 if (is_error) {
[10:27:03.139]                   sessionInformation <- function() {
[10:27:03.139]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:03.139]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:03.139]                       search = base::search(), system = base::Sys.info())
[10:27:03.139]                   }
[10:27:03.139]                   ...future.conditions[[length(...future.conditions) + 
[10:27:03.139]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:03.139]                     cond$call), session = sessionInformation(), 
[10:27:03.139]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:03.139]                   signalCondition(cond)
[10:27:03.139]                 }
[10:27:03.139]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:03.139]                 "immediateCondition"))) {
[10:27:03.139]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:03.139]                   ...future.conditions[[length(...future.conditions) + 
[10:27:03.139]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:03.139]                   if (TRUE && !signal) {
[10:27:03.139]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:03.139]                     {
[10:27:03.139]                       inherits <- base::inherits
[10:27:03.139]                       invokeRestart <- base::invokeRestart
[10:27:03.139]                       is.null <- base::is.null
[10:27:03.139]                       muffled <- FALSE
[10:27:03.139]                       if (inherits(cond, "message")) {
[10:27:03.139]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:03.139]                         if (muffled) 
[10:27:03.139]                           invokeRestart("muffleMessage")
[10:27:03.139]                       }
[10:27:03.139]                       else if (inherits(cond, "warning")) {
[10:27:03.139]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:03.139]                         if (muffled) 
[10:27:03.139]                           invokeRestart("muffleWarning")
[10:27:03.139]                       }
[10:27:03.139]                       else if (inherits(cond, "condition")) {
[10:27:03.139]                         if (!is.null(pattern)) {
[10:27:03.139]                           computeRestarts <- base::computeRestarts
[10:27:03.139]                           grepl <- base::grepl
[10:27:03.139]                           restarts <- computeRestarts(cond)
[10:27:03.139]                           for (restart in restarts) {
[10:27:03.139]                             name <- restart$name
[10:27:03.139]                             if (is.null(name)) 
[10:27:03.139]                               next
[10:27:03.139]                             if (!grepl(pattern, name)) 
[10:27:03.139]                               next
[10:27:03.139]                             invokeRestart(restart)
[10:27:03.139]                             muffled <- TRUE
[10:27:03.139]                             break
[10:27:03.139]                           }
[10:27:03.139]                         }
[10:27:03.139]                       }
[10:27:03.139]                       invisible(muffled)
[10:27:03.139]                     }
[10:27:03.139]                     muffleCondition(cond, pattern = "^muffle")
[10:27:03.139]                   }
[10:27:03.139]                 }
[10:27:03.139]                 else {
[10:27:03.139]                   if (TRUE) {
[10:27:03.139]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:03.139]                     {
[10:27:03.139]                       inherits <- base::inherits
[10:27:03.139]                       invokeRestart <- base::invokeRestart
[10:27:03.139]                       is.null <- base::is.null
[10:27:03.139]                       muffled <- FALSE
[10:27:03.139]                       if (inherits(cond, "message")) {
[10:27:03.139]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:03.139]                         if (muffled) 
[10:27:03.139]                           invokeRestart("muffleMessage")
[10:27:03.139]                       }
[10:27:03.139]                       else if (inherits(cond, "warning")) {
[10:27:03.139]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:03.139]                         if (muffled) 
[10:27:03.139]                           invokeRestart("muffleWarning")
[10:27:03.139]                       }
[10:27:03.139]                       else if (inherits(cond, "condition")) {
[10:27:03.139]                         if (!is.null(pattern)) {
[10:27:03.139]                           computeRestarts <- base::computeRestarts
[10:27:03.139]                           grepl <- base::grepl
[10:27:03.139]                           restarts <- computeRestarts(cond)
[10:27:03.139]                           for (restart in restarts) {
[10:27:03.139]                             name <- restart$name
[10:27:03.139]                             if (is.null(name)) 
[10:27:03.139]                               next
[10:27:03.139]                             if (!grepl(pattern, name)) 
[10:27:03.139]                               next
[10:27:03.139]                             invokeRestart(restart)
[10:27:03.139]                             muffled <- TRUE
[10:27:03.139]                             break
[10:27:03.139]                           }
[10:27:03.139]                         }
[10:27:03.139]                       }
[10:27:03.139]                       invisible(muffled)
[10:27:03.139]                     }
[10:27:03.139]                     muffleCondition(cond, pattern = "^muffle")
[10:27:03.139]                   }
[10:27:03.139]                 }
[10:27:03.139]             }
[10:27:03.139]         }))
[10:27:03.139]     }, error = function(ex) {
[10:27:03.139]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:03.139]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:03.139]                 ...future.rng), started = ...future.startTime, 
[10:27:03.139]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:03.139]             version = "1.8"), class = "FutureResult")
[10:27:03.139]     }, finally = {
[10:27:03.139]         if (!identical(...future.workdir, getwd())) 
[10:27:03.139]             setwd(...future.workdir)
[10:27:03.139]         {
[10:27:03.139]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:03.139]                 ...future.oldOptions$nwarnings <- NULL
[10:27:03.139]             }
[10:27:03.139]             base::options(...future.oldOptions)
[10:27:03.139]             if (.Platform$OS.type == "windows") {
[10:27:03.139]                 old_names <- names(...future.oldEnvVars)
[10:27:03.139]                 envs <- base::Sys.getenv()
[10:27:03.139]                 names <- names(envs)
[10:27:03.139]                 common <- intersect(names, old_names)
[10:27:03.139]                 added <- setdiff(names, old_names)
[10:27:03.139]                 removed <- setdiff(old_names, names)
[10:27:03.139]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:03.139]                   envs[common]]
[10:27:03.139]                 NAMES <- toupper(changed)
[10:27:03.139]                 args <- list()
[10:27:03.139]                 for (kk in seq_along(NAMES)) {
[10:27:03.139]                   name <- changed[[kk]]
[10:27:03.139]                   NAME <- NAMES[[kk]]
[10:27:03.139]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:03.139]                     next
[10:27:03.139]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:03.139]                 }
[10:27:03.139]                 NAMES <- toupper(added)
[10:27:03.139]                 for (kk in seq_along(NAMES)) {
[10:27:03.139]                   name <- added[[kk]]
[10:27:03.139]                   NAME <- NAMES[[kk]]
[10:27:03.139]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:03.139]                     next
[10:27:03.139]                   args[[name]] <- ""
[10:27:03.139]                 }
[10:27:03.139]                 NAMES <- toupper(removed)
[10:27:03.139]                 for (kk in seq_along(NAMES)) {
[10:27:03.139]                   name <- removed[[kk]]
[10:27:03.139]                   NAME <- NAMES[[kk]]
[10:27:03.139]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:03.139]                     next
[10:27:03.139]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:03.139]                 }
[10:27:03.139]                 if (length(args) > 0) 
[10:27:03.139]                   base::do.call(base::Sys.setenv, args = args)
[10:27:03.139]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:03.139]             }
[10:27:03.139]             else {
[10:27:03.139]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:03.139]             }
[10:27:03.139]             {
[10:27:03.139]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:03.139]                   0L) {
[10:27:03.139]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:03.139]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:03.139]                   base::options(opts)
[10:27:03.139]                 }
[10:27:03.139]                 {
[10:27:03.139]                   {
[10:27:03.139]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:03.139]                     NULL
[10:27:03.139]                   }
[10:27:03.139]                   options(future.plan = NULL)
[10:27:03.139]                   if (is.na(NA_character_)) 
[10:27:03.139]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:03.139]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:03.139]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:27:03.139]                     envir = parent.frame()) 
[10:27:03.139]                   {
[10:27:03.139]                     default_workers <- missing(workers)
[10:27:03.139]                     if (is.function(workers)) 
[10:27:03.139]                       workers <- workers()
[10:27:03.139]                     workers <- structure(as.integer(workers), 
[10:27:03.139]                       class = class(workers))
[10:27:03.139]                     stop_if_not(is.finite(workers), workers >= 
[10:27:03.139]                       1L)
[10:27:03.139]                     if ((workers == 1L && !inherits(workers, 
[10:27:03.139]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:27:03.139]                       if (default_workers) 
[10:27:03.139]                         supportsMulticore(warn = TRUE)
[10:27:03.139]                       return(sequential(..., envir = envir))
[10:27:03.139]                     }
[10:27:03.139]                     oopts <- options(mc.cores = workers)
[10:27:03.139]                     on.exit(options(oopts))
[10:27:03.139]                     future <- MulticoreFuture(..., workers = workers, 
[10:27:03.139]                       envir = envir)
[10:27:03.139]                     if (!future$lazy) 
[10:27:03.139]                       future <- run(future)
[10:27:03.139]                     invisible(future)
[10:27:03.139]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:03.139]                 }
[10:27:03.139]             }
[10:27:03.139]         }
[10:27:03.139]     })
[10:27:03.139]     if (TRUE) {
[10:27:03.139]         base::sink(type = "output", split = FALSE)
[10:27:03.139]         if (TRUE) {
[10:27:03.139]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:03.139]         }
[10:27:03.139]         else {
[10:27:03.139]             ...future.result["stdout"] <- base::list(NULL)
[10:27:03.139]         }
[10:27:03.139]         base::close(...future.stdout)
[10:27:03.139]         ...future.stdout <- NULL
[10:27:03.139]     }
[10:27:03.139]     ...future.result$conditions <- ...future.conditions
[10:27:03.139]     ...future.result$finished <- base::Sys.time()
[10:27:03.139]     ...future.result
[10:27:03.139] }
[10:27:03.142] requestCore(): workers = 2
[10:27:03.143] Poll #1 (0): usedCores() = 2, workers = 2
[10:27:03.154] result() for MulticoreFuture ...
[10:27:03.155] result() for MulticoreFuture ...
[10:27:03.155] result() for MulticoreFuture ... done
[10:27:03.155] result() for MulticoreFuture ... done
[10:27:03.155] result() for MulticoreFuture ...
[10:27:03.155] result() for MulticoreFuture ... done
[10:27:03.158] MulticoreFuture started
[10:27:03.162] - Launch lazy future ... done
[10:27:03.162] run() for ‘MulticoreFuture’ ... done
[10:27:03.163] plan(): Setting new future strategy stack:
[10:27:03.163] getGlobalsAndPackages() ...
[10:27:03.164] Searching for globals...
[10:27:03.163] List of future strategies:
[10:27:03.163] 1. sequential:
[10:27:03.163]    - args: function (..., envir = parent.frame())
[10:27:03.163]    - tweaked: FALSE
[10:27:03.163]    - call: NULL
[10:27:03.164] plan(): nbrOfWorkers() = 1
[10:27:03.166] - globals found: [1] ‘{’
[10:27:03.166] Searching for globals ... DONE
[10:27:03.167] Resolving globals: FALSE
[10:27:03.167] 
[10:27:03.167] plan(): Setting new future strategy stack:
[10:27:03.168] 
[10:27:03.168] getGlobalsAndPackages() ... DONE
[10:27:03.168] List of future strategies:
[10:27:03.168] 1. multicore:
[10:27:03.168]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:27:03.168]    - tweaked: FALSE
[10:27:03.168]    - call: plan(strategy)
[10:27:03.169] run() for ‘Future’ ...
[10:27:03.169] - state: ‘created’
[10:27:03.169] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:27:03.174] plan(): nbrOfWorkers() = 2
[10:27:03.175] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:03.175] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:27:03.175]   - Field: ‘label’
[10:27:03.175]   - Field: ‘local’
[10:27:03.176]   - Field: ‘owner’
[10:27:03.176]   - Field: ‘envir’
[10:27:03.176]   - Field: ‘workers’
[10:27:03.176]   - Field: ‘packages’
[10:27:03.176]   - Field: ‘gc’
[10:27:03.176]   - Field: ‘job’
[10:27:03.177]   - Field: ‘conditions’
[10:27:03.177]   - Field: ‘expr’
[10:27:03.177]   - Field: ‘uuid’
[10:27:03.177]   - Field: ‘seed’
[10:27:03.177]   - Field: ‘version’
[10:27:03.177]   - Field: ‘result’
[10:27:03.178]   - Field: ‘asynchronous’
[10:27:03.178]   - Field: ‘calls’
[10:27:03.178]   - Field: ‘globals’
[10:27:03.178]   - Field: ‘stdout’
[10:27:03.178]   - Field: ‘earlySignal’
[10:27:03.178]   - Field: ‘lazy’
[10:27:03.179]   - Field: ‘state’
[10:27:03.179] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:27:03.179] - Launch lazy future ...
[10:27:03.179] Packages needed by the future expression (n = 0): <none>
[10:27:03.180] Packages needed by future strategies (n = 0): <none>
[10:27:03.180] {
[10:27:03.180]     {
[10:27:03.180]         {
[10:27:03.180]             ...future.startTime <- base::Sys.time()
[10:27:03.180]             {
[10:27:03.180]                 {
[10:27:03.180]                   {
[10:27:03.180]                     {
[10:27:03.180]                       base::local({
[10:27:03.180]                         has_future <- base::requireNamespace("future", 
[10:27:03.180]                           quietly = TRUE)
[10:27:03.180]                         if (has_future) {
[10:27:03.180]                           ns <- base::getNamespace("future")
[10:27:03.180]                           version <- ns[[".package"]][["version"]]
[10:27:03.180]                           if (is.null(version)) 
[10:27:03.180]                             version <- utils::packageVersion("future")
[10:27:03.180]                         }
[10:27:03.180]                         else {
[10:27:03.180]                           version <- NULL
[10:27:03.180]                         }
[10:27:03.180]                         if (!has_future || version < "1.8.0") {
[10:27:03.180]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:03.180]                             "", base::R.version$version.string), 
[10:27:03.180]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:03.180]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:03.180]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:03.180]                               "release", "version")], collapse = " "), 
[10:27:03.180]                             hostname = base::Sys.info()[["nodename"]])
[10:27:03.180]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:03.180]                             info)
[10:27:03.180]                           info <- base::paste(info, collapse = "; ")
[10:27:03.180]                           if (!has_future) {
[10:27:03.180]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:03.180]                               info)
[10:27:03.180]                           }
[10:27:03.180]                           else {
[10:27:03.180]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:03.180]                               info, version)
[10:27:03.180]                           }
[10:27:03.180]                           base::stop(msg)
[10:27:03.180]                         }
[10:27:03.180]                       })
[10:27:03.180]                     }
[10:27:03.180]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:03.180]                     base::options(mc.cores = 1L)
[10:27:03.180]                   }
[10:27:03.180]                   options(future.plan = NULL)
[10:27:03.180]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:03.180]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:03.180]                 }
[10:27:03.180]                 ...future.workdir <- getwd()
[10:27:03.180]             }
[10:27:03.180]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:03.180]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:03.180]         }
[10:27:03.180]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:03.180]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:03.180]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:03.180]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:03.180]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:03.180]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:03.180]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:03.180]             base::names(...future.oldOptions))
[10:27:03.180]     }
[10:27:03.180]     if (FALSE) {
[10:27:03.180]     }
[10:27:03.180]     else {
[10:27:03.180]         if (TRUE) {
[10:27:03.180]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:03.180]                 open = "w")
[10:27:03.180]         }
[10:27:03.180]         else {
[10:27:03.180]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:03.180]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:03.180]         }
[10:27:03.180]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:03.180]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:03.180]             base::sink(type = "output", split = FALSE)
[10:27:03.180]             base::close(...future.stdout)
[10:27:03.180]         }, add = TRUE)
[10:27:03.180]     }
[10:27:03.180]     ...future.frame <- base::sys.nframe()
[10:27:03.180]     ...future.conditions <- base::list()
[10:27:03.180]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:03.180]     if (FALSE) {
[10:27:03.180]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:03.180]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:03.180]     }
[10:27:03.180]     ...future.result <- base::tryCatch({
[10:27:03.180]         base::withCallingHandlers({
[10:27:03.180]             ...future.value <- base::withVisible(base::local({
[10:27:03.180]                 withCallingHandlers({
[10:27:03.180]                   {
[10:27:03.180]                     2
[10:27:03.180]                   }
[10:27:03.180]                 }, immediateCondition = function(cond) {
[10:27:03.180]                   save_rds <- function (object, pathname, ...) 
[10:27:03.180]                   {
[10:27:03.180]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:27:03.180]                     if (file_test("-f", pathname_tmp)) {
[10:27:03.180]                       fi_tmp <- file.info(pathname_tmp)
[10:27:03.180]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:27:03.180]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:03.180]                         fi_tmp[["mtime"]])
[10:27:03.180]                     }
[10:27:03.180]                     tryCatch({
[10:27:03.180]                       saveRDS(object, file = pathname_tmp, ...)
[10:27:03.180]                     }, error = function(ex) {
[10:27:03.180]                       msg <- conditionMessage(ex)
[10:27:03.180]                       fi_tmp <- file.info(pathname_tmp)
[10:27:03.180]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:27:03.180]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:03.180]                         fi_tmp[["mtime"]], msg)
[10:27:03.180]                       ex$message <- msg
[10:27:03.180]                       stop(ex)
[10:27:03.180]                     })
[10:27:03.180]                     stopifnot(file_test("-f", pathname_tmp))
[10:27:03.180]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:27:03.180]                     if (!res || file_test("-f", pathname_tmp)) {
[10:27:03.180]                       fi_tmp <- file.info(pathname_tmp)
[10:27:03.180]                       fi <- file.info(pathname)
[10:27:03.180]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:27:03.180]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:03.180]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:27:03.180]                         fi[["size"]], fi[["mtime"]])
[10:27:03.180]                       stop(msg)
[10:27:03.180]                     }
[10:27:03.180]                     invisible(pathname)
[10:27:03.180]                   }
[10:27:03.180]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:27:03.180]                     rootPath = tempdir()) 
[10:27:03.180]                   {
[10:27:03.180]                     obj <- list(time = Sys.time(), condition = cond)
[10:27:03.180]                     file <- tempfile(pattern = class(cond)[1], 
[10:27:03.180]                       tmpdir = path, fileext = ".rds")
[10:27:03.180]                     save_rds(obj, file)
[10:27:03.180]                   }
[10:27:03.180]                   saveImmediateCondition(cond, path = "/tmp/RtmpisxSDE/.future/immediateConditions")
[10:27:03.180]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:03.180]                   {
[10:27:03.180]                     inherits <- base::inherits
[10:27:03.180]                     invokeRestart <- base::invokeRestart
[10:27:03.180]                     is.null <- base::is.null
[10:27:03.180]                     muffled <- FALSE
[10:27:03.180]                     if (inherits(cond, "message")) {
[10:27:03.180]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:03.180]                       if (muffled) 
[10:27:03.180]                         invokeRestart("muffleMessage")
[10:27:03.180]                     }
[10:27:03.180]                     else if (inherits(cond, "warning")) {
[10:27:03.180]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:03.180]                       if (muffled) 
[10:27:03.180]                         invokeRestart("muffleWarning")
[10:27:03.180]                     }
[10:27:03.180]                     else if (inherits(cond, "condition")) {
[10:27:03.180]                       if (!is.null(pattern)) {
[10:27:03.180]                         computeRestarts <- base::computeRestarts
[10:27:03.180]                         grepl <- base::grepl
[10:27:03.180]                         restarts <- computeRestarts(cond)
[10:27:03.180]                         for (restart in restarts) {
[10:27:03.180]                           name <- restart$name
[10:27:03.180]                           if (is.null(name)) 
[10:27:03.180]                             next
[10:27:03.180]                           if (!grepl(pattern, name)) 
[10:27:03.180]                             next
[10:27:03.180]                           invokeRestart(restart)
[10:27:03.180]                           muffled <- TRUE
[10:27:03.180]                           break
[10:27:03.180]                         }
[10:27:03.180]                       }
[10:27:03.180]                     }
[10:27:03.180]                     invisible(muffled)
[10:27:03.180]                   }
[10:27:03.180]                   muffleCondition(cond)
[10:27:03.180]                 })
[10:27:03.180]             }))
[10:27:03.180]             future::FutureResult(value = ...future.value$value, 
[10:27:03.180]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:03.180]                   ...future.rng), globalenv = if (FALSE) 
[10:27:03.180]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:03.180]                     ...future.globalenv.names))
[10:27:03.180]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:03.180]         }, condition = base::local({
[10:27:03.180]             c <- base::c
[10:27:03.180]             inherits <- base::inherits
[10:27:03.180]             invokeRestart <- base::invokeRestart
[10:27:03.180]             length <- base::length
[10:27:03.180]             list <- base::list
[10:27:03.180]             seq.int <- base::seq.int
[10:27:03.180]             signalCondition <- base::signalCondition
[10:27:03.180]             sys.calls <- base::sys.calls
[10:27:03.180]             `[[` <- base::`[[`
[10:27:03.180]             `+` <- base::`+`
[10:27:03.180]             `<<-` <- base::`<<-`
[10:27:03.180]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:03.180]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:03.180]                   3L)]
[10:27:03.180]             }
[10:27:03.180]             function(cond) {
[10:27:03.180]                 is_error <- inherits(cond, "error")
[10:27:03.180]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:03.180]                   NULL)
[10:27:03.180]                 if (is_error) {
[10:27:03.180]                   sessionInformation <- function() {
[10:27:03.180]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:03.180]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:03.180]                       search = base::search(), system = base::Sys.info())
[10:27:03.180]                   }
[10:27:03.180]                   ...future.conditions[[length(...future.conditions) + 
[10:27:03.180]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:03.180]                     cond$call), session = sessionInformation(), 
[10:27:03.180]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:03.180]                   signalCondition(cond)
[10:27:03.180]                 }
[10:27:03.180]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:03.180]                 "immediateCondition"))) {
[10:27:03.180]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:03.180]                   ...future.conditions[[length(...future.conditions) + 
[10:27:03.180]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:03.180]                   if (TRUE && !signal) {
[10:27:03.180]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:03.180]                     {
[10:27:03.180]                       inherits <- base::inherits
[10:27:03.180]                       invokeRestart <- base::invokeRestart
[10:27:03.180]                       is.null <- base::is.null
[10:27:03.180]                       muffled <- FALSE
[10:27:03.180]                       if (inherits(cond, "message")) {
[10:27:03.180]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:03.180]                         if (muffled) 
[10:27:03.180]                           invokeRestart("muffleMessage")
[10:27:03.180]                       }
[10:27:03.180]                       else if (inherits(cond, "warning")) {
[10:27:03.180]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:03.180]                         if (muffled) 
[10:27:03.180]                           invokeRestart("muffleWarning")
[10:27:03.180]                       }
[10:27:03.180]                       else if (inherits(cond, "condition")) {
[10:27:03.180]                         if (!is.null(pattern)) {
[10:27:03.180]                           computeRestarts <- base::computeRestarts
[10:27:03.180]                           grepl <- base::grepl
[10:27:03.180]                           restarts <- computeRestarts(cond)
[10:27:03.180]                           for (restart in restarts) {
[10:27:03.180]                             name <- restart$name
[10:27:03.180]                             if (is.null(name)) 
[10:27:03.180]                               next
[10:27:03.180]                             if (!grepl(pattern, name)) 
[10:27:03.180]                               next
[10:27:03.180]                             invokeRestart(restart)
[10:27:03.180]                             muffled <- TRUE
[10:27:03.180]                             break
[10:27:03.180]                           }
[10:27:03.180]                         }
[10:27:03.180]                       }
[10:27:03.180]                       invisible(muffled)
[10:27:03.180]                     }
[10:27:03.180]                     muffleCondition(cond, pattern = "^muffle")
[10:27:03.180]                   }
[10:27:03.180]                 }
[10:27:03.180]                 else {
[10:27:03.180]                   if (TRUE) {
[10:27:03.180]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:03.180]                     {
[10:27:03.180]                       inherits <- base::inherits
[10:27:03.180]                       invokeRestart <- base::invokeRestart
[10:27:03.180]                       is.null <- base::is.null
[10:27:03.180]                       muffled <- FALSE
[10:27:03.180]                       if (inherits(cond, "message")) {
[10:27:03.180]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:03.180]                         if (muffled) 
[10:27:03.180]                           invokeRestart("muffleMessage")
[10:27:03.180]                       }
[10:27:03.180]                       else if (inherits(cond, "warning")) {
[10:27:03.180]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:03.180]                         if (muffled) 
[10:27:03.180]                           invokeRestart("muffleWarning")
[10:27:03.180]                       }
[10:27:03.180]                       else if (inherits(cond, "condition")) {
[10:27:03.180]                         if (!is.null(pattern)) {
[10:27:03.180]                           computeRestarts <- base::computeRestarts
[10:27:03.180]                           grepl <- base::grepl
[10:27:03.180]                           restarts <- computeRestarts(cond)
[10:27:03.180]                           for (restart in restarts) {
[10:27:03.180]                             name <- restart$name
[10:27:03.180]                             if (is.null(name)) 
[10:27:03.180]                               next
[10:27:03.180]                             if (!grepl(pattern, name)) 
[10:27:03.180]                               next
[10:27:03.180]                             invokeRestart(restart)
[10:27:03.180]                             muffled <- TRUE
[10:27:03.180]                             break
[10:27:03.180]                           }
[10:27:03.180]                         }
[10:27:03.180]                       }
[10:27:03.180]                       invisible(muffled)
[10:27:03.180]                     }
[10:27:03.180]                     muffleCondition(cond, pattern = "^muffle")
[10:27:03.180]                   }
[10:27:03.180]                 }
[10:27:03.180]             }
[10:27:03.180]         }))
[10:27:03.180]     }, error = function(ex) {
[10:27:03.180]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:03.180]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:03.180]                 ...future.rng), started = ...future.startTime, 
[10:27:03.180]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:03.180]             version = "1.8"), class = "FutureResult")
[10:27:03.180]     }, finally = {
[10:27:03.180]         if (!identical(...future.workdir, getwd())) 
[10:27:03.180]             setwd(...future.workdir)
[10:27:03.180]         {
[10:27:03.180]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:03.180]                 ...future.oldOptions$nwarnings <- NULL
[10:27:03.180]             }
[10:27:03.180]             base::options(...future.oldOptions)
[10:27:03.180]             if (.Platform$OS.type == "windows") {
[10:27:03.180]                 old_names <- names(...future.oldEnvVars)
[10:27:03.180]                 envs <- base::Sys.getenv()
[10:27:03.180]                 names <- names(envs)
[10:27:03.180]                 common <- intersect(names, old_names)
[10:27:03.180]                 added <- setdiff(names, old_names)
[10:27:03.180]                 removed <- setdiff(old_names, names)
[10:27:03.180]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:03.180]                   envs[common]]
[10:27:03.180]                 NAMES <- toupper(changed)
[10:27:03.180]                 args <- list()
[10:27:03.180]                 for (kk in seq_along(NAMES)) {
[10:27:03.180]                   name <- changed[[kk]]
[10:27:03.180]                   NAME <- NAMES[[kk]]
[10:27:03.180]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:03.180]                     next
[10:27:03.180]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:03.180]                 }
[10:27:03.180]                 NAMES <- toupper(added)
[10:27:03.180]                 for (kk in seq_along(NAMES)) {
[10:27:03.180]                   name <- added[[kk]]
[10:27:03.180]                   NAME <- NAMES[[kk]]
[10:27:03.180]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:03.180]                     next
[10:27:03.180]                   args[[name]] <- ""
[10:27:03.180]                 }
[10:27:03.180]                 NAMES <- toupper(removed)
[10:27:03.180]                 for (kk in seq_along(NAMES)) {
[10:27:03.180]                   name <- removed[[kk]]
[10:27:03.180]                   NAME <- NAMES[[kk]]
[10:27:03.180]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:03.180]                     next
[10:27:03.180]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:03.180]                 }
[10:27:03.180]                 if (length(args) > 0) 
[10:27:03.180]                   base::do.call(base::Sys.setenv, args = args)
[10:27:03.180]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:03.180]             }
[10:27:03.180]             else {
[10:27:03.180]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:03.180]             }
[10:27:03.180]             {
[10:27:03.180]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:03.180]                   0L) {
[10:27:03.180]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:03.180]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:03.180]                   base::options(opts)
[10:27:03.180]                 }
[10:27:03.180]                 {
[10:27:03.180]                   {
[10:27:03.180]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:03.180]                     NULL
[10:27:03.180]                   }
[10:27:03.180]                   options(future.plan = NULL)
[10:27:03.180]                   if (is.na(NA_character_)) 
[10:27:03.180]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:03.180]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:03.180]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:27:03.180]                     envir = parent.frame()) 
[10:27:03.180]                   {
[10:27:03.180]                     default_workers <- missing(workers)
[10:27:03.180]                     if (is.function(workers)) 
[10:27:03.180]                       workers <- workers()
[10:27:03.180]                     workers <- structure(as.integer(workers), 
[10:27:03.180]                       class = class(workers))
[10:27:03.180]                     stop_if_not(is.finite(workers), workers >= 
[10:27:03.180]                       1L)
[10:27:03.180]                     if ((workers == 1L && !inherits(workers, 
[10:27:03.180]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:27:03.180]                       if (default_workers) 
[10:27:03.180]                         supportsMulticore(warn = TRUE)
[10:27:03.180]                       return(sequential(..., envir = envir))
[10:27:03.180]                     }
[10:27:03.180]                     oopts <- options(mc.cores = workers)
[10:27:03.180]                     on.exit(options(oopts))
[10:27:03.180]                     future <- MulticoreFuture(..., workers = workers, 
[10:27:03.180]                       envir = envir)
[10:27:03.180]                     if (!future$lazy) 
[10:27:03.180]                       future <- run(future)
[10:27:03.180]                     invisible(future)
[10:27:03.180]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:03.180]                 }
[10:27:03.180]             }
[10:27:03.180]         }
[10:27:03.180]     })
[10:27:03.180]     if (TRUE) {
[10:27:03.180]         base::sink(type = "output", split = FALSE)
[10:27:03.180]         if (TRUE) {
[10:27:03.180]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:03.180]         }
[10:27:03.180]         else {
[10:27:03.180]             ...future.result["stdout"] <- base::list(NULL)
[10:27:03.180]         }
[10:27:03.180]         base::close(...future.stdout)
[10:27:03.180]         ...future.stdout <- NULL
[10:27:03.180]     }
[10:27:03.180]     ...future.result$conditions <- ...future.conditions
[10:27:03.180]     ...future.result$finished <- base::Sys.time()
[10:27:03.180]     ...future.result
[10:27:03.180] }
[10:27:03.184] requestCore(): workers = 2
[10:27:03.185] Poll #1 (0): usedCores() = 2, workers = 2
[10:27:03.195] result() for MulticoreFuture ...
[10:27:03.197] result() for MulticoreFuture ...
[10:27:03.198] result() for MulticoreFuture ... done
[10:27:03.199] result() for MulticoreFuture ... done
[10:27:03.202] result() for MulticoreFuture ...
[10:27:03.202] result() for MulticoreFuture ... done
[10:27:03.205] MulticoreFuture started
[10:27:03.205] - Launch lazy future ... done
[10:27:03.206] run() for ‘MulticoreFuture’ ... done
[10:27:03.206] plan(): Setting new future strategy stack:
[10:27:03.207] List of future strategies:
[10:27:03.207] 1. sequential:
[10:27:03.207]    - args: function (..., envir = parent.frame())
[10:27:03.207]    - tweaked: FALSE
[10:27:03.207]    - call: NULL
[10:27:03.207] resolve() on environment ...
[10:27:03.207]  recursive: 0
[10:27:03.207] plan(): nbrOfWorkers() = 1
[10:27:03.208]  elements: [3] ‘a’
[10:27:03.209] Future #1
[10:27:03.209]  length: 2 (resolved future 1)
[10:27:03.210] plan(): Setting new future strategy stack:
[10:27:03.210] List of future strategies:
[10:27:03.210] 1. multicore:
[10:27:03.210]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:27:03.210]    - tweaked: FALSE
[10:27:03.210]    - call: plan(strategy)
[10:27:03.219] plan(): nbrOfWorkers() = 2
[10:27:03.220]  length: 1 (resolved future 3)
[10:27:03.231] Future #2
[10:27:03.231]  length: 0 (resolved future 2)
[10:27:03.232] resolve() on environment ... DONE
[10:27:03.233] resolve() on environment ...
[10:27:03.233]  recursive: 0
[10:27:03.233]  elements: [3] ‘b’
[10:27:03.234] Future #1
[10:27:03.234]  length: 2 (resolved future 1)
[10:27:03.234] Future #2
[10:27:03.235]  length: 1 (resolved future 2)
[10:27:03.235]  length: 0 (resolved future 3)
[10:27:03.235] resolve() on environment ... DONE
[10:27:03.236] resolve() on environment ...
[10:27:03.236]  recursive: 0
[10:27:03.237]  elements: [3] ‘c’
[10:27:03.237] Future #1
[10:27:03.237]  length: 2 (resolved future 1)
[10:27:03.237] Future #2
[10:27:03.238]  length: 1 (resolved future 2)
[10:27:03.238]  length: 0 (resolved future 3)
[10:27:03.238] resolve() on environment ... DONE
[10:27:03.239] resolve() on environment ...
[10:27:03.239]  recursive: 0
[10:27:03.240]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[10:27:03.240] Future #1
[10:27:03.240] result() for MulticoreFuture ...
[10:27:03.241] result() for MulticoreFuture ...
[10:27:03.241] result() for MulticoreFuture ... done
[10:27:03.246] result() for MulticoreFuture ... done
[10:27:03.246] result() for MulticoreFuture ...
[10:27:03.247] result() for MulticoreFuture ... done
[10:27:03.247]  length: 2 (resolved future 1)
[10:27:03.248] Future #2
[10:27:03.248] result() for MulticoreFuture ...
[10:27:03.249] result() for MulticoreFuture ...
[10:27:03.250] result() for MulticoreFuture ... done
[10:27:03.250] result() for MulticoreFuture ... done
[10:27:03.250] result() for MulticoreFuture ...
[10:27:03.250] result() for MulticoreFuture ... done
[10:27:03.251]  length: 1 (resolved future 2)
[10:27:03.251]  length: 0 (resolved future 3)
[10:27:03.251] resolve() on environment ... DONE
[10:27:03.252] resolve() on environment ...
[10:27:03.252]  recursive: 99
[10:27:03.252]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[10:27:03.253] Future #1
[10:27:03.253] result() for MulticoreFuture ...
[10:27:03.253] result() for MulticoreFuture ... done
[10:27:03.253] result() for MulticoreFuture ...
[10:27:03.253] result() for MulticoreFuture ... done
[10:27:03.253] A MulticoreFuture was resolved
[10:27:03.253]  length: 2 (resolved future 1)
[10:27:03.254] Future #2
[10:27:03.254] result() for MulticoreFuture ...
[10:27:03.254] result() for MulticoreFuture ... done
[10:27:03.254] result() for MulticoreFuture ...
[10:27:03.254] result() for MulticoreFuture ... done
[10:27:03.254] A MulticoreFuture was resolved
[10:27:03.254]  length: 1 (resolved future 2)
[10:27:03.255]  length: 0 (resolved future 3)
[10:27:03.255] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[10:27:03.256] resolve() on list environment ...
[10:27:03.256]  recursive: 0
[10:27:03.256]  length: 2
[10:27:03.256]  elements: ‘a’, ‘b’
[10:27:03.257]  length: 1 (resolved future 1)
[10:27:03.257]  length: 0 (resolved future 2)
[10:27:03.257] resolve() on list environment ... DONE
[10:27:03.257] getGlobalsAndPackages() ...
[10:27:03.257] Searching for globals...
[10:27:03.258] 
[10:27:03.258] Searching for globals ... DONE
[10:27:03.258] - globals: [0] <none>
[10:27:03.258] getGlobalsAndPackages() ... DONE
[10:27:03.258] run() for ‘Future’ ...
[10:27:03.258] - state: ‘created’
[10:27:03.259] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:27:03.263] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:03.263] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:27:03.264]   - Field: ‘label’
[10:27:03.264]   - Field: ‘local’
[10:27:03.264]   - Field: ‘owner’
[10:27:03.264]   - Field: ‘envir’
[10:27:03.264]   - Field: ‘workers’
[10:27:03.264]   - Field: ‘packages’
[10:27:03.264]   - Field: ‘gc’
[10:27:03.264]   - Field: ‘job’
[10:27:03.264]   - Field: ‘conditions’
[10:27:03.265]   - Field: ‘expr’
[10:27:03.265]   - Field: ‘uuid’
[10:27:03.265]   - Field: ‘seed’
[10:27:03.265]   - Field: ‘version’
[10:27:03.265]   - Field: ‘result’
[10:27:03.267]   - Field: ‘asynchronous’
[10:27:03.270]   - Field: ‘calls’
[10:27:03.271]   - Field: ‘globals’
[10:27:03.271]   - Field: ‘stdout’
[10:27:03.271]   - Field: ‘earlySignal’
[10:27:03.272]   - Field: ‘lazy’
[10:27:03.272]   - Field: ‘state’
[10:27:03.272] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:27:03.272] - Launch lazy future ...
[10:27:03.272] Packages needed by the future expression (n = 0): <none>
[10:27:03.272] Packages needed by future strategies (n = 0): <none>
[10:27:03.273] {
[10:27:03.273]     {
[10:27:03.273]         {
[10:27:03.273]             ...future.startTime <- base::Sys.time()
[10:27:03.273]             {
[10:27:03.273]                 {
[10:27:03.273]                   {
[10:27:03.273]                     {
[10:27:03.273]                       base::local({
[10:27:03.273]                         has_future <- base::requireNamespace("future", 
[10:27:03.273]                           quietly = TRUE)
[10:27:03.273]                         if (has_future) {
[10:27:03.273]                           ns <- base::getNamespace("future")
[10:27:03.273]                           version <- ns[[".package"]][["version"]]
[10:27:03.273]                           if (is.null(version)) 
[10:27:03.273]                             version <- utils::packageVersion("future")
[10:27:03.273]                         }
[10:27:03.273]                         else {
[10:27:03.273]                           version <- NULL
[10:27:03.273]                         }
[10:27:03.273]                         if (!has_future || version < "1.8.0") {
[10:27:03.273]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:03.273]                             "", base::R.version$version.string), 
[10:27:03.273]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:03.273]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:03.273]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:03.273]                               "release", "version")], collapse = " "), 
[10:27:03.273]                             hostname = base::Sys.info()[["nodename"]])
[10:27:03.273]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:03.273]                             info)
[10:27:03.273]                           info <- base::paste(info, collapse = "; ")
[10:27:03.273]                           if (!has_future) {
[10:27:03.273]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:03.273]                               info)
[10:27:03.273]                           }
[10:27:03.273]                           else {
[10:27:03.273]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:03.273]                               info, version)
[10:27:03.273]                           }
[10:27:03.273]                           base::stop(msg)
[10:27:03.273]                         }
[10:27:03.273]                       })
[10:27:03.273]                     }
[10:27:03.273]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:03.273]                     base::options(mc.cores = 1L)
[10:27:03.273]                   }
[10:27:03.273]                   options(future.plan = NULL)
[10:27:03.273]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:03.273]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:03.273]                 }
[10:27:03.273]                 ...future.workdir <- getwd()
[10:27:03.273]             }
[10:27:03.273]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:03.273]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:03.273]         }
[10:27:03.273]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:03.273]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:03.273]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:03.273]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:03.273]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:03.273]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:03.273]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:03.273]             base::names(...future.oldOptions))
[10:27:03.273]     }
[10:27:03.273]     if (FALSE) {
[10:27:03.273]     }
[10:27:03.273]     else {
[10:27:03.273]         if (TRUE) {
[10:27:03.273]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:03.273]                 open = "w")
[10:27:03.273]         }
[10:27:03.273]         else {
[10:27:03.273]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:03.273]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:03.273]         }
[10:27:03.273]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:03.273]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:03.273]             base::sink(type = "output", split = FALSE)
[10:27:03.273]             base::close(...future.stdout)
[10:27:03.273]         }, add = TRUE)
[10:27:03.273]     }
[10:27:03.273]     ...future.frame <- base::sys.nframe()
[10:27:03.273]     ...future.conditions <- base::list()
[10:27:03.273]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:03.273]     if (FALSE) {
[10:27:03.273]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:03.273]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:03.273]     }
[10:27:03.273]     ...future.result <- base::tryCatch({
[10:27:03.273]         base::withCallingHandlers({
[10:27:03.273]             ...future.value <- base::withVisible(base::local({
[10:27:03.273]                 withCallingHandlers({
[10:27:03.273]                   1
[10:27:03.273]                 }, immediateCondition = function(cond) {
[10:27:03.273]                   save_rds <- function (object, pathname, ...) 
[10:27:03.273]                   {
[10:27:03.273]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:27:03.273]                     if (file_test("-f", pathname_tmp)) {
[10:27:03.273]                       fi_tmp <- file.info(pathname_tmp)
[10:27:03.273]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:27:03.273]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:03.273]                         fi_tmp[["mtime"]])
[10:27:03.273]                     }
[10:27:03.273]                     tryCatch({
[10:27:03.273]                       saveRDS(object, file = pathname_tmp, ...)
[10:27:03.273]                     }, error = function(ex) {
[10:27:03.273]                       msg <- conditionMessage(ex)
[10:27:03.273]                       fi_tmp <- file.info(pathname_tmp)
[10:27:03.273]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:27:03.273]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:03.273]                         fi_tmp[["mtime"]], msg)
[10:27:03.273]                       ex$message <- msg
[10:27:03.273]                       stop(ex)
[10:27:03.273]                     })
[10:27:03.273]                     stopifnot(file_test("-f", pathname_tmp))
[10:27:03.273]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:27:03.273]                     if (!res || file_test("-f", pathname_tmp)) {
[10:27:03.273]                       fi_tmp <- file.info(pathname_tmp)
[10:27:03.273]                       fi <- file.info(pathname)
[10:27:03.273]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:27:03.273]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:03.273]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:27:03.273]                         fi[["size"]], fi[["mtime"]])
[10:27:03.273]                       stop(msg)
[10:27:03.273]                     }
[10:27:03.273]                     invisible(pathname)
[10:27:03.273]                   }
[10:27:03.273]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:27:03.273]                     rootPath = tempdir()) 
[10:27:03.273]                   {
[10:27:03.273]                     obj <- list(time = Sys.time(), condition = cond)
[10:27:03.273]                     file <- tempfile(pattern = class(cond)[1], 
[10:27:03.273]                       tmpdir = path, fileext = ".rds")
[10:27:03.273]                     save_rds(obj, file)
[10:27:03.273]                   }
[10:27:03.273]                   saveImmediateCondition(cond, path = "/tmp/RtmpisxSDE/.future/immediateConditions")
[10:27:03.273]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:03.273]                   {
[10:27:03.273]                     inherits <- base::inherits
[10:27:03.273]                     invokeRestart <- base::invokeRestart
[10:27:03.273]                     is.null <- base::is.null
[10:27:03.273]                     muffled <- FALSE
[10:27:03.273]                     if (inherits(cond, "message")) {
[10:27:03.273]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:03.273]                       if (muffled) 
[10:27:03.273]                         invokeRestart("muffleMessage")
[10:27:03.273]                     }
[10:27:03.273]                     else if (inherits(cond, "warning")) {
[10:27:03.273]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:03.273]                       if (muffled) 
[10:27:03.273]                         invokeRestart("muffleWarning")
[10:27:03.273]                     }
[10:27:03.273]                     else if (inherits(cond, "condition")) {
[10:27:03.273]                       if (!is.null(pattern)) {
[10:27:03.273]                         computeRestarts <- base::computeRestarts
[10:27:03.273]                         grepl <- base::grepl
[10:27:03.273]                         restarts <- computeRestarts(cond)
[10:27:03.273]                         for (restart in restarts) {
[10:27:03.273]                           name <- restart$name
[10:27:03.273]                           if (is.null(name)) 
[10:27:03.273]                             next
[10:27:03.273]                           if (!grepl(pattern, name)) 
[10:27:03.273]                             next
[10:27:03.273]                           invokeRestart(restart)
[10:27:03.273]                           muffled <- TRUE
[10:27:03.273]                           break
[10:27:03.273]                         }
[10:27:03.273]                       }
[10:27:03.273]                     }
[10:27:03.273]                     invisible(muffled)
[10:27:03.273]                   }
[10:27:03.273]                   muffleCondition(cond)
[10:27:03.273]                 })
[10:27:03.273]             }))
[10:27:03.273]             future::FutureResult(value = ...future.value$value, 
[10:27:03.273]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:03.273]                   ...future.rng), globalenv = if (FALSE) 
[10:27:03.273]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:03.273]                     ...future.globalenv.names))
[10:27:03.273]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:03.273]         }, condition = base::local({
[10:27:03.273]             c <- base::c
[10:27:03.273]             inherits <- base::inherits
[10:27:03.273]             invokeRestart <- base::invokeRestart
[10:27:03.273]             length <- base::length
[10:27:03.273]             list <- base::list
[10:27:03.273]             seq.int <- base::seq.int
[10:27:03.273]             signalCondition <- base::signalCondition
[10:27:03.273]             sys.calls <- base::sys.calls
[10:27:03.273]             `[[` <- base::`[[`
[10:27:03.273]             `+` <- base::`+`
[10:27:03.273]             `<<-` <- base::`<<-`
[10:27:03.273]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:03.273]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:03.273]                   3L)]
[10:27:03.273]             }
[10:27:03.273]             function(cond) {
[10:27:03.273]                 is_error <- inherits(cond, "error")
[10:27:03.273]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:03.273]                   NULL)
[10:27:03.273]                 if (is_error) {
[10:27:03.273]                   sessionInformation <- function() {
[10:27:03.273]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:03.273]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:03.273]                       search = base::search(), system = base::Sys.info())
[10:27:03.273]                   }
[10:27:03.273]                   ...future.conditions[[length(...future.conditions) + 
[10:27:03.273]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:03.273]                     cond$call), session = sessionInformation(), 
[10:27:03.273]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:03.273]                   signalCondition(cond)
[10:27:03.273]                 }
[10:27:03.273]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:03.273]                 "immediateCondition"))) {
[10:27:03.273]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:03.273]                   ...future.conditions[[length(...future.conditions) + 
[10:27:03.273]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:03.273]                   if (TRUE && !signal) {
[10:27:03.273]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:03.273]                     {
[10:27:03.273]                       inherits <- base::inherits
[10:27:03.273]                       invokeRestart <- base::invokeRestart
[10:27:03.273]                       is.null <- base::is.null
[10:27:03.273]                       muffled <- FALSE
[10:27:03.273]                       if (inherits(cond, "message")) {
[10:27:03.273]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:03.273]                         if (muffled) 
[10:27:03.273]                           invokeRestart("muffleMessage")
[10:27:03.273]                       }
[10:27:03.273]                       else if (inherits(cond, "warning")) {
[10:27:03.273]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:03.273]                         if (muffled) 
[10:27:03.273]                           invokeRestart("muffleWarning")
[10:27:03.273]                       }
[10:27:03.273]                       else if (inherits(cond, "condition")) {
[10:27:03.273]                         if (!is.null(pattern)) {
[10:27:03.273]                           computeRestarts <- base::computeRestarts
[10:27:03.273]                           grepl <- base::grepl
[10:27:03.273]                           restarts <- computeRestarts(cond)
[10:27:03.273]                           for (restart in restarts) {
[10:27:03.273]                             name <- restart$name
[10:27:03.273]                             if (is.null(name)) 
[10:27:03.273]                               next
[10:27:03.273]                             if (!grepl(pattern, name)) 
[10:27:03.273]                               next
[10:27:03.273]                             invokeRestart(restart)
[10:27:03.273]                             muffled <- TRUE
[10:27:03.273]                             break
[10:27:03.273]                           }
[10:27:03.273]                         }
[10:27:03.273]                       }
[10:27:03.273]                       invisible(muffled)
[10:27:03.273]                     }
[10:27:03.273]                     muffleCondition(cond, pattern = "^muffle")
[10:27:03.273]                   }
[10:27:03.273]                 }
[10:27:03.273]                 else {
[10:27:03.273]                   if (TRUE) {
[10:27:03.273]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:03.273]                     {
[10:27:03.273]                       inherits <- base::inherits
[10:27:03.273]                       invokeRestart <- base::invokeRestart
[10:27:03.273]                       is.null <- base::is.null
[10:27:03.273]                       muffled <- FALSE
[10:27:03.273]                       if (inherits(cond, "message")) {
[10:27:03.273]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:03.273]                         if (muffled) 
[10:27:03.273]                           invokeRestart("muffleMessage")
[10:27:03.273]                       }
[10:27:03.273]                       else if (inherits(cond, "warning")) {
[10:27:03.273]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:03.273]                         if (muffled) 
[10:27:03.273]                           invokeRestart("muffleWarning")
[10:27:03.273]                       }
[10:27:03.273]                       else if (inherits(cond, "condition")) {
[10:27:03.273]                         if (!is.null(pattern)) {
[10:27:03.273]                           computeRestarts <- base::computeRestarts
[10:27:03.273]                           grepl <- base::grepl
[10:27:03.273]                           restarts <- computeRestarts(cond)
[10:27:03.273]                           for (restart in restarts) {
[10:27:03.273]                             name <- restart$name
[10:27:03.273]                             if (is.null(name)) 
[10:27:03.273]                               next
[10:27:03.273]                             if (!grepl(pattern, name)) 
[10:27:03.273]                               next
[10:27:03.273]                             invokeRestart(restart)
[10:27:03.273]                             muffled <- TRUE
[10:27:03.273]                             break
[10:27:03.273]                           }
[10:27:03.273]                         }
[10:27:03.273]                       }
[10:27:03.273]                       invisible(muffled)
[10:27:03.273]                     }
[10:27:03.273]                     muffleCondition(cond, pattern = "^muffle")
[10:27:03.273]                   }
[10:27:03.273]                 }
[10:27:03.273]             }
[10:27:03.273]         }))
[10:27:03.273]     }, error = function(ex) {
[10:27:03.273]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:03.273]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:03.273]                 ...future.rng), started = ...future.startTime, 
[10:27:03.273]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:03.273]             version = "1.8"), class = "FutureResult")
[10:27:03.273]     }, finally = {
[10:27:03.273]         if (!identical(...future.workdir, getwd())) 
[10:27:03.273]             setwd(...future.workdir)
[10:27:03.273]         {
[10:27:03.273]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:03.273]                 ...future.oldOptions$nwarnings <- NULL
[10:27:03.273]             }
[10:27:03.273]             base::options(...future.oldOptions)
[10:27:03.273]             if (.Platform$OS.type == "windows") {
[10:27:03.273]                 old_names <- names(...future.oldEnvVars)
[10:27:03.273]                 envs <- base::Sys.getenv()
[10:27:03.273]                 names <- names(envs)
[10:27:03.273]                 common <- intersect(names, old_names)
[10:27:03.273]                 added <- setdiff(names, old_names)
[10:27:03.273]                 removed <- setdiff(old_names, names)
[10:27:03.273]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:03.273]                   envs[common]]
[10:27:03.273]                 NAMES <- toupper(changed)
[10:27:03.273]                 args <- list()
[10:27:03.273]                 for (kk in seq_along(NAMES)) {
[10:27:03.273]                   name <- changed[[kk]]
[10:27:03.273]                   NAME <- NAMES[[kk]]
[10:27:03.273]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:03.273]                     next
[10:27:03.273]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:03.273]                 }
[10:27:03.273]                 NAMES <- toupper(added)
[10:27:03.273]                 for (kk in seq_along(NAMES)) {
[10:27:03.273]                   name <- added[[kk]]
[10:27:03.273]                   NAME <- NAMES[[kk]]
[10:27:03.273]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:03.273]                     next
[10:27:03.273]                   args[[name]] <- ""
[10:27:03.273]                 }
[10:27:03.273]                 NAMES <- toupper(removed)
[10:27:03.273]                 for (kk in seq_along(NAMES)) {
[10:27:03.273]                   name <- removed[[kk]]
[10:27:03.273]                   NAME <- NAMES[[kk]]
[10:27:03.273]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:03.273]                     next
[10:27:03.273]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:03.273]                 }
[10:27:03.273]                 if (length(args) > 0) 
[10:27:03.273]                   base::do.call(base::Sys.setenv, args = args)
[10:27:03.273]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:03.273]             }
[10:27:03.273]             else {
[10:27:03.273]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:03.273]             }
[10:27:03.273]             {
[10:27:03.273]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:03.273]                   0L) {
[10:27:03.273]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:03.273]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:03.273]                   base::options(opts)
[10:27:03.273]                 }
[10:27:03.273]                 {
[10:27:03.273]                   {
[10:27:03.273]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:03.273]                     NULL
[10:27:03.273]                   }
[10:27:03.273]                   options(future.plan = NULL)
[10:27:03.273]                   if (is.na(NA_character_)) 
[10:27:03.273]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:03.273]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:03.273]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:27:03.273]                     envir = parent.frame()) 
[10:27:03.273]                   {
[10:27:03.273]                     default_workers <- missing(workers)
[10:27:03.273]                     if (is.function(workers)) 
[10:27:03.273]                       workers <- workers()
[10:27:03.273]                     workers <- structure(as.integer(workers), 
[10:27:03.273]                       class = class(workers))
[10:27:03.273]                     stop_if_not(is.finite(workers), workers >= 
[10:27:03.273]                       1L)
[10:27:03.273]                     if ((workers == 1L && !inherits(workers, 
[10:27:03.273]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:27:03.273]                       if (default_workers) 
[10:27:03.273]                         supportsMulticore(warn = TRUE)
[10:27:03.273]                       return(sequential(..., envir = envir))
[10:27:03.273]                     }
[10:27:03.273]                     oopts <- options(mc.cores = workers)
[10:27:03.273]                     on.exit(options(oopts))
[10:27:03.273]                     future <- MulticoreFuture(..., workers = workers, 
[10:27:03.273]                       envir = envir)
[10:27:03.273]                     if (!future$lazy) 
[10:27:03.273]                       future <- run(future)
[10:27:03.273]                     invisible(future)
[10:27:03.273]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:03.273]                 }
[10:27:03.273]             }
[10:27:03.273]         }
[10:27:03.273]     })
[10:27:03.273]     if (TRUE) {
[10:27:03.273]         base::sink(type = "output", split = FALSE)
[10:27:03.273]         if (TRUE) {
[10:27:03.273]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:03.273]         }
[10:27:03.273]         else {
[10:27:03.273]             ...future.result["stdout"] <- base::list(NULL)
[10:27:03.273]         }
[10:27:03.273]         base::close(...future.stdout)
[10:27:03.273]         ...future.stdout <- NULL
[10:27:03.273]     }
[10:27:03.273]     ...future.result$conditions <- ...future.conditions
[10:27:03.273]     ...future.result$finished <- base::Sys.time()
[10:27:03.273]     ...future.result
[10:27:03.273] }
[10:27:03.276] requestCore(): workers = 2
[10:27:03.278] MulticoreFuture started
[10:27:03.279] - Launch lazy future ... done
[10:27:03.279] run() for ‘MulticoreFuture’ ... done
[10:27:03.279] getGlobalsAndPackages() ...
[10:27:03.279] Searching for globals...
[10:27:03.279] plan(): Setting new future strategy stack:
[10:27:03.280] 
[10:27:03.280] Searching for globals ... DONE
[10:27:03.280] List of future strategies:
[10:27:03.280] 1. sequential:
[10:27:03.280]    - args: function (..., envir = parent.frame())
[10:27:03.280]    - tweaked: FALSE
[10:27:03.280]    - call: NULL
[10:27:03.281] - globals: [0] <none>
[10:27:03.281] getGlobalsAndPackages() ... DONE
[10:27:03.281] plan(): nbrOfWorkers() = 1
[10:27:03.281] run() for ‘Future’ ...
[10:27:03.282] - state: ‘created’
[10:27:03.282] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:27:03.283] plan(): Setting new future strategy stack:
[10:27:03.284] List of future strategies:
[10:27:03.284] 1. multicore:
[10:27:03.284]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:27:03.284]    - tweaked: FALSE
[10:27:03.284]    - call: plan(strategy)
[10:27:03.288] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:03.288] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:27:03.288]   - Field: ‘label’
[10:27:03.288]   - Field: ‘local’
[10:27:03.288]   - Field: ‘owner’
[10:27:03.288]   - Field: ‘envir’
[10:27:03.289]   - Field: ‘workers’
[10:27:03.289]   - Field: ‘packages’
[10:27:03.289]   - Field: ‘gc’
[10:27:03.289]   - Field: ‘job’
[10:27:03.289]   - Field: ‘conditions’
[10:27:03.289]   - Field: ‘expr’
[10:27:03.290]   - Field: ‘uuid’
[10:27:03.290]   - Field: ‘seed’
[10:27:03.290]   - Field: ‘version’
[10:27:03.290]   - Field: ‘result’
[10:27:03.290]   - Field: ‘asynchronous’
[10:27:03.290]   - Field: ‘calls’
[10:27:03.291]   - Field: ‘globals’
[10:27:03.291]   - Field: ‘stdout’
[10:27:03.291]   - Field: ‘earlySignal’
[10:27:03.291]   - Field: ‘lazy’
[10:27:03.291]   - Field: ‘state’
[10:27:03.291] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:27:03.292] - Launch lazy future ...
[10:27:03.292] Packages needed by the future expression (n = 0): <none>
[10:27:03.292] Packages needed by future strategies (n = 0): <none>
[10:27:03.294] plan(): nbrOfWorkers() = 2
[10:27:03.294] {
[10:27:03.294]     {
[10:27:03.294]         {
[10:27:03.294]             ...future.startTime <- base::Sys.time()
[10:27:03.294]             {
[10:27:03.294]                 {
[10:27:03.294]                   {
[10:27:03.294]                     {
[10:27:03.294]                       base::local({
[10:27:03.294]                         has_future <- base::requireNamespace("future", 
[10:27:03.294]                           quietly = TRUE)
[10:27:03.294]                         if (has_future) {
[10:27:03.294]                           ns <- base::getNamespace("future")
[10:27:03.294]                           version <- ns[[".package"]][["version"]]
[10:27:03.294]                           if (is.null(version)) 
[10:27:03.294]                             version <- utils::packageVersion("future")
[10:27:03.294]                         }
[10:27:03.294]                         else {
[10:27:03.294]                           version <- NULL
[10:27:03.294]                         }
[10:27:03.294]                         if (!has_future || version < "1.8.0") {
[10:27:03.294]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:03.294]                             "", base::R.version$version.string), 
[10:27:03.294]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:03.294]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:03.294]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:03.294]                               "release", "version")], collapse = " "), 
[10:27:03.294]                             hostname = base::Sys.info()[["nodename"]])
[10:27:03.294]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:03.294]                             info)
[10:27:03.294]                           info <- base::paste(info, collapse = "; ")
[10:27:03.294]                           if (!has_future) {
[10:27:03.294]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:03.294]                               info)
[10:27:03.294]                           }
[10:27:03.294]                           else {
[10:27:03.294]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:03.294]                               info, version)
[10:27:03.294]                           }
[10:27:03.294]                           base::stop(msg)
[10:27:03.294]                         }
[10:27:03.294]                       })
[10:27:03.294]                     }
[10:27:03.294]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:03.294]                     base::options(mc.cores = 1L)
[10:27:03.294]                   }
[10:27:03.294]                   options(future.plan = NULL)
[10:27:03.294]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:03.294]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:03.294]                 }
[10:27:03.294]                 ...future.workdir <- getwd()
[10:27:03.294]             }
[10:27:03.294]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:03.294]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:03.294]         }
[10:27:03.294]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:03.294]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:03.294]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:03.294]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:03.294]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:03.294]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:03.294]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:03.294]             base::names(...future.oldOptions))
[10:27:03.294]     }
[10:27:03.294]     if (FALSE) {
[10:27:03.294]     }
[10:27:03.294]     else {
[10:27:03.294]         if (TRUE) {
[10:27:03.294]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:03.294]                 open = "w")
[10:27:03.294]         }
[10:27:03.294]         else {
[10:27:03.294]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:03.294]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:03.294]         }
[10:27:03.294]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:03.294]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:03.294]             base::sink(type = "output", split = FALSE)
[10:27:03.294]             base::close(...future.stdout)
[10:27:03.294]         }, add = TRUE)
[10:27:03.294]     }
[10:27:03.294]     ...future.frame <- base::sys.nframe()
[10:27:03.294]     ...future.conditions <- base::list()
[10:27:03.294]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:03.294]     if (FALSE) {
[10:27:03.294]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:03.294]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:03.294]     }
[10:27:03.294]     ...future.result <- base::tryCatch({
[10:27:03.294]         base::withCallingHandlers({
[10:27:03.294]             ...future.value <- base::withVisible(base::local({
[10:27:03.294]                 withCallingHandlers({
[10:27:03.294]                   2
[10:27:03.294]                 }, immediateCondition = function(cond) {
[10:27:03.294]                   save_rds <- function (object, pathname, ...) 
[10:27:03.294]                   {
[10:27:03.294]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:27:03.294]                     if (file_test("-f", pathname_tmp)) {
[10:27:03.294]                       fi_tmp <- file.info(pathname_tmp)
[10:27:03.294]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:27:03.294]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:03.294]                         fi_tmp[["mtime"]])
[10:27:03.294]                     }
[10:27:03.294]                     tryCatch({
[10:27:03.294]                       saveRDS(object, file = pathname_tmp, ...)
[10:27:03.294]                     }, error = function(ex) {
[10:27:03.294]                       msg <- conditionMessage(ex)
[10:27:03.294]                       fi_tmp <- file.info(pathname_tmp)
[10:27:03.294]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:27:03.294]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:03.294]                         fi_tmp[["mtime"]], msg)
[10:27:03.294]                       ex$message <- msg
[10:27:03.294]                       stop(ex)
[10:27:03.294]                     })
[10:27:03.294]                     stopifnot(file_test("-f", pathname_tmp))
[10:27:03.294]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:27:03.294]                     if (!res || file_test("-f", pathname_tmp)) {
[10:27:03.294]                       fi_tmp <- file.info(pathname_tmp)
[10:27:03.294]                       fi <- file.info(pathname)
[10:27:03.294]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:27:03.294]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:03.294]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:27:03.294]                         fi[["size"]], fi[["mtime"]])
[10:27:03.294]                       stop(msg)
[10:27:03.294]                     }
[10:27:03.294]                     invisible(pathname)
[10:27:03.294]                   }
[10:27:03.294]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:27:03.294]                     rootPath = tempdir()) 
[10:27:03.294]                   {
[10:27:03.294]                     obj <- list(time = Sys.time(), condition = cond)
[10:27:03.294]                     file <- tempfile(pattern = class(cond)[1], 
[10:27:03.294]                       tmpdir = path, fileext = ".rds")
[10:27:03.294]                     save_rds(obj, file)
[10:27:03.294]                   }
[10:27:03.294]                   saveImmediateCondition(cond, path = "/tmp/RtmpisxSDE/.future/immediateConditions")
[10:27:03.294]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:03.294]                   {
[10:27:03.294]                     inherits <- base::inherits
[10:27:03.294]                     invokeRestart <- base::invokeRestart
[10:27:03.294]                     is.null <- base::is.null
[10:27:03.294]                     muffled <- FALSE
[10:27:03.294]                     if (inherits(cond, "message")) {
[10:27:03.294]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:03.294]                       if (muffled) 
[10:27:03.294]                         invokeRestart("muffleMessage")
[10:27:03.294]                     }
[10:27:03.294]                     else if (inherits(cond, "warning")) {
[10:27:03.294]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:03.294]                       if (muffled) 
[10:27:03.294]                         invokeRestart("muffleWarning")
[10:27:03.294]                     }
[10:27:03.294]                     else if (inherits(cond, "condition")) {
[10:27:03.294]                       if (!is.null(pattern)) {
[10:27:03.294]                         computeRestarts <- base::computeRestarts
[10:27:03.294]                         grepl <- base::grepl
[10:27:03.294]                         restarts <- computeRestarts(cond)
[10:27:03.294]                         for (restart in restarts) {
[10:27:03.294]                           name <- restart$name
[10:27:03.294]                           if (is.null(name)) 
[10:27:03.294]                             next
[10:27:03.294]                           if (!grepl(pattern, name)) 
[10:27:03.294]                             next
[10:27:03.294]                           invokeRestart(restart)
[10:27:03.294]                           muffled <- TRUE
[10:27:03.294]                           break
[10:27:03.294]                         }
[10:27:03.294]                       }
[10:27:03.294]                     }
[10:27:03.294]                     invisible(muffled)
[10:27:03.294]                   }
[10:27:03.294]                   muffleCondition(cond)
[10:27:03.294]                 })
[10:27:03.294]             }))
[10:27:03.294]             future::FutureResult(value = ...future.value$value, 
[10:27:03.294]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:03.294]                   ...future.rng), globalenv = if (FALSE) 
[10:27:03.294]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:03.294]                     ...future.globalenv.names))
[10:27:03.294]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:03.294]         }, condition = base::local({
[10:27:03.294]             c <- base::c
[10:27:03.294]             inherits <- base::inherits
[10:27:03.294]             invokeRestart <- base::invokeRestart
[10:27:03.294]             length <- base::length
[10:27:03.294]             list <- base::list
[10:27:03.294]             seq.int <- base::seq.int
[10:27:03.294]             signalCondition <- base::signalCondition
[10:27:03.294]             sys.calls <- base::sys.calls
[10:27:03.294]             `[[` <- base::`[[`
[10:27:03.294]             `+` <- base::`+`
[10:27:03.294]             `<<-` <- base::`<<-`
[10:27:03.294]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:03.294]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:03.294]                   3L)]
[10:27:03.294]             }
[10:27:03.294]             function(cond) {
[10:27:03.294]                 is_error <- inherits(cond, "error")
[10:27:03.294]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:03.294]                   NULL)
[10:27:03.294]                 if (is_error) {
[10:27:03.294]                   sessionInformation <- function() {
[10:27:03.294]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:03.294]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:03.294]                       search = base::search(), system = base::Sys.info())
[10:27:03.294]                   }
[10:27:03.294]                   ...future.conditions[[length(...future.conditions) + 
[10:27:03.294]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:03.294]                     cond$call), session = sessionInformation(), 
[10:27:03.294]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:03.294]                   signalCondition(cond)
[10:27:03.294]                 }
[10:27:03.294]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:03.294]                 "immediateCondition"))) {
[10:27:03.294]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:03.294]                   ...future.conditions[[length(...future.conditions) + 
[10:27:03.294]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:03.294]                   if (TRUE && !signal) {
[10:27:03.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:03.294]                     {
[10:27:03.294]                       inherits <- base::inherits
[10:27:03.294]                       invokeRestart <- base::invokeRestart
[10:27:03.294]                       is.null <- base::is.null
[10:27:03.294]                       muffled <- FALSE
[10:27:03.294]                       if (inherits(cond, "message")) {
[10:27:03.294]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:03.294]                         if (muffled) 
[10:27:03.294]                           invokeRestart("muffleMessage")
[10:27:03.294]                       }
[10:27:03.294]                       else if (inherits(cond, "warning")) {
[10:27:03.294]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:03.294]                         if (muffled) 
[10:27:03.294]                           invokeRestart("muffleWarning")
[10:27:03.294]                       }
[10:27:03.294]                       else if (inherits(cond, "condition")) {
[10:27:03.294]                         if (!is.null(pattern)) {
[10:27:03.294]                           computeRestarts <- base::computeRestarts
[10:27:03.294]                           grepl <- base::grepl
[10:27:03.294]                           restarts <- computeRestarts(cond)
[10:27:03.294]                           for (restart in restarts) {
[10:27:03.294]                             name <- restart$name
[10:27:03.294]                             if (is.null(name)) 
[10:27:03.294]                               next
[10:27:03.294]                             if (!grepl(pattern, name)) 
[10:27:03.294]                               next
[10:27:03.294]                             invokeRestart(restart)
[10:27:03.294]                             muffled <- TRUE
[10:27:03.294]                             break
[10:27:03.294]                           }
[10:27:03.294]                         }
[10:27:03.294]                       }
[10:27:03.294]                       invisible(muffled)
[10:27:03.294]                     }
[10:27:03.294]                     muffleCondition(cond, pattern = "^muffle")
[10:27:03.294]                   }
[10:27:03.294]                 }
[10:27:03.294]                 else {
[10:27:03.294]                   if (TRUE) {
[10:27:03.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:03.294]                     {
[10:27:03.294]                       inherits <- base::inherits
[10:27:03.294]                       invokeRestart <- base::invokeRestart
[10:27:03.294]                       is.null <- base::is.null
[10:27:03.294]                       muffled <- FALSE
[10:27:03.294]                       if (inherits(cond, "message")) {
[10:27:03.294]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:03.294]                         if (muffled) 
[10:27:03.294]                           invokeRestart("muffleMessage")
[10:27:03.294]                       }
[10:27:03.294]                       else if (inherits(cond, "warning")) {
[10:27:03.294]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:03.294]                         if (muffled) 
[10:27:03.294]                           invokeRestart("muffleWarning")
[10:27:03.294]                       }
[10:27:03.294]                       else if (inherits(cond, "condition")) {
[10:27:03.294]                         if (!is.null(pattern)) {
[10:27:03.294]                           computeRestarts <- base::computeRestarts
[10:27:03.294]                           grepl <- base::grepl
[10:27:03.294]                           restarts <- computeRestarts(cond)
[10:27:03.294]                           for (restart in restarts) {
[10:27:03.294]                             name <- restart$name
[10:27:03.294]                             if (is.null(name)) 
[10:27:03.294]                               next
[10:27:03.294]                             if (!grepl(pattern, name)) 
[10:27:03.294]                               next
[10:27:03.294]                             invokeRestart(restart)
[10:27:03.294]                             muffled <- TRUE
[10:27:03.294]                             break
[10:27:03.294]                           }
[10:27:03.294]                         }
[10:27:03.294]                       }
[10:27:03.294]                       invisible(muffled)
[10:27:03.294]                     }
[10:27:03.294]                     muffleCondition(cond, pattern = "^muffle")
[10:27:03.294]                   }
[10:27:03.294]                 }
[10:27:03.294]             }
[10:27:03.294]         }))
[10:27:03.294]     }, error = function(ex) {
[10:27:03.294]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:03.294]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:03.294]                 ...future.rng), started = ...future.startTime, 
[10:27:03.294]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:03.294]             version = "1.8"), class = "FutureResult")
[10:27:03.294]     }, finally = {
[10:27:03.294]         if (!identical(...future.workdir, getwd())) 
[10:27:03.294]             setwd(...future.workdir)
[10:27:03.294]         {
[10:27:03.294]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:03.294]                 ...future.oldOptions$nwarnings <- NULL
[10:27:03.294]             }
[10:27:03.294]             base::options(...future.oldOptions)
[10:27:03.294]             if (.Platform$OS.type == "windows") {
[10:27:03.294]                 old_names <- names(...future.oldEnvVars)
[10:27:03.294]                 envs <- base::Sys.getenv()
[10:27:03.294]                 names <- names(envs)
[10:27:03.294]                 common <- intersect(names, old_names)
[10:27:03.294]                 added <- setdiff(names, old_names)
[10:27:03.294]                 removed <- setdiff(old_names, names)
[10:27:03.294]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:03.294]                   envs[common]]
[10:27:03.294]                 NAMES <- toupper(changed)
[10:27:03.294]                 args <- list()
[10:27:03.294]                 for (kk in seq_along(NAMES)) {
[10:27:03.294]                   name <- changed[[kk]]
[10:27:03.294]                   NAME <- NAMES[[kk]]
[10:27:03.294]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:03.294]                     next
[10:27:03.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:03.294]                 }
[10:27:03.294]                 NAMES <- toupper(added)
[10:27:03.294]                 for (kk in seq_along(NAMES)) {
[10:27:03.294]                   name <- added[[kk]]
[10:27:03.294]                   NAME <- NAMES[[kk]]
[10:27:03.294]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:03.294]                     next
[10:27:03.294]                   args[[name]] <- ""
[10:27:03.294]                 }
[10:27:03.294]                 NAMES <- toupper(removed)
[10:27:03.294]                 for (kk in seq_along(NAMES)) {
[10:27:03.294]                   name <- removed[[kk]]
[10:27:03.294]                   NAME <- NAMES[[kk]]
[10:27:03.294]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:03.294]                     next
[10:27:03.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:03.294]                 }
[10:27:03.294]                 if (length(args) > 0) 
[10:27:03.294]                   base::do.call(base::Sys.setenv, args = args)
[10:27:03.294]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:03.294]             }
[10:27:03.294]             else {
[10:27:03.294]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:03.294]             }
[10:27:03.294]             {
[10:27:03.294]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:03.294]                   0L) {
[10:27:03.294]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:03.294]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:03.294]                   base::options(opts)
[10:27:03.294]                 }
[10:27:03.294]                 {
[10:27:03.294]                   {
[10:27:03.294]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:03.294]                     NULL
[10:27:03.294]                   }
[10:27:03.294]                   options(future.plan = NULL)
[10:27:03.294]                   if (is.na(NA_character_)) 
[10:27:03.294]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:03.294]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:03.294]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:27:03.294]                     envir = parent.frame()) 
[10:27:03.294]                   {
[10:27:03.294]                     default_workers <- missing(workers)
[10:27:03.294]                     if (is.function(workers)) 
[10:27:03.294]                       workers <- workers()
[10:27:03.294]                     workers <- structure(as.integer(workers), 
[10:27:03.294]                       class = class(workers))
[10:27:03.294]                     stop_if_not(is.finite(workers), workers >= 
[10:27:03.294]                       1L)
[10:27:03.294]                     if ((workers == 1L && !inherits(workers, 
[10:27:03.294]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:27:03.294]                       if (default_workers) 
[10:27:03.294]                         supportsMulticore(warn = TRUE)
[10:27:03.294]                       return(sequential(..., envir = envir))
[10:27:03.294]                     }
[10:27:03.294]                     oopts <- options(mc.cores = workers)
[10:27:03.294]                     on.exit(options(oopts))
[10:27:03.294]                     future <- MulticoreFuture(..., workers = workers, 
[10:27:03.294]                       envir = envir)
[10:27:03.294]                     if (!future$lazy) 
[10:27:03.294]                       future <- run(future)
[10:27:03.294]                     invisible(future)
[10:27:03.294]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:03.294]                 }
[10:27:03.294]             }
[10:27:03.294]         }
[10:27:03.294]     })
[10:27:03.294]     if (TRUE) {
[10:27:03.294]         base::sink(type = "output", split = FALSE)
[10:27:03.294]         if (TRUE) {
[10:27:03.294]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:03.294]         }
[10:27:03.294]         else {
[10:27:03.294]             ...future.result["stdout"] <- base::list(NULL)
[10:27:03.294]         }
[10:27:03.294]         base::close(...future.stdout)
[10:27:03.294]         ...future.stdout <- NULL
[10:27:03.294]     }
[10:27:03.294]     ...future.result$conditions <- ...future.conditions
[10:27:03.294]     ...future.result$finished <- base::Sys.time()
[10:27:03.294]     ...future.result
[10:27:03.294] }
[10:27:03.298] requestCore(): workers = 2
[10:27:03.300] MulticoreFuture started
[10:27:03.301] - Launch lazy future ... done
[10:27:03.301] run() for ‘MulticoreFuture’ ... done
[10:27:03.302] plan(): Setting new future strategy stack:
[10:27:03.302] resolve() on list environment ...
[10:27:03.303]  recursive: 0
[10:27:03.304]  length: 3
[10:27:03.304]  elements: ‘a’, ‘b’, ‘c’
[10:27:03.304] Future #1
[10:27:03.305]  length: 2 (resolved future 1)
[10:27:03.302] List of future strategies:
[10:27:03.302] 1. sequential:
[10:27:03.302]    - args: function (..., envir = parent.frame())
[10:27:03.302]    - tweaked: FALSE
[10:27:03.302]    - call: NULL
[10:27:03.305] plan(): nbrOfWorkers() = 1
[10:27:03.307] plan(): Setting new future strategy stack:
[10:27:03.308] List of future strategies:
[10:27:03.308] 1. multicore:
[10:27:03.308]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:27:03.308]    - tweaked: FALSE
[10:27:03.308]    - call: plan(strategy)
[10:27:03.315]  length: 1 (resolved future 3)
[10:27:03.316] plan(): nbrOfWorkers() = 2
[10:27:03.326] Future #2
[10:27:03.326]  length: 0 (resolved future 2)
[10:27:03.327] resolve() on list environment ... DONE
[10:27:03.334] getGlobalsAndPackages() ...
[10:27:03.335] Searching for globals...
[10:27:03.337] - globals found: [1] ‘{’
[10:27:03.338] Searching for globals ... DONE
[10:27:03.338] Resolving globals: FALSE
[10:27:03.338] 
[10:27:03.339] 
[10:27:03.339] getGlobalsAndPackages() ... DONE
[10:27:03.339] run() for ‘Future’ ...
[10:27:03.340] - state: ‘created’
[10:27:03.340] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:27:03.345] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:03.345] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:27:03.346]   - Field: ‘label’
[10:27:03.346]   - Field: ‘local’
[10:27:03.346]   - Field: ‘owner’
[10:27:03.346]   - Field: ‘envir’
[10:27:03.347]   - Field: ‘workers’
[10:27:03.347]   - Field: ‘packages’
[10:27:03.347]   - Field: ‘gc’
[10:27:03.347]   - Field: ‘job’
[10:27:03.347]   - Field: ‘conditions’
[10:27:03.348]   - Field: ‘expr’
[10:27:03.348]   - Field: ‘uuid’
[10:27:03.348]   - Field: ‘seed’
[10:27:03.348]   - Field: ‘version’
[10:27:03.348]   - Field: ‘result’
[10:27:03.348]   - Field: ‘asynchronous’
[10:27:03.348]   - Field: ‘calls’
[10:27:03.349]   - Field: ‘globals’
[10:27:03.349]   - Field: ‘stdout’
[10:27:03.349]   - Field: ‘earlySignal’
[10:27:03.349]   - Field: ‘lazy’
[10:27:03.349]   - Field: ‘state’
[10:27:03.349] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:27:03.349] - Launch lazy future ...
[10:27:03.350] Packages needed by the future expression (n = 0): <none>
[10:27:03.350] Packages needed by future strategies (n = 0): <none>
[10:27:03.351] {
[10:27:03.351]     {
[10:27:03.351]         {
[10:27:03.351]             ...future.startTime <- base::Sys.time()
[10:27:03.351]             {
[10:27:03.351]                 {
[10:27:03.351]                   {
[10:27:03.351]                     {
[10:27:03.351]                       base::local({
[10:27:03.351]                         has_future <- base::requireNamespace("future", 
[10:27:03.351]                           quietly = TRUE)
[10:27:03.351]                         if (has_future) {
[10:27:03.351]                           ns <- base::getNamespace("future")
[10:27:03.351]                           version <- ns[[".package"]][["version"]]
[10:27:03.351]                           if (is.null(version)) 
[10:27:03.351]                             version <- utils::packageVersion("future")
[10:27:03.351]                         }
[10:27:03.351]                         else {
[10:27:03.351]                           version <- NULL
[10:27:03.351]                         }
[10:27:03.351]                         if (!has_future || version < "1.8.0") {
[10:27:03.351]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:03.351]                             "", base::R.version$version.string), 
[10:27:03.351]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:03.351]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:03.351]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:03.351]                               "release", "version")], collapse = " "), 
[10:27:03.351]                             hostname = base::Sys.info()[["nodename"]])
[10:27:03.351]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:03.351]                             info)
[10:27:03.351]                           info <- base::paste(info, collapse = "; ")
[10:27:03.351]                           if (!has_future) {
[10:27:03.351]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:03.351]                               info)
[10:27:03.351]                           }
[10:27:03.351]                           else {
[10:27:03.351]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:03.351]                               info, version)
[10:27:03.351]                           }
[10:27:03.351]                           base::stop(msg)
[10:27:03.351]                         }
[10:27:03.351]                       })
[10:27:03.351]                     }
[10:27:03.351]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:03.351]                     base::options(mc.cores = 1L)
[10:27:03.351]                   }
[10:27:03.351]                   options(future.plan = NULL)
[10:27:03.351]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:03.351]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:03.351]                 }
[10:27:03.351]                 ...future.workdir <- getwd()
[10:27:03.351]             }
[10:27:03.351]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:03.351]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:03.351]         }
[10:27:03.351]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:03.351]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:03.351]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:03.351]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:03.351]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:03.351]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:03.351]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:03.351]             base::names(...future.oldOptions))
[10:27:03.351]     }
[10:27:03.351]     if (FALSE) {
[10:27:03.351]     }
[10:27:03.351]     else {
[10:27:03.351]         if (TRUE) {
[10:27:03.351]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:03.351]                 open = "w")
[10:27:03.351]         }
[10:27:03.351]         else {
[10:27:03.351]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:03.351]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:03.351]         }
[10:27:03.351]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:03.351]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:03.351]             base::sink(type = "output", split = FALSE)
[10:27:03.351]             base::close(...future.stdout)
[10:27:03.351]         }, add = TRUE)
[10:27:03.351]     }
[10:27:03.351]     ...future.frame <- base::sys.nframe()
[10:27:03.351]     ...future.conditions <- base::list()
[10:27:03.351]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:03.351]     if (FALSE) {
[10:27:03.351]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:03.351]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:03.351]     }
[10:27:03.351]     ...future.result <- base::tryCatch({
[10:27:03.351]         base::withCallingHandlers({
[10:27:03.351]             ...future.value <- base::withVisible(base::local({
[10:27:03.351]                 withCallingHandlers({
[10:27:03.351]                   {
[10:27:03.351]                     1
[10:27:03.351]                   }
[10:27:03.351]                 }, immediateCondition = function(cond) {
[10:27:03.351]                   save_rds <- function (object, pathname, ...) 
[10:27:03.351]                   {
[10:27:03.351]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:27:03.351]                     if (file_test("-f", pathname_tmp)) {
[10:27:03.351]                       fi_tmp <- file.info(pathname_tmp)
[10:27:03.351]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:27:03.351]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:03.351]                         fi_tmp[["mtime"]])
[10:27:03.351]                     }
[10:27:03.351]                     tryCatch({
[10:27:03.351]                       saveRDS(object, file = pathname_tmp, ...)
[10:27:03.351]                     }, error = function(ex) {
[10:27:03.351]                       msg <- conditionMessage(ex)
[10:27:03.351]                       fi_tmp <- file.info(pathname_tmp)
[10:27:03.351]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:27:03.351]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:03.351]                         fi_tmp[["mtime"]], msg)
[10:27:03.351]                       ex$message <- msg
[10:27:03.351]                       stop(ex)
[10:27:03.351]                     })
[10:27:03.351]                     stopifnot(file_test("-f", pathname_tmp))
[10:27:03.351]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:27:03.351]                     if (!res || file_test("-f", pathname_tmp)) {
[10:27:03.351]                       fi_tmp <- file.info(pathname_tmp)
[10:27:03.351]                       fi <- file.info(pathname)
[10:27:03.351]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:27:03.351]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:03.351]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:27:03.351]                         fi[["size"]], fi[["mtime"]])
[10:27:03.351]                       stop(msg)
[10:27:03.351]                     }
[10:27:03.351]                     invisible(pathname)
[10:27:03.351]                   }
[10:27:03.351]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:27:03.351]                     rootPath = tempdir()) 
[10:27:03.351]                   {
[10:27:03.351]                     obj <- list(time = Sys.time(), condition = cond)
[10:27:03.351]                     file <- tempfile(pattern = class(cond)[1], 
[10:27:03.351]                       tmpdir = path, fileext = ".rds")
[10:27:03.351]                     save_rds(obj, file)
[10:27:03.351]                   }
[10:27:03.351]                   saveImmediateCondition(cond, path = "/tmp/RtmpisxSDE/.future/immediateConditions")
[10:27:03.351]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:03.351]                   {
[10:27:03.351]                     inherits <- base::inherits
[10:27:03.351]                     invokeRestart <- base::invokeRestart
[10:27:03.351]                     is.null <- base::is.null
[10:27:03.351]                     muffled <- FALSE
[10:27:03.351]                     if (inherits(cond, "message")) {
[10:27:03.351]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:03.351]                       if (muffled) 
[10:27:03.351]                         invokeRestart("muffleMessage")
[10:27:03.351]                     }
[10:27:03.351]                     else if (inherits(cond, "warning")) {
[10:27:03.351]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:03.351]                       if (muffled) 
[10:27:03.351]                         invokeRestart("muffleWarning")
[10:27:03.351]                     }
[10:27:03.351]                     else if (inherits(cond, "condition")) {
[10:27:03.351]                       if (!is.null(pattern)) {
[10:27:03.351]                         computeRestarts <- base::computeRestarts
[10:27:03.351]                         grepl <- base::grepl
[10:27:03.351]                         restarts <- computeRestarts(cond)
[10:27:03.351]                         for (restart in restarts) {
[10:27:03.351]                           name <- restart$name
[10:27:03.351]                           if (is.null(name)) 
[10:27:03.351]                             next
[10:27:03.351]                           if (!grepl(pattern, name)) 
[10:27:03.351]                             next
[10:27:03.351]                           invokeRestart(restart)
[10:27:03.351]                           muffled <- TRUE
[10:27:03.351]                           break
[10:27:03.351]                         }
[10:27:03.351]                       }
[10:27:03.351]                     }
[10:27:03.351]                     invisible(muffled)
[10:27:03.351]                   }
[10:27:03.351]                   muffleCondition(cond)
[10:27:03.351]                 })
[10:27:03.351]             }))
[10:27:03.351]             future::FutureResult(value = ...future.value$value, 
[10:27:03.351]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:03.351]                   ...future.rng), globalenv = if (FALSE) 
[10:27:03.351]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:03.351]                     ...future.globalenv.names))
[10:27:03.351]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:03.351]         }, condition = base::local({
[10:27:03.351]             c <- base::c
[10:27:03.351]             inherits <- base::inherits
[10:27:03.351]             invokeRestart <- base::invokeRestart
[10:27:03.351]             length <- base::length
[10:27:03.351]             list <- base::list
[10:27:03.351]             seq.int <- base::seq.int
[10:27:03.351]             signalCondition <- base::signalCondition
[10:27:03.351]             sys.calls <- base::sys.calls
[10:27:03.351]             `[[` <- base::`[[`
[10:27:03.351]             `+` <- base::`+`
[10:27:03.351]             `<<-` <- base::`<<-`
[10:27:03.351]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:03.351]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:03.351]                   3L)]
[10:27:03.351]             }
[10:27:03.351]             function(cond) {
[10:27:03.351]                 is_error <- inherits(cond, "error")
[10:27:03.351]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:03.351]                   NULL)
[10:27:03.351]                 if (is_error) {
[10:27:03.351]                   sessionInformation <- function() {
[10:27:03.351]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:03.351]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:03.351]                       search = base::search(), system = base::Sys.info())
[10:27:03.351]                   }
[10:27:03.351]                   ...future.conditions[[length(...future.conditions) + 
[10:27:03.351]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:03.351]                     cond$call), session = sessionInformation(), 
[10:27:03.351]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:03.351]                   signalCondition(cond)
[10:27:03.351]                 }
[10:27:03.351]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:03.351]                 "immediateCondition"))) {
[10:27:03.351]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:03.351]                   ...future.conditions[[length(...future.conditions) + 
[10:27:03.351]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:03.351]                   if (TRUE && !signal) {
[10:27:03.351]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:03.351]                     {
[10:27:03.351]                       inherits <- base::inherits
[10:27:03.351]                       invokeRestart <- base::invokeRestart
[10:27:03.351]                       is.null <- base::is.null
[10:27:03.351]                       muffled <- FALSE
[10:27:03.351]                       if (inherits(cond, "message")) {
[10:27:03.351]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:03.351]                         if (muffled) 
[10:27:03.351]                           invokeRestart("muffleMessage")
[10:27:03.351]                       }
[10:27:03.351]                       else if (inherits(cond, "warning")) {
[10:27:03.351]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:03.351]                         if (muffled) 
[10:27:03.351]                           invokeRestart("muffleWarning")
[10:27:03.351]                       }
[10:27:03.351]                       else if (inherits(cond, "condition")) {
[10:27:03.351]                         if (!is.null(pattern)) {
[10:27:03.351]                           computeRestarts <- base::computeRestarts
[10:27:03.351]                           grepl <- base::grepl
[10:27:03.351]                           restarts <- computeRestarts(cond)
[10:27:03.351]                           for (restart in restarts) {
[10:27:03.351]                             name <- restart$name
[10:27:03.351]                             if (is.null(name)) 
[10:27:03.351]                               next
[10:27:03.351]                             if (!grepl(pattern, name)) 
[10:27:03.351]                               next
[10:27:03.351]                             invokeRestart(restart)
[10:27:03.351]                             muffled <- TRUE
[10:27:03.351]                             break
[10:27:03.351]                           }
[10:27:03.351]                         }
[10:27:03.351]                       }
[10:27:03.351]                       invisible(muffled)
[10:27:03.351]                     }
[10:27:03.351]                     muffleCondition(cond, pattern = "^muffle")
[10:27:03.351]                   }
[10:27:03.351]                 }
[10:27:03.351]                 else {
[10:27:03.351]                   if (TRUE) {
[10:27:03.351]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:03.351]                     {
[10:27:03.351]                       inherits <- base::inherits
[10:27:03.351]                       invokeRestart <- base::invokeRestart
[10:27:03.351]                       is.null <- base::is.null
[10:27:03.351]                       muffled <- FALSE
[10:27:03.351]                       if (inherits(cond, "message")) {
[10:27:03.351]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:03.351]                         if (muffled) 
[10:27:03.351]                           invokeRestart("muffleMessage")
[10:27:03.351]                       }
[10:27:03.351]                       else if (inherits(cond, "warning")) {
[10:27:03.351]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:03.351]                         if (muffled) 
[10:27:03.351]                           invokeRestart("muffleWarning")
[10:27:03.351]                       }
[10:27:03.351]                       else if (inherits(cond, "condition")) {
[10:27:03.351]                         if (!is.null(pattern)) {
[10:27:03.351]                           computeRestarts <- base::computeRestarts
[10:27:03.351]                           grepl <- base::grepl
[10:27:03.351]                           restarts <- computeRestarts(cond)
[10:27:03.351]                           for (restart in restarts) {
[10:27:03.351]                             name <- restart$name
[10:27:03.351]                             if (is.null(name)) 
[10:27:03.351]                               next
[10:27:03.351]                             if (!grepl(pattern, name)) 
[10:27:03.351]                               next
[10:27:03.351]                             invokeRestart(restart)
[10:27:03.351]                             muffled <- TRUE
[10:27:03.351]                             break
[10:27:03.351]                           }
[10:27:03.351]                         }
[10:27:03.351]                       }
[10:27:03.351]                       invisible(muffled)
[10:27:03.351]                     }
[10:27:03.351]                     muffleCondition(cond, pattern = "^muffle")
[10:27:03.351]                   }
[10:27:03.351]                 }
[10:27:03.351]             }
[10:27:03.351]         }))
[10:27:03.351]     }, error = function(ex) {
[10:27:03.351]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:03.351]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:03.351]                 ...future.rng), started = ...future.startTime, 
[10:27:03.351]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:03.351]             version = "1.8"), class = "FutureResult")
[10:27:03.351]     }, finally = {
[10:27:03.351]         if (!identical(...future.workdir, getwd())) 
[10:27:03.351]             setwd(...future.workdir)
[10:27:03.351]         {
[10:27:03.351]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:03.351]                 ...future.oldOptions$nwarnings <- NULL
[10:27:03.351]             }
[10:27:03.351]             base::options(...future.oldOptions)
[10:27:03.351]             if (.Platform$OS.type == "windows") {
[10:27:03.351]                 old_names <- names(...future.oldEnvVars)
[10:27:03.351]                 envs <- base::Sys.getenv()
[10:27:03.351]                 names <- names(envs)
[10:27:03.351]                 common <- intersect(names, old_names)
[10:27:03.351]                 added <- setdiff(names, old_names)
[10:27:03.351]                 removed <- setdiff(old_names, names)
[10:27:03.351]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:03.351]                   envs[common]]
[10:27:03.351]                 NAMES <- toupper(changed)
[10:27:03.351]                 args <- list()
[10:27:03.351]                 for (kk in seq_along(NAMES)) {
[10:27:03.351]                   name <- changed[[kk]]
[10:27:03.351]                   NAME <- NAMES[[kk]]
[10:27:03.351]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:03.351]                     next
[10:27:03.351]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:03.351]                 }
[10:27:03.351]                 NAMES <- toupper(added)
[10:27:03.351]                 for (kk in seq_along(NAMES)) {
[10:27:03.351]                   name <- added[[kk]]
[10:27:03.351]                   NAME <- NAMES[[kk]]
[10:27:03.351]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:03.351]                     next
[10:27:03.351]                   args[[name]] <- ""
[10:27:03.351]                 }
[10:27:03.351]                 NAMES <- toupper(removed)
[10:27:03.351]                 for (kk in seq_along(NAMES)) {
[10:27:03.351]                   name <- removed[[kk]]
[10:27:03.351]                   NAME <- NAMES[[kk]]
[10:27:03.351]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:03.351]                     next
[10:27:03.351]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:03.351]                 }
[10:27:03.351]                 if (length(args) > 0) 
[10:27:03.351]                   base::do.call(base::Sys.setenv, args = args)
[10:27:03.351]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:03.351]             }
[10:27:03.351]             else {
[10:27:03.351]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:03.351]             }
[10:27:03.351]             {
[10:27:03.351]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:03.351]                   0L) {
[10:27:03.351]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:03.351]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:03.351]                   base::options(opts)
[10:27:03.351]                 }
[10:27:03.351]                 {
[10:27:03.351]                   {
[10:27:03.351]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:03.351]                     NULL
[10:27:03.351]                   }
[10:27:03.351]                   options(future.plan = NULL)
[10:27:03.351]                   if (is.na(NA_character_)) 
[10:27:03.351]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:03.351]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:03.351]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:27:03.351]                     envir = parent.frame()) 
[10:27:03.351]                   {
[10:27:03.351]                     default_workers <- missing(workers)
[10:27:03.351]                     if (is.function(workers)) 
[10:27:03.351]                       workers <- workers()
[10:27:03.351]                     workers <- structure(as.integer(workers), 
[10:27:03.351]                       class = class(workers))
[10:27:03.351]                     stop_if_not(is.finite(workers), workers >= 
[10:27:03.351]                       1L)
[10:27:03.351]                     if ((workers == 1L && !inherits(workers, 
[10:27:03.351]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:27:03.351]                       if (default_workers) 
[10:27:03.351]                         supportsMulticore(warn = TRUE)
[10:27:03.351]                       return(sequential(..., envir = envir))
[10:27:03.351]                     }
[10:27:03.351]                     oopts <- options(mc.cores = workers)
[10:27:03.351]                     on.exit(options(oopts))
[10:27:03.351]                     future <- MulticoreFuture(..., workers = workers, 
[10:27:03.351]                       envir = envir)
[10:27:03.351]                     if (!future$lazy) 
[10:27:03.351]                       future <- run(future)
[10:27:03.351]                     invisible(future)
[10:27:03.351]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:03.351]                 }
[10:27:03.351]             }
[10:27:03.351]         }
[10:27:03.351]     })
[10:27:03.351]     if (TRUE) {
[10:27:03.351]         base::sink(type = "output", split = FALSE)
[10:27:03.351]         if (TRUE) {
[10:27:03.351]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:03.351]         }
[10:27:03.351]         else {
[10:27:03.351]             ...future.result["stdout"] <- base::list(NULL)
[10:27:03.351]         }
[10:27:03.351]         base::close(...future.stdout)
[10:27:03.351]         ...future.stdout <- NULL
[10:27:03.351]     }
[10:27:03.351]     ...future.result$conditions <- ...future.conditions
[10:27:03.351]     ...future.result$finished <- base::Sys.time()
[10:27:03.351]     ...future.result
[10:27:03.351] }
[10:27:03.354] requestCore(): workers = 2
[10:27:03.354] Poll #1 (0): usedCores() = 2, workers = 2
[10:27:03.365] result() for MulticoreFuture ...
[10:27:03.366] result() for MulticoreFuture ...
[10:27:03.366] result() for MulticoreFuture ... done
[10:27:03.366] result() for MulticoreFuture ... done
[10:27:03.367] result() for MulticoreFuture ...
[10:27:03.367] result() for MulticoreFuture ... done
[10:27:03.370] MulticoreFuture started
[10:27:03.371] - Launch lazy future ... done
[10:27:03.371] run() for ‘MulticoreFuture’ ... done
[10:27:03.371] plan(): Setting new future strategy stack:
[10:27:03.372] getGlobalsAndPackages() ...
[10:27:03.372] List of future strategies:
[10:27:03.372] 1. sequential:
[10:27:03.372]    - args: function (..., envir = parent.frame())
[10:27:03.372]    - tweaked: FALSE
[10:27:03.372]    - call: NULL
[10:27:03.373] Searching for globals...
[10:27:03.373] plan(): nbrOfWorkers() = 1
[10:27:03.374] - globals found: [1] ‘{’
[10:27:03.374] Searching for globals ... DONE
[10:27:03.374] Resolving globals: FALSE
[10:27:03.375] 
[10:27:03.375] 
[10:27:03.376] getGlobalsAndPackages() ... DONE
[10:27:03.376] run() for ‘Future’ ...
[10:27:03.376] - state: ‘created’
[10:27:03.377] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:27:03.378] plan(): Setting new future strategy stack:
[10:27:03.378] List of future strategies:
[10:27:03.378] 1. multicore:
[10:27:03.378]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:27:03.378]    - tweaked: FALSE
[10:27:03.378]    - call: plan(strategy)
[10:27:03.382] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:03.382] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:27:03.382]   - Field: ‘label’
[10:27:03.383]   - Field: ‘local’
[10:27:03.383]   - Field: ‘owner’
[10:27:03.383]   - Field: ‘envir’
[10:27:03.383] plan(): nbrOfWorkers() = 2
[10:27:03.383]   - Field: ‘workers’
[10:27:03.383]   - Field: ‘packages’
[10:27:03.383]   - Field: ‘gc’
[10:27:03.384]   - Field: ‘job’
[10:27:03.384]   - Field: ‘conditions’
[10:27:03.384]   - Field: ‘expr’
[10:27:03.384]   - Field: ‘uuid’
[10:27:03.384]   - Field: ‘seed’
[10:27:03.384]   - Field: ‘version’
[10:27:03.384]   - Field: ‘result’
[10:27:03.385]   - Field: ‘asynchronous’
[10:27:03.385]   - Field: ‘calls’
[10:27:03.385]   - Field: ‘globals’
[10:27:03.385]   - Field: ‘stdout’
[10:27:03.385]   - Field: ‘earlySignal’
[10:27:03.385]   - Field: ‘lazy’
[10:27:03.385]   - Field: ‘state’
[10:27:03.386] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:27:03.386] - Launch lazy future ...
[10:27:03.386] Packages needed by the future expression (n = 0): <none>
[10:27:03.386] Packages needed by future strategies (n = 0): <none>
[10:27:03.387] {
[10:27:03.387]     {
[10:27:03.387]         {
[10:27:03.387]             ...future.startTime <- base::Sys.time()
[10:27:03.387]             {
[10:27:03.387]                 {
[10:27:03.387]                   {
[10:27:03.387]                     {
[10:27:03.387]                       base::local({
[10:27:03.387]                         has_future <- base::requireNamespace("future", 
[10:27:03.387]                           quietly = TRUE)
[10:27:03.387]                         if (has_future) {
[10:27:03.387]                           ns <- base::getNamespace("future")
[10:27:03.387]                           version <- ns[[".package"]][["version"]]
[10:27:03.387]                           if (is.null(version)) 
[10:27:03.387]                             version <- utils::packageVersion("future")
[10:27:03.387]                         }
[10:27:03.387]                         else {
[10:27:03.387]                           version <- NULL
[10:27:03.387]                         }
[10:27:03.387]                         if (!has_future || version < "1.8.0") {
[10:27:03.387]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:03.387]                             "", base::R.version$version.string), 
[10:27:03.387]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:03.387]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:03.387]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:03.387]                               "release", "version")], collapse = " "), 
[10:27:03.387]                             hostname = base::Sys.info()[["nodename"]])
[10:27:03.387]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:03.387]                             info)
[10:27:03.387]                           info <- base::paste(info, collapse = "; ")
[10:27:03.387]                           if (!has_future) {
[10:27:03.387]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:03.387]                               info)
[10:27:03.387]                           }
[10:27:03.387]                           else {
[10:27:03.387]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:03.387]                               info, version)
[10:27:03.387]                           }
[10:27:03.387]                           base::stop(msg)
[10:27:03.387]                         }
[10:27:03.387]                       })
[10:27:03.387]                     }
[10:27:03.387]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:03.387]                     base::options(mc.cores = 1L)
[10:27:03.387]                   }
[10:27:03.387]                   options(future.plan = NULL)
[10:27:03.387]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:03.387]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:03.387]                 }
[10:27:03.387]                 ...future.workdir <- getwd()
[10:27:03.387]             }
[10:27:03.387]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:03.387]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:03.387]         }
[10:27:03.387]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:03.387]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:03.387]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:03.387]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:03.387]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:03.387]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:03.387]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:03.387]             base::names(...future.oldOptions))
[10:27:03.387]     }
[10:27:03.387]     if (FALSE) {
[10:27:03.387]     }
[10:27:03.387]     else {
[10:27:03.387]         if (TRUE) {
[10:27:03.387]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:03.387]                 open = "w")
[10:27:03.387]         }
[10:27:03.387]         else {
[10:27:03.387]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:03.387]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:03.387]         }
[10:27:03.387]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:03.387]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:03.387]             base::sink(type = "output", split = FALSE)
[10:27:03.387]             base::close(...future.stdout)
[10:27:03.387]         }, add = TRUE)
[10:27:03.387]     }
[10:27:03.387]     ...future.frame <- base::sys.nframe()
[10:27:03.387]     ...future.conditions <- base::list()
[10:27:03.387]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:03.387]     if (FALSE) {
[10:27:03.387]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:03.387]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:03.387]     }
[10:27:03.387]     ...future.result <- base::tryCatch({
[10:27:03.387]         base::withCallingHandlers({
[10:27:03.387]             ...future.value <- base::withVisible(base::local({
[10:27:03.387]                 withCallingHandlers({
[10:27:03.387]                   {
[10:27:03.387]                     2
[10:27:03.387]                   }
[10:27:03.387]                 }, immediateCondition = function(cond) {
[10:27:03.387]                   save_rds <- function (object, pathname, ...) 
[10:27:03.387]                   {
[10:27:03.387]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:27:03.387]                     if (file_test("-f", pathname_tmp)) {
[10:27:03.387]                       fi_tmp <- file.info(pathname_tmp)
[10:27:03.387]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:27:03.387]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:03.387]                         fi_tmp[["mtime"]])
[10:27:03.387]                     }
[10:27:03.387]                     tryCatch({
[10:27:03.387]                       saveRDS(object, file = pathname_tmp, ...)
[10:27:03.387]                     }, error = function(ex) {
[10:27:03.387]                       msg <- conditionMessage(ex)
[10:27:03.387]                       fi_tmp <- file.info(pathname_tmp)
[10:27:03.387]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:27:03.387]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:03.387]                         fi_tmp[["mtime"]], msg)
[10:27:03.387]                       ex$message <- msg
[10:27:03.387]                       stop(ex)
[10:27:03.387]                     })
[10:27:03.387]                     stopifnot(file_test("-f", pathname_tmp))
[10:27:03.387]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:27:03.387]                     if (!res || file_test("-f", pathname_tmp)) {
[10:27:03.387]                       fi_tmp <- file.info(pathname_tmp)
[10:27:03.387]                       fi <- file.info(pathname)
[10:27:03.387]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:27:03.387]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:03.387]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:27:03.387]                         fi[["size"]], fi[["mtime"]])
[10:27:03.387]                       stop(msg)
[10:27:03.387]                     }
[10:27:03.387]                     invisible(pathname)
[10:27:03.387]                   }
[10:27:03.387]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:27:03.387]                     rootPath = tempdir()) 
[10:27:03.387]                   {
[10:27:03.387]                     obj <- list(time = Sys.time(), condition = cond)
[10:27:03.387]                     file <- tempfile(pattern = class(cond)[1], 
[10:27:03.387]                       tmpdir = path, fileext = ".rds")
[10:27:03.387]                     save_rds(obj, file)
[10:27:03.387]                   }
[10:27:03.387]                   saveImmediateCondition(cond, path = "/tmp/RtmpisxSDE/.future/immediateConditions")
[10:27:03.387]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:03.387]                   {
[10:27:03.387]                     inherits <- base::inherits
[10:27:03.387]                     invokeRestart <- base::invokeRestart
[10:27:03.387]                     is.null <- base::is.null
[10:27:03.387]                     muffled <- FALSE
[10:27:03.387]                     if (inherits(cond, "message")) {
[10:27:03.387]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:03.387]                       if (muffled) 
[10:27:03.387]                         invokeRestart("muffleMessage")
[10:27:03.387]                     }
[10:27:03.387]                     else if (inherits(cond, "warning")) {
[10:27:03.387]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:03.387]                       if (muffled) 
[10:27:03.387]                         invokeRestart("muffleWarning")
[10:27:03.387]                     }
[10:27:03.387]                     else if (inherits(cond, "condition")) {
[10:27:03.387]                       if (!is.null(pattern)) {
[10:27:03.387]                         computeRestarts <- base::computeRestarts
[10:27:03.387]                         grepl <- base::grepl
[10:27:03.387]                         restarts <- computeRestarts(cond)
[10:27:03.387]                         for (restart in restarts) {
[10:27:03.387]                           name <- restart$name
[10:27:03.387]                           if (is.null(name)) 
[10:27:03.387]                             next
[10:27:03.387]                           if (!grepl(pattern, name)) 
[10:27:03.387]                             next
[10:27:03.387]                           invokeRestart(restart)
[10:27:03.387]                           muffled <- TRUE
[10:27:03.387]                           break
[10:27:03.387]                         }
[10:27:03.387]                       }
[10:27:03.387]                     }
[10:27:03.387]                     invisible(muffled)
[10:27:03.387]                   }
[10:27:03.387]                   muffleCondition(cond)
[10:27:03.387]                 })
[10:27:03.387]             }))
[10:27:03.387]             future::FutureResult(value = ...future.value$value, 
[10:27:03.387]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:03.387]                   ...future.rng), globalenv = if (FALSE) 
[10:27:03.387]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:03.387]                     ...future.globalenv.names))
[10:27:03.387]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:03.387]         }, condition = base::local({
[10:27:03.387]             c <- base::c
[10:27:03.387]             inherits <- base::inherits
[10:27:03.387]             invokeRestart <- base::invokeRestart
[10:27:03.387]             length <- base::length
[10:27:03.387]             list <- base::list
[10:27:03.387]             seq.int <- base::seq.int
[10:27:03.387]             signalCondition <- base::signalCondition
[10:27:03.387]             sys.calls <- base::sys.calls
[10:27:03.387]             `[[` <- base::`[[`
[10:27:03.387]             `+` <- base::`+`
[10:27:03.387]             `<<-` <- base::`<<-`
[10:27:03.387]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:03.387]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:03.387]                   3L)]
[10:27:03.387]             }
[10:27:03.387]             function(cond) {
[10:27:03.387]                 is_error <- inherits(cond, "error")
[10:27:03.387]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:03.387]                   NULL)
[10:27:03.387]                 if (is_error) {
[10:27:03.387]                   sessionInformation <- function() {
[10:27:03.387]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:03.387]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:03.387]                       search = base::search(), system = base::Sys.info())
[10:27:03.387]                   }
[10:27:03.387]                   ...future.conditions[[length(...future.conditions) + 
[10:27:03.387]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:03.387]                     cond$call), session = sessionInformation(), 
[10:27:03.387]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:03.387]                   signalCondition(cond)
[10:27:03.387]                 }
[10:27:03.387]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:03.387]                 "immediateCondition"))) {
[10:27:03.387]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:03.387]                   ...future.conditions[[length(...future.conditions) + 
[10:27:03.387]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:03.387]                   if (TRUE && !signal) {
[10:27:03.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:03.387]                     {
[10:27:03.387]                       inherits <- base::inherits
[10:27:03.387]                       invokeRestart <- base::invokeRestart
[10:27:03.387]                       is.null <- base::is.null
[10:27:03.387]                       muffled <- FALSE
[10:27:03.387]                       if (inherits(cond, "message")) {
[10:27:03.387]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:03.387]                         if (muffled) 
[10:27:03.387]                           invokeRestart("muffleMessage")
[10:27:03.387]                       }
[10:27:03.387]                       else if (inherits(cond, "warning")) {
[10:27:03.387]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:03.387]                         if (muffled) 
[10:27:03.387]                           invokeRestart("muffleWarning")
[10:27:03.387]                       }
[10:27:03.387]                       else if (inherits(cond, "condition")) {
[10:27:03.387]                         if (!is.null(pattern)) {
[10:27:03.387]                           computeRestarts <- base::computeRestarts
[10:27:03.387]                           grepl <- base::grepl
[10:27:03.387]                           restarts <- computeRestarts(cond)
[10:27:03.387]                           for (restart in restarts) {
[10:27:03.387]                             name <- restart$name
[10:27:03.387]                             if (is.null(name)) 
[10:27:03.387]                               next
[10:27:03.387]                             if (!grepl(pattern, name)) 
[10:27:03.387]                               next
[10:27:03.387]                             invokeRestart(restart)
[10:27:03.387]                             muffled <- TRUE
[10:27:03.387]                             break
[10:27:03.387]                           }
[10:27:03.387]                         }
[10:27:03.387]                       }
[10:27:03.387]                       invisible(muffled)
[10:27:03.387]                     }
[10:27:03.387]                     muffleCondition(cond, pattern = "^muffle")
[10:27:03.387]                   }
[10:27:03.387]                 }
[10:27:03.387]                 else {
[10:27:03.387]                   if (TRUE) {
[10:27:03.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:03.387]                     {
[10:27:03.387]                       inherits <- base::inherits
[10:27:03.387]                       invokeRestart <- base::invokeRestart
[10:27:03.387]                       is.null <- base::is.null
[10:27:03.387]                       muffled <- FALSE
[10:27:03.387]                       if (inherits(cond, "message")) {
[10:27:03.387]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:03.387]                         if (muffled) 
[10:27:03.387]                           invokeRestart("muffleMessage")
[10:27:03.387]                       }
[10:27:03.387]                       else if (inherits(cond, "warning")) {
[10:27:03.387]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:03.387]                         if (muffled) 
[10:27:03.387]                           invokeRestart("muffleWarning")
[10:27:03.387]                       }
[10:27:03.387]                       else if (inherits(cond, "condition")) {
[10:27:03.387]                         if (!is.null(pattern)) {
[10:27:03.387]                           computeRestarts <- base::computeRestarts
[10:27:03.387]                           grepl <- base::grepl
[10:27:03.387]                           restarts <- computeRestarts(cond)
[10:27:03.387]                           for (restart in restarts) {
[10:27:03.387]                             name <- restart$name
[10:27:03.387]                             if (is.null(name)) 
[10:27:03.387]                               next
[10:27:03.387]                             if (!grepl(pattern, name)) 
[10:27:03.387]                               next
[10:27:03.387]                             invokeRestart(restart)
[10:27:03.387]                             muffled <- TRUE
[10:27:03.387]                             break
[10:27:03.387]                           }
[10:27:03.387]                         }
[10:27:03.387]                       }
[10:27:03.387]                       invisible(muffled)
[10:27:03.387]                     }
[10:27:03.387]                     muffleCondition(cond, pattern = "^muffle")
[10:27:03.387]                   }
[10:27:03.387]                 }
[10:27:03.387]             }
[10:27:03.387]         }))
[10:27:03.387]     }, error = function(ex) {
[10:27:03.387]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:03.387]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:03.387]                 ...future.rng), started = ...future.startTime, 
[10:27:03.387]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:03.387]             version = "1.8"), class = "FutureResult")
[10:27:03.387]     }, finally = {
[10:27:03.387]         if (!identical(...future.workdir, getwd())) 
[10:27:03.387]             setwd(...future.workdir)
[10:27:03.387]         {
[10:27:03.387]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:03.387]                 ...future.oldOptions$nwarnings <- NULL
[10:27:03.387]             }
[10:27:03.387]             base::options(...future.oldOptions)
[10:27:03.387]             if (.Platform$OS.type == "windows") {
[10:27:03.387]                 old_names <- names(...future.oldEnvVars)
[10:27:03.387]                 envs <- base::Sys.getenv()
[10:27:03.387]                 names <- names(envs)
[10:27:03.387]                 common <- intersect(names, old_names)
[10:27:03.387]                 added <- setdiff(names, old_names)
[10:27:03.387]                 removed <- setdiff(old_names, names)
[10:27:03.387]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:03.387]                   envs[common]]
[10:27:03.387]                 NAMES <- toupper(changed)
[10:27:03.387]                 args <- list()
[10:27:03.387]                 for (kk in seq_along(NAMES)) {
[10:27:03.387]                   name <- changed[[kk]]
[10:27:03.387]                   NAME <- NAMES[[kk]]
[10:27:03.387]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:03.387]                     next
[10:27:03.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:03.387]                 }
[10:27:03.387]                 NAMES <- toupper(added)
[10:27:03.387]                 for (kk in seq_along(NAMES)) {
[10:27:03.387]                   name <- added[[kk]]
[10:27:03.387]                   NAME <- NAMES[[kk]]
[10:27:03.387]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:03.387]                     next
[10:27:03.387]                   args[[name]] <- ""
[10:27:03.387]                 }
[10:27:03.387]                 NAMES <- toupper(removed)
[10:27:03.387]                 for (kk in seq_along(NAMES)) {
[10:27:03.387]                   name <- removed[[kk]]
[10:27:03.387]                   NAME <- NAMES[[kk]]
[10:27:03.387]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:03.387]                     next
[10:27:03.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:03.387]                 }
[10:27:03.387]                 if (length(args) > 0) 
[10:27:03.387]                   base::do.call(base::Sys.setenv, args = args)
[10:27:03.387]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:03.387]             }
[10:27:03.387]             else {
[10:27:03.387]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:03.387]             }
[10:27:03.387]             {
[10:27:03.387]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:03.387]                   0L) {
[10:27:03.387]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:03.387]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:03.387]                   base::options(opts)
[10:27:03.387]                 }
[10:27:03.387]                 {
[10:27:03.387]                   {
[10:27:03.387]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:03.387]                     NULL
[10:27:03.387]                   }
[10:27:03.387]                   options(future.plan = NULL)
[10:27:03.387]                   if (is.na(NA_character_)) 
[10:27:03.387]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:03.387]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:03.387]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:27:03.387]                     envir = parent.frame()) 
[10:27:03.387]                   {
[10:27:03.387]                     default_workers <- missing(workers)
[10:27:03.387]                     if (is.function(workers)) 
[10:27:03.387]                       workers <- workers()
[10:27:03.387]                     workers <- structure(as.integer(workers), 
[10:27:03.387]                       class = class(workers))
[10:27:03.387]                     stop_if_not(is.finite(workers), workers >= 
[10:27:03.387]                       1L)
[10:27:03.387]                     if ((workers == 1L && !inherits(workers, 
[10:27:03.387]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:27:03.387]                       if (default_workers) 
[10:27:03.387]                         supportsMulticore(warn = TRUE)
[10:27:03.387]                       return(sequential(..., envir = envir))
[10:27:03.387]                     }
[10:27:03.387]                     oopts <- options(mc.cores = workers)
[10:27:03.387]                     on.exit(options(oopts))
[10:27:03.387]                     future <- MulticoreFuture(..., workers = workers, 
[10:27:03.387]                       envir = envir)
[10:27:03.387]                     if (!future$lazy) 
[10:27:03.387]                       future <- run(future)
[10:27:03.387]                     invisible(future)
[10:27:03.387]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:03.387]                 }
[10:27:03.387]             }
[10:27:03.387]         }
[10:27:03.387]     })
[10:27:03.387]     if (TRUE) {
[10:27:03.387]         base::sink(type = "output", split = FALSE)
[10:27:03.387]         if (TRUE) {
[10:27:03.387]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:03.387]         }
[10:27:03.387]         else {
[10:27:03.387]             ...future.result["stdout"] <- base::list(NULL)
[10:27:03.387]         }
[10:27:03.387]         base::close(...future.stdout)
[10:27:03.387]         ...future.stdout <- NULL
[10:27:03.387]     }
[10:27:03.387]     ...future.result$conditions <- ...future.conditions
[10:27:03.387]     ...future.result$finished <- base::Sys.time()
[10:27:03.387]     ...future.result
[10:27:03.387] }
[10:27:03.391] requestCore(): workers = 2
[10:27:03.391] Poll #1 (0): usedCores() = 2, workers = 2
[10:27:03.402] result() for MulticoreFuture ...
[10:27:03.403] result() for MulticoreFuture ...
[10:27:03.403] result() for MulticoreFuture ... done
[10:27:03.404] result() for MulticoreFuture ... done
[10:27:03.404] result() for MulticoreFuture ...
[10:27:03.404] result() for MulticoreFuture ... done
[10:27:03.407] MulticoreFuture started
[10:27:03.407] - Launch lazy future ... done
[10:27:03.408] run() for ‘MulticoreFuture’ ... done
[10:27:03.408] plan(): Setting new future strategy stack:
[10:27:03.410] resolve() on list environment ...
[10:27:03.409] List of future strategies:
[10:27:03.409] 1. sequential:
[10:27:03.409]    - args: function (..., envir = parent.frame())
[10:27:03.409]    - tweaked: FALSE
[10:27:03.409]    - call: NULL
[10:27:03.410]  recursive: 0
[10:27:03.410] plan(): nbrOfWorkers() = 1
[10:27:03.411]  length: 3
[10:27:03.411]  elements: ‘a’, ‘b’, ‘c’
[10:27:03.412] Future #1
[10:27:03.412]  length: 2 (resolved future 1)
[10:27:03.413] plan(): Setting new future strategy stack:
[10:27:03.413] List of future strategies:
[10:27:03.413] 1. multicore:
[10:27:03.413]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:27:03.413]    - tweaked: FALSE
[10:27:03.413]    - call: plan(strategy)
[10:27:03.422] plan(): nbrOfWorkers() = 2
[10:27:03.423] Future #2
[10:27:03.423]  length: 1 (resolved future 2)
[10:27:03.423]  length: 0 (resolved future 3)
[10:27:03.423] resolve() on list environment ... DONE
[10:27:03.424] getGlobalsAndPackages() ...
[10:27:03.424] Searching for globals...
[10:27:03.426] - globals found: [1] ‘{’
[10:27:03.426] Searching for globals ... DONE
[10:27:03.426] Resolving globals: FALSE
[10:27:03.427] 
[10:27:03.427] 
[10:27:03.427] getGlobalsAndPackages() ... DONE
[10:27:03.432] run() for ‘Future’ ...
[10:27:03.433] - state: ‘created’
[10:27:03.433] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:27:03.446] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:03.446] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:27:03.447]   - Field: ‘label’
[10:27:03.447]   - Field: ‘local’
[10:27:03.448]   - Field: ‘owner’
[10:27:03.448]   - Field: ‘envir’
[10:27:03.448]   - Field: ‘workers’
[10:27:03.448]   - Field: ‘packages’
[10:27:03.448]   - Field: ‘gc’
[10:27:03.449]   - Field: ‘job’
[10:27:03.449]   - Field: ‘conditions’
[10:27:03.449]   - Field: ‘expr’
[10:27:03.449]   - Field: ‘uuid’
[10:27:03.449]   - Field: ‘seed’
[10:27:03.450]   - Field: ‘version’
[10:27:03.450]   - Field: ‘result’
[10:27:03.450]   - Field: ‘asynchronous’
[10:27:03.450]   - Field: ‘calls’
[10:27:03.450]   - Field: ‘globals’
[10:27:03.450]   - Field: ‘stdout’
[10:27:03.451]   - Field: ‘earlySignal’
[10:27:03.451]   - Field: ‘lazy’
[10:27:03.451]   - Field: ‘state’
[10:27:03.451] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:27:03.451] - Launch lazy future ...
[10:27:03.452] Packages needed by the future expression (n = 0): <none>
[10:27:03.452] Packages needed by future strategies (n = 0): <none>
[10:27:03.453] {
[10:27:03.453]     {
[10:27:03.453]         {
[10:27:03.453]             ...future.startTime <- base::Sys.time()
[10:27:03.453]             {
[10:27:03.453]                 {
[10:27:03.453]                   {
[10:27:03.453]                     {
[10:27:03.453]                       base::local({
[10:27:03.453]                         has_future <- base::requireNamespace("future", 
[10:27:03.453]                           quietly = TRUE)
[10:27:03.453]                         if (has_future) {
[10:27:03.453]                           ns <- base::getNamespace("future")
[10:27:03.453]                           version <- ns[[".package"]][["version"]]
[10:27:03.453]                           if (is.null(version)) 
[10:27:03.453]                             version <- utils::packageVersion("future")
[10:27:03.453]                         }
[10:27:03.453]                         else {
[10:27:03.453]                           version <- NULL
[10:27:03.453]                         }
[10:27:03.453]                         if (!has_future || version < "1.8.0") {
[10:27:03.453]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:03.453]                             "", base::R.version$version.string), 
[10:27:03.453]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:03.453]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:03.453]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:03.453]                               "release", "version")], collapse = " "), 
[10:27:03.453]                             hostname = base::Sys.info()[["nodename"]])
[10:27:03.453]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:03.453]                             info)
[10:27:03.453]                           info <- base::paste(info, collapse = "; ")
[10:27:03.453]                           if (!has_future) {
[10:27:03.453]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:03.453]                               info)
[10:27:03.453]                           }
[10:27:03.453]                           else {
[10:27:03.453]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:03.453]                               info, version)
[10:27:03.453]                           }
[10:27:03.453]                           base::stop(msg)
[10:27:03.453]                         }
[10:27:03.453]                       })
[10:27:03.453]                     }
[10:27:03.453]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:03.453]                     base::options(mc.cores = 1L)
[10:27:03.453]                   }
[10:27:03.453]                   options(future.plan = NULL)
[10:27:03.453]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:03.453]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:03.453]                 }
[10:27:03.453]                 ...future.workdir <- getwd()
[10:27:03.453]             }
[10:27:03.453]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:03.453]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:03.453]         }
[10:27:03.453]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:03.453]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:03.453]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:03.453]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:03.453]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:03.453]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:03.453]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:03.453]             base::names(...future.oldOptions))
[10:27:03.453]     }
[10:27:03.453]     if (FALSE) {
[10:27:03.453]     }
[10:27:03.453]     else {
[10:27:03.453]         if (TRUE) {
[10:27:03.453]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:03.453]                 open = "w")
[10:27:03.453]         }
[10:27:03.453]         else {
[10:27:03.453]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:03.453]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:03.453]         }
[10:27:03.453]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:03.453]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:03.453]             base::sink(type = "output", split = FALSE)
[10:27:03.453]             base::close(...future.stdout)
[10:27:03.453]         }, add = TRUE)
[10:27:03.453]     }
[10:27:03.453]     ...future.frame <- base::sys.nframe()
[10:27:03.453]     ...future.conditions <- base::list()
[10:27:03.453]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:03.453]     if (FALSE) {
[10:27:03.453]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:03.453]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:03.453]     }
[10:27:03.453]     ...future.result <- base::tryCatch({
[10:27:03.453]         base::withCallingHandlers({
[10:27:03.453]             ...future.value <- base::withVisible(base::local({
[10:27:03.453]                 withCallingHandlers({
[10:27:03.453]                   {
[10:27:03.453]                     1
[10:27:03.453]                   }
[10:27:03.453]                 }, immediateCondition = function(cond) {
[10:27:03.453]                   save_rds <- function (object, pathname, ...) 
[10:27:03.453]                   {
[10:27:03.453]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:27:03.453]                     if (file_test("-f", pathname_tmp)) {
[10:27:03.453]                       fi_tmp <- file.info(pathname_tmp)
[10:27:03.453]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:27:03.453]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:03.453]                         fi_tmp[["mtime"]])
[10:27:03.453]                     }
[10:27:03.453]                     tryCatch({
[10:27:03.453]                       saveRDS(object, file = pathname_tmp, ...)
[10:27:03.453]                     }, error = function(ex) {
[10:27:03.453]                       msg <- conditionMessage(ex)
[10:27:03.453]                       fi_tmp <- file.info(pathname_tmp)
[10:27:03.453]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:27:03.453]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:03.453]                         fi_tmp[["mtime"]], msg)
[10:27:03.453]                       ex$message <- msg
[10:27:03.453]                       stop(ex)
[10:27:03.453]                     })
[10:27:03.453]                     stopifnot(file_test("-f", pathname_tmp))
[10:27:03.453]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:27:03.453]                     if (!res || file_test("-f", pathname_tmp)) {
[10:27:03.453]                       fi_tmp <- file.info(pathname_tmp)
[10:27:03.453]                       fi <- file.info(pathname)
[10:27:03.453]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:27:03.453]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:03.453]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:27:03.453]                         fi[["size"]], fi[["mtime"]])
[10:27:03.453]                       stop(msg)
[10:27:03.453]                     }
[10:27:03.453]                     invisible(pathname)
[10:27:03.453]                   }
[10:27:03.453]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:27:03.453]                     rootPath = tempdir()) 
[10:27:03.453]                   {
[10:27:03.453]                     obj <- list(time = Sys.time(), condition = cond)
[10:27:03.453]                     file <- tempfile(pattern = class(cond)[1], 
[10:27:03.453]                       tmpdir = path, fileext = ".rds")
[10:27:03.453]                     save_rds(obj, file)
[10:27:03.453]                   }
[10:27:03.453]                   saveImmediateCondition(cond, path = "/tmp/RtmpisxSDE/.future/immediateConditions")
[10:27:03.453]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:03.453]                   {
[10:27:03.453]                     inherits <- base::inherits
[10:27:03.453]                     invokeRestart <- base::invokeRestart
[10:27:03.453]                     is.null <- base::is.null
[10:27:03.453]                     muffled <- FALSE
[10:27:03.453]                     if (inherits(cond, "message")) {
[10:27:03.453]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:03.453]                       if (muffled) 
[10:27:03.453]                         invokeRestart("muffleMessage")
[10:27:03.453]                     }
[10:27:03.453]                     else if (inherits(cond, "warning")) {
[10:27:03.453]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:03.453]                       if (muffled) 
[10:27:03.453]                         invokeRestart("muffleWarning")
[10:27:03.453]                     }
[10:27:03.453]                     else if (inherits(cond, "condition")) {
[10:27:03.453]                       if (!is.null(pattern)) {
[10:27:03.453]                         computeRestarts <- base::computeRestarts
[10:27:03.453]                         grepl <- base::grepl
[10:27:03.453]                         restarts <- computeRestarts(cond)
[10:27:03.453]                         for (restart in restarts) {
[10:27:03.453]                           name <- restart$name
[10:27:03.453]                           if (is.null(name)) 
[10:27:03.453]                             next
[10:27:03.453]                           if (!grepl(pattern, name)) 
[10:27:03.453]                             next
[10:27:03.453]                           invokeRestart(restart)
[10:27:03.453]                           muffled <- TRUE
[10:27:03.453]                           break
[10:27:03.453]                         }
[10:27:03.453]                       }
[10:27:03.453]                     }
[10:27:03.453]                     invisible(muffled)
[10:27:03.453]                   }
[10:27:03.453]                   muffleCondition(cond)
[10:27:03.453]                 })
[10:27:03.453]             }))
[10:27:03.453]             future::FutureResult(value = ...future.value$value, 
[10:27:03.453]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:03.453]                   ...future.rng), globalenv = if (FALSE) 
[10:27:03.453]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:03.453]                     ...future.globalenv.names))
[10:27:03.453]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:03.453]         }, condition = base::local({
[10:27:03.453]             c <- base::c
[10:27:03.453]             inherits <- base::inherits
[10:27:03.453]             invokeRestart <- base::invokeRestart
[10:27:03.453]             length <- base::length
[10:27:03.453]             list <- base::list
[10:27:03.453]             seq.int <- base::seq.int
[10:27:03.453]             signalCondition <- base::signalCondition
[10:27:03.453]             sys.calls <- base::sys.calls
[10:27:03.453]             `[[` <- base::`[[`
[10:27:03.453]             `+` <- base::`+`
[10:27:03.453]             `<<-` <- base::`<<-`
[10:27:03.453]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:03.453]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:03.453]                   3L)]
[10:27:03.453]             }
[10:27:03.453]             function(cond) {
[10:27:03.453]                 is_error <- inherits(cond, "error")
[10:27:03.453]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:03.453]                   NULL)
[10:27:03.453]                 if (is_error) {
[10:27:03.453]                   sessionInformation <- function() {
[10:27:03.453]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:03.453]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:03.453]                       search = base::search(), system = base::Sys.info())
[10:27:03.453]                   }
[10:27:03.453]                   ...future.conditions[[length(...future.conditions) + 
[10:27:03.453]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:03.453]                     cond$call), session = sessionInformation(), 
[10:27:03.453]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:03.453]                   signalCondition(cond)
[10:27:03.453]                 }
[10:27:03.453]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:03.453]                 "immediateCondition"))) {
[10:27:03.453]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:03.453]                   ...future.conditions[[length(...future.conditions) + 
[10:27:03.453]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:03.453]                   if (TRUE && !signal) {
[10:27:03.453]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:03.453]                     {
[10:27:03.453]                       inherits <- base::inherits
[10:27:03.453]                       invokeRestart <- base::invokeRestart
[10:27:03.453]                       is.null <- base::is.null
[10:27:03.453]                       muffled <- FALSE
[10:27:03.453]                       if (inherits(cond, "message")) {
[10:27:03.453]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:03.453]                         if (muffled) 
[10:27:03.453]                           invokeRestart("muffleMessage")
[10:27:03.453]                       }
[10:27:03.453]                       else if (inherits(cond, "warning")) {
[10:27:03.453]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:03.453]                         if (muffled) 
[10:27:03.453]                           invokeRestart("muffleWarning")
[10:27:03.453]                       }
[10:27:03.453]                       else if (inherits(cond, "condition")) {
[10:27:03.453]                         if (!is.null(pattern)) {
[10:27:03.453]                           computeRestarts <- base::computeRestarts
[10:27:03.453]                           grepl <- base::grepl
[10:27:03.453]                           restarts <- computeRestarts(cond)
[10:27:03.453]                           for (restart in restarts) {
[10:27:03.453]                             name <- restart$name
[10:27:03.453]                             if (is.null(name)) 
[10:27:03.453]                               next
[10:27:03.453]                             if (!grepl(pattern, name)) 
[10:27:03.453]                               next
[10:27:03.453]                             invokeRestart(restart)
[10:27:03.453]                             muffled <- TRUE
[10:27:03.453]                             break
[10:27:03.453]                           }
[10:27:03.453]                         }
[10:27:03.453]                       }
[10:27:03.453]                       invisible(muffled)
[10:27:03.453]                     }
[10:27:03.453]                     muffleCondition(cond, pattern = "^muffle")
[10:27:03.453]                   }
[10:27:03.453]                 }
[10:27:03.453]                 else {
[10:27:03.453]                   if (TRUE) {
[10:27:03.453]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:03.453]                     {
[10:27:03.453]                       inherits <- base::inherits
[10:27:03.453]                       invokeRestart <- base::invokeRestart
[10:27:03.453]                       is.null <- base::is.null
[10:27:03.453]                       muffled <- FALSE
[10:27:03.453]                       if (inherits(cond, "message")) {
[10:27:03.453]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:03.453]                         if (muffled) 
[10:27:03.453]                           invokeRestart("muffleMessage")
[10:27:03.453]                       }
[10:27:03.453]                       else if (inherits(cond, "warning")) {
[10:27:03.453]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:03.453]                         if (muffled) 
[10:27:03.453]                           invokeRestart("muffleWarning")
[10:27:03.453]                       }
[10:27:03.453]                       else if (inherits(cond, "condition")) {
[10:27:03.453]                         if (!is.null(pattern)) {
[10:27:03.453]                           computeRestarts <- base::computeRestarts
[10:27:03.453]                           grepl <- base::grepl
[10:27:03.453]                           restarts <- computeRestarts(cond)
[10:27:03.453]                           for (restart in restarts) {
[10:27:03.453]                             name <- restart$name
[10:27:03.453]                             if (is.null(name)) 
[10:27:03.453]                               next
[10:27:03.453]                             if (!grepl(pattern, name)) 
[10:27:03.453]                               next
[10:27:03.453]                             invokeRestart(restart)
[10:27:03.453]                             muffled <- TRUE
[10:27:03.453]                             break
[10:27:03.453]                           }
[10:27:03.453]                         }
[10:27:03.453]                       }
[10:27:03.453]                       invisible(muffled)
[10:27:03.453]                     }
[10:27:03.453]                     muffleCondition(cond, pattern = "^muffle")
[10:27:03.453]                   }
[10:27:03.453]                 }
[10:27:03.453]             }
[10:27:03.453]         }))
[10:27:03.453]     }, error = function(ex) {
[10:27:03.453]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:03.453]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:03.453]                 ...future.rng), started = ...future.startTime, 
[10:27:03.453]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:03.453]             version = "1.8"), class = "FutureResult")
[10:27:03.453]     }, finally = {
[10:27:03.453]         if (!identical(...future.workdir, getwd())) 
[10:27:03.453]             setwd(...future.workdir)
[10:27:03.453]         {
[10:27:03.453]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:03.453]                 ...future.oldOptions$nwarnings <- NULL
[10:27:03.453]             }
[10:27:03.453]             base::options(...future.oldOptions)
[10:27:03.453]             if (.Platform$OS.type == "windows") {
[10:27:03.453]                 old_names <- names(...future.oldEnvVars)
[10:27:03.453]                 envs <- base::Sys.getenv()
[10:27:03.453]                 names <- names(envs)
[10:27:03.453]                 common <- intersect(names, old_names)
[10:27:03.453]                 added <- setdiff(names, old_names)
[10:27:03.453]                 removed <- setdiff(old_names, names)
[10:27:03.453]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:03.453]                   envs[common]]
[10:27:03.453]                 NAMES <- toupper(changed)
[10:27:03.453]                 args <- list()
[10:27:03.453]                 for (kk in seq_along(NAMES)) {
[10:27:03.453]                   name <- changed[[kk]]
[10:27:03.453]                   NAME <- NAMES[[kk]]
[10:27:03.453]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:03.453]                     next
[10:27:03.453]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:03.453]                 }
[10:27:03.453]                 NAMES <- toupper(added)
[10:27:03.453]                 for (kk in seq_along(NAMES)) {
[10:27:03.453]                   name <- added[[kk]]
[10:27:03.453]                   NAME <- NAMES[[kk]]
[10:27:03.453]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:03.453]                     next
[10:27:03.453]                   args[[name]] <- ""
[10:27:03.453]                 }
[10:27:03.453]                 NAMES <- toupper(removed)
[10:27:03.453]                 for (kk in seq_along(NAMES)) {
[10:27:03.453]                   name <- removed[[kk]]
[10:27:03.453]                   NAME <- NAMES[[kk]]
[10:27:03.453]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:03.453]                     next
[10:27:03.453]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:03.453]                 }
[10:27:03.453]                 if (length(args) > 0) 
[10:27:03.453]                   base::do.call(base::Sys.setenv, args = args)
[10:27:03.453]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:03.453]             }
[10:27:03.453]             else {
[10:27:03.453]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:03.453]             }
[10:27:03.453]             {
[10:27:03.453]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:03.453]                   0L) {
[10:27:03.453]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:03.453]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:03.453]                   base::options(opts)
[10:27:03.453]                 }
[10:27:03.453]                 {
[10:27:03.453]                   {
[10:27:03.453]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:03.453]                     NULL
[10:27:03.453]                   }
[10:27:03.453]                   options(future.plan = NULL)
[10:27:03.453]                   if (is.na(NA_character_)) 
[10:27:03.453]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:03.453]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:03.453]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:27:03.453]                     envir = parent.frame()) 
[10:27:03.453]                   {
[10:27:03.453]                     default_workers <- missing(workers)
[10:27:03.453]                     if (is.function(workers)) 
[10:27:03.453]                       workers <- workers()
[10:27:03.453]                     workers <- structure(as.integer(workers), 
[10:27:03.453]                       class = class(workers))
[10:27:03.453]                     stop_if_not(is.finite(workers), workers >= 
[10:27:03.453]                       1L)
[10:27:03.453]                     if ((workers == 1L && !inherits(workers, 
[10:27:03.453]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:27:03.453]                       if (default_workers) 
[10:27:03.453]                         supportsMulticore(warn = TRUE)
[10:27:03.453]                       return(sequential(..., envir = envir))
[10:27:03.453]                     }
[10:27:03.453]                     oopts <- options(mc.cores = workers)
[10:27:03.453]                     on.exit(options(oopts))
[10:27:03.453]                     future <- MulticoreFuture(..., workers = workers, 
[10:27:03.453]                       envir = envir)
[10:27:03.453]                     if (!future$lazy) 
[10:27:03.453]                       future <- run(future)
[10:27:03.453]                     invisible(future)
[10:27:03.453]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:03.453]                 }
[10:27:03.453]             }
[10:27:03.453]         }
[10:27:03.453]     })
[10:27:03.453]     if (TRUE) {
[10:27:03.453]         base::sink(type = "output", split = FALSE)
[10:27:03.453]         if (TRUE) {
[10:27:03.453]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:03.453]         }
[10:27:03.453]         else {
[10:27:03.453]             ...future.result["stdout"] <- base::list(NULL)
[10:27:03.453]         }
[10:27:03.453]         base::close(...future.stdout)
[10:27:03.453]         ...future.stdout <- NULL
[10:27:03.453]     }
[10:27:03.453]     ...future.result$conditions <- ...future.conditions
[10:27:03.453]     ...future.result$finished <- base::Sys.time()
[10:27:03.453]     ...future.result
[10:27:03.453] }
[10:27:03.456] requestCore(): workers = 2
[10:27:03.457] Poll #1 (0): usedCores() = 2, workers = 2
[10:27:03.467] result() for MulticoreFuture ...
[10:27:03.468] result() for MulticoreFuture ...
[10:27:03.468] result() for MulticoreFuture ... done
[10:27:03.469] result() for MulticoreFuture ... done
[10:27:03.469] result() for MulticoreFuture ...
[10:27:03.469] result() for MulticoreFuture ... done
[10:27:03.472] MulticoreFuture started
[10:27:03.472] - Launch lazy future ... done
[10:27:03.472] run() for ‘MulticoreFuture’ ... done
[10:27:03.473] plan(): Setting new future strategy stack:
[10:27:03.474] getGlobalsAndPackages() ...
[10:27:03.473] List of future strategies:
[10:27:03.473] 1. sequential:
[10:27:03.473]    - args: function (..., envir = parent.frame())
[10:27:03.473]    - tweaked: FALSE
[10:27:03.473]    - call: NULL
[10:27:03.474] Searching for globals...
[10:27:03.475] plan(): nbrOfWorkers() = 1
[10:27:03.478] - globals found: [2] ‘{’, ‘Sys.sleep’
[10:27:03.478] Searching for globals ... DONE
[10:27:03.478] plan(): Setting new future strategy stack:
[10:27:03.479] Resolving globals: FALSE
[10:27:03.479] List of future strategies:
[10:27:03.479] 1. multicore:
[10:27:03.479]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:27:03.479]    - tweaked: FALSE
[10:27:03.479]    - call: plan(strategy)
[10:27:03.479] 
[10:27:03.480] 
[10:27:03.480] getGlobalsAndPackages() ... DONE
[10:27:03.481] run() for ‘Future’ ...
[10:27:03.481] - state: ‘created’
[10:27:03.481] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:27:03.485] plan(): nbrOfWorkers() = 2
[10:27:03.487] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:03.488] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:27:03.489]   - Field: ‘label’
[10:27:03.489]   - Field: ‘local’
[10:27:03.489]   - Field: ‘owner’
[10:27:03.489]   - Field: ‘envir’
[10:27:03.490]   - Field: ‘workers’
[10:27:03.490]   - Field: ‘packages’
[10:27:03.490]   - Field: ‘gc’
[10:27:03.490]   - Field: ‘job’
[10:27:03.490]   - Field: ‘conditions’
[10:27:03.490]   - Field: ‘expr’
[10:27:03.490]   - Field: ‘uuid’
[10:27:03.491]   - Field: ‘seed’
[10:27:03.491]   - Field: ‘version’
[10:27:03.491]   - Field: ‘result’
[10:27:03.491]   - Field: ‘asynchronous’
[10:27:03.491]   - Field: ‘calls’
[10:27:03.491]   - Field: ‘globals’
[10:27:03.491]   - Field: ‘stdout’
[10:27:03.492]   - Field: ‘earlySignal’
[10:27:03.492]   - Field: ‘lazy’
[10:27:03.492]   - Field: ‘state’
[10:27:03.492] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:27:03.492] - Launch lazy future ...
[10:27:03.493] Packages needed by the future expression (n = 0): <none>
[10:27:03.493] Packages needed by future strategies (n = 0): <none>
[10:27:03.494] {
[10:27:03.494]     {
[10:27:03.494]         {
[10:27:03.494]             ...future.startTime <- base::Sys.time()
[10:27:03.494]             {
[10:27:03.494]                 {
[10:27:03.494]                   {
[10:27:03.494]                     {
[10:27:03.494]                       base::local({
[10:27:03.494]                         has_future <- base::requireNamespace("future", 
[10:27:03.494]                           quietly = TRUE)
[10:27:03.494]                         if (has_future) {
[10:27:03.494]                           ns <- base::getNamespace("future")
[10:27:03.494]                           version <- ns[[".package"]][["version"]]
[10:27:03.494]                           if (is.null(version)) 
[10:27:03.494]                             version <- utils::packageVersion("future")
[10:27:03.494]                         }
[10:27:03.494]                         else {
[10:27:03.494]                           version <- NULL
[10:27:03.494]                         }
[10:27:03.494]                         if (!has_future || version < "1.8.0") {
[10:27:03.494]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:03.494]                             "", base::R.version$version.string), 
[10:27:03.494]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:03.494]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:03.494]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:03.494]                               "release", "version")], collapse = " "), 
[10:27:03.494]                             hostname = base::Sys.info()[["nodename"]])
[10:27:03.494]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:03.494]                             info)
[10:27:03.494]                           info <- base::paste(info, collapse = "; ")
[10:27:03.494]                           if (!has_future) {
[10:27:03.494]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:03.494]                               info)
[10:27:03.494]                           }
[10:27:03.494]                           else {
[10:27:03.494]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:03.494]                               info, version)
[10:27:03.494]                           }
[10:27:03.494]                           base::stop(msg)
[10:27:03.494]                         }
[10:27:03.494]                       })
[10:27:03.494]                     }
[10:27:03.494]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:03.494]                     base::options(mc.cores = 1L)
[10:27:03.494]                   }
[10:27:03.494]                   options(future.plan = NULL)
[10:27:03.494]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:03.494]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:03.494]                 }
[10:27:03.494]                 ...future.workdir <- getwd()
[10:27:03.494]             }
[10:27:03.494]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:03.494]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:03.494]         }
[10:27:03.494]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:03.494]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:03.494]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:03.494]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:03.494]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:03.494]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:03.494]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:03.494]             base::names(...future.oldOptions))
[10:27:03.494]     }
[10:27:03.494]     if (FALSE) {
[10:27:03.494]     }
[10:27:03.494]     else {
[10:27:03.494]         if (TRUE) {
[10:27:03.494]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:03.494]                 open = "w")
[10:27:03.494]         }
[10:27:03.494]         else {
[10:27:03.494]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:03.494]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:03.494]         }
[10:27:03.494]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:03.494]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:03.494]             base::sink(type = "output", split = FALSE)
[10:27:03.494]             base::close(...future.stdout)
[10:27:03.494]         }, add = TRUE)
[10:27:03.494]     }
[10:27:03.494]     ...future.frame <- base::sys.nframe()
[10:27:03.494]     ...future.conditions <- base::list()
[10:27:03.494]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:03.494]     if (FALSE) {
[10:27:03.494]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:03.494]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:03.494]     }
[10:27:03.494]     ...future.result <- base::tryCatch({
[10:27:03.494]         base::withCallingHandlers({
[10:27:03.494]             ...future.value <- base::withVisible(base::local({
[10:27:03.494]                 withCallingHandlers({
[10:27:03.494]                   {
[10:27:03.494]                     Sys.sleep(0.5)
[10:27:03.494]                     2
[10:27:03.494]                   }
[10:27:03.494]                 }, immediateCondition = function(cond) {
[10:27:03.494]                   save_rds <- function (object, pathname, ...) 
[10:27:03.494]                   {
[10:27:03.494]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:27:03.494]                     if (file_test("-f", pathname_tmp)) {
[10:27:03.494]                       fi_tmp <- file.info(pathname_tmp)
[10:27:03.494]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:27:03.494]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:03.494]                         fi_tmp[["mtime"]])
[10:27:03.494]                     }
[10:27:03.494]                     tryCatch({
[10:27:03.494]                       saveRDS(object, file = pathname_tmp, ...)
[10:27:03.494]                     }, error = function(ex) {
[10:27:03.494]                       msg <- conditionMessage(ex)
[10:27:03.494]                       fi_tmp <- file.info(pathname_tmp)
[10:27:03.494]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:27:03.494]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:03.494]                         fi_tmp[["mtime"]], msg)
[10:27:03.494]                       ex$message <- msg
[10:27:03.494]                       stop(ex)
[10:27:03.494]                     })
[10:27:03.494]                     stopifnot(file_test("-f", pathname_tmp))
[10:27:03.494]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:27:03.494]                     if (!res || file_test("-f", pathname_tmp)) {
[10:27:03.494]                       fi_tmp <- file.info(pathname_tmp)
[10:27:03.494]                       fi <- file.info(pathname)
[10:27:03.494]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:27:03.494]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:03.494]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:27:03.494]                         fi[["size"]], fi[["mtime"]])
[10:27:03.494]                       stop(msg)
[10:27:03.494]                     }
[10:27:03.494]                     invisible(pathname)
[10:27:03.494]                   }
[10:27:03.494]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:27:03.494]                     rootPath = tempdir()) 
[10:27:03.494]                   {
[10:27:03.494]                     obj <- list(time = Sys.time(), condition = cond)
[10:27:03.494]                     file <- tempfile(pattern = class(cond)[1], 
[10:27:03.494]                       tmpdir = path, fileext = ".rds")
[10:27:03.494]                     save_rds(obj, file)
[10:27:03.494]                   }
[10:27:03.494]                   saveImmediateCondition(cond, path = "/tmp/RtmpisxSDE/.future/immediateConditions")
[10:27:03.494]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:03.494]                   {
[10:27:03.494]                     inherits <- base::inherits
[10:27:03.494]                     invokeRestart <- base::invokeRestart
[10:27:03.494]                     is.null <- base::is.null
[10:27:03.494]                     muffled <- FALSE
[10:27:03.494]                     if (inherits(cond, "message")) {
[10:27:03.494]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:03.494]                       if (muffled) 
[10:27:03.494]                         invokeRestart("muffleMessage")
[10:27:03.494]                     }
[10:27:03.494]                     else if (inherits(cond, "warning")) {
[10:27:03.494]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:03.494]                       if (muffled) 
[10:27:03.494]                         invokeRestart("muffleWarning")
[10:27:03.494]                     }
[10:27:03.494]                     else if (inherits(cond, "condition")) {
[10:27:03.494]                       if (!is.null(pattern)) {
[10:27:03.494]                         computeRestarts <- base::computeRestarts
[10:27:03.494]                         grepl <- base::grepl
[10:27:03.494]                         restarts <- computeRestarts(cond)
[10:27:03.494]                         for (restart in restarts) {
[10:27:03.494]                           name <- restart$name
[10:27:03.494]                           if (is.null(name)) 
[10:27:03.494]                             next
[10:27:03.494]                           if (!grepl(pattern, name)) 
[10:27:03.494]                             next
[10:27:03.494]                           invokeRestart(restart)
[10:27:03.494]                           muffled <- TRUE
[10:27:03.494]                           break
[10:27:03.494]                         }
[10:27:03.494]                       }
[10:27:03.494]                     }
[10:27:03.494]                     invisible(muffled)
[10:27:03.494]                   }
[10:27:03.494]                   muffleCondition(cond)
[10:27:03.494]                 })
[10:27:03.494]             }))
[10:27:03.494]             future::FutureResult(value = ...future.value$value, 
[10:27:03.494]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:03.494]                   ...future.rng), globalenv = if (FALSE) 
[10:27:03.494]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:03.494]                     ...future.globalenv.names))
[10:27:03.494]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:03.494]         }, condition = base::local({
[10:27:03.494]             c <- base::c
[10:27:03.494]             inherits <- base::inherits
[10:27:03.494]             invokeRestart <- base::invokeRestart
[10:27:03.494]             length <- base::length
[10:27:03.494]             list <- base::list
[10:27:03.494]             seq.int <- base::seq.int
[10:27:03.494]             signalCondition <- base::signalCondition
[10:27:03.494]             sys.calls <- base::sys.calls
[10:27:03.494]             `[[` <- base::`[[`
[10:27:03.494]             `+` <- base::`+`
[10:27:03.494]             `<<-` <- base::`<<-`
[10:27:03.494]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:03.494]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:03.494]                   3L)]
[10:27:03.494]             }
[10:27:03.494]             function(cond) {
[10:27:03.494]                 is_error <- inherits(cond, "error")
[10:27:03.494]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:03.494]                   NULL)
[10:27:03.494]                 if (is_error) {
[10:27:03.494]                   sessionInformation <- function() {
[10:27:03.494]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:03.494]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:03.494]                       search = base::search(), system = base::Sys.info())
[10:27:03.494]                   }
[10:27:03.494]                   ...future.conditions[[length(...future.conditions) + 
[10:27:03.494]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:03.494]                     cond$call), session = sessionInformation(), 
[10:27:03.494]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:03.494]                   signalCondition(cond)
[10:27:03.494]                 }
[10:27:03.494]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:03.494]                 "immediateCondition"))) {
[10:27:03.494]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:03.494]                   ...future.conditions[[length(...future.conditions) + 
[10:27:03.494]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:03.494]                   if (TRUE && !signal) {
[10:27:03.494]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:03.494]                     {
[10:27:03.494]                       inherits <- base::inherits
[10:27:03.494]                       invokeRestart <- base::invokeRestart
[10:27:03.494]                       is.null <- base::is.null
[10:27:03.494]                       muffled <- FALSE
[10:27:03.494]                       if (inherits(cond, "message")) {
[10:27:03.494]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:03.494]                         if (muffled) 
[10:27:03.494]                           invokeRestart("muffleMessage")
[10:27:03.494]                       }
[10:27:03.494]                       else if (inherits(cond, "warning")) {
[10:27:03.494]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:03.494]                         if (muffled) 
[10:27:03.494]                           invokeRestart("muffleWarning")
[10:27:03.494]                       }
[10:27:03.494]                       else if (inherits(cond, "condition")) {
[10:27:03.494]                         if (!is.null(pattern)) {
[10:27:03.494]                           computeRestarts <- base::computeRestarts
[10:27:03.494]                           grepl <- base::grepl
[10:27:03.494]                           restarts <- computeRestarts(cond)
[10:27:03.494]                           for (restart in restarts) {
[10:27:03.494]                             name <- restart$name
[10:27:03.494]                             if (is.null(name)) 
[10:27:03.494]                               next
[10:27:03.494]                             if (!grepl(pattern, name)) 
[10:27:03.494]                               next
[10:27:03.494]                             invokeRestart(restart)
[10:27:03.494]                             muffled <- TRUE
[10:27:03.494]                             break
[10:27:03.494]                           }
[10:27:03.494]                         }
[10:27:03.494]                       }
[10:27:03.494]                       invisible(muffled)
[10:27:03.494]                     }
[10:27:03.494]                     muffleCondition(cond, pattern = "^muffle")
[10:27:03.494]                   }
[10:27:03.494]                 }
[10:27:03.494]                 else {
[10:27:03.494]                   if (TRUE) {
[10:27:03.494]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:03.494]                     {
[10:27:03.494]                       inherits <- base::inherits
[10:27:03.494]                       invokeRestart <- base::invokeRestart
[10:27:03.494]                       is.null <- base::is.null
[10:27:03.494]                       muffled <- FALSE
[10:27:03.494]                       if (inherits(cond, "message")) {
[10:27:03.494]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:03.494]                         if (muffled) 
[10:27:03.494]                           invokeRestart("muffleMessage")
[10:27:03.494]                       }
[10:27:03.494]                       else if (inherits(cond, "warning")) {
[10:27:03.494]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:03.494]                         if (muffled) 
[10:27:03.494]                           invokeRestart("muffleWarning")
[10:27:03.494]                       }
[10:27:03.494]                       else if (inherits(cond, "condition")) {
[10:27:03.494]                         if (!is.null(pattern)) {
[10:27:03.494]                           computeRestarts <- base::computeRestarts
[10:27:03.494]                           grepl <- base::grepl
[10:27:03.494]                           restarts <- computeRestarts(cond)
[10:27:03.494]                           for (restart in restarts) {
[10:27:03.494]                             name <- restart$name
[10:27:03.494]                             if (is.null(name)) 
[10:27:03.494]                               next
[10:27:03.494]                             if (!grepl(pattern, name)) 
[10:27:03.494]                               next
[10:27:03.494]                             invokeRestart(restart)
[10:27:03.494]                             muffled <- TRUE
[10:27:03.494]                             break
[10:27:03.494]                           }
[10:27:03.494]                         }
[10:27:03.494]                       }
[10:27:03.494]                       invisible(muffled)
[10:27:03.494]                     }
[10:27:03.494]                     muffleCondition(cond, pattern = "^muffle")
[10:27:03.494]                   }
[10:27:03.494]                 }
[10:27:03.494]             }
[10:27:03.494]         }))
[10:27:03.494]     }, error = function(ex) {
[10:27:03.494]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:03.494]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:03.494]                 ...future.rng), started = ...future.startTime, 
[10:27:03.494]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:03.494]             version = "1.8"), class = "FutureResult")
[10:27:03.494]     }, finally = {
[10:27:03.494]         if (!identical(...future.workdir, getwd())) 
[10:27:03.494]             setwd(...future.workdir)
[10:27:03.494]         {
[10:27:03.494]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:03.494]                 ...future.oldOptions$nwarnings <- NULL
[10:27:03.494]             }
[10:27:03.494]             base::options(...future.oldOptions)
[10:27:03.494]             if (.Platform$OS.type == "windows") {
[10:27:03.494]                 old_names <- names(...future.oldEnvVars)
[10:27:03.494]                 envs <- base::Sys.getenv()
[10:27:03.494]                 names <- names(envs)
[10:27:03.494]                 common <- intersect(names, old_names)
[10:27:03.494]                 added <- setdiff(names, old_names)
[10:27:03.494]                 removed <- setdiff(old_names, names)
[10:27:03.494]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:03.494]                   envs[common]]
[10:27:03.494]                 NAMES <- toupper(changed)
[10:27:03.494]                 args <- list()
[10:27:03.494]                 for (kk in seq_along(NAMES)) {
[10:27:03.494]                   name <- changed[[kk]]
[10:27:03.494]                   NAME <- NAMES[[kk]]
[10:27:03.494]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:03.494]                     next
[10:27:03.494]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:03.494]                 }
[10:27:03.494]                 NAMES <- toupper(added)
[10:27:03.494]                 for (kk in seq_along(NAMES)) {
[10:27:03.494]                   name <- added[[kk]]
[10:27:03.494]                   NAME <- NAMES[[kk]]
[10:27:03.494]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:03.494]                     next
[10:27:03.494]                   args[[name]] <- ""
[10:27:03.494]                 }
[10:27:03.494]                 NAMES <- toupper(removed)
[10:27:03.494]                 for (kk in seq_along(NAMES)) {
[10:27:03.494]                   name <- removed[[kk]]
[10:27:03.494]                   NAME <- NAMES[[kk]]
[10:27:03.494]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:03.494]                     next
[10:27:03.494]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:03.494]                 }
[10:27:03.494]                 if (length(args) > 0) 
[10:27:03.494]                   base::do.call(base::Sys.setenv, args = args)
[10:27:03.494]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:03.494]             }
[10:27:03.494]             else {
[10:27:03.494]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:03.494]             }
[10:27:03.494]             {
[10:27:03.494]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:03.494]                   0L) {
[10:27:03.494]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:03.494]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:03.494]                   base::options(opts)
[10:27:03.494]                 }
[10:27:03.494]                 {
[10:27:03.494]                   {
[10:27:03.494]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:03.494]                     NULL
[10:27:03.494]                   }
[10:27:03.494]                   options(future.plan = NULL)
[10:27:03.494]                   if (is.na(NA_character_)) 
[10:27:03.494]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:03.494]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:03.494]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:27:03.494]                     envir = parent.frame()) 
[10:27:03.494]                   {
[10:27:03.494]                     default_workers <- missing(workers)
[10:27:03.494]                     if (is.function(workers)) 
[10:27:03.494]                       workers <- workers()
[10:27:03.494]                     workers <- structure(as.integer(workers), 
[10:27:03.494]                       class = class(workers))
[10:27:03.494]                     stop_if_not(is.finite(workers), workers >= 
[10:27:03.494]                       1L)
[10:27:03.494]                     if ((workers == 1L && !inherits(workers, 
[10:27:03.494]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:27:03.494]                       if (default_workers) 
[10:27:03.494]                         supportsMulticore(warn = TRUE)
[10:27:03.494]                       return(sequential(..., envir = envir))
[10:27:03.494]                     }
[10:27:03.494]                     oopts <- options(mc.cores = workers)
[10:27:03.494]                     on.exit(options(oopts))
[10:27:03.494]                     future <- MulticoreFuture(..., workers = workers, 
[10:27:03.494]                       envir = envir)
[10:27:03.494]                     if (!future$lazy) 
[10:27:03.494]                       future <- run(future)
[10:27:03.494]                     invisible(future)
[10:27:03.494]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:03.494]                 }
[10:27:03.494]             }
[10:27:03.494]         }
[10:27:03.494]     })
[10:27:03.494]     if (TRUE) {
[10:27:03.494]         base::sink(type = "output", split = FALSE)
[10:27:03.494]         if (TRUE) {
[10:27:03.494]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:03.494]         }
[10:27:03.494]         else {
[10:27:03.494]             ...future.result["stdout"] <- base::list(NULL)
[10:27:03.494]         }
[10:27:03.494]         base::close(...future.stdout)
[10:27:03.494]         ...future.stdout <- NULL
[10:27:03.494]     }
[10:27:03.494]     ...future.result$conditions <- ...future.conditions
[10:27:03.494]     ...future.result$finished <- base::Sys.time()
[10:27:03.494]     ...future.result
[10:27:03.494] }
[10:27:03.499] requestCore(): workers = 2
[10:27:03.500] Poll #1 (0): usedCores() = 2, workers = 2
[10:27:03.511] result() for MulticoreFuture ...
[10:27:03.512] result() for MulticoreFuture ...
[10:27:03.512] result() for MulticoreFuture ... done
[10:27:03.512] result() for MulticoreFuture ... done
[10:27:03.512] result() for MulticoreFuture ...
[10:27:03.512] result() for MulticoreFuture ... done
[10:27:03.516] MulticoreFuture started
[10:27:03.517] - Launch lazy future ... done
[10:27:03.517] run() for ‘MulticoreFuture’ ... done
[10:27:03.518] plan(): Setting new future strategy stack:
[10:27:03.519] getGlobalsAndPackages() ...
[10:27:03.519] Searching for globals...
[10:27:03.518] List of future strategies:
[10:27:03.518] 1. sequential:
[10:27:03.518]    - args: function (..., envir = parent.frame())
[10:27:03.518]    - tweaked: FALSE
[10:27:03.518]    - call: NULL
[10:27:03.519] plan(): nbrOfWorkers() = 1
[10:27:03.521] - globals found: [1] ‘{’
[10:27:03.521] Searching for globals ... DONE
[10:27:03.521] Resolving globals: FALSE
[10:27:03.522] 
[10:27:03.522] 
[10:27:03.522] getGlobalsAndPackages() ... DONE
[10:27:03.523] run() for ‘Future’ ...
[10:27:03.523] - state: ‘created’
[10:27:03.523] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:27:03.530] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:03.530] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:27:03.530]   - Field: ‘label’
[10:27:03.530]   - Field: ‘local’
[10:27:03.530]   - Field: ‘owner’
[10:27:03.531]   - Field: ‘envir’
[10:27:03.531]   - Field: ‘workers’
[10:27:03.531]   - Field: ‘packages’
[10:27:03.531]   - Field: ‘gc’
[10:27:03.531]   - Field: ‘job’
[10:27:03.531]   - Field: ‘conditions’
[10:27:03.531]   - Field: ‘expr’
[10:27:03.532]   - Field: ‘uuid’
[10:27:03.532]   - Field: ‘seed’
[10:27:03.532]   - Field: ‘version’
[10:27:03.532]   - Field: ‘result’
[10:27:03.532]   - Field: ‘asynchronous’
[10:27:03.532]   - Field: ‘calls’
[10:27:03.533]   - Field: ‘globals’
[10:27:03.533]   - Field: ‘stdout’
[10:27:03.533]   - Field: ‘earlySignal’
[10:27:03.533]   - Field: ‘lazy’
[10:27:03.537]   - Field: ‘state’
[10:27:03.538] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:27:03.538] - Launch lazy future ...
[10:27:03.539] Packages needed by the future expression (n = 0): <none>
[10:27:03.539] Packages needed by future strategies (n = 0): <none>
[10:27:03.541] {
[10:27:03.541]     {
[10:27:03.541]         {
[10:27:03.541]             ...future.startTime <- base::Sys.time()
[10:27:03.541]             {
[10:27:03.541]                 {
[10:27:03.541]                   {
[10:27:03.541]                     {
[10:27:03.541]                       base::local({
[10:27:03.541]                         has_future <- base::requireNamespace("future", 
[10:27:03.541]                           quietly = TRUE)
[10:27:03.541]                         if (has_future) {
[10:27:03.541]                           ns <- base::getNamespace("future")
[10:27:03.541]                           version <- ns[[".package"]][["version"]]
[10:27:03.541]                           if (is.null(version)) 
[10:27:03.541]                             version <- utils::packageVersion("future")
[10:27:03.541]                         }
[10:27:03.541]                         else {
[10:27:03.541]                           version <- NULL
[10:27:03.541]                         }
[10:27:03.541]                         if (!has_future || version < "1.8.0") {
[10:27:03.541]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:03.541]                             "", base::R.version$version.string), 
[10:27:03.541]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:03.541]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:03.541]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:03.541]                               "release", "version")], collapse = " "), 
[10:27:03.541]                             hostname = base::Sys.info()[["nodename"]])
[10:27:03.541]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:03.541]                             info)
[10:27:03.541]                           info <- base::paste(info, collapse = "; ")
[10:27:03.541]                           if (!has_future) {
[10:27:03.541]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:03.541]                               info)
[10:27:03.541]                           }
[10:27:03.541]                           else {
[10:27:03.541]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:03.541]                               info, version)
[10:27:03.541]                           }
[10:27:03.541]                           base::stop(msg)
[10:27:03.541]                         }
[10:27:03.541]                       })
[10:27:03.541]                     }
[10:27:03.541]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:03.541]                     base::options(mc.cores = 1L)
[10:27:03.541]                   }
[10:27:03.541]                   options(future.plan = NULL)
[10:27:03.541]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:03.541]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:03.541]                 }
[10:27:03.541]                 ...future.workdir <- getwd()
[10:27:03.541]             }
[10:27:03.541]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:03.541]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:03.541]         }
[10:27:03.541]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:03.541]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:03.541]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:03.541]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:03.541]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:03.541]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:03.541]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:03.541]             base::names(...future.oldOptions))
[10:27:03.541]     }
[10:27:03.541]     if (FALSE) {
[10:27:03.541]     }
[10:27:03.541]     else {
[10:27:03.541]         if (TRUE) {
[10:27:03.541]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:03.541]                 open = "w")
[10:27:03.541]         }
[10:27:03.541]         else {
[10:27:03.541]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:03.541]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:03.541]         }
[10:27:03.541]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:03.541]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:03.541]             base::sink(type = "output", split = FALSE)
[10:27:03.541]             base::close(...future.stdout)
[10:27:03.541]         }, add = TRUE)
[10:27:03.541]     }
[10:27:03.541]     ...future.frame <- base::sys.nframe()
[10:27:03.541]     ...future.conditions <- base::list()
[10:27:03.541]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:03.541]     if (FALSE) {
[10:27:03.541]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:03.541]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:03.541]     }
[10:27:03.541]     ...future.result <- base::tryCatch({
[10:27:03.541]         base::withCallingHandlers({
[10:27:03.541]             ...future.value <- base::withVisible(base::local({
[10:27:03.541]                 withCallingHandlers({
[10:27:03.541]                   {
[10:27:03.541]                     3
[10:27:03.541]                   }
[10:27:03.541]                 }, immediateCondition = function(cond) {
[10:27:03.541]                   save_rds <- function (object, pathname, ...) 
[10:27:03.541]                   {
[10:27:03.541]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:27:03.541]                     if (file_test("-f", pathname_tmp)) {
[10:27:03.541]                       fi_tmp <- file.info(pathname_tmp)
[10:27:03.541]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:27:03.541]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:03.541]                         fi_tmp[["mtime"]])
[10:27:03.541]                     }
[10:27:03.541]                     tryCatch({
[10:27:03.541]                       saveRDS(object, file = pathname_tmp, ...)
[10:27:03.541]                     }, error = function(ex) {
[10:27:03.541]                       msg <- conditionMessage(ex)
[10:27:03.541]                       fi_tmp <- file.info(pathname_tmp)
[10:27:03.541]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:27:03.541]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:03.541]                         fi_tmp[["mtime"]], msg)
[10:27:03.541]                       ex$message <- msg
[10:27:03.541]                       stop(ex)
[10:27:03.541]                     })
[10:27:03.541]                     stopifnot(file_test("-f", pathname_tmp))
[10:27:03.541]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:27:03.541]                     if (!res || file_test("-f", pathname_tmp)) {
[10:27:03.541]                       fi_tmp <- file.info(pathname_tmp)
[10:27:03.541]                       fi <- file.info(pathname)
[10:27:03.541]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:27:03.541]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:27:03.541]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:27:03.541]                         fi[["size"]], fi[["mtime"]])
[10:27:03.541]                       stop(msg)
[10:27:03.541]                     }
[10:27:03.541]                     invisible(pathname)
[10:27:03.541]                   }
[10:27:03.541]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:27:03.541]                     rootPath = tempdir()) 
[10:27:03.541]                   {
[10:27:03.541]                     obj <- list(time = Sys.time(), condition = cond)
[10:27:03.541]                     file <- tempfile(pattern = class(cond)[1], 
[10:27:03.541]                       tmpdir = path, fileext = ".rds")
[10:27:03.541]                     save_rds(obj, file)
[10:27:03.541]                   }
[10:27:03.541]                   saveImmediateCondition(cond, path = "/tmp/RtmpisxSDE/.future/immediateConditions")
[10:27:03.541]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:03.541]                   {
[10:27:03.541]                     inherits <- base::inherits
[10:27:03.541]                     invokeRestart <- base::invokeRestart
[10:27:03.541]                     is.null <- base::is.null
[10:27:03.541]                     muffled <- FALSE
[10:27:03.541]                     if (inherits(cond, "message")) {
[10:27:03.541]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:03.541]                       if (muffled) 
[10:27:03.541]                         invokeRestart("muffleMessage")
[10:27:03.541]                     }
[10:27:03.541]                     else if (inherits(cond, "warning")) {
[10:27:03.541]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:03.541]                       if (muffled) 
[10:27:03.541]                         invokeRestart("muffleWarning")
[10:27:03.541]                     }
[10:27:03.541]                     else if (inherits(cond, "condition")) {
[10:27:03.541]                       if (!is.null(pattern)) {
[10:27:03.541]                         computeRestarts <- base::computeRestarts
[10:27:03.541]                         grepl <- base::grepl
[10:27:03.541]                         restarts <- computeRestarts(cond)
[10:27:03.541]                         for (restart in restarts) {
[10:27:03.541]                           name <- restart$name
[10:27:03.541]                           if (is.null(name)) 
[10:27:03.541]                             next
[10:27:03.541]                           if (!grepl(pattern, name)) 
[10:27:03.541]                             next
[10:27:03.541]                           invokeRestart(restart)
[10:27:03.541]                           muffled <- TRUE
[10:27:03.541]                           break
[10:27:03.541]                         }
[10:27:03.541]                       }
[10:27:03.541]                     }
[10:27:03.541]                     invisible(muffled)
[10:27:03.541]                   }
[10:27:03.541]                   muffleCondition(cond)
[10:27:03.541]                 })
[10:27:03.541]             }))
[10:27:03.541]             future::FutureResult(value = ...future.value$value, 
[10:27:03.541]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:03.541]                   ...future.rng), globalenv = if (FALSE) 
[10:27:03.541]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:03.541]                     ...future.globalenv.names))
[10:27:03.541]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:03.541]         }, condition = base::local({
[10:27:03.541]             c <- base::c
[10:27:03.541]             inherits <- base::inherits
[10:27:03.541]             invokeRestart <- base::invokeRestart
[10:27:03.541]             length <- base::length
[10:27:03.541]             list <- base::list
[10:27:03.541]             seq.int <- base::seq.int
[10:27:03.541]             signalCondition <- base::signalCondition
[10:27:03.541]             sys.calls <- base::sys.calls
[10:27:03.541]             `[[` <- base::`[[`
[10:27:03.541]             `+` <- base::`+`
[10:27:03.541]             `<<-` <- base::`<<-`
[10:27:03.541]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:03.541]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:03.541]                   3L)]
[10:27:03.541]             }
[10:27:03.541]             function(cond) {
[10:27:03.541]                 is_error <- inherits(cond, "error")
[10:27:03.541]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:03.541]                   NULL)
[10:27:03.541]                 if (is_error) {
[10:27:03.541]                   sessionInformation <- function() {
[10:27:03.541]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:03.541]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:03.541]                       search = base::search(), system = base::Sys.info())
[10:27:03.541]                   }
[10:27:03.541]                   ...future.conditions[[length(...future.conditions) + 
[10:27:03.541]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:03.541]                     cond$call), session = sessionInformation(), 
[10:27:03.541]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:03.541]                   signalCondition(cond)
[10:27:03.541]                 }
[10:27:03.541]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:03.541]                 "immediateCondition"))) {
[10:27:03.541]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:03.541]                   ...future.conditions[[length(...future.conditions) + 
[10:27:03.541]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:03.541]                   if (TRUE && !signal) {
[10:27:03.541]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:03.541]                     {
[10:27:03.541]                       inherits <- base::inherits
[10:27:03.541]                       invokeRestart <- base::invokeRestart
[10:27:03.541]                       is.null <- base::is.null
[10:27:03.541]                       muffled <- FALSE
[10:27:03.541]                       if (inherits(cond, "message")) {
[10:27:03.541]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:03.541]                         if (muffled) 
[10:27:03.541]                           invokeRestart("muffleMessage")
[10:27:03.541]                       }
[10:27:03.541]                       else if (inherits(cond, "warning")) {
[10:27:03.541]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:03.541]                         if (muffled) 
[10:27:03.541]                           invokeRestart("muffleWarning")
[10:27:03.541]                       }
[10:27:03.541]                       else if (inherits(cond, "condition")) {
[10:27:03.541]                         if (!is.null(pattern)) {
[10:27:03.541]                           computeRestarts <- base::computeRestarts
[10:27:03.541]                           grepl <- base::grepl
[10:27:03.541]                           restarts <- computeRestarts(cond)
[10:27:03.541]                           for (restart in restarts) {
[10:27:03.541]                             name <- restart$name
[10:27:03.541]                             if (is.null(name)) 
[10:27:03.541]                               next
[10:27:03.541]                             if (!grepl(pattern, name)) 
[10:27:03.541]                               next
[10:27:03.541]                             invokeRestart(restart)
[10:27:03.541]                             muffled <- TRUE
[10:27:03.541]                             break
[10:27:03.541]                           }
[10:27:03.541]                         }
[10:27:03.541]                       }
[10:27:03.541]                       invisible(muffled)
[10:27:03.541]                     }
[10:27:03.541]                     muffleCondition(cond, pattern = "^muffle")
[10:27:03.541]                   }
[10:27:03.541]                 }
[10:27:03.541]                 else {
[10:27:03.541]                   if (TRUE) {
[10:27:03.541]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:03.541]                     {
[10:27:03.541]                       inherits <- base::inherits
[10:27:03.541]                       invokeRestart <- base::invokeRestart
[10:27:03.541]                       is.null <- base::is.null
[10:27:03.541]                       muffled <- FALSE
[10:27:03.541]                       if (inherits(cond, "message")) {
[10:27:03.541]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:03.541]                         if (muffled) 
[10:27:03.541]                           invokeRestart("muffleMessage")
[10:27:03.541]                       }
[10:27:03.541]                       else if (inherits(cond, "warning")) {
[10:27:03.541]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:03.541]                         if (muffled) 
[10:27:03.541]                           invokeRestart("muffleWarning")
[10:27:03.541]                       }
[10:27:03.541]                       else if (inherits(cond, "condition")) {
[10:27:03.541]                         if (!is.null(pattern)) {
[10:27:03.541]                           computeRestarts <- base::computeRestarts
[10:27:03.541]                           grepl <- base::grepl
[10:27:03.541]                           restarts <- computeRestarts(cond)
[10:27:03.541]                           for (restart in restarts) {
[10:27:03.541]                             name <- restart$name
[10:27:03.541]                             if (is.null(name)) 
[10:27:03.541]                               next
[10:27:03.541]                             if (!grepl(pattern, name)) 
[10:27:03.541]                               next
[10:27:03.541]                             invokeRestart(restart)
[10:27:03.541]                             muffled <- TRUE
[10:27:03.541]                             break
[10:27:03.541]                           }
[10:27:03.541]                         }
[10:27:03.541]                       }
[10:27:03.541]                       invisible(muffled)
[10:27:03.541]                     }
[10:27:03.541]                     muffleCondition(cond, pattern = "^muffle")
[10:27:03.541]                   }
[10:27:03.541]                 }
[10:27:03.541]             }
[10:27:03.541]         }))
[10:27:03.541]     }, error = function(ex) {
[10:27:03.541]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:03.541]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:03.541]                 ...future.rng), started = ...future.startTime, 
[10:27:03.541]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:03.541]             version = "1.8"), class = "FutureResult")
[10:27:03.541]     }, finally = {
[10:27:03.541]         if (!identical(...future.workdir, getwd())) 
[10:27:03.541]             setwd(...future.workdir)
[10:27:03.541]         {
[10:27:03.541]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:03.541]                 ...future.oldOptions$nwarnings <- NULL
[10:27:03.541]             }
[10:27:03.541]             base::options(...future.oldOptions)
[10:27:03.541]             if (.Platform$OS.type == "windows") {
[10:27:03.541]                 old_names <- names(...future.oldEnvVars)
[10:27:03.541]                 envs <- base::Sys.getenv()
[10:27:03.541]                 names <- names(envs)
[10:27:03.541]                 common <- intersect(names, old_names)
[10:27:03.541]                 added <- setdiff(names, old_names)
[10:27:03.541]                 removed <- setdiff(old_names, names)
[10:27:03.541]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:03.541]                   envs[common]]
[10:27:03.541]                 NAMES <- toupper(changed)
[10:27:03.541]                 args <- list()
[10:27:03.541]                 for (kk in seq_along(NAMES)) {
[10:27:03.541]                   name <- changed[[kk]]
[10:27:03.541]                   NAME <- NAMES[[kk]]
[10:27:03.541]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:03.541]                     next
[10:27:03.541]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:03.541]                 }
[10:27:03.541]                 NAMES <- toupper(added)
[10:27:03.541]                 for (kk in seq_along(NAMES)) {
[10:27:03.541]                   name <- added[[kk]]
[10:27:03.541]                   NAME <- NAMES[[kk]]
[10:27:03.541]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:03.541]                     next
[10:27:03.541]                   args[[name]] <- ""
[10:27:03.541]                 }
[10:27:03.541]                 NAMES <- toupper(removed)
[10:27:03.541]                 for (kk in seq_along(NAMES)) {
[10:27:03.541]                   name <- removed[[kk]]
[10:27:03.541]                   NAME <- NAMES[[kk]]
[10:27:03.541]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:03.541]                     next
[10:27:03.541]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:03.541]                 }
[10:27:03.541]                 if (length(args) > 0) 
[10:27:03.541]                   base::do.call(base::Sys.setenv, args = args)
[10:27:03.541]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:03.541]             }
[10:27:03.541]             else {
[10:27:03.541]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:03.541]             }
[10:27:03.541]             {
[10:27:03.541]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:03.541]                   0L) {
[10:27:03.541]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:03.541]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:03.541]                   base::options(opts)
[10:27:03.541]                 }
[10:27:03.541]                 {
[10:27:03.541]                   {
[10:27:03.541]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:03.541]                     NULL
[10:27:03.541]                   }
[10:27:03.541]                   options(future.plan = NULL)
[10:27:03.541]                   if (is.na(NA_character_)) 
[10:27:03.541]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:03.541]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:03.541]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:27:03.541]                     envir = parent.frame()) 
[10:27:03.541]                   {
[10:27:03.541]                     default_workers <- missing(workers)
[10:27:03.541]                     if (is.function(workers)) 
[10:27:03.541]                       workers <- workers()
[10:27:03.541]                     workers <- structure(as.integer(workers), 
[10:27:03.541]                       class = class(workers))
[10:27:03.541]                     stop_if_not(is.finite(workers), workers >= 
[10:27:03.541]                       1L)
[10:27:03.541]                     if ((workers == 1L && !inherits(workers, 
[10:27:03.541]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:27:03.541]                       if (default_workers) 
[10:27:03.541]                         supportsMulticore(warn = TRUE)
[10:27:03.541]                       return(sequential(..., envir = envir))
[10:27:03.541]                     }
[10:27:03.541]                     oopts <- options(mc.cores = workers)
[10:27:03.541]                     on.exit(options(oopts))
[10:27:03.541]                     future <- MulticoreFuture(..., workers = workers, 
[10:27:03.541]                       envir = envir)
[10:27:03.541]                     if (!future$lazy) 
[10:27:03.541]                       future <- run(future)
[10:27:03.541]                     invisible(future)
[10:27:03.541]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:03.541]                 }
[10:27:03.541]             }
[10:27:03.541]         }
[10:27:03.541]     })
[10:27:03.541]     if (TRUE) {
[10:27:03.541]         base::sink(type = "output", split = FALSE)
[10:27:03.541]         if (TRUE) {
[10:27:03.541]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:03.541]         }
[10:27:03.541]         else {
[10:27:03.541]             ...future.result["stdout"] <- base::list(NULL)
[10:27:03.541]         }
[10:27:03.541]         base::close(...future.stdout)
[10:27:03.541]         ...future.stdout <- NULL
[10:27:03.541]     }
[10:27:03.541]     ...future.result$conditions <- ...future.conditions
[10:27:03.541]     ...future.result$finished <- base::Sys.time()
[10:27:03.541]     ...future.result
[10:27:03.541] }
[10:27:03.545] requestCore(): workers = 2
[10:27:03.545] Poll #1 (0): usedCores() = 2, workers = 2
[10:27:03.556] result() for MulticoreFuture ...
[10:27:03.558] result() for MulticoreFuture ...
[10:27:03.558] result() for MulticoreFuture ... done
[10:27:03.558] result() for MulticoreFuture ... done
[10:27:03.558] result() for MulticoreFuture ...
[10:27:03.558] result() for MulticoreFuture ... done
[10:27:03.566] MulticoreFuture started
[10:27:03.568] - Launch lazy future ... done
[10:27:03.568] run() for ‘MulticoreFuture’ ... done
[10:27:03.568] plan(): Setting new future strategy stack:
[10:27:03.569] List of future strategies:
[10:27:03.569] 1. sequential:
[10:27:03.569]    - args: function (..., envir = parent.frame())
[10:27:03.569]    - tweaked: FALSE
[10:27:03.569]    - call: NULL
[10:27:03.571] plan(): nbrOfWorkers() = 1
[10:27:03.571] resolve() on list environment ...
[10:27:03.571]  recursive: 0
[10:27:03.574]  length: 4
[10:27:03.574] plan(): Setting new future strategy stack:
[10:27:03.574]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:27:03.575] Future #1
[10:27:03.575]  length: 3 (resolved future 1)
[10:27:03.574] List of future strategies:
[10:27:03.574] 1. multicore:
[10:27:03.574]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:27:03.574]    - tweaked: FALSE
[10:27:03.574]    - call: plan(strategy)
[10:27:03.580] plan(): nbrOfWorkers() = 2
[10:27:03.586] Future #3
[10:27:03.587]  length: 2 (resolved future 3)
[10:27:03.587]  length: 1 (resolved future 4)
[10:27:04.022] plan(): Setting new future strategy stack:
[10:27:04.023] List of future strategies:
[10:27:04.023] 1. multicore:
[10:27:04.023]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:27:04.023]    - tweaked: FALSE
[10:27:04.023]    - call: plan(strategy)
[10:27:04.033] plan(): nbrOfWorkers() = 2
[10:27:04.034] Future #2
[10:27:04.034]  length: 0 (resolved future 2)
[10:27:04.034] resolve() on list environment ... DONE
[10:27:04.035] resolve() on list environment ...
[10:27:04.035]  recursive: 0
[10:27:04.036]  length: 4
[10:27:04.036]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:27:04.036] Future #1
[10:27:04.037]  length: 3 (resolved future 1)
[10:27:04.037] Future #2
[10:27:04.037]  length: 2 (resolved future 2)
[10:27:04.038] Future #3
[10:27:04.038]  length: 1 (resolved future 3)
[10:27:04.038]  length: 0 (resolved future 4)
[10:27:04.038] resolve() on list environment ... DONE
[10:27:04.039] resolve() on list environment ...
[10:27:04.039]  recursive: 0
[10:27:04.040]  length: 4
[10:27:04.040]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:27:04.040] Future #1
[10:27:04.041]  length: 3 (resolved future 1)
[10:27:04.041] Future #2
[10:27:04.041]  length: 2 (resolved future 2)
[10:27:04.041] Future #3
[10:27:04.042]  length: 1 (resolved future 3)
[10:27:04.042]  length: 0 (resolved future 4)
[10:27:04.042] resolve() on list environment ... DONE
[10:27:04.043] resolve() on list environment ...
[10:27:04.043]  recursive: 0
[10:27:04.044]  length: 4
[10:27:04.044]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:27:04.044] Future #1
[10:27:04.044]  length: 3 (resolved future 1)
[10:27:04.045] Future #2
[10:27:04.045]  length: 2 (resolved future 2)
[10:27:04.045] Future #3
[10:27:04.045]  length: 1 (resolved future 3)
[10:27:04.045]  length: 0 (resolved future 4)
[10:27:04.046] resolve() on list environment ... DONE
[10:27:04.046] resolve() on list environment ...
[10:27:04.046]  recursive: 0
[10:27:04.047]  length: 4
[10:27:04.047]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:27:04.048] Future #1
[10:27:04.048] result() for MulticoreFuture ...
[10:27:04.048] result() for MulticoreFuture ... done
[10:27:04.048] result() for MulticoreFuture ...
[10:27:04.048] result() for MulticoreFuture ... done
[10:27:04.048]  length: 3 (resolved future 1)
[10:27:04.049] Future #2
[10:27:04.049] result() for MulticoreFuture ...
[10:27:04.050] result() for MulticoreFuture ...
[10:27:04.050] result() for MulticoreFuture ... done
[10:27:04.050] result() for MulticoreFuture ... done
[10:27:04.050] result() for MulticoreFuture ...
[10:27:04.050] result() for MulticoreFuture ... done
[10:27:04.051]  length: 2 (resolved future 2)
[10:27:04.051] Future #3
[10:27:04.051] result() for MulticoreFuture ...
[10:27:04.052] result() for MulticoreFuture ...
[10:27:04.052] result() for MulticoreFuture ... done
[10:27:04.052] result() for MulticoreFuture ... done
[10:27:04.052] result() for MulticoreFuture ...
[10:27:04.052] result() for MulticoreFuture ... done
[10:27:04.052]  length: 1 (resolved future 3)
[10:27:04.053]  length: 0 (resolved future 4)
[10:27:04.053] resolve() on list environment ... DONE
[10:27:04.054] resolve() on list environment ...
[10:27:04.054]  recursive: 99
[10:27:04.055]  length: 4
[10:27:04.057]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:27:04.058] Future #1
[10:27:04.058] result() for MulticoreFuture ...
[10:27:04.058] result() for MulticoreFuture ... done
[10:27:04.058] result() for MulticoreFuture ...
[10:27:04.058] result() for MulticoreFuture ... done
[10:27:04.059] A MulticoreFuture was resolved
[10:27:04.059]  length: 3 (resolved future 1)
[10:27:04.059] Future #2
[10:27:04.059] result() for MulticoreFuture ...
[10:27:04.059] result() for MulticoreFuture ... done
[10:27:04.059] result() for MulticoreFuture ...
[10:27:04.060] result() for MulticoreFuture ... done
[10:27:04.060] A MulticoreFuture was resolved
[10:27:04.060]  length: 2 (resolved future 2)
[10:27:04.060] Future #3
[10:27:04.060] result() for MulticoreFuture ...
[10:27:04.060] result() for MulticoreFuture ... done
[10:27:04.060] result() for MulticoreFuture ...
[10:27:04.060] result() for MulticoreFuture ... done
[10:27:04.061] A MulticoreFuture was resolved
[10:27:04.061]  length: 1 (resolved future 3)
[10:27:04.061]  length: 0 (resolved future 4)
[10:27:04.061] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('multicore') ...
- plan('multisession') ...
[10:27:04.062] plan(): Setting new future strategy stack:
[10:27:04.062] List of future strategies:
[10:27:04.062] 1. multisession:
[10:27:04.062]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:27:04.062]    - tweaked: FALSE
[10:27:04.062]    - call: plan(strategy)
[10:27:04.062] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:27:04.063] multisession:
[10:27:04.063] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:27:04.063] - tweaked: FALSE
[10:27:04.063] - call: plan(strategy)
[10:27:04.075] getGlobalsAndPackages() ...
[10:27:04.075] Not searching for globals
[10:27:04.075] - globals: [0] <none>
[10:27:04.075] getGlobalsAndPackages() ... DONE
[10:27:04.076] [local output] makeClusterPSOCK() ...
[10:27:04.131] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:27:04.133] [local output] Base port: 11878
[10:27:04.133] [local output] Getting setup options for 2 cluster nodes ...
[10:27:04.133] [local output]  - Node 1 of 2 ...
[10:27:04.133] [local output] localMachine=TRUE => revtunnel=FALSE

[10:27:04.134] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpisxSDE/worker.rank=1.parallelly.parent=90628.1620471f1c2dd.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpisxSDE/worker.rank=1.parallelly.parent=90628.1620471f1c2dd.pid")'’
[10:27:04.343] - Possible to infer worker's PID: TRUE
[10:27:04.343] [local output] Rscript port: 11878

[10:27:04.344] [local output]  - Node 2 of 2 ...
[10:27:04.344] [local output] localMachine=TRUE => revtunnel=FALSE

[10:27:04.345] [local output] Rscript port: 11878

[10:27:04.345] [local output] Getting setup options for 2 cluster nodes ... done
[10:27:04.345] [local output]  - Parallel setup requested for some PSOCK nodes
[10:27:04.346] [local output] Setting up PSOCK nodes in parallel
[10:27:04.346] List of 36
[10:27:04.346]  $ worker          : chr "localhost"
[10:27:04.346]   ..- attr(*, "localhost")= logi TRUE
[10:27:04.346]  $ master          : chr "localhost"
[10:27:04.346]  $ port            : int 11878
[10:27:04.346]  $ connectTimeout  : num 120
[10:27:04.346]  $ timeout         : num 2592000
[10:27:04.346]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:27:04.346]  $ homogeneous     : logi TRUE
[10:27:04.346]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:27:04.346]  $ rscript_envs    : NULL
[10:27:04.346]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:27:04.346]  $ rscript_startup : NULL
[10:27:04.346]  $ rscript_sh      : chr "sh"
[10:27:04.346]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:27:04.346]  $ methods         : logi TRUE
[10:27:04.346]  $ socketOptions   : chr "no-delay"
[10:27:04.346]  $ useXDR          : logi FALSE
[10:27:04.346]  $ outfile         : chr "/dev/null"
[10:27:04.346]  $ renice          : int NA
[10:27:04.346]  $ rshcmd          : NULL
[10:27:04.346]  $ user            : chr(0) 
[10:27:04.346]  $ revtunnel       : logi FALSE
[10:27:04.346]  $ rshlogfile      : NULL
[10:27:04.346]  $ rshopts         : chr(0) 
[10:27:04.346]  $ rank            : int 1
[10:27:04.346]  $ manual          : logi FALSE
[10:27:04.346]  $ dryrun          : logi FALSE
[10:27:04.346]  $ quiet           : logi FALSE
[10:27:04.346]  $ setup_strategy  : chr "parallel"
[10:27:04.346]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:27:04.346]  $ pidfile         : chr "/tmp/RtmpisxSDE/worker.rank=1.parallelly.parent=90628.1620471f1c2dd.pid"
[10:27:04.346]  $ rshcmd_label    : NULL
[10:27:04.346]  $ rsh_call        : NULL
[10:27:04.346]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:27:04.346]  $ localMachine    : logi TRUE
[10:27:04.346]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:27:04.346]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:27:04.346]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:27:04.346]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:27:04.346]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:27:04.346]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:27:04.346]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:27:04.346]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:27:04.346]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:27:04.346]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:27:04.346]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:27:04.346]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:27:04.346]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:27:04.346]  $ arguments       :List of 28
[10:27:04.346]   ..$ worker          : chr "localhost"
[10:27:04.346]   ..$ master          : NULL
[10:27:04.346]   ..$ port            : int 11878
[10:27:04.346]   ..$ connectTimeout  : num 120
[10:27:04.346]   ..$ timeout         : num 2592000
[10:27:04.346]   ..$ rscript         : NULL
[10:27:04.346]   ..$ homogeneous     : NULL
[10:27:04.346]   ..$ rscript_args    : NULL
[10:27:04.346]   ..$ rscript_envs    : NULL
[10:27:04.346]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:27:04.346]   ..$ rscript_startup : NULL
[10:27:04.346]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:27:04.346]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:27:04.346]   ..$ methods         : logi TRUE
[10:27:04.346]   ..$ socketOptions   : chr "no-delay"
[10:27:04.346]   ..$ useXDR          : logi FALSE
[10:27:04.346]   ..$ outfile         : chr "/dev/null"
[10:27:04.346]   ..$ renice          : int NA
[10:27:04.346]   ..$ rshcmd          : NULL
[10:27:04.346]   ..$ user            : NULL
[10:27:04.346]   ..$ revtunnel       : logi NA
[10:27:04.346]   ..$ rshlogfile      : NULL
[10:27:04.346]   ..$ rshopts         : NULL
[10:27:04.346]   ..$ rank            : int 1
[10:27:04.346]   ..$ manual          : logi FALSE
[10:27:04.346]   ..$ dryrun          : logi FALSE
[10:27:04.346]   ..$ quiet           : logi FALSE
[10:27:04.346]   ..$ setup_strategy  : chr "parallel"
[10:27:04.346]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:27:04.364] [local output] System call to launch all workers:
[10:27:04.364] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpisxSDE/worker.rank=1.parallelly.parent=90628.1620471f1c2dd.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11878 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:27:04.364] [local output] Starting PSOCK main server
[10:27:04.371] [local output] Workers launched
[10:27:04.372] [local output] Waiting for workers to connect back
[10:27:04.372]  - [local output] 0 workers out of 2 ready
[10:27:04.638]  - [local output] 0 workers out of 2 ready
[10:27:04.641]  - [local output] 1 workers out of 2 ready
[10:27:04.646]  - [local output] 1 workers out of 2 ready
[10:27:04.646]  - [local output] 2 workers out of 2 ready
[10:27:04.646] [local output] Launching of workers completed
[10:27:04.647] [local output] Collecting session information from workers
[10:27:04.648] [local output]  - Worker #1 of 2
[10:27:04.648] [local output]  - Worker #2 of 2
[10:27:04.648] [local output] makeClusterPSOCK() ... done
[10:27:04.660] Packages needed by the future expression (n = 0): <none>
[10:27:04.660] Packages needed by future strategies (n = 0): <none>
[10:27:04.661] {
[10:27:04.661]     {
[10:27:04.661]         {
[10:27:04.661]             ...future.startTime <- base::Sys.time()
[10:27:04.661]             {
[10:27:04.661]                 {
[10:27:04.661]                   {
[10:27:04.661]                     {
[10:27:04.661]                       base::local({
[10:27:04.661]                         has_future <- base::requireNamespace("future", 
[10:27:04.661]                           quietly = TRUE)
[10:27:04.661]                         if (has_future) {
[10:27:04.661]                           ns <- base::getNamespace("future")
[10:27:04.661]                           version <- ns[[".package"]][["version"]]
[10:27:04.661]                           if (is.null(version)) 
[10:27:04.661]                             version <- utils::packageVersion("future")
[10:27:04.661]                         }
[10:27:04.661]                         else {
[10:27:04.661]                           version <- NULL
[10:27:04.661]                         }
[10:27:04.661]                         if (!has_future || version < "1.8.0") {
[10:27:04.661]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:04.661]                             "", base::R.version$version.string), 
[10:27:04.661]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:04.661]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:04.661]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:04.661]                               "release", "version")], collapse = " "), 
[10:27:04.661]                             hostname = base::Sys.info()[["nodename"]])
[10:27:04.661]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:04.661]                             info)
[10:27:04.661]                           info <- base::paste(info, collapse = "; ")
[10:27:04.661]                           if (!has_future) {
[10:27:04.661]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:04.661]                               info)
[10:27:04.661]                           }
[10:27:04.661]                           else {
[10:27:04.661]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:04.661]                               info, version)
[10:27:04.661]                           }
[10:27:04.661]                           base::stop(msg)
[10:27:04.661]                         }
[10:27:04.661]                       })
[10:27:04.661]                     }
[10:27:04.661]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:04.661]                     base::options(mc.cores = 1L)
[10:27:04.661]                   }
[10:27:04.661]                   options(future.plan = NULL)
[10:27:04.661]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:04.661]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:04.661]                 }
[10:27:04.661]                 ...future.workdir <- getwd()
[10:27:04.661]             }
[10:27:04.661]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:04.661]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:04.661]         }
[10:27:04.661]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:04.661]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:04.661]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:04.661]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:04.661]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:04.661]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:04.661]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:04.661]             base::names(...future.oldOptions))
[10:27:04.661]     }
[10:27:04.661]     if (FALSE) {
[10:27:04.661]     }
[10:27:04.661]     else {
[10:27:04.661]         if (TRUE) {
[10:27:04.661]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:04.661]                 open = "w")
[10:27:04.661]         }
[10:27:04.661]         else {
[10:27:04.661]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:04.661]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:04.661]         }
[10:27:04.661]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:04.661]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:04.661]             base::sink(type = "output", split = FALSE)
[10:27:04.661]             base::close(...future.stdout)
[10:27:04.661]         }, add = TRUE)
[10:27:04.661]     }
[10:27:04.661]     ...future.frame <- base::sys.nframe()
[10:27:04.661]     ...future.conditions <- base::list()
[10:27:04.661]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:04.661]     if (FALSE) {
[10:27:04.661]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:04.661]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:04.661]     }
[10:27:04.661]     ...future.result <- base::tryCatch({
[10:27:04.661]         base::withCallingHandlers({
[10:27:04.661]             ...future.value <- base::withVisible(base::local({
[10:27:04.661]                 ...future.makeSendCondition <- base::local({
[10:27:04.661]                   sendCondition <- NULL
[10:27:04.661]                   function(frame = 1L) {
[10:27:04.661]                     if (is.function(sendCondition)) 
[10:27:04.661]                       return(sendCondition)
[10:27:04.661]                     ns <- getNamespace("parallel")
[10:27:04.661]                     if (exists("sendData", mode = "function", 
[10:27:04.661]                       envir = ns)) {
[10:27:04.661]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:04.661]                         envir = ns)
[10:27:04.661]                       envir <- sys.frame(frame)
[10:27:04.661]                       master <- NULL
[10:27:04.661]                       while (!identical(envir, .GlobalEnv) && 
[10:27:04.661]                         !identical(envir, emptyenv())) {
[10:27:04.661]                         if (exists("master", mode = "list", envir = envir, 
[10:27:04.661]                           inherits = FALSE)) {
[10:27:04.661]                           master <- get("master", mode = "list", 
[10:27:04.661]                             envir = envir, inherits = FALSE)
[10:27:04.661]                           if (inherits(master, c("SOCKnode", 
[10:27:04.661]                             "SOCK0node"))) {
[10:27:04.661]                             sendCondition <<- function(cond) {
[10:27:04.661]                               data <- list(type = "VALUE", value = cond, 
[10:27:04.661]                                 success = TRUE)
[10:27:04.661]                               parallel_sendData(master, data)
[10:27:04.661]                             }
[10:27:04.661]                             return(sendCondition)
[10:27:04.661]                           }
[10:27:04.661]                         }
[10:27:04.661]                         frame <- frame + 1L
[10:27:04.661]                         envir <- sys.frame(frame)
[10:27:04.661]                       }
[10:27:04.661]                     }
[10:27:04.661]                     sendCondition <<- function(cond) NULL
[10:27:04.661]                   }
[10:27:04.661]                 })
[10:27:04.661]                 withCallingHandlers({
[10:27:04.661]                   NA
[10:27:04.661]                 }, immediateCondition = function(cond) {
[10:27:04.661]                   sendCondition <- ...future.makeSendCondition()
[10:27:04.661]                   sendCondition(cond)
[10:27:04.661]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:04.661]                   {
[10:27:04.661]                     inherits <- base::inherits
[10:27:04.661]                     invokeRestart <- base::invokeRestart
[10:27:04.661]                     is.null <- base::is.null
[10:27:04.661]                     muffled <- FALSE
[10:27:04.661]                     if (inherits(cond, "message")) {
[10:27:04.661]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:04.661]                       if (muffled) 
[10:27:04.661]                         invokeRestart("muffleMessage")
[10:27:04.661]                     }
[10:27:04.661]                     else if (inherits(cond, "warning")) {
[10:27:04.661]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:04.661]                       if (muffled) 
[10:27:04.661]                         invokeRestart("muffleWarning")
[10:27:04.661]                     }
[10:27:04.661]                     else if (inherits(cond, "condition")) {
[10:27:04.661]                       if (!is.null(pattern)) {
[10:27:04.661]                         computeRestarts <- base::computeRestarts
[10:27:04.661]                         grepl <- base::grepl
[10:27:04.661]                         restarts <- computeRestarts(cond)
[10:27:04.661]                         for (restart in restarts) {
[10:27:04.661]                           name <- restart$name
[10:27:04.661]                           if (is.null(name)) 
[10:27:04.661]                             next
[10:27:04.661]                           if (!grepl(pattern, name)) 
[10:27:04.661]                             next
[10:27:04.661]                           invokeRestart(restart)
[10:27:04.661]                           muffled <- TRUE
[10:27:04.661]                           break
[10:27:04.661]                         }
[10:27:04.661]                       }
[10:27:04.661]                     }
[10:27:04.661]                     invisible(muffled)
[10:27:04.661]                   }
[10:27:04.661]                   muffleCondition(cond)
[10:27:04.661]                 })
[10:27:04.661]             }))
[10:27:04.661]             future::FutureResult(value = ...future.value$value, 
[10:27:04.661]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:04.661]                   ...future.rng), globalenv = if (FALSE) 
[10:27:04.661]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:04.661]                     ...future.globalenv.names))
[10:27:04.661]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:04.661]         }, condition = base::local({
[10:27:04.661]             c <- base::c
[10:27:04.661]             inherits <- base::inherits
[10:27:04.661]             invokeRestart <- base::invokeRestart
[10:27:04.661]             length <- base::length
[10:27:04.661]             list <- base::list
[10:27:04.661]             seq.int <- base::seq.int
[10:27:04.661]             signalCondition <- base::signalCondition
[10:27:04.661]             sys.calls <- base::sys.calls
[10:27:04.661]             `[[` <- base::`[[`
[10:27:04.661]             `+` <- base::`+`
[10:27:04.661]             `<<-` <- base::`<<-`
[10:27:04.661]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:04.661]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:04.661]                   3L)]
[10:27:04.661]             }
[10:27:04.661]             function(cond) {
[10:27:04.661]                 is_error <- inherits(cond, "error")
[10:27:04.661]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:04.661]                   NULL)
[10:27:04.661]                 if (is_error) {
[10:27:04.661]                   sessionInformation <- function() {
[10:27:04.661]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:04.661]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:04.661]                       search = base::search(), system = base::Sys.info())
[10:27:04.661]                   }
[10:27:04.661]                   ...future.conditions[[length(...future.conditions) + 
[10:27:04.661]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:04.661]                     cond$call), session = sessionInformation(), 
[10:27:04.661]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:04.661]                   signalCondition(cond)
[10:27:04.661]                 }
[10:27:04.661]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:04.661]                 "immediateCondition"))) {
[10:27:04.661]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:04.661]                   ...future.conditions[[length(...future.conditions) + 
[10:27:04.661]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:04.661]                   if (TRUE && !signal) {
[10:27:04.661]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:04.661]                     {
[10:27:04.661]                       inherits <- base::inherits
[10:27:04.661]                       invokeRestart <- base::invokeRestart
[10:27:04.661]                       is.null <- base::is.null
[10:27:04.661]                       muffled <- FALSE
[10:27:04.661]                       if (inherits(cond, "message")) {
[10:27:04.661]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:04.661]                         if (muffled) 
[10:27:04.661]                           invokeRestart("muffleMessage")
[10:27:04.661]                       }
[10:27:04.661]                       else if (inherits(cond, "warning")) {
[10:27:04.661]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:04.661]                         if (muffled) 
[10:27:04.661]                           invokeRestart("muffleWarning")
[10:27:04.661]                       }
[10:27:04.661]                       else if (inherits(cond, "condition")) {
[10:27:04.661]                         if (!is.null(pattern)) {
[10:27:04.661]                           computeRestarts <- base::computeRestarts
[10:27:04.661]                           grepl <- base::grepl
[10:27:04.661]                           restarts <- computeRestarts(cond)
[10:27:04.661]                           for (restart in restarts) {
[10:27:04.661]                             name <- restart$name
[10:27:04.661]                             if (is.null(name)) 
[10:27:04.661]                               next
[10:27:04.661]                             if (!grepl(pattern, name)) 
[10:27:04.661]                               next
[10:27:04.661]                             invokeRestart(restart)
[10:27:04.661]                             muffled <- TRUE
[10:27:04.661]                             break
[10:27:04.661]                           }
[10:27:04.661]                         }
[10:27:04.661]                       }
[10:27:04.661]                       invisible(muffled)
[10:27:04.661]                     }
[10:27:04.661]                     muffleCondition(cond, pattern = "^muffle")
[10:27:04.661]                   }
[10:27:04.661]                 }
[10:27:04.661]                 else {
[10:27:04.661]                   if (TRUE) {
[10:27:04.661]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:04.661]                     {
[10:27:04.661]                       inherits <- base::inherits
[10:27:04.661]                       invokeRestart <- base::invokeRestart
[10:27:04.661]                       is.null <- base::is.null
[10:27:04.661]                       muffled <- FALSE
[10:27:04.661]                       if (inherits(cond, "message")) {
[10:27:04.661]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:04.661]                         if (muffled) 
[10:27:04.661]                           invokeRestart("muffleMessage")
[10:27:04.661]                       }
[10:27:04.661]                       else if (inherits(cond, "warning")) {
[10:27:04.661]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:04.661]                         if (muffled) 
[10:27:04.661]                           invokeRestart("muffleWarning")
[10:27:04.661]                       }
[10:27:04.661]                       else if (inherits(cond, "condition")) {
[10:27:04.661]                         if (!is.null(pattern)) {
[10:27:04.661]                           computeRestarts <- base::computeRestarts
[10:27:04.661]                           grepl <- base::grepl
[10:27:04.661]                           restarts <- computeRestarts(cond)
[10:27:04.661]                           for (restart in restarts) {
[10:27:04.661]                             name <- restart$name
[10:27:04.661]                             if (is.null(name)) 
[10:27:04.661]                               next
[10:27:04.661]                             if (!grepl(pattern, name)) 
[10:27:04.661]                               next
[10:27:04.661]                             invokeRestart(restart)
[10:27:04.661]                             muffled <- TRUE
[10:27:04.661]                             break
[10:27:04.661]                           }
[10:27:04.661]                         }
[10:27:04.661]                       }
[10:27:04.661]                       invisible(muffled)
[10:27:04.661]                     }
[10:27:04.661]                     muffleCondition(cond, pattern = "^muffle")
[10:27:04.661]                   }
[10:27:04.661]                 }
[10:27:04.661]             }
[10:27:04.661]         }))
[10:27:04.661]     }, error = function(ex) {
[10:27:04.661]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:04.661]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:04.661]                 ...future.rng), started = ...future.startTime, 
[10:27:04.661]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:04.661]             version = "1.8"), class = "FutureResult")
[10:27:04.661]     }, finally = {
[10:27:04.661]         if (!identical(...future.workdir, getwd())) 
[10:27:04.661]             setwd(...future.workdir)
[10:27:04.661]         {
[10:27:04.661]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:04.661]                 ...future.oldOptions$nwarnings <- NULL
[10:27:04.661]             }
[10:27:04.661]             base::options(...future.oldOptions)
[10:27:04.661]             if (.Platform$OS.type == "windows") {
[10:27:04.661]                 old_names <- names(...future.oldEnvVars)
[10:27:04.661]                 envs <- base::Sys.getenv()
[10:27:04.661]                 names <- names(envs)
[10:27:04.661]                 common <- intersect(names, old_names)
[10:27:04.661]                 added <- setdiff(names, old_names)
[10:27:04.661]                 removed <- setdiff(old_names, names)
[10:27:04.661]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:04.661]                   envs[common]]
[10:27:04.661]                 NAMES <- toupper(changed)
[10:27:04.661]                 args <- list()
[10:27:04.661]                 for (kk in seq_along(NAMES)) {
[10:27:04.661]                   name <- changed[[kk]]
[10:27:04.661]                   NAME <- NAMES[[kk]]
[10:27:04.661]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:04.661]                     next
[10:27:04.661]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:04.661]                 }
[10:27:04.661]                 NAMES <- toupper(added)
[10:27:04.661]                 for (kk in seq_along(NAMES)) {
[10:27:04.661]                   name <- added[[kk]]
[10:27:04.661]                   NAME <- NAMES[[kk]]
[10:27:04.661]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:04.661]                     next
[10:27:04.661]                   args[[name]] <- ""
[10:27:04.661]                 }
[10:27:04.661]                 NAMES <- toupper(removed)
[10:27:04.661]                 for (kk in seq_along(NAMES)) {
[10:27:04.661]                   name <- removed[[kk]]
[10:27:04.661]                   NAME <- NAMES[[kk]]
[10:27:04.661]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:04.661]                     next
[10:27:04.661]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:04.661]                 }
[10:27:04.661]                 if (length(args) > 0) 
[10:27:04.661]                   base::do.call(base::Sys.setenv, args = args)
[10:27:04.661]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:04.661]             }
[10:27:04.661]             else {
[10:27:04.661]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:04.661]             }
[10:27:04.661]             {
[10:27:04.661]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:04.661]                   0L) {
[10:27:04.661]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:04.661]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:04.661]                   base::options(opts)
[10:27:04.661]                 }
[10:27:04.661]                 {
[10:27:04.661]                   {
[10:27:04.661]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:04.661]                     NULL
[10:27:04.661]                   }
[10:27:04.661]                   options(future.plan = NULL)
[10:27:04.661]                   if (is.na(NA_character_)) 
[10:27:04.661]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:04.661]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:04.661]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:04.661]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:04.661]                     envir = parent.frame()) 
[10:27:04.661]                   {
[10:27:04.661]                     if (is.function(workers)) 
[10:27:04.661]                       workers <- workers()
[10:27:04.661]                     workers <- structure(as.integer(workers), 
[10:27:04.661]                       class = class(workers))
[10:27:04.661]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:04.661]                       workers >= 1)
[10:27:04.661]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:04.661]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:04.661]                     }
[10:27:04.661]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:04.661]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:04.661]                       envir = envir)
[10:27:04.661]                     if (!future$lazy) 
[10:27:04.661]                       future <- run(future)
[10:27:04.661]                     invisible(future)
[10:27:04.661]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:04.661]                 }
[10:27:04.661]             }
[10:27:04.661]         }
[10:27:04.661]     })
[10:27:04.661]     if (TRUE) {
[10:27:04.661]         base::sink(type = "output", split = FALSE)
[10:27:04.661]         if (TRUE) {
[10:27:04.661]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:04.661]         }
[10:27:04.661]         else {
[10:27:04.661]             ...future.result["stdout"] <- base::list(NULL)
[10:27:04.661]         }
[10:27:04.661]         base::close(...future.stdout)
[10:27:04.661]         ...future.stdout <- NULL
[10:27:04.661]     }
[10:27:04.661]     ...future.result$conditions <- ...future.conditions
[10:27:04.661]     ...future.result$finished <- base::Sys.time()
[10:27:04.661]     ...future.result
[10:27:04.661] }
[10:27:04.715] MultisessionFuture started
[10:27:04.716] result() for ClusterFuture ...
[10:27:04.716] receiveMessageFromWorker() for ClusterFuture ...
[10:27:04.716] - Validating connection of MultisessionFuture
[10:27:04.769] - received message: FutureResult
[10:27:04.769] - Received FutureResult
[10:27:04.770] - Erased future from FutureRegistry
[10:27:04.770] result() for ClusterFuture ...
[10:27:04.770] - result already collected: FutureResult
[10:27:04.770] result() for ClusterFuture ... done
[10:27:04.771] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:04.771] result() for ClusterFuture ... done
[10:27:04.771] result() for ClusterFuture ...
[10:27:04.771] - result already collected: FutureResult
[10:27:04.771] result() for ClusterFuture ... done
[10:27:04.771] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:27:04.778] plan(): nbrOfWorkers() = 2
*** resolve() for Future objects ...
- result = FALSE, recursive = FALSE ...
[10:27:04.785] getGlobalsAndPackages() ...
[10:27:04.785] Searching for globals...
[10:27:04.787] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:27:04.787] Searching for globals ... DONE
[10:27:04.787] Resolving globals: FALSE
[10:27:04.788] 
[10:27:04.788] 
[10:27:04.788] getGlobalsAndPackages() ... DONE
[10:27:04.788] run() for ‘Future’ ...
[10:27:04.788] - state: ‘created’
[10:27:04.788] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:04.803] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:04.804] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:04.804]   - Field: ‘node’
[10:27:04.804]   - Field: ‘label’
[10:27:04.804]   - Field: ‘local’
[10:27:04.804]   - Field: ‘owner’
[10:27:04.804]   - Field: ‘envir’
[10:27:04.804]   - Field: ‘workers’
[10:27:04.804]   - Field: ‘packages’
[10:27:04.805]   - Field: ‘gc’
[10:27:04.805]   - Field: ‘conditions’
[10:27:04.805]   - Field: ‘persistent’
[10:27:04.805]   - Field: ‘expr’
[10:27:04.805]   - Field: ‘uuid’
[10:27:04.805]   - Field: ‘seed’
[10:27:04.805]   - Field: ‘version’
[10:27:04.805]   - Field: ‘result’
[10:27:04.805]   - Field: ‘asynchronous’
[10:27:04.806]   - Field: ‘calls’
[10:27:04.806]   - Field: ‘globals’
[10:27:04.806]   - Field: ‘stdout’
[10:27:04.806]   - Field: ‘earlySignal’
[10:27:04.806]   - Field: ‘lazy’
[10:27:04.806]   - Field: ‘state’
[10:27:04.806] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:04.806] - Launch lazy future ...
[10:27:04.807] Packages needed by the future expression (n = 0): <none>
[10:27:04.807] Packages needed by future strategies (n = 0): <none>
[10:27:04.808] {
[10:27:04.808]     {
[10:27:04.808]         {
[10:27:04.808]             ...future.startTime <- base::Sys.time()
[10:27:04.808]             {
[10:27:04.808]                 {
[10:27:04.808]                   {
[10:27:04.808]                     {
[10:27:04.808]                       base::local({
[10:27:04.808]                         has_future <- base::requireNamespace("future", 
[10:27:04.808]                           quietly = TRUE)
[10:27:04.808]                         if (has_future) {
[10:27:04.808]                           ns <- base::getNamespace("future")
[10:27:04.808]                           version <- ns[[".package"]][["version"]]
[10:27:04.808]                           if (is.null(version)) 
[10:27:04.808]                             version <- utils::packageVersion("future")
[10:27:04.808]                         }
[10:27:04.808]                         else {
[10:27:04.808]                           version <- NULL
[10:27:04.808]                         }
[10:27:04.808]                         if (!has_future || version < "1.8.0") {
[10:27:04.808]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:04.808]                             "", base::R.version$version.string), 
[10:27:04.808]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:04.808]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:04.808]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:04.808]                               "release", "version")], collapse = " "), 
[10:27:04.808]                             hostname = base::Sys.info()[["nodename"]])
[10:27:04.808]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:04.808]                             info)
[10:27:04.808]                           info <- base::paste(info, collapse = "; ")
[10:27:04.808]                           if (!has_future) {
[10:27:04.808]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:04.808]                               info)
[10:27:04.808]                           }
[10:27:04.808]                           else {
[10:27:04.808]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:04.808]                               info, version)
[10:27:04.808]                           }
[10:27:04.808]                           base::stop(msg)
[10:27:04.808]                         }
[10:27:04.808]                       })
[10:27:04.808]                     }
[10:27:04.808]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:04.808]                     base::options(mc.cores = 1L)
[10:27:04.808]                   }
[10:27:04.808]                   options(future.plan = NULL)
[10:27:04.808]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:04.808]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:04.808]                 }
[10:27:04.808]                 ...future.workdir <- getwd()
[10:27:04.808]             }
[10:27:04.808]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:04.808]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:04.808]         }
[10:27:04.808]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:04.808]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:04.808]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:04.808]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:04.808]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:04.808]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:04.808]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:04.808]             base::names(...future.oldOptions))
[10:27:04.808]     }
[10:27:04.808]     if (FALSE) {
[10:27:04.808]     }
[10:27:04.808]     else {
[10:27:04.808]         if (TRUE) {
[10:27:04.808]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:04.808]                 open = "w")
[10:27:04.808]         }
[10:27:04.808]         else {
[10:27:04.808]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:04.808]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:04.808]         }
[10:27:04.808]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:04.808]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:04.808]             base::sink(type = "output", split = FALSE)
[10:27:04.808]             base::close(...future.stdout)
[10:27:04.808]         }, add = TRUE)
[10:27:04.808]     }
[10:27:04.808]     ...future.frame <- base::sys.nframe()
[10:27:04.808]     ...future.conditions <- base::list()
[10:27:04.808]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:04.808]     if (FALSE) {
[10:27:04.808]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:04.808]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:04.808]     }
[10:27:04.808]     ...future.result <- base::tryCatch({
[10:27:04.808]         base::withCallingHandlers({
[10:27:04.808]             ...future.value <- base::withVisible(base::local({
[10:27:04.808]                 ...future.makeSendCondition <- base::local({
[10:27:04.808]                   sendCondition <- NULL
[10:27:04.808]                   function(frame = 1L) {
[10:27:04.808]                     if (is.function(sendCondition)) 
[10:27:04.808]                       return(sendCondition)
[10:27:04.808]                     ns <- getNamespace("parallel")
[10:27:04.808]                     if (exists("sendData", mode = "function", 
[10:27:04.808]                       envir = ns)) {
[10:27:04.808]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:04.808]                         envir = ns)
[10:27:04.808]                       envir <- sys.frame(frame)
[10:27:04.808]                       master <- NULL
[10:27:04.808]                       while (!identical(envir, .GlobalEnv) && 
[10:27:04.808]                         !identical(envir, emptyenv())) {
[10:27:04.808]                         if (exists("master", mode = "list", envir = envir, 
[10:27:04.808]                           inherits = FALSE)) {
[10:27:04.808]                           master <- get("master", mode = "list", 
[10:27:04.808]                             envir = envir, inherits = FALSE)
[10:27:04.808]                           if (inherits(master, c("SOCKnode", 
[10:27:04.808]                             "SOCK0node"))) {
[10:27:04.808]                             sendCondition <<- function(cond) {
[10:27:04.808]                               data <- list(type = "VALUE", value = cond, 
[10:27:04.808]                                 success = TRUE)
[10:27:04.808]                               parallel_sendData(master, data)
[10:27:04.808]                             }
[10:27:04.808]                             return(sendCondition)
[10:27:04.808]                           }
[10:27:04.808]                         }
[10:27:04.808]                         frame <- frame + 1L
[10:27:04.808]                         envir <- sys.frame(frame)
[10:27:04.808]                       }
[10:27:04.808]                     }
[10:27:04.808]                     sendCondition <<- function(cond) NULL
[10:27:04.808]                   }
[10:27:04.808]                 })
[10:27:04.808]                 withCallingHandlers({
[10:27:04.808]                   {
[10:27:04.808]                     Sys.sleep(0.5)
[10:27:04.808]                     list(a = 1, b = 42L)
[10:27:04.808]                   }
[10:27:04.808]                 }, immediateCondition = function(cond) {
[10:27:04.808]                   sendCondition <- ...future.makeSendCondition()
[10:27:04.808]                   sendCondition(cond)
[10:27:04.808]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:04.808]                   {
[10:27:04.808]                     inherits <- base::inherits
[10:27:04.808]                     invokeRestart <- base::invokeRestart
[10:27:04.808]                     is.null <- base::is.null
[10:27:04.808]                     muffled <- FALSE
[10:27:04.808]                     if (inherits(cond, "message")) {
[10:27:04.808]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:04.808]                       if (muffled) 
[10:27:04.808]                         invokeRestart("muffleMessage")
[10:27:04.808]                     }
[10:27:04.808]                     else if (inherits(cond, "warning")) {
[10:27:04.808]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:04.808]                       if (muffled) 
[10:27:04.808]                         invokeRestart("muffleWarning")
[10:27:04.808]                     }
[10:27:04.808]                     else if (inherits(cond, "condition")) {
[10:27:04.808]                       if (!is.null(pattern)) {
[10:27:04.808]                         computeRestarts <- base::computeRestarts
[10:27:04.808]                         grepl <- base::grepl
[10:27:04.808]                         restarts <- computeRestarts(cond)
[10:27:04.808]                         for (restart in restarts) {
[10:27:04.808]                           name <- restart$name
[10:27:04.808]                           if (is.null(name)) 
[10:27:04.808]                             next
[10:27:04.808]                           if (!grepl(pattern, name)) 
[10:27:04.808]                             next
[10:27:04.808]                           invokeRestart(restart)
[10:27:04.808]                           muffled <- TRUE
[10:27:04.808]                           break
[10:27:04.808]                         }
[10:27:04.808]                       }
[10:27:04.808]                     }
[10:27:04.808]                     invisible(muffled)
[10:27:04.808]                   }
[10:27:04.808]                   muffleCondition(cond)
[10:27:04.808]                 })
[10:27:04.808]             }))
[10:27:04.808]             future::FutureResult(value = ...future.value$value, 
[10:27:04.808]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:04.808]                   ...future.rng), globalenv = if (FALSE) 
[10:27:04.808]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:04.808]                     ...future.globalenv.names))
[10:27:04.808]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:04.808]         }, condition = base::local({
[10:27:04.808]             c <- base::c
[10:27:04.808]             inherits <- base::inherits
[10:27:04.808]             invokeRestart <- base::invokeRestart
[10:27:04.808]             length <- base::length
[10:27:04.808]             list <- base::list
[10:27:04.808]             seq.int <- base::seq.int
[10:27:04.808]             signalCondition <- base::signalCondition
[10:27:04.808]             sys.calls <- base::sys.calls
[10:27:04.808]             `[[` <- base::`[[`
[10:27:04.808]             `+` <- base::`+`
[10:27:04.808]             `<<-` <- base::`<<-`
[10:27:04.808]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:04.808]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:04.808]                   3L)]
[10:27:04.808]             }
[10:27:04.808]             function(cond) {
[10:27:04.808]                 is_error <- inherits(cond, "error")
[10:27:04.808]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:04.808]                   NULL)
[10:27:04.808]                 if (is_error) {
[10:27:04.808]                   sessionInformation <- function() {
[10:27:04.808]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:04.808]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:04.808]                       search = base::search(), system = base::Sys.info())
[10:27:04.808]                   }
[10:27:04.808]                   ...future.conditions[[length(...future.conditions) + 
[10:27:04.808]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:04.808]                     cond$call), session = sessionInformation(), 
[10:27:04.808]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:04.808]                   signalCondition(cond)
[10:27:04.808]                 }
[10:27:04.808]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:04.808]                 "immediateCondition"))) {
[10:27:04.808]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:04.808]                   ...future.conditions[[length(...future.conditions) + 
[10:27:04.808]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:04.808]                   if (TRUE && !signal) {
[10:27:04.808]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:04.808]                     {
[10:27:04.808]                       inherits <- base::inherits
[10:27:04.808]                       invokeRestart <- base::invokeRestart
[10:27:04.808]                       is.null <- base::is.null
[10:27:04.808]                       muffled <- FALSE
[10:27:04.808]                       if (inherits(cond, "message")) {
[10:27:04.808]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:04.808]                         if (muffled) 
[10:27:04.808]                           invokeRestart("muffleMessage")
[10:27:04.808]                       }
[10:27:04.808]                       else if (inherits(cond, "warning")) {
[10:27:04.808]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:04.808]                         if (muffled) 
[10:27:04.808]                           invokeRestart("muffleWarning")
[10:27:04.808]                       }
[10:27:04.808]                       else if (inherits(cond, "condition")) {
[10:27:04.808]                         if (!is.null(pattern)) {
[10:27:04.808]                           computeRestarts <- base::computeRestarts
[10:27:04.808]                           grepl <- base::grepl
[10:27:04.808]                           restarts <- computeRestarts(cond)
[10:27:04.808]                           for (restart in restarts) {
[10:27:04.808]                             name <- restart$name
[10:27:04.808]                             if (is.null(name)) 
[10:27:04.808]                               next
[10:27:04.808]                             if (!grepl(pattern, name)) 
[10:27:04.808]                               next
[10:27:04.808]                             invokeRestart(restart)
[10:27:04.808]                             muffled <- TRUE
[10:27:04.808]                             break
[10:27:04.808]                           }
[10:27:04.808]                         }
[10:27:04.808]                       }
[10:27:04.808]                       invisible(muffled)
[10:27:04.808]                     }
[10:27:04.808]                     muffleCondition(cond, pattern = "^muffle")
[10:27:04.808]                   }
[10:27:04.808]                 }
[10:27:04.808]                 else {
[10:27:04.808]                   if (TRUE) {
[10:27:04.808]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:04.808]                     {
[10:27:04.808]                       inherits <- base::inherits
[10:27:04.808]                       invokeRestart <- base::invokeRestart
[10:27:04.808]                       is.null <- base::is.null
[10:27:04.808]                       muffled <- FALSE
[10:27:04.808]                       if (inherits(cond, "message")) {
[10:27:04.808]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:04.808]                         if (muffled) 
[10:27:04.808]                           invokeRestart("muffleMessage")
[10:27:04.808]                       }
[10:27:04.808]                       else if (inherits(cond, "warning")) {
[10:27:04.808]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:04.808]                         if (muffled) 
[10:27:04.808]                           invokeRestart("muffleWarning")
[10:27:04.808]                       }
[10:27:04.808]                       else if (inherits(cond, "condition")) {
[10:27:04.808]                         if (!is.null(pattern)) {
[10:27:04.808]                           computeRestarts <- base::computeRestarts
[10:27:04.808]                           grepl <- base::grepl
[10:27:04.808]                           restarts <- computeRestarts(cond)
[10:27:04.808]                           for (restart in restarts) {
[10:27:04.808]                             name <- restart$name
[10:27:04.808]                             if (is.null(name)) 
[10:27:04.808]                               next
[10:27:04.808]                             if (!grepl(pattern, name)) 
[10:27:04.808]                               next
[10:27:04.808]                             invokeRestart(restart)
[10:27:04.808]                             muffled <- TRUE
[10:27:04.808]                             break
[10:27:04.808]                           }
[10:27:04.808]                         }
[10:27:04.808]                       }
[10:27:04.808]                       invisible(muffled)
[10:27:04.808]                     }
[10:27:04.808]                     muffleCondition(cond, pattern = "^muffle")
[10:27:04.808]                   }
[10:27:04.808]                 }
[10:27:04.808]             }
[10:27:04.808]         }))
[10:27:04.808]     }, error = function(ex) {
[10:27:04.808]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:04.808]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:04.808]                 ...future.rng), started = ...future.startTime, 
[10:27:04.808]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:04.808]             version = "1.8"), class = "FutureResult")
[10:27:04.808]     }, finally = {
[10:27:04.808]         if (!identical(...future.workdir, getwd())) 
[10:27:04.808]             setwd(...future.workdir)
[10:27:04.808]         {
[10:27:04.808]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:04.808]                 ...future.oldOptions$nwarnings <- NULL
[10:27:04.808]             }
[10:27:04.808]             base::options(...future.oldOptions)
[10:27:04.808]             if (.Platform$OS.type == "windows") {
[10:27:04.808]                 old_names <- names(...future.oldEnvVars)
[10:27:04.808]                 envs <- base::Sys.getenv()
[10:27:04.808]                 names <- names(envs)
[10:27:04.808]                 common <- intersect(names, old_names)
[10:27:04.808]                 added <- setdiff(names, old_names)
[10:27:04.808]                 removed <- setdiff(old_names, names)
[10:27:04.808]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:04.808]                   envs[common]]
[10:27:04.808]                 NAMES <- toupper(changed)
[10:27:04.808]                 args <- list()
[10:27:04.808]                 for (kk in seq_along(NAMES)) {
[10:27:04.808]                   name <- changed[[kk]]
[10:27:04.808]                   NAME <- NAMES[[kk]]
[10:27:04.808]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:04.808]                     next
[10:27:04.808]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:04.808]                 }
[10:27:04.808]                 NAMES <- toupper(added)
[10:27:04.808]                 for (kk in seq_along(NAMES)) {
[10:27:04.808]                   name <- added[[kk]]
[10:27:04.808]                   NAME <- NAMES[[kk]]
[10:27:04.808]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:04.808]                     next
[10:27:04.808]                   args[[name]] <- ""
[10:27:04.808]                 }
[10:27:04.808]                 NAMES <- toupper(removed)
[10:27:04.808]                 for (kk in seq_along(NAMES)) {
[10:27:04.808]                   name <- removed[[kk]]
[10:27:04.808]                   NAME <- NAMES[[kk]]
[10:27:04.808]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:04.808]                     next
[10:27:04.808]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:04.808]                 }
[10:27:04.808]                 if (length(args) > 0) 
[10:27:04.808]                   base::do.call(base::Sys.setenv, args = args)
[10:27:04.808]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:04.808]             }
[10:27:04.808]             else {
[10:27:04.808]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:04.808]             }
[10:27:04.808]             {
[10:27:04.808]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:04.808]                   0L) {
[10:27:04.808]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:04.808]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:04.808]                   base::options(opts)
[10:27:04.808]                 }
[10:27:04.808]                 {
[10:27:04.808]                   {
[10:27:04.808]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:04.808]                     NULL
[10:27:04.808]                   }
[10:27:04.808]                   options(future.plan = NULL)
[10:27:04.808]                   if (is.na(NA_character_)) 
[10:27:04.808]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:04.808]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:04.808]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:04.808]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:04.808]                     envir = parent.frame()) 
[10:27:04.808]                   {
[10:27:04.808]                     if (is.function(workers)) 
[10:27:04.808]                       workers <- workers()
[10:27:04.808]                     workers <- structure(as.integer(workers), 
[10:27:04.808]                       class = class(workers))
[10:27:04.808]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:04.808]                       workers >= 1)
[10:27:04.808]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:04.808]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:04.808]                     }
[10:27:04.808]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:04.808]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:04.808]                       envir = envir)
[10:27:04.808]                     if (!future$lazy) 
[10:27:04.808]                       future <- run(future)
[10:27:04.808]                     invisible(future)
[10:27:04.808]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:04.808]                 }
[10:27:04.808]             }
[10:27:04.808]         }
[10:27:04.808]     })
[10:27:04.808]     if (TRUE) {
[10:27:04.808]         base::sink(type = "output", split = FALSE)
[10:27:04.808]         if (TRUE) {
[10:27:04.808]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:04.808]         }
[10:27:04.808]         else {
[10:27:04.808]             ...future.result["stdout"] <- base::list(NULL)
[10:27:04.808]         }
[10:27:04.808]         base::close(...future.stdout)
[10:27:04.808]         ...future.stdout <- NULL
[10:27:04.808]     }
[10:27:04.808]     ...future.result$conditions <- ...future.conditions
[10:27:04.808]     ...future.result$finished <- base::Sys.time()
[10:27:04.808]     ...future.result
[10:27:04.808] }
[10:27:04.811] MultisessionFuture started
[10:27:04.811] - Launch lazy future ... done
[10:27:04.811] run() for ‘MultisessionFuture’ ... done
[10:27:05.360] receiveMessageFromWorker() for ClusterFuture ...
[10:27:05.360] - Validating connection of MultisessionFuture
[10:27:05.360] - received message: FutureResult
[10:27:05.361] - Received FutureResult
[10:27:05.361] - Erased future from FutureRegistry
[10:27:05.361] result() for ClusterFuture ...
[10:27:05.361] - result already collected: FutureResult
[10:27:05.362] result() for ClusterFuture ... done
[10:27:05.362] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:05.362] A MultisessionFuture was resolved (result was not collected)
[10:27:05.363] getGlobalsAndPackages() ...
[10:27:05.363] Searching for globals...
[10:27:05.365] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:27:05.365] Searching for globals ... DONE
[10:27:05.366] Resolving globals: FALSE
[10:27:05.368] 
[10:27:05.368] 
[10:27:05.369] getGlobalsAndPackages() ... DONE
[10:27:05.369] run() for ‘Future’ ...
[10:27:05.370] - state: ‘created’
[10:27:05.370] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:05.385] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:05.385] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:05.385]   - Field: ‘node’
[10:27:05.385]   - Field: ‘label’
[10:27:05.385]   - Field: ‘local’
[10:27:05.385]   - Field: ‘owner’
[10:27:05.385]   - Field: ‘envir’
[10:27:05.385]   - Field: ‘workers’
[10:27:05.386]   - Field: ‘packages’
[10:27:05.386]   - Field: ‘gc’
[10:27:05.386]   - Field: ‘conditions’
[10:27:05.386]   - Field: ‘persistent’
[10:27:05.386]   - Field: ‘expr’
[10:27:05.386]   - Field: ‘uuid’
[10:27:05.386]   - Field: ‘seed’
[10:27:05.386]   - Field: ‘version’
[10:27:05.386]   - Field: ‘result’
[10:27:05.387]   - Field: ‘asynchronous’
[10:27:05.387]   - Field: ‘calls’
[10:27:05.387]   - Field: ‘globals’
[10:27:05.387]   - Field: ‘stdout’
[10:27:05.387]   - Field: ‘earlySignal’
[10:27:05.387]   - Field: ‘lazy’
[10:27:05.387]   - Field: ‘state’
[10:27:05.387] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:05.388] - Launch lazy future ...
[10:27:05.388] Packages needed by the future expression (n = 0): <none>
[10:27:05.388] Packages needed by future strategies (n = 0): <none>
[10:27:05.389] {
[10:27:05.389]     {
[10:27:05.389]         {
[10:27:05.389]             ...future.startTime <- base::Sys.time()
[10:27:05.389]             {
[10:27:05.389]                 {
[10:27:05.389]                   {
[10:27:05.389]                     {
[10:27:05.389]                       base::local({
[10:27:05.389]                         has_future <- base::requireNamespace("future", 
[10:27:05.389]                           quietly = TRUE)
[10:27:05.389]                         if (has_future) {
[10:27:05.389]                           ns <- base::getNamespace("future")
[10:27:05.389]                           version <- ns[[".package"]][["version"]]
[10:27:05.389]                           if (is.null(version)) 
[10:27:05.389]                             version <- utils::packageVersion("future")
[10:27:05.389]                         }
[10:27:05.389]                         else {
[10:27:05.389]                           version <- NULL
[10:27:05.389]                         }
[10:27:05.389]                         if (!has_future || version < "1.8.0") {
[10:27:05.389]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:05.389]                             "", base::R.version$version.string), 
[10:27:05.389]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:05.389]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:05.389]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:05.389]                               "release", "version")], collapse = " "), 
[10:27:05.389]                             hostname = base::Sys.info()[["nodename"]])
[10:27:05.389]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:05.389]                             info)
[10:27:05.389]                           info <- base::paste(info, collapse = "; ")
[10:27:05.389]                           if (!has_future) {
[10:27:05.389]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:05.389]                               info)
[10:27:05.389]                           }
[10:27:05.389]                           else {
[10:27:05.389]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:05.389]                               info, version)
[10:27:05.389]                           }
[10:27:05.389]                           base::stop(msg)
[10:27:05.389]                         }
[10:27:05.389]                       })
[10:27:05.389]                     }
[10:27:05.389]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:05.389]                     base::options(mc.cores = 1L)
[10:27:05.389]                   }
[10:27:05.389]                   options(future.plan = NULL)
[10:27:05.389]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:05.389]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:05.389]                 }
[10:27:05.389]                 ...future.workdir <- getwd()
[10:27:05.389]             }
[10:27:05.389]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:05.389]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:05.389]         }
[10:27:05.389]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:05.389]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:05.389]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:05.389]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:05.389]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:05.389]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:05.389]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:05.389]             base::names(...future.oldOptions))
[10:27:05.389]     }
[10:27:05.389]     if (FALSE) {
[10:27:05.389]     }
[10:27:05.389]     else {
[10:27:05.389]         if (TRUE) {
[10:27:05.389]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:05.389]                 open = "w")
[10:27:05.389]         }
[10:27:05.389]         else {
[10:27:05.389]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:05.389]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:05.389]         }
[10:27:05.389]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:05.389]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:05.389]             base::sink(type = "output", split = FALSE)
[10:27:05.389]             base::close(...future.stdout)
[10:27:05.389]         }, add = TRUE)
[10:27:05.389]     }
[10:27:05.389]     ...future.frame <- base::sys.nframe()
[10:27:05.389]     ...future.conditions <- base::list()
[10:27:05.389]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:05.389]     if (FALSE) {
[10:27:05.389]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:05.389]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:05.389]     }
[10:27:05.389]     ...future.result <- base::tryCatch({
[10:27:05.389]         base::withCallingHandlers({
[10:27:05.389]             ...future.value <- base::withVisible(base::local({
[10:27:05.389]                 ...future.makeSendCondition <- base::local({
[10:27:05.389]                   sendCondition <- NULL
[10:27:05.389]                   function(frame = 1L) {
[10:27:05.389]                     if (is.function(sendCondition)) 
[10:27:05.389]                       return(sendCondition)
[10:27:05.389]                     ns <- getNamespace("parallel")
[10:27:05.389]                     if (exists("sendData", mode = "function", 
[10:27:05.389]                       envir = ns)) {
[10:27:05.389]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:05.389]                         envir = ns)
[10:27:05.389]                       envir <- sys.frame(frame)
[10:27:05.389]                       master <- NULL
[10:27:05.389]                       while (!identical(envir, .GlobalEnv) && 
[10:27:05.389]                         !identical(envir, emptyenv())) {
[10:27:05.389]                         if (exists("master", mode = "list", envir = envir, 
[10:27:05.389]                           inherits = FALSE)) {
[10:27:05.389]                           master <- get("master", mode = "list", 
[10:27:05.389]                             envir = envir, inherits = FALSE)
[10:27:05.389]                           if (inherits(master, c("SOCKnode", 
[10:27:05.389]                             "SOCK0node"))) {
[10:27:05.389]                             sendCondition <<- function(cond) {
[10:27:05.389]                               data <- list(type = "VALUE", value = cond, 
[10:27:05.389]                                 success = TRUE)
[10:27:05.389]                               parallel_sendData(master, data)
[10:27:05.389]                             }
[10:27:05.389]                             return(sendCondition)
[10:27:05.389]                           }
[10:27:05.389]                         }
[10:27:05.389]                         frame <- frame + 1L
[10:27:05.389]                         envir <- sys.frame(frame)
[10:27:05.389]                       }
[10:27:05.389]                     }
[10:27:05.389]                     sendCondition <<- function(cond) NULL
[10:27:05.389]                   }
[10:27:05.389]                 })
[10:27:05.389]                 withCallingHandlers({
[10:27:05.389]                   {
[10:27:05.389]                     Sys.sleep(0.5)
[10:27:05.389]                     list(a = 1, b = 42L)
[10:27:05.389]                   }
[10:27:05.389]                 }, immediateCondition = function(cond) {
[10:27:05.389]                   sendCondition <- ...future.makeSendCondition()
[10:27:05.389]                   sendCondition(cond)
[10:27:05.389]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:05.389]                   {
[10:27:05.389]                     inherits <- base::inherits
[10:27:05.389]                     invokeRestart <- base::invokeRestart
[10:27:05.389]                     is.null <- base::is.null
[10:27:05.389]                     muffled <- FALSE
[10:27:05.389]                     if (inherits(cond, "message")) {
[10:27:05.389]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:05.389]                       if (muffled) 
[10:27:05.389]                         invokeRestart("muffleMessage")
[10:27:05.389]                     }
[10:27:05.389]                     else if (inherits(cond, "warning")) {
[10:27:05.389]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:05.389]                       if (muffled) 
[10:27:05.389]                         invokeRestart("muffleWarning")
[10:27:05.389]                     }
[10:27:05.389]                     else if (inherits(cond, "condition")) {
[10:27:05.389]                       if (!is.null(pattern)) {
[10:27:05.389]                         computeRestarts <- base::computeRestarts
[10:27:05.389]                         grepl <- base::grepl
[10:27:05.389]                         restarts <- computeRestarts(cond)
[10:27:05.389]                         for (restart in restarts) {
[10:27:05.389]                           name <- restart$name
[10:27:05.389]                           if (is.null(name)) 
[10:27:05.389]                             next
[10:27:05.389]                           if (!grepl(pattern, name)) 
[10:27:05.389]                             next
[10:27:05.389]                           invokeRestart(restart)
[10:27:05.389]                           muffled <- TRUE
[10:27:05.389]                           break
[10:27:05.389]                         }
[10:27:05.389]                       }
[10:27:05.389]                     }
[10:27:05.389]                     invisible(muffled)
[10:27:05.389]                   }
[10:27:05.389]                   muffleCondition(cond)
[10:27:05.389]                 })
[10:27:05.389]             }))
[10:27:05.389]             future::FutureResult(value = ...future.value$value, 
[10:27:05.389]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:05.389]                   ...future.rng), globalenv = if (FALSE) 
[10:27:05.389]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:05.389]                     ...future.globalenv.names))
[10:27:05.389]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:05.389]         }, condition = base::local({
[10:27:05.389]             c <- base::c
[10:27:05.389]             inherits <- base::inherits
[10:27:05.389]             invokeRestart <- base::invokeRestart
[10:27:05.389]             length <- base::length
[10:27:05.389]             list <- base::list
[10:27:05.389]             seq.int <- base::seq.int
[10:27:05.389]             signalCondition <- base::signalCondition
[10:27:05.389]             sys.calls <- base::sys.calls
[10:27:05.389]             `[[` <- base::`[[`
[10:27:05.389]             `+` <- base::`+`
[10:27:05.389]             `<<-` <- base::`<<-`
[10:27:05.389]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:05.389]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:05.389]                   3L)]
[10:27:05.389]             }
[10:27:05.389]             function(cond) {
[10:27:05.389]                 is_error <- inherits(cond, "error")
[10:27:05.389]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:05.389]                   NULL)
[10:27:05.389]                 if (is_error) {
[10:27:05.389]                   sessionInformation <- function() {
[10:27:05.389]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:05.389]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:05.389]                       search = base::search(), system = base::Sys.info())
[10:27:05.389]                   }
[10:27:05.389]                   ...future.conditions[[length(...future.conditions) + 
[10:27:05.389]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:05.389]                     cond$call), session = sessionInformation(), 
[10:27:05.389]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:05.389]                   signalCondition(cond)
[10:27:05.389]                 }
[10:27:05.389]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:05.389]                 "immediateCondition"))) {
[10:27:05.389]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:05.389]                   ...future.conditions[[length(...future.conditions) + 
[10:27:05.389]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:05.389]                   if (TRUE && !signal) {
[10:27:05.389]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:05.389]                     {
[10:27:05.389]                       inherits <- base::inherits
[10:27:05.389]                       invokeRestart <- base::invokeRestart
[10:27:05.389]                       is.null <- base::is.null
[10:27:05.389]                       muffled <- FALSE
[10:27:05.389]                       if (inherits(cond, "message")) {
[10:27:05.389]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:05.389]                         if (muffled) 
[10:27:05.389]                           invokeRestart("muffleMessage")
[10:27:05.389]                       }
[10:27:05.389]                       else if (inherits(cond, "warning")) {
[10:27:05.389]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:05.389]                         if (muffled) 
[10:27:05.389]                           invokeRestart("muffleWarning")
[10:27:05.389]                       }
[10:27:05.389]                       else if (inherits(cond, "condition")) {
[10:27:05.389]                         if (!is.null(pattern)) {
[10:27:05.389]                           computeRestarts <- base::computeRestarts
[10:27:05.389]                           grepl <- base::grepl
[10:27:05.389]                           restarts <- computeRestarts(cond)
[10:27:05.389]                           for (restart in restarts) {
[10:27:05.389]                             name <- restart$name
[10:27:05.389]                             if (is.null(name)) 
[10:27:05.389]                               next
[10:27:05.389]                             if (!grepl(pattern, name)) 
[10:27:05.389]                               next
[10:27:05.389]                             invokeRestart(restart)
[10:27:05.389]                             muffled <- TRUE
[10:27:05.389]                             break
[10:27:05.389]                           }
[10:27:05.389]                         }
[10:27:05.389]                       }
[10:27:05.389]                       invisible(muffled)
[10:27:05.389]                     }
[10:27:05.389]                     muffleCondition(cond, pattern = "^muffle")
[10:27:05.389]                   }
[10:27:05.389]                 }
[10:27:05.389]                 else {
[10:27:05.389]                   if (TRUE) {
[10:27:05.389]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:05.389]                     {
[10:27:05.389]                       inherits <- base::inherits
[10:27:05.389]                       invokeRestart <- base::invokeRestart
[10:27:05.389]                       is.null <- base::is.null
[10:27:05.389]                       muffled <- FALSE
[10:27:05.389]                       if (inherits(cond, "message")) {
[10:27:05.389]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:05.389]                         if (muffled) 
[10:27:05.389]                           invokeRestart("muffleMessage")
[10:27:05.389]                       }
[10:27:05.389]                       else if (inherits(cond, "warning")) {
[10:27:05.389]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:05.389]                         if (muffled) 
[10:27:05.389]                           invokeRestart("muffleWarning")
[10:27:05.389]                       }
[10:27:05.389]                       else if (inherits(cond, "condition")) {
[10:27:05.389]                         if (!is.null(pattern)) {
[10:27:05.389]                           computeRestarts <- base::computeRestarts
[10:27:05.389]                           grepl <- base::grepl
[10:27:05.389]                           restarts <- computeRestarts(cond)
[10:27:05.389]                           for (restart in restarts) {
[10:27:05.389]                             name <- restart$name
[10:27:05.389]                             if (is.null(name)) 
[10:27:05.389]                               next
[10:27:05.389]                             if (!grepl(pattern, name)) 
[10:27:05.389]                               next
[10:27:05.389]                             invokeRestart(restart)
[10:27:05.389]                             muffled <- TRUE
[10:27:05.389]                             break
[10:27:05.389]                           }
[10:27:05.389]                         }
[10:27:05.389]                       }
[10:27:05.389]                       invisible(muffled)
[10:27:05.389]                     }
[10:27:05.389]                     muffleCondition(cond, pattern = "^muffle")
[10:27:05.389]                   }
[10:27:05.389]                 }
[10:27:05.389]             }
[10:27:05.389]         }))
[10:27:05.389]     }, error = function(ex) {
[10:27:05.389]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:05.389]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:05.389]                 ...future.rng), started = ...future.startTime, 
[10:27:05.389]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:05.389]             version = "1.8"), class = "FutureResult")
[10:27:05.389]     }, finally = {
[10:27:05.389]         if (!identical(...future.workdir, getwd())) 
[10:27:05.389]             setwd(...future.workdir)
[10:27:05.389]         {
[10:27:05.389]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:05.389]                 ...future.oldOptions$nwarnings <- NULL
[10:27:05.389]             }
[10:27:05.389]             base::options(...future.oldOptions)
[10:27:05.389]             if (.Platform$OS.type == "windows") {
[10:27:05.389]                 old_names <- names(...future.oldEnvVars)
[10:27:05.389]                 envs <- base::Sys.getenv()
[10:27:05.389]                 names <- names(envs)
[10:27:05.389]                 common <- intersect(names, old_names)
[10:27:05.389]                 added <- setdiff(names, old_names)
[10:27:05.389]                 removed <- setdiff(old_names, names)
[10:27:05.389]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:05.389]                   envs[common]]
[10:27:05.389]                 NAMES <- toupper(changed)
[10:27:05.389]                 args <- list()
[10:27:05.389]                 for (kk in seq_along(NAMES)) {
[10:27:05.389]                   name <- changed[[kk]]
[10:27:05.389]                   NAME <- NAMES[[kk]]
[10:27:05.389]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:05.389]                     next
[10:27:05.389]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:05.389]                 }
[10:27:05.389]                 NAMES <- toupper(added)
[10:27:05.389]                 for (kk in seq_along(NAMES)) {
[10:27:05.389]                   name <- added[[kk]]
[10:27:05.389]                   NAME <- NAMES[[kk]]
[10:27:05.389]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:05.389]                     next
[10:27:05.389]                   args[[name]] <- ""
[10:27:05.389]                 }
[10:27:05.389]                 NAMES <- toupper(removed)
[10:27:05.389]                 for (kk in seq_along(NAMES)) {
[10:27:05.389]                   name <- removed[[kk]]
[10:27:05.389]                   NAME <- NAMES[[kk]]
[10:27:05.389]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:05.389]                     next
[10:27:05.389]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:05.389]                 }
[10:27:05.389]                 if (length(args) > 0) 
[10:27:05.389]                   base::do.call(base::Sys.setenv, args = args)
[10:27:05.389]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:05.389]             }
[10:27:05.389]             else {
[10:27:05.389]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:05.389]             }
[10:27:05.389]             {
[10:27:05.389]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:05.389]                   0L) {
[10:27:05.389]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:05.389]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:05.389]                   base::options(opts)
[10:27:05.389]                 }
[10:27:05.389]                 {
[10:27:05.389]                   {
[10:27:05.389]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:05.389]                     NULL
[10:27:05.389]                   }
[10:27:05.389]                   options(future.plan = NULL)
[10:27:05.389]                   if (is.na(NA_character_)) 
[10:27:05.389]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:05.389]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:05.389]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:05.389]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:05.389]                     envir = parent.frame()) 
[10:27:05.389]                   {
[10:27:05.389]                     if (is.function(workers)) 
[10:27:05.389]                       workers <- workers()
[10:27:05.389]                     workers <- structure(as.integer(workers), 
[10:27:05.389]                       class = class(workers))
[10:27:05.389]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:05.389]                       workers >= 1)
[10:27:05.389]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:05.389]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:05.389]                     }
[10:27:05.389]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:05.389]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:05.389]                       envir = envir)
[10:27:05.389]                     if (!future$lazy) 
[10:27:05.389]                       future <- run(future)
[10:27:05.389]                     invisible(future)
[10:27:05.389]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:05.389]                 }
[10:27:05.389]             }
[10:27:05.389]         }
[10:27:05.389]     })
[10:27:05.389]     if (TRUE) {
[10:27:05.389]         base::sink(type = "output", split = FALSE)
[10:27:05.389]         if (TRUE) {
[10:27:05.389]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:05.389]         }
[10:27:05.389]         else {
[10:27:05.389]             ...future.result["stdout"] <- base::list(NULL)
[10:27:05.389]         }
[10:27:05.389]         base::close(...future.stdout)
[10:27:05.389]         ...future.stdout <- NULL
[10:27:05.389]     }
[10:27:05.389]     ...future.result$conditions <- ...future.conditions
[10:27:05.389]     ...future.result$finished <- base::Sys.time()
[10:27:05.389]     ...future.result
[10:27:05.389] }
[10:27:05.392] MultisessionFuture started
[10:27:05.392] - Launch lazy future ... done
[10:27:05.392] run() for ‘MultisessionFuture’ ... done
[10:27:05.939] receiveMessageFromWorker() for ClusterFuture ...
[10:27:05.940] - Validating connection of MultisessionFuture
[10:27:05.940] - received message: FutureResult
[10:27:05.940] - Received FutureResult
[10:27:05.940] - Erased future from FutureRegistry
[10:27:05.940] result() for ClusterFuture ...
[10:27:05.940] - result already collected: FutureResult
[10:27:05.941] result() for ClusterFuture ... done
[10:27:05.941] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:05.941] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[10:27:05.941] getGlobalsAndPackages() ...
[10:27:05.941] Searching for globals...
[10:27:05.942] - globals found: [2] ‘list’, ‘stop’
[10:27:05.942] Searching for globals ... DONE
[10:27:05.942] Resolving globals: FALSE
[10:27:05.943] 
[10:27:05.943] 
[10:27:05.943] getGlobalsAndPackages() ... DONE
[10:27:05.943] run() for ‘Future’ ...
[10:27:05.944] - state: ‘created’
[10:27:05.944] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:05.960] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:05.960] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:05.961]   - Field: ‘node’
[10:27:05.961]   - Field: ‘label’
[10:27:05.961]   - Field: ‘local’
[10:27:05.961]   - Field: ‘owner’
[10:27:05.961]   - Field: ‘envir’
[10:27:05.961]   - Field: ‘workers’
[10:27:05.961]   - Field: ‘packages’
[10:27:05.961]   - Field: ‘gc’
[10:27:05.961]   - Field: ‘conditions’
[10:27:05.961]   - Field: ‘persistent’
[10:27:05.962]   - Field: ‘expr’
[10:27:05.962]   - Field: ‘uuid’
[10:27:05.962]   - Field: ‘seed’
[10:27:05.962]   - Field: ‘version’
[10:27:05.962]   - Field: ‘result’
[10:27:05.962]   - Field: ‘asynchronous’
[10:27:05.962]   - Field: ‘calls’
[10:27:05.962]   - Field: ‘globals’
[10:27:05.962]   - Field: ‘stdout’
[10:27:05.962]   - Field: ‘earlySignal’
[10:27:05.962]   - Field: ‘lazy’
[10:27:05.963]   - Field: ‘state’
[10:27:05.963] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:05.963] - Launch lazy future ...
[10:27:05.963] Packages needed by the future expression (n = 0): <none>
[10:27:05.963] Packages needed by future strategies (n = 0): <none>
[10:27:05.964] {
[10:27:05.964]     {
[10:27:05.964]         {
[10:27:05.964]             ...future.startTime <- base::Sys.time()
[10:27:05.964]             {
[10:27:05.964]                 {
[10:27:05.964]                   {
[10:27:05.964]                     {
[10:27:05.964]                       base::local({
[10:27:05.964]                         has_future <- base::requireNamespace("future", 
[10:27:05.964]                           quietly = TRUE)
[10:27:05.964]                         if (has_future) {
[10:27:05.964]                           ns <- base::getNamespace("future")
[10:27:05.964]                           version <- ns[[".package"]][["version"]]
[10:27:05.964]                           if (is.null(version)) 
[10:27:05.964]                             version <- utils::packageVersion("future")
[10:27:05.964]                         }
[10:27:05.964]                         else {
[10:27:05.964]                           version <- NULL
[10:27:05.964]                         }
[10:27:05.964]                         if (!has_future || version < "1.8.0") {
[10:27:05.964]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:05.964]                             "", base::R.version$version.string), 
[10:27:05.964]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:05.964]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:05.964]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:05.964]                               "release", "version")], collapse = " "), 
[10:27:05.964]                             hostname = base::Sys.info()[["nodename"]])
[10:27:05.964]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:05.964]                             info)
[10:27:05.964]                           info <- base::paste(info, collapse = "; ")
[10:27:05.964]                           if (!has_future) {
[10:27:05.964]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:05.964]                               info)
[10:27:05.964]                           }
[10:27:05.964]                           else {
[10:27:05.964]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:05.964]                               info, version)
[10:27:05.964]                           }
[10:27:05.964]                           base::stop(msg)
[10:27:05.964]                         }
[10:27:05.964]                       })
[10:27:05.964]                     }
[10:27:05.964]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:05.964]                     base::options(mc.cores = 1L)
[10:27:05.964]                   }
[10:27:05.964]                   options(future.plan = NULL)
[10:27:05.964]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:05.964]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:05.964]                 }
[10:27:05.964]                 ...future.workdir <- getwd()
[10:27:05.964]             }
[10:27:05.964]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:05.964]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:05.964]         }
[10:27:05.964]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:05.964]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:05.964]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:05.964]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:05.964]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:05.964]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:05.964]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:05.964]             base::names(...future.oldOptions))
[10:27:05.964]     }
[10:27:05.964]     if (FALSE) {
[10:27:05.964]     }
[10:27:05.964]     else {
[10:27:05.964]         if (TRUE) {
[10:27:05.964]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:05.964]                 open = "w")
[10:27:05.964]         }
[10:27:05.964]         else {
[10:27:05.964]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:05.964]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:05.964]         }
[10:27:05.964]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:05.964]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:05.964]             base::sink(type = "output", split = FALSE)
[10:27:05.964]             base::close(...future.stdout)
[10:27:05.964]         }, add = TRUE)
[10:27:05.964]     }
[10:27:05.964]     ...future.frame <- base::sys.nframe()
[10:27:05.964]     ...future.conditions <- base::list()
[10:27:05.964]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:05.964]     if (FALSE) {
[10:27:05.964]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:05.964]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:05.964]     }
[10:27:05.964]     ...future.result <- base::tryCatch({
[10:27:05.964]         base::withCallingHandlers({
[10:27:05.964]             ...future.value <- base::withVisible(base::local({
[10:27:05.964]                 ...future.makeSendCondition <- base::local({
[10:27:05.964]                   sendCondition <- NULL
[10:27:05.964]                   function(frame = 1L) {
[10:27:05.964]                     if (is.function(sendCondition)) 
[10:27:05.964]                       return(sendCondition)
[10:27:05.964]                     ns <- getNamespace("parallel")
[10:27:05.964]                     if (exists("sendData", mode = "function", 
[10:27:05.964]                       envir = ns)) {
[10:27:05.964]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:05.964]                         envir = ns)
[10:27:05.964]                       envir <- sys.frame(frame)
[10:27:05.964]                       master <- NULL
[10:27:05.964]                       while (!identical(envir, .GlobalEnv) && 
[10:27:05.964]                         !identical(envir, emptyenv())) {
[10:27:05.964]                         if (exists("master", mode = "list", envir = envir, 
[10:27:05.964]                           inherits = FALSE)) {
[10:27:05.964]                           master <- get("master", mode = "list", 
[10:27:05.964]                             envir = envir, inherits = FALSE)
[10:27:05.964]                           if (inherits(master, c("SOCKnode", 
[10:27:05.964]                             "SOCK0node"))) {
[10:27:05.964]                             sendCondition <<- function(cond) {
[10:27:05.964]                               data <- list(type = "VALUE", value = cond, 
[10:27:05.964]                                 success = TRUE)
[10:27:05.964]                               parallel_sendData(master, data)
[10:27:05.964]                             }
[10:27:05.964]                             return(sendCondition)
[10:27:05.964]                           }
[10:27:05.964]                         }
[10:27:05.964]                         frame <- frame + 1L
[10:27:05.964]                         envir <- sys.frame(frame)
[10:27:05.964]                       }
[10:27:05.964]                     }
[10:27:05.964]                     sendCondition <<- function(cond) NULL
[10:27:05.964]                   }
[10:27:05.964]                 })
[10:27:05.964]                 withCallingHandlers({
[10:27:05.964]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:27:05.964]                 }, immediateCondition = function(cond) {
[10:27:05.964]                   sendCondition <- ...future.makeSendCondition()
[10:27:05.964]                   sendCondition(cond)
[10:27:05.964]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:05.964]                   {
[10:27:05.964]                     inherits <- base::inherits
[10:27:05.964]                     invokeRestart <- base::invokeRestart
[10:27:05.964]                     is.null <- base::is.null
[10:27:05.964]                     muffled <- FALSE
[10:27:05.964]                     if (inherits(cond, "message")) {
[10:27:05.964]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:05.964]                       if (muffled) 
[10:27:05.964]                         invokeRestart("muffleMessage")
[10:27:05.964]                     }
[10:27:05.964]                     else if (inherits(cond, "warning")) {
[10:27:05.964]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:05.964]                       if (muffled) 
[10:27:05.964]                         invokeRestart("muffleWarning")
[10:27:05.964]                     }
[10:27:05.964]                     else if (inherits(cond, "condition")) {
[10:27:05.964]                       if (!is.null(pattern)) {
[10:27:05.964]                         computeRestarts <- base::computeRestarts
[10:27:05.964]                         grepl <- base::grepl
[10:27:05.964]                         restarts <- computeRestarts(cond)
[10:27:05.964]                         for (restart in restarts) {
[10:27:05.964]                           name <- restart$name
[10:27:05.964]                           if (is.null(name)) 
[10:27:05.964]                             next
[10:27:05.964]                           if (!grepl(pattern, name)) 
[10:27:05.964]                             next
[10:27:05.964]                           invokeRestart(restart)
[10:27:05.964]                           muffled <- TRUE
[10:27:05.964]                           break
[10:27:05.964]                         }
[10:27:05.964]                       }
[10:27:05.964]                     }
[10:27:05.964]                     invisible(muffled)
[10:27:05.964]                   }
[10:27:05.964]                   muffleCondition(cond)
[10:27:05.964]                 })
[10:27:05.964]             }))
[10:27:05.964]             future::FutureResult(value = ...future.value$value, 
[10:27:05.964]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:05.964]                   ...future.rng), globalenv = if (FALSE) 
[10:27:05.964]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:05.964]                     ...future.globalenv.names))
[10:27:05.964]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:05.964]         }, condition = base::local({
[10:27:05.964]             c <- base::c
[10:27:05.964]             inherits <- base::inherits
[10:27:05.964]             invokeRestart <- base::invokeRestart
[10:27:05.964]             length <- base::length
[10:27:05.964]             list <- base::list
[10:27:05.964]             seq.int <- base::seq.int
[10:27:05.964]             signalCondition <- base::signalCondition
[10:27:05.964]             sys.calls <- base::sys.calls
[10:27:05.964]             `[[` <- base::`[[`
[10:27:05.964]             `+` <- base::`+`
[10:27:05.964]             `<<-` <- base::`<<-`
[10:27:05.964]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:05.964]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:05.964]                   3L)]
[10:27:05.964]             }
[10:27:05.964]             function(cond) {
[10:27:05.964]                 is_error <- inherits(cond, "error")
[10:27:05.964]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:05.964]                   NULL)
[10:27:05.964]                 if (is_error) {
[10:27:05.964]                   sessionInformation <- function() {
[10:27:05.964]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:05.964]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:05.964]                       search = base::search(), system = base::Sys.info())
[10:27:05.964]                   }
[10:27:05.964]                   ...future.conditions[[length(...future.conditions) + 
[10:27:05.964]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:05.964]                     cond$call), session = sessionInformation(), 
[10:27:05.964]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:05.964]                   signalCondition(cond)
[10:27:05.964]                 }
[10:27:05.964]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:05.964]                 "immediateCondition"))) {
[10:27:05.964]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:05.964]                   ...future.conditions[[length(...future.conditions) + 
[10:27:05.964]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:05.964]                   if (TRUE && !signal) {
[10:27:05.964]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:05.964]                     {
[10:27:05.964]                       inherits <- base::inherits
[10:27:05.964]                       invokeRestart <- base::invokeRestart
[10:27:05.964]                       is.null <- base::is.null
[10:27:05.964]                       muffled <- FALSE
[10:27:05.964]                       if (inherits(cond, "message")) {
[10:27:05.964]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:05.964]                         if (muffled) 
[10:27:05.964]                           invokeRestart("muffleMessage")
[10:27:05.964]                       }
[10:27:05.964]                       else if (inherits(cond, "warning")) {
[10:27:05.964]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:05.964]                         if (muffled) 
[10:27:05.964]                           invokeRestart("muffleWarning")
[10:27:05.964]                       }
[10:27:05.964]                       else if (inherits(cond, "condition")) {
[10:27:05.964]                         if (!is.null(pattern)) {
[10:27:05.964]                           computeRestarts <- base::computeRestarts
[10:27:05.964]                           grepl <- base::grepl
[10:27:05.964]                           restarts <- computeRestarts(cond)
[10:27:05.964]                           for (restart in restarts) {
[10:27:05.964]                             name <- restart$name
[10:27:05.964]                             if (is.null(name)) 
[10:27:05.964]                               next
[10:27:05.964]                             if (!grepl(pattern, name)) 
[10:27:05.964]                               next
[10:27:05.964]                             invokeRestart(restart)
[10:27:05.964]                             muffled <- TRUE
[10:27:05.964]                             break
[10:27:05.964]                           }
[10:27:05.964]                         }
[10:27:05.964]                       }
[10:27:05.964]                       invisible(muffled)
[10:27:05.964]                     }
[10:27:05.964]                     muffleCondition(cond, pattern = "^muffle")
[10:27:05.964]                   }
[10:27:05.964]                 }
[10:27:05.964]                 else {
[10:27:05.964]                   if (TRUE) {
[10:27:05.964]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:05.964]                     {
[10:27:05.964]                       inherits <- base::inherits
[10:27:05.964]                       invokeRestart <- base::invokeRestart
[10:27:05.964]                       is.null <- base::is.null
[10:27:05.964]                       muffled <- FALSE
[10:27:05.964]                       if (inherits(cond, "message")) {
[10:27:05.964]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:05.964]                         if (muffled) 
[10:27:05.964]                           invokeRestart("muffleMessage")
[10:27:05.964]                       }
[10:27:05.964]                       else if (inherits(cond, "warning")) {
[10:27:05.964]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:05.964]                         if (muffled) 
[10:27:05.964]                           invokeRestart("muffleWarning")
[10:27:05.964]                       }
[10:27:05.964]                       else if (inherits(cond, "condition")) {
[10:27:05.964]                         if (!is.null(pattern)) {
[10:27:05.964]                           computeRestarts <- base::computeRestarts
[10:27:05.964]                           grepl <- base::grepl
[10:27:05.964]                           restarts <- computeRestarts(cond)
[10:27:05.964]                           for (restart in restarts) {
[10:27:05.964]                             name <- restart$name
[10:27:05.964]                             if (is.null(name)) 
[10:27:05.964]                               next
[10:27:05.964]                             if (!grepl(pattern, name)) 
[10:27:05.964]                               next
[10:27:05.964]                             invokeRestart(restart)
[10:27:05.964]                             muffled <- TRUE
[10:27:05.964]                             break
[10:27:05.964]                           }
[10:27:05.964]                         }
[10:27:05.964]                       }
[10:27:05.964]                       invisible(muffled)
[10:27:05.964]                     }
[10:27:05.964]                     muffleCondition(cond, pattern = "^muffle")
[10:27:05.964]                   }
[10:27:05.964]                 }
[10:27:05.964]             }
[10:27:05.964]         }))
[10:27:05.964]     }, error = function(ex) {
[10:27:05.964]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:05.964]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:05.964]                 ...future.rng), started = ...future.startTime, 
[10:27:05.964]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:05.964]             version = "1.8"), class = "FutureResult")
[10:27:05.964]     }, finally = {
[10:27:05.964]         if (!identical(...future.workdir, getwd())) 
[10:27:05.964]             setwd(...future.workdir)
[10:27:05.964]         {
[10:27:05.964]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:05.964]                 ...future.oldOptions$nwarnings <- NULL
[10:27:05.964]             }
[10:27:05.964]             base::options(...future.oldOptions)
[10:27:05.964]             if (.Platform$OS.type == "windows") {
[10:27:05.964]                 old_names <- names(...future.oldEnvVars)
[10:27:05.964]                 envs <- base::Sys.getenv()
[10:27:05.964]                 names <- names(envs)
[10:27:05.964]                 common <- intersect(names, old_names)
[10:27:05.964]                 added <- setdiff(names, old_names)
[10:27:05.964]                 removed <- setdiff(old_names, names)
[10:27:05.964]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:05.964]                   envs[common]]
[10:27:05.964]                 NAMES <- toupper(changed)
[10:27:05.964]                 args <- list()
[10:27:05.964]                 for (kk in seq_along(NAMES)) {
[10:27:05.964]                   name <- changed[[kk]]
[10:27:05.964]                   NAME <- NAMES[[kk]]
[10:27:05.964]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:05.964]                     next
[10:27:05.964]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:05.964]                 }
[10:27:05.964]                 NAMES <- toupper(added)
[10:27:05.964]                 for (kk in seq_along(NAMES)) {
[10:27:05.964]                   name <- added[[kk]]
[10:27:05.964]                   NAME <- NAMES[[kk]]
[10:27:05.964]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:05.964]                     next
[10:27:05.964]                   args[[name]] <- ""
[10:27:05.964]                 }
[10:27:05.964]                 NAMES <- toupper(removed)
[10:27:05.964]                 for (kk in seq_along(NAMES)) {
[10:27:05.964]                   name <- removed[[kk]]
[10:27:05.964]                   NAME <- NAMES[[kk]]
[10:27:05.964]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:05.964]                     next
[10:27:05.964]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:05.964]                 }
[10:27:05.964]                 if (length(args) > 0) 
[10:27:05.964]                   base::do.call(base::Sys.setenv, args = args)
[10:27:05.964]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:05.964]             }
[10:27:05.964]             else {
[10:27:05.964]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:05.964]             }
[10:27:05.964]             {
[10:27:05.964]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:05.964]                   0L) {
[10:27:05.964]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:05.964]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:05.964]                   base::options(opts)
[10:27:05.964]                 }
[10:27:05.964]                 {
[10:27:05.964]                   {
[10:27:05.964]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:05.964]                     NULL
[10:27:05.964]                   }
[10:27:05.964]                   options(future.plan = NULL)
[10:27:05.964]                   if (is.na(NA_character_)) 
[10:27:05.964]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:05.964]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:05.964]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:05.964]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:05.964]                     envir = parent.frame()) 
[10:27:05.964]                   {
[10:27:05.964]                     if (is.function(workers)) 
[10:27:05.964]                       workers <- workers()
[10:27:05.964]                     workers <- structure(as.integer(workers), 
[10:27:05.964]                       class = class(workers))
[10:27:05.964]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:05.964]                       workers >= 1)
[10:27:05.964]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:05.964]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:05.964]                     }
[10:27:05.964]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:05.964]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:05.964]                       envir = envir)
[10:27:05.964]                     if (!future$lazy) 
[10:27:05.964]                       future <- run(future)
[10:27:05.964]                     invisible(future)
[10:27:05.964]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:05.964]                 }
[10:27:05.964]             }
[10:27:05.964]         }
[10:27:05.964]     })
[10:27:05.964]     if (TRUE) {
[10:27:05.964]         base::sink(type = "output", split = FALSE)
[10:27:05.964]         if (TRUE) {
[10:27:05.964]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:05.964]         }
[10:27:05.964]         else {
[10:27:05.964]             ...future.result["stdout"] <- base::list(NULL)
[10:27:05.964]         }
[10:27:05.964]         base::close(...future.stdout)
[10:27:05.964]         ...future.stdout <- NULL
[10:27:05.964]     }
[10:27:05.964]     ...future.result$conditions <- ...future.conditions
[10:27:05.964]     ...future.result$finished <- base::Sys.time()
[10:27:05.964]     ...future.result
[10:27:05.964] }
[10:27:05.967] MultisessionFuture started
[10:27:05.967] - Launch lazy future ... done
[10:27:05.967] run() for ‘MultisessionFuture’ ... done
[10:27:05.977] receiveMessageFromWorker() for ClusterFuture ...
[10:27:05.977] - Validating connection of MultisessionFuture
[10:27:05.977] - received message: FutureResult
[10:27:05.977] - Received FutureResult
[10:27:05.978] - Erased future from FutureRegistry
[10:27:05.978] result() for ClusterFuture ...
[10:27:05.978] - result already collected: FutureResult
[10:27:05.978] result() for ClusterFuture ... done
[10:27:05.978] signalConditions() ...
[10:27:05.978]  - include = ‘immediateCondition’
[10:27:05.978]  - exclude = 
[10:27:05.978]  - resignal = FALSE
[10:27:05.978]  - Number of conditions: 1
[10:27:05.978] signalConditions() ... done
[10:27:05.979] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:05.979] A MultisessionFuture was resolved (result was not collected)
[10:27:05.979] getGlobalsAndPackages() ...
[10:27:05.979] Searching for globals...
[10:27:05.980] - globals found: [2] ‘list’, ‘stop’
[10:27:05.980] Searching for globals ... DONE
[10:27:05.980] Resolving globals: FALSE
[10:27:05.980] 
[10:27:05.980] 
[10:27:05.980] getGlobalsAndPackages() ... DONE
[10:27:05.981] run() for ‘Future’ ...
[10:27:05.981] - state: ‘created’
[10:27:05.981] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:05.996] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:05.996] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:05.996]   - Field: ‘node’
[10:27:05.996]   - Field: ‘label’
[10:27:05.996]   - Field: ‘local’
[10:27:05.996]   - Field: ‘owner’
[10:27:05.996]   - Field: ‘envir’
[10:27:05.996]   - Field: ‘workers’
[10:27:05.996]   - Field: ‘packages’
[10:27:05.997]   - Field: ‘gc’
[10:27:05.997]   - Field: ‘conditions’
[10:27:05.997]   - Field: ‘persistent’
[10:27:05.997]   - Field: ‘expr’
[10:27:05.997]   - Field: ‘uuid’
[10:27:05.997]   - Field: ‘seed’
[10:27:05.997]   - Field: ‘version’
[10:27:05.997]   - Field: ‘result’
[10:27:05.997]   - Field: ‘asynchronous’
[10:27:05.997]   - Field: ‘calls’
[10:27:05.998]   - Field: ‘globals’
[10:27:05.998]   - Field: ‘stdout’
[10:27:05.998]   - Field: ‘earlySignal’
[10:27:05.998]   - Field: ‘lazy’
[10:27:05.998]   - Field: ‘state’
[10:27:05.998] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:05.998] - Launch lazy future ...
[10:27:05.998] Packages needed by the future expression (n = 0): <none>
[10:27:05.999] Packages needed by future strategies (n = 0): <none>
[10:27:05.999] {
[10:27:05.999]     {
[10:27:05.999]         {
[10:27:05.999]             ...future.startTime <- base::Sys.time()
[10:27:05.999]             {
[10:27:05.999]                 {
[10:27:05.999]                   {
[10:27:05.999]                     {
[10:27:05.999]                       base::local({
[10:27:05.999]                         has_future <- base::requireNamespace("future", 
[10:27:05.999]                           quietly = TRUE)
[10:27:05.999]                         if (has_future) {
[10:27:05.999]                           ns <- base::getNamespace("future")
[10:27:05.999]                           version <- ns[[".package"]][["version"]]
[10:27:05.999]                           if (is.null(version)) 
[10:27:05.999]                             version <- utils::packageVersion("future")
[10:27:05.999]                         }
[10:27:05.999]                         else {
[10:27:05.999]                           version <- NULL
[10:27:05.999]                         }
[10:27:05.999]                         if (!has_future || version < "1.8.0") {
[10:27:05.999]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:05.999]                             "", base::R.version$version.string), 
[10:27:05.999]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:05.999]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:05.999]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:05.999]                               "release", "version")], collapse = " "), 
[10:27:05.999]                             hostname = base::Sys.info()[["nodename"]])
[10:27:05.999]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:05.999]                             info)
[10:27:05.999]                           info <- base::paste(info, collapse = "; ")
[10:27:05.999]                           if (!has_future) {
[10:27:05.999]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:05.999]                               info)
[10:27:05.999]                           }
[10:27:05.999]                           else {
[10:27:05.999]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:05.999]                               info, version)
[10:27:05.999]                           }
[10:27:05.999]                           base::stop(msg)
[10:27:05.999]                         }
[10:27:05.999]                       })
[10:27:05.999]                     }
[10:27:05.999]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:05.999]                     base::options(mc.cores = 1L)
[10:27:05.999]                   }
[10:27:05.999]                   options(future.plan = NULL)
[10:27:05.999]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:05.999]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:05.999]                 }
[10:27:05.999]                 ...future.workdir <- getwd()
[10:27:05.999]             }
[10:27:05.999]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:05.999]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:05.999]         }
[10:27:05.999]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:05.999]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:05.999]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:05.999]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:05.999]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:05.999]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:05.999]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:05.999]             base::names(...future.oldOptions))
[10:27:05.999]     }
[10:27:05.999]     if (FALSE) {
[10:27:05.999]     }
[10:27:05.999]     else {
[10:27:05.999]         if (TRUE) {
[10:27:05.999]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:05.999]                 open = "w")
[10:27:05.999]         }
[10:27:05.999]         else {
[10:27:05.999]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:05.999]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:05.999]         }
[10:27:05.999]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:05.999]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:05.999]             base::sink(type = "output", split = FALSE)
[10:27:05.999]             base::close(...future.stdout)
[10:27:05.999]         }, add = TRUE)
[10:27:05.999]     }
[10:27:05.999]     ...future.frame <- base::sys.nframe()
[10:27:05.999]     ...future.conditions <- base::list()
[10:27:05.999]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:05.999]     if (FALSE) {
[10:27:05.999]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:05.999]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:05.999]     }
[10:27:05.999]     ...future.result <- base::tryCatch({
[10:27:05.999]         base::withCallingHandlers({
[10:27:05.999]             ...future.value <- base::withVisible(base::local({
[10:27:05.999]                 ...future.makeSendCondition <- base::local({
[10:27:05.999]                   sendCondition <- NULL
[10:27:05.999]                   function(frame = 1L) {
[10:27:05.999]                     if (is.function(sendCondition)) 
[10:27:05.999]                       return(sendCondition)
[10:27:05.999]                     ns <- getNamespace("parallel")
[10:27:05.999]                     if (exists("sendData", mode = "function", 
[10:27:05.999]                       envir = ns)) {
[10:27:05.999]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:05.999]                         envir = ns)
[10:27:05.999]                       envir <- sys.frame(frame)
[10:27:05.999]                       master <- NULL
[10:27:05.999]                       while (!identical(envir, .GlobalEnv) && 
[10:27:05.999]                         !identical(envir, emptyenv())) {
[10:27:05.999]                         if (exists("master", mode = "list", envir = envir, 
[10:27:05.999]                           inherits = FALSE)) {
[10:27:05.999]                           master <- get("master", mode = "list", 
[10:27:05.999]                             envir = envir, inherits = FALSE)
[10:27:05.999]                           if (inherits(master, c("SOCKnode", 
[10:27:05.999]                             "SOCK0node"))) {
[10:27:05.999]                             sendCondition <<- function(cond) {
[10:27:05.999]                               data <- list(type = "VALUE", value = cond, 
[10:27:05.999]                                 success = TRUE)
[10:27:05.999]                               parallel_sendData(master, data)
[10:27:05.999]                             }
[10:27:05.999]                             return(sendCondition)
[10:27:05.999]                           }
[10:27:05.999]                         }
[10:27:05.999]                         frame <- frame + 1L
[10:27:05.999]                         envir <- sys.frame(frame)
[10:27:05.999]                       }
[10:27:05.999]                     }
[10:27:05.999]                     sendCondition <<- function(cond) NULL
[10:27:05.999]                   }
[10:27:05.999]                 })
[10:27:05.999]                 withCallingHandlers({
[10:27:05.999]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:27:05.999]                 }, immediateCondition = function(cond) {
[10:27:05.999]                   sendCondition <- ...future.makeSendCondition()
[10:27:05.999]                   sendCondition(cond)
[10:27:05.999]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:05.999]                   {
[10:27:05.999]                     inherits <- base::inherits
[10:27:05.999]                     invokeRestart <- base::invokeRestart
[10:27:05.999]                     is.null <- base::is.null
[10:27:05.999]                     muffled <- FALSE
[10:27:05.999]                     if (inherits(cond, "message")) {
[10:27:05.999]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:05.999]                       if (muffled) 
[10:27:05.999]                         invokeRestart("muffleMessage")
[10:27:05.999]                     }
[10:27:05.999]                     else if (inherits(cond, "warning")) {
[10:27:05.999]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:05.999]                       if (muffled) 
[10:27:05.999]                         invokeRestart("muffleWarning")
[10:27:05.999]                     }
[10:27:05.999]                     else if (inherits(cond, "condition")) {
[10:27:05.999]                       if (!is.null(pattern)) {
[10:27:05.999]                         computeRestarts <- base::computeRestarts
[10:27:05.999]                         grepl <- base::grepl
[10:27:05.999]                         restarts <- computeRestarts(cond)
[10:27:05.999]                         for (restart in restarts) {
[10:27:05.999]                           name <- restart$name
[10:27:05.999]                           if (is.null(name)) 
[10:27:05.999]                             next
[10:27:05.999]                           if (!grepl(pattern, name)) 
[10:27:05.999]                             next
[10:27:05.999]                           invokeRestart(restart)
[10:27:05.999]                           muffled <- TRUE
[10:27:05.999]                           break
[10:27:05.999]                         }
[10:27:05.999]                       }
[10:27:05.999]                     }
[10:27:05.999]                     invisible(muffled)
[10:27:05.999]                   }
[10:27:05.999]                   muffleCondition(cond)
[10:27:05.999]                 })
[10:27:05.999]             }))
[10:27:05.999]             future::FutureResult(value = ...future.value$value, 
[10:27:05.999]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:05.999]                   ...future.rng), globalenv = if (FALSE) 
[10:27:05.999]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:05.999]                     ...future.globalenv.names))
[10:27:05.999]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:05.999]         }, condition = base::local({
[10:27:05.999]             c <- base::c
[10:27:05.999]             inherits <- base::inherits
[10:27:05.999]             invokeRestart <- base::invokeRestart
[10:27:05.999]             length <- base::length
[10:27:05.999]             list <- base::list
[10:27:05.999]             seq.int <- base::seq.int
[10:27:05.999]             signalCondition <- base::signalCondition
[10:27:05.999]             sys.calls <- base::sys.calls
[10:27:05.999]             `[[` <- base::`[[`
[10:27:05.999]             `+` <- base::`+`
[10:27:05.999]             `<<-` <- base::`<<-`
[10:27:05.999]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:05.999]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:05.999]                   3L)]
[10:27:05.999]             }
[10:27:05.999]             function(cond) {
[10:27:05.999]                 is_error <- inherits(cond, "error")
[10:27:05.999]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:05.999]                   NULL)
[10:27:05.999]                 if (is_error) {
[10:27:05.999]                   sessionInformation <- function() {
[10:27:05.999]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:05.999]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:05.999]                       search = base::search(), system = base::Sys.info())
[10:27:05.999]                   }
[10:27:05.999]                   ...future.conditions[[length(...future.conditions) + 
[10:27:05.999]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:05.999]                     cond$call), session = sessionInformation(), 
[10:27:05.999]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:05.999]                   signalCondition(cond)
[10:27:05.999]                 }
[10:27:05.999]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:05.999]                 "immediateCondition"))) {
[10:27:05.999]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:05.999]                   ...future.conditions[[length(...future.conditions) + 
[10:27:05.999]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:05.999]                   if (TRUE && !signal) {
[10:27:05.999]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:05.999]                     {
[10:27:05.999]                       inherits <- base::inherits
[10:27:05.999]                       invokeRestart <- base::invokeRestart
[10:27:05.999]                       is.null <- base::is.null
[10:27:05.999]                       muffled <- FALSE
[10:27:05.999]                       if (inherits(cond, "message")) {
[10:27:05.999]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:05.999]                         if (muffled) 
[10:27:05.999]                           invokeRestart("muffleMessage")
[10:27:05.999]                       }
[10:27:05.999]                       else if (inherits(cond, "warning")) {
[10:27:05.999]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:05.999]                         if (muffled) 
[10:27:05.999]                           invokeRestart("muffleWarning")
[10:27:05.999]                       }
[10:27:05.999]                       else if (inherits(cond, "condition")) {
[10:27:05.999]                         if (!is.null(pattern)) {
[10:27:05.999]                           computeRestarts <- base::computeRestarts
[10:27:05.999]                           grepl <- base::grepl
[10:27:05.999]                           restarts <- computeRestarts(cond)
[10:27:05.999]                           for (restart in restarts) {
[10:27:05.999]                             name <- restart$name
[10:27:05.999]                             if (is.null(name)) 
[10:27:05.999]                               next
[10:27:05.999]                             if (!grepl(pattern, name)) 
[10:27:05.999]                               next
[10:27:05.999]                             invokeRestart(restart)
[10:27:05.999]                             muffled <- TRUE
[10:27:05.999]                             break
[10:27:05.999]                           }
[10:27:05.999]                         }
[10:27:05.999]                       }
[10:27:05.999]                       invisible(muffled)
[10:27:05.999]                     }
[10:27:05.999]                     muffleCondition(cond, pattern = "^muffle")
[10:27:05.999]                   }
[10:27:05.999]                 }
[10:27:05.999]                 else {
[10:27:05.999]                   if (TRUE) {
[10:27:05.999]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:05.999]                     {
[10:27:05.999]                       inherits <- base::inherits
[10:27:05.999]                       invokeRestart <- base::invokeRestart
[10:27:05.999]                       is.null <- base::is.null
[10:27:05.999]                       muffled <- FALSE
[10:27:05.999]                       if (inherits(cond, "message")) {
[10:27:05.999]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:05.999]                         if (muffled) 
[10:27:05.999]                           invokeRestart("muffleMessage")
[10:27:05.999]                       }
[10:27:05.999]                       else if (inherits(cond, "warning")) {
[10:27:05.999]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:05.999]                         if (muffled) 
[10:27:05.999]                           invokeRestart("muffleWarning")
[10:27:05.999]                       }
[10:27:05.999]                       else if (inherits(cond, "condition")) {
[10:27:05.999]                         if (!is.null(pattern)) {
[10:27:05.999]                           computeRestarts <- base::computeRestarts
[10:27:05.999]                           grepl <- base::grepl
[10:27:05.999]                           restarts <- computeRestarts(cond)
[10:27:05.999]                           for (restart in restarts) {
[10:27:05.999]                             name <- restart$name
[10:27:05.999]                             if (is.null(name)) 
[10:27:05.999]                               next
[10:27:05.999]                             if (!grepl(pattern, name)) 
[10:27:05.999]                               next
[10:27:05.999]                             invokeRestart(restart)
[10:27:05.999]                             muffled <- TRUE
[10:27:05.999]                             break
[10:27:05.999]                           }
[10:27:05.999]                         }
[10:27:05.999]                       }
[10:27:05.999]                       invisible(muffled)
[10:27:05.999]                     }
[10:27:05.999]                     muffleCondition(cond, pattern = "^muffle")
[10:27:05.999]                   }
[10:27:05.999]                 }
[10:27:05.999]             }
[10:27:05.999]         }))
[10:27:05.999]     }, error = function(ex) {
[10:27:05.999]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:05.999]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:05.999]                 ...future.rng), started = ...future.startTime, 
[10:27:05.999]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:05.999]             version = "1.8"), class = "FutureResult")
[10:27:05.999]     }, finally = {
[10:27:05.999]         if (!identical(...future.workdir, getwd())) 
[10:27:05.999]             setwd(...future.workdir)
[10:27:05.999]         {
[10:27:05.999]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:05.999]                 ...future.oldOptions$nwarnings <- NULL
[10:27:05.999]             }
[10:27:05.999]             base::options(...future.oldOptions)
[10:27:05.999]             if (.Platform$OS.type == "windows") {
[10:27:05.999]                 old_names <- names(...future.oldEnvVars)
[10:27:05.999]                 envs <- base::Sys.getenv()
[10:27:05.999]                 names <- names(envs)
[10:27:05.999]                 common <- intersect(names, old_names)
[10:27:05.999]                 added <- setdiff(names, old_names)
[10:27:05.999]                 removed <- setdiff(old_names, names)
[10:27:05.999]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:05.999]                   envs[common]]
[10:27:05.999]                 NAMES <- toupper(changed)
[10:27:05.999]                 args <- list()
[10:27:05.999]                 for (kk in seq_along(NAMES)) {
[10:27:05.999]                   name <- changed[[kk]]
[10:27:05.999]                   NAME <- NAMES[[kk]]
[10:27:05.999]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:05.999]                     next
[10:27:05.999]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:05.999]                 }
[10:27:05.999]                 NAMES <- toupper(added)
[10:27:05.999]                 for (kk in seq_along(NAMES)) {
[10:27:05.999]                   name <- added[[kk]]
[10:27:05.999]                   NAME <- NAMES[[kk]]
[10:27:05.999]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:05.999]                     next
[10:27:05.999]                   args[[name]] <- ""
[10:27:05.999]                 }
[10:27:05.999]                 NAMES <- toupper(removed)
[10:27:05.999]                 for (kk in seq_along(NAMES)) {
[10:27:05.999]                   name <- removed[[kk]]
[10:27:05.999]                   NAME <- NAMES[[kk]]
[10:27:05.999]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:05.999]                     next
[10:27:05.999]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:05.999]                 }
[10:27:05.999]                 if (length(args) > 0) 
[10:27:05.999]                   base::do.call(base::Sys.setenv, args = args)
[10:27:05.999]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:05.999]             }
[10:27:05.999]             else {
[10:27:05.999]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:05.999]             }
[10:27:05.999]             {
[10:27:05.999]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:05.999]                   0L) {
[10:27:05.999]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:05.999]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:05.999]                   base::options(opts)
[10:27:05.999]                 }
[10:27:05.999]                 {
[10:27:05.999]                   {
[10:27:05.999]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:05.999]                     NULL
[10:27:05.999]                   }
[10:27:05.999]                   options(future.plan = NULL)
[10:27:05.999]                   if (is.na(NA_character_)) 
[10:27:05.999]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:05.999]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:05.999]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:05.999]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:05.999]                     envir = parent.frame()) 
[10:27:05.999]                   {
[10:27:05.999]                     if (is.function(workers)) 
[10:27:05.999]                       workers <- workers()
[10:27:05.999]                     workers <- structure(as.integer(workers), 
[10:27:05.999]                       class = class(workers))
[10:27:05.999]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:05.999]                       workers >= 1)
[10:27:05.999]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:05.999]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:05.999]                     }
[10:27:05.999]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:05.999]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:05.999]                       envir = envir)
[10:27:05.999]                     if (!future$lazy) 
[10:27:05.999]                       future <- run(future)
[10:27:05.999]                     invisible(future)
[10:27:05.999]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:05.999]                 }
[10:27:05.999]             }
[10:27:05.999]         }
[10:27:05.999]     })
[10:27:05.999]     if (TRUE) {
[10:27:05.999]         base::sink(type = "output", split = FALSE)
[10:27:05.999]         if (TRUE) {
[10:27:05.999]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:05.999]         }
[10:27:05.999]         else {
[10:27:05.999]             ...future.result["stdout"] <- base::list(NULL)
[10:27:05.999]         }
[10:27:05.999]         base::close(...future.stdout)
[10:27:05.999]         ...future.stdout <- NULL
[10:27:05.999]     }
[10:27:05.999]     ...future.result$conditions <- ...future.conditions
[10:27:05.999]     ...future.result$finished <- base::Sys.time()
[10:27:05.999]     ...future.result
[10:27:05.999] }
[10:27:06.002] MultisessionFuture started
[10:27:06.002] - Launch lazy future ... done
[10:27:06.002] run() for ‘MultisessionFuture’ ... done
[10:27:06.050] receiveMessageFromWorker() for ClusterFuture ...
[10:27:06.051] - Validating connection of MultisessionFuture
[10:27:06.051] - received message: FutureResult
[10:27:06.051] - Received FutureResult
[10:27:06.051] - Erased future from FutureRegistry
[10:27:06.052] result() for ClusterFuture ...
[10:27:06.052] - result already collected: FutureResult
[10:27:06.052] result() for ClusterFuture ... done
[10:27:06.052] signalConditions() ...
[10:27:06.052]  - include = ‘immediateCondition’
[10:27:06.052]  - exclude = 
[10:27:06.052]  - resignal = FALSE
[10:27:06.052]  - Number of conditions: 1
[10:27:06.052] signalConditions() ... done
[10:27:06.052] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:06.052] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = FALSE ... DONE
- result = FALSE, recursive = TRUE ...
[10:27:06.053] getGlobalsAndPackages() ...
[10:27:06.053] Searching for globals...
[10:27:06.054] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:27:06.054] Searching for globals ... DONE
[10:27:06.054] Resolving globals: FALSE
[10:27:06.055] 
[10:27:06.055] 
[10:27:06.055] getGlobalsAndPackages() ... DONE
[10:27:06.055] run() for ‘Future’ ...
[10:27:06.055] - state: ‘created’
[10:27:06.055] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:06.072] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:06.073] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:06.073]   - Field: ‘node’
[10:27:06.073]   - Field: ‘label’
[10:27:06.073]   - Field: ‘local’
[10:27:06.073]   - Field: ‘owner’
[10:27:06.073]   - Field: ‘envir’
[10:27:06.073]   - Field: ‘workers’
[10:27:06.074]   - Field: ‘packages’
[10:27:06.074]   - Field: ‘gc’
[10:27:06.074]   - Field: ‘conditions’
[10:27:06.074]   - Field: ‘persistent’
[10:27:06.074]   - Field: ‘expr’
[10:27:06.074]   - Field: ‘uuid’
[10:27:06.074]   - Field: ‘seed’
[10:27:06.074]   - Field: ‘version’
[10:27:06.074]   - Field: ‘result’
[10:27:06.074]   - Field: ‘asynchronous’
[10:27:06.075]   - Field: ‘calls’
[10:27:06.075]   - Field: ‘globals’
[10:27:06.075]   - Field: ‘stdout’
[10:27:06.075]   - Field: ‘earlySignal’
[10:27:06.075]   - Field: ‘lazy’
[10:27:06.075]   - Field: ‘state’
[10:27:06.075] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:06.075] - Launch lazy future ...
[10:27:06.076] Packages needed by the future expression (n = 0): <none>
[10:27:06.076] Packages needed by future strategies (n = 0): <none>
[10:27:06.076] {
[10:27:06.076]     {
[10:27:06.076]         {
[10:27:06.076]             ...future.startTime <- base::Sys.time()
[10:27:06.076]             {
[10:27:06.076]                 {
[10:27:06.076]                   {
[10:27:06.076]                     {
[10:27:06.076]                       base::local({
[10:27:06.076]                         has_future <- base::requireNamespace("future", 
[10:27:06.076]                           quietly = TRUE)
[10:27:06.076]                         if (has_future) {
[10:27:06.076]                           ns <- base::getNamespace("future")
[10:27:06.076]                           version <- ns[[".package"]][["version"]]
[10:27:06.076]                           if (is.null(version)) 
[10:27:06.076]                             version <- utils::packageVersion("future")
[10:27:06.076]                         }
[10:27:06.076]                         else {
[10:27:06.076]                           version <- NULL
[10:27:06.076]                         }
[10:27:06.076]                         if (!has_future || version < "1.8.0") {
[10:27:06.076]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:06.076]                             "", base::R.version$version.string), 
[10:27:06.076]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:06.076]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:06.076]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:06.076]                               "release", "version")], collapse = " "), 
[10:27:06.076]                             hostname = base::Sys.info()[["nodename"]])
[10:27:06.076]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:06.076]                             info)
[10:27:06.076]                           info <- base::paste(info, collapse = "; ")
[10:27:06.076]                           if (!has_future) {
[10:27:06.076]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:06.076]                               info)
[10:27:06.076]                           }
[10:27:06.076]                           else {
[10:27:06.076]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:06.076]                               info, version)
[10:27:06.076]                           }
[10:27:06.076]                           base::stop(msg)
[10:27:06.076]                         }
[10:27:06.076]                       })
[10:27:06.076]                     }
[10:27:06.076]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:06.076]                     base::options(mc.cores = 1L)
[10:27:06.076]                   }
[10:27:06.076]                   options(future.plan = NULL)
[10:27:06.076]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:06.076]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:06.076]                 }
[10:27:06.076]                 ...future.workdir <- getwd()
[10:27:06.076]             }
[10:27:06.076]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:06.076]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:06.076]         }
[10:27:06.076]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:06.076]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:06.076]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:06.076]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:06.076]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:06.076]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:06.076]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:06.076]             base::names(...future.oldOptions))
[10:27:06.076]     }
[10:27:06.076]     if (FALSE) {
[10:27:06.076]     }
[10:27:06.076]     else {
[10:27:06.076]         if (TRUE) {
[10:27:06.076]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:06.076]                 open = "w")
[10:27:06.076]         }
[10:27:06.076]         else {
[10:27:06.076]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:06.076]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:06.076]         }
[10:27:06.076]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:06.076]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:06.076]             base::sink(type = "output", split = FALSE)
[10:27:06.076]             base::close(...future.stdout)
[10:27:06.076]         }, add = TRUE)
[10:27:06.076]     }
[10:27:06.076]     ...future.frame <- base::sys.nframe()
[10:27:06.076]     ...future.conditions <- base::list()
[10:27:06.076]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:06.076]     if (FALSE) {
[10:27:06.076]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:06.076]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:06.076]     }
[10:27:06.076]     ...future.result <- base::tryCatch({
[10:27:06.076]         base::withCallingHandlers({
[10:27:06.076]             ...future.value <- base::withVisible(base::local({
[10:27:06.076]                 ...future.makeSendCondition <- base::local({
[10:27:06.076]                   sendCondition <- NULL
[10:27:06.076]                   function(frame = 1L) {
[10:27:06.076]                     if (is.function(sendCondition)) 
[10:27:06.076]                       return(sendCondition)
[10:27:06.076]                     ns <- getNamespace("parallel")
[10:27:06.076]                     if (exists("sendData", mode = "function", 
[10:27:06.076]                       envir = ns)) {
[10:27:06.076]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:06.076]                         envir = ns)
[10:27:06.076]                       envir <- sys.frame(frame)
[10:27:06.076]                       master <- NULL
[10:27:06.076]                       while (!identical(envir, .GlobalEnv) && 
[10:27:06.076]                         !identical(envir, emptyenv())) {
[10:27:06.076]                         if (exists("master", mode = "list", envir = envir, 
[10:27:06.076]                           inherits = FALSE)) {
[10:27:06.076]                           master <- get("master", mode = "list", 
[10:27:06.076]                             envir = envir, inherits = FALSE)
[10:27:06.076]                           if (inherits(master, c("SOCKnode", 
[10:27:06.076]                             "SOCK0node"))) {
[10:27:06.076]                             sendCondition <<- function(cond) {
[10:27:06.076]                               data <- list(type = "VALUE", value = cond, 
[10:27:06.076]                                 success = TRUE)
[10:27:06.076]                               parallel_sendData(master, data)
[10:27:06.076]                             }
[10:27:06.076]                             return(sendCondition)
[10:27:06.076]                           }
[10:27:06.076]                         }
[10:27:06.076]                         frame <- frame + 1L
[10:27:06.076]                         envir <- sys.frame(frame)
[10:27:06.076]                       }
[10:27:06.076]                     }
[10:27:06.076]                     sendCondition <<- function(cond) NULL
[10:27:06.076]                   }
[10:27:06.076]                 })
[10:27:06.076]                 withCallingHandlers({
[10:27:06.076]                   {
[10:27:06.076]                     Sys.sleep(0.5)
[10:27:06.076]                     list(a = 1, b = 42L)
[10:27:06.076]                   }
[10:27:06.076]                 }, immediateCondition = function(cond) {
[10:27:06.076]                   sendCondition <- ...future.makeSendCondition()
[10:27:06.076]                   sendCondition(cond)
[10:27:06.076]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:06.076]                   {
[10:27:06.076]                     inherits <- base::inherits
[10:27:06.076]                     invokeRestart <- base::invokeRestart
[10:27:06.076]                     is.null <- base::is.null
[10:27:06.076]                     muffled <- FALSE
[10:27:06.076]                     if (inherits(cond, "message")) {
[10:27:06.076]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:06.076]                       if (muffled) 
[10:27:06.076]                         invokeRestart("muffleMessage")
[10:27:06.076]                     }
[10:27:06.076]                     else if (inherits(cond, "warning")) {
[10:27:06.076]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:06.076]                       if (muffled) 
[10:27:06.076]                         invokeRestart("muffleWarning")
[10:27:06.076]                     }
[10:27:06.076]                     else if (inherits(cond, "condition")) {
[10:27:06.076]                       if (!is.null(pattern)) {
[10:27:06.076]                         computeRestarts <- base::computeRestarts
[10:27:06.076]                         grepl <- base::grepl
[10:27:06.076]                         restarts <- computeRestarts(cond)
[10:27:06.076]                         for (restart in restarts) {
[10:27:06.076]                           name <- restart$name
[10:27:06.076]                           if (is.null(name)) 
[10:27:06.076]                             next
[10:27:06.076]                           if (!grepl(pattern, name)) 
[10:27:06.076]                             next
[10:27:06.076]                           invokeRestart(restart)
[10:27:06.076]                           muffled <- TRUE
[10:27:06.076]                           break
[10:27:06.076]                         }
[10:27:06.076]                       }
[10:27:06.076]                     }
[10:27:06.076]                     invisible(muffled)
[10:27:06.076]                   }
[10:27:06.076]                   muffleCondition(cond)
[10:27:06.076]                 })
[10:27:06.076]             }))
[10:27:06.076]             future::FutureResult(value = ...future.value$value, 
[10:27:06.076]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:06.076]                   ...future.rng), globalenv = if (FALSE) 
[10:27:06.076]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:06.076]                     ...future.globalenv.names))
[10:27:06.076]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:06.076]         }, condition = base::local({
[10:27:06.076]             c <- base::c
[10:27:06.076]             inherits <- base::inherits
[10:27:06.076]             invokeRestart <- base::invokeRestart
[10:27:06.076]             length <- base::length
[10:27:06.076]             list <- base::list
[10:27:06.076]             seq.int <- base::seq.int
[10:27:06.076]             signalCondition <- base::signalCondition
[10:27:06.076]             sys.calls <- base::sys.calls
[10:27:06.076]             `[[` <- base::`[[`
[10:27:06.076]             `+` <- base::`+`
[10:27:06.076]             `<<-` <- base::`<<-`
[10:27:06.076]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:06.076]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:06.076]                   3L)]
[10:27:06.076]             }
[10:27:06.076]             function(cond) {
[10:27:06.076]                 is_error <- inherits(cond, "error")
[10:27:06.076]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:06.076]                   NULL)
[10:27:06.076]                 if (is_error) {
[10:27:06.076]                   sessionInformation <- function() {
[10:27:06.076]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:06.076]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:06.076]                       search = base::search(), system = base::Sys.info())
[10:27:06.076]                   }
[10:27:06.076]                   ...future.conditions[[length(...future.conditions) + 
[10:27:06.076]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:06.076]                     cond$call), session = sessionInformation(), 
[10:27:06.076]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:06.076]                   signalCondition(cond)
[10:27:06.076]                 }
[10:27:06.076]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:06.076]                 "immediateCondition"))) {
[10:27:06.076]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:06.076]                   ...future.conditions[[length(...future.conditions) + 
[10:27:06.076]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:06.076]                   if (TRUE && !signal) {
[10:27:06.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:06.076]                     {
[10:27:06.076]                       inherits <- base::inherits
[10:27:06.076]                       invokeRestart <- base::invokeRestart
[10:27:06.076]                       is.null <- base::is.null
[10:27:06.076]                       muffled <- FALSE
[10:27:06.076]                       if (inherits(cond, "message")) {
[10:27:06.076]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:06.076]                         if (muffled) 
[10:27:06.076]                           invokeRestart("muffleMessage")
[10:27:06.076]                       }
[10:27:06.076]                       else if (inherits(cond, "warning")) {
[10:27:06.076]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:06.076]                         if (muffled) 
[10:27:06.076]                           invokeRestart("muffleWarning")
[10:27:06.076]                       }
[10:27:06.076]                       else if (inherits(cond, "condition")) {
[10:27:06.076]                         if (!is.null(pattern)) {
[10:27:06.076]                           computeRestarts <- base::computeRestarts
[10:27:06.076]                           grepl <- base::grepl
[10:27:06.076]                           restarts <- computeRestarts(cond)
[10:27:06.076]                           for (restart in restarts) {
[10:27:06.076]                             name <- restart$name
[10:27:06.076]                             if (is.null(name)) 
[10:27:06.076]                               next
[10:27:06.076]                             if (!grepl(pattern, name)) 
[10:27:06.076]                               next
[10:27:06.076]                             invokeRestart(restart)
[10:27:06.076]                             muffled <- TRUE
[10:27:06.076]                             break
[10:27:06.076]                           }
[10:27:06.076]                         }
[10:27:06.076]                       }
[10:27:06.076]                       invisible(muffled)
[10:27:06.076]                     }
[10:27:06.076]                     muffleCondition(cond, pattern = "^muffle")
[10:27:06.076]                   }
[10:27:06.076]                 }
[10:27:06.076]                 else {
[10:27:06.076]                   if (TRUE) {
[10:27:06.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:06.076]                     {
[10:27:06.076]                       inherits <- base::inherits
[10:27:06.076]                       invokeRestart <- base::invokeRestart
[10:27:06.076]                       is.null <- base::is.null
[10:27:06.076]                       muffled <- FALSE
[10:27:06.076]                       if (inherits(cond, "message")) {
[10:27:06.076]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:06.076]                         if (muffled) 
[10:27:06.076]                           invokeRestart("muffleMessage")
[10:27:06.076]                       }
[10:27:06.076]                       else if (inherits(cond, "warning")) {
[10:27:06.076]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:06.076]                         if (muffled) 
[10:27:06.076]                           invokeRestart("muffleWarning")
[10:27:06.076]                       }
[10:27:06.076]                       else if (inherits(cond, "condition")) {
[10:27:06.076]                         if (!is.null(pattern)) {
[10:27:06.076]                           computeRestarts <- base::computeRestarts
[10:27:06.076]                           grepl <- base::grepl
[10:27:06.076]                           restarts <- computeRestarts(cond)
[10:27:06.076]                           for (restart in restarts) {
[10:27:06.076]                             name <- restart$name
[10:27:06.076]                             if (is.null(name)) 
[10:27:06.076]                               next
[10:27:06.076]                             if (!grepl(pattern, name)) 
[10:27:06.076]                               next
[10:27:06.076]                             invokeRestart(restart)
[10:27:06.076]                             muffled <- TRUE
[10:27:06.076]                             break
[10:27:06.076]                           }
[10:27:06.076]                         }
[10:27:06.076]                       }
[10:27:06.076]                       invisible(muffled)
[10:27:06.076]                     }
[10:27:06.076]                     muffleCondition(cond, pattern = "^muffle")
[10:27:06.076]                   }
[10:27:06.076]                 }
[10:27:06.076]             }
[10:27:06.076]         }))
[10:27:06.076]     }, error = function(ex) {
[10:27:06.076]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:06.076]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:06.076]                 ...future.rng), started = ...future.startTime, 
[10:27:06.076]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:06.076]             version = "1.8"), class = "FutureResult")
[10:27:06.076]     }, finally = {
[10:27:06.076]         if (!identical(...future.workdir, getwd())) 
[10:27:06.076]             setwd(...future.workdir)
[10:27:06.076]         {
[10:27:06.076]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:06.076]                 ...future.oldOptions$nwarnings <- NULL
[10:27:06.076]             }
[10:27:06.076]             base::options(...future.oldOptions)
[10:27:06.076]             if (.Platform$OS.type == "windows") {
[10:27:06.076]                 old_names <- names(...future.oldEnvVars)
[10:27:06.076]                 envs <- base::Sys.getenv()
[10:27:06.076]                 names <- names(envs)
[10:27:06.076]                 common <- intersect(names, old_names)
[10:27:06.076]                 added <- setdiff(names, old_names)
[10:27:06.076]                 removed <- setdiff(old_names, names)
[10:27:06.076]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:06.076]                   envs[common]]
[10:27:06.076]                 NAMES <- toupper(changed)
[10:27:06.076]                 args <- list()
[10:27:06.076]                 for (kk in seq_along(NAMES)) {
[10:27:06.076]                   name <- changed[[kk]]
[10:27:06.076]                   NAME <- NAMES[[kk]]
[10:27:06.076]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:06.076]                     next
[10:27:06.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:06.076]                 }
[10:27:06.076]                 NAMES <- toupper(added)
[10:27:06.076]                 for (kk in seq_along(NAMES)) {
[10:27:06.076]                   name <- added[[kk]]
[10:27:06.076]                   NAME <- NAMES[[kk]]
[10:27:06.076]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:06.076]                     next
[10:27:06.076]                   args[[name]] <- ""
[10:27:06.076]                 }
[10:27:06.076]                 NAMES <- toupper(removed)
[10:27:06.076]                 for (kk in seq_along(NAMES)) {
[10:27:06.076]                   name <- removed[[kk]]
[10:27:06.076]                   NAME <- NAMES[[kk]]
[10:27:06.076]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:06.076]                     next
[10:27:06.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:06.076]                 }
[10:27:06.076]                 if (length(args) > 0) 
[10:27:06.076]                   base::do.call(base::Sys.setenv, args = args)
[10:27:06.076]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:06.076]             }
[10:27:06.076]             else {
[10:27:06.076]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:06.076]             }
[10:27:06.076]             {
[10:27:06.076]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:06.076]                   0L) {
[10:27:06.076]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:06.076]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:06.076]                   base::options(opts)
[10:27:06.076]                 }
[10:27:06.076]                 {
[10:27:06.076]                   {
[10:27:06.076]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:06.076]                     NULL
[10:27:06.076]                   }
[10:27:06.076]                   options(future.plan = NULL)
[10:27:06.076]                   if (is.na(NA_character_)) 
[10:27:06.076]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:06.076]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:06.076]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:06.076]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:06.076]                     envir = parent.frame()) 
[10:27:06.076]                   {
[10:27:06.076]                     if (is.function(workers)) 
[10:27:06.076]                       workers <- workers()
[10:27:06.076]                     workers <- structure(as.integer(workers), 
[10:27:06.076]                       class = class(workers))
[10:27:06.076]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:06.076]                       workers >= 1)
[10:27:06.076]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:06.076]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:06.076]                     }
[10:27:06.076]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:06.076]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:06.076]                       envir = envir)
[10:27:06.076]                     if (!future$lazy) 
[10:27:06.076]                       future <- run(future)
[10:27:06.076]                     invisible(future)
[10:27:06.076]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:06.076]                 }
[10:27:06.076]             }
[10:27:06.076]         }
[10:27:06.076]     })
[10:27:06.076]     if (TRUE) {
[10:27:06.076]         base::sink(type = "output", split = FALSE)
[10:27:06.076]         if (TRUE) {
[10:27:06.076]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:06.076]         }
[10:27:06.076]         else {
[10:27:06.076]             ...future.result["stdout"] <- base::list(NULL)
[10:27:06.076]         }
[10:27:06.076]         base::close(...future.stdout)
[10:27:06.076]         ...future.stdout <- NULL
[10:27:06.076]     }
[10:27:06.076]     ...future.result$conditions <- ...future.conditions
[10:27:06.076]     ...future.result$finished <- base::Sys.time()
[10:27:06.076]     ...future.result
[10:27:06.076] }
[10:27:06.079] MultisessionFuture started
[10:27:06.079] - Launch lazy future ... done
[10:27:06.080] run() for ‘MultisessionFuture’ ... done
[10:27:06.629] receiveMessageFromWorker() for ClusterFuture ...
[10:27:06.630] - Validating connection of MultisessionFuture
[10:27:06.630] - received message: FutureResult
[10:27:06.631] - Received FutureResult
[10:27:06.631] - Erased future from FutureRegistry
[10:27:06.631] result() for ClusterFuture ...
[10:27:06.631] - result already collected: FutureResult
[10:27:06.632] result() for ClusterFuture ... done
[10:27:06.632] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:06.632] A MultisessionFuture was resolved (result was not collected)
[10:27:06.632] getGlobalsAndPackages() ...
[10:27:06.632] Searching for globals...
[10:27:06.634] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:27:06.634] Searching for globals ... DONE
[10:27:06.634] Resolving globals: FALSE
[10:27:06.634] 
[10:27:06.634] 
[10:27:06.634] getGlobalsAndPackages() ... DONE
[10:27:06.635] run() for ‘Future’ ...
[10:27:06.635] - state: ‘created’
[10:27:06.635] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:06.649] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:06.649] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:06.649]   - Field: ‘node’
[10:27:06.649]   - Field: ‘label’
[10:27:06.649]   - Field: ‘local’
[10:27:06.650]   - Field: ‘owner’
[10:27:06.650]   - Field: ‘envir’
[10:27:06.650]   - Field: ‘workers’
[10:27:06.650]   - Field: ‘packages’
[10:27:06.650]   - Field: ‘gc’
[10:27:06.650]   - Field: ‘conditions’
[10:27:06.650]   - Field: ‘persistent’
[10:27:06.650]   - Field: ‘expr’
[10:27:06.650]   - Field: ‘uuid’
[10:27:06.650]   - Field: ‘seed’
[10:27:06.650]   - Field: ‘version’
[10:27:06.651]   - Field: ‘result’
[10:27:06.651]   - Field: ‘asynchronous’
[10:27:06.651]   - Field: ‘calls’
[10:27:06.651]   - Field: ‘globals’
[10:27:06.651]   - Field: ‘stdout’
[10:27:06.651]   - Field: ‘earlySignal’
[10:27:06.651]   - Field: ‘lazy’
[10:27:06.651]   - Field: ‘state’
[10:27:06.651] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:06.651] - Launch lazy future ...
[10:27:06.652] Packages needed by the future expression (n = 0): <none>
[10:27:06.652] Packages needed by future strategies (n = 0): <none>
[10:27:06.652] {
[10:27:06.652]     {
[10:27:06.652]         {
[10:27:06.652]             ...future.startTime <- base::Sys.time()
[10:27:06.652]             {
[10:27:06.652]                 {
[10:27:06.652]                   {
[10:27:06.652]                     {
[10:27:06.652]                       base::local({
[10:27:06.652]                         has_future <- base::requireNamespace("future", 
[10:27:06.652]                           quietly = TRUE)
[10:27:06.652]                         if (has_future) {
[10:27:06.652]                           ns <- base::getNamespace("future")
[10:27:06.652]                           version <- ns[[".package"]][["version"]]
[10:27:06.652]                           if (is.null(version)) 
[10:27:06.652]                             version <- utils::packageVersion("future")
[10:27:06.652]                         }
[10:27:06.652]                         else {
[10:27:06.652]                           version <- NULL
[10:27:06.652]                         }
[10:27:06.652]                         if (!has_future || version < "1.8.0") {
[10:27:06.652]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:06.652]                             "", base::R.version$version.string), 
[10:27:06.652]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:06.652]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:06.652]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:06.652]                               "release", "version")], collapse = " "), 
[10:27:06.652]                             hostname = base::Sys.info()[["nodename"]])
[10:27:06.652]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:06.652]                             info)
[10:27:06.652]                           info <- base::paste(info, collapse = "; ")
[10:27:06.652]                           if (!has_future) {
[10:27:06.652]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:06.652]                               info)
[10:27:06.652]                           }
[10:27:06.652]                           else {
[10:27:06.652]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:06.652]                               info, version)
[10:27:06.652]                           }
[10:27:06.652]                           base::stop(msg)
[10:27:06.652]                         }
[10:27:06.652]                       })
[10:27:06.652]                     }
[10:27:06.652]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:06.652]                     base::options(mc.cores = 1L)
[10:27:06.652]                   }
[10:27:06.652]                   options(future.plan = NULL)
[10:27:06.652]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:06.652]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:06.652]                 }
[10:27:06.652]                 ...future.workdir <- getwd()
[10:27:06.652]             }
[10:27:06.652]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:06.652]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:06.652]         }
[10:27:06.652]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:06.652]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:06.652]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:06.652]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:06.652]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:06.652]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:06.652]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:06.652]             base::names(...future.oldOptions))
[10:27:06.652]     }
[10:27:06.652]     if (FALSE) {
[10:27:06.652]     }
[10:27:06.652]     else {
[10:27:06.652]         if (TRUE) {
[10:27:06.652]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:06.652]                 open = "w")
[10:27:06.652]         }
[10:27:06.652]         else {
[10:27:06.652]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:06.652]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:06.652]         }
[10:27:06.652]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:06.652]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:06.652]             base::sink(type = "output", split = FALSE)
[10:27:06.652]             base::close(...future.stdout)
[10:27:06.652]         }, add = TRUE)
[10:27:06.652]     }
[10:27:06.652]     ...future.frame <- base::sys.nframe()
[10:27:06.652]     ...future.conditions <- base::list()
[10:27:06.652]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:06.652]     if (FALSE) {
[10:27:06.652]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:06.652]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:06.652]     }
[10:27:06.652]     ...future.result <- base::tryCatch({
[10:27:06.652]         base::withCallingHandlers({
[10:27:06.652]             ...future.value <- base::withVisible(base::local({
[10:27:06.652]                 ...future.makeSendCondition <- base::local({
[10:27:06.652]                   sendCondition <- NULL
[10:27:06.652]                   function(frame = 1L) {
[10:27:06.652]                     if (is.function(sendCondition)) 
[10:27:06.652]                       return(sendCondition)
[10:27:06.652]                     ns <- getNamespace("parallel")
[10:27:06.652]                     if (exists("sendData", mode = "function", 
[10:27:06.652]                       envir = ns)) {
[10:27:06.652]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:06.652]                         envir = ns)
[10:27:06.652]                       envir <- sys.frame(frame)
[10:27:06.652]                       master <- NULL
[10:27:06.652]                       while (!identical(envir, .GlobalEnv) && 
[10:27:06.652]                         !identical(envir, emptyenv())) {
[10:27:06.652]                         if (exists("master", mode = "list", envir = envir, 
[10:27:06.652]                           inherits = FALSE)) {
[10:27:06.652]                           master <- get("master", mode = "list", 
[10:27:06.652]                             envir = envir, inherits = FALSE)
[10:27:06.652]                           if (inherits(master, c("SOCKnode", 
[10:27:06.652]                             "SOCK0node"))) {
[10:27:06.652]                             sendCondition <<- function(cond) {
[10:27:06.652]                               data <- list(type = "VALUE", value = cond, 
[10:27:06.652]                                 success = TRUE)
[10:27:06.652]                               parallel_sendData(master, data)
[10:27:06.652]                             }
[10:27:06.652]                             return(sendCondition)
[10:27:06.652]                           }
[10:27:06.652]                         }
[10:27:06.652]                         frame <- frame + 1L
[10:27:06.652]                         envir <- sys.frame(frame)
[10:27:06.652]                       }
[10:27:06.652]                     }
[10:27:06.652]                     sendCondition <<- function(cond) NULL
[10:27:06.652]                   }
[10:27:06.652]                 })
[10:27:06.652]                 withCallingHandlers({
[10:27:06.652]                   {
[10:27:06.652]                     Sys.sleep(0.5)
[10:27:06.652]                     list(a = 1, b = 42L)
[10:27:06.652]                   }
[10:27:06.652]                 }, immediateCondition = function(cond) {
[10:27:06.652]                   sendCondition <- ...future.makeSendCondition()
[10:27:06.652]                   sendCondition(cond)
[10:27:06.652]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:06.652]                   {
[10:27:06.652]                     inherits <- base::inherits
[10:27:06.652]                     invokeRestart <- base::invokeRestart
[10:27:06.652]                     is.null <- base::is.null
[10:27:06.652]                     muffled <- FALSE
[10:27:06.652]                     if (inherits(cond, "message")) {
[10:27:06.652]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:06.652]                       if (muffled) 
[10:27:06.652]                         invokeRestart("muffleMessage")
[10:27:06.652]                     }
[10:27:06.652]                     else if (inherits(cond, "warning")) {
[10:27:06.652]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:06.652]                       if (muffled) 
[10:27:06.652]                         invokeRestart("muffleWarning")
[10:27:06.652]                     }
[10:27:06.652]                     else if (inherits(cond, "condition")) {
[10:27:06.652]                       if (!is.null(pattern)) {
[10:27:06.652]                         computeRestarts <- base::computeRestarts
[10:27:06.652]                         grepl <- base::grepl
[10:27:06.652]                         restarts <- computeRestarts(cond)
[10:27:06.652]                         for (restart in restarts) {
[10:27:06.652]                           name <- restart$name
[10:27:06.652]                           if (is.null(name)) 
[10:27:06.652]                             next
[10:27:06.652]                           if (!grepl(pattern, name)) 
[10:27:06.652]                             next
[10:27:06.652]                           invokeRestart(restart)
[10:27:06.652]                           muffled <- TRUE
[10:27:06.652]                           break
[10:27:06.652]                         }
[10:27:06.652]                       }
[10:27:06.652]                     }
[10:27:06.652]                     invisible(muffled)
[10:27:06.652]                   }
[10:27:06.652]                   muffleCondition(cond)
[10:27:06.652]                 })
[10:27:06.652]             }))
[10:27:06.652]             future::FutureResult(value = ...future.value$value, 
[10:27:06.652]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:06.652]                   ...future.rng), globalenv = if (FALSE) 
[10:27:06.652]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:06.652]                     ...future.globalenv.names))
[10:27:06.652]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:06.652]         }, condition = base::local({
[10:27:06.652]             c <- base::c
[10:27:06.652]             inherits <- base::inherits
[10:27:06.652]             invokeRestart <- base::invokeRestart
[10:27:06.652]             length <- base::length
[10:27:06.652]             list <- base::list
[10:27:06.652]             seq.int <- base::seq.int
[10:27:06.652]             signalCondition <- base::signalCondition
[10:27:06.652]             sys.calls <- base::sys.calls
[10:27:06.652]             `[[` <- base::`[[`
[10:27:06.652]             `+` <- base::`+`
[10:27:06.652]             `<<-` <- base::`<<-`
[10:27:06.652]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:06.652]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:06.652]                   3L)]
[10:27:06.652]             }
[10:27:06.652]             function(cond) {
[10:27:06.652]                 is_error <- inherits(cond, "error")
[10:27:06.652]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:06.652]                   NULL)
[10:27:06.652]                 if (is_error) {
[10:27:06.652]                   sessionInformation <- function() {
[10:27:06.652]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:06.652]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:06.652]                       search = base::search(), system = base::Sys.info())
[10:27:06.652]                   }
[10:27:06.652]                   ...future.conditions[[length(...future.conditions) + 
[10:27:06.652]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:06.652]                     cond$call), session = sessionInformation(), 
[10:27:06.652]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:06.652]                   signalCondition(cond)
[10:27:06.652]                 }
[10:27:06.652]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:06.652]                 "immediateCondition"))) {
[10:27:06.652]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:06.652]                   ...future.conditions[[length(...future.conditions) + 
[10:27:06.652]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:06.652]                   if (TRUE && !signal) {
[10:27:06.652]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:06.652]                     {
[10:27:06.652]                       inherits <- base::inherits
[10:27:06.652]                       invokeRestart <- base::invokeRestart
[10:27:06.652]                       is.null <- base::is.null
[10:27:06.652]                       muffled <- FALSE
[10:27:06.652]                       if (inherits(cond, "message")) {
[10:27:06.652]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:06.652]                         if (muffled) 
[10:27:06.652]                           invokeRestart("muffleMessage")
[10:27:06.652]                       }
[10:27:06.652]                       else if (inherits(cond, "warning")) {
[10:27:06.652]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:06.652]                         if (muffled) 
[10:27:06.652]                           invokeRestart("muffleWarning")
[10:27:06.652]                       }
[10:27:06.652]                       else if (inherits(cond, "condition")) {
[10:27:06.652]                         if (!is.null(pattern)) {
[10:27:06.652]                           computeRestarts <- base::computeRestarts
[10:27:06.652]                           grepl <- base::grepl
[10:27:06.652]                           restarts <- computeRestarts(cond)
[10:27:06.652]                           for (restart in restarts) {
[10:27:06.652]                             name <- restart$name
[10:27:06.652]                             if (is.null(name)) 
[10:27:06.652]                               next
[10:27:06.652]                             if (!grepl(pattern, name)) 
[10:27:06.652]                               next
[10:27:06.652]                             invokeRestart(restart)
[10:27:06.652]                             muffled <- TRUE
[10:27:06.652]                             break
[10:27:06.652]                           }
[10:27:06.652]                         }
[10:27:06.652]                       }
[10:27:06.652]                       invisible(muffled)
[10:27:06.652]                     }
[10:27:06.652]                     muffleCondition(cond, pattern = "^muffle")
[10:27:06.652]                   }
[10:27:06.652]                 }
[10:27:06.652]                 else {
[10:27:06.652]                   if (TRUE) {
[10:27:06.652]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:06.652]                     {
[10:27:06.652]                       inherits <- base::inherits
[10:27:06.652]                       invokeRestart <- base::invokeRestart
[10:27:06.652]                       is.null <- base::is.null
[10:27:06.652]                       muffled <- FALSE
[10:27:06.652]                       if (inherits(cond, "message")) {
[10:27:06.652]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:06.652]                         if (muffled) 
[10:27:06.652]                           invokeRestart("muffleMessage")
[10:27:06.652]                       }
[10:27:06.652]                       else if (inherits(cond, "warning")) {
[10:27:06.652]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:06.652]                         if (muffled) 
[10:27:06.652]                           invokeRestart("muffleWarning")
[10:27:06.652]                       }
[10:27:06.652]                       else if (inherits(cond, "condition")) {
[10:27:06.652]                         if (!is.null(pattern)) {
[10:27:06.652]                           computeRestarts <- base::computeRestarts
[10:27:06.652]                           grepl <- base::grepl
[10:27:06.652]                           restarts <- computeRestarts(cond)
[10:27:06.652]                           for (restart in restarts) {
[10:27:06.652]                             name <- restart$name
[10:27:06.652]                             if (is.null(name)) 
[10:27:06.652]                               next
[10:27:06.652]                             if (!grepl(pattern, name)) 
[10:27:06.652]                               next
[10:27:06.652]                             invokeRestart(restart)
[10:27:06.652]                             muffled <- TRUE
[10:27:06.652]                             break
[10:27:06.652]                           }
[10:27:06.652]                         }
[10:27:06.652]                       }
[10:27:06.652]                       invisible(muffled)
[10:27:06.652]                     }
[10:27:06.652]                     muffleCondition(cond, pattern = "^muffle")
[10:27:06.652]                   }
[10:27:06.652]                 }
[10:27:06.652]             }
[10:27:06.652]         }))
[10:27:06.652]     }, error = function(ex) {
[10:27:06.652]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:06.652]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:06.652]                 ...future.rng), started = ...future.startTime, 
[10:27:06.652]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:06.652]             version = "1.8"), class = "FutureResult")
[10:27:06.652]     }, finally = {
[10:27:06.652]         if (!identical(...future.workdir, getwd())) 
[10:27:06.652]             setwd(...future.workdir)
[10:27:06.652]         {
[10:27:06.652]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:06.652]                 ...future.oldOptions$nwarnings <- NULL
[10:27:06.652]             }
[10:27:06.652]             base::options(...future.oldOptions)
[10:27:06.652]             if (.Platform$OS.type == "windows") {
[10:27:06.652]                 old_names <- names(...future.oldEnvVars)
[10:27:06.652]                 envs <- base::Sys.getenv()
[10:27:06.652]                 names <- names(envs)
[10:27:06.652]                 common <- intersect(names, old_names)
[10:27:06.652]                 added <- setdiff(names, old_names)
[10:27:06.652]                 removed <- setdiff(old_names, names)
[10:27:06.652]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:06.652]                   envs[common]]
[10:27:06.652]                 NAMES <- toupper(changed)
[10:27:06.652]                 args <- list()
[10:27:06.652]                 for (kk in seq_along(NAMES)) {
[10:27:06.652]                   name <- changed[[kk]]
[10:27:06.652]                   NAME <- NAMES[[kk]]
[10:27:06.652]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:06.652]                     next
[10:27:06.652]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:06.652]                 }
[10:27:06.652]                 NAMES <- toupper(added)
[10:27:06.652]                 for (kk in seq_along(NAMES)) {
[10:27:06.652]                   name <- added[[kk]]
[10:27:06.652]                   NAME <- NAMES[[kk]]
[10:27:06.652]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:06.652]                     next
[10:27:06.652]                   args[[name]] <- ""
[10:27:06.652]                 }
[10:27:06.652]                 NAMES <- toupper(removed)
[10:27:06.652]                 for (kk in seq_along(NAMES)) {
[10:27:06.652]                   name <- removed[[kk]]
[10:27:06.652]                   NAME <- NAMES[[kk]]
[10:27:06.652]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:06.652]                     next
[10:27:06.652]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:06.652]                 }
[10:27:06.652]                 if (length(args) > 0) 
[10:27:06.652]                   base::do.call(base::Sys.setenv, args = args)
[10:27:06.652]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:06.652]             }
[10:27:06.652]             else {
[10:27:06.652]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:06.652]             }
[10:27:06.652]             {
[10:27:06.652]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:06.652]                   0L) {
[10:27:06.652]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:06.652]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:06.652]                   base::options(opts)
[10:27:06.652]                 }
[10:27:06.652]                 {
[10:27:06.652]                   {
[10:27:06.652]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:06.652]                     NULL
[10:27:06.652]                   }
[10:27:06.652]                   options(future.plan = NULL)
[10:27:06.652]                   if (is.na(NA_character_)) 
[10:27:06.652]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:06.652]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:06.652]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:06.652]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:06.652]                     envir = parent.frame()) 
[10:27:06.652]                   {
[10:27:06.652]                     if (is.function(workers)) 
[10:27:06.652]                       workers <- workers()
[10:27:06.652]                     workers <- structure(as.integer(workers), 
[10:27:06.652]                       class = class(workers))
[10:27:06.652]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:06.652]                       workers >= 1)
[10:27:06.652]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:06.652]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:06.652]                     }
[10:27:06.652]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:06.652]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:06.652]                       envir = envir)
[10:27:06.652]                     if (!future$lazy) 
[10:27:06.652]                       future <- run(future)
[10:27:06.652]                     invisible(future)
[10:27:06.652]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:06.652]                 }
[10:27:06.652]             }
[10:27:06.652]         }
[10:27:06.652]     })
[10:27:06.652]     if (TRUE) {
[10:27:06.652]         base::sink(type = "output", split = FALSE)
[10:27:06.652]         if (TRUE) {
[10:27:06.652]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:06.652]         }
[10:27:06.652]         else {
[10:27:06.652]             ...future.result["stdout"] <- base::list(NULL)
[10:27:06.652]         }
[10:27:06.652]         base::close(...future.stdout)
[10:27:06.652]         ...future.stdout <- NULL
[10:27:06.652]     }
[10:27:06.652]     ...future.result$conditions <- ...future.conditions
[10:27:06.652]     ...future.result$finished <- base::Sys.time()
[10:27:06.652]     ...future.result
[10:27:06.652] }
[10:27:06.656] MultisessionFuture started
[10:27:06.656] - Launch lazy future ... done
[10:27:06.656] run() for ‘MultisessionFuture’ ... done
[10:27:07.204] receiveMessageFromWorker() for ClusterFuture ...
[10:27:07.204] - Validating connection of MultisessionFuture
[10:27:07.204] - received message: FutureResult
[10:27:07.204] - Received FutureResult
[10:27:07.204] - Erased future from FutureRegistry
[10:27:07.205] result() for ClusterFuture ...
[10:27:07.205] - result already collected: FutureResult
[10:27:07.205] result() for ClusterFuture ... done
[10:27:07.205] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:07.205] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[10:27:07.205] getGlobalsAndPackages() ...
[10:27:07.205] Searching for globals...
[10:27:07.206] - globals found: [2] ‘list’, ‘stop’
[10:27:07.206] Searching for globals ... DONE
[10:27:07.206] Resolving globals: FALSE
[10:27:07.207] 
[10:27:07.207] 
[10:27:07.207] getGlobalsAndPackages() ... DONE
[10:27:07.207] run() for ‘Future’ ...
[10:27:07.207] - state: ‘created’
[10:27:07.207] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:07.221] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:07.222] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:07.222]   - Field: ‘node’
[10:27:07.222]   - Field: ‘label’
[10:27:07.222]   - Field: ‘local’
[10:27:07.222]   - Field: ‘owner’
[10:27:07.222]   - Field: ‘envir’
[10:27:07.222]   - Field: ‘workers’
[10:27:07.222]   - Field: ‘packages’
[10:27:07.222]   - Field: ‘gc’
[10:27:07.223]   - Field: ‘conditions’
[10:27:07.223]   - Field: ‘persistent’
[10:27:07.223]   - Field: ‘expr’
[10:27:07.223]   - Field: ‘uuid’
[10:27:07.223]   - Field: ‘seed’
[10:27:07.223]   - Field: ‘version’
[10:27:07.223]   - Field: ‘result’
[10:27:07.223]   - Field: ‘asynchronous’
[10:27:07.223]   - Field: ‘calls’
[10:27:07.223]   - Field: ‘globals’
[10:27:07.224]   - Field: ‘stdout’
[10:27:07.224]   - Field: ‘earlySignal’
[10:27:07.224]   - Field: ‘lazy’
[10:27:07.224]   - Field: ‘state’
[10:27:07.224] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:07.224] - Launch lazy future ...
[10:27:07.224] Packages needed by the future expression (n = 0): <none>
[10:27:07.224] Packages needed by future strategies (n = 0): <none>
[10:27:07.225] {
[10:27:07.225]     {
[10:27:07.225]         {
[10:27:07.225]             ...future.startTime <- base::Sys.time()
[10:27:07.225]             {
[10:27:07.225]                 {
[10:27:07.225]                   {
[10:27:07.225]                     {
[10:27:07.225]                       base::local({
[10:27:07.225]                         has_future <- base::requireNamespace("future", 
[10:27:07.225]                           quietly = TRUE)
[10:27:07.225]                         if (has_future) {
[10:27:07.225]                           ns <- base::getNamespace("future")
[10:27:07.225]                           version <- ns[[".package"]][["version"]]
[10:27:07.225]                           if (is.null(version)) 
[10:27:07.225]                             version <- utils::packageVersion("future")
[10:27:07.225]                         }
[10:27:07.225]                         else {
[10:27:07.225]                           version <- NULL
[10:27:07.225]                         }
[10:27:07.225]                         if (!has_future || version < "1.8.0") {
[10:27:07.225]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:07.225]                             "", base::R.version$version.string), 
[10:27:07.225]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:07.225]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:07.225]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:07.225]                               "release", "version")], collapse = " "), 
[10:27:07.225]                             hostname = base::Sys.info()[["nodename"]])
[10:27:07.225]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:07.225]                             info)
[10:27:07.225]                           info <- base::paste(info, collapse = "; ")
[10:27:07.225]                           if (!has_future) {
[10:27:07.225]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:07.225]                               info)
[10:27:07.225]                           }
[10:27:07.225]                           else {
[10:27:07.225]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:07.225]                               info, version)
[10:27:07.225]                           }
[10:27:07.225]                           base::stop(msg)
[10:27:07.225]                         }
[10:27:07.225]                       })
[10:27:07.225]                     }
[10:27:07.225]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:07.225]                     base::options(mc.cores = 1L)
[10:27:07.225]                   }
[10:27:07.225]                   options(future.plan = NULL)
[10:27:07.225]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:07.225]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:07.225]                 }
[10:27:07.225]                 ...future.workdir <- getwd()
[10:27:07.225]             }
[10:27:07.225]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:07.225]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:07.225]         }
[10:27:07.225]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:07.225]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:07.225]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:07.225]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:07.225]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:07.225]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:07.225]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:07.225]             base::names(...future.oldOptions))
[10:27:07.225]     }
[10:27:07.225]     if (FALSE) {
[10:27:07.225]     }
[10:27:07.225]     else {
[10:27:07.225]         if (TRUE) {
[10:27:07.225]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:07.225]                 open = "w")
[10:27:07.225]         }
[10:27:07.225]         else {
[10:27:07.225]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:07.225]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:07.225]         }
[10:27:07.225]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:07.225]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:07.225]             base::sink(type = "output", split = FALSE)
[10:27:07.225]             base::close(...future.stdout)
[10:27:07.225]         }, add = TRUE)
[10:27:07.225]     }
[10:27:07.225]     ...future.frame <- base::sys.nframe()
[10:27:07.225]     ...future.conditions <- base::list()
[10:27:07.225]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:07.225]     if (FALSE) {
[10:27:07.225]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:07.225]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:07.225]     }
[10:27:07.225]     ...future.result <- base::tryCatch({
[10:27:07.225]         base::withCallingHandlers({
[10:27:07.225]             ...future.value <- base::withVisible(base::local({
[10:27:07.225]                 ...future.makeSendCondition <- base::local({
[10:27:07.225]                   sendCondition <- NULL
[10:27:07.225]                   function(frame = 1L) {
[10:27:07.225]                     if (is.function(sendCondition)) 
[10:27:07.225]                       return(sendCondition)
[10:27:07.225]                     ns <- getNamespace("parallel")
[10:27:07.225]                     if (exists("sendData", mode = "function", 
[10:27:07.225]                       envir = ns)) {
[10:27:07.225]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:07.225]                         envir = ns)
[10:27:07.225]                       envir <- sys.frame(frame)
[10:27:07.225]                       master <- NULL
[10:27:07.225]                       while (!identical(envir, .GlobalEnv) && 
[10:27:07.225]                         !identical(envir, emptyenv())) {
[10:27:07.225]                         if (exists("master", mode = "list", envir = envir, 
[10:27:07.225]                           inherits = FALSE)) {
[10:27:07.225]                           master <- get("master", mode = "list", 
[10:27:07.225]                             envir = envir, inherits = FALSE)
[10:27:07.225]                           if (inherits(master, c("SOCKnode", 
[10:27:07.225]                             "SOCK0node"))) {
[10:27:07.225]                             sendCondition <<- function(cond) {
[10:27:07.225]                               data <- list(type = "VALUE", value = cond, 
[10:27:07.225]                                 success = TRUE)
[10:27:07.225]                               parallel_sendData(master, data)
[10:27:07.225]                             }
[10:27:07.225]                             return(sendCondition)
[10:27:07.225]                           }
[10:27:07.225]                         }
[10:27:07.225]                         frame <- frame + 1L
[10:27:07.225]                         envir <- sys.frame(frame)
[10:27:07.225]                       }
[10:27:07.225]                     }
[10:27:07.225]                     sendCondition <<- function(cond) NULL
[10:27:07.225]                   }
[10:27:07.225]                 })
[10:27:07.225]                 withCallingHandlers({
[10:27:07.225]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:27:07.225]                 }, immediateCondition = function(cond) {
[10:27:07.225]                   sendCondition <- ...future.makeSendCondition()
[10:27:07.225]                   sendCondition(cond)
[10:27:07.225]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:07.225]                   {
[10:27:07.225]                     inherits <- base::inherits
[10:27:07.225]                     invokeRestart <- base::invokeRestart
[10:27:07.225]                     is.null <- base::is.null
[10:27:07.225]                     muffled <- FALSE
[10:27:07.225]                     if (inherits(cond, "message")) {
[10:27:07.225]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:07.225]                       if (muffled) 
[10:27:07.225]                         invokeRestart("muffleMessage")
[10:27:07.225]                     }
[10:27:07.225]                     else if (inherits(cond, "warning")) {
[10:27:07.225]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:07.225]                       if (muffled) 
[10:27:07.225]                         invokeRestart("muffleWarning")
[10:27:07.225]                     }
[10:27:07.225]                     else if (inherits(cond, "condition")) {
[10:27:07.225]                       if (!is.null(pattern)) {
[10:27:07.225]                         computeRestarts <- base::computeRestarts
[10:27:07.225]                         grepl <- base::grepl
[10:27:07.225]                         restarts <- computeRestarts(cond)
[10:27:07.225]                         for (restart in restarts) {
[10:27:07.225]                           name <- restart$name
[10:27:07.225]                           if (is.null(name)) 
[10:27:07.225]                             next
[10:27:07.225]                           if (!grepl(pattern, name)) 
[10:27:07.225]                             next
[10:27:07.225]                           invokeRestart(restart)
[10:27:07.225]                           muffled <- TRUE
[10:27:07.225]                           break
[10:27:07.225]                         }
[10:27:07.225]                       }
[10:27:07.225]                     }
[10:27:07.225]                     invisible(muffled)
[10:27:07.225]                   }
[10:27:07.225]                   muffleCondition(cond)
[10:27:07.225]                 })
[10:27:07.225]             }))
[10:27:07.225]             future::FutureResult(value = ...future.value$value, 
[10:27:07.225]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:07.225]                   ...future.rng), globalenv = if (FALSE) 
[10:27:07.225]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:07.225]                     ...future.globalenv.names))
[10:27:07.225]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:07.225]         }, condition = base::local({
[10:27:07.225]             c <- base::c
[10:27:07.225]             inherits <- base::inherits
[10:27:07.225]             invokeRestart <- base::invokeRestart
[10:27:07.225]             length <- base::length
[10:27:07.225]             list <- base::list
[10:27:07.225]             seq.int <- base::seq.int
[10:27:07.225]             signalCondition <- base::signalCondition
[10:27:07.225]             sys.calls <- base::sys.calls
[10:27:07.225]             `[[` <- base::`[[`
[10:27:07.225]             `+` <- base::`+`
[10:27:07.225]             `<<-` <- base::`<<-`
[10:27:07.225]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:07.225]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:07.225]                   3L)]
[10:27:07.225]             }
[10:27:07.225]             function(cond) {
[10:27:07.225]                 is_error <- inherits(cond, "error")
[10:27:07.225]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:07.225]                   NULL)
[10:27:07.225]                 if (is_error) {
[10:27:07.225]                   sessionInformation <- function() {
[10:27:07.225]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:07.225]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:07.225]                       search = base::search(), system = base::Sys.info())
[10:27:07.225]                   }
[10:27:07.225]                   ...future.conditions[[length(...future.conditions) + 
[10:27:07.225]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:07.225]                     cond$call), session = sessionInformation(), 
[10:27:07.225]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:07.225]                   signalCondition(cond)
[10:27:07.225]                 }
[10:27:07.225]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:07.225]                 "immediateCondition"))) {
[10:27:07.225]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:07.225]                   ...future.conditions[[length(...future.conditions) + 
[10:27:07.225]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:07.225]                   if (TRUE && !signal) {
[10:27:07.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:07.225]                     {
[10:27:07.225]                       inherits <- base::inherits
[10:27:07.225]                       invokeRestart <- base::invokeRestart
[10:27:07.225]                       is.null <- base::is.null
[10:27:07.225]                       muffled <- FALSE
[10:27:07.225]                       if (inherits(cond, "message")) {
[10:27:07.225]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:07.225]                         if (muffled) 
[10:27:07.225]                           invokeRestart("muffleMessage")
[10:27:07.225]                       }
[10:27:07.225]                       else if (inherits(cond, "warning")) {
[10:27:07.225]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:07.225]                         if (muffled) 
[10:27:07.225]                           invokeRestart("muffleWarning")
[10:27:07.225]                       }
[10:27:07.225]                       else if (inherits(cond, "condition")) {
[10:27:07.225]                         if (!is.null(pattern)) {
[10:27:07.225]                           computeRestarts <- base::computeRestarts
[10:27:07.225]                           grepl <- base::grepl
[10:27:07.225]                           restarts <- computeRestarts(cond)
[10:27:07.225]                           for (restart in restarts) {
[10:27:07.225]                             name <- restart$name
[10:27:07.225]                             if (is.null(name)) 
[10:27:07.225]                               next
[10:27:07.225]                             if (!grepl(pattern, name)) 
[10:27:07.225]                               next
[10:27:07.225]                             invokeRestart(restart)
[10:27:07.225]                             muffled <- TRUE
[10:27:07.225]                             break
[10:27:07.225]                           }
[10:27:07.225]                         }
[10:27:07.225]                       }
[10:27:07.225]                       invisible(muffled)
[10:27:07.225]                     }
[10:27:07.225]                     muffleCondition(cond, pattern = "^muffle")
[10:27:07.225]                   }
[10:27:07.225]                 }
[10:27:07.225]                 else {
[10:27:07.225]                   if (TRUE) {
[10:27:07.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:07.225]                     {
[10:27:07.225]                       inherits <- base::inherits
[10:27:07.225]                       invokeRestart <- base::invokeRestart
[10:27:07.225]                       is.null <- base::is.null
[10:27:07.225]                       muffled <- FALSE
[10:27:07.225]                       if (inherits(cond, "message")) {
[10:27:07.225]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:07.225]                         if (muffled) 
[10:27:07.225]                           invokeRestart("muffleMessage")
[10:27:07.225]                       }
[10:27:07.225]                       else if (inherits(cond, "warning")) {
[10:27:07.225]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:07.225]                         if (muffled) 
[10:27:07.225]                           invokeRestart("muffleWarning")
[10:27:07.225]                       }
[10:27:07.225]                       else if (inherits(cond, "condition")) {
[10:27:07.225]                         if (!is.null(pattern)) {
[10:27:07.225]                           computeRestarts <- base::computeRestarts
[10:27:07.225]                           grepl <- base::grepl
[10:27:07.225]                           restarts <- computeRestarts(cond)
[10:27:07.225]                           for (restart in restarts) {
[10:27:07.225]                             name <- restart$name
[10:27:07.225]                             if (is.null(name)) 
[10:27:07.225]                               next
[10:27:07.225]                             if (!grepl(pattern, name)) 
[10:27:07.225]                               next
[10:27:07.225]                             invokeRestart(restart)
[10:27:07.225]                             muffled <- TRUE
[10:27:07.225]                             break
[10:27:07.225]                           }
[10:27:07.225]                         }
[10:27:07.225]                       }
[10:27:07.225]                       invisible(muffled)
[10:27:07.225]                     }
[10:27:07.225]                     muffleCondition(cond, pattern = "^muffle")
[10:27:07.225]                   }
[10:27:07.225]                 }
[10:27:07.225]             }
[10:27:07.225]         }))
[10:27:07.225]     }, error = function(ex) {
[10:27:07.225]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:07.225]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:07.225]                 ...future.rng), started = ...future.startTime, 
[10:27:07.225]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:07.225]             version = "1.8"), class = "FutureResult")
[10:27:07.225]     }, finally = {
[10:27:07.225]         if (!identical(...future.workdir, getwd())) 
[10:27:07.225]             setwd(...future.workdir)
[10:27:07.225]         {
[10:27:07.225]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:07.225]                 ...future.oldOptions$nwarnings <- NULL
[10:27:07.225]             }
[10:27:07.225]             base::options(...future.oldOptions)
[10:27:07.225]             if (.Platform$OS.type == "windows") {
[10:27:07.225]                 old_names <- names(...future.oldEnvVars)
[10:27:07.225]                 envs <- base::Sys.getenv()
[10:27:07.225]                 names <- names(envs)
[10:27:07.225]                 common <- intersect(names, old_names)
[10:27:07.225]                 added <- setdiff(names, old_names)
[10:27:07.225]                 removed <- setdiff(old_names, names)
[10:27:07.225]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:07.225]                   envs[common]]
[10:27:07.225]                 NAMES <- toupper(changed)
[10:27:07.225]                 args <- list()
[10:27:07.225]                 for (kk in seq_along(NAMES)) {
[10:27:07.225]                   name <- changed[[kk]]
[10:27:07.225]                   NAME <- NAMES[[kk]]
[10:27:07.225]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:07.225]                     next
[10:27:07.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:07.225]                 }
[10:27:07.225]                 NAMES <- toupper(added)
[10:27:07.225]                 for (kk in seq_along(NAMES)) {
[10:27:07.225]                   name <- added[[kk]]
[10:27:07.225]                   NAME <- NAMES[[kk]]
[10:27:07.225]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:07.225]                     next
[10:27:07.225]                   args[[name]] <- ""
[10:27:07.225]                 }
[10:27:07.225]                 NAMES <- toupper(removed)
[10:27:07.225]                 for (kk in seq_along(NAMES)) {
[10:27:07.225]                   name <- removed[[kk]]
[10:27:07.225]                   NAME <- NAMES[[kk]]
[10:27:07.225]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:07.225]                     next
[10:27:07.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:07.225]                 }
[10:27:07.225]                 if (length(args) > 0) 
[10:27:07.225]                   base::do.call(base::Sys.setenv, args = args)
[10:27:07.225]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:07.225]             }
[10:27:07.225]             else {
[10:27:07.225]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:07.225]             }
[10:27:07.225]             {
[10:27:07.225]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:07.225]                   0L) {
[10:27:07.225]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:07.225]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:07.225]                   base::options(opts)
[10:27:07.225]                 }
[10:27:07.225]                 {
[10:27:07.225]                   {
[10:27:07.225]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:07.225]                     NULL
[10:27:07.225]                   }
[10:27:07.225]                   options(future.plan = NULL)
[10:27:07.225]                   if (is.na(NA_character_)) 
[10:27:07.225]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:07.225]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:07.225]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:07.225]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:07.225]                     envir = parent.frame()) 
[10:27:07.225]                   {
[10:27:07.225]                     if (is.function(workers)) 
[10:27:07.225]                       workers <- workers()
[10:27:07.225]                     workers <- structure(as.integer(workers), 
[10:27:07.225]                       class = class(workers))
[10:27:07.225]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:07.225]                       workers >= 1)
[10:27:07.225]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:07.225]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:07.225]                     }
[10:27:07.225]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:07.225]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:07.225]                       envir = envir)
[10:27:07.225]                     if (!future$lazy) 
[10:27:07.225]                       future <- run(future)
[10:27:07.225]                     invisible(future)
[10:27:07.225]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:07.225]                 }
[10:27:07.225]             }
[10:27:07.225]         }
[10:27:07.225]     })
[10:27:07.225]     if (TRUE) {
[10:27:07.225]         base::sink(type = "output", split = FALSE)
[10:27:07.225]         if (TRUE) {
[10:27:07.225]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:07.225]         }
[10:27:07.225]         else {
[10:27:07.225]             ...future.result["stdout"] <- base::list(NULL)
[10:27:07.225]         }
[10:27:07.225]         base::close(...future.stdout)
[10:27:07.225]         ...future.stdout <- NULL
[10:27:07.225]     }
[10:27:07.225]     ...future.result$conditions <- ...future.conditions
[10:27:07.225]     ...future.result$finished <- base::Sys.time()
[10:27:07.225]     ...future.result
[10:27:07.225] }
[10:27:07.228] MultisessionFuture started
[10:27:07.228] - Launch lazy future ... done
[10:27:07.229] run() for ‘MultisessionFuture’ ... done
[10:27:07.274] receiveMessageFromWorker() for ClusterFuture ...
[10:27:07.275] - Validating connection of MultisessionFuture
[10:27:07.275] - received message: FutureResult
[10:27:07.275] - Received FutureResult
[10:27:07.275] - Erased future from FutureRegistry
[10:27:07.276] result() for ClusterFuture ...
[10:27:07.276] - result already collected: FutureResult
[10:27:07.276] result() for ClusterFuture ... done
[10:27:07.276] signalConditions() ...
[10:27:07.276]  - include = ‘immediateCondition’
[10:27:07.276]  - exclude = 
[10:27:07.276]  - resignal = FALSE
[10:27:07.276]  - Number of conditions: 1
[10:27:07.276] signalConditions() ... done
[10:27:07.276] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:07.277] A MultisessionFuture was resolved (result was not collected)
[10:27:07.277] getGlobalsAndPackages() ...
[10:27:07.277] Searching for globals...
[10:27:07.278] - globals found: [2] ‘list’, ‘stop’
[10:27:07.278] Searching for globals ... DONE
[10:27:07.278] Resolving globals: FALSE
[10:27:07.278] 
[10:27:07.278] 
[10:27:07.278] getGlobalsAndPackages() ... DONE
[10:27:07.279] run() for ‘Future’ ...
[10:27:07.279] - state: ‘created’
[10:27:07.279] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:07.293] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:07.293] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:07.293]   - Field: ‘node’
[10:27:07.293]   - Field: ‘label’
[10:27:07.293]   - Field: ‘local’
[10:27:07.294]   - Field: ‘owner’
[10:27:07.294]   - Field: ‘envir’
[10:27:07.294]   - Field: ‘workers’
[10:27:07.294]   - Field: ‘packages’
[10:27:07.294]   - Field: ‘gc’
[10:27:07.296]   - Field: ‘conditions’
[10:27:07.296]   - Field: ‘persistent’
[10:27:07.296]   - Field: ‘expr’
[10:27:07.296]   - Field: ‘uuid’
[10:27:07.296]   - Field: ‘seed’
[10:27:07.297]   - Field: ‘version’
[10:27:07.297]   - Field: ‘result’
[10:27:07.297]   - Field: ‘asynchronous’
[10:27:07.297]   - Field: ‘calls’
[10:27:07.297]   - Field: ‘globals’
[10:27:07.297]   - Field: ‘stdout’
[10:27:07.297]   - Field: ‘earlySignal’
[10:27:07.297]   - Field: ‘lazy’
[10:27:07.297]   - Field: ‘state’
[10:27:07.297] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:07.297] - Launch lazy future ...
[10:27:07.298] Packages needed by the future expression (n = 0): <none>
[10:27:07.298] Packages needed by future strategies (n = 0): <none>
[10:27:07.298] {
[10:27:07.298]     {
[10:27:07.298]         {
[10:27:07.298]             ...future.startTime <- base::Sys.time()
[10:27:07.298]             {
[10:27:07.298]                 {
[10:27:07.298]                   {
[10:27:07.298]                     {
[10:27:07.298]                       base::local({
[10:27:07.298]                         has_future <- base::requireNamespace("future", 
[10:27:07.298]                           quietly = TRUE)
[10:27:07.298]                         if (has_future) {
[10:27:07.298]                           ns <- base::getNamespace("future")
[10:27:07.298]                           version <- ns[[".package"]][["version"]]
[10:27:07.298]                           if (is.null(version)) 
[10:27:07.298]                             version <- utils::packageVersion("future")
[10:27:07.298]                         }
[10:27:07.298]                         else {
[10:27:07.298]                           version <- NULL
[10:27:07.298]                         }
[10:27:07.298]                         if (!has_future || version < "1.8.0") {
[10:27:07.298]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:07.298]                             "", base::R.version$version.string), 
[10:27:07.298]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:07.298]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:07.298]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:07.298]                               "release", "version")], collapse = " "), 
[10:27:07.298]                             hostname = base::Sys.info()[["nodename"]])
[10:27:07.298]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:07.298]                             info)
[10:27:07.298]                           info <- base::paste(info, collapse = "; ")
[10:27:07.298]                           if (!has_future) {
[10:27:07.298]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:07.298]                               info)
[10:27:07.298]                           }
[10:27:07.298]                           else {
[10:27:07.298]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:07.298]                               info, version)
[10:27:07.298]                           }
[10:27:07.298]                           base::stop(msg)
[10:27:07.298]                         }
[10:27:07.298]                       })
[10:27:07.298]                     }
[10:27:07.298]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:07.298]                     base::options(mc.cores = 1L)
[10:27:07.298]                   }
[10:27:07.298]                   options(future.plan = NULL)
[10:27:07.298]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:07.298]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:07.298]                 }
[10:27:07.298]                 ...future.workdir <- getwd()
[10:27:07.298]             }
[10:27:07.298]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:07.298]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:07.298]         }
[10:27:07.298]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:07.298]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:07.298]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:07.298]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:07.298]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:07.298]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:07.298]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:07.298]             base::names(...future.oldOptions))
[10:27:07.298]     }
[10:27:07.298]     if (FALSE) {
[10:27:07.298]     }
[10:27:07.298]     else {
[10:27:07.298]         if (TRUE) {
[10:27:07.298]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:07.298]                 open = "w")
[10:27:07.298]         }
[10:27:07.298]         else {
[10:27:07.298]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:07.298]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:07.298]         }
[10:27:07.298]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:07.298]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:07.298]             base::sink(type = "output", split = FALSE)
[10:27:07.298]             base::close(...future.stdout)
[10:27:07.298]         }, add = TRUE)
[10:27:07.298]     }
[10:27:07.298]     ...future.frame <- base::sys.nframe()
[10:27:07.298]     ...future.conditions <- base::list()
[10:27:07.298]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:07.298]     if (FALSE) {
[10:27:07.298]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:07.298]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:07.298]     }
[10:27:07.298]     ...future.result <- base::tryCatch({
[10:27:07.298]         base::withCallingHandlers({
[10:27:07.298]             ...future.value <- base::withVisible(base::local({
[10:27:07.298]                 ...future.makeSendCondition <- base::local({
[10:27:07.298]                   sendCondition <- NULL
[10:27:07.298]                   function(frame = 1L) {
[10:27:07.298]                     if (is.function(sendCondition)) 
[10:27:07.298]                       return(sendCondition)
[10:27:07.298]                     ns <- getNamespace("parallel")
[10:27:07.298]                     if (exists("sendData", mode = "function", 
[10:27:07.298]                       envir = ns)) {
[10:27:07.298]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:07.298]                         envir = ns)
[10:27:07.298]                       envir <- sys.frame(frame)
[10:27:07.298]                       master <- NULL
[10:27:07.298]                       while (!identical(envir, .GlobalEnv) && 
[10:27:07.298]                         !identical(envir, emptyenv())) {
[10:27:07.298]                         if (exists("master", mode = "list", envir = envir, 
[10:27:07.298]                           inherits = FALSE)) {
[10:27:07.298]                           master <- get("master", mode = "list", 
[10:27:07.298]                             envir = envir, inherits = FALSE)
[10:27:07.298]                           if (inherits(master, c("SOCKnode", 
[10:27:07.298]                             "SOCK0node"))) {
[10:27:07.298]                             sendCondition <<- function(cond) {
[10:27:07.298]                               data <- list(type = "VALUE", value = cond, 
[10:27:07.298]                                 success = TRUE)
[10:27:07.298]                               parallel_sendData(master, data)
[10:27:07.298]                             }
[10:27:07.298]                             return(sendCondition)
[10:27:07.298]                           }
[10:27:07.298]                         }
[10:27:07.298]                         frame <- frame + 1L
[10:27:07.298]                         envir <- sys.frame(frame)
[10:27:07.298]                       }
[10:27:07.298]                     }
[10:27:07.298]                     sendCondition <<- function(cond) NULL
[10:27:07.298]                   }
[10:27:07.298]                 })
[10:27:07.298]                 withCallingHandlers({
[10:27:07.298]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:27:07.298]                 }, immediateCondition = function(cond) {
[10:27:07.298]                   sendCondition <- ...future.makeSendCondition()
[10:27:07.298]                   sendCondition(cond)
[10:27:07.298]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:07.298]                   {
[10:27:07.298]                     inherits <- base::inherits
[10:27:07.298]                     invokeRestart <- base::invokeRestart
[10:27:07.298]                     is.null <- base::is.null
[10:27:07.298]                     muffled <- FALSE
[10:27:07.298]                     if (inherits(cond, "message")) {
[10:27:07.298]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:07.298]                       if (muffled) 
[10:27:07.298]                         invokeRestart("muffleMessage")
[10:27:07.298]                     }
[10:27:07.298]                     else if (inherits(cond, "warning")) {
[10:27:07.298]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:07.298]                       if (muffled) 
[10:27:07.298]                         invokeRestart("muffleWarning")
[10:27:07.298]                     }
[10:27:07.298]                     else if (inherits(cond, "condition")) {
[10:27:07.298]                       if (!is.null(pattern)) {
[10:27:07.298]                         computeRestarts <- base::computeRestarts
[10:27:07.298]                         grepl <- base::grepl
[10:27:07.298]                         restarts <- computeRestarts(cond)
[10:27:07.298]                         for (restart in restarts) {
[10:27:07.298]                           name <- restart$name
[10:27:07.298]                           if (is.null(name)) 
[10:27:07.298]                             next
[10:27:07.298]                           if (!grepl(pattern, name)) 
[10:27:07.298]                             next
[10:27:07.298]                           invokeRestart(restart)
[10:27:07.298]                           muffled <- TRUE
[10:27:07.298]                           break
[10:27:07.298]                         }
[10:27:07.298]                       }
[10:27:07.298]                     }
[10:27:07.298]                     invisible(muffled)
[10:27:07.298]                   }
[10:27:07.298]                   muffleCondition(cond)
[10:27:07.298]                 })
[10:27:07.298]             }))
[10:27:07.298]             future::FutureResult(value = ...future.value$value, 
[10:27:07.298]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:07.298]                   ...future.rng), globalenv = if (FALSE) 
[10:27:07.298]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:07.298]                     ...future.globalenv.names))
[10:27:07.298]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:07.298]         }, condition = base::local({
[10:27:07.298]             c <- base::c
[10:27:07.298]             inherits <- base::inherits
[10:27:07.298]             invokeRestart <- base::invokeRestart
[10:27:07.298]             length <- base::length
[10:27:07.298]             list <- base::list
[10:27:07.298]             seq.int <- base::seq.int
[10:27:07.298]             signalCondition <- base::signalCondition
[10:27:07.298]             sys.calls <- base::sys.calls
[10:27:07.298]             `[[` <- base::`[[`
[10:27:07.298]             `+` <- base::`+`
[10:27:07.298]             `<<-` <- base::`<<-`
[10:27:07.298]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:07.298]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:07.298]                   3L)]
[10:27:07.298]             }
[10:27:07.298]             function(cond) {
[10:27:07.298]                 is_error <- inherits(cond, "error")
[10:27:07.298]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:07.298]                   NULL)
[10:27:07.298]                 if (is_error) {
[10:27:07.298]                   sessionInformation <- function() {
[10:27:07.298]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:07.298]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:07.298]                       search = base::search(), system = base::Sys.info())
[10:27:07.298]                   }
[10:27:07.298]                   ...future.conditions[[length(...future.conditions) + 
[10:27:07.298]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:07.298]                     cond$call), session = sessionInformation(), 
[10:27:07.298]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:07.298]                   signalCondition(cond)
[10:27:07.298]                 }
[10:27:07.298]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:07.298]                 "immediateCondition"))) {
[10:27:07.298]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:07.298]                   ...future.conditions[[length(...future.conditions) + 
[10:27:07.298]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:07.298]                   if (TRUE && !signal) {
[10:27:07.298]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:07.298]                     {
[10:27:07.298]                       inherits <- base::inherits
[10:27:07.298]                       invokeRestart <- base::invokeRestart
[10:27:07.298]                       is.null <- base::is.null
[10:27:07.298]                       muffled <- FALSE
[10:27:07.298]                       if (inherits(cond, "message")) {
[10:27:07.298]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:07.298]                         if (muffled) 
[10:27:07.298]                           invokeRestart("muffleMessage")
[10:27:07.298]                       }
[10:27:07.298]                       else if (inherits(cond, "warning")) {
[10:27:07.298]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:07.298]                         if (muffled) 
[10:27:07.298]                           invokeRestart("muffleWarning")
[10:27:07.298]                       }
[10:27:07.298]                       else if (inherits(cond, "condition")) {
[10:27:07.298]                         if (!is.null(pattern)) {
[10:27:07.298]                           computeRestarts <- base::computeRestarts
[10:27:07.298]                           grepl <- base::grepl
[10:27:07.298]                           restarts <- computeRestarts(cond)
[10:27:07.298]                           for (restart in restarts) {
[10:27:07.298]                             name <- restart$name
[10:27:07.298]                             if (is.null(name)) 
[10:27:07.298]                               next
[10:27:07.298]                             if (!grepl(pattern, name)) 
[10:27:07.298]                               next
[10:27:07.298]                             invokeRestart(restart)
[10:27:07.298]                             muffled <- TRUE
[10:27:07.298]                             break
[10:27:07.298]                           }
[10:27:07.298]                         }
[10:27:07.298]                       }
[10:27:07.298]                       invisible(muffled)
[10:27:07.298]                     }
[10:27:07.298]                     muffleCondition(cond, pattern = "^muffle")
[10:27:07.298]                   }
[10:27:07.298]                 }
[10:27:07.298]                 else {
[10:27:07.298]                   if (TRUE) {
[10:27:07.298]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:07.298]                     {
[10:27:07.298]                       inherits <- base::inherits
[10:27:07.298]                       invokeRestart <- base::invokeRestart
[10:27:07.298]                       is.null <- base::is.null
[10:27:07.298]                       muffled <- FALSE
[10:27:07.298]                       if (inherits(cond, "message")) {
[10:27:07.298]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:07.298]                         if (muffled) 
[10:27:07.298]                           invokeRestart("muffleMessage")
[10:27:07.298]                       }
[10:27:07.298]                       else if (inherits(cond, "warning")) {
[10:27:07.298]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:07.298]                         if (muffled) 
[10:27:07.298]                           invokeRestart("muffleWarning")
[10:27:07.298]                       }
[10:27:07.298]                       else if (inherits(cond, "condition")) {
[10:27:07.298]                         if (!is.null(pattern)) {
[10:27:07.298]                           computeRestarts <- base::computeRestarts
[10:27:07.298]                           grepl <- base::grepl
[10:27:07.298]                           restarts <- computeRestarts(cond)
[10:27:07.298]                           for (restart in restarts) {
[10:27:07.298]                             name <- restart$name
[10:27:07.298]                             if (is.null(name)) 
[10:27:07.298]                               next
[10:27:07.298]                             if (!grepl(pattern, name)) 
[10:27:07.298]                               next
[10:27:07.298]                             invokeRestart(restart)
[10:27:07.298]                             muffled <- TRUE
[10:27:07.298]                             break
[10:27:07.298]                           }
[10:27:07.298]                         }
[10:27:07.298]                       }
[10:27:07.298]                       invisible(muffled)
[10:27:07.298]                     }
[10:27:07.298]                     muffleCondition(cond, pattern = "^muffle")
[10:27:07.298]                   }
[10:27:07.298]                 }
[10:27:07.298]             }
[10:27:07.298]         }))
[10:27:07.298]     }, error = function(ex) {
[10:27:07.298]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:07.298]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:07.298]                 ...future.rng), started = ...future.startTime, 
[10:27:07.298]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:07.298]             version = "1.8"), class = "FutureResult")
[10:27:07.298]     }, finally = {
[10:27:07.298]         if (!identical(...future.workdir, getwd())) 
[10:27:07.298]             setwd(...future.workdir)
[10:27:07.298]         {
[10:27:07.298]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:07.298]                 ...future.oldOptions$nwarnings <- NULL
[10:27:07.298]             }
[10:27:07.298]             base::options(...future.oldOptions)
[10:27:07.298]             if (.Platform$OS.type == "windows") {
[10:27:07.298]                 old_names <- names(...future.oldEnvVars)
[10:27:07.298]                 envs <- base::Sys.getenv()
[10:27:07.298]                 names <- names(envs)
[10:27:07.298]                 common <- intersect(names, old_names)
[10:27:07.298]                 added <- setdiff(names, old_names)
[10:27:07.298]                 removed <- setdiff(old_names, names)
[10:27:07.298]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:07.298]                   envs[common]]
[10:27:07.298]                 NAMES <- toupper(changed)
[10:27:07.298]                 args <- list()
[10:27:07.298]                 for (kk in seq_along(NAMES)) {
[10:27:07.298]                   name <- changed[[kk]]
[10:27:07.298]                   NAME <- NAMES[[kk]]
[10:27:07.298]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:07.298]                     next
[10:27:07.298]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:07.298]                 }
[10:27:07.298]                 NAMES <- toupper(added)
[10:27:07.298]                 for (kk in seq_along(NAMES)) {
[10:27:07.298]                   name <- added[[kk]]
[10:27:07.298]                   NAME <- NAMES[[kk]]
[10:27:07.298]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:07.298]                     next
[10:27:07.298]                   args[[name]] <- ""
[10:27:07.298]                 }
[10:27:07.298]                 NAMES <- toupper(removed)
[10:27:07.298]                 for (kk in seq_along(NAMES)) {
[10:27:07.298]                   name <- removed[[kk]]
[10:27:07.298]                   NAME <- NAMES[[kk]]
[10:27:07.298]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:07.298]                     next
[10:27:07.298]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:07.298]                 }
[10:27:07.298]                 if (length(args) > 0) 
[10:27:07.298]                   base::do.call(base::Sys.setenv, args = args)
[10:27:07.298]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:07.298]             }
[10:27:07.298]             else {
[10:27:07.298]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:07.298]             }
[10:27:07.298]             {
[10:27:07.298]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:07.298]                   0L) {
[10:27:07.298]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:07.298]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:07.298]                   base::options(opts)
[10:27:07.298]                 }
[10:27:07.298]                 {
[10:27:07.298]                   {
[10:27:07.298]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:07.298]                     NULL
[10:27:07.298]                   }
[10:27:07.298]                   options(future.plan = NULL)
[10:27:07.298]                   if (is.na(NA_character_)) 
[10:27:07.298]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:07.298]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:07.298]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:07.298]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:07.298]                     envir = parent.frame()) 
[10:27:07.298]                   {
[10:27:07.298]                     if (is.function(workers)) 
[10:27:07.298]                       workers <- workers()
[10:27:07.298]                     workers <- structure(as.integer(workers), 
[10:27:07.298]                       class = class(workers))
[10:27:07.298]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:07.298]                       workers >= 1)
[10:27:07.298]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:07.298]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:07.298]                     }
[10:27:07.298]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:07.298]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:07.298]                       envir = envir)
[10:27:07.298]                     if (!future$lazy) 
[10:27:07.298]                       future <- run(future)
[10:27:07.298]                     invisible(future)
[10:27:07.298]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:07.298]                 }
[10:27:07.298]             }
[10:27:07.298]         }
[10:27:07.298]     })
[10:27:07.298]     if (TRUE) {
[10:27:07.298]         base::sink(type = "output", split = FALSE)
[10:27:07.298]         if (TRUE) {
[10:27:07.298]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:07.298]         }
[10:27:07.298]         else {
[10:27:07.298]             ...future.result["stdout"] <- base::list(NULL)
[10:27:07.298]         }
[10:27:07.298]         base::close(...future.stdout)
[10:27:07.298]         ...future.stdout <- NULL
[10:27:07.298]     }
[10:27:07.298]     ...future.result$conditions <- ...future.conditions
[10:27:07.298]     ...future.result$finished <- base::Sys.time()
[10:27:07.298]     ...future.result
[10:27:07.298] }
[10:27:07.301] MultisessionFuture started
[10:27:07.301] - Launch lazy future ... done
[10:27:07.302] run() for ‘MultisessionFuture’ ... done
[10:27:07.347] receiveMessageFromWorker() for ClusterFuture ...
[10:27:07.347] - Validating connection of MultisessionFuture
[10:27:07.348] - received message: FutureResult
[10:27:07.348] - Received FutureResult
[10:27:07.348] - Erased future from FutureRegistry
[10:27:07.348] result() for ClusterFuture ...
[10:27:07.348] - result already collected: FutureResult
[10:27:07.348] result() for ClusterFuture ... done
[10:27:07.349] signalConditions() ...
[10:27:07.349]  - include = ‘immediateCondition’
[10:27:07.349]  - exclude = 
[10:27:07.349]  - resignal = FALSE
[10:27:07.349]  - Number of conditions: 1
[10:27:07.349] signalConditions() ... done
[10:27:07.349] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:07.349] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = TRUE ... DONE
- result = FALSE, recursive = -1 ...
[10:27:07.350] getGlobalsAndPackages() ...
[10:27:07.350] Searching for globals...
[10:27:07.351] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:27:07.351] Searching for globals ... DONE
[10:27:07.351] Resolving globals: FALSE
[10:27:07.352] 
[10:27:07.352] 
[10:27:07.352] getGlobalsAndPackages() ... DONE
[10:27:07.352] run() for ‘Future’ ...
[10:27:07.352] - state: ‘created’
[10:27:07.352] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:07.366] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:07.366] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:07.367]   - Field: ‘node’
[10:27:07.367]   - Field: ‘label’
[10:27:07.367]   - Field: ‘local’
[10:27:07.367]   - Field: ‘owner’
[10:27:07.367]   - Field: ‘envir’
[10:27:07.367]   - Field: ‘workers’
[10:27:07.367]   - Field: ‘packages’
[10:27:07.367]   - Field: ‘gc’
[10:27:07.367]   - Field: ‘conditions’
[10:27:07.367]   - Field: ‘persistent’
[10:27:07.367]   - Field: ‘expr’
[10:27:07.368]   - Field: ‘uuid’
[10:27:07.368]   - Field: ‘seed’
[10:27:07.368]   - Field: ‘version’
[10:27:07.368]   - Field: ‘result’
[10:27:07.368]   - Field: ‘asynchronous’
[10:27:07.368]   - Field: ‘calls’
[10:27:07.368]   - Field: ‘globals’
[10:27:07.368]   - Field: ‘stdout’
[10:27:07.368]   - Field: ‘earlySignal’
[10:27:07.368]   - Field: ‘lazy’
[10:27:07.368]   - Field: ‘state’
[10:27:07.369] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:07.369] - Launch lazy future ...
[10:27:07.369] Packages needed by the future expression (n = 0): <none>
[10:27:07.369] Packages needed by future strategies (n = 0): <none>
[10:27:07.370] {
[10:27:07.370]     {
[10:27:07.370]         {
[10:27:07.370]             ...future.startTime <- base::Sys.time()
[10:27:07.370]             {
[10:27:07.370]                 {
[10:27:07.370]                   {
[10:27:07.370]                     {
[10:27:07.370]                       base::local({
[10:27:07.370]                         has_future <- base::requireNamespace("future", 
[10:27:07.370]                           quietly = TRUE)
[10:27:07.370]                         if (has_future) {
[10:27:07.370]                           ns <- base::getNamespace("future")
[10:27:07.370]                           version <- ns[[".package"]][["version"]]
[10:27:07.370]                           if (is.null(version)) 
[10:27:07.370]                             version <- utils::packageVersion("future")
[10:27:07.370]                         }
[10:27:07.370]                         else {
[10:27:07.370]                           version <- NULL
[10:27:07.370]                         }
[10:27:07.370]                         if (!has_future || version < "1.8.0") {
[10:27:07.370]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:07.370]                             "", base::R.version$version.string), 
[10:27:07.370]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:07.370]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:07.370]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:07.370]                               "release", "version")], collapse = " "), 
[10:27:07.370]                             hostname = base::Sys.info()[["nodename"]])
[10:27:07.370]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:07.370]                             info)
[10:27:07.370]                           info <- base::paste(info, collapse = "; ")
[10:27:07.370]                           if (!has_future) {
[10:27:07.370]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:07.370]                               info)
[10:27:07.370]                           }
[10:27:07.370]                           else {
[10:27:07.370]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:07.370]                               info, version)
[10:27:07.370]                           }
[10:27:07.370]                           base::stop(msg)
[10:27:07.370]                         }
[10:27:07.370]                       })
[10:27:07.370]                     }
[10:27:07.370]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:07.370]                     base::options(mc.cores = 1L)
[10:27:07.370]                   }
[10:27:07.370]                   options(future.plan = NULL)
[10:27:07.370]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:07.370]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:07.370]                 }
[10:27:07.370]                 ...future.workdir <- getwd()
[10:27:07.370]             }
[10:27:07.370]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:07.370]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:07.370]         }
[10:27:07.370]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:07.370]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:07.370]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:07.370]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:07.370]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:07.370]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:07.370]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:07.370]             base::names(...future.oldOptions))
[10:27:07.370]     }
[10:27:07.370]     if (FALSE) {
[10:27:07.370]     }
[10:27:07.370]     else {
[10:27:07.370]         if (TRUE) {
[10:27:07.370]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:07.370]                 open = "w")
[10:27:07.370]         }
[10:27:07.370]         else {
[10:27:07.370]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:07.370]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:07.370]         }
[10:27:07.370]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:07.370]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:07.370]             base::sink(type = "output", split = FALSE)
[10:27:07.370]             base::close(...future.stdout)
[10:27:07.370]         }, add = TRUE)
[10:27:07.370]     }
[10:27:07.370]     ...future.frame <- base::sys.nframe()
[10:27:07.370]     ...future.conditions <- base::list()
[10:27:07.370]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:07.370]     if (FALSE) {
[10:27:07.370]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:07.370]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:07.370]     }
[10:27:07.370]     ...future.result <- base::tryCatch({
[10:27:07.370]         base::withCallingHandlers({
[10:27:07.370]             ...future.value <- base::withVisible(base::local({
[10:27:07.370]                 ...future.makeSendCondition <- base::local({
[10:27:07.370]                   sendCondition <- NULL
[10:27:07.370]                   function(frame = 1L) {
[10:27:07.370]                     if (is.function(sendCondition)) 
[10:27:07.370]                       return(sendCondition)
[10:27:07.370]                     ns <- getNamespace("parallel")
[10:27:07.370]                     if (exists("sendData", mode = "function", 
[10:27:07.370]                       envir = ns)) {
[10:27:07.370]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:07.370]                         envir = ns)
[10:27:07.370]                       envir <- sys.frame(frame)
[10:27:07.370]                       master <- NULL
[10:27:07.370]                       while (!identical(envir, .GlobalEnv) && 
[10:27:07.370]                         !identical(envir, emptyenv())) {
[10:27:07.370]                         if (exists("master", mode = "list", envir = envir, 
[10:27:07.370]                           inherits = FALSE)) {
[10:27:07.370]                           master <- get("master", mode = "list", 
[10:27:07.370]                             envir = envir, inherits = FALSE)
[10:27:07.370]                           if (inherits(master, c("SOCKnode", 
[10:27:07.370]                             "SOCK0node"))) {
[10:27:07.370]                             sendCondition <<- function(cond) {
[10:27:07.370]                               data <- list(type = "VALUE", value = cond, 
[10:27:07.370]                                 success = TRUE)
[10:27:07.370]                               parallel_sendData(master, data)
[10:27:07.370]                             }
[10:27:07.370]                             return(sendCondition)
[10:27:07.370]                           }
[10:27:07.370]                         }
[10:27:07.370]                         frame <- frame + 1L
[10:27:07.370]                         envir <- sys.frame(frame)
[10:27:07.370]                       }
[10:27:07.370]                     }
[10:27:07.370]                     sendCondition <<- function(cond) NULL
[10:27:07.370]                   }
[10:27:07.370]                 })
[10:27:07.370]                 withCallingHandlers({
[10:27:07.370]                   {
[10:27:07.370]                     Sys.sleep(0.5)
[10:27:07.370]                     list(a = 1, b = 42L)
[10:27:07.370]                   }
[10:27:07.370]                 }, immediateCondition = function(cond) {
[10:27:07.370]                   sendCondition <- ...future.makeSendCondition()
[10:27:07.370]                   sendCondition(cond)
[10:27:07.370]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:07.370]                   {
[10:27:07.370]                     inherits <- base::inherits
[10:27:07.370]                     invokeRestart <- base::invokeRestart
[10:27:07.370]                     is.null <- base::is.null
[10:27:07.370]                     muffled <- FALSE
[10:27:07.370]                     if (inherits(cond, "message")) {
[10:27:07.370]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:07.370]                       if (muffled) 
[10:27:07.370]                         invokeRestart("muffleMessage")
[10:27:07.370]                     }
[10:27:07.370]                     else if (inherits(cond, "warning")) {
[10:27:07.370]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:07.370]                       if (muffled) 
[10:27:07.370]                         invokeRestart("muffleWarning")
[10:27:07.370]                     }
[10:27:07.370]                     else if (inherits(cond, "condition")) {
[10:27:07.370]                       if (!is.null(pattern)) {
[10:27:07.370]                         computeRestarts <- base::computeRestarts
[10:27:07.370]                         grepl <- base::grepl
[10:27:07.370]                         restarts <- computeRestarts(cond)
[10:27:07.370]                         for (restart in restarts) {
[10:27:07.370]                           name <- restart$name
[10:27:07.370]                           if (is.null(name)) 
[10:27:07.370]                             next
[10:27:07.370]                           if (!grepl(pattern, name)) 
[10:27:07.370]                             next
[10:27:07.370]                           invokeRestart(restart)
[10:27:07.370]                           muffled <- TRUE
[10:27:07.370]                           break
[10:27:07.370]                         }
[10:27:07.370]                       }
[10:27:07.370]                     }
[10:27:07.370]                     invisible(muffled)
[10:27:07.370]                   }
[10:27:07.370]                   muffleCondition(cond)
[10:27:07.370]                 })
[10:27:07.370]             }))
[10:27:07.370]             future::FutureResult(value = ...future.value$value, 
[10:27:07.370]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:07.370]                   ...future.rng), globalenv = if (FALSE) 
[10:27:07.370]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:07.370]                     ...future.globalenv.names))
[10:27:07.370]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:07.370]         }, condition = base::local({
[10:27:07.370]             c <- base::c
[10:27:07.370]             inherits <- base::inherits
[10:27:07.370]             invokeRestart <- base::invokeRestart
[10:27:07.370]             length <- base::length
[10:27:07.370]             list <- base::list
[10:27:07.370]             seq.int <- base::seq.int
[10:27:07.370]             signalCondition <- base::signalCondition
[10:27:07.370]             sys.calls <- base::sys.calls
[10:27:07.370]             `[[` <- base::`[[`
[10:27:07.370]             `+` <- base::`+`
[10:27:07.370]             `<<-` <- base::`<<-`
[10:27:07.370]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:07.370]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:07.370]                   3L)]
[10:27:07.370]             }
[10:27:07.370]             function(cond) {
[10:27:07.370]                 is_error <- inherits(cond, "error")
[10:27:07.370]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:07.370]                   NULL)
[10:27:07.370]                 if (is_error) {
[10:27:07.370]                   sessionInformation <- function() {
[10:27:07.370]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:07.370]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:07.370]                       search = base::search(), system = base::Sys.info())
[10:27:07.370]                   }
[10:27:07.370]                   ...future.conditions[[length(...future.conditions) + 
[10:27:07.370]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:07.370]                     cond$call), session = sessionInformation(), 
[10:27:07.370]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:07.370]                   signalCondition(cond)
[10:27:07.370]                 }
[10:27:07.370]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:07.370]                 "immediateCondition"))) {
[10:27:07.370]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:07.370]                   ...future.conditions[[length(...future.conditions) + 
[10:27:07.370]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:07.370]                   if (TRUE && !signal) {
[10:27:07.370]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:07.370]                     {
[10:27:07.370]                       inherits <- base::inherits
[10:27:07.370]                       invokeRestart <- base::invokeRestart
[10:27:07.370]                       is.null <- base::is.null
[10:27:07.370]                       muffled <- FALSE
[10:27:07.370]                       if (inherits(cond, "message")) {
[10:27:07.370]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:07.370]                         if (muffled) 
[10:27:07.370]                           invokeRestart("muffleMessage")
[10:27:07.370]                       }
[10:27:07.370]                       else if (inherits(cond, "warning")) {
[10:27:07.370]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:07.370]                         if (muffled) 
[10:27:07.370]                           invokeRestart("muffleWarning")
[10:27:07.370]                       }
[10:27:07.370]                       else if (inherits(cond, "condition")) {
[10:27:07.370]                         if (!is.null(pattern)) {
[10:27:07.370]                           computeRestarts <- base::computeRestarts
[10:27:07.370]                           grepl <- base::grepl
[10:27:07.370]                           restarts <- computeRestarts(cond)
[10:27:07.370]                           for (restart in restarts) {
[10:27:07.370]                             name <- restart$name
[10:27:07.370]                             if (is.null(name)) 
[10:27:07.370]                               next
[10:27:07.370]                             if (!grepl(pattern, name)) 
[10:27:07.370]                               next
[10:27:07.370]                             invokeRestart(restart)
[10:27:07.370]                             muffled <- TRUE
[10:27:07.370]                             break
[10:27:07.370]                           }
[10:27:07.370]                         }
[10:27:07.370]                       }
[10:27:07.370]                       invisible(muffled)
[10:27:07.370]                     }
[10:27:07.370]                     muffleCondition(cond, pattern = "^muffle")
[10:27:07.370]                   }
[10:27:07.370]                 }
[10:27:07.370]                 else {
[10:27:07.370]                   if (TRUE) {
[10:27:07.370]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:07.370]                     {
[10:27:07.370]                       inherits <- base::inherits
[10:27:07.370]                       invokeRestart <- base::invokeRestart
[10:27:07.370]                       is.null <- base::is.null
[10:27:07.370]                       muffled <- FALSE
[10:27:07.370]                       if (inherits(cond, "message")) {
[10:27:07.370]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:07.370]                         if (muffled) 
[10:27:07.370]                           invokeRestart("muffleMessage")
[10:27:07.370]                       }
[10:27:07.370]                       else if (inherits(cond, "warning")) {
[10:27:07.370]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:07.370]                         if (muffled) 
[10:27:07.370]                           invokeRestart("muffleWarning")
[10:27:07.370]                       }
[10:27:07.370]                       else if (inherits(cond, "condition")) {
[10:27:07.370]                         if (!is.null(pattern)) {
[10:27:07.370]                           computeRestarts <- base::computeRestarts
[10:27:07.370]                           grepl <- base::grepl
[10:27:07.370]                           restarts <- computeRestarts(cond)
[10:27:07.370]                           for (restart in restarts) {
[10:27:07.370]                             name <- restart$name
[10:27:07.370]                             if (is.null(name)) 
[10:27:07.370]                               next
[10:27:07.370]                             if (!grepl(pattern, name)) 
[10:27:07.370]                               next
[10:27:07.370]                             invokeRestart(restart)
[10:27:07.370]                             muffled <- TRUE
[10:27:07.370]                             break
[10:27:07.370]                           }
[10:27:07.370]                         }
[10:27:07.370]                       }
[10:27:07.370]                       invisible(muffled)
[10:27:07.370]                     }
[10:27:07.370]                     muffleCondition(cond, pattern = "^muffle")
[10:27:07.370]                   }
[10:27:07.370]                 }
[10:27:07.370]             }
[10:27:07.370]         }))
[10:27:07.370]     }, error = function(ex) {
[10:27:07.370]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:07.370]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:07.370]                 ...future.rng), started = ...future.startTime, 
[10:27:07.370]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:07.370]             version = "1.8"), class = "FutureResult")
[10:27:07.370]     }, finally = {
[10:27:07.370]         if (!identical(...future.workdir, getwd())) 
[10:27:07.370]             setwd(...future.workdir)
[10:27:07.370]         {
[10:27:07.370]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:07.370]                 ...future.oldOptions$nwarnings <- NULL
[10:27:07.370]             }
[10:27:07.370]             base::options(...future.oldOptions)
[10:27:07.370]             if (.Platform$OS.type == "windows") {
[10:27:07.370]                 old_names <- names(...future.oldEnvVars)
[10:27:07.370]                 envs <- base::Sys.getenv()
[10:27:07.370]                 names <- names(envs)
[10:27:07.370]                 common <- intersect(names, old_names)
[10:27:07.370]                 added <- setdiff(names, old_names)
[10:27:07.370]                 removed <- setdiff(old_names, names)
[10:27:07.370]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:07.370]                   envs[common]]
[10:27:07.370]                 NAMES <- toupper(changed)
[10:27:07.370]                 args <- list()
[10:27:07.370]                 for (kk in seq_along(NAMES)) {
[10:27:07.370]                   name <- changed[[kk]]
[10:27:07.370]                   NAME <- NAMES[[kk]]
[10:27:07.370]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:07.370]                     next
[10:27:07.370]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:07.370]                 }
[10:27:07.370]                 NAMES <- toupper(added)
[10:27:07.370]                 for (kk in seq_along(NAMES)) {
[10:27:07.370]                   name <- added[[kk]]
[10:27:07.370]                   NAME <- NAMES[[kk]]
[10:27:07.370]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:07.370]                     next
[10:27:07.370]                   args[[name]] <- ""
[10:27:07.370]                 }
[10:27:07.370]                 NAMES <- toupper(removed)
[10:27:07.370]                 for (kk in seq_along(NAMES)) {
[10:27:07.370]                   name <- removed[[kk]]
[10:27:07.370]                   NAME <- NAMES[[kk]]
[10:27:07.370]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:07.370]                     next
[10:27:07.370]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:07.370]                 }
[10:27:07.370]                 if (length(args) > 0) 
[10:27:07.370]                   base::do.call(base::Sys.setenv, args = args)
[10:27:07.370]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:07.370]             }
[10:27:07.370]             else {
[10:27:07.370]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:07.370]             }
[10:27:07.370]             {
[10:27:07.370]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:07.370]                   0L) {
[10:27:07.370]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:07.370]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:07.370]                   base::options(opts)
[10:27:07.370]                 }
[10:27:07.370]                 {
[10:27:07.370]                   {
[10:27:07.370]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:07.370]                     NULL
[10:27:07.370]                   }
[10:27:07.370]                   options(future.plan = NULL)
[10:27:07.370]                   if (is.na(NA_character_)) 
[10:27:07.370]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:07.370]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:07.370]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:07.370]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:07.370]                     envir = parent.frame()) 
[10:27:07.370]                   {
[10:27:07.370]                     if (is.function(workers)) 
[10:27:07.370]                       workers <- workers()
[10:27:07.370]                     workers <- structure(as.integer(workers), 
[10:27:07.370]                       class = class(workers))
[10:27:07.370]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:07.370]                       workers >= 1)
[10:27:07.370]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:07.370]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:07.370]                     }
[10:27:07.370]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:07.370]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:07.370]                       envir = envir)
[10:27:07.370]                     if (!future$lazy) 
[10:27:07.370]                       future <- run(future)
[10:27:07.370]                     invisible(future)
[10:27:07.370]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:07.370]                 }
[10:27:07.370]             }
[10:27:07.370]         }
[10:27:07.370]     })
[10:27:07.370]     if (TRUE) {
[10:27:07.370]         base::sink(type = "output", split = FALSE)
[10:27:07.370]         if (TRUE) {
[10:27:07.370]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:07.370]         }
[10:27:07.370]         else {
[10:27:07.370]             ...future.result["stdout"] <- base::list(NULL)
[10:27:07.370]         }
[10:27:07.370]         base::close(...future.stdout)
[10:27:07.370]         ...future.stdout <- NULL
[10:27:07.370]     }
[10:27:07.370]     ...future.result$conditions <- ...future.conditions
[10:27:07.370]     ...future.result$finished <- base::Sys.time()
[10:27:07.370]     ...future.result
[10:27:07.370] }
[10:27:07.373] MultisessionFuture started
[10:27:07.373] - Launch lazy future ... done
[10:27:07.373] run() for ‘MultisessionFuture’ ... done
[10:27:07.373] getGlobalsAndPackages() ...
[10:27:07.373] Searching for globals...
[10:27:07.374] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:27:07.375] Searching for globals ... DONE
[10:27:07.375] Resolving globals: FALSE
[10:27:07.375] 
[10:27:07.375] 
[10:27:07.375] getGlobalsAndPackages() ... DONE
- w/ exception ...
[10:27:07.376] getGlobalsAndPackages() ...
[10:27:07.376] Searching for globals...
[10:27:07.376] - globals found: [2] ‘list’, ‘stop’
[10:27:07.376] Searching for globals ... DONE
[10:27:07.376] Resolving globals: FALSE
[10:27:07.377] 
[10:27:07.377] 
[10:27:07.377] getGlobalsAndPackages() ... DONE
[10:27:07.377] run() for ‘Future’ ...
[10:27:07.377] - state: ‘created’
[10:27:07.377] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:07.391] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:07.392] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:07.392]   - Field: ‘node’
[10:27:07.392]   - Field: ‘label’
[10:27:07.392]   - Field: ‘local’
[10:27:07.392]   - Field: ‘owner’
[10:27:07.392]   - Field: ‘envir’
[10:27:07.392]   - Field: ‘workers’
[10:27:07.392]   - Field: ‘packages’
[10:27:07.392]   - Field: ‘gc’
[10:27:07.392]   - Field: ‘conditions’
[10:27:07.393]   - Field: ‘persistent’
[10:27:07.393]   - Field: ‘expr’
[10:27:07.393]   - Field: ‘uuid’
[10:27:07.393]   - Field: ‘seed’
[10:27:07.393]   - Field: ‘version’
[10:27:07.393]   - Field: ‘result’
[10:27:07.393]   - Field: ‘asynchronous’
[10:27:07.393]   - Field: ‘calls’
[10:27:07.393]   - Field: ‘globals’
[10:27:07.393]   - Field: ‘stdout’
[10:27:07.394]   - Field: ‘earlySignal’
[10:27:07.394]   - Field: ‘lazy’
[10:27:07.394]   - Field: ‘state’
[10:27:07.394] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:07.394] - Launch lazy future ...
[10:27:07.394] Packages needed by the future expression (n = 0): <none>
[10:27:07.394] Packages needed by future strategies (n = 0): <none>
[10:27:07.395] {
[10:27:07.395]     {
[10:27:07.395]         {
[10:27:07.395]             ...future.startTime <- base::Sys.time()
[10:27:07.395]             {
[10:27:07.395]                 {
[10:27:07.395]                   {
[10:27:07.395]                     {
[10:27:07.395]                       base::local({
[10:27:07.395]                         has_future <- base::requireNamespace("future", 
[10:27:07.395]                           quietly = TRUE)
[10:27:07.395]                         if (has_future) {
[10:27:07.395]                           ns <- base::getNamespace("future")
[10:27:07.395]                           version <- ns[[".package"]][["version"]]
[10:27:07.395]                           if (is.null(version)) 
[10:27:07.395]                             version <- utils::packageVersion("future")
[10:27:07.395]                         }
[10:27:07.395]                         else {
[10:27:07.395]                           version <- NULL
[10:27:07.395]                         }
[10:27:07.395]                         if (!has_future || version < "1.8.0") {
[10:27:07.395]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:07.395]                             "", base::R.version$version.string), 
[10:27:07.395]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:07.395]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:07.395]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:07.395]                               "release", "version")], collapse = " "), 
[10:27:07.395]                             hostname = base::Sys.info()[["nodename"]])
[10:27:07.395]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:07.395]                             info)
[10:27:07.395]                           info <- base::paste(info, collapse = "; ")
[10:27:07.395]                           if (!has_future) {
[10:27:07.395]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:07.395]                               info)
[10:27:07.395]                           }
[10:27:07.395]                           else {
[10:27:07.395]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:07.395]                               info, version)
[10:27:07.395]                           }
[10:27:07.395]                           base::stop(msg)
[10:27:07.395]                         }
[10:27:07.395]                       })
[10:27:07.395]                     }
[10:27:07.395]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:07.395]                     base::options(mc.cores = 1L)
[10:27:07.395]                   }
[10:27:07.395]                   options(future.plan = NULL)
[10:27:07.395]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:07.395]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:07.395]                 }
[10:27:07.395]                 ...future.workdir <- getwd()
[10:27:07.395]             }
[10:27:07.395]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:07.395]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:07.395]         }
[10:27:07.395]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:07.395]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:07.395]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:07.395]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:07.395]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:07.395]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:07.395]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:07.395]             base::names(...future.oldOptions))
[10:27:07.395]     }
[10:27:07.395]     if (FALSE) {
[10:27:07.395]     }
[10:27:07.395]     else {
[10:27:07.395]         if (TRUE) {
[10:27:07.395]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:07.395]                 open = "w")
[10:27:07.395]         }
[10:27:07.395]         else {
[10:27:07.395]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:07.395]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:07.395]         }
[10:27:07.395]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:07.395]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:07.395]             base::sink(type = "output", split = FALSE)
[10:27:07.395]             base::close(...future.stdout)
[10:27:07.395]         }, add = TRUE)
[10:27:07.395]     }
[10:27:07.395]     ...future.frame <- base::sys.nframe()
[10:27:07.395]     ...future.conditions <- base::list()
[10:27:07.395]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:07.395]     if (FALSE) {
[10:27:07.395]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:07.395]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:07.395]     }
[10:27:07.395]     ...future.result <- base::tryCatch({
[10:27:07.395]         base::withCallingHandlers({
[10:27:07.395]             ...future.value <- base::withVisible(base::local({
[10:27:07.395]                 ...future.makeSendCondition <- base::local({
[10:27:07.395]                   sendCondition <- NULL
[10:27:07.395]                   function(frame = 1L) {
[10:27:07.395]                     if (is.function(sendCondition)) 
[10:27:07.395]                       return(sendCondition)
[10:27:07.395]                     ns <- getNamespace("parallel")
[10:27:07.395]                     if (exists("sendData", mode = "function", 
[10:27:07.395]                       envir = ns)) {
[10:27:07.395]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:07.395]                         envir = ns)
[10:27:07.395]                       envir <- sys.frame(frame)
[10:27:07.395]                       master <- NULL
[10:27:07.395]                       while (!identical(envir, .GlobalEnv) && 
[10:27:07.395]                         !identical(envir, emptyenv())) {
[10:27:07.395]                         if (exists("master", mode = "list", envir = envir, 
[10:27:07.395]                           inherits = FALSE)) {
[10:27:07.395]                           master <- get("master", mode = "list", 
[10:27:07.395]                             envir = envir, inherits = FALSE)
[10:27:07.395]                           if (inherits(master, c("SOCKnode", 
[10:27:07.395]                             "SOCK0node"))) {
[10:27:07.395]                             sendCondition <<- function(cond) {
[10:27:07.395]                               data <- list(type = "VALUE", value = cond, 
[10:27:07.395]                                 success = TRUE)
[10:27:07.395]                               parallel_sendData(master, data)
[10:27:07.395]                             }
[10:27:07.395]                             return(sendCondition)
[10:27:07.395]                           }
[10:27:07.395]                         }
[10:27:07.395]                         frame <- frame + 1L
[10:27:07.395]                         envir <- sys.frame(frame)
[10:27:07.395]                       }
[10:27:07.395]                     }
[10:27:07.395]                     sendCondition <<- function(cond) NULL
[10:27:07.395]                   }
[10:27:07.395]                 })
[10:27:07.395]                 withCallingHandlers({
[10:27:07.395]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:27:07.395]                 }, immediateCondition = function(cond) {
[10:27:07.395]                   sendCondition <- ...future.makeSendCondition()
[10:27:07.395]                   sendCondition(cond)
[10:27:07.395]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:07.395]                   {
[10:27:07.395]                     inherits <- base::inherits
[10:27:07.395]                     invokeRestart <- base::invokeRestart
[10:27:07.395]                     is.null <- base::is.null
[10:27:07.395]                     muffled <- FALSE
[10:27:07.395]                     if (inherits(cond, "message")) {
[10:27:07.395]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:07.395]                       if (muffled) 
[10:27:07.395]                         invokeRestart("muffleMessage")
[10:27:07.395]                     }
[10:27:07.395]                     else if (inherits(cond, "warning")) {
[10:27:07.395]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:07.395]                       if (muffled) 
[10:27:07.395]                         invokeRestart("muffleWarning")
[10:27:07.395]                     }
[10:27:07.395]                     else if (inherits(cond, "condition")) {
[10:27:07.395]                       if (!is.null(pattern)) {
[10:27:07.395]                         computeRestarts <- base::computeRestarts
[10:27:07.395]                         grepl <- base::grepl
[10:27:07.395]                         restarts <- computeRestarts(cond)
[10:27:07.395]                         for (restart in restarts) {
[10:27:07.395]                           name <- restart$name
[10:27:07.395]                           if (is.null(name)) 
[10:27:07.395]                             next
[10:27:07.395]                           if (!grepl(pattern, name)) 
[10:27:07.395]                             next
[10:27:07.395]                           invokeRestart(restart)
[10:27:07.395]                           muffled <- TRUE
[10:27:07.395]                           break
[10:27:07.395]                         }
[10:27:07.395]                       }
[10:27:07.395]                     }
[10:27:07.395]                     invisible(muffled)
[10:27:07.395]                   }
[10:27:07.395]                   muffleCondition(cond)
[10:27:07.395]                 })
[10:27:07.395]             }))
[10:27:07.395]             future::FutureResult(value = ...future.value$value, 
[10:27:07.395]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:07.395]                   ...future.rng), globalenv = if (FALSE) 
[10:27:07.395]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:07.395]                     ...future.globalenv.names))
[10:27:07.395]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:07.395]         }, condition = base::local({
[10:27:07.395]             c <- base::c
[10:27:07.395]             inherits <- base::inherits
[10:27:07.395]             invokeRestart <- base::invokeRestart
[10:27:07.395]             length <- base::length
[10:27:07.395]             list <- base::list
[10:27:07.395]             seq.int <- base::seq.int
[10:27:07.395]             signalCondition <- base::signalCondition
[10:27:07.395]             sys.calls <- base::sys.calls
[10:27:07.395]             `[[` <- base::`[[`
[10:27:07.395]             `+` <- base::`+`
[10:27:07.395]             `<<-` <- base::`<<-`
[10:27:07.395]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:07.395]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:07.395]                   3L)]
[10:27:07.395]             }
[10:27:07.395]             function(cond) {
[10:27:07.395]                 is_error <- inherits(cond, "error")
[10:27:07.395]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:07.395]                   NULL)
[10:27:07.395]                 if (is_error) {
[10:27:07.395]                   sessionInformation <- function() {
[10:27:07.395]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:07.395]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:07.395]                       search = base::search(), system = base::Sys.info())
[10:27:07.395]                   }
[10:27:07.395]                   ...future.conditions[[length(...future.conditions) + 
[10:27:07.395]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:07.395]                     cond$call), session = sessionInformation(), 
[10:27:07.395]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:07.395]                   signalCondition(cond)
[10:27:07.395]                 }
[10:27:07.395]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:07.395]                 "immediateCondition"))) {
[10:27:07.395]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:07.395]                   ...future.conditions[[length(...future.conditions) + 
[10:27:07.395]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:07.395]                   if (TRUE && !signal) {
[10:27:07.395]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:07.395]                     {
[10:27:07.395]                       inherits <- base::inherits
[10:27:07.395]                       invokeRestart <- base::invokeRestart
[10:27:07.395]                       is.null <- base::is.null
[10:27:07.395]                       muffled <- FALSE
[10:27:07.395]                       if (inherits(cond, "message")) {
[10:27:07.395]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:07.395]                         if (muffled) 
[10:27:07.395]                           invokeRestart("muffleMessage")
[10:27:07.395]                       }
[10:27:07.395]                       else if (inherits(cond, "warning")) {
[10:27:07.395]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:07.395]                         if (muffled) 
[10:27:07.395]                           invokeRestart("muffleWarning")
[10:27:07.395]                       }
[10:27:07.395]                       else if (inherits(cond, "condition")) {
[10:27:07.395]                         if (!is.null(pattern)) {
[10:27:07.395]                           computeRestarts <- base::computeRestarts
[10:27:07.395]                           grepl <- base::grepl
[10:27:07.395]                           restarts <- computeRestarts(cond)
[10:27:07.395]                           for (restart in restarts) {
[10:27:07.395]                             name <- restart$name
[10:27:07.395]                             if (is.null(name)) 
[10:27:07.395]                               next
[10:27:07.395]                             if (!grepl(pattern, name)) 
[10:27:07.395]                               next
[10:27:07.395]                             invokeRestart(restart)
[10:27:07.395]                             muffled <- TRUE
[10:27:07.395]                             break
[10:27:07.395]                           }
[10:27:07.395]                         }
[10:27:07.395]                       }
[10:27:07.395]                       invisible(muffled)
[10:27:07.395]                     }
[10:27:07.395]                     muffleCondition(cond, pattern = "^muffle")
[10:27:07.395]                   }
[10:27:07.395]                 }
[10:27:07.395]                 else {
[10:27:07.395]                   if (TRUE) {
[10:27:07.395]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:07.395]                     {
[10:27:07.395]                       inherits <- base::inherits
[10:27:07.395]                       invokeRestart <- base::invokeRestart
[10:27:07.395]                       is.null <- base::is.null
[10:27:07.395]                       muffled <- FALSE
[10:27:07.395]                       if (inherits(cond, "message")) {
[10:27:07.395]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:07.395]                         if (muffled) 
[10:27:07.395]                           invokeRestart("muffleMessage")
[10:27:07.395]                       }
[10:27:07.395]                       else if (inherits(cond, "warning")) {
[10:27:07.395]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:07.395]                         if (muffled) 
[10:27:07.395]                           invokeRestart("muffleWarning")
[10:27:07.395]                       }
[10:27:07.395]                       else if (inherits(cond, "condition")) {
[10:27:07.395]                         if (!is.null(pattern)) {
[10:27:07.395]                           computeRestarts <- base::computeRestarts
[10:27:07.395]                           grepl <- base::grepl
[10:27:07.395]                           restarts <- computeRestarts(cond)
[10:27:07.395]                           for (restart in restarts) {
[10:27:07.395]                             name <- restart$name
[10:27:07.395]                             if (is.null(name)) 
[10:27:07.395]                               next
[10:27:07.395]                             if (!grepl(pattern, name)) 
[10:27:07.395]                               next
[10:27:07.395]                             invokeRestart(restart)
[10:27:07.395]                             muffled <- TRUE
[10:27:07.395]                             break
[10:27:07.395]                           }
[10:27:07.395]                         }
[10:27:07.395]                       }
[10:27:07.395]                       invisible(muffled)
[10:27:07.395]                     }
[10:27:07.395]                     muffleCondition(cond, pattern = "^muffle")
[10:27:07.395]                   }
[10:27:07.395]                 }
[10:27:07.395]             }
[10:27:07.395]         }))
[10:27:07.395]     }, error = function(ex) {
[10:27:07.395]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:07.395]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:07.395]                 ...future.rng), started = ...future.startTime, 
[10:27:07.395]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:07.395]             version = "1.8"), class = "FutureResult")
[10:27:07.395]     }, finally = {
[10:27:07.395]         if (!identical(...future.workdir, getwd())) 
[10:27:07.395]             setwd(...future.workdir)
[10:27:07.395]         {
[10:27:07.395]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:07.395]                 ...future.oldOptions$nwarnings <- NULL
[10:27:07.395]             }
[10:27:07.395]             base::options(...future.oldOptions)
[10:27:07.395]             if (.Platform$OS.type == "windows") {
[10:27:07.395]                 old_names <- names(...future.oldEnvVars)
[10:27:07.395]                 envs <- base::Sys.getenv()
[10:27:07.395]                 names <- names(envs)
[10:27:07.395]                 common <- intersect(names, old_names)
[10:27:07.395]                 added <- setdiff(names, old_names)
[10:27:07.395]                 removed <- setdiff(old_names, names)
[10:27:07.395]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:07.395]                   envs[common]]
[10:27:07.395]                 NAMES <- toupper(changed)
[10:27:07.395]                 args <- list()
[10:27:07.395]                 for (kk in seq_along(NAMES)) {
[10:27:07.395]                   name <- changed[[kk]]
[10:27:07.395]                   NAME <- NAMES[[kk]]
[10:27:07.395]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:07.395]                     next
[10:27:07.395]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:07.395]                 }
[10:27:07.395]                 NAMES <- toupper(added)
[10:27:07.395]                 for (kk in seq_along(NAMES)) {
[10:27:07.395]                   name <- added[[kk]]
[10:27:07.395]                   NAME <- NAMES[[kk]]
[10:27:07.395]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:07.395]                     next
[10:27:07.395]                   args[[name]] <- ""
[10:27:07.395]                 }
[10:27:07.395]                 NAMES <- toupper(removed)
[10:27:07.395]                 for (kk in seq_along(NAMES)) {
[10:27:07.395]                   name <- removed[[kk]]
[10:27:07.395]                   NAME <- NAMES[[kk]]
[10:27:07.395]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:07.395]                     next
[10:27:07.395]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:07.395]                 }
[10:27:07.395]                 if (length(args) > 0) 
[10:27:07.395]                   base::do.call(base::Sys.setenv, args = args)
[10:27:07.395]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:07.395]             }
[10:27:07.395]             else {
[10:27:07.395]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:07.395]             }
[10:27:07.395]             {
[10:27:07.395]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:07.395]                   0L) {
[10:27:07.395]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:07.395]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:07.395]                   base::options(opts)
[10:27:07.395]                 }
[10:27:07.395]                 {
[10:27:07.395]                   {
[10:27:07.395]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:07.395]                     NULL
[10:27:07.395]                   }
[10:27:07.395]                   options(future.plan = NULL)
[10:27:07.395]                   if (is.na(NA_character_)) 
[10:27:07.395]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:07.395]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:07.395]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:07.395]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:07.395]                     envir = parent.frame()) 
[10:27:07.395]                   {
[10:27:07.395]                     if (is.function(workers)) 
[10:27:07.395]                       workers <- workers()
[10:27:07.395]                     workers <- structure(as.integer(workers), 
[10:27:07.395]                       class = class(workers))
[10:27:07.395]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:07.395]                       workers >= 1)
[10:27:07.395]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:07.395]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:07.395]                     }
[10:27:07.395]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:07.395]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:07.395]                       envir = envir)
[10:27:07.395]                     if (!future$lazy) 
[10:27:07.395]                       future <- run(future)
[10:27:07.395]                     invisible(future)
[10:27:07.395]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:07.395]                 }
[10:27:07.395]             }
[10:27:07.395]         }
[10:27:07.395]     })
[10:27:07.395]     if (TRUE) {
[10:27:07.395]         base::sink(type = "output", split = FALSE)
[10:27:07.395]         if (TRUE) {
[10:27:07.395]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:07.395]         }
[10:27:07.395]         else {
[10:27:07.395]             ...future.result["stdout"] <- base::list(NULL)
[10:27:07.395]         }
[10:27:07.395]         base::close(...future.stdout)
[10:27:07.395]         ...future.stdout <- NULL
[10:27:07.395]     }
[10:27:07.395]     ...future.result$conditions <- ...future.conditions
[10:27:07.395]     ...future.result$finished <- base::Sys.time()
[10:27:07.395]     ...future.result
[10:27:07.395] }
[10:27:07.449] MultisessionFuture started
[10:27:07.449] - Launch lazy future ... done
[10:27:07.449] run() for ‘MultisessionFuture’ ... done
[10:27:07.450] getGlobalsAndPackages() ...
[10:27:07.450] Searching for globals...
[10:27:07.451] - globals found: [2] ‘list’, ‘stop’
[10:27:07.451] Searching for globals ... DONE
[10:27:07.451] Resolving globals: FALSE
[10:27:07.452] 
[10:27:07.452] 
[10:27:07.452] getGlobalsAndPackages() ... DONE
- result = FALSE, recursive = -1 ... DONE
- result = FALSE, recursive = 0 ...
[10:27:07.453] getGlobalsAndPackages() ...
[10:27:07.453] Searching for globals...
[10:27:07.455] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:27:07.455] Searching for globals ... DONE
[10:27:07.455] Resolving globals: FALSE
[10:27:07.456] 
[10:27:07.456] 
[10:27:07.456] getGlobalsAndPackages() ... DONE
[10:27:07.456] run() for ‘Future’ ...
[10:27:07.456] - state: ‘created’
[10:27:07.457] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:07.474] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:07.474] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:07.474]   - Field: ‘node’
[10:27:07.474]   - Field: ‘label’
[10:27:07.475]   - Field: ‘local’
[10:27:07.475]   - Field: ‘owner’
[10:27:07.475]   - Field: ‘envir’
[10:27:07.475]   - Field: ‘workers’
[10:27:07.475]   - Field: ‘packages’
[10:27:07.475]   - Field: ‘gc’
[10:27:07.476]   - Field: ‘conditions’
[10:27:07.476]   - Field: ‘persistent’
[10:27:07.476]   - Field: ‘expr’
[10:27:07.476]   - Field: ‘uuid’
[10:27:07.476]   - Field: ‘seed’
[10:27:07.476]   - Field: ‘version’
[10:27:07.477]   - Field: ‘result’
[10:27:07.477]   - Field: ‘asynchronous’
[10:27:07.477]   - Field: ‘calls’
[10:27:07.477]   - Field: ‘globals’
[10:27:07.477]   - Field: ‘stdout’
[10:27:07.478]   - Field: ‘earlySignal’
[10:27:07.478]   - Field: ‘lazy’
[10:27:07.478]   - Field: ‘state’
[10:27:07.478] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:07.478] - Launch lazy future ...
[10:27:07.479] Packages needed by the future expression (n = 0): <none>
[10:27:07.479] Packages needed by future strategies (n = 0): <none>
[10:27:07.480] {
[10:27:07.480]     {
[10:27:07.480]         {
[10:27:07.480]             ...future.startTime <- base::Sys.time()
[10:27:07.480]             {
[10:27:07.480]                 {
[10:27:07.480]                   {
[10:27:07.480]                     {
[10:27:07.480]                       base::local({
[10:27:07.480]                         has_future <- base::requireNamespace("future", 
[10:27:07.480]                           quietly = TRUE)
[10:27:07.480]                         if (has_future) {
[10:27:07.480]                           ns <- base::getNamespace("future")
[10:27:07.480]                           version <- ns[[".package"]][["version"]]
[10:27:07.480]                           if (is.null(version)) 
[10:27:07.480]                             version <- utils::packageVersion("future")
[10:27:07.480]                         }
[10:27:07.480]                         else {
[10:27:07.480]                           version <- NULL
[10:27:07.480]                         }
[10:27:07.480]                         if (!has_future || version < "1.8.0") {
[10:27:07.480]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:07.480]                             "", base::R.version$version.string), 
[10:27:07.480]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:07.480]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:07.480]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:07.480]                               "release", "version")], collapse = " "), 
[10:27:07.480]                             hostname = base::Sys.info()[["nodename"]])
[10:27:07.480]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:07.480]                             info)
[10:27:07.480]                           info <- base::paste(info, collapse = "; ")
[10:27:07.480]                           if (!has_future) {
[10:27:07.480]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:07.480]                               info)
[10:27:07.480]                           }
[10:27:07.480]                           else {
[10:27:07.480]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:07.480]                               info, version)
[10:27:07.480]                           }
[10:27:07.480]                           base::stop(msg)
[10:27:07.480]                         }
[10:27:07.480]                       })
[10:27:07.480]                     }
[10:27:07.480]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:07.480]                     base::options(mc.cores = 1L)
[10:27:07.480]                   }
[10:27:07.480]                   options(future.plan = NULL)
[10:27:07.480]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:07.480]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:07.480]                 }
[10:27:07.480]                 ...future.workdir <- getwd()
[10:27:07.480]             }
[10:27:07.480]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:07.480]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:07.480]         }
[10:27:07.480]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:07.480]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:07.480]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:07.480]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:07.480]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:07.480]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:07.480]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:07.480]             base::names(...future.oldOptions))
[10:27:07.480]     }
[10:27:07.480]     if (FALSE) {
[10:27:07.480]     }
[10:27:07.480]     else {
[10:27:07.480]         if (TRUE) {
[10:27:07.480]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:07.480]                 open = "w")
[10:27:07.480]         }
[10:27:07.480]         else {
[10:27:07.480]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:07.480]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:07.480]         }
[10:27:07.480]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:07.480]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:07.480]             base::sink(type = "output", split = FALSE)
[10:27:07.480]             base::close(...future.stdout)
[10:27:07.480]         }, add = TRUE)
[10:27:07.480]     }
[10:27:07.480]     ...future.frame <- base::sys.nframe()
[10:27:07.480]     ...future.conditions <- base::list()
[10:27:07.480]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:07.480]     if (FALSE) {
[10:27:07.480]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:07.480]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:07.480]     }
[10:27:07.480]     ...future.result <- base::tryCatch({
[10:27:07.480]         base::withCallingHandlers({
[10:27:07.480]             ...future.value <- base::withVisible(base::local({
[10:27:07.480]                 ...future.makeSendCondition <- base::local({
[10:27:07.480]                   sendCondition <- NULL
[10:27:07.480]                   function(frame = 1L) {
[10:27:07.480]                     if (is.function(sendCondition)) 
[10:27:07.480]                       return(sendCondition)
[10:27:07.480]                     ns <- getNamespace("parallel")
[10:27:07.480]                     if (exists("sendData", mode = "function", 
[10:27:07.480]                       envir = ns)) {
[10:27:07.480]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:07.480]                         envir = ns)
[10:27:07.480]                       envir <- sys.frame(frame)
[10:27:07.480]                       master <- NULL
[10:27:07.480]                       while (!identical(envir, .GlobalEnv) && 
[10:27:07.480]                         !identical(envir, emptyenv())) {
[10:27:07.480]                         if (exists("master", mode = "list", envir = envir, 
[10:27:07.480]                           inherits = FALSE)) {
[10:27:07.480]                           master <- get("master", mode = "list", 
[10:27:07.480]                             envir = envir, inherits = FALSE)
[10:27:07.480]                           if (inherits(master, c("SOCKnode", 
[10:27:07.480]                             "SOCK0node"))) {
[10:27:07.480]                             sendCondition <<- function(cond) {
[10:27:07.480]                               data <- list(type = "VALUE", value = cond, 
[10:27:07.480]                                 success = TRUE)
[10:27:07.480]                               parallel_sendData(master, data)
[10:27:07.480]                             }
[10:27:07.480]                             return(sendCondition)
[10:27:07.480]                           }
[10:27:07.480]                         }
[10:27:07.480]                         frame <- frame + 1L
[10:27:07.480]                         envir <- sys.frame(frame)
[10:27:07.480]                       }
[10:27:07.480]                     }
[10:27:07.480]                     sendCondition <<- function(cond) NULL
[10:27:07.480]                   }
[10:27:07.480]                 })
[10:27:07.480]                 withCallingHandlers({
[10:27:07.480]                   {
[10:27:07.480]                     Sys.sleep(0.5)
[10:27:07.480]                     list(a = 1, b = 42L)
[10:27:07.480]                   }
[10:27:07.480]                 }, immediateCondition = function(cond) {
[10:27:07.480]                   sendCondition <- ...future.makeSendCondition()
[10:27:07.480]                   sendCondition(cond)
[10:27:07.480]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:07.480]                   {
[10:27:07.480]                     inherits <- base::inherits
[10:27:07.480]                     invokeRestart <- base::invokeRestart
[10:27:07.480]                     is.null <- base::is.null
[10:27:07.480]                     muffled <- FALSE
[10:27:07.480]                     if (inherits(cond, "message")) {
[10:27:07.480]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:07.480]                       if (muffled) 
[10:27:07.480]                         invokeRestart("muffleMessage")
[10:27:07.480]                     }
[10:27:07.480]                     else if (inherits(cond, "warning")) {
[10:27:07.480]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:07.480]                       if (muffled) 
[10:27:07.480]                         invokeRestart("muffleWarning")
[10:27:07.480]                     }
[10:27:07.480]                     else if (inherits(cond, "condition")) {
[10:27:07.480]                       if (!is.null(pattern)) {
[10:27:07.480]                         computeRestarts <- base::computeRestarts
[10:27:07.480]                         grepl <- base::grepl
[10:27:07.480]                         restarts <- computeRestarts(cond)
[10:27:07.480]                         for (restart in restarts) {
[10:27:07.480]                           name <- restart$name
[10:27:07.480]                           if (is.null(name)) 
[10:27:07.480]                             next
[10:27:07.480]                           if (!grepl(pattern, name)) 
[10:27:07.480]                             next
[10:27:07.480]                           invokeRestart(restart)
[10:27:07.480]                           muffled <- TRUE
[10:27:07.480]                           break
[10:27:07.480]                         }
[10:27:07.480]                       }
[10:27:07.480]                     }
[10:27:07.480]                     invisible(muffled)
[10:27:07.480]                   }
[10:27:07.480]                   muffleCondition(cond)
[10:27:07.480]                 })
[10:27:07.480]             }))
[10:27:07.480]             future::FutureResult(value = ...future.value$value, 
[10:27:07.480]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:07.480]                   ...future.rng), globalenv = if (FALSE) 
[10:27:07.480]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:07.480]                     ...future.globalenv.names))
[10:27:07.480]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:07.480]         }, condition = base::local({
[10:27:07.480]             c <- base::c
[10:27:07.480]             inherits <- base::inherits
[10:27:07.480]             invokeRestart <- base::invokeRestart
[10:27:07.480]             length <- base::length
[10:27:07.480]             list <- base::list
[10:27:07.480]             seq.int <- base::seq.int
[10:27:07.480]             signalCondition <- base::signalCondition
[10:27:07.480]             sys.calls <- base::sys.calls
[10:27:07.480]             `[[` <- base::`[[`
[10:27:07.480]             `+` <- base::`+`
[10:27:07.480]             `<<-` <- base::`<<-`
[10:27:07.480]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:07.480]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:07.480]                   3L)]
[10:27:07.480]             }
[10:27:07.480]             function(cond) {
[10:27:07.480]                 is_error <- inherits(cond, "error")
[10:27:07.480]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:07.480]                   NULL)
[10:27:07.480]                 if (is_error) {
[10:27:07.480]                   sessionInformation <- function() {
[10:27:07.480]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:07.480]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:07.480]                       search = base::search(), system = base::Sys.info())
[10:27:07.480]                   }
[10:27:07.480]                   ...future.conditions[[length(...future.conditions) + 
[10:27:07.480]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:07.480]                     cond$call), session = sessionInformation(), 
[10:27:07.480]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:07.480]                   signalCondition(cond)
[10:27:07.480]                 }
[10:27:07.480]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:07.480]                 "immediateCondition"))) {
[10:27:07.480]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:07.480]                   ...future.conditions[[length(...future.conditions) + 
[10:27:07.480]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:07.480]                   if (TRUE && !signal) {
[10:27:07.480]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:07.480]                     {
[10:27:07.480]                       inherits <- base::inherits
[10:27:07.480]                       invokeRestart <- base::invokeRestart
[10:27:07.480]                       is.null <- base::is.null
[10:27:07.480]                       muffled <- FALSE
[10:27:07.480]                       if (inherits(cond, "message")) {
[10:27:07.480]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:07.480]                         if (muffled) 
[10:27:07.480]                           invokeRestart("muffleMessage")
[10:27:07.480]                       }
[10:27:07.480]                       else if (inherits(cond, "warning")) {
[10:27:07.480]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:07.480]                         if (muffled) 
[10:27:07.480]                           invokeRestart("muffleWarning")
[10:27:07.480]                       }
[10:27:07.480]                       else if (inherits(cond, "condition")) {
[10:27:07.480]                         if (!is.null(pattern)) {
[10:27:07.480]                           computeRestarts <- base::computeRestarts
[10:27:07.480]                           grepl <- base::grepl
[10:27:07.480]                           restarts <- computeRestarts(cond)
[10:27:07.480]                           for (restart in restarts) {
[10:27:07.480]                             name <- restart$name
[10:27:07.480]                             if (is.null(name)) 
[10:27:07.480]                               next
[10:27:07.480]                             if (!grepl(pattern, name)) 
[10:27:07.480]                               next
[10:27:07.480]                             invokeRestart(restart)
[10:27:07.480]                             muffled <- TRUE
[10:27:07.480]                             break
[10:27:07.480]                           }
[10:27:07.480]                         }
[10:27:07.480]                       }
[10:27:07.480]                       invisible(muffled)
[10:27:07.480]                     }
[10:27:07.480]                     muffleCondition(cond, pattern = "^muffle")
[10:27:07.480]                   }
[10:27:07.480]                 }
[10:27:07.480]                 else {
[10:27:07.480]                   if (TRUE) {
[10:27:07.480]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:07.480]                     {
[10:27:07.480]                       inherits <- base::inherits
[10:27:07.480]                       invokeRestart <- base::invokeRestart
[10:27:07.480]                       is.null <- base::is.null
[10:27:07.480]                       muffled <- FALSE
[10:27:07.480]                       if (inherits(cond, "message")) {
[10:27:07.480]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:07.480]                         if (muffled) 
[10:27:07.480]                           invokeRestart("muffleMessage")
[10:27:07.480]                       }
[10:27:07.480]                       else if (inherits(cond, "warning")) {
[10:27:07.480]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:07.480]                         if (muffled) 
[10:27:07.480]                           invokeRestart("muffleWarning")
[10:27:07.480]                       }
[10:27:07.480]                       else if (inherits(cond, "condition")) {
[10:27:07.480]                         if (!is.null(pattern)) {
[10:27:07.480]                           computeRestarts <- base::computeRestarts
[10:27:07.480]                           grepl <- base::grepl
[10:27:07.480]                           restarts <- computeRestarts(cond)
[10:27:07.480]                           for (restart in restarts) {
[10:27:07.480]                             name <- restart$name
[10:27:07.480]                             if (is.null(name)) 
[10:27:07.480]                               next
[10:27:07.480]                             if (!grepl(pattern, name)) 
[10:27:07.480]                               next
[10:27:07.480]                             invokeRestart(restart)
[10:27:07.480]                             muffled <- TRUE
[10:27:07.480]                             break
[10:27:07.480]                           }
[10:27:07.480]                         }
[10:27:07.480]                       }
[10:27:07.480]                       invisible(muffled)
[10:27:07.480]                     }
[10:27:07.480]                     muffleCondition(cond, pattern = "^muffle")
[10:27:07.480]                   }
[10:27:07.480]                 }
[10:27:07.480]             }
[10:27:07.480]         }))
[10:27:07.480]     }, error = function(ex) {
[10:27:07.480]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:07.480]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:07.480]                 ...future.rng), started = ...future.startTime, 
[10:27:07.480]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:07.480]             version = "1.8"), class = "FutureResult")
[10:27:07.480]     }, finally = {
[10:27:07.480]         if (!identical(...future.workdir, getwd())) 
[10:27:07.480]             setwd(...future.workdir)
[10:27:07.480]         {
[10:27:07.480]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:07.480]                 ...future.oldOptions$nwarnings <- NULL
[10:27:07.480]             }
[10:27:07.480]             base::options(...future.oldOptions)
[10:27:07.480]             if (.Platform$OS.type == "windows") {
[10:27:07.480]                 old_names <- names(...future.oldEnvVars)
[10:27:07.480]                 envs <- base::Sys.getenv()
[10:27:07.480]                 names <- names(envs)
[10:27:07.480]                 common <- intersect(names, old_names)
[10:27:07.480]                 added <- setdiff(names, old_names)
[10:27:07.480]                 removed <- setdiff(old_names, names)
[10:27:07.480]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:07.480]                   envs[common]]
[10:27:07.480]                 NAMES <- toupper(changed)
[10:27:07.480]                 args <- list()
[10:27:07.480]                 for (kk in seq_along(NAMES)) {
[10:27:07.480]                   name <- changed[[kk]]
[10:27:07.480]                   NAME <- NAMES[[kk]]
[10:27:07.480]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:07.480]                     next
[10:27:07.480]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:07.480]                 }
[10:27:07.480]                 NAMES <- toupper(added)
[10:27:07.480]                 for (kk in seq_along(NAMES)) {
[10:27:07.480]                   name <- added[[kk]]
[10:27:07.480]                   NAME <- NAMES[[kk]]
[10:27:07.480]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:07.480]                     next
[10:27:07.480]                   args[[name]] <- ""
[10:27:07.480]                 }
[10:27:07.480]                 NAMES <- toupper(removed)
[10:27:07.480]                 for (kk in seq_along(NAMES)) {
[10:27:07.480]                   name <- removed[[kk]]
[10:27:07.480]                   NAME <- NAMES[[kk]]
[10:27:07.480]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:07.480]                     next
[10:27:07.480]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:07.480]                 }
[10:27:07.480]                 if (length(args) > 0) 
[10:27:07.480]                   base::do.call(base::Sys.setenv, args = args)
[10:27:07.480]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:07.480]             }
[10:27:07.480]             else {
[10:27:07.480]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:07.480]             }
[10:27:07.480]             {
[10:27:07.480]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:07.480]                   0L) {
[10:27:07.480]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:07.480]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:07.480]                   base::options(opts)
[10:27:07.480]                 }
[10:27:07.480]                 {
[10:27:07.480]                   {
[10:27:07.480]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:07.480]                     NULL
[10:27:07.480]                   }
[10:27:07.480]                   options(future.plan = NULL)
[10:27:07.480]                   if (is.na(NA_character_)) 
[10:27:07.480]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:07.480]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:07.480]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:07.480]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:07.480]                     envir = parent.frame()) 
[10:27:07.480]                   {
[10:27:07.480]                     if (is.function(workers)) 
[10:27:07.480]                       workers <- workers()
[10:27:07.480]                     workers <- structure(as.integer(workers), 
[10:27:07.480]                       class = class(workers))
[10:27:07.480]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:07.480]                       workers >= 1)
[10:27:07.480]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:07.480]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:07.480]                     }
[10:27:07.480]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:07.480]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:07.480]                       envir = envir)
[10:27:07.480]                     if (!future$lazy) 
[10:27:07.480]                       future <- run(future)
[10:27:07.480]                     invisible(future)
[10:27:07.480]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:07.480]                 }
[10:27:07.480]             }
[10:27:07.480]         }
[10:27:07.480]     })
[10:27:07.480]     if (TRUE) {
[10:27:07.480]         base::sink(type = "output", split = FALSE)
[10:27:07.480]         if (TRUE) {
[10:27:07.480]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:07.480]         }
[10:27:07.480]         else {
[10:27:07.480]             ...future.result["stdout"] <- base::list(NULL)
[10:27:07.480]         }
[10:27:07.480]         base::close(...future.stdout)
[10:27:07.480]         ...future.stdout <- NULL
[10:27:07.480]     }
[10:27:07.480]     ...future.result$conditions <- ...future.conditions
[10:27:07.480]     ...future.result$finished <- base::Sys.time()
[10:27:07.480]     ...future.result
[10:27:07.480] }
[10:27:07.484] Poll #1 (0): usedNodes() = 2, workers = 2
[10:27:07.510] receiveMessageFromWorker() for ClusterFuture ...
[10:27:07.510] - Validating connection of MultisessionFuture
[10:27:07.510] - received message: FutureResult
[10:27:07.511] - Received FutureResult
[10:27:07.511] - Erased future from FutureRegistry
[10:27:07.511] result() for ClusterFuture ...
[10:27:07.511] - result already collected: FutureResult
[10:27:07.511] result() for ClusterFuture ... done
[10:27:07.511] signalConditions() ...
[10:27:07.511]  - include = ‘immediateCondition’
[10:27:07.511]  - exclude = 
[10:27:07.511]  - resignal = FALSE
[10:27:07.512]  - Number of conditions: 1
[10:27:07.512] signalConditions() ... done
[10:27:07.512] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:07.512] result() for ClusterFuture ...
[10:27:07.512] - result already collected: FutureResult
[10:27:07.512] result() for ClusterFuture ... done
[10:27:07.512] result() for ClusterFuture ...
[10:27:07.512] - result already collected: FutureResult
[10:27:07.512] result() for ClusterFuture ... done
[10:27:07.512] signalConditions() ...
[10:27:07.512]  - include = ‘immediateCondition’
[10:27:07.513]  - exclude = 
[10:27:07.513]  - resignal = FALSE
[10:27:07.513]  - Number of conditions: 1
[10:27:07.513] signalConditions() ... done
[10:27:07.514] MultisessionFuture started
[10:27:07.514] - Launch lazy future ... done
[10:27:07.514] run() for ‘MultisessionFuture’ ... done
[10:27:08.074] receiveMessageFromWorker() for ClusterFuture ...
[10:27:08.074] - Validating connection of MultisessionFuture
[10:27:08.074] - received message: FutureResult
[10:27:08.075] - Received FutureResult
[10:27:08.075] - Erased future from FutureRegistry
[10:27:08.075] result() for ClusterFuture ...
[10:27:08.075] - result already collected: FutureResult
[10:27:08.075] result() for ClusterFuture ... done
[10:27:08.075] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:08.075] A MultisessionFuture was resolved (result was not collected)
[10:27:08.075] getGlobalsAndPackages() ...
[10:27:08.075] Searching for globals...
[10:27:08.077] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:27:08.077] Searching for globals ... DONE
[10:27:08.077] Resolving globals: FALSE
[10:27:08.077] 
[10:27:08.077] 
[10:27:08.077] getGlobalsAndPackages() ... DONE
[10:27:08.078] run() for ‘Future’ ...
[10:27:08.078] - state: ‘created’
[10:27:08.078] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:08.092] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:08.093] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:08.093]   - Field: ‘node’
[10:27:08.093]   - Field: ‘label’
[10:27:08.093]   - Field: ‘local’
[10:27:08.093]   - Field: ‘owner’
[10:27:08.093]   - Field: ‘envir’
[10:27:08.093]   - Field: ‘workers’
[10:27:08.093]   - Field: ‘packages’
[10:27:08.093]   - Field: ‘gc’
[10:27:08.093]   - Field: ‘conditions’
[10:27:08.094]   - Field: ‘persistent’
[10:27:08.094]   - Field: ‘expr’
[10:27:08.094]   - Field: ‘uuid’
[10:27:08.094]   - Field: ‘seed’
[10:27:08.094]   - Field: ‘version’
[10:27:08.094]   - Field: ‘result’
[10:27:08.094]   - Field: ‘asynchronous’
[10:27:08.094]   - Field: ‘calls’
[10:27:08.094]   - Field: ‘globals’
[10:27:08.094]   - Field: ‘stdout’
[10:27:08.094]   - Field: ‘earlySignal’
[10:27:08.095]   - Field: ‘lazy’
[10:27:08.095]   - Field: ‘state’
[10:27:08.095] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:08.095] - Launch lazy future ...
[10:27:08.095] Packages needed by the future expression (n = 0): <none>
[10:27:08.095] Packages needed by future strategies (n = 0): <none>
[10:27:08.096] {
[10:27:08.096]     {
[10:27:08.096]         {
[10:27:08.096]             ...future.startTime <- base::Sys.time()
[10:27:08.096]             {
[10:27:08.096]                 {
[10:27:08.096]                   {
[10:27:08.096]                     {
[10:27:08.096]                       base::local({
[10:27:08.096]                         has_future <- base::requireNamespace("future", 
[10:27:08.096]                           quietly = TRUE)
[10:27:08.096]                         if (has_future) {
[10:27:08.096]                           ns <- base::getNamespace("future")
[10:27:08.096]                           version <- ns[[".package"]][["version"]]
[10:27:08.096]                           if (is.null(version)) 
[10:27:08.096]                             version <- utils::packageVersion("future")
[10:27:08.096]                         }
[10:27:08.096]                         else {
[10:27:08.096]                           version <- NULL
[10:27:08.096]                         }
[10:27:08.096]                         if (!has_future || version < "1.8.0") {
[10:27:08.096]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:08.096]                             "", base::R.version$version.string), 
[10:27:08.096]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:08.096]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:08.096]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:08.096]                               "release", "version")], collapse = " "), 
[10:27:08.096]                             hostname = base::Sys.info()[["nodename"]])
[10:27:08.096]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:08.096]                             info)
[10:27:08.096]                           info <- base::paste(info, collapse = "; ")
[10:27:08.096]                           if (!has_future) {
[10:27:08.096]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:08.096]                               info)
[10:27:08.096]                           }
[10:27:08.096]                           else {
[10:27:08.096]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:08.096]                               info, version)
[10:27:08.096]                           }
[10:27:08.096]                           base::stop(msg)
[10:27:08.096]                         }
[10:27:08.096]                       })
[10:27:08.096]                     }
[10:27:08.096]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:08.096]                     base::options(mc.cores = 1L)
[10:27:08.096]                   }
[10:27:08.096]                   options(future.plan = NULL)
[10:27:08.096]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:08.096]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:08.096]                 }
[10:27:08.096]                 ...future.workdir <- getwd()
[10:27:08.096]             }
[10:27:08.096]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:08.096]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:08.096]         }
[10:27:08.096]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:08.096]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:08.096]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:08.096]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:08.096]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:08.096]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:08.096]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:08.096]             base::names(...future.oldOptions))
[10:27:08.096]     }
[10:27:08.096]     if (FALSE) {
[10:27:08.096]     }
[10:27:08.096]     else {
[10:27:08.096]         if (TRUE) {
[10:27:08.096]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:08.096]                 open = "w")
[10:27:08.096]         }
[10:27:08.096]         else {
[10:27:08.096]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:08.096]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:08.096]         }
[10:27:08.096]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:08.096]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:08.096]             base::sink(type = "output", split = FALSE)
[10:27:08.096]             base::close(...future.stdout)
[10:27:08.096]         }, add = TRUE)
[10:27:08.096]     }
[10:27:08.096]     ...future.frame <- base::sys.nframe()
[10:27:08.096]     ...future.conditions <- base::list()
[10:27:08.096]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:08.096]     if (FALSE) {
[10:27:08.096]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:08.096]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:08.096]     }
[10:27:08.096]     ...future.result <- base::tryCatch({
[10:27:08.096]         base::withCallingHandlers({
[10:27:08.096]             ...future.value <- base::withVisible(base::local({
[10:27:08.096]                 ...future.makeSendCondition <- base::local({
[10:27:08.096]                   sendCondition <- NULL
[10:27:08.096]                   function(frame = 1L) {
[10:27:08.096]                     if (is.function(sendCondition)) 
[10:27:08.096]                       return(sendCondition)
[10:27:08.096]                     ns <- getNamespace("parallel")
[10:27:08.096]                     if (exists("sendData", mode = "function", 
[10:27:08.096]                       envir = ns)) {
[10:27:08.096]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:08.096]                         envir = ns)
[10:27:08.096]                       envir <- sys.frame(frame)
[10:27:08.096]                       master <- NULL
[10:27:08.096]                       while (!identical(envir, .GlobalEnv) && 
[10:27:08.096]                         !identical(envir, emptyenv())) {
[10:27:08.096]                         if (exists("master", mode = "list", envir = envir, 
[10:27:08.096]                           inherits = FALSE)) {
[10:27:08.096]                           master <- get("master", mode = "list", 
[10:27:08.096]                             envir = envir, inherits = FALSE)
[10:27:08.096]                           if (inherits(master, c("SOCKnode", 
[10:27:08.096]                             "SOCK0node"))) {
[10:27:08.096]                             sendCondition <<- function(cond) {
[10:27:08.096]                               data <- list(type = "VALUE", value = cond, 
[10:27:08.096]                                 success = TRUE)
[10:27:08.096]                               parallel_sendData(master, data)
[10:27:08.096]                             }
[10:27:08.096]                             return(sendCondition)
[10:27:08.096]                           }
[10:27:08.096]                         }
[10:27:08.096]                         frame <- frame + 1L
[10:27:08.096]                         envir <- sys.frame(frame)
[10:27:08.096]                       }
[10:27:08.096]                     }
[10:27:08.096]                     sendCondition <<- function(cond) NULL
[10:27:08.096]                   }
[10:27:08.096]                 })
[10:27:08.096]                 withCallingHandlers({
[10:27:08.096]                   {
[10:27:08.096]                     Sys.sleep(0.5)
[10:27:08.096]                     list(a = 1, b = 42L)
[10:27:08.096]                   }
[10:27:08.096]                 }, immediateCondition = function(cond) {
[10:27:08.096]                   sendCondition <- ...future.makeSendCondition()
[10:27:08.096]                   sendCondition(cond)
[10:27:08.096]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:08.096]                   {
[10:27:08.096]                     inherits <- base::inherits
[10:27:08.096]                     invokeRestart <- base::invokeRestart
[10:27:08.096]                     is.null <- base::is.null
[10:27:08.096]                     muffled <- FALSE
[10:27:08.096]                     if (inherits(cond, "message")) {
[10:27:08.096]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:08.096]                       if (muffled) 
[10:27:08.096]                         invokeRestart("muffleMessage")
[10:27:08.096]                     }
[10:27:08.096]                     else if (inherits(cond, "warning")) {
[10:27:08.096]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:08.096]                       if (muffled) 
[10:27:08.096]                         invokeRestart("muffleWarning")
[10:27:08.096]                     }
[10:27:08.096]                     else if (inherits(cond, "condition")) {
[10:27:08.096]                       if (!is.null(pattern)) {
[10:27:08.096]                         computeRestarts <- base::computeRestarts
[10:27:08.096]                         grepl <- base::grepl
[10:27:08.096]                         restarts <- computeRestarts(cond)
[10:27:08.096]                         for (restart in restarts) {
[10:27:08.096]                           name <- restart$name
[10:27:08.096]                           if (is.null(name)) 
[10:27:08.096]                             next
[10:27:08.096]                           if (!grepl(pattern, name)) 
[10:27:08.096]                             next
[10:27:08.096]                           invokeRestart(restart)
[10:27:08.096]                           muffled <- TRUE
[10:27:08.096]                           break
[10:27:08.096]                         }
[10:27:08.096]                       }
[10:27:08.096]                     }
[10:27:08.096]                     invisible(muffled)
[10:27:08.096]                   }
[10:27:08.096]                   muffleCondition(cond)
[10:27:08.096]                 })
[10:27:08.096]             }))
[10:27:08.096]             future::FutureResult(value = ...future.value$value, 
[10:27:08.096]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:08.096]                   ...future.rng), globalenv = if (FALSE) 
[10:27:08.096]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:08.096]                     ...future.globalenv.names))
[10:27:08.096]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:08.096]         }, condition = base::local({
[10:27:08.096]             c <- base::c
[10:27:08.096]             inherits <- base::inherits
[10:27:08.096]             invokeRestart <- base::invokeRestart
[10:27:08.096]             length <- base::length
[10:27:08.096]             list <- base::list
[10:27:08.096]             seq.int <- base::seq.int
[10:27:08.096]             signalCondition <- base::signalCondition
[10:27:08.096]             sys.calls <- base::sys.calls
[10:27:08.096]             `[[` <- base::`[[`
[10:27:08.096]             `+` <- base::`+`
[10:27:08.096]             `<<-` <- base::`<<-`
[10:27:08.096]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:08.096]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:08.096]                   3L)]
[10:27:08.096]             }
[10:27:08.096]             function(cond) {
[10:27:08.096]                 is_error <- inherits(cond, "error")
[10:27:08.096]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:08.096]                   NULL)
[10:27:08.096]                 if (is_error) {
[10:27:08.096]                   sessionInformation <- function() {
[10:27:08.096]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:08.096]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:08.096]                       search = base::search(), system = base::Sys.info())
[10:27:08.096]                   }
[10:27:08.096]                   ...future.conditions[[length(...future.conditions) + 
[10:27:08.096]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:08.096]                     cond$call), session = sessionInformation(), 
[10:27:08.096]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:08.096]                   signalCondition(cond)
[10:27:08.096]                 }
[10:27:08.096]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:08.096]                 "immediateCondition"))) {
[10:27:08.096]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:08.096]                   ...future.conditions[[length(...future.conditions) + 
[10:27:08.096]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:08.096]                   if (TRUE && !signal) {
[10:27:08.096]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:08.096]                     {
[10:27:08.096]                       inherits <- base::inherits
[10:27:08.096]                       invokeRestart <- base::invokeRestart
[10:27:08.096]                       is.null <- base::is.null
[10:27:08.096]                       muffled <- FALSE
[10:27:08.096]                       if (inherits(cond, "message")) {
[10:27:08.096]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:08.096]                         if (muffled) 
[10:27:08.096]                           invokeRestart("muffleMessage")
[10:27:08.096]                       }
[10:27:08.096]                       else if (inherits(cond, "warning")) {
[10:27:08.096]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:08.096]                         if (muffled) 
[10:27:08.096]                           invokeRestart("muffleWarning")
[10:27:08.096]                       }
[10:27:08.096]                       else if (inherits(cond, "condition")) {
[10:27:08.096]                         if (!is.null(pattern)) {
[10:27:08.096]                           computeRestarts <- base::computeRestarts
[10:27:08.096]                           grepl <- base::grepl
[10:27:08.096]                           restarts <- computeRestarts(cond)
[10:27:08.096]                           for (restart in restarts) {
[10:27:08.096]                             name <- restart$name
[10:27:08.096]                             if (is.null(name)) 
[10:27:08.096]                               next
[10:27:08.096]                             if (!grepl(pattern, name)) 
[10:27:08.096]                               next
[10:27:08.096]                             invokeRestart(restart)
[10:27:08.096]                             muffled <- TRUE
[10:27:08.096]                             break
[10:27:08.096]                           }
[10:27:08.096]                         }
[10:27:08.096]                       }
[10:27:08.096]                       invisible(muffled)
[10:27:08.096]                     }
[10:27:08.096]                     muffleCondition(cond, pattern = "^muffle")
[10:27:08.096]                   }
[10:27:08.096]                 }
[10:27:08.096]                 else {
[10:27:08.096]                   if (TRUE) {
[10:27:08.096]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:08.096]                     {
[10:27:08.096]                       inherits <- base::inherits
[10:27:08.096]                       invokeRestart <- base::invokeRestart
[10:27:08.096]                       is.null <- base::is.null
[10:27:08.096]                       muffled <- FALSE
[10:27:08.096]                       if (inherits(cond, "message")) {
[10:27:08.096]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:08.096]                         if (muffled) 
[10:27:08.096]                           invokeRestart("muffleMessage")
[10:27:08.096]                       }
[10:27:08.096]                       else if (inherits(cond, "warning")) {
[10:27:08.096]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:08.096]                         if (muffled) 
[10:27:08.096]                           invokeRestart("muffleWarning")
[10:27:08.096]                       }
[10:27:08.096]                       else if (inherits(cond, "condition")) {
[10:27:08.096]                         if (!is.null(pattern)) {
[10:27:08.096]                           computeRestarts <- base::computeRestarts
[10:27:08.096]                           grepl <- base::grepl
[10:27:08.096]                           restarts <- computeRestarts(cond)
[10:27:08.096]                           for (restart in restarts) {
[10:27:08.096]                             name <- restart$name
[10:27:08.096]                             if (is.null(name)) 
[10:27:08.096]                               next
[10:27:08.096]                             if (!grepl(pattern, name)) 
[10:27:08.096]                               next
[10:27:08.096]                             invokeRestart(restart)
[10:27:08.096]                             muffled <- TRUE
[10:27:08.096]                             break
[10:27:08.096]                           }
[10:27:08.096]                         }
[10:27:08.096]                       }
[10:27:08.096]                       invisible(muffled)
[10:27:08.096]                     }
[10:27:08.096]                     muffleCondition(cond, pattern = "^muffle")
[10:27:08.096]                   }
[10:27:08.096]                 }
[10:27:08.096]             }
[10:27:08.096]         }))
[10:27:08.096]     }, error = function(ex) {
[10:27:08.096]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:08.096]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:08.096]                 ...future.rng), started = ...future.startTime, 
[10:27:08.096]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:08.096]             version = "1.8"), class = "FutureResult")
[10:27:08.096]     }, finally = {
[10:27:08.096]         if (!identical(...future.workdir, getwd())) 
[10:27:08.096]             setwd(...future.workdir)
[10:27:08.096]         {
[10:27:08.096]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:08.096]                 ...future.oldOptions$nwarnings <- NULL
[10:27:08.096]             }
[10:27:08.096]             base::options(...future.oldOptions)
[10:27:08.096]             if (.Platform$OS.type == "windows") {
[10:27:08.096]                 old_names <- names(...future.oldEnvVars)
[10:27:08.096]                 envs <- base::Sys.getenv()
[10:27:08.096]                 names <- names(envs)
[10:27:08.096]                 common <- intersect(names, old_names)
[10:27:08.096]                 added <- setdiff(names, old_names)
[10:27:08.096]                 removed <- setdiff(old_names, names)
[10:27:08.096]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:08.096]                   envs[common]]
[10:27:08.096]                 NAMES <- toupper(changed)
[10:27:08.096]                 args <- list()
[10:27:08.096]                 for (kk in seq_along(NAMES)) {
[10:27:08.096]                   name <- changed[[kk]]
[10:27:08.096]                   NAME <- NAMES[[kk]]
[10:27:08.096]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:08.096]                     next
[10:27:08.096]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:08.096]                 }
[10:27:08.096]                 NAMES <- toupper(added)
[10:27:08.096]                 for (kk in seq_along(NAMES)) {
[10:27:08.096]                   name <- added[[kk]]
[10:27:08.096]                   NAME <- NAMES[[kk]]
[10:27:08.096]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:08.096]                     next
[10:27:08.096]                   args[[name]] <- ""
[10:27:08.096]                 }
[10:27:08.096]                 NAMES <- toupper(removed)
[10:27:08.096]                 for (kk in seq_along(NAMES)) {
[10:27:08.096]                   name <- removed[[kk]]
[10:27:08.096]                   NAME <- NAMES[[kk]]
[10:27:08.096]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:08.096]                     next
[10:27:08.096]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:08.096]                 }
[10:27:08.096]                 if (length(args) > 0) 
[10:27:08.096]                   base::do.call(base::Sys.setenv, args = args)
[10:27:08.096]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:08.096]             }
[10:27:08.096]             else {
[10:27:08.096]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:08.096]             }
[10:27:08.096]             {
[10:27:08.096]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:08.096]                   0L) {
[10:27:08.096]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:08.096]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:08.096]                   base::options(opts)
[10:27:08.096]                 }
[10:27:08.096]                 {
[10:27:08.096]                   {
[10:27:08.096]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:08.096]                     NULL
[10:27:08.096]                   }
[10:27:08.096]                   options(future.plan = NULL)
[10:27:08.096]                   if (is.na(NA_character_)) 
[10:27:08.096]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:08.096]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:08.096]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:08.096]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:08.096]                     envir = parent.frame()) 
[10:27:08.096]                   {
[10:27:08.096]                     if (is.function(workers)) 
[10:27:08.096]                       workers <- workers()
[10:27:08.096]                     workers <- structure(as.integer(workers), 
[10:27:08.096]                       class = class(workers))
[10:27:08.096]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:08.096]                       workers >= 1)
[10:27:08.096]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:08.096]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:08.096]                     }
[10:27:08.096]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:08.096]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:08.096]                       envir = envir)
[10:27:08.096]                     if (!future$lazy) 
[10:27:08.096]                       future <- run(future)
[10:27:08.096]                     invisible(future)
[10:27:08.096]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:08.096]                 }
[10:27:08.096]             }
[10:27:08.096]         }
[10:27:08.096]     })
[10:27:08.096]     if (TRUE) {
[10:27:08.096]         base::sink(type = "output", split = FALSE)
[10:27:08.096]         if (TRUE) {
[10:27:08.096]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:08.096]         }
[10:27:08.096]         else {
[10:27:08.096]             ...future.result["stdout"] <- base::list(NULL)
[10:27:08.096]         }
[10:27:08.096]         base::close(...future.stdout)
[10:27:08.096]         ...future.stdout <- NULL
[10:27:08.096]     }
[10:27:08.096]     ...future.result$conditions <- ...future.conditions
[10:27:08.096]     ...future.result$finished <- base::Sys.time()
[10:27:08.096]     ...future.result
[10:27:08.096] }
[10:27:08.099] MultisessionFuture started
[10:27:08.099] - Launch lazy future ... done
[10:27:08.099] run() for ‘MultisessionFuture’ ... done
[10:27:08.647] receiveMessageFromWorker() for ClusterFuture ...
[10:27:08.648] - Validating connection of MultisessionFuture
[10:27:08.648] - received message: FutureResult
[10:27:08.648] - Received FutureResult
[10:27:08.648] - Erased future from FutureRegistry
[10:27:08.648] result() for ClusterFuture ...
[10:27:08.648] - result already collected: FutureResult
[10:27:08.649] result() for ClusterFuture ... done
[10:27:08.649] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:08.649] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[10:27:08.649] getGlobalsAndPackages() ...
[10:27:08.649] Searching for globals...
[10:27:08.650] - globals found: [2] ‘list’, ‘stop’
[10:27:08.650] Searching for globals ... DONE
[10:27:08.650] Resolving globals: FALSE
[10:27:08.650] 
[10:27:08.651] 
[10:27:08.651] getGlobalsAndPackages() ... DONE
[10:27:08.651] run() for ‘Future’ ...
[10:27:08.651] - state: ‘created’
[10:27:08.651] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:08.667] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:08.668] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:08.668]   - Field: ‘node’
[10:27:08.668]   - Field: ‘label’
[10:27:08.668]   - Field: ‘local’
[10:27:08.668]   - Field: ‘owner’
[10:27:08.668]   - Field: ‘envir’
[10:27:08.668]   - Field: ‘workers’
[10:27:08.668]   - Field: ‘packages’
[10:27:08.668]   - Field: ‘gc’
[10:27:08.669]   - Field: ‘conditions’
[10:27:08.669]   - Field: ‘persistent’
[10:27:08.669]   - Field: ‘expr’
[10:27:08.669]   - Field: ‘uuid’
[10:27:08.669]   - Field: ‘seed’
[10:27:08.669]   - Field: ‘version’
[10:27:08.669]   - Field: ‘result’
[10:27:08.669]   - Field: ‘asynchronous’
[10:27:08.669]   - Field: ‘calls’
[10:27:08.669]   - Field: ‘globals’
[10:27:08.670]   - Field: ‘stdout’
[10:27:08.670]   - Field: ‘earlySignal’
[10:27:08.670]   - Field: ‘lazy’
[10:27:08.670]   - Field: ‘state’
[10:27:08.670] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:08.670] - Launch lazy future ...
[10:27:08.670] Packages needed by the future expression (n = 0): <none>
[10:27:08.670] Packages needed by future strategies (n = 0): <none>
[10:27:08.671] {
[10:27:08.671]     {
[10:27:08.671]         {
[10:27:08.671]             ...future.startTime <- base::Sys.time()
[10:27:08.671]             {
[10:27:08.671]                 {
[10:27:08.671]                   {
[10:27:08.671]                     {
[10:27:08.671]                       base::local({
[10:27:08.671]                         has_future <- base::requireNamespace("future", 
[10:27:08.671]                           quietly = TRUE)
[10:27:08.671]                         if (has_future) {
[10:27:08.671]                           ns <- base::getNamespace("future")
[10:27:08.671]                           version <- ns[[".package"]][["version"]]
[10:27:08.671]                           if (is.null(version)) 
[10:27:08.671]                             version <- utils::packageVersion("future")
[10:27:08.671]                         }
[10:27:08.671]                         else {
[10:27:08.671]                           version <- NULL
[10:27:08.671]                         }
[10:27:08.671]                         if (!has_future || version < "1.8.0") {
[10:27:08.671]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:08.671]                             "", base::R.version$version.string), 
[10:27:08.671]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:08.671]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:08.671]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:08.671]                               "release", "version")], collapse = " "), 
[10:27:08.671]                             hostname = base::Sys.info()[["nodename"]])
[10:27:08.671]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:08.671]                             info)
[10:27:08.671]                           info <- base::paste(info, collapse = "; ")
[10:27:08.671]                           if (!has_future) {
[10:27:08.671]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:08.671]                               info)
[10:27:08.671]                           }
[10:27:08.671]                           else {
[10:27:08.671]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:08.671]                               info, version)
[10:27:08.671]                           }
[10:27:08.671]                           base::stop(msg)
[10:27:08.671]                         }
[10:27:08.671]                       })
[10:27:08.671]                     }
[10:27:08.671]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:08.671]                     base::options(mc.cores = 1L)
[10:27:08.671]                   }
[10:27:08.671]                   options(future.plan = NULL)
[10:27:08.671]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:08.671]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:08.671]                 }
[10:27:08.671]                 ...future.workdir <- getwd()
[10:27:08.671]             }
[10:27:08.671]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:08.671]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:08.671]         }
[10:27:08.671]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:08.671]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:08.671]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:08.671]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:08.671]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:08.671]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:08.671]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:08.671]             base::names(...future.oldOptions))
[10:27:08.671]     }
[10:27:08.671]     if (FALSE) {
[10:27:08.671]     }
[10:27:08.671]     else {
[10:27:08.671]         if (TRUE) {
[10:27:08.671]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:08.671]                 open = "w")
[10:27:08.671]         }
[10:27:08.671]         else {
[10:27:08.671]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:08.671]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:08.671]         }
[10:27:08.671]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:08.671]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:08.671]             base::sink(type = "output", split = FALSE)
[10:27:08.671]             base::close(...future.stdout)
[10:27:08.671]         }, add = TRUE)
[10:27:08.671]     }
[10:27:08.671]     ...future.frame <- base::sys.nframe()
[10:27:08.671]     ...future.conditions <- base::list()
[10:27:08.671]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:08.671]     if (FALSE) {
[10:27:08.671]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:08.671]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:08.671]     }
[10:27:08.671]     ...future.result <- base::tryCatch({
[10:27:08.671]         base::withCallingHandlers({
[10:27:08.671]             ...future.value <- base::withVisible(base::local({
[10:27:08.671]                 ...future.makeSendCondition <- base::local({
[10:27:08.671]                   sendCondition <- NULL
[10:27:08.671]                   function(frame = 1L) {
[10:27:08.671]                     if (is.function(sendCondition)) 
[10:27:08.671]                       return(sendCondition)
[10:27:08.671]                     ns <- getNamespace("parallel")
[10:27:08.671]                     if (exists("sendData", mode = "function", 
[10:27:08.671]                       envir = ns)) {
[10:27:08.671]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:08.671]                         envir = ns)
[10:27:08.671]                       envir <- sys.frame(frame)
[10:27:08.671]                       master <- NULL
[10:27:08.671]                       while (!identical(envir, .GlobalEnv) && 
[10:27:08.671]                         !identical(envir, emptyenv())) {
[10:27:08.671]                         if (exists("master", mode = "list", envir = envir, 
[10:27:08.671]                           inherits = FALSE)) {
[10:27:08.671]                           master <- get("master", mode = "list", 
[10:27:08.671]                             envir = envir, inherits = FALSE)
[10:27:08.671]                           if (inherits(master, c("SOCKnode", 
[10:27:08.671]                             "SOCK0node"))) {
[10:27:08.671]                             sendCondition <<- function(cond) {
[10:27:08.671]                               data <- list(type = "VALUE", value = cond, 
[10:27:08.671]                                 success = TRUE)
[10:27:08.671]                               parallel_sendData(master, data)
[10:27:08.671]                             }
[10:27:08.671]                             return(sendCondition)
[10:27:08.671]                           }
[10:27:08.671]                         }
[10:27:08.671]                         frame <- frame + 1L
[10:27:08.671]                         envir <- sys.frame(frame)
[10:27:08.671]                       }
[10:27:08.671]                     }
[10:27:08.671]                     sendCondition <<- function(cond) NULL
[10:27:08.671]                   }
[10:27:08.671]                 })
[10:27:08.671]                 withCallingHandlers({
[10:27:08.671]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:27:08.671]                 }, immediateCondition = function(cond) {
[10:27:08.671]                   sendCondition <- ...future.makeSendCondition()
[10:27:08.671]                   sendCondition(cond)
[10:27:08.671]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:08.671]                   {
[10:27:08.671]                     inherits <- base::inherits
[10:27:08.671]                     invokeRestart <- base::invokeRestart
[10:27:08.671]                     is.null <- base::is.null
[10:27:08.671]                     muffled <- FALSE
[10:27:08.671]                     if (inherits(cond, "message")) {
[10:27:08.671]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:08.671]                       if (muffled) 
[10:27:08.671]                         invokeRestart("muffleMessage")
[10:27:08.671]                     }
[10:27:08.671]                     else if (inherits(cond, "warning")) {
[10:27:08.671]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:08.671]                       if (muffled) 
[10:27:08.671]                         invokeRestart("muffleWarning")
[10:27:08.671]                     }
[10:27:08.671]                     else if (inherits(cond, "condition")) {
[10:27:08.671]                       if (!is.null(pattern)) {
[10:27:08.671]                         computeRestarts <- base::computeRestarts
[10:27:08.671]                         grepl <- base::grepl
[10:27:08.671]                         restarts <- computeRestarts(cond)
[10:27:08.671]                         for (restart in restarts) {
[10:27:08.671]                           name <- restart$name
[10:27:08.671]                           if (is.null(name)) 
[10:27:08.671]                             next
[10:27:08.671]                           if (!grepl(pattern, name)) 
[10:27:08.671]                             next
[10:27:08.671]                           invokeRestart(restart)
[10:27:08.671]                           muffled <- TRUE
[10:27:08.671]                           break
[10:27:08.671]                         }
[10:27:08.671]                       }
[10:27:08.671]                     }
[10:27:08.671]                     invisible(muffled)
[10:27:08.671]                   }
[10:27:08.671]                   muffleCondition(cond)
[10:27:08.671]                 })
[10:27:08.671]             }))
[10:27:08.671]             future::FutureResult(value = ...future.value$value, 
[10:27:08.671]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:08.671]                   ...future.rng), globalenv = if (FALSE) 
[10:27:08.671]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:08.671]                     ...future.globalenv.names))
[10:27:08.671]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:08.671]         }, condition = base::local({
[10:27:08.671]             c <- base::c
[10:27:08.671]             inherits <- base::inherits
[10:27:08.671]             invokeRestart <- base::invokeRestart
[10:27:08.671]             length <- base::length
[10:27:08.671]             list <- base::list
[10:27:08.671]             seq.int <- base::seq.int
[10:27:08.671]             signalCondition <- base::signalCondition
[10:27:08.671]             sys.calls <- base::sys.calls
[10:27:08.671]             `[[` <- base::`[[`
[10:27:08.671]             `+` <- base::`+`
[10:27:08.671]             `<<-` <- base::`<<-`
[10:27:08.671]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:08.671]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:08.671]                   3L)]
[10:27:08.671]             }
[10:27:08.671]             function(cond) {
[10:27:08.671]                 is_error <- inherits(cond, "error")
[10:27:08.671]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:08.671]                   NULL)
[10:27:08.671]                 if (is_error) {
[10:27:08.671]                   sessionInformation <- function() {
[10:27:08.671]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:08.671]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:08.671]                       search = base::search(), system = base::Sys.info())
[10:27:08.671]                   }
[10:27:08.671]                   ...future.conditions[[length(...future.conditions) + 
[10:27:08.671]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:08.671]                     cond$call), session = sessionInformation(), 
[10:27:08.671]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:08.671]                   signalCondition(cond)
[10:27:08.671]                 }
[10:27:08.671]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:08.671]                 "immediateCondition"))) {
[10:27:08.671]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:08.671]                   ...future.conditions[[length(...future.conditions) + 
[10:27:08.671]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:08.671]                   if (TRUE && !signal) {
[10:27:08.671]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:08.671]                     {
[10:27:08.671]                       inherits <- base::inherits
[10:27:08.671]                       invokeRestart <- base::invokeRestart
[10:27:08.671]                       is.null <- base::is.null
[10:27:08.671]                       muffled <- FALSE
[10:27:08.671]                       if (inherits(cond, "message")) {
[10:27:08.671]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:08.671]                         if (muffled) 
[10:27:08.671]                           invokeRestart("muffleMessage")
[10:27:08.671]                       }
[10:27:08.671]                       else if (inherits(cond, "warning")) {
[10:27:08.671]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:08.671]                         if (muffled) 
[10:27:08.671]                           invokeRestart("muffleWarning")
[10:27:08.671]                       }
[10:27:08.671]                       else if (inherits(cond, "condition")) {
[10:27:08.671]                         if (!is.null(pattern)) {
[10:27:08.671]                           computeRestarts <- base::computeRestarts
[10:27:08.671]                           grepl <- base::grepl
[10:27:08.671]                           restarts <- computeRestarts(cond)
[10:27:08.671]                           for (restart in restarts) {
[10:27:08.671]                             name <- restart$name
[10:27:08.671]                             if (is.null(name)) 
[10:27:08.671]                               next
[10:27:08.671]                             if (!grepl(pattern, name)) 
[10:27:08.671]                               next
[10:27:08.671]                             invokeRestart(restart)
[10:27:08.671]                             muffled <- TRUE
[10:27:08.671]                             break
[10:27:08.671]                           }
[10:27:08.671]                         }
[10:27:08.671]                       }
[10:27:08.671]                       invisible(muffled)
[10:27:08.671]                     }
[10:27:08.671]                     muffleCondition(cond, pattern = "^muffle")
[10:27:08.671]                   }
[10:27:08.671]                 }
[10:27:08.671]                 else {
[10:27:08.671]                   if (TRUE) {
[10:27:08.671]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:08.671]                     {
[10:27:08.671]                       inherits <- base::inherits
[10:27:08.671]                       invokeRestart <- base::invokeRestart
[10:27:08.671]                       is.null <- base::is.null
[10:27:08.671]                       muffled <- FALSE
[10:27:08.671]                       if (inherits(cond, "message")) {
[10:27:08.671]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:08.671]                         if (muffled) 
[10:27:08.671]                           invokeRestart("muffleMessage")
[10:27:08.671]                       }
[10:27:08.671]                       else if (inherits(cond, "warning")) {
[10:27:08.671]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:08.671]                         if (muffled) 
[10:27:08.671]                           invokeRestart("muffleWarning")
[10:27:08.671]                       }
[10:27:08.671]                       else if (inherits(cond, "condition")) {
[10:27:08.671]                         if (!is.null(pattern)) {
[10:27:08.671]                           computeRestarts <- base::computeRestarts
[10:27:08.671]                           grepl <- base::grepl
[10:27:08.671]                           restarts <- computeRestarts(cond)
[10:27:08.671]                           for (restart in restarts) {
[10:27:08.671]                             name <- restart$name
[10:27:08.671]                             if (is.null(name)) 
[10:27:08.671]                               next
[10:27:08.671]                             if (!grepl(pattern, name)) 
[10:27:08.671]                               next
[10:27:08.671]                             invokeRestart(restart)
[10:27:08.671]                             muffled <- TRUE
[10:27:08.671]                             break
[10:27:08.671]                           }
[10:27:08.671]                         }
[10:27:08.671]                       }
[10:27:08.671]                       invisible(muffled)
[10:27:08.671]                     }
[10:27:08.671]                     muffleCondition(cond, pattern = "^muffle")
[10:27:08.671]                   }
[10:27:08.671]                 }
[10:27:08.671]             }
[10:27:08.671]         }))
[10:27:08.671]     }, error = function(ex) {
[10:27:08.671]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:08.671]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:08.671]                 ...future.rng), started = ...future.startTime, 
[10:27:08.671]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:08.671]             version = "1.8"), class = "FutureResult")
[10:27:08.671]     }, finally = {
[10:27:08.671]         if (!identical(...future.workdir, getwd())) 
[10:27:08.671]             setwd(...future.workdir)
[10:27:08.671]         {
[10:27:08.671]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:08.671]                 ...future.oldOptions$nwarnings <- NULL
[10:27:08.671]             }
[10:27:08.671]             base::options(...future.oldOptions)
[10:27:08.671]             if (.Platform$OS.type == "windows") {
[10:27:08.671]                 old_names <- names(...future.oldEnvVars)
[10:27:08.671]                 envs <- base::Sys.getenv()
[10:27:08.671]                 names <- names(envs)
[10:27:08.671]                 common <- intersect(names, old_names)
[10:27:08.671]                 added <- setdiff(names, old_names)
[10:27:08.671]                 removed <- setdiff(old_names, names)
[10:27:08.671]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:08.671]                   envs[common]]
[10:27:08.671]                 NAMES <- toupper(changed)
[10:27:08.671]                 args <- list()
[10:27:08.671]                 for (kk in seq_along(NAMES)) {
[10:27:08.671]                   name <- changed[[kk]]
[10:27:08.671]                   NAME <- NAMES[[kk]]
[10:27:08.671]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:08.671]                     next
[10:27:08.671]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:08.671]                 }
[10:27:08.671]                 NAMES <- toupper(added)
[10:27:08.671]                 for (kk in seq_along(NAMES)) {
[10:27:08.671]                   name <- added[[kk]]
[10:27:08.671]                   NAME <- NAMES[[kk]]
[10:27:08.671]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:08.671]                     next
[10:27:08.671]                   args[[name]] <- ""
[10:27:08.671]                 }
[10:27:08.671]                 NAMES <- toupper(removed)
[10:27:08.671]                 for (kk in seq_along(NAMES)) {
[10:27:08.671]                   name <- removed[[kk]]
[10:27:08.671]                   NAME <- NAMES[[kk]]
[10:27:08.671]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:08.671]                     next
[10:27:08.671]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:08.671]                 }
[10:27:08.671]                 if (length(args) > 0) 
[10:27:08.671]                   base::do.call(base::Sys.setenv, args = args)
[10:27:08.671]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:08.671]             }
[10:27:08.671]             else {
[10:27:08.671]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:08.671]             }
[10:27:08.671]             {
[10:27:08.671]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:08.671]                   0L) {
[10:27:08.671]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:08.671]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:08.671]                   base::options(opts)
[10:27:08.671]                 }
[10:27:08.671]                 {
[10:27:08.671]                   {
[10:27:08.671]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:08.671]                     NULL
[10:27:08.671]                   }
[10:27:08.671]                   options(future.plan = NULL)
[10:27:08.671]                   if (is.na(NA_character_)) 
[10:27:08.671]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:08.671]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:08.671]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:08.671]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:08.671]                     envir = parent.frame()) 
[10:27:08.671]                   {
[10:27:08.671]                     if (is.function(workers)) 
[10:27:08.671]                       workers <- workers()
[10:27:08.671]                     workers <- structure(as.integer(workers), 
[10:27:08.671]                       class = class(workers))
[10:27:08.671]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:08.671]                       workers >= 1)
[10:27:08.671]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:08.671]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:08.671]                     }
[10:27:08.671]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:08.671]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:08.671]                       envir = envir)
[10:27:08.671]                     if (!future$lazy) 
[10:27:08.671]                       future <- run(future)
[10:27:08.671]                     invisible(future)
[10:27:08.671]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:08.671]                 }
[10:27:08.671]             }
[10:27:08.671]         }
[10:27:08.671]     })
[10:27:08.671]     if (TRUE) {
[10:27:08.671]         base::sink(type = "output", split = FALSE)
[10:27:08.671]         if (TRUE) {
[10:27:08.671]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:08.671]         }
[10:27:08.671]         else {
[10:27:08.671]             ...future.result["stdout"] <- base::list(NULL)
[10:27:08.671]         }
[10:27:08.671]         base::close(...future.stdout)
[10:27:08.671]         ...future.stdout <- NULL
[10:27:08.671]     }
[10:27:08.671]     ...future.result$conditions <- ...future.conditions
[10:27:08.671]     ...future.result$finished <- base::Sys.time()
[10:27:08.671]     ...future.result
[10:27:08.671] }
[10:27:08.674] MultisessionFuture started
[10:27:08.674] - Launch lazy future ... done
[10:27:08.674] run() for ‘MultisessionFuture’ ... done
[10:27:08.681] receiveMessageFromWorker() for ClusterFuture ...
[10:27:08.681] - Validating connection of MultisessionFuture
[10:27:08.682] - received message: FutureResult
[10:27:08.682] - Received FutureResult
[10:27:08.682] - Erased future from FutureRegistry
[10:27:08.682] result() for ClusterFuture ...
[10:27:08.682] - result already collected: FutureResult
[10:27:08.682] result() for ClusterFuture ... done
[10:27:08.682] signalConditions() ...
[10:27:08.682]  - include = ‘immediateCondition’
[10:27:08.683]  - exclude = 
[10:27:08.683]  - resignal = FALSE
[10:27:08.683]  - Number of conditions: 1
[10:27:08.683] signalConditions() ... done
[10:27:08.683] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:08.683] A MultisessionFuture was resolved (result was not collected)
[10:27:08.683] getGlobalsAndPackages() ...
[10:27:08.683] Searching for globals...
[10:27:08.684] - globals found: [2] ‘list’, ‘stop’
[10:27:08.684] Searching for globals ... DONE
[10:27:08.684] Resolving globals: FALSE
[10:27:08.685] 
[10:27:08.685] 
[10:27:08.685] getGlobalsAndPackages() ... DONE
[10:27:08.685] run() for ‘Future’ ...
[10:27:08.685] - state: ‘created’
[10:27:08.685] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:08.702] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:08.702] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:08.702]   - Field: ‘node’
[10:27:08.702]   - Field: ‘label’
[10:27:08.702]   - Field: ‘local’
[10:27:08.702]   - Field: ‘owner’
[10:27:08.702]   - Field: ‘envir’
[10:27:08.702]   - Field: ‘workers’
[10:27:08.703]   - Field: ‘packages’
[10:27:08.703]   - Field: ‘gc’
[10:27:08.703]   - Field: ‘conditions’
[10:27:08.703]   - Field: ‘persistent’
[10:27:08.703]   - Field: ‘expr’
[10:27:08.703]   - Field: ‘uuid’
[10:27:08.703]   - Field: ‘seed’
[10:27:08.703]   - Field: ‘version’
[10:27:08.703]   - Field: ‘result’
[10:27:08.703]   - Field: ‘asynchronous’
[10:27:08.704]   - Field: ‘calls’
[10:27:08.704]   - Field: ‘globals’
[10:27:08.704]   - Field: ‘stdout’
[10:27:08.704]   - Field: ‘earlySignal’
[10:27:08.704]   - Field: ‘lazy’
[10:27:08.704]   - Field: ‘state’
[10:27:08.704] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:08.704] - Launch lazy future ...
[10:27:08.705] Packages needed by the future expression (n = 0): <none>
[10:27:08.705] Packages needed by future strategies (n = 0): <none>
[10:27:08.705] {
[10:27:08.705]     {
[10:27:08.705]         {
[10:27:08.705]             ...future.startTime <- base::Sys.time()
[10:27:08.705]             {
[10:27:08.705]                 {
[10:27:08.705]                   {
[10:27:08.705]                     {
[10:27:08.705]                       base::local({
[10:27:08.705]                         has_future <- base::requireNamespace("future", 
[10:27:08.705]                           quietly = TRUE)
[10:27:08.705]                         if (has_future) {
[10:27:08.705]                           ns <- base::getNamespace("future")
[10:27:08.705]                           version <- ns[[".package"]][["version"]]
[10:27:08.705]                           if (is.null(version)) 
[10:27:08.705]                             version <- utils::packageVersion("future")
[10:27:08.705]                         }
[10:27:08.705]                         else {
[10:27:08.705]                           version <- NULL
[10:27:08.705]                         }
[10:27:08.705]                         if (!has_future || version < "1.8.0") {
[10:27:08.705]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:08.705]                             "", base::R.version$version.string), 
[10:27:08.705]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:08.705]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:08.705]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:08.705]                               "release", "version")], collapse = " "), 
[10:27:08.705]                             hostname = base::Sys.info()[["nodename"]])
[10:27:08.705]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:08.705]                             info)
[10:27:08.705]                           info <- base::paste(info, collapse = "; ")
[10:27:08.705]                           if (!has_future) {
[10:27:08.705]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:08.705]                               info)
[10:27:08.705]                           }
[10:27:08.705]                           else {
[10:27:08.705]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:08.705]                               info, version)
[10:27:08.705]                           }
[10:27:08.705]                           base::stop(msg)
[10:27:08.705]                         }
[10:27:08.705]                       })
[10:27:08.705]                     }
[10:27:08.705]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:08.705]                     base::options(mc.cores = 1L)
[10:27:08.705]                   }
[10:27:08.705]                   options(future.plan = NULL)
[10:27:08.705]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:08.705]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:08.705]                 }
[10:27:08.705]                 ...future.workdir <- getwd()
[10:27:08.705]             }
[10:27:08.705]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:08.705]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:08.705]         }
[10:27:08.705]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:08.705]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:08.705]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:08.705]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:08.705]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:08.705]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:08.705]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:08.705]             base::names(...future.oldOptions))
[10:27:08.705]     }
[10:27:08.705]     if (FALSE) {
[10:27:08.705]     }
[10:27:08.705]     else {
[10:27:08.705]         if (TRUE) {
[10:27:08.705]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:08.705]                 open = "w")
[10:27:08.705]         }
[10:27:08.705]         else {
[10:27:08.705]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:08.705]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:08.705]         }
[10:27:08.705]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:08.705]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:08.705]             base::sink(type = "output", split = FALSE)
[10:27:08.705]             base::close(...future.stdout)
[10:27:08.705]         }, add = TRUE)
[10:27:08.705]     }
[10:27:08.705]     ...future.frame <- base::sys.nframe()
[10:27:08.705]     ...future.conditions <- base::list()
[10:27:08.705]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:08.705]     if (FALSE) {
[10:27:08.705]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:08.705]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:08.705]     }
[10:27:08.705]     ...future.result <- base::tryCatch({
[10:27:08.705]         base::withCallingHandlers({
[10:27:08.705]             ...future.value <- base::withVisible(base::local({
[10:27:08.705]                 ...future.makeSendCondition <- base::local({
[10:27:08.705]                   sendCondition <- NULL
[10:27:08.705]                   function(frame = 1L) {
[10:27:08.705]                     if (is.function(sendCondition)) 
[10:27:08.705]                       return(sendCondition)
[10:27:08.705]                     ns <- getNamespace("parallel")
[10:27:08.705]                     if (exists("sendData", mode = "function", 
[10:27:08.705]                       envir = ns)) {
[10:27:08.705]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:08.705]                         envir = ns)
[10:27:08.705]                       envir <- sys.frame(frame)
[10:27:08.705]                       master <- NULL
[10:27:08.705]                       while (!identical(envir, .GlobalEnv) && 
[10:27:08.705]                         !identical(envir, emptyenv())) {
[10:27:08.705]                         if (exists("master", mode = "list", envir = envir, 
[10:27:08.705]                           inherits = FALSE)) {
[10:27:08.705]                           master <- get("master", mode = "list", 
[10:27:08.705]                             envir = envir, inherits = FALSE)
[10:27:08.705]                           if (inherits(master, c("SOCKnode", 
[10:27:08.705]                             "SOCK0node"))) {
[10:27:08.705]                             sendCondition <<- function(cond) {
[10:27:08.705]                               data <- list(type = "VALUE", value = cond, 
[10:27:08.705]                                 success = TRUE)
[10:27:08.705]                               parallel_sendData(master, data)
[10:27:08.705]                             }
[10:27:08.705]                             return(sendCondition)
[10:27:08.705]                           }
[10:27:08.705]                         }
[10:27:08.705]                         frame <- frame + 1L
[10:27:08.705]                         envir <- sys.frame(frame)
[10:27:08.705]                       }
[10:27:08.705]                     }
[10:27:08.705]                     sendCondition <<- function(cond) NULL
[10:27:08.705]                   }
[10:27:08.705]                 })
[10:27:08.705]                 withCallingHandlers({
[10:27:08.705]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:27:08.705]                 }, immediateCondition = function(cond) {
[10:27:08.705]                   sendCondition <- ...future.makeSendCondition()
[10:27:08.705]                   sendCondition(cond)
[10:27:08.705]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:08.705]                   {
[10:27:08.705]                     inherits <- base::inherits
[10:27:08.705]                     invokeRestart <- base::invokeRestart
[10:27:08.705]                     is.null <- base::is.null
[10:27:08.705]                     muffled <- FALSE
[10:27:08.705]                     if (inherits(cond, "message")) {
[10:27:08.705]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:08.705]                       if (muffled) 
[10:27:08.705]                         invokeRestart("muffleMessage")
[10:27:08.705]                     }
[10:27:08.705]                     else if (inherits(cond, "warning")) {
[10:27:08.705]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:08.705]                       if (muffled) 
[10:27:08.705]                         invokeRestart("muffleWarning")
[10:27:08.705]                     }
[10:27:08.705]                     else if (inherits(cond, "condition")) {
[10:27:08.705]                       if (!is.null(pattern)) {
[10:27:08.705]                         computeRestarts <- base::computeRestarts
[10:27:08.705]                         grepl <- base::grepl
[10:27:08.705]                         restarts <- computeRestarts(cond)
[10:27:08.705]                         for (restart in restarts) {
[10:27:08.705]                           name <- restart$name
[10:27:08.705]                           if (is.null(name)) 
[10:27:08.705]                             next
[10:27:08.705]                           if (!grepl(pattern, name)) 
[10:27:08.705]                             next
[10:27:08.705]                           invokeRestart(restart)
[10:27:08.705]                           muffled <- TRUE
[10:27:08.705]                           break
[10:27:08.705]                         }
[10:27:08.705]                       }
[10:27:08.705]                     }
[10:27:08.705]                     invisible(muffled)
[10:27:08.705]                   }
[10:27:08.705]                   muffleCondition(cond)
[10:27:08.705]                 })
[10:27:08.705]             }))
[10:27:08.705]             future::FutureResult(value = ...future.value$value, 
[10:27:08.705]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:08.705]                   ...future.rng), globalenv = if (FALSE) 
[10:27:08.705]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:08.705]                     ...future.globalenv.names))
[10:27:08.705]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:08.705]         }, condition = base::local({
[10:27:08.705]             c <- base::c
[10:27:08.705]             inherits <- base::inherits
[10:27:08.705]             invokeRestart <- base::invokeRestart
[10:27:08.705]             length <- base::length
[10:27:08.705]             list <- base::list
[10:27:08.705]             seq.int <- base::seq.int
[10:27:08.705]             signalCondition <- base::signalCondition
[10:27:08.705]             sys.calls <- base::sys.calls
[10:27:08.705]             `[[` <- base::`[[`
[10:27:08.705]             `+` <- base::`+`
[10:27:08.705]             `<<-` <- base::`<<-`
[10:27:08.705]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:08.705]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:08.705]                   3L)]
[10:27:08.705]             }
[10:27:08.705]             function(cond) {
[10:27:08.705]                 is_error <- inherits(cond, "error")
[10:27:08.705]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:08.705]                   NULL)
[10:27:08.705]                 if (is_error) {
[10:27:08.705]                   sessionInformation <- function() {
[10:27:08.705]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:08.705]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:08.705]                       search = base::search(), system = base::Sys.info())
[10:27:08.705]                   }
[10:27:08.705]                   ...future.conditions[[length(...future.conditions) + 
[10:27:08.705]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:08.705]                     cond$call), session = sessionInformation(), 
[10:27:08.705]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:08.705]                   signalCondition(cond)
[10:27:08.705]                 }
[10:27:08.705]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:08.705]                 "immediateCondition"))) {
[10:27:08.705]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:08.705]                   ...future.conditions[[length(...future.conditions) + 
[10:27:08.705]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:08.705]                   if (TRUE && !signal) {
[10:27:08.705]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:08.705]                     {
[10:27:08.705]                       inherits <- base::inherits
[10:27:08.705]                       invokeRestart <- base::invokeRestart
[10:27:08.705]                       is.null <- base::is.null
[10:27:08.705]                       muffled <- FALSE
[10:27:08.705]                       if (inherits(cond, "message")) {
[10:27:08.705]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:08.705]                         if (muffled) 
[10:27:08.705]                           invokeRestart("muffleMessage")
[10:27:08.705]                       }
[10:27:08.705]                       else if (inherits(cond, "warning")) {
[10:27:08.705]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:08.705]                         if (muffled) 
[10:27:08.705]                           invokeRestart("muffleWarning")
[10:27:08.705]                       }
[10:27:08.705]                       else if (inherits(cond, "condition")) {
[10:27:08.705]                         if (!is.null(pattern)) {
[10:27:08.705]                           computeRestarts <- base::computeRestarts
[10:27:08.705]                           grepl <- base::grepl
[10:27:08.705]                           restarts <- computeRestarts(cond)
[10:27:08.705]                           for (restart in restarts) {
[10:27:08.705]                             name <- restart$name
[10:27:08.705]                             if (is.null(name)) 
[10:27:08.705]                               next
[10:27:08.705]                             if (!grepl(pattern, name)) 
[10:27:08.705]                               next
[10:27:08.705]                             invokeRestart(restart)
[10:27:08.705]                             muffled <- TRUE
[10:27:08.705]                             break
[10:27:08.705]                           }
[10:27:08.705]                         }
[10:27:08.705]                       }
[10:27:08.705]                       invisible(muffled)
[10:27:08.705]                     }
[10:27:08.705]                     muffleCondition(cond, pattern = "^muffle")
[10:27:08.705]                   }
[10:27:08.705]                 }
[10:27:08.705]                 else {
[10:27:08.705]                   if (TRUE) {
[10:27:08.705]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:08.705]                     {
[10:27:08.705]                       inherits <- base::inherits
[10:27:08.705]                       invokeRestart <- base::invokeRestart
[10:27:08.705]                       is.null <- base::is.null
[10:27:08.705]                       muffled <- FALSE
[10:27:08.705]                       if (inherits(cond, "message")) {
[10:27:08.705]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:08.705]                         if (muffled) 
[10:27:08.705]                           invokeRestart("muffleMessage")
[10:27:08.705]                       }
[10:27:08.705]                       else if (inherits(cond, "warning")) {
[10:27:08.705]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:08.705]                         if (muffled) 
[10:27:08.705]                           invokeRestart("muffleWarning")
[10:27:08.705]                       }
[10:27:08.705]                       else if (inherits(cond, "condition")) {
[10:27:08.705]                         if (!is.null(pattern)) {
[10:27:08.705]                           computeRestarts <- base::computeRestarts
[10:27:08.705]                           grepl <- base::grepl
[10:27:08.705]                           restarts <- computeRestarts(cond)
[10:27:08.705]                           for (restart in restarts) {
[10:27:08.705]                             name <- restart$name
[10:27:08.705]                             if (is.null(name)) 
[10:27:08.705]                               next
[10:27:08.705]                             if (!grepl(pattern, name)) 
[10:27:08.705]                               next
[10:27:08.705]                             invokeRestart(restart)
[10:27:08.705]                             muffled <- TRUE
[10:27:08.705]                             break
[10:27:08.705]                           }
[10:27:08.705]                         }
[10:27:08.705]                       }
[10:27:08.705]                       invisible(muffled)
[10:27:08.705]                     }
[10:27:08.705]                     muffleCondition(cond, pattern = "^muffle")
[10:27:08.705]                   }
[10:27:08.705]                 }
[10:27:08.705]             }
[10:27:08.705]         }))
[10:27:08.705]     }, error = function(ex) {
[10:27:08.705]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:08.705]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:08.705]                 ...future.rng), started = ...future.startTime, 
[10:27:08.705]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:08.705]             version = "1.8"), class = "FutureResult")
[10:27:08.705]     }, finally = {
[10:27:08.705]         if (!identical(...future.workdir, getwd())) 
[10:27:08.705]             setwd(...future.workdir)
[10:27:08.705]         {
[10:27:08.705]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:08.705]                 ...future.oldOptions$nwarnings <- NULL
[10:27:08.705]             }
[10:27:08.705]             base::options(...future.oldOptions)
[10:27:08.705]             if (.Platform$OS.type == "windows") {
[10:27:08.705]                 old_names <- names(...future.oldEnvVars)
[10:27:08.705]                 envs <- base::Sys.getenv()
[10:27:08.705]                 names <- names(envs)
[10:27:08.705]                 common <- intersect(names, old_names)
[10:27:08.705]                 added <- setdiff(names, old_names)
[10:27:08.705]                 removed <- setdiff(old_names, names)
[10:27:08.705]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:08.705]                   envs[common]]
[10:27:08.705]                 NAMES <- toupper(changed)
[10:27:08.705]                 args <- list()
[10:27:08.705]                 for (kk in seq_along(NAMES)) {
[10:27:08.705]                   name <- changed[[kk]]
[10:27:08.705]                   NAME <- NAMES[[kk]]
[10:27:08.705]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:08.705]                     next
[10:27:08.705]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:08.705]                 }
[10:27:08.705]                 NAMES <- toupper(added)
[10:27:08.705]                 for (kk in seq_along(NAMES)) {
[10:27:08.705]                   name <- added[[kk]]
[10:27:08.705]                   NAME <- NAMES[[kk]]
[10:27:08.705]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:08.705]                     next
[10:27:08.705]                   args[[name]] <- ""
[10:27:08.705]                 }
[10:27:08.705]                 NAMES <- toupper(removed)
[10:27:08.705]                 for (kk in seq_along(NAMES)) {
[10:27:08.705]                   name <- removed[[kk]]
[10:27:08.705]                   NAME <- NAMES[[kk]]
[10:27:08.705]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:08.705]                     next
[10:27:08.705]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:08.705]                 }
[10:27:08.705]                 if (length(args) > 0) 
[10:27:08.705]                   base::do.call(base::Sys.setenv, args = args)
[10:27:08.705]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:08.705]             }
[10:27:08.705]             else {
[10:27:08.705]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:08.705]             }
[10:27:08.705]             {
[10:27:08.705]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:08.705]                   0L) {
[10:27:08.705]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:08.705]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:08.705]                   base::options(opts)
[10:27:08.705]                 }
[10:27:08.705]                 {
[10:27:08.705]                   {
[10:27:08.705]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:08.705]                     NULL
[10:27:08.705]                   }
[10:27:08.705]                   options(future.plan = NULL)
[10:27:08.705]                   if (is.na(NA_character_)) 
[10:27:08.705]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:08.705]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:08.705]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:08.705]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:08.705]                     envir = parent.frame()) 
[10:27:08.705]                   {
[10:27:08.705]                     if (is.function(workers)) 
[10:27:08.705]                       workers <- workers()
[10:27:08.705]                     workers <- structure(as.integer(workers), 
[10:27:08.705]                       class = class(workers))
[10:27:08.705]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:08.705]                       workers >= 1)
[10:27:08.705]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:08.705]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:08.705]                     }
[10:27:08.705]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:08.705]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:08.705]                       envir = envir)
[10:27:08.705]                     if (!future$lazy) 
[10:27:08.705]                       future <- run(future)
[10:27:08.705]                     invisible(future)
[10:27:08.705]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:08.705]                 }
[10:27:08.705]             }
[10:27:08.705]         }
[10:27:08.705]     })
[10:27:08.705]     if (TRUE) {
[10:27:08.705]         base::sink(type = "output", split = FALSE)
[10:27:08.705]         if (TRUE) {
[10:27:08.705]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:08.705]         }
[10:27:08.705]         else {
[10:27:08.705]             ...future.result["stdout"] <- base::list(NULL)
[10:27:08.705]         }
[10:27:08.705]         base::close(...future.stdout)
[10:27:08.705]         ...future.stdout <- NULL
[10:27:08.705]     }
[10:27:08.705]     ...future.result$conditions <- ...future.conditions
[10:27:08.705]     ...future.result$finished <- base::Sys.time()
[10:27:08.705]     ...future.result
[10:27:08.705] }
[10:27:08.708] MultisessionFuture started
[10:27:08.709] - Launch lazy future ... done
[10:27:08.709] run() for ‘MultisessionFuture’ ... done
[10:27:08.755] receiveMessageFromWorker() for ClusterFuture ...
[10:27:08.755] - Validating connection of MultisessionFuture
[10:27:08.755] - received message: FutureResult
[10:27:08.755] - Received FutureResult
[10:27:08.756] - Erased future from FutureRegistry
[10:27:08.756] result() for ClusterFuture ...
[10:27:08.756] - result already collected: FutureResult
[10:27:08.756] result() for ClusterFuture ... done
[10:27:08.756] signalConditions() ...
[10:27:08.756]  - include = ‘immediateCondition’
[10:27:08.756]  - exclude = 
[10:27:08.756]  - resignal = FALSE
[10:27:08.756]  - Number of conditions: 1
[10:27:08.756] signalConditions() ... done
[10:27:08.756] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:08.757] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 0 ... DONE
- result = FALSE, recursive = 1 ...
[10:27:08.757] getGlobalsAndPackages() ...
[10:27:08.757] Searching for globals...
[10:27:08.758] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:27:08.758] Searching for globals ... DONE
[10:27:08.758] Resolving globals: FALSE
[10:27:08.759] 
[10:27:08.759] 
[10:27:08.759] getGlobalsAndPackages() ... DONE
[10:27:08.759] run() for ‘Future’ ...
[10:27:08.759] - state: ‘created’
[10:27:08.759] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:08.775] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:08.775] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:08.775]   - Field: ‘node’
[10:27:08.775]   - Field: ‘label’
[10:27:08.775]   - Field: ‘local’
[10:27:08.775]   - Field: ‘owner’
[10:27:08.775]   - Field: ‘envir’
[10:27:08.775]   - Field: ‘workers’
[10:27:08.776]   - Field: ‘packages’
[10:27:08.776]   - Field: ‘gc’
[10:27:08.776]   - Field: ‘conditions’
[10:27:08.776]   - Field: ‘persistent’
[10:27:08.776]   - Field: ‘expr’
[10:27:08.776]   - Field: ‘uuid’
[10:27:08.776]   - Field: ‘seed’
[10:27:08.776]   - Field: ‘version’
[10:27:08.776]   - Field: ‘result’
[10:27:08.776]   - Field: ‘asynchronous’
[10:27:08.777]   - Field: ‘calls’
[10:27:08.777]   - Field: ‘globals’
[10:27:08.777]   - Field: ‘stdout’
[10:27:08.777]   - Field: ‘earlySignal’
[10:27:08.777]   - Field: ‘lazy’
[10:27:08.777]   - Field: ‘state’
[10:27:08.777] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:08.777] - Launch lazy future ...
[10:27:08.778] Packages needed by the future expression (n = 0): <none>
[10:27:08.778] Packages needed by future strategies (n = 0): <none>
[10:27:08.778] {
[10:27:08.778]     {
[10:27:08.778]         {
[10:27:08.778]             ...future.startTime <- base::Sys.time()
[10:27:08.778]             {
[10:27:08.778]                 {
[10:27:08.778]                   {
[10:27:08.778]                     {
[10:27:08.778]                       base::local({
[10:27:08.778]                         has_future <- base::requireNamespace("future", 
[10:27:08.778]                           quietly = TRUE)
[10:27:08.778]                         if (has_future) {
[10:27:08.778]                           ns <- base::getNamespace("future")
[10:27:08.778]                           version <- ns[[".package"]][["version"]]
[10:27:08.778]                           if (is.null(version)) 
[10:27:08.778]                             version <- utils::packageVersion("future")
[10:27:08.778]                         }
[10:27:08.778]                         else {
[10:27:08.778]                           version <- NULL
[10:27:08.778]                         }
[10:27:08.778]                         if (!has_future || version < "1.8.0") {
[10:27:08.778]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:08.778]                             "", base::R.version$version.string), 
[10:27:08.778]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:08.778]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:08.778]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:08.778]                               "release", "version")], collapse = " "), 
[10:27:08.778]                             hostname = base::Sys.info()[["nodename"]])
[10:27:08.778]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:08.778]                             info)
[10:27:08.778]                           info <- base::paste(info, collapse = "; ")
[10:27:08.778]                           if (!has_future) {
[10:27:08.778]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:08.778]                               info)
[10:27:08.778]                           }
[10:27:08.778]                           else {
[10:27:08.778]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:08.778]                               info, version)
[10:27:08.778]                           }
[10:27:08.778]                           base::stop(msg)
[10:27:08.778]                         }
[10:27:08.778]                       })
[10:27:08.778]                     }
[10:27:08.778]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:08.778]                     base::options(mc.cores = 1L)
[10:27:08.778]                   }
[10:27:08.778]                   options(future.plan = NULL)
[10:27:08.778]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:08.778]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:08.778]                 }
[10:27:08.778]                 ...future.workdir <- getwd()
[10:27:08.778]             }
[10:27:08.778]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:08.778]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:08.778]         }
[10:27:08.778]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:08.778]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:08.778]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:08.778]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:08.778]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:08.778]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:08.778]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:08.778]             base::names(...future.oldOptions))
[10:27:08.778]     }
[10:27:08.778]     if (FALSE) {
[10:27:08.778]     }
[10:27:08.778]     else {
[10:27:08.778]         if (TRUE) {
[10:27:08.778]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:08.778]                 open = "w")
[10:27:08.778]         }
[10:27:08.778]         else {
[10:27:08.778]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:08.778]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:08.778]         }
[10:27:08.778]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:08.778]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:08.778]             base::sink(type = "output", split = FALSE)
[10:27:08.778]             base::close(...future.stdout)
[10:27:08.778]         }, add = TRUE)
[10:27:08.778]     }
[10:27:08.778]     ...future.frame <- base::sys.nframe()
[10:27:08.778]     ...future.conditions <- base::list()
[10:27:08.778]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:08.778]     if (FALSE) {
[10:27:08.778]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:08.778]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:08.778]     }
[10:27:08.778]     ...future.result <- base::tryCatch({
[10:27:08.778]         base::withCallingHandlers({
[10:27:08.778]             ...future.value <- base::withVisible(base::local({
[10:27:08.778]                 ...future.makeSendCondition <- base::local({
[10:27:08.778]                   sendCondition <- NULL
[10:27:08.778]                   function(frame = 1L) {
[10:27:08.778]                     if (is.function(sendCondition)) 
[10:27:08.778]                       return(sendCondition)
[10:27:08.778]                     ns <- getNamespace("parallel")
[10:27:08.778]                     if (exists("sendData", mode = "function", 
[10:27:08.778]                       envir = ns)) {
[10:27:08.778]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:08.778]                         envir = ns)
[10:27:08.778]                       envir <- sys.frame(frame)
[10:27:08.778]                       master <- NULL
[10:27:08.778]                       while (!identical(envir, .GlobalEnv) && 
[10:27:08.778]                         !identical(envir, emptyenv())) {
[10:27:08.778]                         if (exists("master", mode = "list", envir = envir, 
[10:27:08.778]                           inherits = FALSE)) {
[10:27:08.778]                           master <- get("master", mode = "list", 
[10:27:08.778]                             envir = envir, inherits = FALSE)
[10:27:08.778]                           if (inherits(master, c("SOCKnode", 
[10:27:08.778]                             "SOCK0node"))) {
[10:27:08.778]                             sendCondition <<- function(cond) {
[10:27:08.778]                               data <- list(type = "VALUE", value = cond, 
[10:27:08.778]                                 success = TRUE)
[10:27:08.778]                               parallel_sendData(master, data)
[10:27:08.778]                             }
[10:27:08.778]                             return(sendCondition)
[10:27:08.778]                           }
[10:27:08.778]                         }
[10:27:08.778]                         frame <- frame + 1L
[10:27:08.778]                         envir <- sys.frame(frame)
[10:27:08.778]                       }
[10:27:08.778]                     }
[10:27:08.778]                     sendCondition <<- function(cond) NULL
[10:27:08.778]                   }
[10:27:08.778]                 })
[10:27:08.778]                 withCallingHandlers({
[10:27:08.778]                   {
[10:27:08.778]                     Sys.sleep(0.5)
[10:27:08.778]                     list(a = 1, b = 42L)
[10:27:08.778]                   }
[10:27:08.778]                 }, immediateCondition = function(cond) {
[10:27:08.778]                   sendCondition <- ...future.makeSendCondition()
[10:27:08.778]                   sendCondition(cond)
[10:27:08.778]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:08.778]                   {
[10:27:08.778]                     inherits <- base::inherits
[10:27:08.778]                     invokeRestart <- base::invokeRestart
[10:27:08.778]                     is.null <- base::is.null
[10:27:08.778]                     muffled <- FALSE
[10:27:08.778]                     if (inherits(cond, "message")) {
[10:27:08.778]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:08.778]                       if (muffled) 
[10:27:08.778]                         invokeRestart("muffleMessage")
[10:27:08.778]                     }
[10:27:08.778]                     else if (inherits(cond, "warning")) {
[10:27:08.778]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:08.778]                       if (muffled) 
[10:27:08.778]                         invokeRestart("muffleWarning")
[10:27:08.778]                     }
[10:27:08.778]                     else if (inherits(cond, "condition")) {
[10:27:08.778]                       if (!is.null(pattern)) {
[10:27:08.778]                         computeRestarts <- base::computeRestarts
[10:27:08.778]                         grepl <- base::grepl
[10:27:08.778]                         restarts <- computeRestarts(cond)
[10:27:08.778]                         for (restart in restarts) {
[10:27:08.778]                           name <- restart$name
[10:27:08.778]                           if (is.null(name)) 
[10:27:08.778]                             next
[10:27:08.778]                           if (!grepl(pattern, name)) 
[10:27:08.778]                             next
[10:27:08.778]                           invokeRestart(restart)
[10:27:08.778]                           muffled <- TRUE
[10:27:08.778]                           break
[10:27:08.778]                         }
[10:27:08.778]                       }
[10:27:08.778]                     }
[10:27:08.778]                     invisible(muffled)
[10:27:08.778]                   }
[10:27:08.778]                   muffleCondition(cond)
[10:27:08.778]                 })
[10:27:08.778]             }))
[10:27:08.778]             future::FutureResult(value = ...future.value$value, 
[10:27:08.778]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:08.778]                   ...future.rng), globalenv = if (FALSE) 
[10:27:08.778]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:08.778]                     ...future.globalenv.names))
[10:27:08.778]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:08.778]         }, condition = base::local({
[10:27:08.778]             c <- base::c
[10:27:08.778]             inherits <- base::inherits
[10:27:08.778]             invokeRestart <- base::invokeRestart
[10:27:08.778]             length <- base::length
[10:27:08.778]             list <- base::list
[10:27:08.778]             seq.int <- base::seq.int
[10:27:08.778]             signalCondition <- base::signalCondition
[10:27:08.778]             sys.calls <- base::sys.calls
[10:27:08.778]             `[[` <- base::`[[`
[10:27:08.778]             `+` <- base::`+`
[10:27:08.778]             `<<-` <- base::`<<-`
[10:27:08.778]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:08.778]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:08.778]                   3L)]
[10:27:08.778]             }
[10:27:08.778]             function(cond) {
[10:27:08.778]                 is_error <- inherits(cond, "error")
[10:27:08.778]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:08.778]                   NULL)
[10:27:08.778]                 if (is_error) {
[10:27:08.778]                   sessionInformation <- function() {
[10:27:08.778]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:08.778]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:08.778]                       search = base::search(), system = base::Sys.info())
[10:27:08.778]                   }
[10:27:08.778]                   ...future.conditions[[length(...future.conditions) + 
[10:27:08.778]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:08.778]                     cond$call), session = sessionInformation(), 
[10:27:08.778]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:08.778]                   signalCondition(cond)
[10:27:08.778]                 }
[10:27:08.778]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:08.778]                 "immediateCondition"))) {
[10:27:08.778]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:08.778]                   ...future.conditions[[length(...future.conditions) + 
[10:27:08.778]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:08.778]                   if (TRUE && !signal) {
[10:27:08.778]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:08.778]                     {
[10:27:08.778]                       inherits <- base::inherits
[10:27:08.778]                       invokeRestart <- base::invokeRestart
[10:27:08.778]                       is.null <- base::is.null
[10:27:08.778]                       muffled <- FALSE
[10:27:08.778]                       if (inherits(cond, "message")) {
[10:27:08.778]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:08.778]                         if (muffled) 
[10:27:08.778]                           invokeRestart("muffleMessage")
[10:27:08.778]                       }
[10:27:08.778]                       else if (inherits(cond, "warning")) {
[10:27:08.778]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:08.778]                         if (muffled) 
[10:27:08.778]                           invokeRestart("muffleWarning")
[10:27:08.778]                       }
[10:27:08.778]                       else if (inherits(cond, "condition")) {
[10:27:08.778]                         if (!is.null(pattern)) {
[10:27:08.778]                           computeRestarts <- base::computeRestarts
[10:27:08.778]                           grepl <- base::grepl
[10:27:08.778]                           restarts <- computeRestarts(cond)
[10:27:08.778]                           for (restart in restarts) {
[10:27:08.778]                             name <- restart$name
[10:27:08.778]                             if (is.null(name)) 
[10:27:08.778]                               next
[10:27:08.778]                             if (!grepl(pattern, name)) 
[10:27:08.778]                               next
[10:27:08.778]                             invokeRestart(restart)
[10:27:08.778]                             muffled <- TRUE
[10:27:08.778]                             break
[10:27:08.778]                           }
[10:27:08.778]                         }
[10:27:08.778]                       }
[10:27:08.778]                       invisible(muffled)
[10:27:08.778]                     }
[10:27:08.778]                     muffleCondition(cond, pattern = "^muffle")
[10:27:08.778]                   }
[10:27:08.778]                 }
[10:27:08.778]                 else {
[10:27:08.778]                   if (TRUE) {
[10:27:08.778]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:08.778]                     {
[10:27:08.778]                       inherits <- base::inherits
[10:27:08.778]                       invokeRestart <- base::invokeRestart
[10:27:08.778]                       is.null <- base::is.null
[10:27:08.778]                       muffled <- FALSE
[10:27:08.778]                       if (inherits(cond, "message")) {
[10:27:08.778]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:08.778]                         if (muffled) 
[10:27:08.778]                           invokeRestart("muffleMessage")
[10:27:08.778]                       }
[10:27:08.778]                       else if (inherits(cond, "warning")) {
[10:27:08.778]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:08.778]                         if (muffled) 
[10:27:08.778]                           invokeRestart("muffleWarning")
[10:27:08.778]                       }
[10:27:08.778]                       else if (inherits(cond, "condition")) {
[10:27:08.778]                         if (!is.null(pattern)) {
[10:27:08.778]                           computeRestarts <- base::computeRestarts
[10:27:08.778]                           grepl <- base::grepl
[10:27:08.778]                           restarts <- computeRestarts(cond)
[10:27:08.778]                           for (restart in restarts) {
[10:27:08.778]                             name <- restart$name
[10:27:08.778]                             if (is.null(name)) 
[10:27:08.778]                               next
[10:27:08.778]                             if (!grepl(pattern, name)) 
[10:27:08.778]                               next
[10:27:08.778]                             invokeRestart(restart)
[10:27:08.778]                             muffled <- TRUE
[10:27:08.778]                             break
[10:27:08.778]                           }
[10:27:08.778]                         }
[10:27:08.778]                       }
[10:27:08.778]                       invisible(muffled)
[10:27:08.778]                     }
[10:27:08.778]                     muffleCondition(cond, pattern = "^muffle")
[10:27:08.778]                   }
[10:27:08.778]                 }
[10:27:08.778]             }
[10:27:08.778]         }))
[10:27:08.778]     }, error = function(ex) {
[10:27:08.778]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:08.778]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:08.778]                 ...future.rng), started = ...future.startTime, 
[10:27:08.778]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:08.778]             version = "1.8"), class = "FutureResult")
[10:27:08.778]     }, finally = {
[10:27:08.778]         if (!identical(...future.workdir, getwd())) 
[10:27:08.778]             setwd(...future.workdir)
[10:27:08.778]         {
[10:27:08.778]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:08.778]                 ...future.oldOptions$nwarnings <- NULL
[10:27:08.778]             }
[10:27:08.778]             base::options(...future.oldOptions)
[10:27:08.778]             if (.Platform$OS.type == "windows") {
[10:27:08.778]                 old_names <- names(...future.oldEnvVars)
[10:27:08.778]                 envs <- base::Sys.getenv()
[10:27:08.778]                 names <- names(envs)
[10:27:08.778]                 common <- intersect(names, old_names)
[10:27:08.778]                 added <- setdiff(names, old_names)
[10:27:08.778]                 removed <- setdiff(old_names, names)
[10:27:08.778]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:08.778]                   envs[common]]
[10:27:08.778]                 NAMES <- toupper(changed)
[10:27:08.778]                 args <- list()
[10:27:08.778]                 for (kk in seq_along(NAMES)) {
[10:27:08.778]                   name <- changed[[kk]]
[10:27:08.778]                   NAME <- NAMES[[kk]]
[10:27:08.778]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:08.778]                     next
[10:27:08.778]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:08.778]                 }
[10:27:08.778]                 NAMES <- toupper(added)
[10:27:08.778]                 for (kk in seq_along(NAMES)) {
[10:27:08.778]                   name <- added[[kk]]
[10:27:08.778]                   NAME <- NAMES[[kk]]
[10:27:08.778]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:08.778]                     next
[10:27:08.778]                   args[[name]] <- ""
[10:27:08.778]                 }
[10:27:08.778]                 NAMES <- toupper(removed)
[10:27:08.778]                 for (kk in seq_along(NAMES)) {
[10:27:08.778]                   name <- removed[[kk]]
[10:27:08.778]                   NAME <- NAMES[[kk]]
[10:27:08.778]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:08.778]                     next
[10:27:08.778]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:08.778]                 }
[10:27:08.778]                 if (length(args) > 0) 
[10:27:08.778]                   base::do.call(base::Sys.setenv, args = args)
[10:27:08.778]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:08.778]             }
[10:27:08.778]             else {
[10:27:08.778]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:08.778]             }
[10:27:08.778]             {
[10:27:08.778]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:08.778]                   0L) {
[10:27:08.778]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:08.778]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:08.778]                   base::options(opts)
[10:27:08.778]                 }
[10:27:08.778]                 {
[10:27:08.778]                   {
[10:27:08.778]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:08.778]                     NULL
[10:27:08.778]                   }
[10:27:08.778]                   options(future.plan = NULL)
[10:27:08.778]                   if (is.na(NA_character_)) 
[10:27:08.778]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:08.778]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:08.778]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:08.778]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:08.778]                     envir = parent.frame()) 
[10:27:08.778]                   {
[10:27:08.778]                     if (is.function(workers)) 
[10:27:08.778]                       workers <- workers()
[10:27:08.778]                     workers <- structure(as.integer(workers), 
[10:27:08.778]                       class = class(workers))
[10:27:08.778]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:08.778]                       workers >= 1)
[10:27:08.778]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:08.778]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:08.778]                     }
[10:27:08.778]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:08.778]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:08.778]                       envir = envir)
[10:27:08.778]                     if (!future$lazy) 
[10:27:08.778]                       future <- run(future)
[10:27:08.778]                     invisible(future)
[10:27:08.778]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:08.778]                 }
[10:27:08.778]             }
[10:27:08.778]         }
[10:27:08.778]     })
[10:27:08.778]     if (TRUE) {
[10:27:08.778]         base::sink(type = "output", split = FALSE)
[10:27:08.778]         if (TRUE) {
[10:27:08.778]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:08.778]         }
[10:27:08.778]         else {
[10:27:08.778]             ...future.result["stdout"] <- base::list(NULL)
[10:27:08.778]         }
[10:27:08.778]         base::close(...future.stdout)
[10:27:08.778]         ...future.stdout <- NULL
[10:27:08.778]     }
[10:27:08.778]     ...future.result$conditions <- ...future.conditions
[10:27:08.778]     ...future.result$finished <- base::Sys.time()
[10:27:08.778]     ...future.result
[10:27:08.778] }
[10:27:08.781] MultisessionFuture started
[10:27:08.782] - Launch lazy future ... done
[10:27:08.782] run() for ‘MultisessionFuture’ ... done
[10:27:09.327] receiveMessageFromWorker() for ClusterFuture ...
[10:27:09.328] - Validating connection of MultisessionFuture
[10:27:09.328] - received message: FutureResult
[10:27:09.328] - Received FutureResult
[10:27:09.328] - Erased future from FutureRegistry
[10:27:09.328] result() for ClusterFuture ...
[10:27:09.328] - result already collected: FutureResult
[10:27:09.328] result() for ClusterFuture ... done
[10:27:09.328] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:09.329] A MultisessionFuture was resolved (result was not collected)
[10:27:09.329] getGlobalsAndPackages() ...
[10:27:09.329] Searching for globals...
[10:27:09.330] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:27:09.330] Searching for globals ... DONE
[10:27:09.330] Resolving globals: FALSE
[10:27:09.331] 
[10:27:09.331] 
[10:27:09.331] getGlobalsAndPackages() ... DONE
[10:27:09.331] run() for ‘Future’ ...
[10:27:09.331] - state: ‘created’
[10:27:09.331] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:09.345] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:09.345] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:09.345]   - Field: ‘node’
[10:27:09.346]   - Field: ‘label’
[10:27:09.346]   - Field: ‘local’
[10:27:09.346]   - Field: ‘owner’
[10:27:09.346]   - Field: ‘envir’
[10:27:09.346]   - Field: ‘workers’
[10:27:09.346]   - Field: ‘packages’
[10:27:09.346]   - Field: ‘gc’
[10:27:09.346]   - Field: ‘conditions’
[10:27:09.346]   - Field: ‘persistent’
[10:27:09.346]   - Field: ‘expr’
[10:27:09.346]   - Field: ‘uuid’
[10:27:09.347]   - Field: ‘seed’
[10:27:09.347]   - Field: ‘version’
[10:27:09.347]   - Field: ‘result’
[10:27:09.347]   - Field: ‘asynchronous’
[10:27:09.347]   - Field: ‘calls’
[10:27:09.347]   - Field: ‘globals’
[10:27:09.347]   - Field: ‘stdout’
[10:27:09.347]   - Field: ‘earlySignal’
[10:27:09.347]   - Field: ‘lazy’
[10:27:09.347]   - Field: ‘state’
[10:27:09.347] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:09.348] - Launch lazy future ...
[10:27:09.348] Packages needed by the future expression (n = 0): <none>
[10:27:09.348] Packages needed by future strategies (n = 0): <none>
[10:27:09.348] {
[10:27:09.348]     {
[10:27:09.348]         {
[10:27:09.348]             ...future.startTime <- base::Sys.time()
[10:27:09.348]             {
[10:27:09.348]                 {
[10:27:09.348]                   {
[10:27:09.348]                     {
[10:27:09.348]                       base::local({
[10:27:09.348]                         has_future <- base::requireNamespace("future", 
[10:27:09.348]                           quietly = TRUE)
[10:27:09.348]                         if (has_future) {
[10:27:09.348]                           ns <- base::getNamespace("future")
[10:27:09.348]                           version <- ns[[".package"]][["version"]]
[10:27:09.348]                           if (is.null(version)) 
[10:27:09.348]                             version <- utils::packageVersion("future")
[10:27:09.348]                         }
[10:27:09.348]                         else {
[10:27:09.348]                           version <- NULL
[10:27:09.348]                         }
[10:27:09.348]                         if (!has_future || version < "1.8.0") {
[10:27:09.348]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:09.348]                             "", base::R.version$version.string), 
[10:27:09.348]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:09.348]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:09.348]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:09.348]                               "release", "version")], collapse = " "), 
[10:27:09.348]                             hostname = base::Sys.info()[["nodename"]])
[10:27:09.348]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:09.348]                             info)
[10:27:09.348]                           info <- base::paste(info, collapse = "; ")
[10:27:09.348]                           if (!has_future) {
[10:27:09.348]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:09.348]                               info)
[10:27:09.348]                           }
[10:27:09.348]                           else {
[10:27:09.348]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:09.348]                               info, version)
[10:27:09.348]                           }
[10:27:09.348]                           base::stop(msg)
[10:27:09.348]                         }
[10:27:09.348]                       })
[10:27:09.348]                     }
[10:27:09.348]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:09.348]                     base::options(mc.cores = 1L)
[10:27:09.348]                   }
[10:27:09.348]                   options(future.plan = NULL)
[10:27:09.348]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:09.348]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:09.348]                 }
[10:27:09.348]                 ...future.workdir <- getwd()
[10:27:09.348]             }
[10:27:09.348]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:09.348]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:09.348]         }
[10:27:09.348]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:09.348]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:09.348]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:09.348]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:09.348]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:09.348]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:09.348]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:09.348]             base::names(...future.oldOptions))
[10:27:09.348]     }
[10:27:09.348]     if (FALSE) {
[10:27:09.348]     }
[10:27:09.348]     else {
[10:27:09.348]         if (TRUE) {
[10:27:09.348]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:09.348]                 open = "w")
[10:27:09.348]         }
[10:27:09.348]         else {
[10:27:09.348]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:09.348]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:09.348]         }
[10:27:09.348]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:09.348]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:09.348]             base::sink(type = "output", split = FALSE)
[10:27:09.348]             base::close(...future.stdout)
[10:27:09.348]         }, add = TRUE)
[10:27:09.348]     }
[10:27:09.348]     ...future.frame <- base::sys.nframe()
[10:27:09.348]     ...future.conditions <- base::list()
[10:27:09.348]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:09.348]     if (FALSE) {
[10:27:09.348]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:09.348]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:09.348]     }
[10:27:09.348]     ...future.result <- base::tryCatch({
[10:27:09.348]         base::withCallingHandlers({
[10:27:09.348]             ...future.value <- base::withVisible(base::local({
[10:27:09.348]                 ...future.makeSendCondition <- base::local({
[10:27:09.348]                   sendCondition <- NULL
[10:27:09.348]                   function(frame = 1L) {
[10:27:09.348]                     if (is.function(sendCondition)) 
[10:27:09.348]                       return(sendCondition)
[10:27:09.348]                     ns <- getNamespace("parallel")
[10:27:09.348]                     if (exists("sendData", mode = "function", 
[10:27:09.348]                       envir = ns)) {
[10:27:09.348]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:09.348]                         envir = ns)
[10:27:09.348]                       envir <- sys.frame(frame)
[10:27:09.348]                       master <- NULL
[10:27:09.348]                       while (!identical(envir, .GlobalEnv) && 
[10:27:09.348]                         !identical(envir, emptyenv())) {
[10:27:09.348]                         if (exists("master", mode = "list", envir = envir, 
[10:27:09.348]                           inherits = FALSE)) {
[10:27:09.348]                           master <- get("master", mode = "list", 
[10:27:09.348]                             envir = envir, inherits = FALSE)
[10:27:09.348]                           if (inherits(master, c("SOCKnode", 
[10:27:09.348]                             "SOCK0node"))) {
[10:27:09.348]                             sendCondition <<- function(cond) {
[10:27:09.348]                               data <- list(type = "VALUE", value = cond, 
[10:27:09.348]                                 success = TRUE)
[10:27:09.348]                               parallel_sendData(master, data)
[10:27:09.348]                             }
[10:27:09.348]                             return(sendCondition)
[10:27:09.348]                           }
[10:27:09.348]                         }
[10:27:09.348]                         frame <- frame + 1L
[10:27:09.348]                         envir <- sys.frame(frame)
[10:27:09.348]                       }
[10:27:09.348]                     }
[10:27:09.348]                     sendCondition <<- function(cond) NULL
[10:27:09.348]                   }
[10:27:09.348]                 })
[10:27:09.348]                 withCallingHandlers({
[10:27:09.348]                   {
[10:27:09.348]                     Sys.sleep(0.5)
[10:27:09.348]                     list(a = 1, b = 42L)
[10:27:09.348]                   }
[10:27:09.348]                 }, immediateCondition = function(cond) {
[10:27:09.348]                   sendCondition <- ...future.makeSendCondition()
[10:27:09.348]                   sendCondition(cond)
[10:27:09.348]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:09.348]                   {
[10:27:09.348]                     inherits <- base::inherits
[10:27:09.348]                     invokeRestart <- base::invokeRestart
[10:27:09.348]                     is.null <- base::is.null
[10:27:09.348]                     muffled <- FALSE
[10:27:09.348]                     if (inherits(cond, "message")) {
[10:27:09.348]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:09.348]                       if (muffled) 
[10:27:09.348]                         invokeRestart("muffleMessage")
[10:27:09.348]                     }
[10:27:09.348]                     else if (inherits(cond, "warning")) {
[10:27:09.348]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:09.348]                       if (muffled) 
[10:27:09.348]                         invokeRestart("muffleWarning")
[10:27:09.348]                     }
[10:27:09.348]                     else if (inherits(cond, "condition")) {
[10:27:09.348]                       if (!is.null(pattern)) {
[10:27:09.348]                         computeRestarts <- base::computeRestarts
[10:27:09.348]                         grepl <- base::grepl
[10:27:09.348]                         restarts <- computeRestarts(cond)
[10:27:09.348]                         for (restart in restarts) {
[10:27:09.348]                           name <- restart$name
[10:27:09.348]                           if (is.null(name)) 
[10:27:09.348]                             next
[10:27:09.348]                           if (!grepl(pattern, name)) 
[10:27:09.348]                             next
[10:27:09.348]                           invokeRestart(restart)
[10:27:09.348]                           muffled <- TRUE
[10:27:09.348]                           break
[10:27:09.348]                         }
[10:27:09.348]                       }
[10:27:09.348]                     }
[10:27:09.348]                     invisible(muffled)
[10:27:09.348]                   }
[10:27:09.348]                   muffleCondition(cond)
[10:27:09.348]                 })
[10:27:09.348]             }))
[10:27:09.348]             future::FutureResult(value = ...future.value$value, 
[10:27:09.348]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:09.348]                   ...future.rng), globalenv = if (FALSE) 
[10:27:09.348]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:09.348]                     ...future.globalenv.names))
[10:27:09.348]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:09.348]         }, condition = base::local({
[10:27:09.348]             c <- base::c
[10:27:09.348]             inherits <- base::inherits
[10:27:09.348]             invokeRestart <- base::invokeRestart
[10:27:09.348]             length <- base::length
[10:27:09.348]             list <- base::list
[10:27:09.348]             seq.int <- base::seq.int
[10:27:09.348]             signalCondition <- base::signalCondition
[10:27:09.348]             sys.calls <- base::sys.calls
[10:27:09.348]             `[[` <- base::`[[`
[10:27:09.348]             `+` <- base::`+`
[10:27:09.348]             `<<-` <- base::`<<-`
[10:27:09.348]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:09.348]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:09.348]                   3L)]
[10:27:09.348]             }
[10:27:09.348]             function(cond) {
[10:27:09.348]                 is_error <- inherits(cond, "error")
[10:27:09.348]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:09.348]                   NULL)
[10:27:09.348]                 if (is_error) {
[10:27:09.348]                   sessionInformation <- function() {
[10:27:09.348]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:09.348]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:09.348]                       search = base::search(), system = base::Sys.info())
[10:27:09.348]                   }
[10:27:09.348]                   ...future.conditions[[length(...future.conditions) + 
[10:27:09.348]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:09.348]                     cond$call), session = sessionInformation(), 
[10:27:09.348]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:09.348]                   signalCondition(cond)
[10:27:09.348]                 }
[10:27:09.348]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:09.348]                 "immediateCondition"))) {
[10:27:09.348]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:09.348]                   ...future.conditions[[length(...future.conditions) + 
[10:27:09.348]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:09.348]                   if (TRUE && !signal) {
[10:27:09.348]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:09.348]                     {
[10:27:09.348]                       inherits <- base::inherits
[10:27:09.348]                       invokeRestart <- base::invokeRestart
[10:27:09.348]                       is.null <- base::is.null
[10:27:09.348]                       muffled <- FALSE
[10:27:09.348]                       if (inherits(cond, "message")) {
[10:27:09.348]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:09.348]                         if (muffled) 
[10:27:09.348]                           invokeRestart("muffleMessage")
[10:27:09.348]                       }
[10:27:09.348]                       else if (inherits(cond, "warning")) {
[10:27:09.348]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:09.348]                         if (muffled) 
[10:27:09.348]                           invokeRestart("muffleWarning")
[10:27:09.348]                       }
[10:27:09.348]                       else if (inherits(cond, "condition")) {
[10:27:09.348]                         if (!is.null(pattern)) {
[10:27:09.348]                           computeRestarts <- base::computeRestarts
[10:27:09.348]                           grepl <- base::grepl
[10:27:09.348]                           restarts <- computeRestarts(cond)
[10:27:09.348]                           for (restart in restarts) {
[10:27:09.348]                             name <- restart$name
[10:27:09.348]                             if (is.null(name)) 
[10:27:09.348]                               next
[10:27:09.348]                             if (!grepl(pattern, name)) 
[10:27:09.348]                               next
[10:27:09.348]                             invokeRestart(restart)
[10:27:09.348]                             muffled <- TRUE
[10:27:09.348]                             break
[10:27:09.348]                           }
[10:27:09.348]                         }
[10:27:09.348]                       }
[10:27:09.348]                       invisible(muffled)
[10:27:09.348]                     }
[10:27:09.348]                     muffleCondition(cond, pattern = "^muffle")
[10:27:09.348]                   }
[10:27:09.348]                 }
[10:27:09.348]                 else {
[10:27:09.348]                   if (TRUE) {
[10:27:09.348]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:09.348]                     {
[10:27:09.348]                       inherits <- base::inherits
[10:27:09.348]                       invokeRestart <- base::invokeRestart
[10:27:09.348]                       is.null <- base::is.null
[10:27:09.348]                       muffled <- FALSE
[10:27:09.348]                       if (inherits(cond, "message")) {
[10:27:09.348]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:09.348]                         if (muffled) 
[10:27:09.348]                           invokeRestart("muffleMessage")
[10:27:09.348]                       }
[10:27:09.348]                       else if (inherits(cond, "warning")) {
[10:27:09.348]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:09.348]                         if (muffled) 
[10:27:09.348]                           invokeRestart("muffleWarning")
[10:27:09.348]                       }
[10:27:09.348]                       else if (inherits(cond, "condition")) {
[10:27:09.348]                         if (!is.null(pattern)) {
[10:27:09.348]                           computeRestarts <- base::computeRestarts
[10:27:09.348]                           grepl <- base::grepl
[10:27:09.348]                           restarts <- computeRestarts(cond)
[10:27:09.348]                           for (restart in restarts) {
[10:27:09.348]                             name <- restart$name
[10:27:09.348]                             if (is.null(name)) 
[10:27:09.348]                               next
[10:27:09.348]                             if (!grepl(pattern, name)) 
[10:27:09.348]                               next
[10:27:09.348]                             invokeRestart(restart)
[10:27:09.348]                             muffled <- TRUE
[10:27:09.348]                             break
[10:27:09.348]                           }
[10:27:09.348]                         }
[10:27:09.348]                       }
[10:27:09.348]                       invisible(muffled)
[10:27:09.348]                     }
[10:27:09.348]                     muffleCondition(cond, pattern = "^muffle")
[10:27:09.348]                   }
[10:27:09.348]                 }
[10:27:09.348]             }
[10:27:09.348]         }))
[10:27:09.348]     }, error = function(ex) {
[10:27:09.348]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:09.348]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:09.348]                 ...future.rng), started = ...future.startTime, 
[10:27:09.348]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:09.348]             version = "1.8"), class = "FutureResult")
[10:27:09.348]     }, finally = {
[10:27:09.348]         if (!identical(...future.workdir, getwd())) 
[10:27:09.348]             setwd(...future.workdir)
[10:27:09.348]         {
[10:27:09.348]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:09.348]                 ...future.oldOptions$nwarnings <- NULL
[10:27:09.348]             }
[10:27:09.348]             base::options(...future.oldOptions)
[10:27:09.348]             if (.Platform$OS.type == "windows") {
[10:27:09.348]                 old_names <- names(...future.oldEnvVars)
[10:27:09.348]                 envs <- base::Sys.getenv()
[10:27:09.348]                 names <- names(envs)
[10:27:09.348]                 common <- intersect(names, old_names)
[10:27:09.348]                 added <- setdiff(names, old_names)
[10:27:09.348]                 removed <- setdiff(old_names, names)
[10:27:09.348]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:09.348]                   envs[common]]
[10:27:09.348]                 NAMES <- toupper(changed)
[10:27:09.348]                 args <- list()
[10:27:09.348]                 for (kk in seq_along(NAMES)) {
[10:27:09.348]                   name <- changed[[kk]]
[10:27:09.348]                   NAME <- NAMES[[kk]]
[10:27:09.348]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:09.348]                     next
[10:27:09.348]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:09.348]                 }
[10:27:09.348]                 NAMES <- toupper(added)
[10:27:09.348]                 for (kk in seq_along(NAMES)) {
[10:27:09.348]                   name <- added[[kk]]
[10:27:09.348]                   NAME <- NAMES[[kk]]
[10:27:09.348]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:09.348]                     next
[10:27:09.348]                   args[[name]] <- ""
[10:27:09.348]                 }
[10:27:09.348]                 NAMES <- toupper(removed)
[10:27:09.348]                 for (kk in seq_along(NAMES)) {
[10:27:09.348]                   name <- removed[[kk]]
[10:27:09.348]                   NAME <- NAMES[[kk]]
[10:27:09.348]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:09.348]                     next
[10:27:09.348]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:09.348]                 }
[10:27:09.348]                 if (length(args) > 0) 
[10:27:09.348]                   base::do.call(base::Sys.setenv, args = args)
[10:27:09.348]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:09.348]             }
[10:27:09.348]             else {
[10:27:09.348]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:09.348]             }
[10:27:09.348]             {
[10:27:09.348]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:09.348]                   0L) {
[10:27:09.348]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:09.348]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:09.348]                   base::options(opts)
[10:27:09.348]                 }
[10:27:09.348]                 {
[10:27:09.348]                   {
[10:27:09.348]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:09.348]                     NULL
[10:27:09.348]                   }
[10:27:09.348]                   options(future.plan = NULL)
[10:27:09.348]                   if (is.na(NA_character_)) 
[10:27:09.348]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:09.348]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:09.348]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:09.348]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:09.348]                     envir = parent.frame()) 
[10:27:09.348]                   {
[10:27:09.348]                     if (is.function(workers)) 
[10:27:09.348]                       workers <- workers()
[10:27:09.348]                     workers <- structure(as.integer(workers), 
[10:27:09.348]                       class = class(workers))
[10:27:09.348]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:09.348]                       workers >= 1)
[10:27:09.348]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:09.348]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:09.348]                     }
[10:27:09.348]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:09.348]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:09.348]                       envir = envir)
[10:27:09.348]                     if (!future$lazy) 
[10:27:09.348]                       future <- run(future)
[10:27:09.348]                     invisible(future)
[10:27:09.348]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:09.348]                 }
[10:27:09.348]             }
[10:27:09.348]         }
[10:27:09.348]     })
[10:27:09.348]     if (TRUE) {
[10:27:09.348]         base::sink(type = "output", split = FALSE)
[10:27:09.348]         if (TRUE) {
[10:27:09.348]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:09.348]         }
[10:27:09.348]         else {
[10:27:09.348]             ...future.result["stdout"] <- base::list(NULL)
[10:27:09.348]         }
[10:27:09.348]         base::close(...future.stdout)
[10:27:09.348]         ...future.stdout <- NULL
[10:27:09.348]     }
[10:27:09.348]     ...future.result$conditions <- ...future.conditions
[10:27:09.348]     ...future.result$finished <- base::Sys.time()
[10:27:09.348]     ...future.result
[10:27:09.348] }
[10:27:09.352] MultisessionFuture started
[10:27:09.352] - Launch lazy future ... done
[10:27:09.352] run() for ‘MultisessionFuture’ ... done
[10:27:09.899] receiveMessageFromWorker() for ClusterFuture ...
[10:27:09.900] - Validating connection of MultisessionFuture
[10:27:09.900] - received message: FutureResult
[10:27:09.900] - Received FutureResult
[10:27:09.900] - Erased future from FutureRegistry
[10:27:09.900] result() for ClusterFuture ...
[10:27:09.900] - result already collected: FutureResult
[10:27:09.900] result() for ClusterFuture ... done
[10:27:09.901] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:09.901] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[10:27:09.901] getGlobalsAndPackages() ...
[10:27:09.901] Searching for globals...
[10:27:09.902] - globals found: [2] ‘list’, ‘stop’
[10:27:09.902] Searching for globals ... DONE
[10:27:09.902] Resolving globals: FALSE
[10:27:09.902] 
[10:27:09.902] 
[10:27:09.902] getGlobalsAndPackages() ... DONE
[10:27:09.903] run() for ‘Future’ ...
[10:27:09.903] - state: ‘created’
[10:27:09.903] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:09.917] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:09.917] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:09.917]   - Field: ‘node’
[10:27:09.917]   - Field: ‘label’
[10:27:09.918]   - Field: ‘local’
[10:27:09.918]   - Field: ‘owner’
[10:27:09.918]   - Field: ‘envir’
[10:27:09.918]   - Field: ‘workers’
[10:27:09.918]   - Field: ‘packages’
[10:27:09.918]   - Field: ‘gc’
[10:27:09.918]   - Field: ‘conditions’
[10:27:09.918]   - Field: ‘persistent’
[10:27:09.918]   - Field: ‘expr’
[10:27:09.918]   - Field: ‘uuid’
[10:27:09.918]   - Field: ‘seed’
[10:27:09.919]   - Field: ‘version’
[10:27:09.919]   - Field: ‘result’
[10:27:09.919]   - Field: ‘asynchronous’
[10:27:09.919]   - Field: ‘calls’
[10:27:09.919]   - Field: ‘globals’
[10:27:09.919]   - Field: ‘stdout’
[10:27:09.919]   - Field: ‘earlySignal’
[10:27:09.919]   - Field: ‘lazy’
[10:27:09.919]   - Field: ‘state’
[10:27:09.919] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:09.919] - Launch lazy future ...
[10:27:09.920] Packages needed by the future expression (n = 0): <none>
[10:27:09.920] Packages needed by future strategies (n = 0): <none>
[10:27:09.920] {
[10:27:09.920]     {
[10:27:09.920]         {
[10:27:09.920]             ...future.startTime <- base::Sys.time()
[10:27:09.920]             {
[10:27:09.920]                 {
[10:27:09.920]                   {
[10:27:09.920]                     {
[10:27:09.920]                       base::local({
[10:27:09.920]                         has_future <- base::requireNamespace("future", 
[10:27:09.920]                           quietly = TRUE)
[10:27:09.920]                         if (has_future) {
[10:27:09.920]                           ns <- base::getNamespace("future")
[10:27:09.920]                           version <- ns[[".package"]][["version"]]
[10:27:09.920]                           if (is.null(version)) 
[10:27:09.920]                             version <- utils::packageVersion("future")
[10:27:09.920]                         }
[10:27:09.920]                         else {
[10:27:09.920]                           version <- NULL
[10:27:09.920]                         }
[10:27:09.920]                         if (!has_future || version < "1.8.0") {
[10:27:09.920]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:09.920]                             "", base::R.version$version.string), 
[10:27:09.920]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:09.920]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:09.920]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:09.920]                               "release", "version")], collapse = " "), 
[10:27:09.920]                             hostname = base::Sys.info()[["nodename"]])
[10:27:09.920]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:09.920]                             info)
[10:27:09.920]                           info <- base::paste(info, collapse = "; ")
[10:27:09.920]                           if (!has_future) {
[10:27:09.920]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:09.920]                               info)
[10:27:09.920]                           }
[10:27:09.920]                           else {
[10:27:09.920]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:09.920]                               info, version)
[10:27:09.920]                           }
[10:27:09.920]                           base::stop(msg)
[10:27:09.920]                         }
[10:27:09.920]                       })
[10:27:09.920]                     }
[10:27:09.920]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:09.920]                     base::options(mc.cores = 1L)
[10:27:09.920]                   }
[10:27:09.920]                   options(future.plan = NULL)
[10:27:09.920]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:09.920]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:09.920]                 }
[10:27:09.920]                 ...future.workdir <- getwd()
[10:27:09.920]             }
[10:27:09.920]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:09.920]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:09.920]         }
[10:27:09.920]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:09.920]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:09.920]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:09.920]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:09.920]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:09.920]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:09.920]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:09.920]             base::names(...future.oldOptions))
[10:27:09.920]     }
[10:27:09.920]     if (FALSE) {
[10:27:09.920]     }
[10:27:09.920]     else {
[10:27:09.920]         if (TRUE) {
[10:27:09.920]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:09.920]                 open = "w")
[10:27:09.920]         }
[10:27:09.920]         else {
[10:27:09.920]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:09.920]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:09.920]         }
[10:27:09.920]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:09.920]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:09.920]             base::sink(type = "output", split = FALSE)
[10:27:09.920]             base::close(...future.stdout)
[10:27:09.920]         }, add = TRUE)
[10:27:09.920]     }
[10:27:09.920]     ...future.frame <- base::sys.nframe()
[10:27:09.920]     ...future.conditions <- base::list()
[10:27:09.920]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:09.920]     if (FALSE) {
[10:27:09.920]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:09.920]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:09.920]     }
[10:27:09.920]     ...future.result <- base::tryCatch({
[10:27:09.920]         base::withCallingHandlers({
[10:27:09.920]             ...future.value <- base::withVisible(base::local({
[10:27:09.920]                 ...future.makeSendCondition <- base::local({
[10:27:09.920]                   sendCondition <- NULL
[10:27:09.920]                   function(frame = 1L) {
[10:27:09.920]                     if (is.function(sendCondition)) 
[10:27:09.920]                       return(sendCondition)
[10:27:09.920]                     ns <- getNamespace("parallel")
[10:27:09.920]                     if (exists("sendData", mode = "function", 
[10:27:09.920]                       envir = ns)) {
[10:27:09.920]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:09.920]                         envir = ns)
[10:27:09.920]                       envir <- sys.frame(frame)
[10:27:09.920]                       master <- NULL
[10:27:09.920]                       while (!identical(envir, .GlobalEnv) && 
[10:27:09.920]                         !identical(envir, emptyenv())) {
[10:27:09.920]                         if (exists("master", mode = "list", envir = envir, 
[10:27:09.920]                           inherits = FALSE)) {
[10:27:09.920]                           master <- get("master", mode = "list", 
[10:27:09.920]                             envir = envir, inherits = FALSE)
[10:27:09.920]                           if (inherits(master, c("SOCKnode", 
[10:27:09.920]                             "SOCK0node"))) {
[10:27:09.920]                             sendCondition <<- function(cond) {
[10:27:09.920]                               data <- list(type = "VALUE", value = cond, 
[10:27:09.920]                                 success = TRUE)
[10:27:09.920]                               parallel_sendData(master, data)
[10:27:09.920]                             }
[10:27:09.920]                             return(sendCondition)
[10:27:09.920]                           }
[10:27:09.920]                         }
[10:27:09.920]                         frame <- frame + 1L
[10:27:09.920]                         envir <- sys.frame(frame)
[10:27:09.920]                       }
[10:27:09.920]                     }
[10:27:09.920]                     sendCondition <<- function(cond) NULL
[10:27:09.920]                   }
[10:27:09.920]                 })
[10:27:09.920]                 withCallingHandlers({
[10:27:09.920]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:27:09.920]                 }, immediateCondition = function(cond) {
[10:27:09.920]                   sendCondition <- ...future.makeSendCondition()
[10:27:09.920]                   sendCondition(cond)
[10:27:09.920]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:09.920]                   {
[10:27:09.920]                     inherits <- base::inherits
[10:27:09.920]                     invokeRestart <- base::invokeRestart
[10:27:09.920]                     is.null <- base::is.null
[10:27:09.920]                     muffled <- FALSE
[10:27:09.920]                     if (inherits(cond, "message")) {
[10:27:09.920]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:09.920]                       if (muffled) 
[10:27:09.920]                         invokeRestart("muffleMessage")
[10:27:09.920]                     }
[10:27:09.920]                     else if (inherits(cond, "warning")) {
[10:27:09.920]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:09.920]                       if (muffled) 
[10:27:09.920]                         invokeRestart("muffleWarning")
[10:27:09.920]                     }
[10:27:09.920]                     else if (inherits(cond, "condition")) {
[10:27:09.920]                       if (!is.null(pattern)) {
[10:27:09.920]                         computeRestarts <- base::computeRestarts
[10:27:09.920]                         grepl <- base::grepl
[10:27:09.920]                         restarts <- computeRestarts(cond)
[10:27:09.920]                         for (restart in restarts) {
[10:27:09.920]                           name <- restart$name
[10:27:09.920]                           if (is.null(name)) 
[10:27:09.920]                             next
[10:27:09.920]                           if (!grepl(pattern, name)) 
[10:27:09.920]                             next
[10:27:09.920]                           invokeRestart(restart)
[10:27:09.920]                           muffled <- TRUE
[10:27:09.920]                           break
[10:27:09.920]                         }
[10:27:09.920]                       }
[10:27:09.920]                     }
[10:27:09.920]                     invisible(muffled)
[10:27:09.920]                   }
[10:27:09.920]                   muffleCondition(cond)
[10:27:09.920]                 })
[10:27:09.920]             }))
[10:27:09.920]             future::FutureResult(value = ...future.value$value, 
[10:27:09.920]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:09.920]                   ...future.rng), globalenv = if (FALSE) 
[10:27:09.920]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:09.920]                     ...future.globalenv.names))
[10:27:09.920]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:09.920]         }, condition = base::local({
[10:27:09.920]             c <- base::c
[10:27:09.920]             inherits <- base::inherits
[10:27:09.920]             invokeRestart <- base::invokeRestart
[10:27:09.920]             length <- base::length
[10:27:09.920]             list <- base::list
[10:27:09.920]             seq.int <- base::seq.int
[10:27:09.920]             signalCondition <- base::signalCondition
[10:27:09.920]             sys.calls <- base::sys.calls
[10:27:09.920]             `[[` <- base::`[[`
[10:27:09.920]             `+` <- base::`+`
[10:27:09.920]             `<<-` <- base::`<<-`
[10:27:09.920]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:09.920]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:09.920]                   3L)]
[10:27:09.920]             }
[10:27:09.920]             function(cond) {
[10:27:09.920]                 is_error <- inherits(cond, "error")
[10:27:09.920]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:09.920]                   NULL)
[10:27:09.920]                 if (is_error) {
[10:27:09.920]                   sessionInformation <- function() {
[10:27:09.920]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:09.920]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:09.920]                       search = base::search(), system = base::Sys.info())
[10:27:09.920]                   }
[10:27:09.920]                   ...future.conditions[[length(...future.conditions) + 
[10:27:09.920]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:09.920]                     cond$call), session = sessionInformation(), 
[10:27:09.920]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:09.920]                   signalCondition(cond)
[10:27:09.920]                 }
[10:27:09.920]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:09.920]                 "immediateCondition"))) {
[10:27:09.920]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:09.920]                   ...future.conditions[[length(...future.conditions) + 
[10:27:09.920]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:09.920]                   if (TRUE && !signal) {
[10:27:09.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:09.920]                     {
[10:27:09.920]                       inherits <- base::inherits
[10:27:09.920]                       invokeRestart <- base::invokeRestart
[10:27:09.920]                       is.null <- base::is.null
[10:27:09.920]                       muffled <- FALSE
[10:27:09.920]                       if (inherits(cond, "message")) {
[10:27:09.920]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:09.920]                         if (muffled) 
[10:27:09.920]                           invokeRestart("muffleMessage")
[10:27:09.920]                       }
[10:27:09.920]                       else if (inherits(cond, "warning")) {
[10:27:09.920]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:09.920]                         if (muffled) 
[10:27:09.920]                           invokeRestart("muffleWarning")
[10:27:09.920]                       }
[10:27:09.920]                       else if (inherits(cond, "condition")) {
[10:27:09.920]                         if (!is.null(pattern)) {
[10:27:09.920]                           computeRestarts <- base::computeRestarts
[10:27:09.920]                           grepl <- base::grepl
[10:27:09.920]                           restarts <- computeRestarts(cond)
[10:27:09.920]                           for (restart in restarts) {
[10:27:09.920]                             name <- restart$name
[10:27:09.920]                             if (is.null(name)) 
[10:27:09.920]                               next
[10:27:09.920]                             if (!grepl(pattern, name)) 
[10:27:09.920]                               next
[10:27:09.920]                             invokeRestart(restart)
[10:27:09.920]                             muffled <- TRUE
[10:27:09.920]                             break
[10:27:09.920]                           }
[10:27:09.920]                         }
[10:27:09.920]                       }
[10:27:09.920]                       invisible(muffled)
[10:27:09.920]                     }
[10:27:09.920]                     muffleCondition(cond, pattern = "^muffle")
[10:27:09.920]                   }
[10:27:09.920]                 }
[10:27:09.920]                 else {
[10:27:09.920]                   if (TRUE) {
[10:27:09.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:09.920]                     {
[10:27:09.920]                       inherits <- base::inherits
[10:27:09.920]                       invokeRestart <- base::invokeRestart
[10:27:09.920]                       is.null <- base::is.null
[10:27:09.920]                       muffled <- FALSE
[10:27:09.920]                       if (inherits(cond, "message")) {
[10:27:09.920]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:09.920]                         if (muffled) 
[10:27:09.920]                           invokeRestart("muffleMessage")
[10:27:09.920]                       }
[10:27:09.920]                       else if (inherits(cond, "warning")) {
[10:27:09.920]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:09.920]                         if (muffled) 
[10:27:09.920]                           invokeRestart("muffleWarning")
[10:27:09.920]                       }
[10:27:09.920]                       else if (inherits(cond, "condition")) {
[10:27:09.920]                         if (!is.null(pattern)) {
[10:27:09.920]                           computeRestarts <- base::computeRestarts
[10:27:09.920]                           grepl <- base::grepl
[10:27:09.920]                           restarts <- computeRestarts(cond)
[10:27:09.920]                           for (restart in restarts) {
[10:27:09.920]                             name <- restart$name
[10:27:09.920]                             if (is.null(name)) 
[10:27:09.920]                               next
[10:27:09.920]                             if (!grepl(pattern, name)) 
[10:27:09.920]                               next
[10:27:09.920]                             invokeRestart(restart)
[10:27:09.920]                             muffled <- TRUE
[10:27:09.920]                             break
[10:27:09.920]                           }
[10:27:09.920]                         }
[10:27:09.920]                       }
[10:27:09.920]                       invisible(muffled)
[10:27:09.920]                     }
[10:27:09.920]                     muffleCondition(cond, pattern = "^muffle")
[10:27:09.920]                   }
[10:27:09.920]                 }
[10:27:09.920]             }
[10:27:09.920]         }))
[10:27:09.920]     }, error = function(ex) {
[10:27:09.920]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:09.920]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:09.920]                 ...future.rng), started = ...future.startTime, 
[10:27:09.920]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:09.920]             version = "1.8"), class = "FutureResult")
[10:27:09.920]     }, finally = {
[10:27:09.920]         if (!identical(...future.workdir, getwd())) 
[10:27:09.920]             setwd(...future.workdir)
[10:27:09.920]         {
[10:27:09.920]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:09.920]                 ...future.oldOptions$nwarnings <- NULL
[10:27:09.920]             }
[10:27:09.920]             base::options(...future.oldOptions)
[10:27:09.920]             if (.Platform$OS.type == "windows") {
[10:27:09.920]                 old_names <- names(...future.oldEnvVars)
[10:27:09.920]                 envs <- base::Sys.getenv()
[10:27:09.920]                 names <- names(envs)
[10:27:09.920]                 common <- intersect(names, old_names)
[10:27:09.920]                 added <- setdiff(names, old_names)
[10:27:09.920]                 removed <- setdiff(old_names, names)
[10:27:09.920]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:09.920]                   envs[common]]
[10:27:09.920]                 NAMES <- toupper(changed)
[10:27:09.920]                 args <- list()
[10:27:09.920]                 for (kk in seq_along(NAMES)) {
[10:27:09.920]                   name <- changed[[kk]]
[10:27:09.920]                   NAME <- NAMES[[kk]]
[10:27:09.920]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:09.920]                     next
[10:27:09.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:09.920]                 }
[10:27:09.920]                 NAMES <- toupper(added)
[10:27:09.920]                 for (kk in seq_along(NAMES)) {
[10:27:09.920]                   name <- added[[kk]]
[10:27:09.920]                   NAME <- NAMES[[kk]]
[10:27:09.920]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:09.920]                     next
[10:27:09.920]                   args[[name]] <- ""
[10:27:09.920]                 }
[10:27:09.920]                 NAMES <- toupper(removed)
[10:27:09.920]                 for (kk in seq_along(NAMES)) {
[10:27:09.920]                   name <- removed[[kk]]
[10:27:09.920]                   NAME <- NAMES[[kk]]
[10:27:09.920]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:09.920]                     next
[10:27:09.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:09.920]                 }
[10:27:09.920]                 if (length(args) > 0) 
[10:27:09.920]                   base::do.call(base::Sys.setenv, args = args)
[10:27:09.920]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:09.920]             }
[10:27:09.920]             else {
[10:27:09.920]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:09.920]             }
[10:27:09.920]             {
[10:27:09.920]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:09.920]                   0L) {
[10:27:09.920]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:09.920]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:09.920]                   base::options(opts)
[10:27:09.920]                 }
[10:27:09.920]                 {
[10:27:09.920]                   {
[10:27:09.920]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:09.920]                     NULL
[10:27:09.920]                   }
[10:27:09.920]                   options(future.plan = NULL)
[10:27:09.920]                   if (is.na(NA_character_)) 
[10:27:09.920]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:09.920]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:09.920]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:09.920]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:09.920]                     envir = parent.frame()) 
[10:27:09.920]                   {
[10:27:09.920]                     if (is.function(workers)) 
[10:27:09.920]                       workers <- workers()
[10:27:09.920]                     workers <- structure(as.integer(workers), 
[10:27:09.920]                       class = class(workers))
[10:27:09.920]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:09.920]                       workers >= 1)
[10:27:09.920]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:09.920]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:09.920]                     }
[10:27:09.920]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:09.920]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:09.920]                       envir = envir)
[10:27:09.920]                     if (!future$lazy) 
[10:27:09.920]                       future <- run(future)
[10:27:09.920]                     invisible(future)
[10:27:09.920]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:09.920]                 }
[10:27:09.920]             }
[10:27:09.920]         }
[10:27:09.920]     })
[10:27:09.920]     if (TRUE) {
[10:27:09.920]         base::sink(type = "output", split = FALSE)
[10:27:09.920]         if (TRUE) {
[10:27:09.920]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:09.920]         }
[10:27:09.920]         else {
[10:27:09.920]             ...future.result["stdout"] <- base::list(NULL)
[10:27:09.920]         }
[10:27:09.920]         base::close(...future.stdout)
[10:27:09.920]         ...future.stdout <- NULL
[10:27:09.920]     }
[10:27:09.920]     ...future.result$conditions <- ...future.conditions
[10:27:09.920]     ...future.result$finished <- base::Sys.time()
[10:27:09.920]     ...future.result
[10:27:09.920] }
[10:27:09.924] MultisessionFuture started
[10:27:09.924] - Launch lazy future ... done
[10:27:09.924] run() for ‘MultisessionFuture’ ... done
[10:27:09.971] receiveMessageFromWorker() for ClusterFuture ...
[10:27:09.971] - Validating connection of MultisessionFuture
[10:27:09.971] - received message: FutureResult
[10:27:09.972] - Received FutureResult
[10:27:09.972] - Erased future from FutureRegistry
[10:27:09.972] result() for ClusterFuture ...
[10:27:09.972] - result already collected: FutureResult
[10:27:09.972] result() for ClusterFuture ... done
[10:27:09.972] signalConditions() ...
[10:27:09.972]  - include = ‘immediateCondition’
[10:27:09.972]  - exclude = 
[10:27:09.972]  - resignal = FALSE
[10:27:09.973]  - Number of conditions: 1
[10:27:09.973] signalConditions() ... done
[10:27:09.973] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:09.973] A MultisessionFuture was resolved (result was not collected)
[10:27:09.973] getGlobalsAndPackages() ...
[10:27:09.973] Searching for globals...
[10:27:09.974] - globals found: [2] ‘list’, ‘stop’
[10:27:09.974] Searching for globals ... DONE
[10:27:09.974] Resolving globals: FALSE
[10:27:09.974] 
[10:27:09.974] 
[10:27:09.975] getGlobalsAndPackages() ... DONE
[10:27:09.975] run() for ‘Future’ ...
[10:27:09.975] - state: ‘created’
[10:27:09.975] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:09.990] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:09.990] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:09.992]   - Field: ‘node’
[10:27:09.992]   - Field: ‘label’
[10:27:09.992]   - Field: ‘local’
[10:27:09.992]   - Field: ‘owner’
[10:27:09.992]   - Field: ‘envir’
[10:27:09.993]   - Field: ‘workers’
[10:27:09.993]   - Field: ‘packages’
[10:27:09.993]   - Field: ‘gc’
[10:27:09.993]   - Field: ‘conditions’
[10:27:09.993]   - Field: ‘persistent’
[10:27:09.993]   - Field: ‘expr’
[10:27:09.993]   - Field: ‘uuid’
[10:27:09.993]   - Field: ‘seed’
[10:27:09.993]   - Field: ‘version’
[10:27:09.993]   - Field: ‘result’
[10:27:09.994]   - Field: ‘asynchronous’
[10:27:09.994]   - Field: ‘calls’
[10:27:09.994]   - Field: ‘globals’
[10:27:09.994]   - Field: ‘stdout’
[10:27:09.994]   - Field: ‘earlySignal’
[10:27:09.994]   - Field: ‘lazy’
[10:27:09.994]   - Field: ‘state’
[10:27:09.994] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:09.994] - Launch lazy future ...
[10:27:09.995] Packages needed by the future expression (n = 0): <none>
[10:27:09.995] Packages needed by future strategies (n = 0): <none>
[10:27:09.995] {
[10:27:09.995]     {
[10:27:09.995]         {
[10:27:09.995]             ...future.startTime <- base::Sys.time()
[10:27:09.995]             {
[10:27:09.995]                 {
[10:27:09.995]                   {
[10:27:09.995]                     {
[10:27:09.995]                       base::local({
[10:27:09.995]                         has_future <- base::requireNamespace("future", 
[10:27:09.995]                           quietly = TRUE)
[10:27:09.995]                         if (has_future) {
[10:27:09.995]                           ns <- base::getNamespace("future")
[10:27:09.995]                           version <- ns[[".package"]][["version"]]
[10:27:09.995]                           if (is.null(version)) 
[10:27:09.995]                             version <- utils::packageVersion("future")
[10:27:09.995]                         }
[10:27:09.995]                         else {
[10:27:09.995]                           version <- NULL
[10:27:09.995]                         }
[10:27:09.995]                         if (!has_future || version < "1.8.0") {
[10:27:09.995]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:09.995]                             "", base::R.version$version.string), 
[10:27:09.995]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:09.995]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:09.995]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:09.995]                               "release", "version")], collapse = " "), 
[10:27:09.995]                             hostname = base::Sys.info()[["nodename"]])
[10:27:09.995]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:09.995]                             info)
[10:27:09.995]                           info <- base::paste(info, collapse = "; ")
[10:27:09.995]                           if (!has_future) {
[10:27:09.995]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:09.995]                               info)
[10:27:09.995]                           }
[10:27:09.995]                           else {
[10:27:09.995]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:09.995]                               info, version)
[10:27:09.995]                           }
[10:27:09.995]                           base::stop(msg)
[10:27:09.995]                         }
[10:27:09.995]                       })
[10:27:09.995]                     }
[10:27:09.995]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:09.995]                     base::options(mc.cores = 1L)
[10:27:09.995]                   }
[10:27:09.995]                   options(future.plan = NULL)
[10:27:09.995]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:09.995]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:09.995]                 }
[10:27:09.995]                 ...future.workdir <- getwd()
[10:27:09.995]             }
[10:27:09.995]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:09.995]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:09.995]         }
[10:27:09.995]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:09.995]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:09.995]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:09.995]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:09.995]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:09.995]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:09.995]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:09.995]             base::names(...future.oldOptions))
[10:27:09.995]     }
[10:27:09.995]     if (FALSE) {
[10:27:09.995]     }
[10:27:09.995]     else {
[10:27:09.995]         if (TRUE) {
[10:27:09.995]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:09.995]                 open = "w")
[10:27:09.995]         }
[10:27:09.995]         else {
[10:27:09.995]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:09.995]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:09.995]         }
[10:27:09.995]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:09.995]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:09.995]             base::sink(type = "output", split = FALSE)
[10:27:09.995]             base::close(...future.stdout)
[10:27:09.995]         }, add = TRUE)
[10:27:09.995]     }
[10:27:09.995]     ...future.frame <- base::sys.nframe()
[10:27:09.995]     ...future.conditions <- base::list()
[10:27:09.995]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:09.995]     if (FALSE) {
[10:27:09.995]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:09.995]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:09.995]     }
[10:27:09.995]     ...future.result <- base::tryCatch({
[10:27:09.995]         base::withCallingHandlers({
[10:27:09.995]             ...future.value <- base::withVisible(base::local({
[10:27:09.995]                 ...future.makeSendCondition <- base::local({
[10:27:09.995]                   sendCondition <- NULL
[10:27:09.995]                   function(frame = 1L) {
[10:27:09.995]                     if (is.function(sendCondition)) 
[10:27:09.995]                       return(sendCondition)
[10:27:09.995]                     ns <- getNamespace("parallel")
[10:27:09.995]                     if (exists("sendData", mode = "function", 
[10:27:09.995]                       envir = ns)) {
[10:27:09.995]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:09.995]                         envir = ns)
[10:27:09.995]                       envir <- sys.frame(frame)
[10:27:09.995]                       master <- NULL
[10:27:09.995]                       while (!identical(envir, .GlobalEnv) && 
[10:27:09.995]                         !identical(envir, emptyenv())) {
[10:27:09.995]                         if (exists("master", mode = "list", envir = envir, 
[10:27:09.995]                           inherits = FALSE)) {
[10:27:09.995]                           master <- get("master", mode = "list", 
[10:27:09.995]                             envir = envir, inherits = FALSE)
[10:27:09.995]                           if (inherits(master, c("SOCKnode", 
[10:27:09.995]                             "SOCK0node"))) {
[10:27:09.995]                             sendCondition <<- function(cond) {
[10:27:09.995]                               data <- list(type = "VALUE", value = cond, 
[10:27:09.995]                                 success = TRUE)
[10:27:09.995]                               parallel_sendData(master, data)
[10:27:09.995]                             }
[10:27:09.995]                             return(sendCondition)
[10:27:09.995]                           }
[10:27:09.995]                         }
[10:27:09.995]                         frame <- frame + 1L
[10:27:09.995]                         envir <- sys.frame(frame)
[10:27:09.995]                       }
[10:27:09.995]                     }
[10:27:09.995]                     sendCondition <<- function(cond) NULL
[10:27:09.995]                   }
[10:27:09.995]                 })
[10:27:09.995]                 withCallingHandlers({
[10:27:09.995]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:27:09.995]                 }, immediateCondition = function(cond) {
[10:27:09.995]                   sendCondition <- ...future.makeSendCondition()
[10:27:09.995]                   sendCondition(cond)
[10:27:09.995]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:09.995]                   {
[10:27:09.995]                     inherits <- base::inherits
[10:27:09.995]                     invokeRestart <- base::invokeRestart
[10:27:09.995]                     is.null <- base::is.null
[10:27:09.995]                     muffled <- FALSE
[10:27:09.995]                     if (inherits(cond, "message")) {
[10:27:09.995]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:09.995]                       if (muffled) 
[10:27:09.995]                         invokeRestart("muffleMessage")
[10:27:09.995]                     }
[10:27:09.995]                     else if (inherits(cond, "warning")) {
[10:27:09.995]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:09.995]                       if (muffled) 
[10:27:09.995]                         invokeRestart("muffleWarning")
[10:27:09.995]                     }
[10:27:09.995]                     else if (inherits(cond, "condition")) {
[10:27:09.995]                       if (!is.null(pattern)) {
[10:27:09.995]                         computeRestarts <- base::computeRestarts
[10:27:09.995]                         grepl <- base::grepl
[10:27:09.995]                         restarts <- computeRestarts(cond)
[10:27:09.995]                         for (restart in restarts) {
[10:27:09.995]                           name <- restart$name
[10:27:09.995]                           if (is.null(name)) 
[10:27:09.995]                             next
[10:27:09.995]                           if (!grepl(pattern, name)) 
[10:27:09.995]                             next
[10:27:09.995]                           invokeRestart(restart)
[10:27:09.995]                           muffled <- TRUE
[10:27:09.995]                           break
[10:27:09.995]                         }
[10:27:09.995]                       }
[10:27:09.995]                     }
[10:27:09.995]                     invisible(muffled)
[10:27:09.995]                   }
[10:27:09.995]                   muffleCondition(cond)
[10:27:09.995]                 })
[10:27:09.995]             }))
[10:27:09.995]             future::FutureResult(value = ...future.value$value, 
[10:27:09.995]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:09.995]                   ...future.rng), globalenv = if (FALSE) 
[10:27:09.995]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:09.995]                     ...future.globalenv.names))
[10:27:09.995]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:09.995]         }, condition = base::local({
[10:27:09.995]             c <- base::c
[10:27:09.995]             inherits <- base::inherits
[10:27:09.995]             invokeRestart <- base::invokeRestart
[10:27:09.995]             length <- base::length
[10:27:09.995]             list <- base::list
[10:27:09.995]             seq.int <- base::seq.int
[10:27:09.995]             signalCondition <- base::signalCondition
[10:27:09.995]             sys.calls <- base::sys.calls
[10:27:09.995]             `[[` <- base::`[[`
[10:27:09.995]             `+` <- base::`+`
[10:27:09.995]             `<<-` <- base::`<<-`
[10:27:09.995]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:09.995]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:09.995]                   3L)]
[10:27:09.995]             }
[10:27:09.995]             function(cond) {
[10:27:09.995]                 is_error <- inherits(cond, "error")
[10:27:09.995]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:09.995]                   NULL)
[10:27:09.995]                 if (is_error) {
[10:27:09.995]                   sessionInformation <- function() {
[10:27:09.995]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:09.995]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:09.995]                       search = base::search(), system = base::Sys.info())
[10:27:09.995]                   }
[10:27:09.995]                   ...future.conditions[[length(...future.conditions) + 
[10:27:09.995]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:09.995]                     cond$call), session = sessionInformation(), 
[10:27:09.995]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:09.995]                   signalCondition(cond)
[10:27:09.995]                 }
[10:27:09.995]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:09.995]                 "immediateCondition"))) {
[10:27:09.995]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:09.995]                   ...future.conditions[[length(...future.conditions) + 
[10:27:09.995]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:09.995]                   if (TRUE && !signal) {
[10:27:09.995]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:09.995]                     {
[10:27:09.995]                       inherits <- base::inherits
[10:27:09.995]                       invokeRestart <- base::invokeRestart
[10:27:09.995]                       is.null <- base::is.null
[10:27:09.995]                       muffled <- FALSE
[10:27:09.995]                       if (inherits(cond, "message")) {
[10:27:09.995]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:09.995]                         if (muffled) 
[10:27:09.995]                           invokeRestart("muffleMessage")
[10:27:09.995]                       }
[10:27:09.995]                       else if (inherits(cond, "warning")) {
[10:27:09.995]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:09.995]                         if (muffled) 
[10:27:09.995]                           invokeRestart("muffleWarning")
[10:27:09.995]                       }
[10:27:09.995]                       else if (inherits(cond, "condition")) {
[10:27:09.995]                         if (!is.null(pattern)) {
[10:27:09.995]                           computeRestarts <- base::computeRestarts
[10:27:09.995]                           grepl <- base::grepl
[10:27:09.995]                           restarts <- computeRestarts(cond)
[10:27:09.995]                           for (restart in restarts) {
[10:27:09.995]                             name <- restart$name
[10:27:09.995]                             if (is.null(name)) 
[10:27:09.995]                               next
[10:27:09.995]                             if (!grepl(pattern, name)) 
[10:27:09.995]                               next
[10:27:09.995]                             invokeRestart(restart)
[10:27:09.995]                             muffled <- TRUE
[10:27:09.995]                             break
[10:27:09.995]                           }
[10:27:09.995]                         }
[10:27:09.995]                       }
[10:27:09.995]                       invisible(muffled)
[10:27:09.995]                     }
[10:27:09.995]                     muffleCondition(cond, pattern = "^muffle")
[10:27:09.995]                   }
[10:27:09.995]                 }
[10:27:09.995]                 else {
[10:27:09.995]                   if (TRUE) {
[10:27:09.995]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:09.995]                     {
[10:27:09.995]                       inherits <- base::inherits
[10:27:09.995]                       invokeRestart <- base::invokeRestart
[10:27:09.995]                       is.null <- base::is.null
[10:27:09.995]                       muffled <- FALSE
[10:27:09.995]                       if (inherits(cond, "message")) {
[10:27:09.995]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:09.995]                         if (muffled) 
[10:27:09.995]                           invokeRestart("muffleMessage")
[10:27:09.995]                       }
[10:27:09.995]                       else if (inherits(cond, "warning")) {
[10:27:09.995]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:09.995]                         if (muffled) 
[10:27:09.995]                           invokeRestart("muffleWarning")
[10:27:09.995]                       }
[10:27:09.995]                       else if (inherits(cond, "condition")) {
[10:27:09.995]                         if (!is.null(pattern)) {
[10:27:09.995]                           computeRestarts <- base::computeRestarts
[10:27:09.995]                           grepl <- base::grepl
[10:27:09.995]                           restarts <- computeRestarts(cond)
[10:27:09.995]                           for (restart in restarts) {
[10:27:09.995]                             name <- restart$name
[10:27:09.995]                             if (is.null(name)) 
[10:27:09.995]                               next
[10:27:09.995]                             if (!grepl(pattern, name)) 
[10:27:09.995]                               next
[10:27:09.995]                             invokeRestart(restart)
[10:27:09.995]                             muffled <- TRUE
[10:27:09.995]                             break
[10:27:09.995]                           }
[10:27:09.995]                         }
[10:27:09.995]                       }
[10:27:09.995]                       invisible(muffled)
[10:27:09.995]                     }
[10:27:09.995]                     muffleCondition(cond, pattern = "^muffle")
[10:27:09.995]                   }
[10:27:09.995]                 }
[10:27:09.995]             }
[10:27:09.995]         }))
[10:27:09.995]     }, error = function(ex) {
[10:27:09.995]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:09.995]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:09.995]                 ...future.rng), started = ...future.startTime, 
[10:27:09.995]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:09.995]             version = "1.8"), class = "FutureResult")
[10:27:09.995]     }, finally = {
[10:27:09.995]         if (!identical(...future.workdir, getwd())) 
[10:27:09.995]             setwd(...future.workdir)
[10:27:09.995]         {
[10:27:09.995]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:09.995]                 ...future.oldOptions$nwarnings <- NULL
[10:27:09.995]             }
[10:27:09.995]             base::options(...future.oldOptions)
[10:27:09.995]             if (.Platform$OS.type == "windows") {
[10:27:09.995]                 old_names <- names(...future.oldEnvVars)
[10:27:09.995]                 envs <- base::Sys.getenv()
[10:27:09.995]                 names <- names(envs)
[10:27:09.995]                 common <- intersect(names, old_names)
[10:27:09.995]                 added <- setdiff(names, old_names)
[10:27:09.995]                 removed <- setdiff(old_names, names)
[10:27:09.995]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:09.995]                   envs[common]]
[10:27:09.995]                 NAMES <- toupper(changed)
[10:27:09.995]                 args <- list()
[10:27:09.995]                 for (kk in seq_along(NAMES)) {
[10:27:09.995]                   name <- changed[[kk]]
[10:27:09.995]                   NAME <- NAMES[[kk]]
[10:27:09.995]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:09.995]                     next
[10:27:09.995]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:09.995]                 }
[10:27:09.995]                 NAMES <- toupper(added)
[10:27:09.995]                 for (kk in seq_along(NAMES)) {
[10:27:09.995]                   name <- added[[kk]]
[10:27:09.995]                   NAME <- NAMES[[kk]]
[10:27:09.995]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:09.995]                     next
[10:27:09.995]                   args[[name]] <- ""
[10:27:09.995]                 }
[10:27:09.995]                 NAMES <- toupper(removed)
[10:27:09.995]                 for (kk in seq_along(NAMES)) {
[10:27:09.995]                   name <- removed[[kk]]
[10:27:09.995]                   NAME <- NAMES[[kk]]
[10:27:09.995]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:09.995]                     next
[10:27:09.995]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:09.995]                 }
[10:27:09.995]                 if (length(args) > 0) 
[10:27:09.995]                   base::do.call(base::Sys.setenv, args = args)
[10:27:09.995]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:09.995]             }
[10:27:09.995]             else {
[10:27:09.995]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:09.995]             }
[10:27:09.995]             {
[10:27:09.995]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:09.995]                   0L) {
[10:27:09.995]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:09.995]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:09.995]                   base::options(opts)
[10:27:09.995]                 }
[10:27:09.995]                 {
[10:27:09.995]                   {
[10:27:09.995]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:09.995]                     NULL
[10:27:09.995]                   }
[10:27:09.995]                   options(future.plan = NULL)
[10:27:09.995]                   if (is.na(NA_character_)) 
[10:27:09.995]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:09.995]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:09.995]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:09.995]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:09.995]                     envir = parent.frame()) 
[10:27:09.995]                   {
[10:27:09.995]                     if (is.function(workers)) 
[10:27:09.995]                       workers <- workers()
[10:27:09.995]                     workers <- structure(as.integer(workers), 
[10:27:09.995]                       class = class(workers))
[10:27:09.995]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:09.995]                       workers >= 1)
[10:27:09.995]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:09.995]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:09.995]                     }
[10:27:09.995]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:09.995]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:09.995]                       envir = envir)
[10:27:09.995]                     if (!future$lazy) 
[10:27:09.995]                       future <- run(future)
[10:27:09.995]                     invisible(future)
[10:27:09.995]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:09.995]                 }
[10:27:09.995]             }
[10:27:09.995]         }
[10:27:09.995]     })
[10:27:09.995]     if (TRUE) {
[10:27:09.995]         base::sink(type = "output", split = FALSE)
[10:27:09.995]         if (TRUE) {
[10:27:09.995]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:09.995]         }
[10:27:09.995]         else {
[10:27:09.995]             ...future.result["stdout"] <- base::list(NULL)
[10:27:09.995]         }
[10:27:09.995]         base::close(...future.stdout)
[10:27:09.995]         ...future.stdout <- NULL
[10:27:09.995]     }
[10:27:09.995]     ...future.result$conditions <- ...future.conditions
[10:27:09.995]     ...future.result$finished <- base::Sys.time()
[10:27:09.995]     ...future.result
[10:27:09.995] }
[10:27:09.998] MultisessionFuture started
[10:27:09.998] - Launch lazy future ... done
[10:27:09.999] run() for ‘MultisessionFuture’ ... done
[10:27:10.046] receiveMessageFromWorker() for ClusterFuture ...
[10:27:10.046] - Validating connection of MultisessionFuture
[10:27:10.047] - received message: FutureResult
[10:27:10.047] - Received FutureResult
[10:27:10.047] - Erased future from FutureRegistry
[10:27:10.047] result() for ClusterFuture ...
[10:27:10.047] - result already collected: FutureResult
[10:27:10.047] result() for ClusterFuture ... done
[10:27:10.048] signalConditions() ...
[10:27:10.048]  - include = ‘immediateCondition’
[10:27:10.048]  - exclude = 
[10:27:10.048]  - resignal = FALSE
[10:27:10.048]  - Number of conditions: 1
[10:27:10.048] signalConditions() ... done
[10:27:10.048] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:10.048] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 1 ... DONE
- result = FALSE, recursive = 2 ...
[10:27:10.048] getGlobalsAndPackages() ...
[10:27:10.049] Searching for globals...
[10:27:10.050] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:27:10.050] Searching for globals ... DONE
[10:27:10.050] Resolving globals: FALSE
[10:27:10.050] 
[10:27:10.050] 
[10:27:10.050] getGlobalsAndPackages() ... DONE
[10:27:10.051] run() for ‘Future’ ...
[10:27:10.051] - state: ‘created’
[10:27:10.051] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:10.064] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:10.065] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:10.065]   - Field: ‘node’
[10:27:10.065]   - Field: ‘label’
[10:27:10.065]   - Field: ‘local’
[10:27:10.065]   - Field: ‘owner’
[10:27:10.065]   - Field: ‘envir’
[10:27:10.065]   - Field: ‘workers’
[10:27:10.065]   - Field: ‘packages’
[10:27:10.065]   - Field: ‘gc’
[10:27:10.066]   - Field: ‘conditions’
[10:27:10.066]   - Field: ‘persistent’
[10:27:10.066]   - Field: ‘expr’
[10:27:10.066]   - Field: ‘uuid’
[10:27:10.066]   - Field: ‘seed’
[10:27:10.066]   - Field: ‘version’
[10:27:10.066]   - Field: ‘result’
[10:27:10.066]   - Field: ‘asynchronous’
[10:27:10.066]   - Field: ‘calls’
[10:27:10.066]   - Field: ‘globals’
[10:27:10.066]   - Field: ‘stdout’
[10:27:10.067]   - Field: ‘earlySignal’
[10:27:10.067]   - Field: ‘lazy’
[10:27:10.067]   - Field: ‘state’
[10:27:10.067] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:10.067] - Launch lazy future ...
[10:27:10.067] Packages needed by the future expression (n = 0): <none>
[10:27:10.067] Packages needed by future strategies (n = 0): <none>
[10:27:10.068] {
[10:27:10.068]     {
[10:27:10.068]         {
[10:27:10.068]             ...future.startTime <- base::Sys.time()
[10:27:10.068]             {
[10:27:10.068]                 {
[10:27:10.068]                   {
[10:27:10.068]                     {
[10:27:10.068]                       base::local({
[10:27:10.068]                         has_future <- base::requireNamespace("future", 
[10:27:10.068]                           quietly = TRUE)
[10:27:10.068]                         if (has_future) {
[10:27:10.068]                           ns <- base::getNamespace("future")
[10:27:10.068]                           version <- ns[[".package"]][["version"]]
[10:27:10.068]                           if (is.null(version)) 
[10:27:10.068]                             version <- utils::packageVersion("future")
[10:27:10.068]                         }
[10:27:10.068]                         else {
[10:27:10.068]                           version <- NULL
[10:27:10.068]                         }
[10:27:10.068]                         if (!has_future || version < "1.8.0") {
[10:27:10.068]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:10.068]                             "", base::R.version$version.string), 
[10:27:10.068]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:10.068]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:10.068]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:10.068]                               "release", "version")], collapse = " "), 
[10:27:10.068]                             hostname = base::Sys.info()[["nodename"]])
[10:27:10.068]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:10.068]                             info)
[10:27:10.068]                           info <- base::paste(info, collapse = "; ")
[10:27:10.068]                           if (!has_future) {
[10:27:10.068]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:10.068]                               info)
[10:27:10.068]                           }
[10:27:10.068]                           else {
[10:27:10.068]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:10.068]                               info, version)
[10:27:10.068]                           }
[10:27:10.068]                           base::stop(msg)
[10:27:10.068]                         }
[10:27:10.068]                       })
[10:27:10.068]                     }
[10:27:10.068]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:10.068]                     base::options(mc.cores = 1L)
[10:27:10.068]                   }
[10:27:10.068]                   options(future.plan = NULL)
[10:27:10.068]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:10.068]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:10.068]                 }
[10:27:10.068]                 ...future.workdir <- getwd()
[10:27:10.068]             }
[10:27:10.068]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:10.068]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:10.068]         }
[10:27:10.068]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:10.068]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:10.068]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:10.068]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:10.068]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:10.068]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:10.068]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:10.068]             base::names(...future.oldOptions))
[10:27:10.068]     }
[10:27:10.068]     if (FALSE) {
[10:27:10.068]     }
[10:27:10.068]     else {
[10:27:10.068]         if (TRUE) {
[10:27:10.068]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:10.068]                 open = "w")
[10:27:10.068]         }
[10:27:10.068]         else {
[10:27:10.068]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:10.068]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:10.068]         }
[10:27:10.068]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:10.068]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:10.068]             base::sink(type = "output", split = FALSE)
[10:27:10.068]             base::close(...future.stdout)
[10:27:10.068]         }, add = TRUE)
[10:27:10.068]     }
[10:27:10.068]     ...future.frame <- base::sys.nframe()
[10:27:10.068]     ...future.conditions <- base::list()
[10:27:10.068]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:10.068]     if (FALSE) {
[10:27:10.068]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:10.068]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:10.068]     }
[10:27:10.068]     ...future.result <- base::tryCatch({
[10:27:10.068]         base::withCallingHandlers({
[10:27:10.068]             ...future.value <- base::withVisible(base::local({
[10:27:10.068]                 ...future.makeSendCondition <- base::local({
[10:27:10.068]                   sendCondition <- NULL
[10:27:10.068]                   function(frame = 1L) {
[10:27:10.068]                     if (is.function(sendCondition)) 
[10:27:10.068]                       return(sendCondition)
[10:27:10.068]                     ns <- getNamespace("parallel")
[10:27:10.068]                     if (exists("sendData", mode = "function", 
[10:27:10.068]                       envir = ns)) {
[10:27:10.068]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:10.068]                         envir = ns)
[10:27:10.068]                       envir <- sys.frame(frame)
[10:27:10.068]                       master <- NULL
[10:27:10.068]                       while (!identical(envir, .GlobalEnv) && 
[10:27:10.068]                         !identical(envir, emptyenv())) {
[10:27:10.068]                         if (exists("master", mode = "list", envir = envir, 
[10:27:10.068]                           inherits = FALSE)) {
[10:27:10.068]                           master <- get("master", mode = "list", 
[10:27:10.068]                             envir = envir, inherits = FALSE)
[10:27:10.068]                           if (inherits(master, c("SOCKnode", 
[10:27:10.068]                             "SOCK0node"))) {
[10:27:10.068]                             sendCondition <<- function(cond) {
[10:27:10.068]                               data <- list(type = "VALUE", value = cond, 
[10:27:10.068]                                 success = TRUE)
[10:27:10.068]                               parallel_sendData(master, data)
[10:27:10.068]                             }
[10:27:10.068]                             return(sendCondition)
[10:27:10.068]                           }
[10:27:10.068]                         }
[10:27:10.068]                         frame <- frame + 1L
[10:27:10.068]                         envir <- sys.frame(frame)
[10:27:10.068]                       }
[10:27:10.068]                     }
[10:27:10.068]                     sendCondition <<- function(cond) NULL
[10:27:10.068]                   }
[10:27:10.068]                 })
[10:27:10.068]                 withCallingHandlers({
[10:27:10.068]                   {
[10:27:10.068]                     Sys.sleep(0.5)
[10:27:10.068]                     list(a = 1, b = 42L)
[10:27:10.068]                   }
[10:27:10.068]                 }, immediateCondition = function(cond) {
[10:27:10.068]                   sendCondition <- ...future.makeSendCondition()
[10:27:10.068]                   sendCondition(cond)
[10:27:10.068]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:10.068]                   {
[10:27:10.068]                     inherits <- base::inherits
[10:27:10.068]                     invokeRestart <- base::invokeRestart
[10:27:10.068]                     is.null <- base::is.null
[10:27:10.068]                     muffled <- FALSE
[10:27:10.068]                     if (inherits(cond, "message")) {
[10:27:10.068]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:10.068]                       if (muffled) 
[10:27:10.068]                         invokeRestart("muffleMessage")
[10:27:10.068]                     }
[10:27:10.068]                     else if (inherits(cond, "warning")) {
[10:27:10.068]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:10.068]                       if (muffled) 
[10:27:10.068]                         invokeRestart("muffleWarning")
[10:27:10.068]                     }
[10:27:10.068]                     else if (inherits(cond, "condition")) {
[10:27:10.068]                       if (!is.null(pattern)) {
[10:27:10.068]                         computeRestarts <- base::computeRestarts
[10:27:10.068]                         grepl <- base::grepl
[10:27:10.068]                         restarts <- computeRestarts(cond)
[10:27:10.068]                         for (restart in restarts) {
[10:27:10.068]                           name <- restart$name
[10:27:10.068]                           if (is.null(name)) 
[10:27:10.068]                             next
[10:27:10.068]                           if (!grepl(pattern, name)) 
[10:27:10.068]                             next
[10:27:10.068]                           invokeRestart(restart)
[10:27:10.068]                           muffled <- TRUE
[10:27:10.068]                           break
[10:27:10.068]                         }
[10:27:10.068]                       }
[10:27:10.068]                     }
[10:27:10.068]                     invisible(muffled)
[10:27:10.068]                   }
[10:27:10.068]                   muffleCondition(cond)
[10:27:10.068]                 })
[10:27:10.068]             }))
[10:27:10.068]             future::FutureResult(value = ...future.value$value, 
[10:27:10.068]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:10.068]                   ...future.rng), globalenv = if (FALSE) 
[10:27:10.068]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:10.068]                     ...future.globalenv.names))
[10:27:10.068]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:10.068]         }, condition = base::local({
[10:27:10.068]             c <- base::c
[10:27:10.068]             inherits <- base::inherits
[10:27:10.068]             invokeRestart <- base::invokeRestart
[10:27:10.068]             length <- base::length
[10:27:10.068]             list <- base::list
[10:27:10.068]             seq.int <- base::seq.int
[10:27:10.068]             signalCondition <- base::signalCondition
[10:27:10.068]             sys.calls <- base::sys.calls
[10:27:10.068]             `[[` <- base::`[[`
[10:27:10.068]             `+` <- base::`+`
[10:27:10.068]             `<<-` <- base::`<<-`
[10:27:10.068]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:10.068]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:10.068]                   3L)]
[10:27:10.068]             }
[10:27:10.068]             function(cond) {
[10:27:10.068]                 is_error <- inherits(cond, "error")
[10:27:10.068]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:10.068]                   NULL)
[10:27:10.068]                 if (is_error) {
[10:27:10.068]                   sessionInformation <- function() {
[10:27:10.068]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:10.068]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:10.068]                       search = base::search(), system = base::Sys.info())
[10:27:10.068]                   }
[10:27:10.068]                   ...future.conditions[[length(...future.conditions) + 
[10:27:10.068]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:10.068]                     cond$call), session = sessionInformation(), 
[10:27:10.068]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:10.068]                   signalCondition(cond)
[10:27:10.068]                 }
[10:27:10.068]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:10.068]                 "immediateCondition"))) {
[10:27:10.068]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:10.068]                   ...future.conditions[[length(...future.conditions) + 
[10:27:10.068]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:10.068]                   if (TRUE && !signal) {
[10:27:10.068]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:10.068]                     {
[10:27:10.068]                       inherits <- base::inherits
[10:27:10.068]                       invokeRestart <- base::invokeRestart
[10:27:10.068]                       is.null <- base::is.null
[10:27:10.068]                       muffled <- FALSE
[10:27:10.068]                       if (inherits(cond, "message")) {
[10:27:10.068]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:10.068]                         if (muffled) 
[10:27:10.068]                           invokeRestart("muffleMessage")
[10:27:10.068]                       }
[10:27:10.068]                       else if (inherits(cond, "warning")) {
[10:27:10.068]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:10.068]                         if (muffled) 
[10:27:10.068]                           invokeRestart("muffleWarning")
[10:27:10.068]                       }
[10:27:10.068]                       else if (inherits(cond, "condition")) {
[10:27:10.068]                         if (!is.null(pattern)) {
[10:27:10.068]                           computeRestarts <- base::computeRestarts
[10:27:10.068]                           grepl <- base::grepl
[10:27:10.068]                           restarts <- computeRestarts(cond)
[10:27:10.068]                           for (restart in restarts) {
[10:27:10.068]                             name <- restart$name
[10:27:10.068]                             if (is.null(name)) 
[10:27:10.068]                               next
[10:27:10.068]                             if (!grepl(pattern, name)) 
[10:27:10.068]                               next
[10:27:10.068]                             invokeRestart(restart)
[10:27:10.068]                             muffled <- TRUE
[10:27:10.068]                             break
[10:27:10.068]                           }
[10:27:10.068]                         }
[10:27:10.068]                       }
[10:27:10.068]                       invisible(muffled)
[10:27:10.068]                     }
[10:27:10.068]                     muffleCondition(cond, pattern = "^muffle")
[10:27:10.068]                   }
[10:27:10.068]                 }
[10:27:10.068]                 else {
[10:27:10.068]                   if (TRUE) {
[10:27:10.068]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:10.068]                     {
[10:27:10.068]                       inherits <- base::inherits
[10:27:10.068]                       invokeRestart <- base::invokeRestart
[10:27:10.068]                       is.null <- base::is.null
[10:27:10.068]                       muffled <- FALSE
[10:27:10.068]                       if (inherits(cond, "message")) {
[10:27:10.068]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:10.068]                         if (muffled) 
[10:27:10.068]                           invokeRestart("muffleMessage")
[10:27:10.068]                       }
[10:27:10.068]                       else if (inherits(cond, "warning")) {
[10:27:10.068]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:10.068]                         if (muffled) 
[10:27:10.068]                           invokeRestart("muffleWarning")
[10:27:10.068]                       }
[10:27:10.068]                       else if (inherits(cond, "condition")) {
[10:27:10.068]                         if (!is.null(pattern)) {
[10:27:10.068]                           computeRestarts <- base::computeRestarts
[10:27:10.068]                           grepl <- base::grepl
[10:27:10.068]                           restarts <- computeRestarts(cond)
[10:27:10.068]                           for (restart in restarts) {
[10:27:10.068]                             name <- restart$name
[10:27:10.068]                             if (is.null(name)) 
[10:27:10.068]                               next
[10:27:10.068]                             if (!grepl(pattern, name)) 
[10:27:10.068]                               next
[10:27:10.068]                             invokeRestart(restart)
[10:27:10.068]                             muffled <- TRUE
[10:27:10.068]                             break
[10:27:10.068]                           }
[10:27:10.068]                         }
[10:27:10.068]                       }
[10:27:10.068]                       invisible(muffled)
[10:27:10.068]                     }
[10:27:10.068]                     muffleCondition(cond, pattern = "^muffle")
[10:27:10.068]                   }
[10:27:10.068]                 }
[10:27:10.068]             }
[10:27:10.068]         }))
[10:27:10.068]     }, error = function(ex) {
[10:27:10.068]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:10.068]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:10.068]                 ...future.rng), started = ...future.startTime, 
[10:27:10.068]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:10.068]             version = "1.8"), class = "FutureResult")
[10:27:10.068]     }, finally = {
[10:27:10.068]         if (!identical(...future.workdir, getwd())) 
[10:27:10.068]             setwd(...future.workdir)
[10:27:10.068]         {
[10:27:10.068]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:10.068]                 ...future.oldOptions$nwarnings <- NULL
[10:27:10.068]             }
[10:27:10.068]             base::options(...future.oldOptions)
[10:27:10.068]             if (.Platform$OS.type == "windows") {
[10:27:10.068]                 old_names <- names(...future.oldEnvVars)
[10:27:10.068]                 envs <- base::Sys.getenv()
[10:27:10.068]                 names <- names(envs)
[10:27:10.068]                 common <- intersect(names, old_names)
[10:27:10.068]                 added <- setdiff(names, old_names)
[10:27:10.068]                 removed <- setdiff(old_names, names)
[10:27:10.068]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:10.068]                   envs[common]]
[10:27:10.068]                 NAMES <- toupper(changed)
[10:27:10.068]                 args <- list()
[10:27:10.068]                 for (kk in seq_along(NAMES)) {
[10:27:10.068]                   name <- changed[[kk]]
[10:27:10.068]                   NAME <- NAMES[[kk]]
[10:27:10.068]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:10.068]                     next
[10:27:10.068]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:10.068]                 }
[10:27:10.068]                 NAMES <- toupper(added)
[10:27:10.068]                 for (kk in seq_along(NAMES)) {
[10:27:10.068]                   name <- added[[kk]]
[10:27:10.068]                   NAME <- NAMES[[kk]]
[10:27:10.068]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:10.068]                     next
[10:27:10.068]                   args[[name]] <- ""
[10:27:10.068]                 }
[10:27:10.068]                 NAMES <- toupper(removed)
[10:27:10.068]                 for (kk in seq_along(NAMES)) {
[10:27:10.068]                   name <- removed[[kk]]
[10:27:10.068]                   NAME <- NAMES[[kk]]
[10:27:10.068]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:10.068]                     next
[10:27:10.068]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:10.068]                 }
[10:27:10.068]                 if (length(args) > 0) 
[10:27:10.068]                   base::do.call(base::Sys.setenv, args = args)
[10:27:10.068]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:10.068]             }
[10:27:10.068]             else {
[10:27:10.068]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:10.068]             }
[10:27:10.068]             {
[10:27:10.068]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:10.068]                   0L) {
[10:27:10.068]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:10.068]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:10.068]                   base::options(opts)
[10:27:10.068]                 }
[10:27:10.068]                 {
[10:27:10.068]                   {
[10:27:10.068]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:10.068]                     NULL
[10:27:10.068]                   }
[10:27:10.068]                   options(future.plan = NULL)
[10:27:10.068]                   if (is.na(NA_character_)) 
[10:27:10.068]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:10.068]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:10.068]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:10.068]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:10.068]                     envir = parent.frame()) 
[10:27:10.068]                   {
[10:27:10.068]                     if (is.function(workers)) 
[10:27:10.068]                       workers <- workers()
[10:27:10.068]                     workers <- structure(as.integer(workers), 
[10:27:10.068]                       class = class(workers))
[10:27:10.068]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:10.068]                       workers >= 1)
[10:27:10.068]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:10.068]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:10.068]                     }
[10:27:10.068]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:10.068]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:10.068]                       envir = envir)
[10:27:10.068]                     if (!future$lazy) 
[10:27:10.068]                       future <- run(future)
[10:27:10.068]                     invisible(future)
[10:27:10.068]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:10.068]                 }
[10:27:10.068]             }
[10:27:10.068]         }
[10:27:10.068]     })
[10:27:10.068]     if (TRUE) {
[10:27:10.068]         base::sink(type = "output", split = FALSE)
[10:27:10.068]         if (TRUE) {
[10:27:10.068]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:10.068]         }
[10:27:10.068]         else {
[10:27:10.068]             ...future.result["stdout"] <- base::list(NULL)
[10:27:10.068]         }
[10:27:10.068]         base::close(...future.stdout)
[10:27:10.068]         ...future.stdout <- NULL
[10:27:10.068]     }
[10:27:10.068]     ...future.result$conditions <- ...future.conditions
[10:27:10.068]     ...future.result$finished <- base::Sys.time()
[10:27:10.068]     ...future.result
[10:27:10.068] }
[10:27:10.071] MultisessionFuture started
[10:27:10.071] - Launch lazy future ... done
[10:27:10.071] run() for ‘MultisessionFuture’ ... done
[10:27:10.619] receiveMessageFromWorker() for ClusterFuture ...
[10:27:10.620] - Validating connection of MultisessionFuture
[10:27:10.620] - received message: FutureResult
[10:27:10.620] - Received FutureResult
[10:27:10.620] - Erased future from FutureRegistry
[10:27:10.620] result() for ClusterFuture ...
[10:27:10.620] - result already collected: FutureResult
[10:27:10.620] result() for ClusterFuture ... done
[10:27:10.621] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:10.621] A MultisessionFuture was resolved (result was not collected)
[10:27:10.621] getGlobalsAndPackages() ...
[10:27:10.621] Searching for globals...
[10:27:10.622] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:27:10.622] Searching for globals ... DONE
[10:27:10.622] Resolving globals: FALSE
[10:27:10.623] 
[10:27:10.623] 
[10:27:10.623] getGlobalsAndPackages() ... DONE
[10:27:10.623] run() for ‘Future’ ...
[10:27:10.623] - state: ‘created’
[10:27:10.624] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:10.639] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:10.640] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:10.640]   - Field: ‘node’
[10:27:10.640]   - Field: ‘label’
[10:27:10.640]   - Field: ‘local’
[10:27:10.640]   - Field: ‘owner’
[10:27:10.640]   - Field: ‘envir’
[10:27:10.640]   - Field: ‘workers’
[10:27:10.640]   - Field: ‘packages’
[10:27:10.640]   - Field: ‘gc’
[10:27:10.641]   - Field: ‘conditions’
[10:27:10.641]   - Field: ‘persistent’
[10:27:10.641]   - Field: ‘expr’
[10:27:10.641]   - Field: ‘uuid’
[10:27:10.641]   - Field: ‘seed’
[10:27:10.641]   - Field: ‘version’
[10:27:10.641]   - Field: ‘result’
[10:27:10.641]   - Field: ‘asynchronous’
[10:27:10.641]   - Field: ‘calls’
[10:27:10.641]   - Field: ‘globals’
[10:27:10.642]   - Field: ‘stdout’
[10:27:10.642]   - Field: ‘earlySignal’
[10:27:10.642]   - Field: ‘lazy’
[10:27:10.642]   - Field: ‘state’
[10:27:10.642] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:10.642] - Launch lazy future ...
[10:27:10.642] Packages needed by the future expression (n = 0): <none>
[10:27:10.642] Packages needed by future strategies (n = 0): <none>
[10:27:10.643] {
[10:27:10.643]     {
[10:27:10.643]         {
[10:27:10.643]             ...future.startTime <- base::Sys.time()
[10:27:10.643]             {
[10:27:10.643]                 {
[10:27:10.643]                   {
[10:27:10.643]                     {
[10:27:10.643]                       base::local({
[10:27:10.643]                         has_future <- base::requireNamespace("future", 
[10:27:10.643]                           quietly = TRUE)
[10:27:10.643]                         if (has_future) {
[10:27:10.643]                           ns <- base::getNamespace("future")
[10:27:10.643]                           version <- ns[[".package"]][["version"]]
[10:27:10.643]                           if (is.null(version)) 
[10:27:10.643]                             version <- utils::packageVersion("future")
[10:27:10.643]                         }
[10:27:10.643]                         else {
[10:27:10.643]                           version <- NULL
[10:27:10.643]                         }
[10:27:10.643]                         if (!has_future || version < "1.8.0") {
[10:27:10.643]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:10.643]                             "", base::R.version$version.string), 
[10:27:10.643]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:10.643]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:10.643]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:10.643]                               "release", "version")], collapse = " "), 
[10:27:10.643]                             hostname = base::Sys.info()[["nodename"]])
[10:27:10.643]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:10.643]                             info)
[10:27:10.643]                           info <- base::paste(info, collapse = "; ")
[10:27:10.643]                           if (!has_future) {
[10:27:10.643]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:10.643]                               info)
[10:27:10.643]                           }
[10:27:10.643]                           else {
[10:27:10.643]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:10.643]                               info, version)
[10:27:10.643]                           }
[10:27:10.643]                           base::stop(msg)
[10:27:10.643]                         }
[10:27:10.643]                       })
[10:27:10.643]                     }
[10:27:10.643]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:10.643]                     base::options(mc.cores = 1L)
[10:27:10.643]                   }
[10:27:10.643]                   options(future.plan = NULL)
[10:27:10.643]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:10.643]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:10.643]                 }
[10:27:10.643]                 ...future.workdir <- getwd()
[10:27:10.643]             }
[10:27:10.643]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:10.643]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:10.643]         }
[10:27:10.643]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:10.643]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:10.643]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:10.643]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:10.643]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:10.643]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:10.643]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:10.643]             base::names(...future.oldOptions))
[10:27:10.643]     }
[10:27:10.643]     if (FALSE) {
[10:27:10.643]     }
[10:27:10.643]     else {
[10:27:10.643]         if (TRUE) {
[10:27:10.643]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:10.643]                 open = "w")
[10:27:10.643]         }
[10:27:10.643]         else {
[10:27:10.643]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:10.643]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:10.643]         }
[10:27:10.643]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:10.643]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:10.643]             base::sink(type = "output", split = FALSE)
[10:27:10.643]             base::close(...future.stdout)
[10:27:10.643]         }, add = TRUE)
[10:27:10.643]     }
[10:27:10.643]     ...future.frame <- base::sys.nframe()
[10:27:10.643]     ...future.conditions <- base::list()
[10:27:10.643]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:10.643]     if (FALSE) {
[10:27:10.643]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:10.643]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:10.643]     }
[10:27:10.643]     ...future.result <- base::tryCatch({
[10:27:10.643]         base::withCallingHandlers({
[10:27:10.643]             ...future.value <- base::withVisible(base::local({
[10:27:10.643]                 ...future.makeSendCondition <- base::local({
[10:27:10.643]                   sendCondition <- NULL
[10:27:10.643]                   function(frame = 1L) {
[10:27:10.643]                     if (is.function(sendCondition)) 
[10:27:10.643]                       return(sendCondition)
[10:27:10.643]                     ns <- getNamespace("parallel")
[10:27:10.643]                     if (exists("sendData", mode = "function", 
[10:27:10.643]                       envir = ns)) {
[10:27:10.643]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:10.643]                         envir = ns)
[10:27:10.643]                       envir <- sys.frame(frame)
[10:27:10.643]                       master <- NULL
[10:27:10.643]                       while (!identical(envir, .GlobalEnv) && 
[10:27:10.643]                         !identical(envir, emptyenv())) {
[10:27:10.643]                         if (exists("master", mode = "list", envir = envir, 
[10:27:10.643]                           inherits = FALSE)) {
[10:27:10.643]                           master <- get("master", mode = "list", 
[10:27:10.643]                             envir = envir, inherits = FALSE)
[10:27:10.643]                           if (inherits(master, c("SOCKnode", 
[10:27:10.643]                             "SOCK0node"))) {
[10:27:10.643]                             sendCondition <<- function(cond) {
[10:27:10.643]                               data <- list(type = "VALUE", value = cond, 
[10:27:10.643]                                 success = TRUE)
[10:27:10.643]                               parallel_sendData(master, data)
[10:27:10.643]                             }
[10:27:10.643]                             return(sendCondition)
[10:27:10.643]                           }
[10:27:10.643]                         }
[10:27:10.643]                         frame <- frame + 1L
[10:27:10.643]                         envir <- sys.frame(frame)
[10:27:10.643]                       }
[10:27:10.643]                     }
[10:27:10.643]                     sendCondition <<- function(cond) NULL
[10:27:10.643]                   }
[10:27:10.643]                 })
[10:27:10.643]                 withCallingHandlers({
[10:27:10.643]                   {
[10:27:10.643]                     Sys.sleep(0.5)
[10:27:10.643]                     list(a = 1, b = 42L)
[10:27:10.643]                   }
[10:27:10.643]                 }, immediateCondition = function(cond) {
[10:27:10.643]                   sendCondition <- ...future.makeSendCondition()
[10:27:10.643]                   sendCondition(cond)
[10:27:10.643]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:10.643]                   {
[10:27:10.643]                     inherits <- base::inherits
[10:27:10.643]                     invokeRestart <- base::invokeRestart
[10:27:10.643]                     is.null <- base::is.null
[10:27:10.643]                     muffled <- FALSE
[10:27:10.643]                     if (inherits(cond, "message")) {
[10:27:10.643]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:10.643]                       if (muffled) 
[10:27:10.643]                         invokeRestart("muffleMessage")
[10:27:10.643]                     }
[10:27:10.643]                     else if (inherits(cond, "warning")) {
[10:27:10.643]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:10.643]                       if (muffled) 
[10:27:10.643]                         invokeRestart("muffleWarning")
[10:27:10.643]                     }
[10:27:10.643]                     else if (inherits(cond, "condition")) {
[10:27:10.643]                       if (!is.null(pattern)) {
[10:27:10.643]                         computeRestarts <- base::computeRestarts
[10:27:10.643]                         grepl <- base::grepl
[10:27:10.643]                         restarts <- computeRestarts(cond)
[10:27:10.643]                         for (restart in restarts) {
[10:27:10.643]                           name <- restart$name
[10:27:10.643]                           if (is.null(name)) 
[10:27:10.643]                             next
[10:27:10.643]                           if (!grepl(pattern, name)) 
[10:27:10.643]                             next
[10:27:10.643]                           invokeRestart(restart)
[10:27:10.643]                           muffled <- TRUE
[10:27:10.643]                           break
[10:27:10.643]                         }
[10:27:10.643]                       }
[10:27:10.643]                     }
[10:27:10.643]                     invisible(muffled)
[10:27:10.643]                   }
[10:27:10.643]                   muffleCondition(cond)
[10:27:10.643]                 })
[10:27:10.643]             }))
[10:27:10.643]             future::FutureResult(value = ...future.value$value, 
[10:27:10.643]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:10.643]                   ...future.rng), globalenv = if (FALSE) 
[10:27:10.643]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:10.643]                     ...future.globalenv.names))
[10:27:10.643]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:10.643]         }, condition = base::local({
[10:27:10.643]             c <- base::c
[10:27:10.643]             inherits <- base::inherits
[10:27:10.643]             invokeRestart <- base::invokeRestart
[10:27:10.643]             length <- base::length
[10:27:10.643]             list <- base::list
[10:27:10.643]             seq.int <- base::seq.int
[10:27:10.643]             signalCondition <- base::signalCondition
[10:27:10.643]             sys.calls <- base::sys.calls
[10:27:10.643]             `[[` <- base::`[[`
[10:27:10.643]             `+` <- base::`+`
[10:27:10.643]             `<<-` <- base::`<<-`
[10:27:10.643]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:10.643]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:10.643]                   3L)]
[10:27:10.643]             }
[10:27:10.643]             function(cond) {
[10:27:10.643]                 is_error <- inherits(cond, "error")
[10:27:10.643]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:10.643]                   NULL)
[10:27:10.643]                 if (is_error) {
[10:27:10.643]                   sessionInformation <- function() {
[10:27:10.643]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:10.643]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:10.643]                       search = base::search(), system = base::Sys.info())
[10:27:10.643]                   }
[10:27:10.643]                   ...future.conditions[[length(...future.conditions) + 
[10:27:10.643]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:10.643]                     cond$call), session = sessionInformation(), 
[10:27:10.643]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:10.643]                   signalCondition(cond)
[10:27:10.643]                 }
[10:27:10.643]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:10.643]                 "immediateCondition"))) {
[10:27:10.643]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:10.643]                   ...future.conditions[[length(...future.conditions) + 
[10:27:10.643]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:10.643]                   if (TRUE && !signal) {
[10:27:10.643]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:10.643]                     {
[10:27:10.643]                       inherits <- base::inherits
[10:27:10.643]                       invokeRestart <- base::invokeRestart
[10:27:10.643]                       is.null <- base::is.null
[10:27:10.643]                       muffled <- FALSE
[10:27:10.643]                       if (inherits(cond, "message")) {
[10:27:10.643]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:10.643]                         if (muffled) 
[10:27:10.643]                           invokeRestart("muffleMessage")
[10:27:10.643]                       }
[10:27:10.643]                       else if (inherits(cond, "warning")) {
[10:27:10.643]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:10.643]                         if (muffled) 
[10:27:10.643]                           invokeRestart("muffleWarning")
[10:27:10.643]                       }
[10:27:10.643]                       else if (inherits(cond, "condition")) {
[10:27:10.643]                         if (!is.null(pattern)) {
[10:27:10.643]                           computeRestarts <- base::computeRestarts
[10:27:10.643]                           grepl <- base::grepl
[10:27:10.643]                           restarts <- computeRestarts(cond)
[10:27:10.643]                           for (restart in restarts) {
[10:27:10.643]                             name <- restart$name
[10:27:10.643]                             if (is.null(name)) 
[10:27:10.643]                               next
[10:27:10.643]                             if (!grepl(pattern, name)) 
[10:27:10.643]                               next
[10:27:10.643]                             invokeRestart(restart)
[10:27:10.643]                             muffled <- TRUE
[10:27:10.643]                             break
[10:27:10.643]                           }
[10:27:10.643]                         }
[10:27:10.643]                       }
[10:27:10.643]                       invisible(muffled)
[10:27:10.643]                     }
[10:27:10.643]                     muffleCondition(cond, pattern = "^muffle")
[10:27:10.643]                   }
[10:27:10.643]                 }
[10:27:10.643]                 else {
[10:27:10.643]                   if (TRUE) {
[10:27:10.643]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:10.643]                     {
[10:27:10.643]                       inherits <- base::inherits
[10:27:10.643]                       invokeRestart <- base::invokeRestart
[10:27:10.643]                       is.null <- base::is.null
[10:27:10.643]                       muffled <- FALSE
[10:27:10.643]                       if (inherits(cond, "message")) {
[10:27:10.643]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:10.643]                         if (muffled) 
[10:27:10.643]                           invokeRestart("muffleMessage")
[10:27:10.643]                       }
[10:27:10.643]                       else if (inherits(cond, "warning")) {
[10:27:10.643]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:10.643]                         if (muffled) 
[10:27:10.643]                           invokeRestart("muffleWarning")
[10:27:10.643]                       }
[10:27:10.643]                       else if (inherits(cond, "condition")) {
[10:27:10.643]                         if (!is.null(pattern)) {
[10:27:10.643]                           computeRestarts <- base::computeRestarts
[10:27:10.643]                           grepl <- base::grepl
[10:27:10.643]                           restarts <- computeRestarts(cond)
[10:27:10.643]                           for (restart in restarts) {
[10:27:10.643]                             name <- restart$name
[10:27:10.643]                             if (is.null(name)) 
[10:27:10.643]                               next
[10:27:10.643]                             if (!grepl(pattern, name)) 
[10:27:10.643]                               next
[10:27:10.643]                             invokeRestart(restart)
[10:27:10.643]                             muffled <- TRUE
[10:27:10.643]                             break
[10:27:10.643]                           }
[10:27:10.643]                         }
[10:27:10.643]                       }
[10:27:10.643]                       invisible(muffled)
[10:27:10.643]                     }
[10:27:10.643]                     muffleCondition(cond, pattern = "^muffle")
[10:27:10.643]                   }
[10:27:10.643]                 }
[10:27:10.643]             }
[10:27:10.643]         }))
[10:27:10.643]     }, error = function(ex) {
[10:27:10.643]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:10.643]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:10.643]                 ...future.rng), started = ...future.startTime, 
[10:27:10.643]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:10.643]             version = "1.8"), class = "FutureResult")
[10:27:10.643]     }, finally = {
[10:27:10.643]         if (!identical(...future.workdir, getwd())) 
[10:27:10.643]             setwd(...future.workdir)
[10:27:10.643]         {
[10:27:10.643]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:10.643]                 ...future.oldOptions$nwarnings <- NULL
[10:27:10.643]             }
[10:27:10.643]             base::options(...future.oldOptions)
[10:27:10.643]             if (.Platform$OS.type == "windows") {
[10:27:10.643]                 old_names <- names(...future.oldEnvVars)
[10:27:10.643]                 envs <- base::Sys.getenv()
[10:27:10.643]                 names <- names(envs)
[10:27:10.643]                 common <- intersect(names, old_names)
[10:27:10.643]                 added <- setdiff(names, old_names)
[10:27:10.643]                 removed <- setdiff(old_names, names)
[10:27:10.643]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:10.643]                   envs[common]]
[10:27:10.643]                 NAMES <- toupper(changed)
[10:27:10.643]                 args <- list()
[10:27:10.643]                 for (kk in seq_along(NAMES)) {
[10:27:10.643]                   name <- changed[[kk]]
[10:27:10.643]                   NAME <- NAMES[[kk]]
[10:27:10.643]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:10.643]                     next
[10:27:10.643]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:10.643]                 }
[10:27:10.643]                 NAMES <- toupper(added)
[10:27:10.643]                 for (kk in seq_along(NAMES)) {
[10:27:10.643]                   name <- added[[kk]]
[10:27:10.643]                   NAME <- NAMES[[kk]]
[10:27:10.643]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:10.643]                     next
[10:27:10.643]                   args[[name]] <- ""
[10:27:10.643]                 }
[10:27:10.643]                 NAMES <- toupper(removed)
[10:27:10.643]                 for (kk in seq_along(NAMES)) {
[10:27:10.643]                   name <- removed[[kk]]
[10:27:10.643]                   NAME <- NAMES[[kk]]
[10:27:10.643]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:10.643]                     next
[10:27:10.643]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:10.643]                 }
[10:27:10.643]                 if (length(args) > 0) 
[10:27:10.643]                   base::do.call(base::Sys.setenv, args = args)
[10:27:10.643]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:10.643]             }
[10:27:10.643]             else {
[10:27:10.643]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:10.643]             }
[10:27:10.643]             {
[10:27:10.643]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:10.643]                   0L) {
[10:27:10.643]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:10.643]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:10.643]                   base::options(opts)
[10:27:10.643]                 }
[10:27:10.643]                 {
[10:27:10.643]                   {
[10:27:10.643]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:10.643]                     NULL
[10:27:10.643]                   }
[10:27:10.643]                   options(future.plan = NULL)
[10:27:10.643]                   if (is.na(NA_character_)) 
[10:27:10.643]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:10.643]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:10.643]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:10.643]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:10.643]                     envir = parent.frame()) 
[10:27:10.643]                   {
[10:27:10.643]                     if (is.function(workers)) 
[10:27:10.643]                       workers <- workers()
[10:27:10.643]                     workers <- structure(as.integer(workers), 
[10:27:10.643]                       class = class(workers))
[10:27:10.643]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:10.643]                       workers >= 1)
[10:27:10.643]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:10.643]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:10.643]                     }
[10:27:10.643]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:10.643]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:10.643]                       envir = envir)
[10:27:10.643]                     if (!future$lazy) 
[10:27:10.643]                       future <- run(future)
[10:27:10.643]                     invisible(future)
[10:27:10.643]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:10.643]                 }
[10:27:10.643]             }
[10:27:10.643]         }
[10:27:10.643]     })
[10:27:10.643]     if (TRUE) {
[10:27:10.643]         base::sink(type = "output", split = FALSE)
[10:27:10.643]         if (TRUE) {
[10:27:10.643]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:10.643]         }
[10:27:10.643]         else {
[10:27:10.643]             ...future.result["stdout"] <- base::list(NULL)
[10:27:10.643]         }
[10:27:10.643]         base::close(...future.stdout)
[10:27:10.643]         ...future.stdout <- NULL
[10:27:10.643]     }
[10:27:10.643]     ...future.result$conditions <- ...future.conditions
[10:27:10.643]     ...future.result$finished <- base::Sys.time()
[10:27:10.643]     ...future.result
[10:27:10.643] }
[10:27:10.646] MultisessionFuture started
[10:27:10.646] - Launch lazy future ... done
[10:27:10.646] run() for ‘MultisessionFuture’ ... done
[10:27:11.206] receiveMessageFromWorker() for ClusterFuture ...
[10:27:11.206] - Validating connection of MultisessionFuture
[10:27:11.206] - received message: FutureResult
[10:27:11.207] - Received FutureResult
[10:27:11.207] - Erased future from FutureRegistry
[10:27:11.207] result() for ClusterFuture ...
[10:27:11.207] - result already collected: FutureResult
[10:27:11.207] result() for ClusterFuture ... done
[10:27:11.207] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:11.207] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[10:27:11.208] getGlobalsAndPackages() ...
[10:27:11.208] Searching for globals...
[10:27:11.208] - globals found: [2] ‘list’, ‘stop’
[10:27:11.209] Searching for globals ... DONE
[10:27:11.209] Resolving globals: FALSE
[10:27:11.209] 
[10:27:11.209] 
[10:27:11.209] getGlobalsAndPackages() ... DONE
[10:27:11.209] run() for ‘Future’ ...
[10:27:11.210] - state: ‘created’
[10:27:11.210] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:11.224] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:11.224] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:11.224]   - Field: ‘node’
[10:27:11.224]   - Field: ‘label’
[10:27:11.225]   - Field: ‘local’
[10:27:11.225]   - Field: ‘owner’
[10:27:11.225]   - Field: ‘envir’
[10:27:11.225]   - Field: ‘workers’
[10:27:11.225]   - Field: ‘packages’
[10:27:11.225]   - Field: ‘gc’
[10:27:11.225]   - Field: ‘conditions’
[10:27:11.225]   - Field: ‘persistent’
[10:27:11.225]   - Field: ‘expr’
[10:27:11.225]   - Field: ‘uuid’
[10:27:11.225]   - Field: ‘seed’
[10:27:11.226]   - Field: ‘version’
[10:27:11.226]   - Field: ‘result’
[10:27:11.226]   - Field: ‘asynchronous’
[10:27:11.226]   - Field: ‘calls’
[10:27:11.226]   - Field: ‘globals’
[10:27:11.226]   - Field: ‘stdout’
[10:27:11.226]   - Field: ‘earlySignal’
[10:27:11.226]   - Field: ‘lazy’
[10:27:11.226]   - Field: ‘state’
[10:27:11.226] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:11.227] - Launch lazy future ...
[10:27:11.227] Packages needed by the future expression (n = 0): <none>
[10:27:11.227] Packages needed by future strategies (n = 0): <none>
[10:27:11.227] {
[10:27:11.227]     {
[10:27:11.227]         {
[10:27:11.227]             ...future.startTime <- base::Sys.time()
[10:27:11.227]             {
[10:27:11.227]                 {
[10:27:11.227]                   {
[10:27:11.227]                     {
[10:27:11.227]                       base::local({
[10:27:11.227]                         has_future <- base::requireNamespace("future", 
[10:27:11.227]                           quietly = TRUE)
[10:27:11.227]                         if (has_future) {
[10:27:11.227]                           ns <- base::getNamespace("future")
[10:27:11.227]                           version <- ns[[".package"]][["version"]]
[10:27:11.227]                           if (is.null(version)) 
[10:27:11.227]                             version <- utils::packageVersion("future")
[10:27:11.227]                         }
[10:27:11.227]                         else {
[10:27:11.227]                           version <- NULL
[10:27:11.227]                         }
[10:27:11.227]                         if (!has_future || version < "1.8.0") {
[10:27:11.227]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:11.227]                             "", base::R.version$version.string), 
[10:27:11.227]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:11.227]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:11.227]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:11.227]                               "release", "version")], collapse = " "), 
[10:27:11.227]                             hostname = base::Sys.info()[["nodename"]])
[10:27:11.227]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:11.227]                             info)
[10:27:11.227]                           info <- base::paste(info, collapse = "; ")
[10:27:11.227]                           if (!has_future) {
[10:27:11.227]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:11.227]                               info)
[10:27:11.227]                           }
[10:27:11.227]                           else {
[10:27:11.227]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:11.227]                               info, version)
[10:27:11.227]                           }
[10:27:11.227]                           base::stop(msg)
[10:27:11.227]                         }
[10:27:11.227]                       })
[10:27:11.227]                     }
[10:27:11.227]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:11.227]                     base::options(mc.cores = 1L)
[10:27:11.227]                   }
[10:27:11.227]                   options(future.plan = NULL)
[10:27:11.227]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:11.227]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:11.227]                 }
[10:27:11.227]                 ...future.workdir <- getwd()
[10:27:11.227]             }
[10:27:11.227]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:11.227]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:11.227]         }
[10:27:11.227]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:11.227]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:11.227]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:11.227]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:11.227]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:11.227]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:11.227]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:11.227]             base::names(...future.oldOptions))
[10:27:11.227]     }
[10:27:11.227]     if (FALSE) {
[10:27:11.227]     }
[10:27:11.227]     else {
[10:27:11.227]         if (TRUE) {
[10:27:11.227]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:11.227]                 open = "w")
[10:27:11.227]         }
[10:27:11.227]         else {
[10:27:11.227]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:11.227]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:11.227]         }
[10:27:11.227]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:11.227]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:11.227]             base::sink(type = "output", split = FALSE)
[10:27:11.227]             base::close(...future.stdout)
[10:27:11.227]         }, add = TRUE)
[10:27:11.227]     }
[10:27:11.227]     ...future.frame <- base::sys.nframe()
[10:27:11.227]     ...future.conditions <- base::list()
[10:27:11.227]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:11.227]     if (FALSE) {
[10:27:11.227]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:11.227]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:11.227]     }
[10:27:11.227]     ...future.result <- base::tryCatch({
[10:27:11.227]         base::withCallingHandlers({
[10:27:11.227]             ...future.value <- base::withVisible(base::local({
[10:27:11.227]                 ...future.makeSendCondition <- base::local({
[10:27:11.227]                   sendCondition <- NULL
[10:27:11.227]                   function(frame = 1L) {
[10:27:11.227]                     if (is.function(sendCondition)) 
[10:27:11.227]                       return(sendCondition)
[10:27:11.227]                     ns <- getNamespace("parallel")
[10:27:11.227]                     if (exists("sendData", mode = "function", 
[10:27:11.227]                       envir = ns)) {
[10:27:11.227]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:11.227]                         envir = ns)
[10:27:11.227]                       envir <- sys.frame(frame)
[10:27:11.227]                       master <- NULL
[10:27:11.227]                       while (!identical(envir, .GlobalEnv) && 
[10:27:11.227]                         !identical(envir, emptyenv())) {
[10:27:11.227]                         if (exists("master", mode = "list", envir = envir, 
[10:27:11.227]                           inherits = FALSE)) {
[10:27:11.227]                           master <- get("master", mode = "list", 
[10:27:11.227]                             envir = envir, inherits = FALSE)
[10:27:11.227]                           if (inherits(master, c("SOCKnode", 
[10:27:11.227]                             "SOCK0node"))) {
[10:27:11.227]                             sendCondition <<- function(cond) {
[10:27:11.227]                               data <- list(type = "VALUE", value = cond, 
[10:27:11.227]                                 success = TRUE)
[10:27:11.227]                               parallel_sendData(master, data)
[10:27:11.227]                             }
[10:27:11.227]                             return(sendCondition)
[10:27:11.227]                           }
[10:27:11.227]                         }
[10:27:11.227]                         frame <- frame + 1L
[10:27:11.227]                         envir <- sys.frame(frame)
[10:27:11.227]                       }
[10:27:11.227]                     }
[10:27:11.227]                     sendCondition <<- function(cond) NULL
[10:27:11.227]                   }
[10:27:11.227]                 })
[10:27:11.227]                 withCallingHandlers({
[10:27:11.227]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:27:11.227]                 }, immediateCondition = function(cond) {
[10:27:11.227]                   sendCondition <- ...future.makeSendCondition()
[10:27:11.227]                   sendCondition(cond)
[10:27:11.227]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:11.227]                   {
[10:27:11.227]                     inherits <- base::inherits
[10:27:11.227]                     invokeRestart <- base::invokeRestart
[10:27:11.227]                     is.null <- base::is.null
[10:27:11.227]                     muffled <- FALSE
[10:27:11.227]                     if (inherits(cond, "message")) {
[10:27:11.227]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:11.227]                       if (muffled) 
[10:27:11.227]                         invokeRestart("muffleMessage")
[10:27:11.227]                     }
[10:27:11.227]                     else if (inherits(cond, "warning")) {
[10:27:11.227]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:11.227]                       if (muffled) 
[10:27:11.227]                         invokeRestart("muffleWarning")
[10:27:11.227]                     }
[10:27:11.227]                     else if (inherits(cond, "condition")) {
[10:27:11.227]                       if (!is.null(pattern)) {
[10:27:11.227]                         computeRestarts <- base::computeRestarts
[10:27:11.227]                         grepl <- base::grepl
[10:27:11.227]                         restarts <- computeRestarts(cond)
[10:27:11.227]                         for (restart in restarts) {
[10:27:11.227]                           name <- restart$name
[10:27:11.227]                           if (is.null(name)) 
[10:27:11.227]                             next
[10:27:11.227]                           if (!grepl(pattern, name)) 
[10:27:11.227]                             next
[10:27:11.227]                           invokeRestart(restart)
[10:27:11.227]                           muffled <- TRUE
[10:27:11.227]                           break
[10:27:11.227]                         }
[10:27:11.227]                       }
[10:27:11.227]                     }
[10:27:11.227]                     invisible(muffled)
[10:27:11.227]                   }
[10:27:11.227]                   muffleCondition(cond)
[10:27:11.227]                 })
[10:27:11.227]             }))
[10:27:11.227]             future::FutureResult(value = ...future.value$value, 
[10:27:11.227]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:11.227]                   ...future.rng), globalenv = if (FALSE) 
[10:27:11.227]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:11.227]                     ...future.globalenv.names))
[10:27:11.227]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:11.227]         }, condition = base::local({
[10:27:11.227]             c <- base::c
[10:27:11.227]             inherits <- base::inherits
[10:27:11.227]             invokeRestart <- base::invokeRestart
[10:27:11.227]             length <- base::length
[10:27:11.227]             list <- base::list
[10:27:11.227]             seq.int <- base::seq.int
[10:27:11.227]             signalCondition <- base::signalCondition
[10:27:11.227]             sys.calls <- base::sys.calls
[10:27:11.227]             `[[` <- base::`[[`
[10:27:11.227]             `+` <- base::`+`
[10:27:11.227]             `<<-` <- base::`<<-`
[10:27:11.227]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:11.227]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:11.227]                   3L)]
[10:27:11.227]             }
[10:27:11.227]             function(cond) {
[10:27:11.227]                 is_error <- inherits(cond, "error")
[10:27:11.227]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:11.227]                   NULL)
[10:27:11.227]                 if (is_error) {
[10:27:11.227]                   sessionInformation <- function() {
[10:27:11.227]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:11.227]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:11.227]                       search = base::search(), system = base::Sys.info())
[10:27:11.227]                   }
[10:27:11.227]                   ...future.conditions[[length(...future.conditions) + 
[10:27:11.227]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:11.227]                     cond$call), session = sessionInformation(), 
[10:27:11.227]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:11.227]                   signalCondition(cond)
[10:27:11.227]                 }
[10:27:11.227]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:11.227]                 "immediateCondition"))) {
[10:27:11.227]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:11.227]                   ...future.conditions[[length(...future.conditions) + 
[10:27:11.227]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:11.227]                   if (TRUE && !signal) {
[10:27:11.227]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:11.227]                     {
[10:27:11.227]                       inherits <- base::inherits
[10:27:11.227]                       invokeRestart <- base::invokeRestart
[10:27:11.227]                       is.null <- base::is.null
[10:27:11.227]                       muffled <- FALSE
[10:27:11.227]                       if (inherits(cond, "message")) {
[10:27:11.227]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:11.227]                         if (muffled) 
[10:27:11.227]                           invokeRestart("muffleMessage")
[10:27:11.227]                       }
[10:27:11.227]                       else if (inherits(cond, "warning")) {
[10:27:11.227]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:11.227]                         if (muffled) 
[10:27:11.227]                           invokeRestart("muffleWarning")
[10:27:11.227]                       }
[10:27:11.227]                       else if (inherits(cond, "condition")) {
[10:27:11.227]                         if (!is.null(pattern)) {
[10:27:11.227]                           computeRestarts <- base::computeRestarts
[10:27:11.227]                           grepl <- base::grepl
[10:27:11.227]                           restarts <- computeRestarts(cond)
[10:27:11.227]                           for (restart in restarts) {
[10:27:11.227]                             name <- restart$name
[10:27:11.227]                             if (is.null(name)) 
[10:27:11.227]                               next
[10:27:11.227]                             if (!grepl(pattern, name)) 
[10:27:11.227]                               next
[10:27:11.227]                             invokeRestart(restart)
[10:27:11.227]                             muffled <- TRUE
[10:27:11.227]                             break
[10:27:11.227]                           }
[10:27:11.227]                         }
[10:27:11.227]                       }
[10:27:11.227]                       invisible(muffled)
[10:27:11.227]                     }
[10:27:11.227]                     muffleCondition(cond, pattern = "^muffle")
[10:27:11.227]                   }
[10:27:11.227]                 }
[10:27:11.227]                 else {
[10:27:11.227]                   if (TRUE) {
[10:27:11.227]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:11.227]                     {
[10:27:11.227]                       inherits <- base::inherits
[10:27:11.227]                       invokeRestart <- base::invokeRestart
[10:27:11.227]                       is.null <- base::is.null
[10:27:11.227]                       muffled <- FALSE
[10:27:11.227]                       if (inherits(cond, "message")) {
[10:27:11.227]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:11.227]                         if (muffled) 
[10:27:11.227]                           invokeRestart("muffleMessage")
[10:27:11.227]                       }
[10:27:11.227]                       else if (inherits(cond, "warning")) {
[10:27:11.227]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:11.227]                         if (muffled) 
[10:27:11.227]                           invokeRestart("muffleWarning")
[10:27:11.227]                       }
[10:27:11.227]                       else if (inherits(cond, "condition")) {
[10:27:11.227]                         if (!is.null(pattern)) {
[10:27:11.227]                           computeRestarts <- base::computeRestarts
[10:27:11.227]                           grepl <- base::grepl
[10:27:11.227]                           restarts <- computeRestarts(cond)
[10:27:11.227]                           for (restart in restarts) {
[10:27:11.227]                             name <- restart$name
[10:27:11.227]                             if (is.null(name)) 
[10:27:11.227]                               next
[10:27:11.227]                             if (!grepl(pattern, name)) 
[10:27:11.227]                               next
[10:27:11.227]                             invokeRestart(restart)
[10:27:11.227]                             muffled <- TRUE
[10:27:11.227]                             break
[10:27:11.227]                           }
[10:27:11.227]                         }
[10:27:11.227]                       }
[10:27:11.227]                       invisible(muffled)
[10:27:11.227]                     }
[10:27:11.227]                     muffleCondition(cond, pattern = "^muffle")
[10:27:11.227]                   }
[10:27:11.227]                 }
[10:27:11.227]             }
[10:27:11.227]         }))
[10:27:11.227]     }, error = function(ex) {
[10:27:11.227]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:11.227]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:11.227]                 ...future.rng), started = ...future.startTime, 
[10:27:11.227]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:11.227]             version = "1.8"), class = "FutureResult")
[10:27:11.227]     }, finally = {
[10:27:11.227]         if (!identical(...future.workdir, getwd())) 
[10:27:11.227]             setwd(...future.workdir)
[10:27:11.227]         {
[10:27:11.227]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:11.227]                 ...future.oldOptions$nwarnings <- NULL
[10:27:11.227]             }
[10:27:11.227]             base::options(...future.oldOptions)
[10:27:11.227]             if (.Platform$OS.type == "windows") {
[10:27:11.227]                 old_names <- names(...future.oldEnvVars)
[10:27:11.227]                 envs <- base::Sys.getenv()
[10:27:11.227]                 names <- names(envs)
[10:27:11.227]                 common <- intersect(names, old_names)
[10:27:11.227]                 added <- setdiff(names, old_names)
[10:27:11.227]                 removed <- setdiff(old_names, names)
[10:27:11.227]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:11.227]                   envs[common]]
[10:27:11.227]                 NAMES <- toupper(changed)
[10:27:11.227]                 args <- list()
[10:27:11.227]                 for (kk in seq_along(NAMES)) {
[10:27:11.227]                   name <- changed[[kk]]
[10:27:11.227]                   NAME <- NAMES[[kk]]
[10:27:11.227]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:11.227]                     next
[10:27:11.227]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:11.227]                 }
[10:27:11.227]                 NAMES <- toupper(added)
[10:27:11.227]                 for (kk in seq_along(NAMES)) {
[10:27:11.227]                   name <- added[[kk]]
[10:27:11.227]                   NAME <- NAMES[[kk]]
[10:27:11.227]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:11.227]                     next
[10:27:11.227]                   args[[name]] <- ""
[10:27:11.227]                 }
[10:27:11.227]                 NAMES <- toupper(removed)
[10:27:11.227]                 for (kk in seq_along(NAMES)) {
[10:27:11.227]                   name <- removed[[kk]]
[10:27:11.227]                   NAME <- NAMES[[kk]]
[10:27:11.227]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:11.227]                     next
[10:27:11.227]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:11.227]                 }
[10:27:11.227]                 if (length(args) > 0) 
[10:27:11.227]                   base::do.call(base::Sys.setenv, args = args)
[10:27:11.227]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:11.227]             }
[10:27:11.227]             else {
[10:27:11.227]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:11.227]             }
[10:27:11.227]             {
[10:27:11.227]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:11.227]                   0L) {
[10:27:11.227]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:11.227]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:11.227]                   base::options(opts)
[10:27:11.227]                 }
[10:27:11.227]                 {
[10:27:11.227]                   {
[10:27:11.227]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:11.227]                     NULL
[10:27:11.227]                   }
[10:27:11.227]                   options(future.plan = NULL)
[10:27:11.227]                   if (is.na(NA_character_)) 
[10:27:11.227]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:11.227]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:11.227]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:11.227]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:11.227]                     envir = parent.frame()) 
[10:27:11.227]                   {
[10:27:11.227]                     if (is.function(workers)) 
[10:27:11.227]                       workers <- workers()
[10:27:11.227]                     workers <- structure(as.integer(workers), 
[10:27:11.227]                       class = class(workers))
[10:27:11.227]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:11.227]                       workers >= 1)
[10:27:11.227]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:11.227]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:11.227]                     }
[10:27:11.227]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:11.227]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:11.227]                       envir = envir)
[10:27:11.227]                     if (!future$lazy) 
[10:27:11.227]                       future <- run(future)
[10:27:11.227]                     invisible(future)
[10:27:11.227]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:11.227]                 }
[10:27:11.227]             }
[10:27:11.227]         }
[10:27:11.227]     })
[10:27:11.227]     if (TRUE) {
[10:27:11.227]         base::sink(type = "output", split = FALSE)
[10:27:11.227]         if (TRUE) {
[10:27:11.227]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:11.227]         }
[10:27:11.227]         else {
[10:27:11.227]             ...future.result["stdout"] <- base::list(NULL)
[10:27:11.227]         }
[10:27:11.227]         base::close(...future.stdout)
[10:27:11.227]         ...future.stdout <- NULL
[10:27:11.227]     }
[10:27:11.227]     ...future.result$conditions <- ...future.conditions
[10:27:11.227]     ...future.result$finished <- base::Sys.time()
[10:27:11.227]     ...future.result
[10:27:11.227] }
[10:27:11.231] MultisessionFuture started
[10:27:11.231] - Launch lazy future ... done
[10:27:11.231] run() for ‘MultisessionFuture’ ... done
[10:27:11.279] receiveMessageFromWorker() for ClusterFuture ...
[10:27:11.279] - Validating connection of MultisessionFuture
[10:27:11.280] - received message: FutureResult
[10:27:11.280] - Received FutureResult
[10:27:11.280] - Erased future from FutureRegistry
[10:27:11.280] result() for ClusterFuture ...
[10:27:11.280] - result already collected: FutureResult
[10:27:11.280] result() for ClusterFuture ... done
[10:27:11.280] signalConditions() ...
[10:27:11.281]  - include = ‘immediateCondition’
[10:27:11.281]  - exclude = 
[10:27:11.281]  - resignal = FALSE
[10:27:11.281]  - Number of conditions: 1
[10:27:11.281] signalConditions() ... done
[10:27:11.281] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:11.281] A MultisessionFuture was resolved (result was not collected)
[10:27:11.281] getGlobalsAndPackages() ...
[10:27:11.281] Searching for globals...
[10:27:11.282] - globals found: [2] ‘list’, ‘stop’
[10:27:11.282] Searching for globals ... DONE
[10:27:11.282] Resolving globals: FALSE
[10:27:11.283] 
[10:27:11.283] 
[10:27:11.283] getGlobalsAndPackages() ... DONE
[10:27:11.283] run() for ‘Future’ ...
[10:27:11.283] - state: ‘created’
[10:27:11.283] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:11.298] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:11.298] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:11.298]   - Field: ‘node’
[10:27:11.298]   - Field: ‘label’
[10:27:11.298]   - Field: ‘local’
[10:27:11.298]   - Field: ‘owner’
[10:27:11.298]   - Field: ‘envir’
[10:27:11.298]   - Field: ‘workers’
[10:27:11.298]   - Field: ‘packages’
[10:27:11.299]   - Field: ‘gc’
[10:27:11.299]   - Field: ‘conditions’
[10:27:11.299]   - Field: ‘persistent’
[10:27:11.299]   - Field: ‘expr’
[10:27:11.299]   - Field: ‘uuid’
[10:27:11.299]   - Field: ‘seed’
[10:27:11.299]   - Field: ‘version’
[10:27:11.299]   - Field: ‘result’
[10:27:11.299]   - Field: ‘asynchronous’
[10:27:11.299]   - Field: ‘calls’
[10:27:11.299]   - Field: ‘globals’
[10:27:11.300]   - Field: ‘stdout’
[10:27:11.300]   - Field: ‘earlySignal’
[10:27:11.300]   - Field: ‘lazy’
[10:27:11.300]   - Field: ‘state’
[10:27:11.300] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:11.300] - Launch lazy future ...
[10:27:11.300] Packages needed by the future expression (n = 0): <none>
[10:27:11.300] Packages needed by future strategies (n = 0): <none>
[10:27:11.301] {
[10:27:11.301]     {
[10:27:11.301]         {
[10:27:11.301]             ...future.startTime <- base::Sys.time()
[10:27:11.301]             {
[10:27:11.301]                 {
[10:27:11.301]                   {
[10:27:11.301]                     {
[10:27:11.301]                       base::local({
[10:27:11.301]                         has_future <- base::requireNamespace("future", 
[10:27:11.301]                           quietly = TRUE)
[10:27:11.301]                         if (has_future) {
[10:27:11.301]                           ns <- base::getNamespace("future")
[10:27:11.301]                           version <- ns[[".package"]][["version"]]
[10:27:11.301]                           if (is.null(version)) 
[10:27:11.301]                             version <- utils::packageVersion("future")
[10:27:11.301]                         }
[10:27:11.301]                         else {
[10:27:11.301]                           version <- NULL
[10:27:11.301]                         }
[10:27:11.301]                         if (!has_future || version < "1.8.0") {
[10:27:11.301]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:11.301]                             "", base::R.version$version.string), 
[10:27:11.301]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:11.301]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:11.301]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:11.301]                               "release", "version")], collapse = " "), 
[10:27:11.301]                             hostname = base::Sys.info()[["nodename"]])
[10:27:11.301]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:11.301]                             info)
[10:27:11.301]                           info <- base::paste(info, collapse = "; ")
[10:27:11.301]                           if (!has_future) {
[10:27:11.301]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:11.301]                               info)
[10:27:11.301]                           }
[10:27:11.301]                           else {
[10:27:11.301]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:11.301]                               info, version)
[10:27:11.301]                           }
[10:27:11.301]                           base::stop(msg)
[10:27:11.301]                         }
[10:27:11.301]                       })
[10:27:11.301]                     }
[10:27:11.301]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:11.301]                     base::options(mc.cores = 1L)
[10:27:11.301]                   }
[10:27:11.301]                   options(future.plan = NULL)
[10:27:11.301]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:11.301]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:11.301]                 }
[10:27:11.301]                 ...future.workdir <- getwd()
[10:27:11.301]             }
[10:27:11.301]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:11.301]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:11.301]         }
[10:27:11.301]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:11.301]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:11.301]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:11.301]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:11.301]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:11.301]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:11.301]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:11.301]             base::names(...future.oldOptions))
[10:27:11.301]     }
[10:27:11.301]     if (FALSE) {
[10:27:11.301]     }
[10:27:11.301]     else {
[10:27:11.301]         if (TRUE) {
[10:27:11.301]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:11.301]                 open = "w")
[10:27:11.301]         }
[10:27:11.301]         else {
[10:27:11.301]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:11.301]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:11.301]         }
[10:27:11.301]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:11.301]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:11.301]             base::sink(type = "output", split = FALSE)
[10:27:11.301]             base::close(...future.stdout)
[10:27:11.301]         }, add = TRUE)
[10:27:11.301]     }
[10:27:11.301]     ...future.frame <- base::sys.nframe()
[10:27:11.301]     ...future.conditions <- base::list()
[10:27:11.301]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:11.301]     if (FALSE) {
[10:27:11.301]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:11.301]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:11.301]     }
[10:27:11.301]     ...future.result <- base::tryCatch({
[10:27:11.301]         base::withCallingHandlers({
[10:27:11.301]             ...future.value <- base::withVisible(base::local({
[10:27:11.301]                 ...future.makeSendCondition <- base::local({
[10:27:11.301]                   sendCondition <- NULL
[10:27:11.301]                   function(frame = 1L) {
[10:27:11.301]                     if (is.function(sendCondition)) 
[10:27:11.301]                       return(sendCondition)
[10:27:11.301]                     ns <- getNamespace("parallel")
[10:27:11.301]                     if (exists("sendData", mode = "function", 
[10:27:11.301]                       envir = ns)) {
[10:27:11.301]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:11.301]                         envir = ns)
[10:27:11.301]                       envir <- sys.frame(frame)
[10:27:11.301]                       master <- NULL
[10:27:11.301]                       while (!identical(envir, .GlobalEnv) && 
[10:27:11.301]                         !identical(envir, emptyenv())) {
[10:27:11.301]                         if (exists("master", mode = "list", envir = envir, 
[10:27:11.301]                           inherits = FALSE)) {
[10:27:11.301]                           master <- get("master", mode = "list", 
[10:27:11.301]                             envir = envir, inherits = FALSE)
[10:27:11.301]                           if (inherits(master, c("SOCKnode", 
[10:27:11.301]                             "SOCK0node"))) {
[10:27:11.301]                             sendCondition <<- function(cond) {
[10:27:11.301]                               data <- list(type = "VALUE", value = cond, 
[10:27:11.301]                                 success = TRUE)
[10:27:11.301]                               parallel_sendData(master, data)
[10:27:11.301]                             }
[10:27:11.301]                             return(sendCondition)
[10:27:11.301]                           }
[10:27:11.301]                         }
[10:27:11.301]                         frame <- frame + 1L
[10:27:11.301]                         envir <- sys.frame(frame)
[10:27:11.301]                       }
[10:27:11.301]                     }
[10:27:11.301]                     sendCondition <<- function(cond) NULL
[10:27:11.301]                   }
[10:27:11.301]                 })
[10:27:11.301]                 withCallingHandlers({
[10:27:11.301]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:27:11.301]                 }, immediateCondition = function(cond) {
[10:27:11.301]                   sendCondition <- ...future.makeSendCondition()
[10:27:11.301]                   sendCondition(cond)
[10:27:11.301]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:11.301]                   {
[10:27:11.301]                     inherits <- base::inherits
[10:27:11.301]                     invokeRestart <- base::invokeRestart
[10:27:11.301]                     is.null <- base::is.null
[10:27:11.301]                     muffled <- FALSE
[10:27:11.301]                     if (inherits(cond, "message")) {
[10:27:11.301]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:11.301]                       if (muffled) 
[10:27:11.301]                         invokeRestart("muffleMessage")
[10:27:11.301]                     }
[10:27:11.301]                     else if (inherits(cond, "warning")) {
[10:27:11.301]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:11.301]                       if (muffled) 
[10:27:11.301]                         invokeRestart("muffleWarning")
[10:27:11.301]                     }
[10:27:11.301]                     else if (inherits(cond, "condition")) {
[10:27:11.301]                       if (!is.null(pattern)) {
[10:27:11.301]                         computeRestarts <- base::computeRestarts
[10:27:11.301]                         grepl <- base::grepl
[10:27:11.301]                         restarts <- computeRestarts(cond)
[10:27:11.301]                         for (restart in restarts) {
[10:27:11.301]                           name <- restart$name
[10:27:11.301]                           if (is.null(name)) 
[10:27:11.301]                             next
[10:27:11.301]                           if (!grepl(pattern, name)) 
[10:27:11.301]                             next
[10:27:11.301]                           invokeRestart(restart)
[10:27:11.301]                           muffled <- TRUE
[10:27:11.301]                           break
[10:27:11.301]                         }
[10:27:11.301]                       }
[10:27:11.301]                     }
[10:27:11.301]                     invisible(muffled)
[10:27:11.301]                   }
[10:27:11.301]                   muffleCondition(cond)
[10:27:11.301]                 })
[10:27:11.301]             }))
[10:27:11.301]             future::FutureResult(value = ...future.value$value, 
[10:27:11.301]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:11.301]                   ...future.rng), globalenv = if (FALSE) 
[10:27:11.301]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:11.301]                     ...future.globalenv.names))
[10:27:11.301]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:11.301]         }, condition = base::local({
[10:27:11.301]             c <- base::c
[10:27:11.301]             inherits <- base::inherits
[10:27:11.301]             invokeRestart <- base::invokeRestart
[10:27:11.301]             length <- base::length
[10:27:11.301]             list <- base::list
[10:27:11.301]             seq.int <- base::seq.int
[10:27:11.301]             signalCondition <- base::signalCondition
[10:27:11.301]             sys.calls <- base::sys.calls
[10:27:11.301]             `[[` <- base::`[[`
[10:27:11.301]             `+` <- base::`+`
[10:27:11.301]             `<<-` <- base::`<<-`
[10:27:11.301]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:11.301]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:11.301]                   3L)]
[10:27:11.301]             }
[10:27:11.301]             function(cond) {
[10:27:11.301]                 is_error <- inherits(cond, "error")
[10:27:11.301]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:11.301]                   NULL)
[10:27:11.301]                 if (is_error) {
[10:27:11.301]                   sessionInformation <- function() {
[10:27:11.301]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:11.301]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:11.301]                       search = base::search(), system = base::Sys.info())
[10:27:11.301]                   }
[10:27:11.301]                   ...future.conditions[[length(...future.conditions) + 
[10:27:11.301]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:11.301]                     cond$call), session = sessionInformation(), 
[10:27:11.301]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:11.301]                   signalCondition(cond)
[10:27:11.301]                 }
[10:27:11.301]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:11.301]                 "immediateCondition"))) {
[10:27:11.301]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:11.301]                   ...future.conditions[[length(...future.conditions) + 
[10:27:11.301]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:11.301]                   if (TRUE && !signal) {
[10:27:11.301]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:11.301]                     {
[10:27:11.301]                       inherits <- base::inherits
[10:27:11.301]                       invokeRestart <- base::invokeRestart
[10:27:11.301]                       is.null <- base::is.null
[10:27:11.301]                       muffled <- FALSE
[10:27:11.301]                       if (inherits(cond, "message")) {
[10:27:11.301]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:11.301]                         if (muffled) 
[10:27:11.301]                           invokeRestart("muffleMessage")
[10:27:11.301]                       }
[10:27:11.301]                       else if (inherits(cond, "warning")) {
[10:27:11.301]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:11.301]                         if (muffled) 
[10:27:11.301]                           invokeRestart("muffleWarning")
[10:27:11.301]                       }
[10:27:11.301]                       else if (inherits(cond, "condition")) {
[10:27:11.301]                         if (!is.null(pattern)) {
[10:27:11.301]                           computeRestarts <- base::computeRestarts
[10:27:11.301]                           grepl <- base::grepl
[10:27:11.301]                           restarts <- computeRestarts(cond)
[10:27:11.301]                           for (restart in restarts) {
[10:27:11.301]                             name <- restart$name
[10:27:11.301]                             if (is.null(name)) 
[10:27:11.301]                               next
[10:27:11.301]                             if (!grepl(pattern, name)) 
[10:27:11.301]                               next
[10:27:11.301]                             invokeRestart(restart)
[10:27:11.301]                             muffled <- TRUE
[10:27:11.301]                             break
[10:27:11.301]                           }
[10:27:11.301]                         }
[10:27:11.301]                       }
[10:27:11.301]                       invisible(muffled)
[10:27:11.301]                     }
[10:27:11.301]                     muffleCondition(cond, pattern = "^muffle")
[10:27:11.301]                   }
[10:27:11.301]                 }
[10:27:11.301]                 else {
[10:27:11.301]                   if (TRUE) {
[10:27:11.301]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:11.301]                     {
[10:27:11.301]                       inherits <- base::inherits
[10:27:11.301]                       invokeRestart <- base::invokeRestart
[10:27:11.301]                       is.null <- base::is.null
[10:27:11.301]                       muffled <- FALSE
[10:27:11.301]                       if (inherits(cond, "message")) {
[10:27:11.301]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:11.301]                         if (muffled) 
[10:27:11.301]                           invokeRestart("muffleMessage")
[10:27:11.301]                       }
[10:27:11.301]                       else if (inherits(cond, "warning")) {
[10:27:11.301]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:11.301]                         if (muffled) 
[10:27:11.301]                           invokeRestart("muffleWarning")
[10:27:11.301]                       }
[10:27:11.301]                       else if (inherits(cond, "condition")) {
[10:27:11.301]                         if (!is.null(pattern)) {
[10:27:11.301]                           computeRestarts <- base::computeRestarts
[10:27:11.301]                           grepl <- base::grepl
[10:27:11.301]                           restarts <- computeRestarts(cond)
[10:27:11.301]                           for (restart in restarts) {
[10:27:11.301]                             name <- restart$name
[10:27:11.301]                             if (is.null(name)) 
[10:27:11.301]                               next
[10:27:11.301]                             if (!grepl(pattern, name)) 
[10:27:11.301]                               next
[10:27:11.301]                             invokeRestart(restart)
[10:27:11.301]                             muffled <- TRUE
[10:27:11.301]                             break
[10:27:11.301]                           }
[10:27:11.301]                         }
[10:27:11.301]                       }
[10:27:11.301]                       invisible(muffled)
[10:27:11.301]                     }
[10:27:11.301]                     muffleCondition(cond, pattern = "^muffle")
[10:27:11.301]                   }
[10:27:11.301]                 }
[10:27:11.301]             }
[10:27:11.301]         }))
[10:27:11.301]     }, error = function(ex) {
[10:27:11.301]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:11.301]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:11.301]                 ...future.rng), started = ...future.startTime, 
[10:27:11.301]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:11.301]             version = "1.8"), class = "FutureResult")
[10:27:11.301]     }, finally = {
[10:27:11.301]         if (!identical(...future.workdir, getwd())) 
[10:27:11.301]             setwd(...future.workdir)
[10:27:11.301]         {
[10:27:11.301]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:11.301]                 ...future.oldOptions$nwarnings <- NULL
[10:27:11.301]             }
[10:27:11.301]             base::options(...future.oldOptions)
[10:27:11.301]             if (.Platform$OS.type == "windows") {
[10:27:11.301]                 old_names <- names(...future.oldEnvVars)
[10:27:11.301]                 envs <- base::Sys.getenv()
[10:27:11.301]                 names <- names(envs)
[10:27:11.301]                 common <- intersect(names, old_names)
[10:27:11.301]                 added <- setdiff(names, old_names)
[10:27:11.301]                 removed <- setdiff(old_names, names)
[10:27:11.301]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:11.301]                   envs[common]]
[10:27:11.301]                 NAMES <- toupper(changed)
[10:27:11.301]                 args <- list()
[10:27:11.301]                 for (kk in seq_along(NAMES)) {
[10:27:11.301]                   name <- changed[[kk]]
[10:27:11.301]                   NAME <- NAMES[[kk]]
[10:27:11.301]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:11.301]                     next
[10:27:11.301]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:11.301]                 }
[10:27:11.301]                 NAMES <- toupper(added)
[10:27:11.301]                 for (kk in seq_along(NAMES)) {
[10:27:11.301]                   name <- added[[kk]]
[10:27:11.301]                   NAME <- NAMES[[kk]]
[10:27:11.301]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:11.301]                     next
[10:27:11.301]                   args[[name]] <- ""
[10:27:11.301]                 }
[10:27:11.301]                 NAMES <- toupper(removed)
[10:27:11.301]                 for (kk in seq_along(NAMES)) {
[10:27:11.301]                   name <- removed[[kk]]
[10:27:11.301]                   NAME <- NAMES[[kk]]
[10:27:11.301]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:11.301]                     next
[10:27:11.301]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:11.301]                 }
[10:27:11.301]                 if (length(args) > 0) 
[10:27:11.301]                   base::do.call(base::Sys.setenv, args = args)
[10:27:11.301]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:11.301]             }
[10:27:11.301]             else {
[10:27:11.301]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:11.301]             }
[10:27:11.301]             {
[10:27:11.301]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:11.301]                   0L) {
[10:27:11.301]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:11.301]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:11.301]                   base::options(opts)
[10:27:11.301]                 }
[10:27:11.301]                 {
[10:27:11.301]                   {
[10:27:11.301]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:11.301]                     NULL
[10:27:11.301]                   }
[10:27:11.301]                   options(future.plan = NULL)
[10:27:11.301]                   if (is.na(NA_character_)) 
[10:27:11.301]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:11.301]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:11.301]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:11.301]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:11.301]                     envir = parent.frame()) 
[10:27:11.301]                   {
[10:27:11.301]                     if (is.function(workers)) 
[10:27:11.301]                       workers <- workers()
[10:27:11.301]                     workers <- structure(as.integer(workers), 
[10:27:11.301]                       class = class(workers))
[10:27:11.301]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:11.301]                       workers >= 1)
[10:27:11.301]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:11.301]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:11.301]                     }
[10:27:11.301]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:11.301]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:11.301]                       envir = envir)
[10:27:11.301]                     if (!future$lazy) 
[10:27:11.301]                       future <- run(future)
[10:27:11.301]                     invisible(future)
[10:27:11.301]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:11.301]                 }
[10:27:11.301]             }
[10:27:11.301]         }
[10:27:11.301]     })
[10:27:11.301]     if (TRUE) {
[10:27:11.301]         base::sink(type = "output", split = FALSE)
[10:27:11.301]         if (TRUE) {
[10:27:11.301]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:11.301]         }
[10:27:11.301]         else {
[10:27:11.301]             ...future.result["stdout"] <- base::list(NULL)
[10:27:11.301]         }
[10:27:11.301]         base::close(...future.stdout)
[10:27:11.301]         ...future.stdout <- NULL
[10:27:11.301]     }
[10:27:11.301]     ...future.result$conditions <- ...future.conditions
[10:27:11.301]     ...future.result$finished <- base::Sys.time()
[10:27:11.301]     ...future.result
[10:27:11.301] }
[10:27:11.304] MultisessionFuture started
[10:27:11.304] - Launch lazy future ... done
[10:27:11.304] run() for ‘MultisessionFuture’ ... done
[10:27:11.351] receiveMessageFromWorker() for ClusterFuture ...
[10:27:11.351] - Validating connection of MultisessionFuture
[10:27:11.351] - received message: FutureResult
[10:27:11.352] - Received FutureResult
[10:27:11.352] - Erased future from FutureRegistry
[10:27:11.352] result() for ClusterFuture ...
[10:27:11.352] - result already collected: FutureResult
[10:27:11.352] result() for ClusterFuture ... done
[10:27:11.352] signalConditions() ...
[10:27:11.352]  - include = ‘immediateCondition’
[10:27:11.352]  - exclude = 
[10:27:11.352]  - resignal = FALSE
[10:27:11.352]  - Number of conditions: 1
[10:27:11.353] signalConditions() ... done
[10:27:11.353] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:11.353] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 2 ... DONE
- result = FALSE, recursive = Inf ...
[10:27:11.353] getGlobalsAndPackages() ...
[10:27:11.353] Searching for globals...
[10:27:11.354] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:27:11.355] Searching for globals ... DONE
[10:27:11.355] Resolving globals: FALSE
[10:27:11.355] 
[10:27:11.355] 
[10:27:11.355] getGlobalsAndPackages() ... DONE
[10:27:11.355] run() for ‘Future’ ...
[10:27:11.356] - state: ‘created’
[10:27:11.356] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:11.372] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:11.372] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:11.372]   - Field: ‘node’
[10:27:11.372]   - Field: ‘label’
[10:27:11.372]   - Field: ‘local’
[10:27:11.372]   - Field: ‘owner’
[10:27:11.373]   - Field: ‘envir’
[10:27:11.373]   - Field: ‘workers’
[10:27:11.373]   - Field: ‘packages’
[10:27:11.373]   - Field: ‘gc’
[10:27:11.373]   - Field: ‘conditions’
[10:27:11.373]   - Field: ‘persistent’
[10:27:11.373]   - Field: ‘expr’
[10:27:11.373]   - Field: ‘uuid’
[10:27:11.373]   - Field: ‘seed’
[10:27:11.373]   - Field: ‘version’
[10:27:11.374]   - Field: ‘result’
[10:27:11.374]   - Field: ‘asynchronous’
[10:27:11.374]   - Field: ‘calls’
[10:27:11.374]   - Field: ‘globals’
[10:27:11.374]   - Field: ‘stdout’
[10:27:11.374]   - Field: ‘earlySignal’
[10:27:11.374]   - Field: ‘lazy’
[10:27:11.374]   - Field: ‘state’
[10:27:11.374] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:11.374] - Launch lazy future ...
[10:27:11.375] Packages needed by the future expression (n = 0): <none>
[10:27:11.375] Packages needed by future strategies (n = 0): <none>
[10:27:11.375] {
[10:27:11.375]     {
[10:27:11.375]         {
[10:27:11.375]             ...future.startTime <- base::Sys.time()
[10:27:11.375]             {
[10:27:11.375]                 {
[10:27:11.375]                   {
[10:27:11.375]                     {
[10:27:11.375]                       base::local({
[10:27:11.375]                         has_future <- base::requireNamespace("future", 
[10:27:11.375]                           quietly = TRUE)
[10:27:11.375]                         if (has_future) {
[10:27:11.375]                           ns <- base::getNamespace("future")
[10:27:11.375]                           version <- ns[[".package"]][["version"]]
[10:27:11.375]                           if (is.null(version)) 
[10:27:11.375]                             version <- utils::packageVersion("future")
[10:27:11.375]                         }
[10:27:11.375]                         else {
[10:27:11.375]                           version <- NULL
[10:27:11.375]                         }
[10:27:11.375]                         if (!has_future || version < "1.8.0") {
[10:27:11.375]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:11.375]                             "", base::R.version$version.string), 
[10:27:11.375]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:11.375]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:11.375]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:11.375]                               "release", "version")], collapse = " "), 
[10:27:11.375]                             hostname = base::Sys.info()[["nodename"]])
[10:27:11.375]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:11.375]                             info)
[10:27:11.375]                           info <- base::paste(info, collapse = "; ")
[10:27:11.375]                           if (!has_future) {
[10:27:11.375]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:11.375]                               info)
[10:27:11.375]                           }
[10:27:11.375]                           else {
[10:27:11.375]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:11.375]                               info, version)
[10:27:11.375]                           }
[10:27:11.375]                           base::stop(msg)
[10:27:11.375]                         }
[10:27:11.375]                       })
[10:27:11.375]                     }
[10:27:11.375]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:11.375]                     base::options(mc.cores = 1L)
[10:27:11.375]                   }
[10:27:11.375]                   options(future.plan = NULL)
[10:27:11.375]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:11.375]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:11.375]                 }
[10:27:11.375]                 ...future.workdir <- getwd()
[10:27:11.375]             }
[10:27:11.375]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:11.375]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:11.375]         }
[10:27:11.375]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:11.375]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:11.375]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:11.375]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:11.375]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:11.375]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:11.375]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:11.375]             base::names(...future.oldOptions))
[10:27:11.375]     }
[10:27:11.375]     if (FALSE) {
[10:27:11.375]     }
[10:27:11.375]     else {
[10:27:11.375]         if (TRUE) {
[10:27:11.375]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:11.375]                 open = "w")
[10:27:11.375]         }
[10:27:11.375]         else {
[10:27:11.375]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:11.375]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:11.375]         }
[10:27:11.375]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:11.375]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:11.375]             base::sink(type = "output", split = FALSE)
[10:27:11.375]             base::close(...future.stdout)
[10:27:11.375]         }, add = TRUE)
[10:27:11.375]     }
[10:27:11.375]     ...future.frame <- base::sys.nframe()
[10:27:11.375]     ...future.conditions <- base::list()
[10:27:11.375]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:11.375]     if (FALSE) {
[10:27:11.375]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:11.375]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:11.375]     }
[10:27:11.375]     ...future.result <- base::tryCatch({
[10:27:11.375]         base::withCallingHandlers({
[10:27:11.375]             ...future.value <- base::withVisible(base::local({
[10:27:11.375]                 ...future.makeSendCondition <- base::local({
[10:27:11.375]                   sendCondition <- NULL
[10:27:11.375]                   function(frame = 1L) {
[10:27:11.375]                     if (is.function(sendCondition)) 
[10:27:11.375]                       return(sendCondition)
[10:27:11.375]                     ns <- getNamespace("parallel")
[10:27:11.375]                     if (exists("sendData", mode = "function", 
[10:27:11.375]                       envir = ns)) {
[10:27:11.375]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:11.375]                         envir = ns)
[10:27:11.375]                       envir <- sys.frame(frame)
[10:27:11.375]                       master <- NULL
[10:27:11.375]                       while (!identical(envir, .GlobalEnv) && 
[10:27:11.375]                         !identical(envir, emptyenv())) {
[10:27:11.375]                         if (exists("master", mode = "list", envir = envir, 
[10:27:11.375]                           inherits = FALSE)) {
[10:27:11.375]                           master <- get("master", mode = "list", 
[10:27:11.375]                             envir = envir, inherits = FALSE)
[10:27:11.375]                           if (inherits(master, c("SOCKnode", 
[10:27:11.375]                             "SOCK0node"))) {
[10:27:11.375]                             sendCondition <<- function(cond) {
[10:27:11.375]                               data <- list(type = "VALUE", value = cond, 
[10:27:11.375]                                 success = TRUE)
[10:27:11.375]                               parallel_sendData(master, data)
[10:27:11.375]                             }
[10:27:11.375]                             return(sendCondition)
[10:27:11.375]                           }
[10:27:11.375]                         }
[10:27:11.375]                         frame <- frame + 1L
[10:27:11.375]                         envir <- sys.frame(frame)
[10:27:11.375]                       }
[10:27:11.375]                     }
[10:27:11.375]                     sendCondition <<- function(cond) NULL
[10:27:11.375]                   }
[10:27:11.375]                 })
[10:27:11.375]                 withCallingHandlers({
[10:27:11.375]                   {
[10:27:11.375]                     Sys.sleep(0.5)
[10:27:11.375]                     list(a = 1, b = 42L)
[10:27:11.375]                   }
[10:27:11.375]                 }, immediateCondition = function(cond) {
[10:27:11.375]                   sendCondition <- ...future.makeSendCondition()
[10:27:11.375]                   sendCondition(cond)
[10:27:11.375]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:11.375]                   {
[10:27:11.375]                     inherits <- base::inherits
[10:27:11.375]                     invokeRestart <- base::invokeRestart
[10:27:11.375]                     is.null <- base::is.null
[10:27:11.375]                     muffled <- FALSE
[10:27:11.375]                     if (inherits(cond, "message")) {
[10:27:11.375]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:11.375]                       if (muffled) 
[10:27:11.375]                         invokeRestart("muffleMessage")
[10:27:11.375]                     }
[10:27:11.375]                     else if (inherits(cond, "warning")) {
[10:27:11.375]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:11.375]                       if (muffled) 
[10:27:11.375]                         invokeRestart("muffleWarning")
[10:27:11.375]                     }
[10:27:11.375]                     else if (inherits(cond, "condition")) {
[10:27:11.375]                       if (!is.null(pattern)) {
[10:27:11.375]                         computeRestarts <- base::computeRestarts
[10:27:11.375]                         grepl <- base::grepl
[10:27:11.375]                         restarts <- computeRestarts(cond)
[10:27:11.375]                         for (restart in restarts) {
[10:27:11.375]                           name <- restart$name
[10:27:11.375]                           if (is.null(name)) 
[10:27:11.375]                             next
[10:27:11.375]                           if (!grepl(pattern, name)) 
[10:27:11.375]                             next
[10:27:11.375]                           invokeRestart(restart)
[10:27:11.375]                           muffled <- TRUE
[10:27:11.375]                           break
[10:27:11.375]                         }
[10:27:11.375]                       }
[10:27:11.375]                     }
[10:27:11.375]                     invisible(muffled)
[10:27:11.375]                   }
[10:27:11.375]                   muffleCondition(cond)
[10:27:11.375]                 })
[10:27:11.375]             }))
[10:27:11.375]             future::FutureResult(value = ...future.value$value, 
[10:27:11.375]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:11.375]                   ...future.rng), globalenv = if (FALSE) 
[10:27:11.375]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:11.375]                     ...future.globalenv.names))
[10:27:11.375]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:11.375]         }, condition = base::local({
[10:27:11.375]             c <- base::c
[10:27:11.375]             inherits <- base::inherits
[10:27:11.375]             invokeRestart <- base::invokeRestart
[10:27:11.375]             length <- base::length
[10:27:11.375]             list <- base::list
[10:27:11.375]             seq.int <- base::seq.int
[10:27:11.375]             signalCondition <- base::signalCondition
[10:27:11.375]             sys.calls <- base::sys.calls
[10:27:11.375]             `[[` <- base::`[[`
[10:27:11.375]             `+` <- base::`+`
[10:27:11.375]             `<<-` <- base::`<<-`
[10:27:11.375]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:11.375]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:11.375]                   3L)]
[10:27:11.375]             }
[10:27:11.375]             function(cond) {
[10:27:11.375]                 is_error <- inherits(cond, "error")
[10:27:11.375]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:11.375]                   NULL)
[10:27:11.375]                 if (is_error) {
[10:27:11.375]                   sessionInformation <- function() {
[10:27:11.375]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:11.375]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:11.375]                       search = base::search(), system = base::Sys.info())
[10:27:11.375]                   }
[10:27:11.375]                   ...future.conditions[[length(...future.conditions) + 
[10:27:11.375]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:11.375]                     cond$call), session = sessionInformation(), 
[10:27:11.375]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:11.375]                   signalCondition(cond)
[10:27:11.375]                 }
[10:27:11.375]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:11.375]                 "immediateCondition"))) {
[10:27:11.375]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:11.375]                   ...future.conditions[[length(...future.conditions) + 
[10:27:11.375]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:11.375]                   if (TRUE && !signal) {
[10:27:11.375]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:11.375]                     {
[10:27:11.375]                       inherits <- base::inherits
[10:27:11.375]                       invokeRestart <- base::invokeRestart
[10:27:11.375]                       is.null <- base::is.null
[10:27:11.375]                       muffled <- FALSE
[10:27:11.375]                       if (inherits(cond, "message")) {
[10:27:11.375]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:11.375]                         if (muffled) 
[10:27:11.375]                           invokeRestart("muffleMessage")
[10:27:11.375]                       }
[10:27:11.375]                       else if (inherits(cond, "warning")) {
[10:27:11.375]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:11.375]                         if (muffled) 
[10:27:11.375]                           invokeRestart("muffleWarning")
[10:27:11.375]                       }
[10:27:11.375]                       else if (inherits(cond, "condition")) {
[10:27:11.375]                         if (!is.null(pattern)) {
[10:27:11.375]                           computeRestarts <- base::computeRestarts
[10:27:11.375]                           grepl <- base::grepl
[10:27:11.375]                           restarts <- computeRestarts(cond)
[10:27:11.375]                           for (restart in restarts) {
[10:27:11.375]                             name <- restart$name
[10:27:11.375]                             if (is.null(name)) 
[10:27:11.375]                               next
[10:27:11.375]                             if (!grepl(pattern, name)) 
[10:27:11.375]                               next
[10:27:11.375]                             invokeRestart(restart)
[10:27:11.375]                             muffled <- TRUE
[10:27:11.375]                             break
[10:27:11.375]                           }
[10:27:11.375]                         }
[10:27:11.375]                       }
[10:27:11.375]                       invisible(muffled)
[10:27:11.375]                     }
[10:27:11.375]                     muffleCondition(cond, pattern = "^muffle")
[10:27:11.375]                   }
[10:27:11.375]                 }
[10:27:11.375]                 else {
[10:27:11.375]                   if (TRUE) {
[10:27:11.375]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:11.375]                     {
[10:27:11.375]                       inherits <- base::inherits
[10:27:11.375]                       invokeRestart <- base::invokeRestart
[10:27:11.375]                       is.null <- base::is.null
[10:27:11.375]                       muffled <- FALSE
[10:27:11.375]                       if (inherits(cond, "message")) {
[10:27:11.375]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:11.375]                         if (muffled) 
[10:27:11.375]                           invokeRestart("muffleMessage")
[10:27:11.375]                       }
[10:27:11.375]                       else if (inherits(cond, "warning")) {
[10:27:11.375]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:11.375]                         if (muffled) 
[10:27:11.375]                           invokeRestart("muffleWarning")
[10:27:11.375]                       }
[10:27:11.375]                       else if (inherits(cond, "condition")) {
[10:27:11.375]                         if (!is.null(pattern)) {
[10:27:11.375]                           computeRestarts <- base::computeRestarts
[10:27:11.375]                           grepl <- base::grepl
[10:27:11.375]                           restarts <- computeRestarts(cond)
[10:27:11.375]                           for (restart in restarts) {
[10:27:11.375]                             name <- restart$name
[10:27:11.375]                             if (is.null(name)) 
[10:27:11.375]                               next
[10:27:11.375]                             if (!grepl(pattern, name)) 
[10:27:11.375]                               next
[10:27:11.375]                             invokeRestart(restart)
[10:27:11.375]                             muffled <- TRUE
[10:27:11.375]                             break
[10:27:11.375]                           }
[10:27:11.375]                         }
[10:27:11.375]                       }
[10:27:11.375]                       invisible(muffled)
[10:27:11.375]                     }
[10:27:11.375]                     muffleCondition(cond, pattern = "^muffle")
[10:27:11.375]                   }
[10:27:11.375]                 }
[10:27:11.375]             }
[10:27:11.375]         }))
[10:27:11.375]     }, error = function(ex) {
[10:27:11.375]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:11.375]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:11.375]                 ...future.rng), started = ...future.startTime, 
[10:27:11.375]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:11.375]             version = "1.8"), class = "FutureResult")
[10:27:11.375]     }, finally = {
[10:27:11.375]         if (!identical(...future.workdir, getwd())) 
[10:27:11.375]             setwd(...future.workdir)
[10:27:11.375]         {
[10:27:11.375]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:11.375]                 ...future.oldOptions$nwarnings <- NULL
[10:27:11.375]             }
[10:27:11.375]             base::options(...future.oldOptions)
[10:27:11.375]             if (.Platform$OS.type == "windows") {
[10:27:11.375]                 old_names <- names(...future.oldEnvVars)
[10:27:11.375]                 envs <- base::Sys.getenv()
[10:27:11.375]                 names <- names(envs)
[10:27:11.375]                 common <- intersect(names, old_names)
[10:27:11.375]                 added <- setdiff(names, old_names)
[10:27:11.375]                 removed <- setdiff(old_names, names)
[10:27:11.375]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:11.375]                   envs[common]]
[10:27:11.375]                 NAMES <- toupper(changed)
[10:27:11.375]                 args <- list()
[10:27:11.375]                 for (kk in seq_along(NAMES)) {
[10:27:11.375]                   name <- changed[[kk]]
[10:27:11.375]                   NAME <- NAMES[[kk]]
[10:27:11.375]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:11.375]                     next
[10:27:11.375]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:11.375]                 }
[10:27:11.375]                 NAMES <- toupper(added)
[10:27:11.375]                 for (kk in seq_along(NAMES)) {
[10:27:11.375]                   name <- added[[kk]]
[10:27:11.375]                   NAME <- NAMES[[kk]]
[10:27:11.375]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:11.375]                     next
[10:27:11.375]                   args[[name]] <- ""
[10:27:11.375]                 }
[10:27:11.375]                 NAMES <- toupper(removed)
[10:27:11.375]                 for (kk in seq_along(NAMES)) {
[10:27:11.375]                   name <- removed[[kk]]
[10:27:11.375]                   NAME <- NAMES[[kk]]
[10:27:11.375]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:11.375]                     next
[10:27:11.375]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:11.375]                 }
[10:27:11.375]                 if (length(args) > 0) 
[10:27:11.375]                   base::do.call(base::Sys.setenv, args = args)
[10:27:11.375]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:11.375]             }
[10:27:11.375]             else {
[10:27:11.375]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:11.375]             }
[10:27:11.375]             {
[10:27:11.375]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:11.375]                   0L) {
[10:27:11.375]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:11.375]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:11.375]                   base::options(opts)
[10:27:11.375]                 }
[10:27:11.375]                 {
[10:27:11.375]                   {
[10:27:11.375]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:11.375]                     NULL
[10:27:11.375]                   }
[10:27:11.375]                   options(future.plan = NULL)
[10:27:11.375]                   if (is.na(NA_character_)) 
[10:27:11.375]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:11.375]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:11.375]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:11.375]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:11.375]                     envir = parent.frame()) 
[10:27:11.375]                   {
[10:27:11.375]                     if (is.function(workers)) 
[10:27:11.375]                       workers <- workers()
[10:27:11.375]                     workers <- structure(as.integer(workers), 
[10:27:11.375]                       class = class(workers))
[10:27:11.375]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:11.375]                       workers >= 1)
[10:27:11.375]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:11.375]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:11.375]                     }
[10:27:11.375]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:11.375]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:11.375]                       envir = envir)
[10:27:11.375]                     if (!future$lazy) 
[10:27:11.375]                       future <- run(future)
[10:27:11.375]                     invisible(future)
[10:27:11.375]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:11.375]                 }
[10:27:11.375]             }
[10:27:11.375]         }
[10:27:11.375]     })
[10:27:11.375]     if (TRUE) {
[10:27:11.375]         base::sink(type = "output", split = FALSE)
[10:27:11.375]         if (TRUE) {
[10:27:11.375]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:11.375]         }
[10:27:11.375]         else {
[10:27:11.375]             ...future.result["stdout"] <- base::list(NULL)
[10:27:11.375]         }
[10:27:11.375]         base::close(...future.stdout)
[10:27:11.375]         ...future.stdout <- NULL
[10:27:11.375]     }
[10:27:11.375]     ...future.result$conditions <- ...future.conditions
[10:27:11.375]     ...future.result$finished <- base::Sys.time()
[10:27:11.375]     ...future.result
[10:27:11.375] }
[10:27:11.378] MultisessionFuture started
[10:27:11.379] - Launch lazy future ... done
[10:27:11.379] run() for ‘MultisessionFuture’ ... done
[10:27:11.929] receiveMessageFromWorker() for ClusterFuture ...
[10:27:11.929] - Validating connection of MultisessionFuture
[10:27:11.929] - received message: FutureResult
[10:27:11.930] - Received FutureResult
[10:27:11.930] - Erased future from FutureRegistry
[10:27:11.930] result() for ClusterFuture ...
[10:27:11.930] - result already collected: FutureResult
[10:27:11.930] result() for ClusterFuture ... done
[10:27:11.930] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:11.930] A MultisessionFuture was resolved (result was not collected)
[10:27:11.930] getGlobalsAndPackages() ...
[10:27:11.930] Searching for globals...
[10:27:11.932] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:27:11.932] Searching for globals ... DONE
[10:27:11.932] Resolving globals: FALSE
[10:27:11.932] 
[10:27:11.932] 
[10:27:11.932] getGlobalsAndPackages() ... DONE
[10:27:11.933] run() for ‘Future’ ...
[10:27:11.933] - state: ‘created’
[10:27:11.933] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:11.947] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:11.947] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:11.947]   - Field: ‘node’
[10:27:11.947]   - Field: ‘label’
[10:27:11.947]   - Field: ‘local’
[10:27:11.947]   - Field: ‘owner’
[10:27:11.947]   - Field: ‘envir’
[10:27:11.947]   - Field: ‘workers’
[10:27:11.948]   - Field: ‘packages’
[10:27:11.948]   - Field: ‘gc’
[10:27:11.948]   - Field: ‘conditions’
[10:27:11.948]   - Field: ‘persistent’
[10:27:11.948]   - Field: ‘expr’
[10:27:11.948]   - Field: ‘uuid’
[10:27:11.948]   - Field: ‘seed’
[10:27:11.948]   - Field: ‘version’
[10:27:11.948]   - Field: ‘result’
[10:27:11.948]   - Field: ‘asynchronous’
[10:27:11.948]   - Field: ‘calls’
[10:27:11.949]   - Field: ‘globals’
[10:27:11.949]   - Field: ‘stdout’
[10:27:11.949]   - Field: ‘earlySignal’
[10:27:11.949]   - Field: ‘lazy’
[10:27:11.949]   - Field: ‘state’
[10:27:11.949] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:11.949] - Launch lazy future ...
[10:27:11.949] Packages needed by the future expression (n = 0): <none>
[10:27:11.950] Packages needed by future strategies (n = 0): <none>
[10:27:11.950] {
[10:27:11.950]     {
[10:27:11.950]         {
[10:27:11.950]             ...future.startTime <- base::Sys.time()
[10:27:11.950]             {
[10:27:11.950]                 {
[10:27:11.950]                   {
[10:27:11.950]                     {
[10:27:11.950]                       base::local({
[10:27:11.950]                         has_future <- base::requireNamespace("future", 
[10:27:11.950]                           quietly = TRUE)
[10:27:11.950]                         if (has_future) {
[10:27:11.950]                           ns <- base::getNamespace("future")
[10:27:11.950]                           version <- ns[[".package"]][["version"]]
[10:27:11.950]                           if (is.null(version)) 
[10:27:11.950]                             version <- utils::packageVersion("future")
[10:27:11.950]                         }
[10:27:11.950]                         else {
[10:27:11.950]                           version <- NULL
[10:27:11.950]                         }
[10:27:11.950]                         if (!has_future || version < "1.8.0") {
[10:27:11.950]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:11.950]                             "", base::R.version$version.string), 
[10:27:11.950]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:11.950]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:11.950]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:11.950]                               "release", "version")], collapse = " "), 
[10:27:11.950]                             hostname = base::Sys.info()[["nodename"]])
[10:27:11.950]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:11.950]                             info)
[10:27:11.950]                           info <- base::paste(info, collapse = "; ")
[10:27:11.950]                           if (!has_future) {
[10:27:11.950]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:11.950]                               info)
[10:27:11.950]                           }
[10:27:11.950]                           else {
[10:27:11.950]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:11.950]                               info, version)
[10:27:11.950]                           }
[10:27:11.950]                           base::stop(msg)
[10:27:11.950]                         }
[10:27:11.950]                       })
[10:27:11.950]                     }
[10:27:11.950]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:11.950]                     base::options(mc.cores = 1L)
[10:27:11.950]                   }
[10:27:11.950]                   options(future.plan = NULL)
[10:27:11.950]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:11.950]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:11.950]                 }
[10:27:11.950]                 ...future.workdir <- getwd()
[10:27:11.950]             }
[10:27:11.950]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:11.950]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:11.950]         }
[10:27:11.950]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:11.950]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:11.950]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:11.950]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:11.950]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:11.950]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:11.950]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:11.950]             base::names(...future.oldOptions))
[10:27:11.950]     }
[10:27:11.950]     if (FALSE) {
[10:27:11.950]     }
[10:27:11.950]     else {
[10:27:11.950]         if (TRUE) {
[10:27:11.950]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:11.950]                 open = "w")
[10:27:11.950]         }
[10:27:11.950]         else {
[10:27:11.950]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:11.950]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:11.950]         }
[10:27:11.950]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:11.950]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:11.950]             base::sink(type = "output", split = FALSE)
[10:27:11.950]             base::close(...future.stdout)
[10:27:11.950]         }, add = TRUE)
[10:27:11.950]     }
[10:27:11.950]     ...future.frame <- base::sys.nframe()
[10:27:11.950]     ...future.conditions <- base::list()
[10:27:11.950]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:11.950]     if (FALSE) {
[10:27:11.950]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:11.950]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:11.950]     }
[10:27:11.950]     ...future.result <- base::tryCatch({
[10:27:11.950]         base::withCallingHandlers({
[10:27:11.950]             ...future.value <- base::withVisible(base::local({
[10:27:11.950]                 ...future.makeSendCondition <- base::local({
[10:27:11.950]                   sendCondition <- NULL
[10:27:11.950]                   function(frame = 1L) {
[10:27:11.950]                     if (is.function(sendCondition)) 
[10:27:11.950]                       return(sendCondition)
[10:27:11.950]                     ns <- getNamespace("parallel")
[10:27:11.950]                     if (exists("sendData", mode = "function", 
[10:27:11.950]                       envir = ns)) {
[10:27:11.950]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:11.950]                         envir = ns)
[10:27:11.950]                       envir <- sys.frame(frame)
[10:27:11.950]                       master <- NULL
[10:27:11.950]                       while (!identical(envir, .GlobalEnv) && 
[10:27:11.950]                         !identical(envir, emptyenv())) {
[10:27:11.950]                         if (exists("master", mode = "list", envir = envir, 
[10:27:11.950]                           inherits = FALSE)) {
[10:27:11.950]                           master <- get("master", mode = "list", 
[10:27:11.950]                             envir = envir, inherits = FALSE)
[10:27:11.950]                           if (inherits(master, c("SOCKnode", 
[10:27:11.950]                             "SOCK0node"))) {
[10:27:11.950]                             sendCondition <<- function(cond) {
[10:27:11.950]                               data <- list(type = "VALUE", value = cond, 
[10:27:11.950]                                 success = TRUE)
[10:27:11.950]                               parallel_sendData(master, data)
[10:27:11.950]                             }
[10:27:11.950]                             return(sendCondition)
[10:27:11.950]                           }
[10:27:11.950]                         }
[10:27:11.950]                         frame <- frame + 1L
[10:27:11.950]                         envir <- sys.frame(frame)
[10:27:11.950]                       }
[10:27:11.950]                     }
[10:27:11.950]                     sendCondition <<- function(cond) NULL
[10:27:11.950]                   }
[10:27:11.950]                 })
[10:27:11.950]                 withCallingHandlers({
[10:27:11.950]                   {
[10:27:11.950]                     Sys.sleep(0.5)
[10:27:11.950]                     list(a = 1, b = 42L)
[10:27:11.950]                   }
[10:27:11.950]                 }, immediateCondition = function(cond) {
[10:27:11.950]                   sendCondition <- ...future.makeSendCondition()
[10:27:11.950]                   sendCondition(cond)
[10:27:11.950]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:11.950]                   {
[10:27:11.950]                     inherits <- base::inherits
[10:27:11.950]                     invokeRestart <- base::invokeRestart
[10:27:11.950]                     is.null <- base::is.null
[10:27:11.950]                     muffled <- FALSE
[10:27:11.950]                     if (inherits(cond, "message")) {
[10:27:11.950]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:11.950]                       if (muffled) 
[10:27:11.950]                         invokeRestart("muffleMessage")
[10:27:11.950]                     }
[10:27:11.950]                     else if (inherits(cond, "warning")) {
[10:27:11.950]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:11.950]                       if (muffled) 
[10:27:11.950]                         invokeRestart("muffleWarning")
[10:27:11.950]                     }
[10:27:11.950]                     else if (inherits(cond, "condition")) {
[10:27:11.950]                       if (!is.null(pattern)) {
[10:27:11.950]                         computeRestarts <- base::computeRestarts
[10:27:11.950]                         grepl <- base::grepl
[10:27:11.950]                         restarts <- computeRestarts(cond)
[10:27:11.950]                         for (restart in restarts) {
[10:27:11.950]                           name <- restart$name
[10:27:11.950]                           if (is.null(name)) 
[10:27:11.950]                             next
[10:27:11.950]                           if (!grepl(pattern, name)) 
[10:27:11.950]                             next
[10:27:11.950]                           invokeRestart(restart)
[10:27:11.950]                           muffled <- TRUE
[10:27:11.950]                           break
[10:27:11.950]                         }
[10:27:11.950]                       }
[10:27:11.950]                     }
[10:27:11.950]                     invisible(muffled)
[10:27:11.950]                   }
[10:27:11.950]                   muffleCondition(cond)
[10:27:11.950]                 })
[10:27:11.950]             }))
[10:27:11.950]             future::FutureResult(value = ...future.value$value, 
[10:27:11.950]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:11.950]                   ...future.rng), globalenv = if (FALSE) 
[10:27:11.950]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:11.950]                     ...future.globalenv.names))
[10:27:11.950]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:11.950]         }, condition = base::local({
[10:27:11.950]             c <- base::c
[10:27:11.950]             inherits <- base::inherits
[10:27:11.950]             invokeRestart <- base::invokeRestart
[10:27:11.950]             length <- base::length
[10:27:11.950]             list <- base::list
[10:27:11.950]             seq.int <- base::seq.int
[10:27:11.950]             signalCondition <- base::signalCondition
[10:27:11.950]             sys.calls <- base::sys.calls
[10:27:11.950]             `[[` <- base::`[[`
[10:27:11.950]             `+` <- base::`+`
[10:27:11.950]             `<<-` <- base::`<<-`
[10:27:11.950]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:11.950]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:11.950]                   3L)]
[10:27:11.950]             }
[10:27:11.950]             function(cond) {
[10:27:11.950]                 is_error <- inherits(cond, "error")
[10:27:11.950]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:11.950]                   NULL)
[10:27:11.950]                 if (is_error) {
[10:27:11.950]                   sessionInformation <- function() {
[10:27:11.950]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:11.950]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:11.950]                       search = base::search(), system = base::Sys.info())
[10:27:11.950]                   }
[10:27:11.950]                   ...future.conditions[[length(...future.conditions) + 
[10:27:11.950]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:11.950]                     cond$call), session = sessionInformation(), 
[10:27:11.950]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:11.950]                   signalCondition(cond)
[10:27:11.950]                 }
[10:27:11.950]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:11.950]                 "immediateCondition"))) {
[10:27:11.950]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:11.950]                   ...future.conditions[[length(...future.conditions) + 
[10:27:11.950]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:11.950]                   if (TRUE && !signal) {
[10:27:11.950]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:11.950]                     {
[10:27:11.950]                       inherits <- base::inherits
[10:27:11.950]                       invokeRestart <- base::invokeRestart
[10:27:11.950]                       is.null <- base::is.null
[10:27:11.950]                       muffled <- FALSE
[10:27:11.950]                       if (inherits(cond, "message")) {
[10:27:11.950]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:11.950]                         if (muffled) 
[10:27:11.950]                           invokeRestart("muffleMessage")
[10:27:11.950]                       }
[10:27:11.950]                       else if (inherits(cond, "warning")) {
[10:27:11.950]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:11.950]                         if (muffled) 
[10:27:11.950]                           invokeRestart("muffleWarning")
[10:27:11.950]                       }
[10:27:11.950]                       else if (inherits(cond, "condition")) {
[10:27:11.950]                         if (!is.null(pattern)) {
[10:27:11.950]                           computeRestarts <- base::computeRestarts
[10:27:11.950]                           grepl <- base::grepl
[10:27:11.950]                           restarts <- computeRestarts(cond)
[10:27:11.950]                           for (restart in restarts) {
[10:27:11.950]                             name <- restart$name
[10:27:11.950]                             if (is.null(name)) 
[10:27:11.950]                               next
[10:27:11.950]                             if (!grepl(pattern, name)) 
[10:27:11.950]                               next
[10:27:11.950]                             invokeRestart(restart)
[10:27:11.950]                             muffled <- TRUE
[10:27:11.950]                             break
[10:27:11.950]                           }
[10:27:11.950]                         }
[10:27:11.950]                       }
[10:27:11.950]                       invisible(muffled)
[10:27:11.950]                     }
[10:27:11.950]                     muffleCondition(cond, pattern = "^muffle")
[10:27:11.950]                   }
[10:27:11.950]                 }
[10:27:11.950]                 else {
[10:27:11.950]                   if (TRUE) {
[10:27:11.950]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:11.950]                     {
[10:27:11.950]                       inherits <- base::inherits
[10:27:11.950]                       invokeRestart <- base::invokeRestart
[10:27:11.950]                       is.null <- base::is.null
[10:27:11.950]                       muffled <- FALSE
[10:27:11.950]                       if (inherits(cond, "message")) {
[10:27:11.950]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:11.950]                         if (muffled) 
[10:27:11.950]                           invokeRestart("muffleMessage")
[10:27:11.950]                       }
[10:27:11.950]                       else if (inherits(cond, "warning")) {
[10:27:11.950]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:11.950]                         if (muffled) 
[10:27:11.950]                           invokeRestart("muffleWarning")
[10:27:11.950]                       }
[10:27:11.950]                       else if (inherits(cond, "condition")) {
[10:27:11.950]                         if (!is.null(pattern)) {
[10:27:11.950]                           computeRestarts <- base::computeRestarts
[10:27:11.950]                           grepl <- base::grepl
[10:27:11.950]                           restarts <- computeRestarts(cond)
[10:27:11.950]                           for (restart in restarts) {
[10:27:11.950]                             name <- restart$name
[10:27:11.950]                             if (is.null(name)) 
[10:27:11.950]                               next
[10:27:11.950]                             if (!grepl(pattern, name)) 
[10:27:11.950]                               next
[10:27:11.950]                             invokeRestart(restart)
[10:27:11.950]                             muffled <- TRUE
[10:27:11.950]                             break
[10:27:11.950]                           }
[10:27:11.950]                         }
[10:27:11.950]                       }
[10:27:11.950]                       invisible(muffled)
[10:27:11.950]                     }
[10:27:11.950]                     muffleCondition(cond, pattern = "^muffle")
[10:27:11.950]                   }
[10:27:11.950]                 }
[10:27:11.950]             }
[10:27:11.950]         }))
[10:27:11.950]     }, error = function(ex) {
[10:27:11.950]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:11.950]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:11.950]                 ...future.rng), started = ...future.startTime, 
[10:27:11.950]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:11.950]             version = "1.8"), class = "FutureResult")
[10:27:11.950]     }, finally = {
[10:27:11.950]         if (!identical(...future.workdir, getwd())) 
[10:27:11.950]             setwd(...future.workdir)
[10:27:11.950]         {
[10:27:11.950]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:11.950]                 ...future.oldOptions$nwarnings <- NULL
[10:27:11.950]             }
[10:27:11.950]             base::options(...future.oldOptions)
[10:27:11.950]             if (.Platform$OS.type == "windows") {
[10:27:11.950]                 old_names <- names(...future.oldEnvVars)
[10:27:11.950]                 envs <- base::Sys.getenv()
[10:27:11.950]                 names <- names(envs)
[10:27:11.950]                 common <- intersect(names, old_names)
[10:27:11.950]                 added <- setdiff(names, old_names)
[10:27:11.950]                 removed <- setdiff(old_names, names)
[10:27:11.950]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:11.950]                   envs[common]]
[10:27:11.950]                 NAMES <- toupper(changed)
[10:27:11.950]                 args <- list()
[10:27:11.950]                 for (kk in seq_along(NAMES)) {
[10:27:11.950]                   name <- changed[[kk]]
[10:27:11.950]                   NAME <- NAMES[[kk]]
[10:27:11.950]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:11.950]                     next
[10:27:11.950]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:11.950]                 }
[10:27:11.950]                 NAMES <- toupper(added)
[10:27:11.950]                 for (kk in seq_along(NAMES)) {
[10:27:11.950]                   name <- added[[kk]]
[10:27:11.950]                   NAME <- NAMES[[kk]]
[10:27:11.950]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:11.950]                     next
[10:27:11.950]                   args[[name]] <- ""
[10:27:11.950]                 }
[10:27:11.950]                 NAMES <- toupper(removed)
[10:27:11.950]                 for (kk in seq_along(NAMES)) {
[10:27:11.950]                   name <- removed[[kk]]
[10:27:11.950]                   NAME <- NAMES[[kk]]
[10:27:11.950]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:11.950]                     next
[10:27:11.950]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:11.950]                 }
[10:27:11.950]                 if (length(args) > 0) 
[10:27:11.950]                   base::do.call(base::Sys.setenv, args = args)
[10:27:11.950]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:11.950]             }
[10:27:11.950]             else {
[10:27:11.950]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:11.950]             }
[10:27:11.950]             {
[10:27:11.950]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:11.950]                   0L) {
[10:27:11.950]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:11.950]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:11.950]                   base::options(opts)
[10:27:11.950]                 }
[10:27:11.950]                 {
[10:27:11.950]                   {
[10:27:11.950]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:11.950]                     NULL
[10:27:11.950]                   }
[10:27:11.950]                   options(future.plan = NULL)
[10:27:11.950]                   if (is.na(NA_character_)) 
[10:27:11.950]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:11.950]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:11.950]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:11.950]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:11.950]                     envir = parent.frame()) 
[10:27:11.950]                   {
[10:27:11.950]                     if (is.function(workers)) 
[10:27:11.950]                       workers <- workers()
[10:27:11.950]                     workers <- structure(as.integer(workers), 
[10:27:11.950]                       class = class(workers))
[10:27:11.950]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:11.950]                       workers >= 1)
[10:27:11.950]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:11.950]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:11.950]                     }
[10:27:11.950]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:11.950]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:11.950]                       envir = envir)
[10:27:11.950]                     if (!future$lazy) 
[10:27:11.950]                       future <- run(future)
[10:27:11.950]                     invisible(future)
[10:27:11.950]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:11.950]                 }
[10:27:11.950]             }
[10:27:11.950]         }
[10:27:11.950]     })
[10:27:11.950]     if (TRUE) {
[10:27:11.950]         base::sink(type = "output", split = FALSE)
[10:27:11.950]         if (TRUE) {
[10:27:11.950]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:11.950]         }
[10:27:11.950]         else {
[10:27:11.950]             ...future.result["stdout"] <- base::list(NULL)
[10:27:11.950]         }
[10:27:11.950]         base::close(...future.stdout)
[10:27:11.950]         ...future.stdout <- NULL
[10:27:11.950]     }
[10:27:11.950]     ...future.result$conditions <- ...future.conditions
[10:27:11.950]     ...future.result$finished <- base::Sys.time()
[10:27:11.950]     ...future.result
[10:27:11.950] }
[10:27:11.953] MultisessionFuture started
[10:27:11.953] - Launch lazy future ... done
[10:27:11.954] run() for ‘MultisessionFuture’ ... done
[10:27:12.499] receiveMessageFromWorker() for ClusterFuture ...
[10:27:12.499] - Validating connection of MultisessionFuture
[10:27:12.500] - received message: FutureResult
[10:27:12.500] - Received FutureResult
[10:27:12.500] - Erased future from FutureRegistry
[10:27:12.500] result() for ClusterFuture ...
[10:27:12.500] - result already collected: FutureResult
[10:27:12.500] result() for ClusterFuture ... done
[10:27:12.500] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:12.500] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[10:27:12.501] getGlobalsAndPackages() ...
[10:27:12.501] Searching for globals...
[10:27:12.501] - globals found: [2] ‘list’, ‘stop’
[10:27:12.502] Searching for globals ... DONE
[10:27:12.502] Resolving globals: FALSE
[10:27:12.502] 
[10:27:12.502] 
[10:27:12.502] getGlobalsAndPackages() ... DONE
[10:27:12.502] run() for ‘Future’ ...
[10:27:12.503] - state: ‘created’
[10:27:12.503] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:12.516] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:12.517] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:12.517]   - Field: ‘node’
[10:27:12.517]   - Field: ‘label’
[10:27:12.517]   - Field: ‘local’
[10:27:12.517]   - Field: ‘owner’
[10:27:12.517]   - Field: ‘envir’
[10:27:12.517]   - Field: ‘workers’
[10:27:12.517]   - Field: ‘packages’
[10:27:12.517]   - Field: ‘gc’
[10:27:12.518]   - Field: ‘conditions’
[10:27:12.518]   - Field: ‘persistent’
[10:27:12.518]   - Field: ‘expr’
[10:27:12.518]   - Field: ‘uuid’
[10:27:12.518]   - Field: ‘seed’
[10:27:12.518]   - Field: ‘version’
[10:27:12.518]   - Field: ‘result’
[10:27:12.518]   - Field: ‘asynchronous’
[10:27:12.518]   - Field: ‘calls’
[10:27:12.518]   - Field: ‘globals’
[10:27:12.518]   - Field: ‘stdout’
[10:27:12.519]   - Field: ‘earlySignal’
[10:27:12.519]   - Field: ‘lazy’
[10:27:12.519]   - Field: ‘state’
[10:27:12.519] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:12.519] - Launch lazy future ...
[10:27:12.519] Packages needed by the future expression (n = 0): <none>
[10:27:12.519] Packages needed by future strategies (n = 0): <none>
[10:27:12.520] {
[10:27:12.520]     {
[10:27:12.520]         {
[10:27:12.520]             ...future.startTime <- base::Sys.time()
[10:27:12.520]             {
[10:27:12.520]                 {
[10:27:12.520]                   {
[10:27:12.520]                     {
[10:27:12.520]                       base::local({
[10:27:12.520]                         has_future <- base::requireNamespace("future", 
[10:27:12.520]                           quietly = TRUE)
[10:27:12.520]                         if (has_future) {
[10:27:12.520]                           ns <- base::getNamespace("future")
[10:27:12.520]                           version <- ns[[".package"]][["version"]]
[10:27:12.520]                           if (is.null(version)) 
[10:27:12.520]                             version <- utils::packageVersion("future")
[10:27:12.520]                         }
[10:27:12.520]                         else {
[10:27:12.520]                           version <- NULL
[10:27:12.520]                         }
[10:27:12.520]                         if (!has_future || version < "1.8.0") {
[10:27:12.520]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:12.520]                             "", base::R.version$version.string), 
[10:27:12.520]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:12.520]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:12.520]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:12.520]                               "release", "version")], collapse = " "), 
[10:27:12.520]                             hostname = base::Sys.info()[["nodename"]])
[10:27:12.520]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:12.520]                             info)
[10:27:12.520]                           info <- base::paste(info, collapse = "; ")
[10:27:12.520]                           if (!has_future) {
[10:27:12.520]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:12.520]                               info)
[10:27:12.520]                           }
[10:27:12.520]                           else {
[10:27:12.520]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:12.520]                               info, version)
[10:27:12.520]                           }
[10:27:12.520]                           base::stop(msg)
[10:27:12.520]                         }
[10:27:12.520]                       })
[10:27:12.520]                     }
[10:27:12.520]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:12.520]                     base::options(mc.cores = 1L)
[10:27:12.520]                   }
[10:27:12.520]                   options(future.plan = NULL)
[10:27:12.520]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:12.520]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:12.520]                 }
[10:27:12.520]                 ...future.workdir <- getwd()
[10:27:12.520]             }
[10:27:12.520]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:12.520]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:12.520]         }
[10:27:12.520]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:12.520]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:12.520]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:12.520]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:12.520]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:12.520]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:12.520]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:12.520]             base::names(...future.oldOptions))
[10:27:12.520]     }
[10:27:12.520]     if (FALSE) {
[10:27:12.520]     }
[10:27:12.520]     else {
[10:27:12.520]         if (TRUE) {
[10:27:12.520]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:12.520]                 open = "w")
[10:27:12.520]         }
[10:27:12.520]         else {
[10:27:12.520]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:12.520]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:12.520]         }
[10:27:12.520]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:12.520]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:12.520]             base::sink(type = "output", split = FALSE)
[10:27:12.520]             base::close(...future.stdout)
[10:27:12.520]         }, add = TRUE)
[10:27:12.520]     }
[10:27:12.520]     ...future.frame <- base::sys.nframe()
[10:27:12.520]     ...future.conditions <- base::list()
[10:27:12.520]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:12.520]     if (FALSE) {
[10:27:12.520]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:12.520]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:12.520]     }
[10:27:12.520]     ...future.result <- base::tryCatch({
[10:27:12.520]         base::withCallingHandlers({
[10:27:12.520]             ...future.value <- base::withVisible(base::local({
[10:27:12.520]                 ...future.makeSendCondition <- base::local({
[10:27:12.520]                   sendCondition <- NULL
[10:27:12.520]                   function(frame = 1L) {
[10:27:12.520]                     if (is.function(sendCondition)) 
[10:27:12.520]                       return(sendCondition)
[10:27:12.520]                     ns <- getNamespace("parallel")
[10:27:12.520]                     if (exists("sendData", mode = "function", 
[10:27:12.520]                       envir = ns)) {
[10:27:12.520]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:12.520]                         envir = ns)
[10:27:12.520]                       envir <- sys.frame(frame)
[10:27:12.520]                       master <- NULL
[10:27:12.520]                       while (!identical(envir, .GlobalEnv) && 
[10:27:12.520]                         !identical(envir, emptyenv())) {
[10:27:12.520]                         if (exists("master", mode = "list", envir = envir, 
[10:27:12.520]                           inherits = FALSE)) {
[10:27:12.520]                           master <- get("master", mode = "list", 
[10:27:12.520]                             envir = envir, inherits = FALSE)
[10:27:12.520]                           if (inherits(master, c("SOCKnode", 
[10:27:12.520]                             "SOCK0node"))) {
[10:27:12.520]                             sendCondition <<- function(cond) {
[10:27:12.520]                               data <- list(type = "VALUE", value = cond, 
[10:27:12.520]                                 success = TRUE)
[10:27:12.520]                               parallel_sendData(master, data)
[10:27:12.520]                             }
[10:27:12.520]                             return(sendCondition)
[10:27:12.520]                           }
[10:27:12.520]                         }
[10:27:12.520]                         frame <- frame + 1L
[10:27:12.520]                         envir <- sys.frame(frame)
[10:27:12.520]                       }
[10:27:12.520]                     }
[10:27:12.520]                     sendCondition <<- function(cond) NULL
[10:27:12.520]                   }
[10:27:12.520]                 })
[10:27:12.520]                 withCallingHandlers({
[10:27:12.520]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:27:12.520]                 }, immediateCondition = function(cond) {
[10:27:12.520]                   sendCondition <- ...future.makeSendCondition()
[10:27:12.520]                   sendCondition(cond)
[10:27:12.520]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:12.520]                   {
[10:27:12.520]                     inherits <- base::inherits
[10:27:12.520]                     invokeRestart <- base::invokeRestart
[10:27:12.520]                     is.null <- base::is.null
[10:27:12.520]                     muffled <- FALSE
[10:27:12.520]                     if (inherits(cond, "message")) {
[10:27:12.520]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:12.520]                       if (muffled) 
[10:27:12.520]                         invokeRestart("muffleMessage")
[10:27:12.520]                     }
[10:27:12.520]                     else if (inherits(cond, "warning")) {
[10:27:12.520]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:12.520]                       if (muffled) 
[10:27:12.520]                         invokeRestart("muffleWarning")
[10:27:12.520]                     }
[10:27:12.520]                     else if (inherits(cond, "condition")) {
[10:27:12.520]                       if (!is.null(pattern)) {
[10:27:12.520]                         computeRestarts <- base::computeRestarts
[10:27:12.520]                         grepl <- base::grepl
[10:27:12.520]                         restarts <- computeRestarts(cond)
[10:27:12.520]                         for (restart in restarts) {
[10:27:12.520]                           name <- restart$name
[10:27:12.520]                           if (is.null(name)) 
[10:27:12.520]                             next
[10:27:12.520]                           if (!grepl(pattern, name)) 
[10:27:12.520]                             next
[10:27:12.520]                           invokeRestart(restart)
[10:27:12.520]                           muffled <- TRUE
[10:27:12.520]                           break
[10:27:12.520]                         }
[10:27:12.520]                       }
[10:27:12.520]                     }
[10:27:12.520]                     invisible(muffled)
[10:27:12.520]                   }
[10:27:12.520]                   muffleCondition(cond)
[10:27:12.520]                 })
[10:27:12.520]             }))
[10:27:12.520]             future::FutureResult(value = ...future.value$value, 
[10:27:12.520]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:12.520]                   ...future.rng), globalenv = if (FALSE) 
[10:27:12.520]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:12.520]                     ...future.globalenv.names))
[10:27:12.520]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:12.520]         }, condition = base::local({
[10:27:12.520]             c <- base::c
[10:27:12.520]             inherits <- base::inherits
[10:27:12.520]             invokeRestart <- base::invokeRestart
[10:27:12.520]             length <- base::length
[10:27:12.520]             list <- base::list
[10:27:12.520]             seq.int <- base::seq.int
[10:27:12.520]             signalCondition <- base::signalCondition
[10:27:12.520]             sys.calls <- base::sys.calls
[10:27:12.520]             `[[` <- base::`[[`
[10:27:12.520]             `+` <- base::`+`
[10:27:12.520]             `<<-` <- base::`<<-`
[10:27:12.520]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:12.520]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:12.520]                   3L)]
[10:27:12.520]             }
[10:27:12.520]             function(cond) {
[10:27:12.520]                 is_error <- inherits(cond, "error")
[10:27:12.520]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:12.520]                   NULL)
[10:27:12.520]                 if (is_error) {
[10:27:12.520]                   sessionInformation <- function() {
[10:27:12.520]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:12.520]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:12.520]                       search = base::search(), system = base::Sys.info())
[10:27:12.520]                   }
[10:27:12.520]                   ...future.conditions[[length(...future.conditions) + 
[10:27:12.520]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:12.520]                     cond$call), session = sessionInformation(), 
[10:27:12.520]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:12.520]                   signalCondition(cond)
[10:27:12.520]                 }
[10:27:12.520]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:12.520]                 "immediateCondition"))) {
[10:27:12.520]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:12.520]                   ...future.conditions[[length(...future.conditions) + 
[10:27:12.520]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:12.520]                   if (TRUE && !signal) {
[10:27:12.520]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:12.520]                     {
[10:27:12.520]                       inherits <- base::inherits
[10:27:12.520]                       invokeRestart <- base::invokeRestart
[10:27:12.520]                       is.null <- base::is.null
[10:27:12.520]                       muffled <- FALSE
[10:27:12.520]                       if (inherits(cond, "message")) {
[10:27:12.520]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:12.520]                         if (muffled) 
[10:27:12.520]                           invokeRestart("muffleMessage")
[10:27:12.520]                       }
[10:27:12.520]                       else if (inherits(cond, "warning")) {
[10:27:12.520]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:12.520]                         if (muffled) 
[10:27:12.520]                           invokeRestart("muffleWarning")
[10:27:12.520]                       }
[10:27:12.520]                       else if (inherits(cond, "condition")) {
[10:27:12.520]                         if (!is.null(pattern)) {
[10:27:12.520]                           computeRestarts <- base::computeRestarts
[10:27:12.520]                           grepl <- base::grepl
[10:27:12.520]                           restarts <- computeRestarts(cond)
[10:27:12.520]                           for (restart in restarts) {
[10:27:12.520]                             name <- restart$name
[10:27:12.520]                             if (is.null(name)) 
[10:27:12.520]                               next
[10:27:12.520]                             if (!grepl(pattern, name)) 
[10:27:12.520]                               next
[10:27:12.520]                             invokeRestart(restart)
[10:27:12.520]                             muffled <- TRUE
[10:27:12.520]                             break
[10:27:12.520]                           }
[10:27:12.520]                         }
[10:27:12.520]                       }
[10:27:12.520]                       invisible(muffled)
[10:27:12.520]                     }
[10:27:12.520]                     muffleCondition(cond, pattern = "^muffle")
[10:27:12.520]                   }
[10:27:12.520]                 }
[10:27:12.520]                 else {
[10:27:12.520]                   if (TRUE) {
[10:27:12.520]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:12.520]                     {
[10:27:12.520]                       inherits <- base::inherits
[10:27:12.520]                       invokeRestart <- base::invokeRestart
[10:27:12.520]                       is.null <- base::is.null
[10:27:12.520]                       muffled <- FALSE
[10:27:12.520]                       if (inherits(cond, "message")) {
[10:27:12.520]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:12.520]                         if (muffled) 
[10:27:12.520]                           invokeRestart("muffleMessage")
[10:27:12.520]                       }
[10:27:12.520]                       else if (inherits(cond, "warning")) {
[10:27:12.520]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:12.520]                         if (muffled) 
[10:27:12.520]                           invokeRestart("muffleWarning")
[10:27:12.520]                       }
[10:27:12.520]                       else if (inherits(cond, "condition")) {
[10:27:12.520]                         if (!is.null(pattern)) {
[10:27:12.520]                           computeRestarts <- base::computeRestarts
[10:27:12.520]                           grepl <- base::grepl
[10:27:12.520]                           restarts <- computeRestarts(cond)
[10:27:12.520]                           for (restart in restarts) {
[10:27:12.520]                             name <- restart$name
[10:27:12.520]                             if (is.null(name)) 
[10:27:12.520]                               next
[10:27:12.520]                             if (!grepl(pattern, name)) 
[10:27:12.520]                               next
[10:27:12.520]                             invokeRestart(restart)
[10:27:12.520]                             muffled <- TRUE
[10:27:12.520]                             break
[10:27:12.520]                           }
[10:27:12.520]                         }
[10:27:12.520]                       }
[10:27:12.520]                       invisible(muffled)
[10:27:12.520]                     }
[10:27:12.520]                     muffleCondition(cond, pattern = "^muffle")
[10:27:12.520]                   }
[10:27:12.520]                 }
[10:27:12.520]             }
[10:27:12.520]         }))
[10:27:12.520]     }, error = function(ex) {
[10:27:12.520]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:12.520]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:12.520]                 ...future.rng), started = ...future.startTime, 
[10:27:12.520]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:12.520]             version = "1.8"), class = "FutureResult")
[10:27:12.520]     }, finally = {
[10:27:12.520]         if (!identical(...future.workdir, getwd())) 
[10:27:12.520]             setwd(...future.workdir)
[10:27:12.520]         {
[10:27:12.520]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:12.520]                 ...future.oldOptions$nwarnings <- NULL
[10:27:12.520]             }
[10:27:12.520]             base::options(...future.oldOptions)
[10:27:12.520]             if (.Platform$OS.type == "windows") {
[10:27:12.520]                 old_names <- names(...future.oldEnvVars)
[10:27:12.520]                 envs <- base::Sys.getenv()
[10:27:12.520]                 names <- names(envs)
[10:27:12.520]                 common <- intersect(names, old_names)
[10:27:12.520]                 added <- setdiff(names, old_names)
[10:27:12.520]                 removed <- setdiff(old_names, names)
[10:27:12.520]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:12.520]                   envs[common]]
[10:27:12.520]                 NAMES <- toupper(changed)
[10:27:12.520]                 args <- list()
[10:27:12.520]                 for (kk in seq_along(NAMES)) {
[10:27:12.520]                   name <- changed[[kk]]
[10:27:12.520]                   NAME <- NAMES[[kk]]
[10:27:12.520]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:12.520]                     next
[10:27:12.520]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:12.520]                 }
[10:27:12.520]                 NAMES <- toupper(added)
[10:27:12.520]                 for (kk in seq_along(NAMES)) {
[10:27:12.520]                   name <- added[[kk]]
[10:27:12.520]                   NAME <- NAMES[[kk]]
[10:27:12.520]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:12.520]                     next
[10:27:12.520]                   args[[name]] <- ""
[10:27:12.520]                 }
[10:27:12.520]                 NAMES <- toupper(removed)
[10:27:12.520]                 for (kk in seq_along(NAMES)) {
[10:27:12.520]                   name <- removed[[kk]]
[10:27:12.520]                   NAME <- NAMES[[kk]]
[10:27:12.520]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:12.520]                     next
[10:27:12.520]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:12.520]                 }
[10:27:12.520]                 if (length(args) > 0) 
[10:27:12.520]                   base::do.call(base::Sys.setenv, args = args)
[10:27:12.520]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:12.520]             }
[10:27:12.520]             else {
[10:27:12.520]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:12.520]             }
[10:27:12.520]             {
[10:27:12.520]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:12.520]                   0L) {
[10:27:12.520]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:12.520]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:12.520]                   base::options(opts)
[10:27:12.520]                 }
[10:27:12.520]                 {
[10:27:12.520]                   {
[10:27:12.520]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:12.520]                     NULL
[10:27:12.520]                   }
[10:27:12.520]                   options(future.plan = NULL)
[10:27:12.520]                   if (is.na(NA_character_)) 
[10:27:12.520]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:12.520]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:12.520]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:12.520]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:12.520]                     envir = parent.frame()) 
[10:27:12.520]                   {
[10:27:12.520]                     if (is.function(workers)) 
[10:27:12.520]                       workers <- workers()
[10:27:12.520]                     workers <- structure(as.integer(workers), 
[10:27:12.520]                       class = class(workers))
[10:27:12.520]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:12.520]                       workers >= 1)
[10:27:12.520]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:12.520]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:12.520]                     }
[10:27:12.520]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:12.520]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:12.520]                       envir = envir)
[10:27:12.520]                     if (!future$lazy) 
[10:27:12.520]                       future <- run(future)
[10:27:12.520]                     invisible(future)
[10:27:12.520]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:12.520]                 }
[10:27:12.520]             }
[10:27:12.520]         }
[10:27:12.520]     })
[10:27:12.520]     if (TRUE) {
[10:27:12.520]         base::sink(type = "output", split = FALSE)
[10:27:12.520]         if (TRUE) {
[10:27:12.520]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:12.520]         }
[10:27:12.520]         else {
[10:27:12.520]             ...future.result["stdout"] <- base::list(NULL)
[10:27:12.520]         }
[10:27:12.520]         base::close(...future.stdout)
[10:27:12.520]         ...future.stdout <- NULL
[10:27:12.520]     }
[10:27:12.520]     ...future.result$conditions <- ...future.conditions
[10:27:12.520]     ...future.result$finished <- base::Sys.time()
[10:27:12.520]     ...future.result
[10:27:12.520] }
[10:27:12.523] MultisessionFuture started
[10:27:12.523] - Launch lazy future ... done
[10:27:12.523] run() for ‘MultisessionFuture’ ... done
[10:27:12.574] receiveMessageFromWorker() for ClusterFuture ...
[10:27:12.575] - Validating connection of MultisessionFuture
[10:27:12.575] - received message: FutureResult
[10:27:12.575] - Received FutureResult
[10:27:12.575] - Erased future from FutureRegistry
[10:27:12.575] result() for ClusterFuture ...
[10:27:12.576] - result already collected: FutureResult
[10:27:12.576] result() for ClusterFuture ... done
[10:27:12.576] signalConditions() ...
[10:27:12.576]  - include = ‘immediateCondition’
[10:27:12.576]  - exclude = 
[10:27:12.576]  - resignal = FALSE
[10:27:12.576]  - Number of conditions: 1
[10:27:12.577] signalConditions() ... done
[10:27:12.577] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:12.577] A MultisessionFuture was resolved (result was not collected)
[10:27:12.577] getGlobalsAndPackages() ...
[10:27:12.577] Searching for globals...
[10:27:12.579] - globals found: [2] ‘list’, ‘stop’
[10:27:12.579] Searching for globals ... DONE
[10:27:12.579] Resolving globals: FALSE
[10:27:12.580] 
[10:27:12.580] 
[10:27:12.580] getGlobalsAndPackages() ... DONE
[10:27:12.580] run() for ‘Future’ ...
[10:27:12.580] - state: ‘created’
[10:27:12.581] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:12.598] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:12.598] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:12.599]   - Field: ‘node’
[10:27:12.599]   - Field: ‘label’
[10:27:12.599]   - Field: ‘local’
[10:27:12.599]   - Field: ‘owner’
[10:27:12.599]   - Field: ‘envir’
[10:27:12.599]   - Field: ‘workers’
[10:27:12.600]   - Field: ‘packages’
[10:27:12.600]   - Field: ‘gc’
[10:27:12.600]   - Field: ‘conditions’
[10:27:12.600]   - Field: ‘persistent’
[10:27:12.600]   - Field: ‘expr’
[10:27:12.601]   - Field: ‘uuid’
[10:27:12.601]   - Field: ‘seed’
[10:27:12.601]   - Field: ‘version’
[10:27:12.601]   - Field: ‘result’
[10:27:12.601]   - Field: ‘asynchronous’
[10:27:12.601]   - Field: ‘calls’
[10:27:12.601]   - Field: ‘globals’
[10:27:12.601]   - Field: ‘stdout’
[10:27:12.601]   - Field: ‘earlySignal’
[10:27:12.602]   - Field: ‘lazy’
[10:27:12.602]   - Field: ‘state’
[10:27:12.602] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:12.602] - Launch lazy future ...
[10:27:12.602] Packages needed by the future expression (n = 0): <none>
[10:27:12.602] Packages needed by future strategies (n = 0): <none>
[10:27:12.603] {
[10:27:12.603]     {
[10:27:12.603]         {
[10:27:12.603]             ...future.startTime <- base::Sys.time()
[10:27:12.603]             {
[10:27:12.603]                 {
[10:27:12.603]                   {
[10:27:12.603]                     {
[10:27:12.603]                       base::local({
[10:27:12.603]                         has_future <- base::requireNamespace("future", 
[10:27:12.603]                           quietly = TRUE)
[10:27:12.603]                         if (has_future) {
[10:27:12.603]                           ns <- base::getNamespace("future")
[10:27:12.603]                           version <- ns[[".package"]][["version"]]
[10:27:12.603]                           if (is.null(version)) 
[10:27:12.603]                             version <- utils::packageVersion("future")
[10:27:12.603]                         }
[10:27:12.603]                         else {
[10:27:12.603]                           version <- NULL
[10:27:12.603]                         }
[10:27:12.603]                         if (!has_future || version < "1.8.0") {
[10:27:12.603]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:12.603]                             "", base::R.version$version.string), 
[10:27:12.603]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:12.603]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:12.603]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:12.603]                               "release", "version")], collapse = " "), 
[10:27:12.603]                             hostname = base::Sys.info()[["nodename"]])
[10:27:12.603]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:12.603]                             info)
[10:27:12.603]                           info <- base::paste(info, collapse = "; ")
[10:27:12.603]                           if (!has_future) {
[10:27:12.603]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:12.603]                               info)
[10:27:12.603]                           }
[10:27:12.603]                           else {
[10:27:12.603]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:12.603]                               info, version)
[10:27:12.603]                           }
[10:27:12.603]                           base::stop(msg)
[10:27:12.603]                         }
[10:27:12.603]                       })
[10:27:12.603]                     }
[10:27:12.603]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:12.603]                     base::options(mc.cores = 1L)
[10:27:12.603]                   }
[10:27:12.603]                   options(future.plan = NULL)
[10:27:12.603]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:12.603]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:12.603]                 }
[10:27:12.603]                 ...future.workdir <- getwd()
[10:27:12.603]             }
[10:27:12.603]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:12.603]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:12.603]         }
[10:27:12.603]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:12.603]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:12.603]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:12.603]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:12.603]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:12.603]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:12.603]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:12.603]             base::names(...future.oldOptions))
[10:27:12.603]     }
[10:27:12.603]     if (FALSE) {
[10:27:12.603]     }
[10:27:12.603]     else {
[10:27:12.603]         if (TRUE) {
[10:27:12.603]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:12.603]                 open = "w")
[10:27:12.603]         }
[10:27:12.603]         else {
[10:27:12.603]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:12.603]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:12.603]         }
[10:27:12.603]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:12.603]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:12.603]             base::sink(type = "output", split = FALSE)
[10:27:12.603]             base::close(...future.stdout)
[10:27:12.603]         }, add = TRUE)
[10:27:12.603]     }
[10:27:12.603]     ...future.frame <- base::sys.nframe()
[10:27:12.603]     ...future.conditions <- base::list()
[10:27:12.603]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:12.603]     if (FALSE) {
[10:27:12.603]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:12.603]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:12.603]     }
[10:27:12.603]     ...future.result <- base::tryCatch({
[10:27:12.603]         base::withCallingHandlers({
[10:27:12.603]             ...future.value <- base::withVisible(base::local({
[10:27:12.603]                 ...future.makeSendCondition <- base::local({
[10:27:12.603]                   sendCondition <- NULL
[10:27:12.603]                   function(frame = 1L) {
[10:27:12.603]                     if (is.function(sendCondition)) 
[10:27:12.603]                       return(sendCondition)
[10:27:12.603]                     ns <- getNamespace("parallel")
[10:27:12.603]                     if (exists("sendData", mode = "function", 
[10:27:12.603]                       envir = ns)) {
[10:27:12.603]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:12.603]                         envir = ns)
[10:27:12.603]                       envir <- sys.frame(frame)
[10:27:12.603]                       master <- NULL
[10:27:12.603]                       while (!identical(envir, .GlobalEnv) && 
[10:27:12.603]                         !identical(envir, emptyenv())) {
[10:27:12.603]                         if (exists("master", mode = "list", envir = envir, 
[10:27:12.603]                           inherits = FALSE)) {
[10:27:12.603]                           master <- get("master", mode = "list", 
[10:27:12.603]                             envir = envir, inherits = FALSE)
[10:27:12.603]                           if (inherits(master, c("SOCKnode", 
[10:27:12.603]                             "SOCK0node"))) {
[10:27:12.603]                             sendCondition <<- function(cond) {
[10:27:12.603]                               data <- list(type = "VALUE", value = cond, 
[10:27:12.603]                                 success = TRUE)
[10:27:12.603]                               parallel_sendData(master, data)
[10:27:12.603]                             }
[10:27:12.603]                             return(sendCondition)
[10:27:12.603]                           }
[10:27:12.603]                         }
[10:27:12.603]                         frame <- frame + 1L
[10:27:12.603]                         envir <- sys.frame(frame)
[10:27:12.603]                       }
[10:27:12.603]                     }
[10:27:12.603]                     sendCondition <<- function(cond) NULL
[10:27:12.603]                   }
[10:27:12.603]                 })
[10:27:12.603]                 withCallingHandlers({
[10:27:12.603]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:27:12.603]                 }, immediateCondition = function(cond) {
[10:27:12.603]                   sendCondition <- ...future.makeSendCondition()
[10:27:12.603]                   sendCondition(cond)
[10:27:12.603]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:12.603]                   {
[10:27:12.603]                     inherits <- base::inherits
[10:27:12.603]                     invokeRestart <- base::invokeRestart
[10:27:12.603]                     is.null <- base::is.null
[10:27:12.603]                     muffled <- FALSE
[10:27:12.603]                     if (inherits(cond, "message")) {
[10:27:12.603]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:12.603]                       if (muffled) 
[10:27:12.603]                         invokeRestart("muffleMessage")
[10:27:12.603]                     }
[10:27:12.603]                     else if (inherits(cond, "warning")) {
[10:27:12.603]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:12.603]                       if (muffled) 
[10:27:12.603]                         invokeRestart("muffleWarning")
[10:27:12.603]                     }
[10:27:12.603]                     else if (inherits(cond, "condition")) {
[10:27:12.603]                       if (!is.null(pattern)) {
[10:27:12.603]                         computeRestarts <- base::computeRestarts
[10:27:12.603]                         grepl <- base::grepl
[10:27:12.603]                         restarts <- computeRestarts(cond)
[10:27:12.603]                         for (restart in restarts) {
[10:27:12.603]                           name <- restart$name
[10:27:12.603]                           if (is.null(name)) 
[10:27:12.603]                             next
[10:27:12.603]                           if (!grepl(pattern, name)) 
[10:27:12.603]                             next
[10:27:12.603]                           invokeRestart(restart)
[10:27:12.603]                           muffled <- TRUE
[10:27:12.603]                           break
[10:27:12.603]                         }
[10:27:12.603]                       }
[10:27:12.603]                     }
[10:27:12.603]                     invisible(muffled)
[10:27:12.603]                   }
[10:27:12.603]                   muffleCondition(cond)
[10:27:12.603]                 })
[10:27:12.603]             }))
[10:27:12.603]             future::FutureResult(value = ...future.value$value, 
[10:27:12.603]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:12.603]                   ...future.rng), globalenv = if (FALSE) 
[10:27:12.603]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:12.603]                     ...future.globalenv.names))
[10:27:12.603]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:12.603]         }, condition = base::local({
[10:27:12.603]             c <- base::c
[10:27:12.603]             inherits <- base::inherits
[10:27:12.603]             invokeRestart <- base::invokeRestart
[10:27:12.603]             length <- base::length
[10:27:12.603]             list <- base::list
[10:27:12.603]             seq.int <- base::seq.int
[10:27:12.603]             signalCondition <- base::signalCondition
[10:27:12.603]             sys.calls <- base::sys.calls
[10:27:12.603]             `[[` <- base::`[[`
[10:27:12.603]             `+` <- base::`+`
[10:27:12.603]             `<<-` <- base::`<<-`
[10:27:12.603]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:12.603]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:12.603]                   3L)]
[10:27:12.603]             }
[10:27:12.603]             function(cond) {
[10:27:12.603]                 is_error <- inherits(cond, "error")
[10:27:12.603]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:12.603]                   NULL)
[10:27:12.603]                 if (is_error) {
[10:27:12.603]                   sessionInformation <- function() {
[10:27:12.603]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:12.603]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:12.603]                       search = base::search(), system = base::Sys.info())
[10:27:12.603]                   }
[10:27:12.603]                   ...future.conditions[[length(...future.conditions) + 
[10:27:12.603]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:12.603]                     cond$call), session = sessionInformation(), 
[10:27:12.603]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:12.603]                   signalCondition(cond)
[10:27:12.603]                 }
[10:27:12.603]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:12.603]                 "immediateCondition"))) {
[10:27:12.603]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:12.603]                   ...future.conditions[[length(...future.conditions) + 
[10:27:12.603]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:12.603]                   if (TRUE && !signal) {
[10:27:12.603]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:12.603]                     {
[10:27:12.603]                       inherits <- base::inherits
[10:27:12.603]                       invokeRestart <- base::invokeRestart
[10:27:12.603]                       is.null <- base::is.null
[10:27:12.603]                       muffled <- FALSE
[10:27:12.603]                       if (inherits(cond, "message")) {
[10:27:12.603]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:12.603]                         if (muffled) 
[10:27:12.603]                           invokeRestart("muffleMessage")
[10:27:12.603]                       }
[10:27:12.603]                       else if (inherits(cond, "warning")) {
[10:27:12.603]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:12.603]                         if (muffled) 
[10:27:12.603]                           invokeRestart("muffleWarning")
[10:27:12.603]                       }
[10:27:12.603]                       else if (inherits(cond, "condition")) {
[10:27:12.603]                         if (!is.null(pattern)) {
[10:27:12.603]                           computeRestarts <- base::computeRestarts
[10:27:12.603]                           grepl <- base::grepl
[10:27:12.603]                           restarts <- computeRestarts(cond)
[10:27:12.603]                           for (restart in restarts) {
[10:27:12.603]                             name <- restart$name
[10:27:12.603]                             if (is.null(name)) 
[10:27:12.603]                               next
[10:27:12.603]                             if (!grepl(pattern, name)) 
[10:27:12.603]                               next
[10:27:12.603]                             invokeRestart(restart)
[10:27:12.603]                             muffled <- TRUE
[10:27:12.603]                             break
[10:27:12.603]                           }
[10:27:12.603]                         }
[10:27:12.603]                       }
[10:27:12.603]                       invisible(muffled)
[10:27:12.603]                     }
[10:27:12.603]                     muffleCondition(cond, pattern = "^muffle")
[10:27:12.603]                   }
[10:27:12.603]                 }
[10:27:12.603]                 else {
[10:27:12.603]                   if (TRUE) {
[10:27:12.603]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:12.603]                     {
[10:27:12.603]                       inherits <- base::inherits
[10:27:12.603]                       invokeRestart <- base::invokeRestart
[10:27:12.603]                       is.null <- base::is.null
[10:27:12.603]                       muffled <- FALSE
[10:27:12.603]                       if (inherits(cond, "message")) {
[10:27:12.603]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:12.603]                         if (muffled) 
[10:27:12.603]                           invokeRestart("muffleMessage")
[10:27:12.603]                       }
[10:27:12.603]                       else if (inherits(cond, "warning")) {
[10:27:12.603]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:12.603]                         if (muffled) 
[10:27:12.603]                           invokeRestart("muffleWarning")
[10:27:12.603]                       }
[10:27:12.603]                       else if (inherits(cond, "condition")) {
[10:27:12.603]                         if (!is.null(pattern)) {
[10:27:12.603]                           computeRestarts <- base::computeRestarts
[10:27:12.603]                           grepl <- base::grepl
[10:27:12.603]                           restarts <- computeRestarts(cond)
[10:27:12.603]                           for (restart in restarts) {
[10:27:12.603]                             name <- restart$name
[10:27:12.603]                             if (is.null(name)) 
[10:27:12.603]                               next
[10:27:12.603]                             if (!grepl(pattern, name)) 
[10:27:12.603]                               next
[10:27:12.603]                             invokeRestart(restart)
[10:27:12.603]                             muffled <- TRUE
[10:27:12.603]                             break
[10:27:12.603]                           }
[10:27:12.603]                         }
[10:27:12.603]                       }
[10:27:12.603]                       invisible(muffled)
[10:27:12.603]                     }
[10:27:12.603]                     muffleCondition(cond, pattern = "^muffle")
[10:27:12.603]                   }
[10:27:12.603]                 }
[10:27:12.603]             }
[10:27:12.603]         }))
[10:27:12.603]     }, error = function(ex) {
[10:27:12.603]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:12.603]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:12.603]                 ...future.rng), started = ...future.startTime, 
[10:27:12.603]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:12.603]             version = "1.8"), class = "FutureResult")
[10:27:12.603]     }, finally = {
[10:27:12.603]         if (!identical(...future.workdir, getwd())) 
[10:27:12.603]             setwd(...future.workdir)
[10:27:12.603]         {
[10:27:12.603]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:12.603]                 ...future.oldOptions$nwarnings <- NULL
[10:27:12.603]             }
[10:27:12.603]             base::options(...future.oldOptions)
[10:27:12.603]             if (.Platform$OS.type == "windows") {
[10:27:12.603]                 old_names <- names(...future.oldEnvVars)
[10:27:12.603]                 envs <- base::Sys.getenv()
[10:27:12.603]                 names <- names(envs)
[10:27:12.603]                 common <- intersect(names, old_names)
[10:27:12.603]                 added <- setdiff(names, old_names)
[10:27:12.603]                 removed <- setdiff(old_names, names)
[10:27:12.603]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:12.603]                   envs[common]]
[10:27:12.603]                 NAMES <- toupper(changed)
[10:27:12.603]                 args <- list()
[10:27:12.603]                 for (kk in seq_along(NAMES)) {
[10:27:12.603]                   name <- changed[[kk]]
[10:27:12.603]                   NAME <- NAMES[[kk]]
[10:27:12.603]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:12.603]                     next
[10:27:12.603]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:12.603]                 }
[10:27:12.603]                 NAMES <- toupper(added)
[10:27:12.603]                 for (kk in seq_along(NAMES)) {
[10:27:12.603]                   name <- added[[kk]]
[10:27:12.603]                   NAME <- NAMES[[kk]]
[10:27:12.603]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:12.603]                     next
[10:27:12.603]                   args[[name]] <- ""
[10:27:12.603]                 }
[10:27:12.603]                 NAMES <- toupper(removed)
[10:27:12.603]                 for (kk in seq_along(NAMES)) {
[10:27:12.603]                   name <- removed[[kk]]
[10:27:12.603]                   NAME <- NAMES[[kk]]
[10:27:12.603]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:12.603]                     next
[10:27:12.603]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:12.603]                 }
[10:27:12.603]                 if (length(args) > 0) 
[10:27:12.603]                   base::do.call(base::Sys.setenv, args = args)
[10:27:12.603]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:12.603]             }
[10:27:12.603]             else {
[10:27:12.603]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:12.603]             }
[10:27:12.603]             {
[10:27:12.603]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:12.603]                   0L) {
[10:27:12.603]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:12.603]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:12.603]                   base::options(opts)
[10:27:12.603]                 }
[10:27:12.603]                 {
[10:27:12.603]                   {
[10:27:12.603]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:12.603]                     NULL
[10:27:12.603]                   }
[10:27:12.603]                   options(future.plan = NULL)
[10:27:12.603]                   if (is.na(NA_character_)) 
[10:27:12.603]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:12.603]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:12.603]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:12.603]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:12.603]                     envir = parent.frame()) 
[10:27:12.603]                   {
[10:27:12.603]                     if (is.function(workers)) 
[10:27:12.603]                       workers <- workers()
[10:27:12.603]                     workers <- structure(as.integer(workers), 
[10:27:12.603]                       class = class(workers))
[10:27:12.603]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:12.603]                       workers >= 1)
[10:27:12.603]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:12.603]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:12.603]                     }
[10:27:12.603]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:12.603]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:12.603]                       envir = envir)
[10:27:12.603]                     if (!future$lazy) 
[10:27:12.603]                       future <- run(future)
[10:27:12.603]                     invisible(future)
[10:27:12.603]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:12.603]                 }
[10:27:12.603]             }
[10:27:12.603]         }
[10:27:12.603]     })
[10:27:12.603]     if (TRUE) {
[10:27:12.603]         base::sink(type = "output", split = FALSE)
[10:27:12.603]         if (TRUE) {
[10:27:12.603]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:12.603]         }
[10:27:12.603]         else {
[10:27:12.603]             ...future.result["stdout"] <- base::list(NULL)
[10:27:12.603]         }
[10:27:12.603]         base::close(...future.stdout)
[10:27:12.603]         ...future.stdout <- NULL
[10:27:12.603]     }
[10:27:12.603]     ...future.result$conditions <- ...future.conditions
[10:27:12.603]     ...future.result$finished <- base::Sys.time()
[10:27:12.603]     ...future.result
[10:27:12.603] }
[10:27:12.606] MultisessionFuture started
[10:27:12.606] - Launch lazy future ... done
[10:27:12.606] run() for ‘MultisessionFuture’ ... done
[10:27:12.654] receiveMessageFromWorker() for ClusterFuture ...
[10:27:12.655] - Validating connection of MultisessionFuture
[10:27:12.655] - received message: FutureResult
[10:27:12.655] - Received FutureResult
[10:27:12.655] - Erased future from FutureRegistry
[10:27:12.656] result() for ClusterFuture ...
[10:27:12.656] - result already collected: FutureResult
[10:27:12.656] result() for ClusterFuture ... done
[10:27:12.656] signalConditions() ...
[10:27:12.656]  - include = ‘immediateCondition’
[10:27:12.656]  - exclude = 
[10:27:12.656]  - resignal = FALSE
[10:27:12.656]  - Number of conditions: 1
[10:27:12.656] signalConditions() ... done
[10:27:12.656] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:12.656] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = Inf ... DONE
- result = TRUE, recursive = FALSE ...
[10:27:12.657] getGlobalsAndPackages() ...
[10:27:12.657] Searching for globals...
[10:27:12.658] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:27:12.658] Searching for globals ... DONE
[10:27:12.658] Resolving globals: FALSE
[10:27:12.659] 
[10:27:12.659] 
[10:27:12.659] getGlobalsAndPackages() ... DONE
[10:27:12.659] run() for ‘Future’ ...
[10:27:12.659] - state: ‘created’
[10:27:12.659] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:12.677] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:12.678] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:12.678]   - Field: ‘node’
[10:27:12.678]   - Field: ‘label’
[10:27:12.678]   - Field: ‘local’
[10:27:12.678]   - Field: ‘owner’
[10:27:12.678]   - Field: ‘envir’
[10:27:12.678]   - Field: ‘workers’
[10:27:12.678]   - Field: ‘packages’
[10:27:12.678]   - Field: ‘gc’
[10:27:12.678]   - Field: ‘conditions’
[10:27:12.679]   - Field: ‘persistent’
[10:27:12.679]   - Field: ‘expr’
[10:27:12.679]   - Field: ‘uuid’
[10:27:12.679]   - Field: ‘seed’
[10:27:12.679]   - Field: ‘version’
[10:27:12.679]   - Field: ‘result’
[10:27:12.679]   - Field: ‘asynchronous’
[10:27:12.679]   - Field: ‘calls’
[10:27:12.679]   - Field: ‘globals’
[10:27:12.679]   - Field: ‘stdout’
[10:27:12.680]   - Field: ‘earlySignal’
[10:27:12.680]   - Field: ‘lazy’
[10:27:12.680]   - Field: ‘state’
[10:27:12.680] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:12.680] - Launch lazy future ...
[10:27:12.680] Packages needed by the future expression (n = 0): <none>
[10:27:12.680] Packages needed by future strategies (n = 0): <none>
[10:27:12.681] {
[10:27:12.681]     {
[10:27:12.681]         {
[10:27:12.681]             ...future.startTime <- base::Sys.time()
[10:27:12.681]             {
[10:27:12.681]                 {
[10:27:12.681]                   {
[10:27:12.681]                     {
[10:27:12.681]                       base::local({
[10:27:12.681]                         has_future <- base::requireNamespace("future", 
[10:27:12.681]                           quietly = TRUE)
[10:27:12.681]                         if (has_future) {
[10:27:12.681]                           ns <- base::getNamespace("future")
[10:27:12.681]                           version <- ns[[".package"]][["version"]]
[10:27:12.681]                           if (is.null(version)) 
[10:27:12.681]                             version <- utils::packageVersion("future")
[10:27:12.681]                         }
[10:27:12.681]                         else {
[10:27:12.681]                           version <- NULL
[10:27:12.681]                         }
[10:27:12.681]                         if (!has_future || version < "1.8.0") {
[10:27:12.681]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:12.681]                             "", base::R.version$version.string), 
[10:27:12.681]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:12.681]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:12.681]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:12.681]                               "release", "version")], collapse = " "), 
[10:27:12.681]                             hostname = base::Sys.info()[["nodename"]])
[10:27:12.681]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:12.681]                             info)
[10:27:12.681]                           info <- base::paste(info, collapse = "; ")
[10:27:12.681]                           if (!has_future) {
[10:27:12.681]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:12.681]                               info)
[10:27:12.681]                           }
[10:27:12.681]                           else {
[10:27:12.681]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:12.681]                               info, version)
[10:27:12.681]                           }
[10:27:12.681]                           base::stop(msg)
[10:27:12.681]                         }
[10:27:12.681]                       })
[10:27:12.681]                     }
[10:27:12.681]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:12.681]                     base::options(mc.cores = 1L)
[10:27:12.681]                   }
[10:27:12.681]                   options(future.plan = NULL)
[10:27:12.681]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:12.681]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:12.681]                 }
[10:27:12.681]                 ...future.workdir <- getwd()
[10:27:12.681]             }
[10:27:12.681]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:12.681]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:12.681]         }
[10:27:12.681]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:12.681]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:12.681]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:12.681]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:12.681]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:12.681]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:12.681]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:12.681]             base::names(...future.oldOptions))
[10:27:12.681]     }
[10:27:12.681]     if (FALSE) {
[10:27:12.681]     }
[10:27:12.681]     else {
[10:27:12.681]         if (TRUE) {
[10:27:12.681]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:12.681]                 open = "w")
[10:27:12.681]         }
[10:27:12.681]         else {
[10:27:12.681]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:12.681]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:12.681]         }
[10:27:12.681]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:12.681]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:12.681]             base::sink(type = "output", split = FALSE)
[10:27:12.681]             base::close(...future.stdout)
[10:27:12.681]         }, add = TRUE)
[10:27:12.681]     }
[10:27:12.681]     ...future.frame <- base::sys.nframe()
[10:27:12.681]     ...future.conditions <- base::list()
[10:27:12.681]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:12.681]     if (FALSE) {
[10:27:12.681]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:12.681]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:12.681]     }
[10:27:12.681]     ...future.result <- base::tryCatch({
[10:27:12.681]         base::withCallingHandlers({
[10:27:12.681]             ...future.value <- base::withVisible(base::local({
[10:27:12.681]                 ...future.makeSendCondition <- base::local({
[10:27:12.681]                   sendCondition <- NULL
[10:27:12.681]                   function(frame = 1L) {
[10:27:12.681]                     if (is.function(sendCondition)) 
[10:27:12.681]                       return(sendCondition)
[10:27:12.681]                     ns <- getNamespace("parallel")
[10:27:12.681]                     if (exists("sendData", mode = "function", 
[10:27:12.681]                       envir = ns)) {
[10:27:12.681]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:12.681]                         envir = ns)
[10:27:12.681]                       envir <- sys.frame(frame)
[10:27:12.681]                       master <- NULL
[10:27:12.681]                       while (!identical(envir, .GlobalEnv) && 
[10:27:12.681]                         !identical(envir, emptyenv())) {
[10:27:12.681]                         if (exists("master", mode = "list", envir = envir, 
[10:27:12.681]                           inherits = FALSE)) {
[10:27:12.681]                           master <- get("master", mode = "list", 
[10:27:12.681]                             envir = envir, inherits = FALSE)
[10:27:12.681]                           if (inherits(master, c("SOCKnode", 
[10:27:12.681]                             "SOCK0node"))) {
[10:27:12.681]                             sendCondition <<- function(cond) {
[10:27:12.681]                               data <- list(type = "VALUE", value = cond, 
[10:27:12.681]                                 success = TRUE)
[10:27:12.681]                               parallel_sendData(master, data)
[10:27:12.681]                             }
[10:27:12.681]                             return(sendCondition)
[10:27:12.681]                           }
[10:27:12.681]                         }
[10:27:12.681]                         frame <- frame + 1L
[10:27:12.681]                         envir <- sys.frame(frame)
[10:27:12.681]                       }
[10:27:12.681]                     }
[10:27:12.681]                     sendCondition <<- function(cond) NULL
[10:27:12.681]                   }
[10:27:12.681]                 })
[10:27:12.681]                 withCallingHandlers({
[10:27:12.681]                   {
[10:27:12.681]                     Sys.sleep(0.5)
[10:27:12.681]                     list(a = 1, b = 42L)
[10:27:12.681]                   }
[10:27:12.681]                 }, immediateCondition = function(cond) {
[10:27:12.681]                   sendCondition <- ...future.makeSendCondition()
[10:27:12.681]                   sendCondition(cond)
[10:27:12.681]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:12.681]                   {
[10:27:12.681]                     inherits <- base::inherits
[10:27:12.681]                     invokeRestart <- base::invokeRestart
[10:27:12.681]                     is.null <- base::is.null
[10:27:12.681]                     muffled <- FALSE
[10:27:12.681]                     if (inherits(cond, "message")) {
[10:27:12.681]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:12.681]                       if (muffled) 
[10:27:12.681]                         invokeRestart("muffleMessage")
[10:27:12.681]                     }
[10:27:12.681]                     else if (inherits(cond, "warning")) {
[10:27:12.681]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:12.681]                       if (muffled) 
[10:27:12.681]                         invokeRestart("muffleWarning")
[10:27:12.681]                     }
[10:27:12.681]                     else if (inherits(cond, "condition")) {
[10:27:12.681]                       if (!is.null(pattern)) {
[10:27:12.681]                         computeRestarts <- base::computeRestarts
[10:27:12.681]                         grepl <- base::grepl
[10:27:12.681]                         restarts <- computeRestarts(cond)
[10:27:12.681]                         for (restart in restarts) {
[10:27:12.681]                           name <- restart$name
[10:27:12.681]                           if (is.null(name)) 
[10:27:12.681]                             next
[10:27:12.681]                           if (!grepl(pattern, name)) 
[10:27:12.681]                             next
[10:27:12.681]                           invokeRestart(restart)
[10:27:12.681]                           muffled <- TRUE
[10:27:12.681]                           break
[10:27:12.681]                         }
[10:27:12.681]                       }
[10:27:12.681]                     }
[10:27:12.681]                     invisible(muffled)
[10:27:12.681]                   }
[10:27:12.681]                   muffleCondition(cond)
[10:27:12.681]                 })
[10:27:12.681]             }))
[10:27:12.681]             future::FutureResult(value = ...future.value$value, 
[10:27:12.681]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:12.681]                   ...future.rng), globalenv = if (FALSE) 
[10:27:12.681]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:12.681]                     ...future.globalenv.names))
[10:27:12.681]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:12.681]         }, condition = base::local({
[10:27:12.681]             c <- base::c
[10:27:12.681]             inherits <- base::inherits
[10:27:12.681]             invokeRestart <- base::invokeRestart
[10:27:12.681]             length <- base::length
[10:27:12.681]             list <- base::list
[10:27:12.681]             seq.int <- base::seq.int
[10:27:12.681]             signalCondition <- base::signalCondition
[10:27:12.681]             sys.calls <- base::sys.calls
[10:27:12.681]             `[[` <- base::`[[`
[10:27:12.681]             `+` <- base::`+`
[10:27:12.681]             `<<-` <- base::`<<-`
[10:27:12.681]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:12.681]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:12.681]                   3L)]
[10:27:12.681]             }
[10:27:12.681]             function(cond) {
[10:27:12.681]                 is_error <- inherits(cond, "error")
[10:27:12.681]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:12.681]                   NULL)
[10:27:12.681]                 if (is_error) {
[10:27:12.681]                   sessionInformation <- function() {
[10:27:12.681]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:12.681]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:12.681]                       search = base::search(), system = base::Sys.info())
[10:27:12.681]                   }
[10:27:12.681]                   ...future.conditions[[length(...future.conditions) + 
[10:27:12.681]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:12.681]                     cond$call), session = sessionInformation(), 
[10:27:12.681]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:12.681]                   signalCondition(cond)
[10:27:12.681]                 }
[10:27:12.681]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:12.681]                 "immediateCondition"))) {
[10:27:12.681]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:12.681]                   ...future.conditions[[length(...future.conditions) + 
[10:27:12.681]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:12.681]                   if (TRUE && !signal) {
[10:27:12.681]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:12.681]                     {
[10:27:12.681]                       inherits <- base::inherits
[10:27:12.681]                       invokeRestart <- base::invokeRestart
[10:27:12.681]                       is.null <- base::is.null
[10:27:12.681]                       muffled <- FALSE
[10:27:12.681]                       if (inherits(cond, "message")) {
[10:27:12.681]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:12.681]                         if (muffled) 
[10:27:12.681]                           invokeRestart("muffleMessage")
[10:27:12.681]                       }
[10:27:12.681]                       else if (inherits(cond, "warning")) {
[10:27:12.681]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:12.681]                         if (muffled) 
[10:27:12.681]                           invokeRestart("muffleWarning")
[10:27:12.681]                       }
[10:27:12.681]                       else if (inherits(cond, "condition")) {
[10:27:12.681]                         if (!is.null(pattern)) {
[10:27:12.681]                           computeRestarts <- base::computeRestarts
[10:27:12.681]                           grepl <- base::grepl
[10:27:12.681]                           restarts <- computeRestarts(cond)
[10:27:12.681]                           for (restart in restarts) {
[10:27:12.681]                             name <- restart$name
[10:27:12.681]                             if (is.null(name)) 
[10:27:12.681]                               next
[10:27:12.681]                             if (!grepl(pattern, name)) 
[10:27:12.681]                               next
[10:27:12.681]                             invokeRestart(restart)
[10:27:12.681]                             muffled <- TRUE
[10:27:12.681]                             break
[10:27:12.681]                           }
[10:27:12.681]                         }
[10:27:12.681]                       }
[10:27:12.681]                       invisible(muffled)
[10:27:12.681]                     }
[10:27:12.681]                     muffleCondition(cond, pattern = "^muffle")
[10:27:12.681]                   }
[10:27:12.681]                 }
[10:27:12.681]                 else {
[10:27:12.681]                   if (TRUE) {
[10:27:12.681]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:12.681]                     {
[10:27:12.681]                       inherits <- base::inherits
[10:27:12.681]                       invokeRestart <- base::invokeRestart
[10:27:12.681]                       is.null <- base::is.null
[10:27:12.681]                       muffled <- FALSE
[10:27:12.681]                       if (inherits(cond, "message")) {
[10:27:12.681]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:12.681]                         if (muffled) 
[10:27:12.681]                           invokeRestart("muffleMessage")
[10:27:12.681]                       }
[10:27:12.681]                       else if (inherits(cond, "warning")) {
[10:27:12.681]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:12.681]                         if (muffled) 
[10:27:12.681]                           invokeRestart("muffleWarning")
[10:27:12.681]                       }
[10:27:12.681]                       else if (inherits(cond, "condition")) {
[10:27:12.681]                         if (!is.null(pattern)) {
[10:27:12.681]                           computeRestarts <- base::computeRestarts
[10:27:12.681]                           grepl <- base::grepl
[10:27:12.681]                           restarts <- computeRestarts(cond)
[10:27:12.681]                           for (restart in restarts) {
[10:27:12.681]                             name <- restart$name
[10:27:12.681]                             if (is.null(name)) 
[10:27:12.681]                               next
[10:27:12.681]                             if (!grepl(pattern, name)) 
[10:27:12.681]                               next
[10:27:12.681]                             invokeRestart(restart)
[10:27:12.681]                             muffled <- TRUE
[10:27:12.681]                             break
[10:27:12.681]                           }
[10:27:12.681]                         }
[10:27:12.681]                       }
[10:27:12.681]                       invisible(muffled)
[10:27:12.681]                     }
[10:27:12.681]                     muffleCondition(cond, pattern = "^muffle")
[10:27:12.681]                   }
[10:27:12.681]                 }
[10:27:12.681]             }
[10:27:12.681]         }))
[10:27:12.681]     }, error = function(ex) {
[10:27:12.681]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:12.681]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:12.681]                 ...future.rng), started = ...future.startTime, 
[10:27:12.681]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:12.681]             version = "1.8"), class = "FutureResult")
[10:27:12.681]     }, finally = {
[10:27:12.681]         if (!identical(...future.workdir, getwd())) 
[10:27:12.681]             setwd(...future.workdir)
[10:27:12.681]         {
[10:27:12.681]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:12.681]                 ...future.oldOptions$nwarnings <- NULL
[10:27:12.681]             }
[10:27:12.681]             base::options(...future.oldOptions)
[10:27:12.681]             if (.Platform$OS.type == "windows") {
[10:27:12.681]                 old_names <- names(...future.oldEnvVars)
[10:27:12.681]                 envs <- base::Sys.getenv()
[10:27:12.681]                 names <- names(envs)
[10:27:12.681]                 common <- intersect(names, old_names)
[10:27:12.681]                 added <- setdiff(names, old_names)
[10:27:12.681]                 removed <- setdiff(old_names, names)
[10:27:12.681]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:12.681]                   envs[common]]
[10:27:12.681]                 NAMES <- toupper(changed)
[10:27:12.681]                 args <- list()
[10:27:12.681]                 for (kk in seq_along(NAMES)) {
[10:27:12.681]                   name <- changed[[kk]]
[10:27:12.681]                   NAME <- NAMES[[kk]]
[10:27:12.681]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:12.681]                     next
[10:27:12.681]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:12.681]                 }
[10:27:12.681]                 NAMES <- toupper(added)
[10:27:12.681]                 for (kk in seq_along(NAMES)) {
[10:27:12.681]                   name <- added[[kk]]
[10:27:12.681]                   NAME <- NAMES[[kk]]
[10:27:12.681]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:12.681]                     next
[10:27:12.681]                   args[[name]] <- ""
[10:27:12.681]                 }
[10:27:12.681]                 NAMES <- toupper(removed)
[10:27:12.681]                 for (kk in seq_along(NAMES)) {
[10:27:12.681]                   name <- removed[[kk]]
[10:27:12.681]                   NAME <- NAMES[[kk]]
[10:27:12.681]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:12.681]                     next
[10:27:12.681]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:12.681]                 }
[10:27:12.681]                 if (length(args) > 0) 
[10:27:12.681]                   base::do.call(base::Sys.setenv, args = args)
[10:27:12.681]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:12.681]             }
[10:27:12.681]             else {
[10:27:12.681]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:12.681]             }
[10:27:12.681]             {
[10:27:12.681]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:12.681]                   0L) {
[10:27:12.681]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:12.681]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:12.681]                   base::options(opts)
[10:27:12.681]                 }
[10:27:12.681]                 {
[10:27:12.681]                   {
[10:27:12.681]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:12.681]                     NULL
[10:27:12.681]                   }
[10:27:12.681]                   options(future.plan = NULL)
[10:27:12.681]                   if (is.na(NA_character_)) 
[10:27:12.681]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:12.681]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:12.681]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:12.681]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:12.681]                     envir = parent.frame()) 
[10:27:12.681]                   {
[10:27:12.681]                     if (is.function(workers)) 
[10:27:12.681]                       workers <- workers()
[10:27:12.681]                     workers <- structure(as.integer(workers), 
[10:27:12.681]                       class = class(workers))
[10:27:12.681]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:12.681]                       workers >= 1)
[10:27:12.681]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:12.681]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:12.681]                     }
[10:27:12.681]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:12.681]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:12.681]                       envir = envir)
[10:27:12.681]                     if (!future$lazy) 
[10:27:12.681]                       future <- run(future)
[10:27:12.681]                     invisible(future)
[10:27:12.681]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:12.681]                 }
[10:27:12.681]             }
[10:27:12.681]         }
[10:27:12.681]     })
[10:27:12.681]     if (TRUE) {
[10:27:12.681]         base::sink(type = "output", split = FALSE)
[10:27:12.681]         if (TRUE) {
[10:27:12.681]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:12.681]         }
[10:27:12.681]         else {
[10:27:12.681]             ...future.result["stdout"] <- base::list(NULL)
[10:27:12.681]         }
[10:27:12.681]         base::close(...future.stdout)
[10:27:12.681]         ...future.stdout <- NULL
[10:27:12.681]     }
[10:27:12.681]     ...future.result$conditions <- ...future.conditions
[10:27:12.681]     ...future.result$finished <- base::Sys.time()
[10:27:12.681]     ...future.result
[10:27:12.681] }
[10:27:12.684] MultisessionFuture started
[10:27:12.684] - Launch lazy future ... done
[10:27:12.684] run() for ‘MultisessionFuture’ ... done
[10:27:13.235] receiveMessageFromWorker() for ClusterFuture ...
[10:27:13.236] - Validating connection of MultisessionFuture
[10:27:13.236] - received message: FutureResult
[10:27:13.236] - Received FutureResult
[10:27:13.236] - Erased future from FutureRegistry
[10:27:13.236] result() for ClusterFuture ...
[10:27:13.236] - result already collected: FutureResult
[10:27:13.236] result() for ClusterFuture ... done
[10:27:13.237] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:13.237] A MultisessionFuture was resolved
[10:27:13.237] getGlobalsAndPackages() ...
[10:27:13.237] Searching for globals...
[10:27:13.238] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:27:13.238] Searching for globals ... DONE
[10:27:13.238] Resolving globals: FALSE
[10:27:13.239] 
[10:27:13.239] 
[10:27:13.239] getGlobalsAndPackages() ... DONE
[10:27:13.239] run() for ‘Future’ ...
[10:27:13.239] - state: ‘created’
[10:27:13.239] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:13.256] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:13.256] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:13.256]   - Field: ‘node’
[10:27:13.256]   - Field: ‘label’
[10:27:13.256]   - Field: ‘local’
[10:27:13.256]   - Field: ‘owner’
[10:27:13.256]   - Field: ‘envir’
[10:27:13.256]   - Field: ‘workers’
[10:27:13.256]   - Field: ‘packages’
[10:27:13.257]   - Field: ‘gc’
[10:27:13.257]   - Field: ‘conditions’
[10:27:13.257]   - Field: ‘persistent’
[10:27:13.257]   - Field: ‘expr’
[10:27:13.257]   - Field: ‘uuid’
[10:27:13.257]   - Field: ‘seed’
[10:27:13.257]   - Field: ‘version’
[10:27:13.257]   - Field: ‘result’
[10:27:13.257]   - Field: ‘asynchronous’
[10:27:13.258]   - Field: ‘calls’
[10:27:13.258]   - Field: ‘globals’
[10:27:13.258]   - Field: ‘stdout’
[10:27:13.258]   - Field: ‘earlySignal’
[10:27:13.258]   - Field: ‘lazy’
[10:27:13.258]   - Field: ‘state’
[10:27:13.258] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:13.258] - Launch lazy future ...
[10:27:13.259] Packages needed by the future expression (n = 0): <none>
[10:27:13.259] Packages needed by future strategies (n = 0): <none>
[10:27:13.259] {
[10:27:13.259]     {
[10:27:13.259]         {
[10:27:13.259]             ...future.startTime <- base::Sys.time()
[10:27:13.259]             {
[10:27:13.259]                 {
[10:27:13.259]                   {
[10:27:13.259]                     {
[10:27:13.259]                       base::local({
[10:27:13.259]                         has_future <- base::requireNamespace("future", 
[10:27:13.259]                           quietly = TRUE)
[10:27:13.259]                         if (has_future) {
[10:27:13.259]                           ns <- base::getNamespace("future")
[10:27:13.259]                           version <- ns[[".package"]][["version"]]
[10:27:13.259]                           if (is.null(version)) 
[10:27:13.259]                             version <- utils::packageVersion("future")
[10:27:13.259]                         }
[10:27:13.259]                         else {
[10:27:13.259]                           version <- NULL
[10:27:13.259]                         }
[10:27:13.259]                         if (!has_future || version < "1.8.0") {
[10:27:13.259]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:13.259]                             "", base::R.version$version.string), 
[10:27:13.259]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:13.259]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:13.259]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:13.259]                               "release", "version")], collapse = " "), 
[10:27:13.259]                             hostname = base::Sys.info()[["nodename"]])
[10:27:13.259]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:13.259]                             info)
[10:27:13.259]                           info <- base::paste(info, collapse = "; ")
[10:27:13.259]                           if (!has_future) {
[10:27:13.259]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:13.259]                               info)
[10:27:13.259]                           }
[10:27:13.259]                           else {
[10:27:13.259]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:13.259]                               info, version)
[10:27:13.259]                           }
[10:27:13.259]                           base::stop(msg)
[10:27:13.259]                         }
[10:27:13.259]                       })
[10:27:13.259]                     }
[10:27:13.259]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:13.259]                     base::options(mc.cores = 1L)
[10:27:13.259]                   }
[10:27:13.259]                   options(future.plan = NULL)
[10:27:13.259]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:13.259]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:13.259]                 }
[10:27:13.259]                 ...future.workdir <- getwd()
[10:27:13.259]             }
[10:27:13.259]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:13.259]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:13.259]         }
[10:27:13.259]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:13.259]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:13.259]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:13.259]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:13.259]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:13.259]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:13.259]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:13.259]             base::names(...future.oldOptions))
[10:27:13.259]     }
[10:27:13.259]     if (FALSE) {
[10:27:13.259]     }
[10:27:13.259]     else {
[10:27:13.259]         if (TRUE) {
[10:27:13.259]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:13.259]                 open = "w")
[10:27:13.259]         }
[10:27:13.259]         else {
[10:27:13.259]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:13.259]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:13.259]         }
[10:27:13.259]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:13.259]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:13.259]             base::sink(type = "output", split = FALSE)
[10:27:13.259]             base::close(...future.stdout)
[10:27:13.259]         }, add = TRUE)
[10:27:13.259]     }
[10:27:13.259]     ...future.frame <- base::sys.nframe()
[10:27:13.259]     ...future.conditions <- base::list()
[10:27:13.259]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:13.259]     if (FALSE) {
[10:27:13.259]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:13.259]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:13.259]     }
[10:27:13.259]     ...future.result <- base::tryCatch({
[10:27:13.259]         base::withCallingHandlers({
[10:27:13.259]             ...future.value <- base::withVisible(base::local({
[10:27:13.259]                 ...future.makeSendCondition <- base::local({
[10:27:13.259]                   sendCondition <- NULL
[10:27:13.259]                   function(frame = 1L) {
[10:27:13.259]                     if (is.function(sendCondition)) 
[10:27:13.259]                       return(sendCondition)
[10:27:13.259]                     ns <- getNamespace("parallel")
[10:27:13.259]                     if (exists("sendData", mode = "function", 
[10:27:13.259]                       envir = ns)) {
[10:27:13.259]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:13.259]                         envir = ns)
[10:27:13.259]                       envir <- sys.frame(frame)
[10:27:13.259]                       master <- NULL
[10:27:13.259]                       while (!identical(envir, .GlobalEnv) && 
[10:27:13.259]                         !identical(envir, emptyenv())) {
[10:27:13.259]                         if (exists("master", mode = "list", envir = envir, 
[10:27:13.259]                           inherits = FALSE)) {
[10:27:13.259]                           master <- get("master", mode = "list", 
[10:27:13.259]                             envir = envir, inherits = FALSE)
[10:27:13.259]                           if (inherits(master, c("SOCKnode", 
[10:27:13.259]                             "SOCK0node"))) {
[10:27:13.259]                             sendCondition <<- function(cond) {
[10:27:13.259]                               data <- list(type = "VALUE", value = cond, 
[10:27:13.259]                                 success = TRUE)
[10:27:13.259]                               parallel_sendData(master, data)
[10:27:13.259]                             }
[10:27:13.259]                             return(sendCondition)
[10:27:13.259]                           }
[10:27:13.259]                         }
[10:27:13.259]                         frame <- frame + 1L
[10:27:13.259]                         envir <- sys.frame(frame)
[10:27:13.259]                       }
[10:27:13.259]                     }
[10:27:13.259]                     sendCondition <<- function(cond) NULL
[10:27:13.259]                   }
[10:27:13.259]                 })
[10:27:13.259]                 withCallingHandlers({
[10:27:13.259]                   {
[10:27:13.259]                     Sys.sleep(0.5)
[10:27:13.259]                     list(a = 1, b = 42L)
[10:27:13.259]                   }
[10:27:13.259]                 }, immediateCondition = function(cond) {
[10:27:13.259]                   sendCondition <- ...future.makeSendCondition()
[10:27:13.259]                   sendCondition(cond)
[10:27:13.259]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:13.259]                   {
[10:27:13.259]                     inherits <- base::inherits
[10:27:13.259]                     invokeRestart <- base::invokeRestart
[10:27:13.259]                     is.null <- base::is.null
[10:27:13.259]                     muffled <- FALSE
[10:27:13.259]                     if (inherits(cond, "message")) {
[10:27:13.259]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:13.259]                       if (muffled) 
[10:27:13.259]                         invokeRestart("muffleMessage")
[10:27:13.259]                     }
[10:27:13.259]                     else if (inherits(cond, "warning")) {
[10:27:13.259]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:13.259]                       if (muffled) 
[10:27:13.259]                         invokeRestart("muffleWarning")
[10:27:13.259]                     }
[10:27:13.259]                     else if (inherits(cond, "condition")) {
[10:27:13.259]                       if (!is.null(pattern)) {
[10:27:13.259]                         computeRestarts <- base::computeRestarts
[10:27:13.259]                         grepl <- base::grepl
[10:27:13.259]                         restarts <- computeRestarts(cond)
[10:27:13.259]                         for (restart in restarts) {
[10:27:13.259]                           name <- restart$name
[10:27:13.259]                           if (is.null(name)) 
[10:27:13.259]                             next
[10:27:13.259]                           if (!grepl(pattern, name)) 
[10:27:13.259]                             next
[10:27:13.259]                           invokeRestart(restart)
[10:27:13.259]                           muffled <- TRUE
[10:27:13.259]                           break
[10:27:13.259]                         }
[10:27:13.259]                       }
[10:27:13.259]                     }
[10:27:13.259]                     invisible(muffled)
[10:27:13.259]                   }
[10:27:13.259]                   muffleCondition(cond)
[10:27:13.259]                 })
[10:27:13.259]             }))
[10:27:13.259]             future::FutureResult(value = ...future.value$value, 
[10:27:13.259]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:13.259]                   ...future.rng), globalenv = if (FALSE) 
[10:27:13.259]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:13.259]                     ...future.globalenv.names))
[10:27:13.259]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:13.259]         }, condition = base::local({
[10:27:13.259]             c <- base::c
[10:27:13.259]             inherits <- base::inherits
[10:27:13.259]             invokeRestart <- base::invokeRestart
[10:27:13.259]             length <- base::length
[10:27:13.259]             list <- base::list
[10:27:13.259]             seq.int <- base::seq.int
[10:27:13.259]             signalCondition <- base::signalCondition
[10:27:13.259]             sys.calls <- base::sys.calls
[10:27:13.259]             `[[` <- base::`[[`
[10:27:13.259]             `+` <- base::`+`
[10:27:13.259]             `<<-` <- base::`<<-`
[10:27:13.259]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:13.259]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:13.259]                   3L)]
[10:27:13.259]             }
[10:27:13.259]             function(cond) {
[10:27:13.259]                 is_error <- inherits(cond, "error")
[10:27:13.259]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:13.259]                   NULL)
[10:27:13.259]                 if (is_error) {
[10:27:13.259]                   sessionInformation <- function() {
[10:27:13.259]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:13.259]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:13.259]                       search = base::search(), system = base::Sys.info())
[10:27:13.259]                   }
[10:27:13.259]                   ...future.conditions[[length(...future.conditions) + 
[10:27:13.259]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:13.259]                     cond$call), session = sessionInformation(), 
[10:27:13.259]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:13.259]                   signalCondition(cond)
[10:27:13.259]                 }
[10:27:13.259]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:13.259]                 "immediateCondition"))) {
[10:27:13.259]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:13.259]                   ...future.conditions[[length(...future.conditions) + 
[10:27:13.259]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:13.259]                   if (TRUE && !signal) {
[10:27:13.259]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:13.259]                     {
[10:27:13.259]                       inherits <- base::inherits
[10:27:13.259]                       invokeRestart <- base::invokeRestart
[10:27:13.259]                       is.null <- base::is.null
[10:27:13.259]                       muffled <- FALSE
[10:27:13.259]                       if (inherits(cond, "message")) {
[10:27:13.259]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:13.259]                         if (muffled) 
[10:27:13.259]                           invokeRestart("muffleMessage")
[10:27:13.259]                       }
[10:27:13.259]                       else if (inherits(cond, "warning")) {
[10:27:13.259]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:13.259]                         if (muffled) 
[10:27:13.259]                           invokeRestart("muffleWarning")
[10:27:13.259]                       }
[10:27:13.259]                       else if (inherits(cond, "condition")) {
[10:27:13.259]                         if (!is.null(pattern)) {
[10:27:13.259]                           computeRestarts <- base::computeRestarts
[10:27:13.259]                           grepl <- base::grepl
[10:27:13.259]                           restarts <- computeRestarts(cond)
[10:27:13.259]                           for (restart in restarts) {
[10:27:13.259]                             name <- restart$name
[10:27:13.259]                             if (is.null(name)) 
[10:27:13.259]                               next
[10:27:13.259]                             if (!grepl(pattern, name)) 
[10:27:13.259]                               next
[10:27:13.259]                             invokeRestart(restart)
[10:27:13.259]                             muffled <- TRUE
[10:27:13.259]                             break
[10:27:13.259]                           }
[10:27:13.259]                         }
[10:27:13.259]                       }
[10:27:13.259]                       invisible(muffled)
[10:27:13.259]                     }
[10:27:13.259]                     muffleCondition(cond, pattern = "^muffle")
[10:27:13.259]                   }
[10:27:13.259]                 }
[10:27:13.259]                 else {
[10:27:13.259]                   if (TRUE) {
[10:27:13.259]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:13.259]                     {
[10:27:13.259]                       inherits <- base::inherits
[10:27:13.259]                       invokeRestart <- base::invokeRestart
[10:27:13.259]                       is.null <- base::is.null
[10:27:13.259]                       muffled <- FALSE
[10:27:13.259]                       if (inherits(cond, "message")) {
[10:27:13.259]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:13.259]                         if (muffled) 
[10:27:13.259]                           invokeRestart("muffleMessage")
[10:27:13.259]                       }
[10:27:13.259]                       else if (inherits(cond, "warning")) {
[10:27:13.259]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:13.259]                         if (muffled) 
[10:27:13.259]                           invokeRestart("muffleWarning")
[10:27:13.259]                       }
[10:27:13.259]                       else if (inherits(cond, "condition")) {
[10:27:13.259]                         if (!is.null(pattern)) {
[10:27:13.259]                           computeRestarts <- base::computeRestarts
[10:27:13.259]                           grepl <- base::grepl
[10:27:13.259]                           restarts <- computeRestarts(cond)
[10:27:13.259]                           for (restart in restarts) {
[10:27:13.259]                             name <- restart$name
[10:27:13.259]                             if (is.null(name)) 
[10:27:13.259]                               next
[10:27:13.259]                             if (!grepl(pattern, name)) 
[10:27:13.259]                               next
[10:27:13.259]                             invokeRestart(restart)
[10:27:13.259]                             muffled <- TRUE
[10:27:13.259]                             break
[10:27:13.259]                           }
[10:27:13.259]                         }
[10:27:13.259]                       }
[10:27:13.259]                       invisible(muffled)
[10:27:13.259]                     }
[10:27:13.259]                     muffleCondition(cond, pattern = "^muffle")
[10:27:13.259]                   }
[10:27:13.259]                 }
[10:27:13.259]             }
[10:27:13.259]         }))
[10:27:13.259]     }, error = function(ex) {
[10:27:13.259]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:13.259]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:13.259]                 ...future.rng), started = ...future.startTime, 
[10:27:13.259]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:13.259]             version = "1.8"), class = "FutureResult")
[10:27:13.259]     }, finally = {
[10:27:13.259]         if (!identical(...future.workdir, getwd())) 
[10:27:13.259]             setwd(...future.workdir)
[10:27:13.259]         {
[10:27:13.259]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:13.259]                 ...future.oldOptions$nwarnings <- NULL
[10:27:13.259]             }
[10:27:13.259]             base::options(...future.oldOptions)
[10:27:13.259]             if (.Platform$OS.type == "windows") {
[10:27:13.259]                 old_names <- names(...future.oldEnvVars)
[10:27:13.259]                 envs <- base::Sys.getenv()
[10:27:13.259]                 names <- names(envs)
[10:27:13.259]                 common <- intersect(names, old_names)
[10:27:13.259]                 added <- setdiff(names, old_names)
[10:27:13.259]                 removed <- setdiff(old_names, names)
[10:27:13.259]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:13.259]                   envs[common]]
[10:27:13.259]                 NAMES <- toupper(changed)
[10:27:13.259]                 args <- list()
[10:27:13.259]                 for (kk in seq_along(NAMES)) {
[10:27:13.259]                   name <- changed[[kk]]
[10:27:13.259]                   NAME <- NAMES[[kk]]
[10:27:13.259]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:13.259]                     next
[10:27:13.259]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:13.259]                 }
[10:27:13.259]                 NAMES <- toupper(added)
[10:27:13.259]                 for (kk in seq_along(NAMES)) {
[10:27:13.259]                   name <- added[[kk]]
[10:27:13.259]                   NAME <- NAMES[[kk]]
[10:27:13.259]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:13.259]                     next
[10:27:13.259]                   args[[name]] <- ""
[10:27:13.259]                 }
[10:27:13.259]                 NAMES <- toupper(removed)
[10:27:13.259]                 for (kk in seq_along(NAMES)) {
[10:27:13.259]                   name <- removed[[kk]]
[10:27:13.259]                   NAME <- NAMES[[kk]]
[10:27:13.259]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:13.259]                     next
[10:27:13.259]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:13.259]                 }
[10:27:13.259]                 if (length(args) > 0) 
[10:27:13.259]                   base::do.call(base::Sys.setenv, args = args)
[10:27:13.259]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:13.259]             }
[10:27:13.259]             else {
[10:27:13.259]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:13.259]             }
[10:27:13.259]             {
[10:27:13.259]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:13.259]                   0L) {
[10:27:13.259]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:13.259]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:13.259]                   base::options(opts)
[10:27:13.259]                 }
[10:27:13.259]                 {
[10:27:13.259]                   {
[10:27:13.259]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:13.259]                     NULL
[10:27:13.259]                   }
[10:27:13.259]                   options(future.plan = NULL)
[10:27:13.259]                   if (is.na(NA_character_)) 
[10:27:13.259]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:13.259]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:13.259]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:13.259]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:13.259]                     envir = parent.frame()) 
[10:27:13.259]                   {
[10:27:13.259]                     if (is.function(workers)) 
[10:27:13.259]                       workers <- workers()
[10:27:13.259]                     workers <- structure(as.integer(workers), 
[10:27:13.259]                       class = class(workers))
[10:27:13.259]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:13.259]                       workers >= 1)
[10:27:13.259]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:13.259]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:13.259]                     }
[10:27:13.259]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:13.259]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:13.259]                       envir = envir)
[10:27:13.259]                     if (!future$lazy) 
[10:27:13.259]                       future <- run(future)
[10:27:13.259]                     invisible(future)
[10:27:13.259]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:13.259]                 }
[10:27:13.259]             }
[10:27:13.259]         }
[10:27:13.259]     })
[10:27:13.259]     if (TRUE) {
[10:27:13.259]         base::sink(type = "output", split = FALSE)
[10:27:13.259]         if (TRUE) {
[10:27:13.259]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:13.259]         }
[10:27:13.259]         else {
[10:27:13.259]             ...future.result["stdout"] <- base::list(NULL)
[10:27:13.259]         }
[10:27:13.259]         base::close(...future.stdout)
[10:27:13.259]         ...future.stdout <- NULL
[10:27:13.259]     }
[10:27:13.259]     ...future.result$conditions <- ...future.conditions
[10:27:13.259]     ...future.result$finished <- base::Sys.time()
[10:27:13.259]     ...future.result
[10:27:13.259] }
[10:27:13.263] MultisessionFuture started
[10:27:13.263] - Launch lazy future ... done
[10:27:13.263] run() for ‘MultisessionFuture’ ... done
[10:27:13.811] receiveMessageFromWorker() for ClusterFuture ...
[10:27:13.811] - Validating connection of MultisessionFuture
[10:27:13.812] - received message: FutureResult
[10:27:13.812] - Received FutureResult
[10:27:13.812] - Erased future from FutureRegistry
[10:27:13.812] result() for ClusterFuture ...
[10:27:13.812] - result already collected: FutureResult
[10:27:13.812] result() for ClusterFuture ... done
[10:27:13.812] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:13.812] A MultisessionFuture was resolved
- w/ exception ...
[10:27:13.813] getGlobalsAndPackages() ...
[10:27:13.813] Searching for globals...
[10:27:13.813] - globals found: [2] ‘list’, ‘stop’
[10:27:13.814] Searching for globals ... DONE
[10:27:13.814] Resolving globals: FALSE
[10:27:13.814] 
[10:27:13.814] 
[10:27:13.814] getGlobalsAndPackages() ... DONE
[10:27:13.815] run() for ‘Future’ ...
[10:27:13.815] - state: ‘created’
[10:27:13.815] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:13.829] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:13.829] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:13.829]   - Field: ‘node’
[10:27:13.829]   - Field: ‘label’
[10:27:13.829]   - Field: ‘local’
[10:27:13.829]   - Field: ‘owner’
[10:27:13.829]   - Field: ‘envir’
[10:27:13.830]   - Field: ‘workers’
[10:27:13.830]   - Field: ‘packages’
[10:27:13.830]   - Field: ‘gc’
[10:27:13.830]   - Field: ‘conditions’
[10:27:13.830]   - Field: ‘persistent’
[10:27:13.830]   - Field: ‘expr’
[10:27:13.830]   - Field: ‘uuid’
[10:27:13.830]   - Field: ‘seed’
[10:27:13.830]   - Field: ‘version’
[10:27:13.830]   - Field: ‘result’
[10:27:13.831]   - Field: ‘asynchronous’
[10:27:13.831]   - Field: ‘calls’
[10:27:13.831]   - Field: ‘globals’
[10:27:13.831]   - Field: ‘stdout’
[10:27:13.831]   - Field: ‘earlySignal’
[10:27:13.831]   - Field: ‘lazy’
[10:27:13.831]   - Field: ‘state’
[10:27:13.831] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:13.831] - Launch lazy future ...
[10:27:13.832] Packages needed by the future expression (n = 0): <none>
[10:27:13.832] Packages needed by future strategies (n = 0): <none>
[10:27:13.832] {
[10:27:13.832]     {
[10:27:13.832]         {
[10:27:13.832]             ...future.startTime <- base::Sys.time()
[10:27:13.832]             {
[10:27:13.832]                 {
[10:27:13.832]                   {
[10:27:13.832]                     {
[10:27:13.832]                       base::local({
[10:27:13.832]                         has_future <- base::requireNamespace("future", 
[10:27:13.832]                           quietly = TRUE)
[10:27:13.832]                         if (has_future) {
[10:27:13.832]                           ns <- base::getNamespace("future")
[10:27:13.832]                           version <- ns[[".package"]][["version"]]
[10:27:13.832]                           if (is.null(version)) 
[10:27:13.832]                             version <- utils::packageVersion("future")
[10:27:13.832]                         }
[10:27:13.832]                         else {
[10:27:13.832]                           version <- NULL
[10:27:13.832]                         }
[10:27:13.832]                         if (!has_future || version < "1.8.0") {
[10:27:13.832]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:13.832]                             "", base::R.version$version.string), 
[10:27:13.832]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:13.832]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:13.832]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:13.832]                               "release", "version")], collapse = " "), 
[10:27:13.832]                             hostname = base::Sys.info()[["nodename"]])
[10:27:13.832]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:13.832]                             info)
[10:27:13.832]                           info <- base::paste(info, collapse = "; ")
[10:27:13.832]                           if (!has_future) {
[10:27:13.832]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:13.832]                               info)
[10:27:13.832]                           }
[10:27:13.832]                           else {
[10:27:13.832]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:13.832]                               info, version)
[10:27:13.832]                           }
[10:27:13.832]                           base::stop(msg)
[10:27:13.832]                         }
[10:27:13.832]                       })
[10:27:13.832]                     }
[10:27:13.832]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:13.832]                     base::options(mc.cores = 1L)
[10:27:13.832]                   }
[10:27:13.832]                   options(future.plan = NULL)
[10:27:13.832]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:13.832]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:13.832]                 }
[10:27:13.832]                 ...future.workdir <- getwd()
[10:27:13.832]             }
[10:27:13.832]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:13.832]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:13.832]         }
[10:27:13.832]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:13.832]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:13.832]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:13.832]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:13.832]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:13.832]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:13.832]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:13.832]             base::names(...future.oldOptions))
[10:27:13.832]     }
[10:27:13.832]     if (FALSE) {
[10:27:13.832]     }
[10:27:13.832]     else {
[10:27:13.832]         if (TRUE) {
[10:27:13.832]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:13.832]                 open = "w")
[10:27:13.832]         }
[10:27:13.832]         else {
[10:27:13.832]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:13.832]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:13.832]         }
[10:27:13.832]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:13.832]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:13.832]             base::sink(type = "output", split = FALSE)
[10:27:13.832]             base::close(...future.stdout)
[10:27:13.832]         }, add = TRUE)
[10:27:13.832]     }
[10:27:13.832]     ...future.frame <- base::sys.nframe()
[10:27:13.832]     ...future.conditions <- base::list()
[10:27:13.832]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:13.832]     if (FALSE) {
[10:27:13.832]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:13.832]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:13.832]     }
[10:27:13.832]     ...future.result <- base::tryCatch({
[10:27:13.832]         base::withCallingHandlers({
[10:27:13.832]             ...future.value <- base::withVisible(base::local({
[10:27:13.832]                 ...future.makeSendCondition <- base::local({
[10:27:13.832]                   sendCondition <- NULL
[10:27:13.832]                   function(frame = 1L) {
[10:27:13.832]                     if (is.function(sendCondition)) 
[10:27:13.832]                       return(sendCondition)
[10:27:13.832]                     ns <- getNamespace("parallel")
[10:27:13.832]                     if (exists("sendData", mode = "function", 
[10:27:13.832]                       envir = ns)) {
[10:27:13.832]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:13.832]                         envir = ns)
[10:27:13.832]                       envir <- sys.frame(frame)
[10:27:13.832]                       master <- NULL
[10:27:13.832]                       while (!identical(envir, .GlobalEnv) && 
[10:27:13.832]                         !identical(envir, emptyenv())) {
[10:27:13.832]                         if (exists("master", mode = "list", envir = envir, 
[10:27:13.832]                           inherits = FALSE)) {
[10:27:13.832]                           master <- get("master", mode = "list", 
[10:27:13.832]                             envir = envir, inherits = FALSE)
[10:27:13.832]                           if (inherits(master, c("SOCKnode", 
[10:27:13.832]                             "SOCK0node"))) {
[10:27:13.832]                             sendCondition <<- function(cond) {
[10:27:13.832]                               data <- list(type = "VALUE", value = cond, 
[10:27:13.832]                                 success = TRUE)
[10:27:13.832]                               parallel_sendData(master, data)
[10:27:13.832]                             }
[10:27:13.832]                             return(sendCondition)
[10:27:13.832]                           }
[10:27:13.832]                         }
[10:27:13.832]                         frame <- frame + 1L
[10:27:13.832]                         envir <- sys.frame(frame)
[10:27:13.832]                       }
[10:27:13.832]                     }
[10:27:13.832]                     sendCondition <<- function(cond) NULL
[10:27:13.832]                   }
[10:27:13.832]                 })
[10:27:13.832]                 withCallingHandlers({
[10:27:13.832]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:27:13.832]                 }, immediateCondition = function(cond) {
[10:27:13.832]                   sendCondition <- ...future.makeSendCondition()
[10:27:13.832]                   sendCondition(cond)
[10:27:13.832]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:13.832]                   {
[10:27:13.832]                     inherits <- base::inherits
[10:27:13.832]                     invokeRestart <- base::invokeRestart
[10:27:13.832]                     is.null <- base::is.null
[10:27:13.832]                     muffled <- FALSE
[10:27:13.832]                     if (inherits(cond, "message")) {
[10:27:13.832]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:13.832]                       if (muffled) 
[10:27:13.832]                         invokeRestart("muffleMessage")
[10:27:13.832]                     }
[10:27:13.832]                     else if (inherits(cond, "warning")) {
[10:27:13.832]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:13.832]                       if (muffled) 
[10:27:13.832]                         invokeRestart("muffleWarning")
[10:27:13.832]                     }
[10:27:13.832]                     else if (inherits(cond, "condition")) {
[10:27:13.832]                       if (!is.null(pattern)) {
[10:27:13.832]                         computeRestarts <- base::computeRestarts
[10:27:13.832]                         grepl <- base::grepl
[10:27:13.832]                         restarts <- computeRestarts(cond)
[10:27:13.832]                         for (restart in restarts) {
[10:27:13.832]                           name <- restart$name
[10:27:13.832]                           if (is.null(name)) 
[10:27:13.832]                             next
[10:27:13.832]                           if (!grepl(pattern, name)) 
[10:27:13.832]                             next
[10:27:13.832]                           invokeRestart(restart)
[10:27:13.832]                           muffled <- TRUE
[10:27:13.832]                           break
[10:27:13.832]                         }
[10:27:13.832]                       }
[10:27:13.832]                     }
[10:27:13.832]                     invisible(muffled)
[10:27:13.832]                   }
[10:27:13.832]                   muffleCondition(cond)
[10:27:13.832]                 })
[10:27:13.832]             }))
[10:27:13.832]             future::FutureResult(value = ...future.value$value, 
[10:27:13.832]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:13.832]                   ...future.rng), globalenv = if (FALSE) 
[10:27:13.832]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:13.832]                     ...future.globalenv.names))
[10:27:13.832]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:13.832]         }, condition = base::local({
[10:27:13.832]             c <- base::c
[10:27:13.832]             inherits <- base::inherits
[10:27:13.832]             invokeRestart <- base::invokeRestart
[10:27:13.832]             length <- base::length
[10:27:13.832]             list <- base::list
[10:27:13.832]             seq.int <- base::seq.int
[10:27:13.832]             signalCondition <- base::signalCondition
[10:27:13.832]             sys.calls <- base::sys.calls
[10:27:13.832]             `[[` <- base::`[[`
[10:27:13.832]             `+` <- base::`+`
[10:27:13.832]             `<<-` <- base::`<<-`
[10:27:13.832]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:13.832]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:13.832]                   3L)]
[10:27:13.832]             }
[10:27:13.832]             function(cond) {
[10:27:13.832]                 is_error <- inherits(cond, "error")
[10:27:13.832]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:13.832]                   NULL)
[10:27:13.832]                 if (is_error) {
[10:27:13.832]                   sessionInformation <- function() {
[10:27:13.832]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:13.832]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:13.832]                       search = base::search(), system = base::Sys.info())
[10:27:13.832]                   }
[10:27:13.832]                   ...future.conditions[[length(...future.conditions) + 
[10:27:13.832]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:13.832]                     cond$call), session = sessionInformation(), 
[10:27:13.832]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:13.832]                   signalCondition(cond)
[10:27:13.832]                 }
[10:27:13.832]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:13.832]                 "immediateCondition"))) {
[10:27:13.832]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:13.832]                   ...future.conditions[[length(...future.conditions) + 
[10:27:13.832]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:13.832]                   if (TRUE && !signal) {
[10:27:13.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:13.832]                     {
[10:27:13.832]                       inherits <- base::inherits
[10:27:13.832]                       invokeRestart <- base::invokeRestart
[10:27:13.832]                       is.null <- base::is.null
[10:27:13.832]                       muffled <- FALSE
[10:27:13.832]                       if (inherits(cond, "message")) {
[10:27:13.832]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:13.832]                         if (muffled) 
[10:27:13.832]                           invokeRestart("muffleMessage")
[10:27:13.832]                       }
[10:27:13.832]                       else if (inherits(cond, "warning")) {
[10:27:13.832]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:13.832]                         if (muffled) 
[10:27:13.832]                           invokeRestart("muffleWarning")
[10:27:13.832]                       }
[10:27:13.832]                       else if (inherits(cond, "condition")) {
[10:27:13.832]                         if (!is.null(pattern)) {
[10:27:13.832]                           computeRestarts <- base::computeRestarts
[10:27:13.832]                           grepl <- base::grepl
[10:27:13.832]                           restarts <- computeRestarts(cond)
[10:27:13.832]                           for (restart in restarts) {
[10:27:13.832]                             name <- restart$name
[10:27:13.832]                             if (is.null(name)) 
[10:27:13.832]                               next
[10:27:13.832]                             if (!grepl(pattern, name)) 
[10:27:13.832]                               next
[10:27:13.832]                             invokeRestart(restart)
[10:27:13.832]                             muffled <- TRUE
[10:27:13.832]                             break
[10:27:13.832]                           }
[10:27:13.832]                         }
[10:27:13.832]                       }
[10:27:13.832]                       invisible(muffled)
[10:27:13.832]                     }
[10:27:13.832]                     muffleCondition(cond, pattern = "^muffle")
[10:27:13.832]                   }
[10:27:13.832]                 }
[10:27:13.832]                 else {
[10:27:13.832]                   if (TRUE) {
[10:27:13.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:13.832]                     {
[10:27:13.832]                       inherits <- base::inherits
[10:27:13.832]                       invokeRestart <- base::invokeRestart
[10:27:13.832]                       is.null <- base::is.null
[10:27:13.832]                       muffled <- FALSE
[10:27:13.832]                       if (inherits(cond, "message")) {
[10:27:13.832]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:13.832]                         if (muffled) 
[10:27:13.832]                           invokeRestart("muffleMessage")
[10:27:13.832]                       }
[10:27:13.832]                       else if (inherits(cond, "warning")) {
[10:27:13.832]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:13.832]                         if (muffled) 
[10:27:13.832]                           invokeRestart("muffleWarning")
[10:27:13.832]                       }
[10:27:13.832]                       else if (inherits(cond, "condition")) {
[10:27:13.832]                         if (!is.null(pattern)) {
[10:27:13.832]                           computeRestarts <- base::computeRestarts
[10:27:13.832]                           grepl <- base::grepl
[10:27:13.832]                           restarts <- computeRestarts(cond)
[10:27:13.832]                           for (restart in restarts) {
[10:27:13.832]                             name <- restart$name
[10:27:13.832]                             if (is.null(name)) 
[10:27:13.832]                               next
[10:27:13.832]                             if (!grepl(pattern, name)) 
[10:27:13.832]                               next
[10:27:13.832]                             invokeRestart(restart)
[10:27:13.832]                             muffled <- TRUE
[10:27:13.832]                             break
[10:27:13.832]                           }
[10:27:13.832]                         }
[10:27:13.832]                       }
[10:27:13.832]                       invisible(muffled)
[10:27:13.832]                     }
[10:27:13.832]                     muffleCondition(cond, pattern = "^muffle")
[10:27:13.832]                   }
[10:27:13.832]                 }
[10:27:13.832]             }
[10:27:13.832]         }))
[10:27:13.832]     }, error = function(ex) {
[10:27:13.832]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:13.832]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:13.832]                 ...future.rng), started = ...future.startTime, 
[10:27:13.832]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:13.832]             version = "1.8"), class = "FutureResult")
[10:27:13.832]     }, finally = {
[10:27:13.832]         if (!identical(...future.workdir, getwd())) 
[10:27:13.832]             setwd(...future.workdir)
[10:27:13.832]         {
[10:27:13.832]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:13.832]                 ...future.oldOptions$nwarnings <- NULL
[10:27:13.832]             }
[10:27:13.832]             base::options(...future.oldOptions)
[10:27:13.832]             if (.Platform$OS.type == "windows") {
[10:27:13.832]                 old_names <- names(...future.oldEnvVars)
[10:27:13.832]                 envs <- base::Sys.getenv()
[10:27:13.832]                 names <- names(envs)
[10:27:13.832]                 common <- intersect(names, old_names)
[10:27:13.832]                 added <- setdiff(names, old_names)
[10:27:13.832]                 removed <- setdiff(old_names, names)
[10:27:13.832]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:13.832]                   envs[common]]
[10:27:13.832]                 NAMES <- toupper(changed)
[10:27:13.832]                 args <- list()
[10:27:13.832]                 for (kk in seq_along(NAMES)) {
[10:27:13.832]                   name <- changed[[kk]]
[10:27:13.832]                   NAME <- NAMES[[kk]]
[10:27:13.832]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:13.832]                     next
[10:27:13.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:13.832]                 }
[10:27:13.832]                 NAMES <- toupper(added)
[10:27:13.832]                 for (kk in seq_along(NAMES)) {
[10:27:13.832]                   name <- added[[kk]]
[10:27:13.832]                   NAME <- NAMES[[kk]]
[10:27:13.832]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:13.832]                     next
[10:27:13.832]                   args[[name]] <- ""
[10:27:13.832]                 }
[10:27:13.832]                 NAMES <- toupper(removed)
[10:27:13.832]                 for (kk in seq_along(NAMES)) {
[10:27:13.832]                   name <- removed[[kk]]
[10:27:13.832]                   NAME <- NAMES[[kk]]
[10:27:13.832]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:13.832]                     next
[10:27:13.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:13.832]                 }
[10:27:13.832]                 if (length(args) > 0) 
[10:27:13.832]                   base::do.call(base::Sys.setenv, args = args)
[10:27:13.832]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:13.832]             }
[10:27:13.832]             else {
[10:27:13.832]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:13.832]             }
[10:27:13.832]             {
[10:27:13.832]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:13.832]                   0L) {
[10:27:13.832]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:13.832]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:13.832]                   base::options(opts)
[10:27:13.832]                 }
[10:27:13.832]                 {
[10:27:13.832]                   {
[10:27:13.832]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:13.832]                     NULL
[10:27:13.832]                   }
[10:27:13.832]                   options(future.plan = NULL)
[10:27:13.832]                   if (is.na(NA_character_)) 
[10:27:13.832]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:13.832]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:13.832]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:13.832]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:13.832]                     envir = parent.frame()) 
[10:27:13.832]                   {
[10:27:13.832]                     if (is.function(workers)) 
[10:27:13.832]                       workers <- workers()
[10:27:13.832]                     workers <- structure(as.integer(workers), 
[10:27:13.832]                       class = class(workers))
[10:27:13.832]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:13.832]                       workers >= 1)
[10:27:13.832]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:13.832]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:13.832]                     }
[10:27:13.832]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:13.832]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:13.832]                       envir = envir)
[10:27:13.832]                     if (!future$lazy) 
[10:27:13.832]                       future <- run(future)
[10:27:13.832]                     invisible(future)
[10:27:13.832]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:13.832]                 }
[10:27:13.832]             }
[10:27:13.832]         }
[10:27:13.832]     })
[10:27:13.832]     if (TRUE) {
[10:27:13.832]         base::sink(type = "output", split = FALSE)
[10:27:13.832]         if (TRUE) {
[10:27:13.832]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:13.832]         }
[10:27:13.832]         else {
[10:27:13.832]             ...future.result["stdout"] <- base::list(NULL)
[10:27:13.832]         }
[10:27:13.832]         base::close(...future.stdout)
[10:27:13.832]         ...future.stdout <- NULL
[10:27:13.832]     }
[10:27:13.832]     ...future.result$conditions <- ...future.conditions
[10:27:13.832]     ...future.result$finished <- base::Sys.time()
[10:27:13.832]     ...future.result
[10:27:13.832] }
[10:27:13.835] MultisessionFuture started
[10:27:13.835] - Launch lazy future ... done
[10:27:13.835] run() for ‘MultisessionFuture’ ... done
[10:27:13.887] receiveMessageFromWorker() for ClusterFuture ...
[10:27:13.887] - Validating connection of MultisessionFuture
[10:27:13.888] - received message: FutureResult
[10:27:13.888] - Received FutureResult
[10:27:13.888] - Erased future from FutureRegistry
[10:27:13.888] result() for ClusterFuture ...
[10:27:13.888] - result already collected: FutureResult
[10:27:13.888] result() for ClusterFuture ... done
[10:27:13.888] signalConditions() ...
[10:27:13.888]  - include = ‘immediateCondition’
[10:27:13.889]  - exclude = 
[10:27:13.889]  - resignal = FALSE
[10:27:13.889]  - Number of conditions: 1
[10:27:13.889] signalConditions() ... done
[10:27:13.889] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:13.889] A MultisessionFuture was resolved
[10:27:13.889] getGlobalsAndPackages() ...
[10:27:13.889] Searching for globals...
[10:27:13.890] - globals found: [2] ‘list’, ‘stop’
[10:27:13.890] Searching for globals ... DONE
[10:27:13.890] Resolving globals: FALSE
[10:27:13.891] 
[10:27:13.891] 
[10:27:13.891] getGlobalsAndPackages() ... DONE
[10:27:13.891] run() for ‘Future’ ...
[10:27:13.891] - state: ‘created’
[10:27:13.892] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:13.905] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:13.905] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:13.906]   - Field: ‘node’
[10:27:13.906]   - Field: ‘label’
[10:27:13.906]   - Field: ‘local’
[10:27:13.906]   - Field: ‘owner’
[10:27:13.906]   - Field: ‘envir’
[10:27:13.906]   - Field: ‘workers’
[10:27:13.906]   - Field: ‘packages’
[10:27:13.906]   - Field: ‘gc’
[10:27:13.906]   - Field: ‘conditions’
[10:27:13.906]   - Field: ‘persistent’
[10:27:13.907]   - Field: ‘expr’
[10:27:13.907]   - Field: ‘uuid’
[10:27:13.907]   - Field: ‘seed’
[10:27:13.907]   - Field: ‘version’
[10:27:13.907]   - Field: ‘result’
[10:27:13.907]   - Field: ‘asynchronous’
[10:27:13.907]   - Field: ‘calls’
[10:27:13.907]   - Field: ‘globals’
[10:27:13.907]   - Field: ‘stdout’
[10:27:13.907]   - Field: ‘earlySignal’
[10:27:13.907]   - Field: ‘lazy’
[10:27:13.908]   - Field: ‘state’
[10:27:13.908] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:13.908] - Launch lazy future ...
[10:27:13.908] Packages needed by the future expression (n = 0): <none>
[10:27:13.908] Packages needed by future strategies (n = 0): <none>
[10:27:13.909] {
[10:27:13.909]     {
[10:27:13.909]         {
[10:27:13.909]             ...future.startTime <- base::Sys.time()
[10:27:13.909]             {
[10:27:13.909]                 {
[10:27:13.909]                   {
[10:27:13.909]                     {
[10:27:13.909]                       base::local({
[10:27:13.909]                         has_future <- base::requireNamespace("future", 
[10:27:13.909]                           quietly = TRUE)
[10:27:13.909]                         if (has_future) {
[10:27:13.909]                           ns <- base::getNamespace("future")
[10:27:13.909]                           version <- ns[[".package"]][["version"]]
[10:27:13.909]                           if (is.null(version)) 
[10:27:13.909]                             version <- utils::packageVersion("future")
[10:27:13.909]                         }
[10:27:13.909]                         else {
[10:27:13.909]                           version <- NULL
[10:27:13.909]                         }
[10:27:13.909]                         if (!has_future || version < "1.8.0") {
[10:27:13.909]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:13.909]                             "", base::R.version$version.string), 
[10:27:13.909]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:13.909]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:13.909]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:13.909]                               "release", "version")], collapse = " "), 
[10:27:13.909]                             hostname = base::Sys.info()[["nodename"]])
[10:27:13.909]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:13.909]                             info)
[10:27:13.909]                           info <- base::paste(info, collapse = "; ")
[10:27:13.909]                           if (!has_future) {
[10:27:13.909]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:13.909]                               info)
[10:27:13.909]                           }
[10:27:13.909]                           else {
[10:27:13.909]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:13.909]                               info, version)
[10:27:13.909]                           }
[10:27:13.909]                           base::stop(msg)
[10:27:13.909]                         }
[10:27:13.909]                       })
[10:27:13.909]                     }
[10:27:13.909]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:13.909]                     base::options(mc.cores = 1L)
[10:27:13.909]                   }
[10:27:13.909]                   options(future.plan = NULL)
[10:27:13.909]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:13.909]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:13.909]                 }
[10:27:13.909]                 ...future.workdir <- getwd()
[10:27:13.909]             }
[10:27:13.909]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:13.909]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:13.909]         }
[10:27:13.909]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:13.909]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:13.909]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:13.909]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:13.909]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:13.909]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:13.909]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:13.909]             base::names(...future.oldOptions))
[10:27:13.909]     }
[10:27:13.909]     if (FALSE) {
[10:27:13.909]     }
[10:27:13.909]     else {
[10:27:13.909]         if (TRUE) {
[10:27:13.909]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:13.909]                 open = "w")
[10:27:13.909]         }
[10:27:13.909]         else {
[10:27:13.909]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:13.909]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:13.909]         }
[10:27:13.909]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:13.909]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:13.909]             base::sink(type = "output", split = FALSE)
[10:27:13.909]             base::close(...future.stdout)
[10:27:13.909]         }, add = TRUE)
[10:27:13.909]     }
[10:27:13.909]     ...future.frame <- base::sys.nframe()
[10:27:13.909]     ...future.conditions <- base::list()
[10:27:13.909]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:13.909]     if (FALSE) {
[10:27:13.909]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:13.909]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:13.909]     }
[10:27:13.909]     ...future.result <- base::tryCatch({
[10:27:13.909]         base::withCallingHandlers({
[10:27:13.909]             ...future.value <- base::withVisible(base::local({
[10:27:13.909]                 ...future.makeSendCondition <- base::local({
[10:27:13.909]                   sendCondition <- NULL
[10:27:13.909]                   function(frame = 1L) {
[10:27:13.909]                     if (is.function(sendCondition)) 
[10:27:13.909]                       return(sendCondition)
[10:27:13.909]                     ns <- getNamespace("parallel")
[10:27:13.909]                     if (exists("sendData", mode = "function", 
[10:27:13.909]                       envir = ns)) {
[10:27:13.909]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:13.909]                         envir = ns)
[10:27:13.909]                       envir <- sys.frame(frame)
[10:27:13.909]                       master <- NULL
[10:27:13.909]                       while (!identical(envir, .GlobalEnv) && 
[10:27:13.909]                         !identical(envir, emptyenv())) {
[10:27:13.909]                         if (exists("master", mode = "list", envir = envir, 
[10:27:13.909]                           inherits = FALSE)) {
[10:27:13.909]                           master <- get("master", mode = "list", 
[10:27:13.909]                             envir = envir, inherits = FALSE)
[10:27:13.909]                           if (inherits(master, c("SOCKnode", 
[10:27:13.909]                             "SOCK0node"))) {
[10:27:13.909]                             sendCondition <<- function(cond) {
[10:27:13.909]                               data <- list(type = "VALUE", value = cond, 
[10:27:13.909]                                 success = TRUE)
[10:27:13.909]                               parallel_sendData(master, data)
[10:27:13.909]                             }
[10:27:13.909]                             return(sendCondition)
[10:27:13.909]                           }
[10:27:13.909]                         }
[10:27:13.909]                         frame <- frame + 1L
[10:27:13.909]                         envir <- sys.frame(frame)
[10:27:13.909]                       }
[10:27:13.909]                     }
[10:27:13.909]                     sendCondition <<- function(cond) NULL
[10:27:13.909]                   }
[10:27:13.909]                 })
[10:27:13.909]                 withCallingHandlers({
[10:27:13.909]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:27:13.909]                 }, immediateCondition = function(cond) {
[10:27:13.909]                   sendCondition <- ...future.makeSendCondition()
[10:27:13.909]                   sendCondition(cond)
[10:27:13.909]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:13.909]                   {
[10:27:13.909]                     inherits <- base::inherits
[10:27:13.909]                     invokeRestart <- base::invokeRestart
[10:27:13.909]                     is.null <- base::is.null
[10:27:13.909]                     muffled <- FALSE
[10:27:13.909]                     if (inherits(cond, "message")) {
[10:27:13.909]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:13.909]                       if (muffled) 
[10:27:13.909]                         invokeRestart("muffleMessage")
[10:27:13.909]                     }
[10:27:13.909]                     else if (inherits(cond, "warning")) {
[10:27:13.909]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:13.909]                       if (muffled) 
[10:27:13.909]                         invokeRestart("muffleWarning")
[10:27:13.909]                     }
[10:27:13.909]                     else if (inherits(cond, "condition")) {
[10:27:13.909]                       if (!is.null(pattern)) {
[10:27:13.909]                         computeRestarts <- base::computeRestarts
[10:27:13.909]                         grepl <- base::grepl
[10:27:13.909]                         restarts <- computeRestarts(cond)
[10:27:13.909]                         for (restart in restarts) {
[10:27:13.909]                           name <- restart$name
[10:27:13.909]                           if (is.null(name)) 
[10:27:13.909]                             next
[10:27:13.909]                           if (!grepl(pattern, name)) 
[10:27:13.909]                             next
[10:27:13.909]                           invokeRestart(restart)
[10:27:13.909]                           muffled <- TRUE
[10:27:13.909]                           break
[10:27:13.909]                         }
[10:27:13.909]                       }
[10:27:13.909]                     }
[10:27:13.909]                     invisible(muffled)
[10:27:13.909]                   }
[10:27:13.909]                   muffleCondition(cond)
[10:27:13.909]                 })
[10:27:13.909]             }))
[10:27:13.909]             future::FutureResult(value = ...future.value$value, 
[10:27:13.909]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:13.909]                   ...future.rng), globalenv = if (FALSE) 
[10:27:13.909]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:13.909]                     ...future.globalenv.names))
[10:27:13.909]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:13.909]         }, condition = base::local({
[10:27:13.909]             c <- base::c
[10:27:13.909]             inherits <- base::inherits
[10:27:13.909]             invokeRestart <- base::invokeRestart
[10:27:13.909]             length <- base::length
[10:27:13.909]             list <- base::list
[10:27:13.909]             seq.int <- base::seq.int
[10:27:13.909]             signalCondition <- base::signalCondition
[10:27:13.909]             sys.calls <- base::sys.calls
[10:27:13.909]             `[[` <- base::`[[`
[10:27:13.909]             `+` <- base::`+`
[10:27:13.909]             `<<-` <- base::`<<-`
[10:27:13.909]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:13.909]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:13.909]                   3L)]
[10:27:13.909]             }
[10:27:13.909]             function(cond) {
[10:27:13.909]                 is_error <- inherits(cond, "error")
[10:27:13.909]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:13.909]                   NULL)
[10:27:13.909]                 if (is_error) {
[10:27:13.909]                   sessionInformation <- function() {
[10:27:13.909]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:13.909]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:13.909]                       search = base::search(), system = base::Sys.info())
[10:27:13.909]                   }
[10:27:13.909]                   ...future.conditions[[length(...future.conditions) + 
[10:27:13.909]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:13.909]                     cond$call), session = sessionInformation(), 
[10:27:13.909]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:13.909]                   signalCondition(cond)
[10:27:13.909]                 }
[10:27:13.909]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:13.909]                 "immediateCondition"))) {
[10:27:13.909]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:13.909]                   ...future.conditions[[length(...future.conditions) + 
[10:27:13.909]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:13.909]                   if (TRUE && !signal) {
[10:27:13.909]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:13.909]                     {
[10:27:13.909]                       inherits <- base::inherits
[10:27:13.909]                       invokeRestart <- base::invokeRestart
[10:27:13.909]                       is.null <- base::is.null
[10:27:13.909]                       muffled <- FALSE
[10:27:13.909]                       if (inherits(cond, "message")) {
[10:27:13.909]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:13.909]                         if (muffled) 
[10:27:13.909]                           invokeRestart("muffleMessage")
[10:27:13.909]                       }
[10:27:13.909]                       else if (inherits(cond, "warning")) {
[10:27:13.909]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:13.909]                         if (muffled) 
[10:27:13.909]                           invokeRestart("muffleWarning")
[10:27:13.909]                       }
[10:27:13.909]                       else if (inherits(cond, "condition")) {
[10:27:13.909]                         if (!is.null(pattern)) {
[10:27:13.909]                           computeRestarts <- base::computeRestarts
[10:27:13.909]                           grepl <- base::grepl
[10:27:13.909]                           restarts <- computeRestarts(cond)
[10:27:13.909]                           for (restart in restarts) {
[10:27:13.909]                             name <- restart$name
[10:27:13.909]                             if (is.null(name)) 
[10:27:13.909]                               next
[10:27:13.909]                             if (!grepl(pattern, name)) 
[10:27:13.909]                               next
[10:27:13.909]                             invokeRestart(restart)
[10:27:13.909]                             muffled <- TRUE
[10:27:13.909]                             break
[10:27:13.909]                           }
[10:27:13.909]                         }
[10:27:13.909]                       }
[10:27:13.909]                       invisible(muffled)
[10:27:13.909]                     }
[10:27:13.909]                     muffleCondition(cond, pattern = "^muffle")
[10:27:13.909]                   }
[10:27:13.909]                 }
[10:27:13.909]                 else {
[10:27:13.909]                   if (TRUE) {
[10:27:13.909]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:13.909]                     {
[10:27:13.909]                       inherits <- base::inherits
[10:27:13.909]                       invokeRestart <- base::invokeRestart
[10:27:13.909]                       is.null <- base::is.null
[10:27:13.909]                       muffled <- FALSE
[10:27:13.909]                       if (inherits(cond, "message")) {
[10:27:13.909]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:13.909]                         if (muffled) 
[10:27:13.909]                           invokeRestart("muffleMessage")
[10:27:13.909]                       }
[10:27:13.909]                       else if (inherits(cond, "warning")) {
[10:27:13.909]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:13.909]                         if (muffled) 
[10:27:13.909]                           invokeRestart("muffleWarning")
[10:27:13.909]                       }
[10:27:13.909]                       else if (inherits(cond, "condition")) {
[10:27:13.909]                         if (!is.null(pattern)) {
[10:27:13.909]                           computeRestarts <- base::computeRestarts
[10:27:13.909]                           grepl <- base::grepl
[10:27:13.909]                           restarts <- computeRestarts(cond)
[10:27:13.909]                           for (restart in restarts) {
[10:27:13.909]                             name <- restart$name
[10:27:13.909]                             if (is.null(name)) 
[10:27:13.909]                               next
[10:27:13.909]                             if (!grepl(pattern, name)) 
[10:27:13.909]                               next
[10:27:13.909]                             invokeRestart(restart)
[10:27:13.909]                             muffled <- TRUE
[10:27:13.909]                             break
[10:27:13.909]                           }
[10:27:13.909]                         }
[10:27:13.909]                       }
[10:27:13.909]                       invisible(muffled)
[10:27:13.909]                     }
[10:27:13.909]                     muffleCondition(cond, pattern = "^muffle")
[10:27:13.909]                   }
[10:27:13.909]                 }
[10:27:13.909]             }
[10:27:13.909]         }))
[10:27:13.909]     }, error = function(ex) {
[10:27:13.909]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:13.909]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:13.909]                 ...future.rng), started = ...future.startTime, 
[10:27:13.909]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:13.909]             version = "1.8"), class = "FutureResult")
[10:27:13.909]     }, finally = {
[10:27:13.909]         if (!identical(...future.workdir, getwd())) 
[10:27:13.909]             setwd(...future.workdir)
[10:27:13.909]         {
[10:27:13.909]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:13.909]                 ...future.oldOptions$nwarnings <- NULL
[10:27:13.909]             }
[10:27:13.909]             base::options(...future.oldOptions)
[10:27:13.909]             if (.Platform$OS.type == "windows") {
[10:27:13.909]                 old_names <- names(...future.oldEnvVars)
[10:27:13.909]                 envs <- base::Sys.getenv()
[10:27:13.909]                 names <- names(envs)
[10:27:13.909]                 common <- intersect(names, old_names)
[10:27:13.909]                 added <- setdiff(names, old_names)
[10:27:13.909]                 removed <- setdiff(old_names, names)
[10:27:13.909]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:13.909]                   envs[common]]
[10:27:13.909]                 NAMES <- toupper(changed)
[10:27:13.909]                 args <- list()
[10:27:13.909]                 for (kk in seq_along(NAMES)) {
[10:27:13.909]                   name <- changed[[kk]]
[10:27:13.909]                   NAME <- NAMES[[kk]]
[10:27:13.909]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:13.909]                     next
[10:27:13.909]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:13.909]                 }
[10:27:13.909]                 NAMES <- toupper(added)
[10:27:13.909]                 for (kk in seq_along(NAMES)) {
[10:27:13.909]                   name <- added[[kk]]
[10:27:13.909]                   NAME <- NAMES[[kk]]
[10:27:13.909]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:13.909]                     next
[10:27:13.909]                   args[[name]] <- ""
[10:27:13.909]                 }
[10:27:13.909]                 NAMES <- toupper(removed)
[10:27:13.909]                 for (kk in seq_along(NAMES)) {
[10:27:13.909]                   name <- removed[[kk]]
[10:27:13.909]                   NAME <- NAMES[[kk]]
[10:27:13.909]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:13.909]                     next
[10:27:13.909]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:13.909]                 }
[10:27:13.909]                 if (length(args) > 0) 
[10:27:13.909]                   base::do.call(base::Sys.setenv, args = args)
[10:27:13.909]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:13.909]             }
[10:27:13.909]             else {
[10:27:13.909]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:13.909]             }
[10:27:13.909]             {
[10:27:13.909]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:13.909]                   0L) {
[10:27:13.909]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:13.909]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:13.909]                   base::options(opts)
[10:27:13.909]                 }
[10:27:13.909]                 {
[10:27:13.909]                   {
[10:27:13.909]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:13.909]                     NULL
[10:27:13.909]                   }
[10:27:13.909]                   options(future.plan = NULL)
[10:27:13.909]                   if (is.na(NA_character_)) 
[10:27:13.909]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:13.909]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:13.909]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:13.909]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:13.909]                     envir = parent.frame()) 
[10:27:13.909]                   {
[10:27:13.909]                     if (is.function(workers)) 
[10:27:13.909]                       workers <- workers()
[10:27:13.909]                     workers <- structure(as.integer(workers), 
[10:27:13.909]                       class = class(workers))
[10:27:13.909]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:13.909]                       workers >= 1)
[10:27:13.909]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:13.909]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:13.909]                     }
[10:27:13.909]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:13.909]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:13.909]                       envir = envir)
[10:27:13.909]                     if (!future$lazy) 
[10:27:13.909]                       future <- run(future)
[10:27:13.909]                     invisible(future)
[10:27:13.909]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:13.909]                 }
[10:27:13.909]             }
[10:27:13.909]         }
[10:27:13.909]     })
[10:27:13.909]     if (TRUE) {
[10:27:13.909]         base::sink(type = "output", split = FALSE)
[10:27:13.909]         if (TRUE) {
[10:27:13.909]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:13.909]         }
[10:27:13.909]         else {
[10:27:13.909]             ...future.result["stdout"] <- base::list(NULL)
[10:27:13.909]         }
[10:27:13.909]         base::close(...future.stdout)
[10:27:13.909]         ...future.stdout <- NULL
[10:27:13.909]     }
[10:27:13.909]     ...future.result$conditions <- ...future.conditions
[10:27:13.909]     ...future.result$finished <- base::Sys.time()
[10:27:13.909]     ...future.result
[10:27:13.909] }
[10:27:13.912] MultisessionFuture started
[10:27:13.913] - Launch lazy future ... done
[10:27:13.913] run() for ‘MultisessionFuture’ ... done
[10:27:13.958] receiveMessageFromWorker() for ClusterFuture ...
[10:27:13.959] - Validating connection of MultisessionFuture
[10:27:13.959] - received message: FutureResult
[10:27:13.959] - Received FutureResult
[10:27:13.959] - Erased future from FutureRegistry
[10:27:13.960] result() for ClusterFuture ...
[10:27:13.960] - result already collected: FutureResult
[10:27:13.960] result() for ClusterFuture ... done
[10:27:13.960] signalConditions() ...
[10:27:13.960]  - include = ‘immediateCondition’
[10:27:13.960]  - exclude = 
[10:27:13.960]  - resignal = FALSE
[10:27:13.960]  - Number of conditions: 1
[10:27:13.960] signalConditions() ... done
[10:27:13.960] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:13.961] A MultisessionFuture was resolved
- result = TRUE, recursive = FALSE ... DONE
- result = TRUE, recursive = TRUE ...
[10:27:13.961] getGlobalsAndPackages() ...
[10:27:13.961] Searching for globals...
[10:27:13.962] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:27:13.962] Searching for globals ... DONE
[10:27:13.962] Resolving globals: FALSE
[10:27:13.963] 
[10:27:13.963] 
[10:27:13.963] getGlobalsAndPackages() ... DONE
[10:27:13.963] run() for ‘Future’ ...
[10:27:13.963] - state: ‘created’
[10:27:13.963] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:13.977] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:13.977] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:13.977]   - Field: ‘node’
[10:27:13.977]   - Field: ‘label’
[10:27:13.978]   - Field: ‘local’
[10:27:13.978]   - Field: ‘owner’
[10:27:13.978]   - Field: ‘envir’
[10:27:13.978]   - Field: ‘workers’
[10:27:13.978]   - Field: ‘packages’
[10:27:13.978]   - Field: ‘gc’
[10:27:13.978]   - Field: ‘conditions’
[10:27:13.978]   - Field: ‘persistent’
[10:27:13.978]   - Field: ‘expr’
[10:27:13.978]   - Field: ‘uuid’
[10:27:13.978]   - Field: ‘seed’
[10:27:13.979]   - Field: ‘version’
[10:27:13.979]   - Field: ‘result’
[10:27:13.979]   - Field: ‘asynchronous’
[10:27:13.979]   - Field: ‘calls’
[10:27:13.979]   - Field: ‘globals’
[10:27:13.979]   - Field: ‘stdout’
[10:27:13.979]   - Field: ‘earlySignal’
[10:27:13.979]   - Field: ‘lazy’
[10:27:13.979]   - Field: ‘state’
[10:27:13.979] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:13.979] - Launch lazy future ...
[10:27:13.980] Packages needed by the future expression (n = 0): <none>
[10:27:13.980] Packages needed by future strategies (n = 0): <none>
[10:27:13.980] {
[10:27:13.980]     {
[10:27:13.980]         {
[10:27:13.980]             ...future.startTime <- base::Sys.time()
[10:27:13.980]             {
[10:27:13.980]                 {
[10:27:13.980]                   {
[10:27:13.980]                     {
[10:27:13.980]                       base::local({
[10:27:13.980]                         has_future <- base::requireNamespace("future", 
[10:27:13.980]                           quietly = TRUE)
[10:27:13.980]                         if (has_future) {
[10:27:13.980]                           ns <- base::getNamespace("future")
[10:27:13.980]                           version <- ns[[".package"]][["version"]]
[10:27:13.980]                           if (is.null(version)) 
[10:27:13.980]                             version <- utils::packageVersion("future")
[10:27:13.980]                         }
[10:27:13.980]                         else {
[10:27:13.980]                           version <- NULL
[10:27:13.980]                         }
[10:27:13.980]                         if (!has_future || version < "1.8.0") {
[10:27:13.980]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:13.980]                             "", base::R.version$version.string), 
[10:27:13.980]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:13.980]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:13.980]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:13.980]                               "release", "version")], collapse = " "), 
[10:27:13.980]                             hostname = base::Sys.info()[["nodename"]])
[10:27:13.980]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:13.980]                             info)
[10:27:13.980]                           info <- base::paste(info, collapse = "; ")
[10:27:13.980]                           if (!has_future) {
[10:27:13.980]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:13.980]                               info)
[10:27:13.980]                           }
[10:27:13.980]                           else {
[10:27:13.980]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:13.980]                               info, version)
[10:27:13.980]                           }
[10:27:13.980]                           base::stop(msg)
[10:27:13.980]                         }
[10:27:13.980]                       })
[10:27:13.980]                     }
[10:27:13.980]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:13.980]                     base::options(mc.cores = 1L)
[10:27:13.980]                   }
[10:27:13.980]                   options(future.plan = NULL)
[10:27:13.980]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:13.980]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:13.980]                 }
[10:27:13.980]                 ...future.workdir <- getwd()
[10:27:13.980]             }
[10:27:13.980]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:13.980]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:13.980]         }
[10:27:13.980]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:13.980]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:13.980]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:13.980]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:13.980]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:13.980]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:13.980]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:13.980]             base::names(...future.oldOptions))
[10:27:13.980]     }
[10:27:13.980]     if (FALSE) {
[10:27:13.980]     }
[10:27:13.980]     else {
[10:27:13.980]         if (TRUE) {
[10:27:13.980]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:13.980]                 open = "w")
[10:27:13.980]         }
[10:27:13.980]         else {
[10:27:13.980]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:13.980]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:13.980]         }
[10:27:13.980]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:13.980]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:13.980]             base::sink(type = "output", split = FALSE)
[10:27:13.980]             base::close(...future.stdout)
[10:27:13.980]         }, add = TRUE)
[10:27:13.980]     }
[10:27:13.980]     ...future.frame <- base::sys.nframe()
[10:27:13.980]     ...future.conditions <- base::list()
[10:27:13.980]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:13.980]     if (FALSE) {
[10:27:13.980]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:13.980]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:13.980]     }
[10:27:13.980]     ...future.result <- base::tryCatch({
[10:27:13.980]         base::withCallingHandlers({
[10:27:13.980]             ...future.value <- base::withVisible(base::local({
[10:27:13.980]                 ...future.makeSendCondition <- base::local({
[10:27:13.980]                   sendCondition <- NULL
[10:27:13.980]                   function(frame = 1L) {
[10:27:13.980]                     if (is.function(sendCondition)) 
[10:27:13.980]                       return(sendCondition)
[10:27:13.980]                     ns <- getNamespace("parallel")
[10:27:13.980]                     if (exists("sendData", mode = "function", 
[10:27:13.980]                       envir = ns)) {
[10:27:13.980]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:13.980]                         envir = ns)
[10:27:13.980]                       envir <- sys.frame(frame)
[10:27:13.980]                       master <- NULL
[10:27:13.980]                       while (!identical(envir, .GlobalEnv) && 
[10:27:13.980]                         !identical(envir, emptyenv())) {
[10:27:13.980]                         if (exists("master", mode = "list", envir = envir, 
[10:27:13.980]                           inherits = FALSE)) {
[10:27:13.980]                           master <- get("master", mode = "list", 
[10:27:13.980]                             envir = envir, inherits = FALSE)
[10:27:13.980]                           if (inherits(master, c("SOCKnode", 
[10:27:13.980]                             "SOCK0node"))) {
[10:27:13.980]                             sendCondition <<- function(cond) {
[10:27:13.980]                               data <- list(type = "VALUE", value = cond, 
[10:27:13.980]                                 success = TRUE)
[10:27:13.980]                               parallel_sendData(master, data)
[10:27:13.980]                             }
[10:27:13.980]                             return(sendCondition)
[10:27:13.980]                           }
[10:27:13.980]                         }
[10:27:13.980]                         frame <- frame + 1L
[10:27:13.980]                         envir <- sys.frame(frame)
[10:27:13.980]                       }
[10:27:13.980]                     }
[10:27:13.980]                     sendCondition <<- function(cond) NULL
[10:27:13.980]                   }
[10:27:13.980]                 })
[10:27:13.980]                 withCallingHandlers({
[10:27:13.980]                   {
[10:27:13.980]                     Sys.sleep(0.5)
[10:27:13.980]                     list(a = 1, b = 42L)
[10:27:13.980]                   }
[10:27:13.980]                 }, immediateCondition = function(cond) {
[10:27:13.980]                   sendCondition <- ...future.makeSendCondition()
[10:27:13.980]                   sendCondition(cond)
[10:27:13.980]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:13.980]                   {
[10:27:13.980]                     inherits <- base::inherits
[10:27:13.980]                     invokeRestart <- base::invokeRestart
[10:27:13.980]                     is.null <- base::is.null
[10:27:13.980]                     muffled <- FALSE
[10:27:13.980]                     if (inherits(cond, "message")) {
[10:27:13.980]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:13.980]                       if (muffled) 
[10:27:13.980]                         invokeRestart("muffleMessage")
[10:27:13.980]                     }
[10:27:13.980]                     else if (inherits(cond, "warning")) {
[10:27:13.980]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:13.980]                       if (muffled) 
[10:27:13.980]                         invokeRestart("muffleWarning")
[10:27:13.980]                     }
[10:27:13.980]                     else if (inherits(cond, "condition")) {
[10:27:13.980]                       if (!is.null(pattern)) {
[10:27:13.980]                         computeRestarts <- base::computeRestarts
[10:27:13.980]                         grepl <- base::grepl
[10:27:13.980]                         restarts <- computeRestarts(cond)
[10:27:13.980]                         for (restart in restarts) {
[10:27:13.980]                           name <- restart$name
[10:27:13.980]                           if (is.null(name)) 
[10:27:13.980]                             next
[10:27:13.980]                           if (!grepl(pattern, name)) 
[10:27:13.980]                             next
[10:27:13.980]                           invokeRestart(restart)
[10:27:13.980]                           muffled <- TRUE
[10:27:13.980]                           break
[10:27:13.980]                         }
[10:27:13.980]                       }
[10:27:13.980]                     }
[10:27:13.980]                     invisible(muffled)
[10:27:13.980]                   }
[10:27:13.980]                   muffleCondition(cond)
[10:27:13.980]                 })
[10:27:13.980]             }))
[10:27:13.980]             future::FutureResult(value = ...future.value$value, 
[10:27:13.980]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:13.980]                   ...future.rng), globalenv = if (FALSE) 
[10:27:13.980]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:13.980]                     ...future.globalenv.names))
[10:27:13.980]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:13.980]         }, condition = base::local({
[10:27:13.980]             c <- base::c
[10:27:13.980]             inherits <- base::inherits
[10:27:13.980]             invokeRestart <- base::invokeRestart
[10:27:13.980]             length <- base::length
[10:27:13.980]             list <- base::list
[10:27:13.980]             seq.int <- base::seq.int
[10:27:13.980]             signalCondition <- base::signalCondition
[10:27:13.980]             sys.calls <- base::sys.calls
[10:27:13.980]             `[[` <- base::`[[`
[10:27:13.980]             `+` <- base::`+`
[10:27:13.980]             `<<-` <- base::`<<-`
[10:27:13.980]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:13.980]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:13.980]                   3L)]
[10:27:13.980]             }
[10:27:13.980]             function(cond) {
[10:27:13.980]                 is_error <- inherits(cond, "error")
[10:27:13.980]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:13.980]                   NULL)
[10:27:13.980]                 if (is_error) {
[10:27:13.980]                   sessionInformation <- function() {
[10:27:13.980]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:13.980]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:13.980]                       search = base::search(), system = base::Sys.info())
[10:27:13.980]                   }
[10:27:13.980]                   ...future.conditions[[length(...future.conditions) + 
[10:27:13.980]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:13.980]                     cond$call), session = sessionInformation(), 
[10:27:13.980]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:13.980]                   signalCondition(cond)
[10:27:13.980]                 }
[10:27:13.980]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:13.980]                 "immediateCondition"))) {
[10:27:13.980]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:13.980]                   ...future.conditions[[length(...future.conditions) + 
[10:27:13.980]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:13.980]                   if (TRUE && !signal) {
[10:27:13.980]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:13.980]                     {
[10:27:13.980]                       inherits <- base::inherits
[10:27:13.980]                       invokeRestart <- base::invokeRestart
[10:27:13.980]                       is.null <- base::is.null
[10:27:13.980]                       muffled <- FALSE
[10:27:13.980]                       if (inherits(cond, "message")) {
[10:27:13.980]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:13.980]                         if (muffled) 
[10:27:13.980]                           invokeRestart("muffleMessage")
[10:27:13.980]                       }
[10:27:13.980]                       else if (inherits(cond, "warning")) {
[10:27:13.980]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:13.980]                         if (muffled) 
[10:27:13.980]                           invokeRestart("muffleWarning")
[10:27:13.980]                       }
[10:27:13.980]                       else if (inherits(cond, "condition")) {
[10:27:13.980]                         if (!is.null(pattern)) {
[10:27:13.980]                           computeRestarts <- base::computeRestarts
[10:27:13.980]                           grepl <- base::grepl
[10:27:13.980]                           restarts <- computeRestarts(cond)
[10:27:13.980]                           for (restart in restarts) {
[10:27:13.980]                             name <- restart$name
[10:27:13.980]                             if (is.null(name)) 
[10:27:13.980]                               next
[10:27:13.980]                             if (!grepl(pattern, name)) 
[10:27:13.980]                               next
[10:27:13.980]                             invokeRestart(restart)
[10:27:13.980]                             muffled <- TRUE
[10:27:13.980]                             break
[10:27:13.980]                           }
[10:27:13.980]                         }
[10:27:13.980]                       }
[10:27:13.980]                       invisible(muffled)
[10:27:13.980]                     }
[10:27:13.980]                     muffleCondition(cond, pattern = "^muffle")
[10:27:13.980]                   }
[10:27:13.980]                 }
[10:27:13.980]                 else {
[10:27:13.980]                   if (TRUE) {
[10:27:13.980]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:13.980]                     {
[10:27:13.980]                       inherits <- base::inherits
[10:27:13.980]                       invokeRestart <- base::invokeRestart
[10:27:13.980]                       is.null <- base::is.null
[10:27:13.980]                       muffled <- FALSE
[10:27:13.980]                       if (inherits(cond, "message")) {
[10:27:13.980]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:13.980]                         if (muffled) 
[10:27:13.980]                           invokeRestart("muffleMessage")
[10:27:13.980]                       }
[10:27:13.980]                       else if (inherits(cond, "warning")) {
[10:27:13.980]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:13.980]                         if (muffled) 
[10:27:13.980]                           invokeRestart("muffleWarning")
[10:27:13.980]                       }
[10:27:13.980]                       else if (inherits(cond, "condition")) {
[10:27:13.980]                         if (!is.null(pattern)) {
[10:27:13.980]                           computeRestarts <- base::computeRestarts
[10:27:13.980]                           grepl <- base::grepl
[10:27:13.980]                           restarts <- computeRestarts(cond)
[10:27:13.980]                           for (restart in restarts) {
[10:27:13.980]                             name <- restart$name
[10:27:13.980]                             if (is.null(name)) 
[10:27:13.980]                               next
[10:27:13.980]                             if (!grepl(pattern, name)) 
[10:27:13.980]                               next
[10:27:13.980]                             invokeRestart(restart)
[10:27:13.980]                             muffled <- TRUE
[10:27:13.980]                             break
[10:27:13.980]                           }
[10:27:13.980]                         }
[10:27:13.980]                       }
[10:27:13.980]                       invisible(muffled)
[10:27:13.980]                     }
[10:27:13.980]                     muffleCondition(cond, pattern = "^muffle")
[10:27:13.980]                   }
[10:27:13.980]                 }
[10:27:13.980]             }
[10:27:13.980]         }))
[10:27:13.980]     }, error = function(ex) {
[10:27:13.980]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:13.980]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:13.980]                 ...future.rng), started = ...future.startTime, 
[10:27:13.980]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:13.980]             version = "1.8"), class = "FutureResult")
[10:27:13.980]     }, finally = {
[10:27:13.980]         if (!identical(...future.workdir, getwd())) 
[10:27:13.980]             setwd(...future.workdir)
[10:27:13.980]         {
[10:27:13.980]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:13.980]                 ...future.oldOptions$nwarnings <- NULL
[10:27:13.980]             }
[10:27:13.980]             base::options(...future.oldOptions)
[10:27:13.980]             if (.Platform$OS.type == "windows") {
[10:27:13.980]                 old_names <- names(...future.oldEnvVars)
[10:27:13.980]                 envs <- base::Sys.getenv()
[10:27:13.980]                 names <- names(envs)
[10:27:13.980]                 common <- intersect(names, old_names)
[10:27:13.980]                 added <- setdiff(names, old_names)
[10:27:13.980]                 removed <- setdiff(old_names, names)
[10:27:13.980]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:13.980]                   envs[common]]
[10:27:13.980]                 NAMES <- toupper(changed)
[10:27:13.980]                 args <- list()
[10:27:13.980]                 for (kk in seq_along(NAMES)) {
[10:27:13.980]                   name <- changed[[kk]]
[10:27:13.980]                   NAME <- NAMES[[kk]]
[10:27:13.980]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:13.980]                     next
[10:27:13.980]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:13.980]                 }
[10:27:13.980]                 NAMES <- toupper(added)
[10:27:13.980]                 for (kk in seq_along(NAMES)) {
[10:27:13.980]                   name <- added[[kk]]
[10:27:13.980]                   NAME <- NAMES[[kk]]
[10:27:13.980]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:13.980]                     next
[10:27:13.980]                   args[[name]] <- ""
[10:27:13.980]                 }
[10:27:13.980]                 NAMES <- toupper(removed)
[10:27:13.980]                 for (kk in seq_along(NAMES)) {
[10:27:13.980]                   name <- removed[[kk]]
[10:27:13.980]                   NAME <- NAMES[[kk]]
[10:27:13.980]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:13.980]                     next
[10:27:13.980]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:13.980]                 }
[10:27:13.980]                 if (length(args) > 0) 
[10:27:13.980]                   base::do.call(base::Sys.setenv, args = args)
[10:27:13.980]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:13.980]             }
[10:27:13.980]             else {
[10:27:13.980]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:13.980]             }
[10:27:13.980]             {
[10:27:13.980]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:13.980]                   0L) {
[10:27:13.980]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:13.980]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:13.980]                   base::options(opts)
[10:27:13.980]                 }
[10:27:13.980]                 {
[10:27:13.980]                   {
[10:27:13.980]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:13.980]                     NULL
[10:27:13.980]                   }
[10:27:13.980]                   options(future.plan = NULL)
[10:27:13.980]                   if (is.na(NA_character_)) 
[10:27:13.980]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:13.980]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:13.980]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:13.980]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:13.980]                     envir = parent.frame()) 
[10:27:13.980]                   {
[10:27:13.980]                     if (is.function(workers)) 
[10:27:13.980]                       workers <- workers()
[10:27:13.980]                     workers <- structure(as.integer(workers), 
[10:27:13.980]                       class = class(workers))
[10:27:13.980]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:13.980]                       workers >= 1)
[10:27:13.980]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:13.980]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:13.980]                     }
[10:27:13.980]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:13.980]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:13.980]                       envir = envir)
[10:27:13.980]                     if (!future$lazy) 
[10:27:13.980]                       future <- run(future)
[10:27:13.980]                     invisible(future)
[10:27:13.980]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:13.980]                 }
[10:27:13.980]             }
[10:27:13.980]         }
[10:27:13.980]     })
[10:27:13.980]     if (TRUE) {
[10:27:13.980]         base::sink(type = "output", split = FALSE)
[10:27:13.980]         if (TRUE) {
[10:27:13.980]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:13.980]         }
[10:27:13.980]         else {
[10:27:13.980]             ...future.result["stdout"] <- base::list(NULL)
[10:27:13.980]         }
[10:27:13.980]         base::close(...future.stdout)
[10:27:13.980]         ...future.stdout <- NULL
[10:27:13.980]     }
[10:27:13.980]     ...future.result$conditions <- ...future.conditions
[10:27:13.980]     ...future.result$finished <- base::Sys.time()
[10:27:13.980]     ...future.result
[10:27:13.980] }
[10:27:13.983] MultisessionFuture started
[10:27:13.984] - Launch lazy future ... done
[10:27:13.984] run() for ‘MultisessionFuture’ ... done
[10:27:14.531] receiveMessageFromWorker() for ClusterFuture ...
[10:27:14.532] - Validating connection of MultisessionFuture
[10:27:14.532] - received message: FutureResult
[10:27:14.532] - Received FutureResult
[10:27:14.532] - Erased future from FutureRegistry
[10:27:14.532] result() for ClusterFuture ...
[10:27:14.533] - result already collected: FutureResult
[10:27:14.533] result() for ClusterFuture ... done
[10:27:14.533] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:14.533] resolve() on list ...
[10:27:14.533]  recursive: 98
[10:27:14.533]  length: 2
[10:27:14.533]  elements: ‘a’, ‘b’
[10:27:14.533]  length: 1 (resolved future 1)
[10:27:14.534]  length: 0 (resolved future 2)
[10:27:14.534] resolve() on list ... DONE
[10:27:14.534] A MultisessionFuture was resolved (and resolved itself)
[10:27:14.534] getGlobalsAndPackages() ...
[10:27:14.534] Searching for globals...
[10:27:14.535] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:27:14.535] Searching for globals ... DONE
[10:27:14.535] Resolving globals: FALSE
[10:27:14.536] 
[10:27:14.536] 
[10:27:14.536] getGlobalsAndPackages() ... DONE
[10:27:14.536] run() for ‘Future’ ...
[10:27:14.536] - state: ‘created’
[10:27:14.536] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:14.551] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:14.551] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:14.551]   - Field: ‘node’
[10:27:14.556]   - Field: ‘label’
[10:27:14.556]   - Field: ‘local’
[10:27:14.557]   - Field: ‘owner’
[10:27:14.557]   - Field: ‘envir’
[10:27:14.557]   - Field: ‘workers’
[10:27:14.557]   - Field: ‘packages’
[10:27:14.557]   - Field: ‘gc’
[10:27:14.557]   - Field: ‘conditions’
[10:27:14.558]   - Field: ‘persistent’
[10:27:14.558]   - Field: ‘expr’
[10:27:14.558]   - Field: ‘uuid’
[10:27:14.558]   - Field: ‘seed’
[10:27:14.558]   - Field: ‘version’
[10:27:14.558]   - Field: ‘result’
[10:27:14.558]   - Field: ‘asynchronous’
[10:27:14.559]   - Field: ‘calls’
[10:27:14.559]   - Field: ‘globals’
[10:27:14.559]   - Field: ‘stdout’
[10:27:14.559]   - Field: ‘earlySignal’
[10:27:14.559]   - Field: ‘lazy’
[10:27:14.559]   - Field: ‘state’
[10:27:14.559] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:14.560] - Launch lazy future ...
[10:27:14.560] Packages needed by the future expression (n = 0): <none>
[10:27:14.560] Packages needed by future strategies (n = 0): <none>
[10:27:14.561] {
[10:27:14.561]     {
[10:27:14.561]         {
[10:27:14.561]             ...future.startTime <- base::Sys.time()
[10:27:14.561]             {
[10:27:14.561]                 {
[10:27:14.561]                   {
[10:27:14.561]                     {
[10:27:14.561]                       base::local({
[10:27:14.561]                         has_future <- base::requireNamespace("future", 
[10:27:14.561]                           quietly = TRUE)
[10:27:14.561]                         if (has_future) {
[10:27:14.561]                           ns <- base::getNamespace("future")
[10:27:14.561]                           version <- ns[[".package"]][["version"]]
[10:27:14.561]                           if (is.null(version)) 
[10:27:14.561]                             version <- utils::packageVersion("future")
[10:27:14.561]                         }
[10:27:14.561]                         else {
[10:27:14.561]                           version <- NULL
[10:27:14.561]                         }
[10:27:14.561]                         if (!has_future || version < "1.8.0") {
[10:27:14.561]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:14.561]                             "", base::R.version$version.string), 
[10:27:14.561]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:14.561]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:14.561]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:14.561]                               "release", "version")], collapse = " "), 
[10:27:14.561]                             hostname = base::Sys.info()[["nodename"]])
[10:27:14.561]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:14.561]                             info)
[10:27:14.561]                           info <- base::paste(info, collapse = "; ")
[10:27:14.561]                           if (!has_future) {
[10:27:14.561]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:14.561]                               info)
[10:27:14.561]                           }
[10:27:14.561]                           else {
[10:27:14.561]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:14.561]                               info, version)
[10:27:14.561]                           }
[10:27:14.561]                           base::stop(msg)
[10:27:14.561]                         }
[10:27:14.561]                       })
[10:27:14.561]                     }
[10:27:14.561]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:14.561]                     base::options(mc.cores = 1L)
[10:27:14.561]                   }
[10:27:14.561]                   options(future.plan = NULL)
[10:27:14.561]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:14.561]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:14.561]                 }
[10:27:14.561]                 ...future.workdir <- getwd()
[10:27:14.561]             }
[10:27:14.561]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:14.561]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:14.561]         }
[10:27:14.561]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:14.561]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:14.561]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:14.561]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:14.561]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:14.561]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:14.561]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:14.561]             base::names(...future.oldOptions))
[10:27:14.561]     }
[10:27:14.561]     if (FALSE) {
[10:27:14.561]     }
[10:27:14.561]     else {
[10:27:14.561]         if (TRUE) {
[10:27:14.561]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:14.561]                 open = "w")
[10:27:14.561]         }
[10:27:14.561]         else {
[10:27:14.561]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:14.561]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:14.561]         }
[10:27:14.561]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:14.561]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:14.561]             base::sink(type = "output", split = FALSE)
[10:27:14.561]             base::close(...future.stdout)
[10:27:14.561]         }, add = TRUE)
[10:27:14.561]     }
[10:27:14.561]     ...future.frame <- base::sys.nframe()
[10:27:14.561]     ...future.conditions <- base::list()
[10:27:14.561]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:14.561]     if (FALSE) {
[10:27:14.561]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:14.561]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:14.561]     }
[10:27:14.561]     ...future.result <- base::tryCatch({
[10:27:14.561]         base::withCallingHandlers({
[10:27:14.561]             ...future.value <- base::withVisible(base::local({
[10:27:14.561]                 ...future.makeSendCondition <- base::local({
[10:27:14.561]                   sendCondition <- NULL
[10:27:14.561]                   function(frame = 1L) {
[10:27:14.561]                     if (is.function(sendCondition)) 
[10:27:14.561]                       return(sendCondition)
[10:27:14.561]                     ns <- getNamespace("parallel")
[10:27:14.561]                     if (exists("sendData", mode = "function", 
[10:27:14.561]                       envir = ns)) {
[10:27:14.561]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:14.561]                         envir = ns)
[10:27:14.561]                       envir <- sys.frame(frame)
[10:27:14.561]                       master <- NULL
[10:27:14.561]                       while (!identical(envir, .GlobalEnv) && 
[10:27:14.561]                         !identical(envir, emptyenv())) {
[10:27:14.561]                         if (exists("master", mode = "list", envir = envir, 
[10:27:14.561]                           inherits = FALSE)) {
[10:27:14.561]                           master <- get("master", mode = "list", 
[10:27:14.561]                             envir = envir, inherits = FALSE)
[10:27:14.561]                           if (inherits(master, c("SOCKnode", 
[10:27:14.561]                             "SOCK0node"))) {
[10:27:14.561]                             sendCondition <<- function(cond) {
[10:27:14.561]                               data <- list(type = "VALUE", value = cond, 
[10:27:14.561]                                 success = TRUE)
[10:27:14.561]                               parallel_sendData(master, data)
[10:27:14.561]                             }
[10:27:14.561]                             return(sendCondition)
[10:27:14.561]                           }
[10:27:14.561]                         }
[10:27:14.561]                         frame <- frame + 1L
[10:27:14.561]                         envir <- sys.frame(frame)
[10:27:14.561]                       }
[10:27:14.561]                     }
[10:27:14.561]                     sendCondition <<- function(cond) NULL
[10:27:14.561]                   }
[10:27:14.561]                 })
[10:27:14.561]                 withCallingHandlers({
[10:27:14.561]                   {
[10:27:14.561]                     Sys.sleep(0.5)
[10:27:14.561]                     list(a = 1, b = 42L)
[10:27:14.561]                   }
[10:27:14.561]                 }, immediateCondition = function(cond) {
[10:27:14.561]                   sendCondition <- ...future.makeSendCondition()
[10:27:14.561]                   sendCondition(cond)
[10:27:14.561]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:14.561]                   {
[10:27:14.561]                     inherits <- base::inherits
[10:27:14.561]                     invokeRestart <- base::invokeRestart
[10:27:14.561]                     is.null <- base::is.null
[10:27:14.561]                     muffled <- FALSE
[10:27:14.561]                     if (inherits(cond, "message")) {
[10:27:14.561]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:14.561]                       if (muffled) 
[10:27:14.561]                         invokeRestart("muffleMessage")
[10:27:14.561]                     }
[10:27:14.561]                     else if (inherits(cond, "warning")) {
[10:27:14.561]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:14.561]                       if (muffled) 
[10:27:14.561]                         invokeRestart("muffleWarning")
[10:27:14.561]                     }
[10:27:14.561]                     else if (inherits(cond, "condition")) {
[10:27:14.561]                       if (!is.null(pattern)) {
[10:27:14.561]                         computeRestarts <- base::computeRestarts
[10:27:14.561]                         grepl <- base::grepl
[10:27:14.561]                         restarts <- computeRestarts(cond)
[10:27:14.561]                         for (restart in restarts) {
[10:27:14.561]                           name <- restart$name
[10:27:14.561]                           if (is.null(name)) 
[10:27:14.561]                             next
[10:27:14.561]                           if (!grepl(pattern, name)) 
[10:27:14.561]                             next
[10:27:14.561]                           invokeRestart(restart)
[10:27:14.561]                           muffled <- TRUE
[10:27:14.561]                           break
[10:27:14.561]                         }
[10:27:14.561]                       }
[10:27:14.561]                     }
[10:27:14.561]                     invisible(muffled)
[10:27:14.561]                   }
[10:27:14.561]                   muffleCondition(cond)
[10:27:14.561]                 })
[10:27:14.561]             }))
[10:27:14.561]             future::FutureResult(value = ...future.value$value, 
[10:27:14.561]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:14.561]                   ...future.rng), globalenv = if (FALSE) 
[10:27:14.561]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:14.561]                     ...future.globalenv.names))
[10:27:14.561]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:14.561]         }, condition = base::local({
[10:27:14.561]             c <- base::c
[10:27:14.561]             inherits <- base::inherits
[10:27:14.561]             invokeRestart <- base::invokeRestart
[10:27:14.561]             length <- base::length
[10:27:14.561]             list <- base::list
[10:27:14.561]             seq.int <- base::seq.int
[10:27:14.561]             signalCondition <- base::signalCondition
[10:27:14.561]             sys.calls <- base::sys.calls
[10:27:14.561]             `[[` <- base::`[[`
[10:27:14.561]             `+` <- base::`+`
[10:27:14.561]             `<<-` <- base::`<<-`
[10:27:14.561]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:14.561]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:14.561]                   3L)]
[10:27:14.561]             }
[10:27:14.561]             function(cond) {
[10:27:14.561]                 is_error <- inherits(cond, "error")
[10:27:14.561]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:14.561]                   NULL)
[10:27:14.561]                 if (is_error) {
[10:27:14.561]                   sessionInformation <- function() {
[10:27:14.561]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:14.561]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:14.561]                       search = base::search(), system = base::Sys.info())
[10:27:14.561]                   }
[10:27:14.561]                   ...future.conditions[[length(...future.conditions) + 
[10:27:14.561]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:14.561]                     cond$call), session = sessionInformation(), 
[10:27:14.561]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:14.561]                   signalCondition(cond)
[10:27:14.561]                 }
[10:27:14.561]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:14.561]                 "immediateCondition"))) {
[10:27:14.561]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:14.561]                   ...future.conditions[[length(...future.conditions) + 
[10:27:14.561]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:14.561]                   if (TRUE && !signal) {
[10:27:14.561]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:14.561]                     {
[10:27:14.561]                       inherits <- base::inherits
[10:27:14.561]                       invokeRestart <- base::invokeRestart
[10:27:14.561]                       is.null <- base::is.null
[10:27:14.561]                       muffled <- FALSE
[10:27:14.561]                       if (inherits(cond, "message")) {
[10:27:14.561]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:14.561]                         if (muffled) 
[10:27:14.561]                           invokeRestart("muffleMessage")
[10:27:14.561]                       }
[10:27:14.561]                       else if (inherits(cond, "warning")) {
[10:27:14.561]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:14.561]                         if (muffled) 
[10:27:14.561]                           invokeRestart("muffleWarning")
[10:27:14.561]                       }
[10:27:14.561]                       else if (inherits(cond, "condition")) {
[10:27:14.561]                         if (!is.null(pattern)) {
[10:27:14.561]                           computeRestarts <- base::computeRestarts
[10:27:14.561]                           grepl <- base::grepl
[10:27:14.561]                           restarts <- computeRestarts(cond)
[10:27:14.561]                           for (restart in restarts) {
[10:27:14.561]                             name <- restart$name
[10:27:14.561]                             if (is.null(name)) 
[10:27:14.561]                               next
[10:27:14.561]                             if (!grepl(pattern, name)) 
[10:27:14.561]                               next
[10:27:14.561]                             invokeRestart(restart)
[10:27:14.561]                             muffled <- TRUE
[10:27:14.561]                             break
[10:27:14.561]                           }
[10:27:14.561]                         }
[10:27:14.561]                       }
[10:27:14.561]                       invisible(muffled)
[10:27:14.561]                     }
[10:27:14.561]                     muffleCondition(cond, pattern = "^muffle")
[10:27:14.561]                   }
[10:27:14.561]                 }
[10:27:14.561]                 else {
[10:27:14.561]                   if (TRUE) {
[10:27:14.561]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:14.561]                     {
[10:27:14.561]                       inherits <- base::inherits
[10:27:14.561]                       invokeRestart <- base::invokeRestart
[10:27:14.561]                       is.null <- base::is.null
[10:27:14.561]                       muffled <- FALSE
[10:27:14.561]                       if (inherits(cond, "message")) {
[10:27:14.561]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:14.561]                         if (muffled) 
[10:27:14.561]                           invokeRestart("muffleMessage")
[10:27:14.561]                       }
[10:27:14.561]                       else if (inherits(cond, "warning")) {
[10:27:14.561]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:14.561]                         if (muffled) 
[10:27:14.561]                           invokeRestart("muffleWarning")
[10:27:14.561]                       }
[10:27:14.561]                       else if (inherits(cond, "condition")) {
[10:27:14.561]                         if (!is.null(pattern)) {
[10:27:14.561]                           computeRestarts <- base::computeRestarts
[10:27:14.561]                           grepl <- base::grepl
[10:27:14.561]                           restarts <- computeRestarts(cond)
[10:27:14.561]                           for (restart in restarts) {
[10:27:14.561]                             name <- restart$name
[10:27:14.561]                             if (is.null(name)) 
[10:27:14.561]                               next
[10:27:14.561]                             if (!grepl(pattern, name)) 
[10:27:14.561]                               next
[10:27:14.561]                             invokeRestart(restart)
[10:27:14.561]                             muffled <- TRUE
[10:27:14.561]                             break
[10:27:14.561]                           }
[10:27:14.561]                         }
[10:27:14.561]                       }
[10:27:14.561]                       invisible(muffled)
[10:27:14.561]                     }
[10:27:14.561]                     muffleCondition(cond, pattern = "^muffle")
[10:27:14.561]                   }
[10:27:14.561]                 }
[10:27:14.561]             }
[10:27:14.561]         }))
[10:27:14.561]     }, error = function(ex) {
[10:27:14.561]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:14.561]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:14.561]                 ...future.rng), started = ...future.startTime, 
[10:27:14.561]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:14.561]             version = "1.8"), class = "FutureResult")
[10:27:14.561]     }, finally = {
[10:27:14.561]         if (!identical(...future.workdir, getwd())) 
[10:27:14.561]             setwd(...future.workdir)
[10:27:14.561]         {
[10:27:14.561]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:14.561]                 ...future.oldOptions$nwarnings <- NULL
[10:27:14.561]             }
[10:27:14.561]             base::options(...future.oldOptions)
[10:27:14.561]             if (.Platform$OS.type == "windows") {
[10:27:14.561]                 old_names <- names(...future.oldEnvVars)
[10:27:14.561]                 envs <- base::Sys.getenv()
[10:27:14.561]                 names <- names(envs)
[10:27:14.561]                 common <- intersect(names, old_names)
[10:27:14.561]                 added <- setdiff(names, old_names)
[10:27:14.561]                 removed <- setdiff(old_names, names)
[10:27:14.561]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:14.561]                   envs[common]]
[10:27:14.561]                 NAMES <- toupper(changed)
[10:27:14.561]                 args <- list()
[10:27:14.561]                 for (kk in seq_along(NAMES)) {
[10:27:14.561]                   name <- changed[[kk]]
[10:27:14.561]                   NAME <- NAMES[[kk]]
[10:27:14.561]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:14.561]                     next
[10:27:14.561]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:14.561]                 }
[10:27:14.561]                 NAMES <- toupper(added)
[10:27:14.561]                 for (kk in seq_along(NAMES)) {
[10:27:14.561]                   name <- added[[kk]]
[10:27:14.561]                   NAME <- NAMES[[kk]]
[10:27:14.561]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:14.561]                     next
[10:27:14.561]                   args[[name]] <- ""
[10:27:14.561]                 }
[10:27:14.561]                 NAMES <- toupper(removed)
[10:27:14.561]                 for (kk in seq_along(NAMES)) {
[10:27:14.561]                   name <- removed[[kk]]
[10:27:14.561]                   NAME <- NAMES[[kk]]
[10:27:14.561]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:14.561]                     next
[10:27:14.561]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:14.561]                 }
[10:27:14.561]                 if (length(args) > 0) 
[10:27:14.561]                   base::do.call(base::Sys.setenv, args = args)
[10:27:14.561]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:14.561]             }
[10:27:14.561]             else {
[10:27:14.561]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:14.561]             }
[10:27:14.561]             {
[10:27:14.561]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:14.561]                   0L) {
[10:27:14.561]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:14.561]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:14.561]                   base::options(opts)
[10:27:14.561]                 }
[10:27:14.561]                 {
[10:27:14.561]                   {
[10:27:14.561]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:14.561]                     NULL
[10:27:14.561]                   }
[10:27:14.561]                   options(future.plan = NULL)
[10:27:14.561]                   if (is.na(NA_character_)) 
[10:27:14.561]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:14.561]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:14.561]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:14.561]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:14.561]                     envir = parent.frame()) 
[10:27:14.561]                   {
[10:27:14.561]                     if (is.function(workers)) 
[10:27:14.561]                       workers <- workers()
[10:27:14.561]                     workers <- structure(as.integer(workers), 
[10:27:14.561]                       class = class(workers))
[10:27:14.561]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:14.561]                       workers >= 1)
[10:27:14.561]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:14.561]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:14.561]                     }
[10:27:14.561]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:14.561]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:14.561]                       envir = envir)
[10:27:14.561]                     if (!future$lazy) 
[10:27:14.561]                       future <- run(future)
[10:27:14.561]                     invisible(future)
[10:27:14.561]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:14.561]                 }
[10:27:14.561]             }
[10:27:14.561]         }
[10:27:14.561]     })
[10:27:14.561]     if (TRUE) {
[10:27:14.561]         base::sink(type = "output", split = FALSE)
[10:27:14.561]         if (TRUE) {
[10:27:14.561]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:14.561]         }
[10:27:14.561]         else {
[10:27:14.561]             ...future.result["stdout"] <- base::list(NULL)
[10:27:14.561]         }
[10:27:14.561]         base::close(...future.stdout)
[10:27:14.561]         ...future.stdout <- NULL
[10:27:14.561]     }
[10:27:14.561]     ...future.result$conditions <- ...future.conditions
[10:27:14.561]     ...future.result$finished <- base::Sys.time()
[10:27:14.561]     ...future.result
[10:27:14.561] }
[10:27:14.565] MultisessionFuture started
[10:27:14.565] - Launch lazy future ... done
[10:27:14.565] run() for ‘MultisessionFuture’ ... done
[10:27:15.111] receiveMessageFromWorker() for ClusterFuture ...
[10:27:15.111] - Validating connection of MultisessionFuture
[10:27:15.112] - received message: FutureResult
[10:27:15.112] - Received FutureResult
[10:27:15.112] - Erased future from FutureRegistry
[10:27:15.112] result() for ClusterFuture ...
[10:27:15.112] - result already collected: FutureResult
[10:27:15.112] result() for ClusterFuture ... done
[10:27:15.112] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:15.112] resolve() on list ...
[10:27:15.112]  recursive: 98
[10:27:15.112]  length: 2
[10:27:15.113]  elements: ‘a’, ‘b’
[10:27:15.113]  length: 1 (resolved future 1)
[10:27:15.113]  length: 0 (resolved future 2)
[10:27:15.113] resolve() on list ... DONE
[10:27:15.113] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[10:27:15.113] getGlobalsAndPackages() ...
[10:27:15.113] Searching for globals...
[10:27:15.114] - globals found: [2] ‘list’, ‘stop’
[10:27:15.114] Searching for globals ... DONE
[10:27:15.114] Resolving globals: FALSE
[10:27:15.114] 
[10:27:15.115] 
[10:27:15.115] getGlobalsAndPackages() ... DONE
[10:27:15.115] run() for ‘Future’ ...
[10:27:15.115] - state: ‘created’
[10:27:15.115] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:15.129] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:15.129] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:15.129]   - Field: ‘node’
[10:27:15.129]   - Field: ‘label’
[10:27:15.129]   - Field: ‘local’
[10:27:15.129]   - Field: ‘owner’
[10:27:15.130]   - Field: ‘envir’
[10:27:15.130]   - Field: ‘workers’
[10:27:15.130]   - Field: ‘packages’
[10:27:15.130]   - Field: ‘gc’
[10:27:15.130]   - Field: ‘conditions’
[10:27:15.130]   - Field: ‘persistent’
[10:27:15.130]   - Field: ‘expr’
[10:27:15.130]   - Field: ‘uuid’
[10:27:15.130]   - Field: ‘seed’
[10:27:15.130]   - Field: ‘version’
[10:27:15.130]   - Field: ‘result’
[10:27:15.131]   - Field: ‘asynchronous’
[10:27:15.131]   - Field: ‘calls’
[10:27:15.131]   - Field: ‘globals’
[10:27:15.131]   - Field: ‘stdout’
[10:27:15.131]   - Field: ‘earlySignal’
[10:27:15.131]   - Field: ‘lazy’
[10:27:15.131]   - Field: ‘state’
[10:27:15.131] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:15.131] - Launch lazy future ...
[10:27:15.132] Packages needed by the future expression (n = 0): <none>
[10:27:15.132] Packages needed by future strategies (n = 0): <none>
[10:27:15.132] {
[10:27:15.132]     {
[10:27:15.132]         {
[10:27:15.132]             ...future.startTime <- base::Sys.time()
[10:27:15.132]             {
[10:27:15.132]                 {
[10:27:15.132]                   {
[10:27:15.132]                     {
[10:27:15.132]                       base::local({
[10:27:15.132]                         has_future <- base::requireNamespace("future", 
[10:27:15.132]                           quietly = TRUE)
[10:27:15.132]                         if (has_future) {
[10:27:15.132]                           ns <- base::getNamespace("future")
[10:27:15.132]                           version <- ns[[".package"]][["version"]]
[10:27:15.132]                           if (is.null(version)) 
[10:27:15.132]                             version <- utils::packageVersion("future")
[10:27:15.132]                         }
[10:27:15.132]                         else {
[10:27:15.132]                           version <- NULL
[10:27:15.132]                         }
[10:27:15.132]                         if (!has_future || version < "1.8.0") {
[10:27:15.132]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:15.132]                             "", base::R.version$version.string), 
[10:27:15.132]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:15.132]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:15.132]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:15.132]                               "release", "version")], collapse = " "), 
[10:27:15.132]                             hostname = base::Sys.info()[["nodename"]])
[10:27:15.132]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:15.132]                             info)
[10:27:15.132]                           info <- base::paste(info, collapse = "; ")
[10:27:15.132]                           if (!has_future) {
[10:27:15.132]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:15.132]                               info)
[10:27:15.132]                           }
[10:27:15.132]                           else {
[10:27:15.132]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:15.132]                               info, version)
[10:27:15.132]                           }
[10:27:15.132]                           base::stop(msg)
[10:27:15.132]                         }
[10:27:15.132]                       })
[10:27:15.132]                     }
[10:27:15.132]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:15.132]                     base::options(mc.cores = 1L)
[10:27:15.132]                   }
[10:27:15.132]                   options(future.plan = NULL)
[10:27:15.132]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:15.132]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:15.132]                 }
[10:27:15.132]                 ...future.workdir <- getwd()
[10:27:15.132]             }
[10:27:15.132]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:15.132]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:15.132]         }
[10:27:15.132]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:15.132]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:15.132]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:15.132]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:15.132]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:15.132]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:15.132]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:15.132]             base::names(...future.oldOptions))
[10:27:15.132]     }
[10:27:15.132]     if (FALSE) {
[10:27:15.132]     }
[10:27:15.132]     else {
[10:27:15.132]         if (TRUE) {
[10:27:15.132]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:15.132]                 open = "w")
[10:27:15.132]         }
[10:27:15.132]         else {
[10:27:15.132]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:15.132]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:15.132]         }
[10:27:15.132]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:15.132]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:15.132]             base::sink(type = "output", split = FALSE)
[10:27:15.132]             base::close(...future.stdout)
[10:27:15.132]         }, add = TRUE)
[10:27:15.132]     }
[10:27:15.132]     ...future.frame <- base::sys.nframe()
[10:27:15.132]     ...future.conditions <- base::list()
[10:27:15.132]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:15.132]     if (FALSE) {
[10:27:15.132]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:15.132]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:15.132]     }
[10:27:15.132]     ...future.result <- base::tryCatch({
[10:27:15.132]         base::withCallingHandlers({
[10:27:15.132]             ...future.value <- base::withVisible(base::local({
[10:27:15.132]                 ...future.makeSendCondition <- base::local({
[10:27:15.132]                   sendCondition <- NULL
[10:27:15.132]                   function(frame = 1L) {
[10:27:15.132]                     if (is.function(sendCondition)) 
[10:27:15.132]                       return(sendCondition)
[10:27:15.132]                     ns <- getNamespace("parallel")
[10:27:15.132]                     if (exists("sendData", mode = "function", 
[10:27:15.132]                       envir = ns)) {
[10:27:15.132]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:15.132]                         envir = ns)
[10:27:15.132]                       envir <- sys.frame(frame)
[10:27:15.132]                       master <- NULL
[10:27:15.132]                       while (!identical(envir, .GlobalEnv) && 
[10:27:15.132]                         !identical(envir, emptyenv())) {
[10:27:15.132]                         if (exists("master", mode = "list", envir = envir, 
[10:27:15.132]                           inherits = FALSE)) {
[10:27:15.132]                           master <- get("master", mode = "list", 
[10:27:15.132]                             envir = envir, inherits = FALSE)
[10:27:15.132]                           if (inherits(master, c("SOCKnode", 
[10:27:15.132]                             "SOCK0node"))) {
[10:27:15.132]                             sendCondition <<- function(cond) {
[10:27:15.132]                               data <- list(type = "VALUE", value = cond, 
[10:27:15.132]                                 success = TRUE)
[10:27:15.132]                               parallel_sendData(master, data)
[10:27:15.132]                             }
[10:27:15.132]                             return(sendCondition)
[10:27:15.132]                           }
[10:27:15.132]                         }
[10:27:15.132]                         frame <- frame + 1L
[10:27:15.132]                         envir <- sys.frame(frame)
[10:27:15.132]                       }
[10:27:15.132]                     }
[10:27:15.132]                     sendCondition <<- function(cond) NULL
[10:27:15.132]                   }
[10:27:15.132]                 })
[10:27:15.132]                 withCallingHandlers({
[10:27:15.132]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:27:15.132]                 }, immediateCondition = function(cond) {
[10:27:15.132]                   sendCondition <- ...future.makeSendCondition()
[10:27:15.132]                   sendCondition(cond)
[10:27:15.132]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:15.132]                   {
[10:27:15.132]                     inherits <- base::inherits
[10:27:15.132]                     invokeRestart <- base::invokeRestart
[10:27:15.132]                     is.null <- base::is.null
[10:27:15.132]                     muffled <- FALSE
[10:27:15.132]                     if (inherits(cond, "message")) {
[10:27:15.132]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:15.132]                       if (muffled) 
[10:27:15.132]                         invokeRestart("muffleMessage")
[10:27:15.132]                     }
[10:27:15.132]                     else if (inherits(cond, "warning")) {
[10:27:15.132]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:15.132]                       if (muffled) 
[10:27:15.132]                         invokeRestart("muffleWarning")
[10:27:15.132]                     }
[10:27:15.132]                     else if (inherits(cond, "condition")) {
[10:27:15.132]                       if (!is.null(pattern)) {
[10:27:15.132]                         computeRestarts <- base::computeRestarts
[10:27:15.132]                         grepl <- base::grepl
[10:27:15.132]                         restarts <- computeRestarts(cond)
[10:27:15.132]                         for (restart in restarts) {
[10:27:15.132]                           name <- restart$name
[10:27:15.132]                           if (is.null(name)) 
[10:27:15.132]                             next
[10:27:15.132]                           if (!grepl(pattern, name)) 
[10:27:15.132]                             next
[10:27:15.132]                           invokeRestart(restart)
[10:27:15.132]                           muffled <- TRUE
[10:27:15.132]                           break
[10:27:15.132]                         }
[10:27:15.132]                       }
[10:27:15.132]                     }
[10:27:15.132]                     invisible(muffled)
[10:27:15.132]                   }
[10:27:15.132]                   muffleCondition(cond)
[10:27:15.132]                 })
[10:27:15.132]             }))
[10:27:15.132]             future::FutureResult(value = ...future.value$value, 
[10:27:15.132]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:15.132]                   ...future.rng), globalenv = if (FALSE) 
[10:27:15.132]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:15.132]                     ...future.globalenv.names))
[10:27:15.132]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:15.132]         }, condition = base::local({
[10:27:15.132]             c <- base::c
[10:27:15.132]             inherits <- base::inherits
[10:27:15.132]             invokeRestart <- base::invokeRestart
[10:27:15.132]             length <- base::length
[10:27:15.132]             list <- base::list
[10:27:15.132]             seq.int <- base::seq.int
[10:27:15.132]             signalCondition <- base::signalCondition
[10:27:15.132]             sys.calls <- base::sys.calls
[10:27:15.132]             `[[` <- base::`[[`
[10:27:15.132]             `+` <- base::`+`
[10:27:15.132]             `<<-` <- base::`<<-`
[10:27:15.132]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:15.132]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:15.132]                   3L)]
[10:27:15.132]             }
[10:27:15.132]             function(cond) {
[10:27:15.132]                 is_error <- inherits(cond, "error")
[10:27:15.132]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:15.132]                   NULL)
[10:27:15.132]                 if (is_error) {
[10:27:15.132]                   sessionInformation <- function() {
[10:27:15.132]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:15.132]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:15.132]                       search = base::search(), system = base::Sys.info())
[10:27:15.132]                   }
[10:27:15.132]                   ...future.conditions[[length(...future.conditions) + 
[10:27:15.132]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:15.132]                     cond$call), session = sessionInformation(), 
[10:27:15.132]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:15.132]                   signalCondition(cond)
[10:27:15.132]                 }
[10:27:15.132]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:15.132]                 "immediateCondition"))) {
[10:27:15.132]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:15.132]                   ...future.conditions[[length(...future.conditions) + 
[10:27:15.132]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:15.132]                   if (TRUE && !signal) {
[10:27:15.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:15.132]                     {
[10:27:15.132]                       inherits <- base::inherits
[10:27:15.132]                       invokeRestart <- base::invokeRestart
[10:27:15.132]                       is.null <- base::is.null
[10:27:15.132]                       muffled <- FALSE
[10:27:15.132]                       if (inherits(cond, "message")) {
[10:27:15.132]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:15.132]                         if (muffled) 
[10:27:15.132]                           invokeRestart("muffleMessage")
[10:27:15.132]                       }
[10:27:15.132]                       else if (inherits(cond, "warning")) {
[10:27:15.132]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:15.132]                         if (muffled) 
[10:27:15.132]                           invokeRestart("muffleWarning")
[10:27:15.132]                       }
[10:27:15.132]                       else if (inherits(cond, "condition")) {
[10:27:15.132]                         if (!is.null(pattern)) {
[10:27:15.132]                           computeRestarts <- base::computeRestarts
[10:27:15.132]                           grepl <- base::grepl
[10:27:15.132]                           restarts <- computeRestarts(cond)
[10:27:15.132]                           for (restart in restarts) {
[10:27:15.132]                             name <- restart$name
[10:27:15.132]                             if (is.null(name)) 
[10:27:15.132]                               next
[10:27:15.132]                             if (!grepl(pattern, name)) 
[10:27:15.132]                               next
[10:27:15.132]                             invokeRestart(restart)
[10:27:15.132]                             muffled <- TRUE
[10:27:15.132]                             break
[10:27:15.132]                           }
[10:27:15.132]                         }
[10:27:15.132]                       }
[10:27:15.132]                       invisible(muffled)
[10:27:15.132]                     }
[10:27:15.132]                     muffleCondition(cond, pattern = "^muffle")
[10:27:15.132]                   }
[10:27:15.132]                 }
[10:27:15.132]                 else {
[10:27:15.132]                   if (TRUE) {
[10:27:15.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:15.132]                     {
[10:27:15.132]                       inherits <- base::inherits
[10:27:15.132]                       invokeRestart <- base::invokeRestart
[10:27:15.132]                       is.null <- base::is.null
[10:27:15.132]                       muffled <- FALSE
[10:27:15.132]                       if (inherits(cond, "message")) {
[10:27:15.132]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:15.132]                         if (muffled) 
[10:27:15.132]                           invokeRestart("muffleMessage")
[10:27:15.132]                       }
[10:27:15.132]                       else if (inherits(cond, "warning")) {
[10:27:15.132]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:15.132]                         if (muffled) 
[10:27:15.132]                           invokeRestart("muffleWarning")
[10:27:15.132]                       }
[10:27:15.132]                       else if (inherits(cond, "condition")) {
[10:27:15.132]                         if (!is.null(pattern)) {
[10:27:15.132]                           computeRestarts <- base::computeRestarts
[10:27:15.132]                           grepl <- base::grepl
[10:27:15.132]                           restarts <- computeRestarts(cond)
[10:27:15.132]                           for (restart in restarts) {
[10:27:15.132]                             name <- restart$name
[10:27:15.132]                             if (is.null(name)) 
[10:27:15.132]                               next
[10:27:15.132]                             if (!grepl(pattern, name)) 
[10:27:15.132]                               next
[10:27:15.132]                             invokeRestart(restart)
[10:27:15.132]                             muffled <- TRUE
[10:27:15.132]                             break
[10:27:15.132]                           }
[10:27:15.132]                         }
[10:27:15.132]                       }
[10:27:15.132]                       invisible(muffled)
[10:27:15.132]                     }
[10:27:15.132]                     muffleCondition(cond, pattern = "^muffle")
[10:27:15.132]                   }
[10:27:15.132]                 }
[10:27:15.132]             }
[10:27:15.132]         }))
[10:27:15.132]     }, error = function(ex) {
[10:27:15.132]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:15.132]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:15.132]                 ...future.rng), started = ...future.startTime, 
[10:27:15.132]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:15.132]             version = "1.8"), class = "FutureResult")
[10:27:15.132]     }, finally = {
[10:27:15.132]         if (!identical(...future.workdir, getwd())) 
[10:27:15.132]             setwd(...future.workdir)
[10:27:15.132]         {
[10:27:15.132]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:15.132]                 ...future.oldOptions$nwarnings <- NULL
[10:27:15.132]             }
[10:27:15.132]             base::options(...future.oldOptions)
[10:27:15.132]             if (.Platform$OS.type == "windows") {
[10:27:15.132]                 old_names <- names(...future.oldEnvVars)
[10:27:15.132]                 envs <- base::Sys.getenv()
[10:27:15.132]                 names <- names(envs)
[10:27:15.132]                 common <- intersect(names, old_names)
[10:27:15.132]                 added <- setdiff(names, old_names)
[10:27:15.132]                 removed <- setdiff(old_names, names)
[10:27:15.132]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:15.132]                   envs[common]]
[10:27:15.132]                 NAMES <- toupper(changed)
[10:27:15.132]                 args <- list()
[10:27:15.132]                 for (kk in seq_along(NAMES)) {
[10:27:15.132]                   name <- changed[[kk]]
[10:27:15.132]                   NAME <- NAMES[[kk]]
[10:27:15.132]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:15.132]                     next
[10:27:15.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:15.132]                 }
[10:27:15.132]                 NAMES <- toupper(added)
[10:27:15.132]                 for (kk in seq_along(NAMES)) {
[10:27:15.132]                   name <- added[[kk]]
[10:27:15.132]                   NAME <- NAMES[[kk]]
[10:27:15.132]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:15.132]                     next
[10:27:15.132]                   args[[name]] <- ""
[10:27:15.132]                 }
[10:27:15.132]                 NAMES <- toupper(removed)
[10:27:15.132]                 for (kk in seq_along(NAMES)) {
[10:27:15.132]                   name <- removed[[kk]]
[10:27:15.132]                   NAME <- NAMES[[kk]]
[10:27:15.132]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:15.132]                     next
[10:27:15.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:15.132]                 }
[10:27:15.132]                 if (length(args) > 0) 
[10:27:15.132]                   base::do.call(base::Sys.setenv, args = args)
[10:27:15.132]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:15.132]             }
[10:27:15.132]             else {
[10:27:15.132]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:15.132]             }
[10:27:15.132]             {
[10:27:15.132]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:15.132]                   0L) {
[10:27:15.132]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:15.132]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:15.132]                   base::options(opts)
[10:27:15.132]                 }
[10:27:15.132]                 {
[10:27:15.132]                   {
[10:27:15.132]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:15.132]                     NULL
[10:27:15.132]                   }
[10:27:15.132]                   options(future.plan = NULL)
[10:27:15.132]                   if (is.na(NA_character_)) 
[10:27:15.132]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:15.132]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:15.132]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:15.132]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:15.132]                     envir = parent.frame()) 
[10:27:15.132]                   {
[10:27:15.132]                     if (is.function(workers)) 
[10:27:15.132]                       workers <- workers()
[10:27:15.132]                     workers <- structure(as.integer(workers), 
[10:27:15.132]                       class = class(workers))
[10:27:15.132]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:15.132]                       workers >= 1)
[10:27:15.132]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:15.132]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:15.132]                     }
[10:27:15.132]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:15.132]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:15.132]                       envir = envir)
[10:27:15.132]                     if (!future$lazy) 
[10:27:15.132]                       future <- run(future)
[10:27:15.132]                     invisible(future)
[10:27:15.132]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:15.132]                 }
[10:27:15.132]             }
[10:27:15.132]         }
[10:27:15.132]     })
[10:27:15.132]     if (TRUE) {
[10:27:15.132]         base::sink(type = "output", split = FALSE)
[10:27:15.132]         if (TRUE) {
[10:27:15.132]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:15.132]         }
[10:27:15.132]         else {
[10:27:15.132]             ...future.result["stdout"] <- base::list(NULL)
[10:27:15.132]         }
[10:27:15.132]         base::close(...future.stdout)
[10:27:15.132]         ...future.stdout <- NULL
[10:27:15.132]     }
[10:27:15.132]     ...future.result$conditions <- ...future.conditions
[10:27:15.132]     ...future.result$finished <- base::Sys.time()
[10:27:15.132]     ...future.result
[10:27:15.132] }
[10:27:15.135] MultisessionFuture started
[10:27:15.135] - Launch lazy future ... done
[10:27:15.135] run() for ‘MultisessionFuture’ ... done
[10:27:15.182] receiveMessageFromWorker() for ClusterFuture ...
[10:27:15.183] - Validating connection of MultisessionFuture
[10:27:15.183] - received message: FutureResult
[10:27:15.184] - Received FutureResult
[10:27:15.184] - Erased future from FutureRegistry
[10:27:15.184] result() for ClusterFuture ...
[10:27:15.184] - result already collected: FutureResult
[10:27:15.184] result() for ClusterFuture ... done
[10:27:15.184] signalConditions() ...
[10:27:15.184]  - include = ‘immediateCondition’
[10:27:15.184]  - exclude = 
[10:27:15.184]  - resignal = FALSE
[10:27:15.185]  - Number of conditions: 1
[10:27:15.185] signalConditions() ... done
[10:27:15.185] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:15.185] A MultisessionFuture was resolved
[10:27:15.185] getGlobalsAndPackages() ...
[10:27:15.185] Searching for globals...
[10:27:15.186] - globals found: [2] ‘list’, ‘stop’
[10:27:15.186] Searching for globals ... DONE
[10:27:15.186] Resolving globals: FALSE
[10:27:15.186] 
[10:27:15.186] 
[10:27:15.186] getGlobalsAndPackages() ... DONE
[10:27:15.187] run() for ‘Future’ ...
[10:27:15.187] - state: ‘created’
[10:27:15.187] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:15.201] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:15.201] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:15.201]   - Field: ‘node’
[10:27:15.201]   - Field: ‘label’
[10:27:15.201]   - Field: ‘local’
[10:27:15.202]   - Field: ‘owner’
[10:27:15.202]   - Field: ‘envir’
[10:27:15.202]   - Field: ‘workers’
[10:27:15.202]   - Field: ‘packages’
[10:27:15.202]   - Field: ‘gc’
[10:27:15.202]   - Field: ‘conditions’
[10:27:15.202]   - Field: ‘persistent’
[10:27:15.202]   - Field: ‘expr’
[10:27:15.202]   - Field: ‘uuid’
[10:27:15.202]   - Field: ‘seed’
[10:27:15.202]   - Field: ‘version’
[10:27:15.203]   - Field: ‘result’
[10:27:15.203]   - Field: ‘asynchronous’
[10:27:15.203]   - Field: ‘calls’
[10:27:15.203]   - Field: ‘globals’
[10:27:15.203]   - Field: ‘stdout’
[10:27:15.203]   - Field: ‘earlySignal’
[10:27:15.203]   - Field: ‘lazy’
[10:27:15.203]   - Field: ‘state’
[10:27:15.203] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:15.203] - Launch lazy future ...
[10:27:15.204] Packages needed by the future expression (n = 0): <none>
[10:27:15.204] Packages needed by future strategies (n = 0): <none>
[10:27:15.204] {
[10:27:15.204]     {
[10:27:15.204]         {
[10:27:15.204]             ...future.startTime <- base::Sys.time()
[10:27:15.204]             {
[10:27:15.204]                 {
[10:27:15.204]                   {
[10:27:15.204]                     {
[10:27:15.204]                       base::local({
[10:27:15.204]                         has_future <- base::requireNamespace("future", 
[10:27:15.204]                           quietly = TRUE)
[10:27:15.204]                         if (has_future) {
[10:27:15.204]                           ns <- base::getNamespace("future")
[10:27:15.204]                           version <- ns[[".package"]][["version"]]
[10:27:15.204]                           if (is.null(version)) 
[10:27:15.204]                             version <- utils::packageVersion("future")
[10:27:15.204]                         }
[10:27:15.204]                         else {
[10:27:15.204]                           version <- NULL
[10:27:15.204]                         }
[10:27:15.204]                         if (!has_future || version < "1.8.0") {
[10:27:15.204]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:15.204]                             "", base::R.version$version.string), 
[10:27:15.204]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:15.204]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:15.204]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:15.204]                               "release", "version")], collapse = " "), 
[10:27:15.204]                             hostname = base::Sys.info()[["nodename"]])
[10:27:15.204]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:15.204]                             info)
[10:27:15.204]                           info <- base::paste(info, collapse = "; ")
[10:27:15.204]                           if (!has_future) {
[10:27:15.204]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:15.204]                               info)
[10:27:15.204]                           }
[10:27:15.204]                           else {
[10:27:15.204]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:15.204]                               info, version)
[10:27:15.204]                           }
[10:27:15.204]                           base::stop(msg)
[10:27:15.204]                         }
[10:27:15.204]                       })
[10:27:15.204]                     }
[10:27:15.204]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:15.204]                     base::options(mc.cores = 1L)
[10:27:15.204]                   }
[10:27:15.204]                   options(future.plan = NULL)
[10:27:15.204]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:15.204]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:15.204]                 }
[10:27:15.204]                 ...future.workdir <- getwd()
[10:27:15.204]             }
[10:27:15.204]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:15.204]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:15.204]         }
[10:27:15.204]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:15.204]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:15.204]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:15.204]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:15.204]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:15.204]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:15.204]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:15.204]             base::names(...future.oldOptions))
[10:27:15.204]     }
[10:27:15.204]     if (FALSE) {
[10:27:15.204]     }
[10:27:15.204]     else {
[10:27:15.204]         if (TRUE) {
[10:27:15.204]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:15.204]                 open = "w")
[10:27:15.204]         }
[10:27:15.204]         else {
[10:27:15.204]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:15.204]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:15.204]         }
[10:27:15.204]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:15.204]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:15.204]             base::sink(type = "output", split = FALSE)
[10:27:15.204]             base::close(...future.stdout)
[10:27:15.204]         }, add = TRUE)
[10:27:15.204]     }
[10:27:15.204]     ...future.frame <- base::sys.nframe()
[10:27:15.204]     ...future.conditions <- base::list()
[10:27:15.204]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:15.204]     if (FALSE) {
[10:27:15.204]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:15.204]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:15.204]     }
[10:27:15.204]     ...future.result <- base::tryCatch({
[10:27:15.204]         base::withCallingHandlers({
[10:27:15.204]             ...future.value <- base::withVisible(base::local({
[10:27:15.204]                 ...future.makeSendCondition <- base::local({
[10:27:15.204]                   sendCondition <- NULL
[10:27:15.204]                   function(frame = 1L) {
[10:27:15.204]                     if (is.function(sendCondition)) 
[10:27:15.204]                       return(sendCondition)
[10:27:15.204]                     ns <- getNamespace("parallel")
[10:27:15.204]                     if (exists("sendData", mode = "function", 
[10:27:15.204]                       envir = ns)) {
[10:27:15.204]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:15.204]                         envir = ns)
[10:27:15.204]                       envir <- sys.frame(frame)
[10:27:15.204]                       master <- NULL
[10:27:15.204]                       while (!identical(envir, .GlobalEnv) && 
[10:27:15.204]                         !identical(envir, emptyenv())) {
[10:27:15.204]                         if (exists("master", mode = "list", envir = envir, 
[10:27:15.204]                           inherits = FALSE)) {
[10:27:15.204]                           master <- get("master", mode = "list", 
[10:27:15.204]                             envir = envir, inherits = FALSE)
[10:27:15.204]                           if (inherits(master, c("SOCKnode", 
[10:27:15.204]                             "SOCK0node"))) {
[10:27:15.204]                             sendCondition <<- function(cond) {
[10:27:15.204]                               data <- list(type = "VALUE", value = cond, 
[10:27:15.204]                                 success = TRUE)
[10:27:15.204]                               parallel_sendData(master, data)
[10:27:15.204]                             }
[10:27:15.204]                             return(sendCondition)
[10:27:15.204]                           }
[10:27:15.204]                         }
[10:27:15.204]                         frame <- frame + 1L
[10:27:15.204]                         envir <- sys.frame(frame)
[10:27:15.204]                       }
[10:27:15.204]                     }
[10:27:15.204]                     sendCondition <<- function(cond) NULL
[10:27:15.204]                   }
[10:27:15.204]                 })
[10:27:15.204]                 withCallingHandlers({
[10:27:15.204]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:27:15.204]                 }, immediateCondition = function(cond) {
[10:27:15.204]                   sendCondition <- ...future.makeSendCondition()
[10:27:15.204]                   sendCondition(cond)
[10:27:15.204]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:15.204]                   {
[10:27:15.204]                     inherits <- base::inherits
[10:27:15.204]                     invokeRestart <- base::invokeRestart
[10:27:15.204]                     is.null <- base::is.null
[10:27:15.204]                     muffled <- FALSE
[10:27:15.204]                     if (inherits(cond, "message")) {
[10:27:15.204]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:15.204]                       if (muffled) 
[10:27:15.204]                         invokeRestart("muffleMessage")
[10:27:15.204]                     }
[10:27:15.204]                     else if (inherits(cond, "warning")) {
[10:27:15.204]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:15.204]                       if (muffled) 
[10:27:15.204]                         invokeRestart("muffleWarning")
[10:27:15.204]                     }
[10:27:15.204]                     else if (inherits(cond, "condition")) {
[10:27:15.204]                       if (!is.null(pattern)) {
[10:27:15.204]                         computeRestarts <- base::computeRestarts
[10:27:15.204]                         grepl <- base::grepl
[10:27:15.204]                         restarts <- computeRestarts(cond)
[10:27:15.204]                         for (restart in restarts) {
[10:27:15.204]                           name <- restart$name
[10:27:15.204]                           if (is.null(name)) 
[10:27:15.204]                             next
[10:27:15.204]                           if (!grepl(pattern, name)) 
[10:27:15.204]                             next
[10:27:15.204]                           invokeRestart(restart)
[10:27:15.204]                           muffled <- TRUE
[10:27:15.204]                           break
[10:27:15.204]                         }
[10:27:15.204]                       }
[10:27:15.204]                     }
[10:27:15.204]                     invisible(muffled)
[10:27:15.204]                   }
[10:27:15.204]                   muffleCondition(cond)
[10:27:15.204]                 })
[10:27:15.204]             }))
[10:27:15.204]             future::FutureResult(value = ...future.value$value, 
[10:27:15.204]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:15.204]                   ...future.rng), globalenv = if (FALSE) 
[10:27:15.204]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:15.204]                     ...future.globalenv.names))
[10:27:15.204]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:15.204]         }, condition = base::local({
[10:27:15.204]             c <- base::c
[10:27:15.204]             inherits <- base::inherits
[10:27:15.204]             invokeRestart <- base::invokeRestart
[10:27:15.204]             length <- base::length
[10:27:15.204]             list <- base::list
[10:27:15.204]             seq.int <- base::seq.int
[10:27:15.204]             signalCondition <- base::signalCondition
[10:27:15.204]             sys.calls <- base::sys.calls
[10:27:15.204]             `[[` <- base::`[[`
[10:27:15.204]             `+` <- base::`+`
[10:27:15.204]             `<<-` <- base::`<<-`
[10:27:15.204]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:15.204]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:15.204]                   3L)]
[10:27:15.204]             }
[10:27:15.204]             function(cond) {
[10:27:15.204]                 is_error <- inherits(cond, "error")
[10:27:15.204]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:15.204]                   NULL)
[10:27:15.204]                 if (is_error) {
[10:27:15.204]                   sessionInformation <- function() {
[10:27:15.204]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:15.204]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:15.204]                       search = base::search(), system = base::Sys.info())
[10:27:15.204]                   }
[10:27:15.204]                   ...future.conditions[[length(...future.conditions) + 
[10:27:15.204]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:15.204]                     cond$call), session = sessionInformation(), 
[10:27:15.204]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:15.204]                   signalCondition(cond)
[10:27:15.204]                 }
[10:27:15.204]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:15.204]                 "immediateCondition"))) {
[10:27:15.204]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:15.204]                   ...future.conditions[[length(...future.conditions) + 
[10:27:15.204]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:15.204]                   if (TRUE && !signal) {
[10:27:15.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:15.204]                     {
[10:27:15.204]                       inherits <- base::inherits
[10:27:15.204]                       invokeRestart <- base::invokeRestart
[10:27:15.204]                       is.null <- base::is.null
[10:27:15.204]                       muffled <- FALSE
[10:27:15.204]                       if (inherits(cond, "message")) {
[10:27:15.204]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:15.204]                         if (muffled) 
[10:27:15.204]                           invokeRestart("muffleMessage")
[10:27:15.204]                       }
[10:27:15.204]                       else if (inherits(cond, "warning")) {
[10:27:15.204]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:15.204]                         if (muffled) 
[10:27:15.204]                           invokeRestart("muffleWarning")
[10:27:15.204]                       }
[10:27:15.204]                       else if (inherits(cond, "condition")) {
[10:27:15.204]                         if (!is.null(pattern)) {
[10:27:15.204]                           computeRestarts <- base::computeRestarts
[10:27:15.204]                           grepl <- base::grepl
[10:27:15.204]                           restarts <- computeRestarts(cond)
[10:27:15.204]                           for (restart in restarts) {
[10:27:15.204]                             name <- restart$name
[10:27:15.204]                             if (is.null(name)) 
[10:27:15.204]                               next
[10:27:15.204]                             if (!grepl(pattern, name)) 
[10:27:15.204]                               next
[10:27:15.204]                             invokeRestart(restart)
[10:27:15.204]                             muffled <- TRUE
[10:27:15.204]                             break
[10:27:15.204]                           }
[10:27:15.204]                         }
[10:27:15.204]                       }
[10:27:15.204]                       invisible(muffled)
[10:27:15.204]                     }
[10:27:15.204]                     muffleCondition(cond, pattern = "^muffle")
[10:27:15.204]                   }
[10:27:15.204]                 }
[10:27:15.204]                 else {
[10:27:15.204]                   if (TRUE) {
[10:27:15.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:15.204]                     {
[10:27:15.204]                       inherits <- base::inherits
[10:27:15.204]                       invokeRestart <- base::invokeRestart
[10:27:15.204]                       is.null <- base::is.null
[10:27:15.204]                       muffled <- FALSE
[10:27:15.204]                       if (inherits(cond, "message")) {
[10:27:15.204]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:15.204]                         if (muffled) 
[10:27:15.204]                           invokeRestart("muffleMessage")
[10:27:15.204]                       }
[10:27:15.204]                       else if (inherits(cond, "warning")) {
[10:27:15.204]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:15.204]                         if (muffled) 
[10:27:15.204]                           invokeRestart("muffleWarning")
[10:27:15.204]                       }
[10:27:15.204]                       else if (inherits(cond, "condition")) {
[10:27:15.204]                         if (!is.null(pattern)) {
[10:27:15.204]                           computeRestarts <- base::computeRestarts
[10:27:15.204]                           grepl <- base::grepl
[10:27:15.204]                           restarts <- computeRestarts(cond)
[10:27:15.204]                           for (restart in restarts) {
[10:27:15.204]                             name <- restart$name
[10:27:15.204]                             if (is.null(name)) 
[10:27:15.204]                               next
[10:27:15.204]                             if (!grepl(pattern, name)) 
[10:27:15.204]                               next
[10:27:15.204]                             invokeRestart(restart)
[10:27:15.204]                             muffled <- TRUE
[10:27:15.204]                             break
[10:27:15.204]                           }
[10:27:15.204]                         }
[10:27:15.204]                       }
[10:27:15.204]                       invisible(muffled)
[10:27:15.204]                     }
[10:27:15.204]                     muffleCondition(cond, pattern = "^muffle")
[10:27:15.204]                   }
[10:27:15.204]                 }
[10:27:15.204]             }
[10:27:15.204]         }))
[10:27:15.204]     }, error = function(ex) {
[10:27:15.204]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:15.204]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:15.204]                 ...future.rng), started = ...future.startTime, 
[10:27:15.204]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:15.204]             version = "1.8"), class = "FutureResult")
[10:27:15.204]     }, finally = {
[10:27:15.204]         if (!identical(...future.workdir, getwd())) 
[10:27:15.204]             setwd(...future.workdir)
[10:27:15.204]         {
[10:27:15.204]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:15.204]                 ...future.oldOptions$nwarnings <- NULL
[10:27:15.204]             }
[10:27:15.204]             base::options(...future.oldOptions)
[10:27:15.204]             if (.Platform$OS.type == "windows") {
[10:27:15.204]                 old_names <- names(...future.oldEnvVars)
[10:27:15.204]                 envs <- base::Sys.getenv()
[10:27:15.204]                 names <- names(envs)
[10:27:15.204]                 common <- intersect(names, old_names)
[10:27:15.204]                 added <- setdiff(names, old_names)
[10:27:15.204]                 removed <- setdiff(old_names, names)
[10:27:15.204]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:15.204]                   envs[common]]
[10:27:15.204]                 NAMES <- toupper(changed)
[10:27:15.204]                 args <- list()
[10:27:15.204]                 for (kk in seq_along(NAMES)) {
[10:27:15.204]                   name <- changed[[kk]]
[10:27:15.204]                   NAME <- NAMES[[kk]]
[10:27:15.204]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:15.204]                     next
[10:27:15.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:15.204]                 }
[10:27:15.204]                 NAMES <- toupper(added)
[10:27:15.204]                 for (kk in seq_along(NAMES)) {
[10:27:15.204]                   name <- added[[kk]]
[10:27:15.204]                   NAME <- NAMES[[kk]]
[10:27:15.204]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:15.204]                     next
[10:27:15.204]                   args[[name]] <- ""
[10:27:15.204]                 }
[10:27:15.204]                 NAMES <- toupper(removed)
[10:27:15.204]                 for (kk in seq_along(NAMES)) {
[10:27:15.204]                   name <- removed[[kk]]
[10:27:15.204]                   NAME <- NAMES[[kk]]
[10:27:15.204]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:15.204]                     next
[10:27:15.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:15.204]                 }
[10:27:15.204]                 if (length(args) > 0) 
[10:27:15.204]                   base::do.call(base::Sys.setenv, args = args)
[10:27:15.204]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:15.204]             }
[10:27:15.204]             else {
[10:27:15.204]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:15.204]             }
[10:27:15.204]             {
[10:27:15.204]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:15.204]                   0L) {
[10:27:15.204]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:15.204]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:15.204]                   base::options(opts)
[10:27:15.204]                 }
[10:27:15.204]                 {
[10:27:15.204]                   {
[10:27:15.204]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:15.204]                     NULL
[10:27:15.204]                   }
[10:27:15.204]                   options(future.plan = NULL)
[10:27:15.204]                   if (is.na(NA_character_)) 
[10:27:15.204]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:15.204]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:15.204]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:15.204]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:15.204]                     envir = parent.frame()) 
[10:27:15.204]                   {
[10:27:15.204]                     if (is.function(workers)) 
[10:27:15.204]                       workers <- workers()
[10:27:15.204]                     workers <- structure(as.integer(workers), 
[10:27:15.204]                       class = class(workers))
[10:27:15.204]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:15.204]                       workers >= 1)
[10:27:15.204]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:15.204]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:15.204]                     }
[10:27:15.204]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:15.204]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:15.204]                       envir = envir)
[10:27:15.204]                     if (!future$lazy) 
[10:27:15.204]                       future <- run(future)
[10:27:15.204]                     invisible(future)
[10:27:15.204]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:15.204]                 }
[10:27:15.204]             }
[10:27:15.204]         }
[10:27:15.204]     })
[10:27:15.204]     if (TRUE) {
[10:27:15.204]         base::sink(type = "output", split = FALSE)
[10:27:15.204]         if (TRUE) {
[10:27:15.204]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:15.204]         }
[10:27:15.204]         else {
[10:27:15.204]             ...future.result["stdout"] <- base::list(NULL)
[10:27:15.204]         }
[10:27:15.204]         base::close(...future.stdout)
[10:27:15.204]         ...future.stdout <- NULL
[10:27:15.204]     }
[10:27:15.204]     ...future.result$conditions <- ...future.conditions
[10:27:15.204]     ...future.result$finished <- base::Sys.time()
[10:27:15.204]     ...future.result
[10:27:15.204] }
[10:27:15.207] MultisessionFuture started
[10:27:15.208] - Launch lazy future ... done
[10:27:15.208] run() for ‘MultisessionFuture’ ... done
[10:27:15.254] receiveMessageFromWorker() for ClusterFuture ...
[10:27:15.254] - Validating connection of MultisessionFuture
[10:27:15.255] - received message: FutureResult
[10:27:15.255] - Received FutureResult
[10:27:15.255] - Erased future from FutureRegistry
[10:27:15.255] result() for ClusterFuture ...
[10:27:15.255] - result already collected: FutureResult
[10:27:15.255] result() for ClusterFuture ... done
[10:27:15.255] signalConditions() ...
[10:27:15.256]  - include = ‘immediateCondition’
[10:27:15.256]  - exclude = 
[10:27:15.256]  - resignal = FALSE
[10:27:15.256]  - Number of conditions: 1
[10:27:15.256] signalConditions() ... done
[10:27:15.256] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:15.256] A MultisessionFuture was resolved
- result = TRUE, recursive = TRUE ... DONE
- result = TRUE, recursive = -1 ...
[10:27:15.256] getGlobalsAndPackages() ...
[10:27:15.257] Searching for globals...
[10:27:15.258] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:27:15.258] Searching for globals ... DONE
[10:27:15.258] Resolving globals: FALSE
[10:27:15.258] 
[10:27:15.258] 
[10:27:15.258] getGlobalsAndPackages() ... DONE
[10:27:15.259] run() for ‘Future’ ...
[10:27:15.259] - state: ‘created’
[10:27:15.259] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:15.273] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:15.273] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:15.273]   - Field: ‘node’
[10:27:15.273]   - Field: ‘label’
[10:27:15.273]   - Field: ‘local’
[10:27:15.273]   - Field: ‘owner’
[10:27:15.273]   - Field: ‘envir’
[10:27:15.273]   - Field: ‘workers’
[10:27:15.274]   - Field: ‘packages’
[10:27:15.274]   - Field: ‘gc’
[10:27:15.274]   - Field: ‘conditions’
[10:27:15.274]   - Field: ‘persistent’
[10:27:15.274]   - Field: ‘expr’
[10:27:15.274]   - Field: ‘uuid’
[10:27:15.274]   - Field: ‘seed’
[10:27:15.274]   - Field: ‘version’
[10:27:15.274]   - Field: ‘result’
[10:27:15.274]   - Field: ‘asynchronous’
[10:27:15.275]   - Field: ‘calls’
[10:27:15.275]   - Field: ‘globals’
[10:27:15.275]   - Field: ‘stdout’
[10:27:15.275]   - Field: ‘earlySignal’
[10:27:15.275]   - Field: ‘lazy’
[10:27:15.275]   - Field: ‘state’
[10:27:15.275] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:15.275] - Launch lazy future ...
[10:27:15.275] Packages needed by the future expression (n = 0): <none>
[10:27:15.276] Packages needed by future strategies (n = 0): <none>
[10:27:15.276] {
[10:27:15.276]     {
[10:27:15.276]         {
[10:27:15.276]             ...future.startTime <- base::Sys.time()
[10:27:15.276]             {
[10:27:15.276]                 {
[10:27:15.276]                   {
[10:27:15.276]                     {
[10:27:15.276]                       base::local({
[10:27:15.276]                         has_future <- base::requireNamespace("future", 
[10:27:15.276]                           quietly = TRUE)
[10:27:15.276]                         if (has_future) {
[10:27:15.276]                           ns <- base::getNamespace("future")
[10:27:15.276]                           version <- ns[[".package"]][["version"]]
[10:27:15.276]                           if (is.null(version)) 
[10:27:15.276]                             version <- utils::packageVersion("future")
[10:27:15.276]                         }
[10:27:15.276]                         else {
[10:27:15.276]                           version <- NULL
[10:27:15.276]                         }
[10:27:15.276]                         if (!has_future || version < "1.8.0") {
[10:27:15.276]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:15.276]                             "", base::R.version$version.string), 
[10:27:15.276]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:15.276]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:15.276]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:15.276]                               "release", "version")], collapse = " "), 
[10:27:15.276]                             hostname = base::Sys.info()[["nodename"]])
[10:27:15.276]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:15.276]                             info)
[10:27:15.276]                           info <- base::paste(info, collapse = "; ")
[10:27:15.276]                           if (!has_future) {
[10:27:15.276]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:15.276]                               info)
[10:27:15.276]                           }
[10:27:15.276]                           else {
[10:27:15.276]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:15.276]                               info, version)
[10:27:15.276]                           }
[10:27:15.276]                           base::stop(msg)
[10:27:15.276]                         }
[10:27:15.276]                       })
[10:27:15.276]                     }
[10:27:15.276]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:15.276]                     base::options(mc.cores = 1L)
[10:27:15.276]                   }
[10:27:15.276]                   options(future.plan = NULL)
[10:27:15.276]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:15.276]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:15.276]                 }
[10:27:15.276]                 ...future.workdir <- getwd()
[10:27:15.276]             }
[10:27:15.276]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:15.276]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:15.276]         }
[10:27:15.276]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:15.276]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:15.276]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:15.276]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:15.276]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:15.276]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:15.276]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:15.276]             base::names(...future.oldOptions))
[10:27:15.276]     }
[10:27:15.276]     if (FALSE) {
[10:27:15.276]     }
[10:27:15.276]     else {
[10:27:15.276]         if (TRUE) {
[10:27:15.276]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:15.276]                 open = "w")
[10:27:15.276]         }
[10:27:15.276]         else {
[10:27:15.276]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:15.276]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:15.276]         }
[10:27:15.276]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:15.276]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:15.276]             base::sink(type = "output", split = FALSE)
[10:27:15.276]             base::close(...future.stdout)
[10:27:15.276]         }, add = TRUE)
[10:27:15.276]     }
[10:27:15.276]     ...future.frame <- base::sys.nframe()
[10:27:15.276]     ...future.conditions <- base::list()
[10:27:15.276]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:15.276]     if (FALSE) {
[10:27:15.276]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:15.276]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:15.276]     }
[10:27:15.276]     ...future.result <- base::tryCatch({
[10:27:15.276]         base::withCallingHandlers({
[10:27:15.276]             ...future.value <- base::withVisible(base::local({
[10:27:15.276]                 ...future.makeSendCondition <- base::local({
[10:27:15.276]                   sendCondition <- NULL
[10:27:15.276]                   function(frame = 1L) {
[10:27:15.276]                     if (is.function(sendCondition)) 
[10:27:15.276]                       return(sendCondition)
[10:27:15.276]                     ns <- getNamespace("parallel")
[10:27:15.276]                     if (exists("sendData", mode = "function", 
[10:27:15.276]                       envir = ns)) {
[10:27:15.276]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:15.276]                         envir = ns)
[10:27:15.276]                       envir <- sys.frame(frame)
[10:27:15.276]                       master <- NULL
[10:27:15.276]                       while (!identical(envir, .GlobalEnv) && 
[10:27:15.276]                         !identical(envir, emptyenv())) {
[10:27:15.276]                         if (exists("master", mode = "list", envir = envir, 
[10:27:15.276]                           inherits = FALSE)) {
[10:27:15.276]                           master <- get("master", mode = "list", 
[10:27:15.276]                             envir = envir, inherits = FALSE)
[10:27:15.276]                           if (inherits(master, c("SOCKnode", 
[10:27:15.276]                             "SOCK0node"))) {
[10:27:15.276]                             sendCondition <<- function(cond) {
[10:27:15.276]                               data <- list(type = "VALUE", value = cond, 
[10:27:15.276]                                 success = TRUE)
[10:27:15.276]                               parallel_sendData(master, data)
[10:27:15.276]                             }
[10:27:15.276]                             return(sendCondition)
[10:27:15.276]                           }
[10:27:15.276]                         }
[10:27:15.276]                         frame <- frame + 1L
[10:27:15.276]                         envir <- sys.frame(frame)
[10:27:15.276]                       }
[10:27:15.276]                     }
[10:27:15.276]                     sendCondition <<- function(cond) NULL
[10:27:15.276]                   }
[10:27:15.276]                 })
[10:27:15.276]                 withCallingHandlers({
[10:27:15.276]                   {
[10:27:15.276]                     Sys.sleep(0.5)
[10:27:15.276]                     list(a = 1, b = 42L)
[10:27:15.276]                   }
[10:27:15.276]                 }, immediateCondition = function(cond) {
[10:27:15.276]                   sendCondition <- ...future.makeSendCondition()
[10:27:15.276]                   sendCondition(cond)
[10:27:15.276]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:15.276]                   {
[10:27:15.276]                     inherits <- base::inherits
[10:27:15.276]                     invokeRestart <- base::invokeRestart
[10:27:15.276]                     is.null <- base::is.null
[10:27:15.276]                     muffled <- FALSE
[10:27:15.276]                     if (inherits(cond, "message")) {
[10:27:15.276]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:15.276]                       if (muffled) 
[10:27:15.276]                         invokeRestart("muffleMessage")
[10:27:15.276]                     }
[10:27:15.276]                     else if (inherits(cond, "warning")) {
[10:27:15.276]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:15.276]                       if (muffled) 
[10:27:15.276]                         invokeRestart("muffleWarning")
[10:27:15.276]                     }
[10:27:15.276]                     else if (inherits(cond, "condition")) {
[10:27:15.276]                       if (!is.null(pattern)) {
[10:27:15.276]                         computeRestarts <- base::computeRestarts
[10:27:15.276]                         grepl <- base::grepl
[10:27:15.276]                         restarts <- computeRestarts(cond)
[10:27:15.276]                         for (restart in restarts) {
[10:27:15.276]                           name <- restart$name
[10:27:15.276]                           if (is.null(name)) 
[10:27:15.276]                             next
[10:27:15.276]                           if (!grepl(pattern, name)) 
[10:27:15.276]                             next
[10:27:15.276]                           invokeRestart(restart)
[10:27:15.276]                           muffled <- TRUE
[10:27:15.276]                           break
[10:27:15.276]                         }
[10:27:15.276]                       }
[10:27:15.276]                     }
[10:27:15.276]                     invisible(muffled)
[10:27:15.276]                   }
[10:27:15.276]                   muffleCondition(cond)
[10:27:15.276]                 })
[10:27:15.276]             }))
[10:27:15.276]             future::FutureResult(value = ...future.value$value, 
[10:27:15.276]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:15.276]                   ...future.rng), globalenv = if (FALSE) 
[10:27:15.276]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:15.276]                     ...future.globalenv.names))
[10:27:15.276]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:15.276]         }, condition = base::local({
[10:27:15.276]             c <- base::c
[10:27:15.276]             inherits <- base::inherits
[10:27:15.276]             invokeRestart <- base::invokeRestart
[10:27:15.276]             length <- base::length
[10:27:15.276]             list <- base::list
[10:27:15.276]             seq.int <- base::seq.int
[10:27:15.276]             signalCondition <- base::signalCondition
[10:27:15.276]             sys.calls <- base::sys.calls
[10:27:15.276]             `[[` <- base::`[[`
[10:27:15.276]             `+` <- base::`+`
[10:27:15.276]             `<<-` <- base::`<<-`
[10:27:15.276]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:15.276]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:15.276]                   3L)]
[10:27:15.276]             }
[10:27:15.276]             function(cond) {
[10:27:15.276]                 is_error <- inherits(cond, "error")
[10:27:15.276]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:15.276]                   NULL)
[10:27:15.276]                 if (is_error) {
[10:27:15.276]                   sessionInformation <- function() {
[10:27:15.276]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:15.276]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:15.276]                       search = base::search(), system = base::Sys.info())
[10:27:15.276]                   }
[10:27:15.276]                   ...future.conditions[[length(...future.conditions) + 
[10:27:15.276]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:15.276]                     cond$call), session = sessionInformation(), 
[10:27:15.276]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:15.276]                   signalCondition(cond)
[10:27:15.276]                 }
[10:27:15.276]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:15.276]                 "immediateCondition"))) {
[10:27:15.276]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:15.276]                   ...future.conditions[[length(...future.conditions) + 
[10:27:15.276]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:15.276]                   if (TRUE && !signal) {
[10:27:15.276]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:15.276]                     {
[10:27:15.276]                       inherits <- base::inherits
[10:27:15.276]                       invokeRestart <- base::invokeRestart
[10:27:15.276]                       is.null <- base::is.null
[10:27:15.276]                       muffled <- FALSE
[10:27:15.276]                       if (inherits(cond, "message")) {
[10:27:15.276]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:15.276]                         if (muffled) 
[10:27:15.276]                           invokeRestart("muffleMessage")
[10:27:15.276]                       }
[10:27:15.276]                       else if (inherits(cond, "warning")) {
[10:27:15.276]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:15.276]                         if (muffled) 
[10:27:15.276]                           invokeRestart("muffleWarning")
[10:27:15.276]                       }
[10:27:15.276]                       else if (inherits(cond, "condition")) {
[10:27:15.276]                         if (!is.null(pattern)) {
[10:27:15.276]                           computeRestarts <- base::computeRestarts
[10:27:15.276]                           grepl <- base::grepl
[10:27:15.276]                           restarts <- computeRestarts(cond)
[10:27:15.276]                           for (restart in restarts) {
[10:27:15.276]                             name <- restart$name
[10:27:15.276]                             if (is.null(name)) 
[10:27:15.276]                               next
[10:27:15.276]                             if (!grepl(pattern, name)) 
[10:27:15.276]                               next
[10:27:15.276]                             invokeRestart(restart)
[10:27:15.276]                             muffled <- TRUE
[10:27:15.276]                             break
[10:27:15.276]                           }
[10:27:15.276]                         }
[10:27:15.276]                       }
[10:27:15.276]                       invisible(muffled)
[10:27:15.276]                     }
[10:27:15.276]                     muffleCondition(cond, pattern = "^muffle")
[10:27:15.276]                   }
[10:27:15.276]                 }
[10:27:15.276]                 else {
[10:27:15.276]                   if (TRUE) {
[10:27:15.276]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:15.276]                     {
[10:27:15.276]                       inherits <- base::inherits
[10:27:15.276]                       invokeRestart <- base::invokeRestart
[10:27:15.276]                       is.null <- base::is.null
[10:27:15.276]                       muffled <- FALSE
[10:27:15.276]                       if (inherits(cond, "message")) {
[10:27:15.276]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:15.276]                         if (muffled) 
[10:27:15.276]                           invokeRestart("muffleMessage")
[10:27:15.276]                       }
[10:27:15.276]                       else if (inherits(cond, "warning")) {
[10:27:15.276]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:15.276]                         if (muffled) 
[10:27:15.276]                           invokeRestart("muffleWarning")
[10:27:15.276]                       }
[10:27:15.276]                       else if (inherits(cond, "condition")) {
[10:27:15.276]                         if (!is.null(pattern)) {
[10:27:15.276]                           computeRestarts <- base::computeRestarts
[10:27:15.276]                           grepl <- base::grepl
[10:27:15.276]                           restarts <- computeRestarts(cond)
[10:27:15.276]                           for (restart in restarts) {
[10:27:15.276]                             name <- restart$name
[10:27:15.276]                             if (is.null(name)) 
[10:27:15.276]                               next
[10:27:15.276]                             if (!grepl(pattern, name)) 
[10:27:15.276]                               next
[10:27:15.276]                             invokeRestart(restart)
[10:27:15.276]                             muffled <- TRUE
[10:27:15.276]                             break
[10:27:15.276]                           }
[10:27:15.276]                         }
[10:27:15.276]                       }
[10:27:15.276]                       invisible(muffled)
[10:27:15.276]                     }
[10:27:15.276]                     muffleCondition(cond, pattern = "^muffle")
[10:27:15.276]                   }
[10:27:15.276]                 }
[10:27:15.276]             }
[10:27:15.276]         }))
[10:27:15.276]     }, error = function(ex) {
[10:27:15.276]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:15.276]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:15.276]                 ...future.rng), started = ...future.startTime, 
[10:27:15.276]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:15.276]             version = "1.8"), class = "FutureResult")
[10:27:15.276]     }, finally = {
[10:27:15.276]         if (!identical(...future.workdir, getwd())) 
[10:27:15.276]             setwd(...future.workdir)
[10:27:15.276]         {
[10:27:15.276]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:15.276]                 ...future.oldOptions$nwarnings <- NULL
[10:27:15.276]             }
[10:27:15.276]             base::options(...future.oldOptions)
[10:27:15.276]             if (.Platform$OS.type == "windows") {
[10:27:15.276]                 old_names <- names(...future.oldEnvVars)
[10:27:15.276]                 envs <- base::Sys.getenv()
[10:27:15.276]                 names <- names(envs)
[10:27:15.276]                 common <- intersect(names, old_names)
[10:27:15.276]                 added <- setdiff(names, old_names)
[10:27:15.276]                 removed <- setdiff(old_names, names)
[10:27:15.276]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:15.276]                   envs[common]]
[10:27:15.276]                 NAMES <- toupper(changed)
[10:27:15.276]                 args <- list()
[10:27:15.276]                 for (kk in seq_along(NAMES)) {
[10:27:15.276]                   name <- changed[[kk]]
[10:27:15.276]                   NAME <- NAMES[[kk]]
[10:27:15.276]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:15.276]                     next
[10:27:15.276]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:15.276]                 }
[10:27:15.276]                 NAMES <- toupper(added)
[10:27:15.276]                 for (kk in seq_along(NAMES)) {
[10:27:15.276]                   name <- added[[kk]]
[10:27:15.276]                   NAME <- NAMES[[kk]]
[10:27:15.276]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:15.276]                     next
[10:27:15.276]                   args[[name]] <- ""
[10:27:15.276]                 }
[10:27:15.276]                 NAMES <- toupper(removed)
[10:27:15.276]                 for (kk in seq_along(NAMES)) {
[10:27:15.276]                   name <- removed[[kk]]
[10:27:15.276]                   NAME <- NAMES[[kk]]
[10:27:15.276]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:15.276]                     next
[10:27:15.276]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:15.276]                 }
[10:27:15.276]                 if (length(args) > 0) 
[10:27:15.276]                   base::do.call(base::Sys.setenv, args = args)
[10:27:15.276]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:15.276]             }
[10:27:15.276]             else {
[10:27:15.276]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:15.276]             }
[10:27:15.276]             {
[10:27:15.276]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:15.276]                   0L) {
[10:27:15.276]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:15.276]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:15.276]                   base::options(opts)
[10:27:15.276]                 }
[10:27:15.276]                 {
[10:27:15.276]                   {
[10:27:15.276]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:15.276]                     NULL
[10:27:15.276]                   }
[10:27:15.276]                   options(future.plan = NULL)
[10:27:15.276]                   if (is.na(NA_character_)) 
[10:27:15.276]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:15.276]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:15.276]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:15.276]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:15.276]                     envir = parent.frame()) 
[10:27:15.276]                   {
[10:27:15.276]                     if (is.function(workers)) 
[10:27:15.276]                       workers <- workers()
[10:27:15.276]                     workers <- structure(as.integer(workers), 
[10:27:15.276]                       class = class(workers))
[10:27:15.276]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:15.276]                       workers >= 1)
[10:27:15.276]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:15.276]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:15.276]                     }
[10:27:15.276]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:15.276]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:15.276]                       envir = envir)
[10:27:15.276]                     if (!future$lazy) 
[10:27:15.276]                       future <- run(future)
[10:27:15.276]                     invisible(future)
[10:27:15.276]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:15.276]                 }
[10:27:15.276]             }
[10:27:15.276]         }
[10:27:15.276]     })
[10:27:15.276]     if (TRUE) {
[10:27:15.276]         base::sink(type = "output", split = FALSE)
[10:27:15.276]         if (TRUE) {
[10:27:15.276]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:15.276]         }
[10:27:15.276]         else {
[10:27:15.276]             ...future.result["stdout"] <- base::list(NULL)
[10:27:15.276]         }
[10:27:15.276]         base::close(...future.stdout)
[10:27:15.276]         ...future.stdout <- NULL
[10:27:15.276]     }
[10:27:15.276]     ...future.result$conditions <- ...future.conditions
[10:27:15.276]     ...future.result$finished <- base::Sys.time()
[10:27:15.276]     ...future.result
[10:27:15.276] }
[10:27:15.279] MultisessionFuture started
[10:27:15.279] - Launch lazy future ... done
[10:27:15.279] run() for ‘MultisessionFuture’ ... done
[10:27:15.280] getGlobalsAndPackages() ...
[10:27:15.280] Searching for globals...
[10:27:15.281] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:27:15.281] Searching for globals ... DONE
[10:27:15.281] Resolving globals: FALSE
[10:27:15.281] 
[10:27:15.281] 
[10:27:15.281] getGlobalsAndPackages() ... DONE
- w/ exception ...
[10:27:15.282] getGlobalsAndPackages() ...
[10:27:15.282] Searching for globals...
[10:27:15.282] - globals found: [2] ‘list’, ‘stop’
[10:27:15.283] Searching for globals ... DONE
[10:27:15.283] Resolving globals: FALSE
[10:27:15.283] 
[10:27:15.283] 
[10:27:15.283] getGlobalsAndPackages() ... DONE
[10:27:15.283] run() for ‘Future’ ...
[10:27:15.283] - state: ‘created’
[10:27:15.284] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:15.297] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:15.297] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:15.298]   - Field: ‘node’
[10:27:15.298]   - Field: ‘label’
[10:27:15.298]   - Field: ‘local’
[10:27:15.298]   - Field: ‘owner’
[10:27:15.298]   - Field: ‘envir’
[10:27:15.298]   - Field: ‘workers’
[10:27:15.298]   - Field: ‘packages’
[10:27:15.298]   - Field: ‘gc’
[10:27:15.298]   - Field: ‘conditions’
[10:27:15.298]   - Field: ‘persistent’
[10:27:15.298]   - Field: ‘expr’
[10:27:15.299]   - Field: ‘uuid’
[10:27:15.299]   - Field: ‘seed’
[10:27:15.299]   - Field: ‘version’
[10:27:15.299]   - Field: ‘result’
[10:27:15.299]   - Field: ‘asynchronous’
[10:27:15.299]   - Field: ‘calls’
[10:27:15.299]   - Field: ‘globals’
[10:27:15.299]   - Field: ‘stdout’
[10:27:15.299]   - Field: ‘earlySignal’
[10:27:15.299]   - Field: ‘lazy’
[10:27:15.299]   - Field: ‘state’
[10:27:15.300] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:15.300] - Launch lazy future ...
[10:27:15.300] Packages needed by the future expression (n = 0): <none>
[10:27:15.300] Packages needed by future strategies (n = 0): <none>
[10:27:15.300] {
[10:27:15.300]     {
[10:27:15.300]         {
[10:27:15.300]             ...future.startTime <- base::Sys.time()
[10:27:15.300]             {
[10:27:15.300]                 {
[10:27:15.300]                   {
[10:27:15.300]                     {
[10:27:15.300]                       base::local({
[10:27:15.300]                         has_future <- base::requireNamespace("future", 
[10:27:15.300]                           quietly = TRUE)
[10:27:15.300]                         if (has_future) {
[10:27:15.300]                           ns <- base::getNamespace("future")
[10:27:15.300]                           version <- ns[[".package"]][["version"]]
[10:27:15.300]                           if (is.null(version)) 
[10:27:15.300]                             version <- utils::packageVersion("future")
[10:27:15.300]                         }
[10:27:15.300]                         else {
[10:27:15.300]                           version <- NULL
[10:27:15.300]                         }
[10:27:15.300]                         if (!has_future || version < "1.8.0") {
[10:27:15.300]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:15.300]                             "", base::R.version$version.string), 
[10:27:15.300]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:15.300]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:15.300]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:15.300]                               "release", "version")], collapse = " "), 
[10:27:15.300]                             hostname = base::Sys.info()[["nodename"]])
[10:27:15.300]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:15.300]                             info)
[10:27:15.300]                           info <- base::paste(info, collapse = "; ")
[10:27:15.300]                           if (!has_future) {
[10:27:15.300]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:15.300]                               info)
[10:27:15.300]                           }
[10:27:15.300]                           else {
[10:27:15.300]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:15.300]                               info, version)
[10:27:15.300]                           }
[10:27:15.300]                           base::stop(msg)
[10:27:15.300]                         }
[10:27:15.300]                       })
[10:27:15.300]                     }
[10:27:15.300]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:15.300]                     base::options(mc.cores = 1L)
[10:27:15.300]                   }
[10:27:15.300]                   options(future.plan = NULL)
[10:27:15.300]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:15.300]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:15.300]                 }
[10:27:15.300]                 ...future.workdir <- getwd()
[10:27:15.300]             }
[10:27:15.300]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:15.300]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:15.300]         }
[10:27:15.300]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:15.300]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:15.300]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:15.300]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:15.300]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:15.300]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:15.300]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:15.300]             base::names(...future.oldOptions))
[10:27:15.300]     }
[10:27:15.300]     if (FALSE) {
[10:27:15.300]     }
[10:27:15.300]     else {
[10:27:15.300]         if (TRUE) {
[10:27:15.300]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:15.300]                 open = "w")
[10:27:15.300]         }
[10:27:15.300]         else {
[10:27:15.300]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:15.300]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:15.300]         }
[10:27:15.300]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:15.300]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:15.300]             base::sink(type = "output", split = FALSE)
[10:27:15.300]             base::close(...future.stdout)
[10:27:15.300]         }, add = TRUE)
[10:27:15.300]     }
[10:27:15.300]     ...future.frame <- base::sys.nframe()
[10:27:15.300]     ...future.conditions <- base::list()
[10:27:15.300]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:15.300]     if (FALSE) {
[10:27:15.300]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:15.300]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:15.300]     }
[10:27:15.300]     ...future.result <- base::tryCatch({
[10:27:15.300]         base::withCallingHandlers({
[10:27:15.300]             ...future.value <- base::withVisible(base::local({
[10:27:15.300]                 ...future.makeSendCondition <- base::local({
[10:27:15.300]                   sendCondition <- NULL
[10:27:15.300]                   function(frame = 1L) {
[10:27:15.300]                     if (is.function(sendCondition)) 
[10:27:15.300]                       return(sendCondition)
[10:27:15.300]                     ns <- getNamespace("parallel")
[10:27:15.300]                     if (exists("sendData", mode = "function", 
[10:27:15.300]                       envir = ns)) {
[10:27:15.300]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:15.300]                         envir = ns)
[10:27:15.300]                       envir <- sys.frame(frame)
[10:27:15.300]                       master <- NULL
[10:27:15.300]                       while (!identical(envir, .GlobalEnv) && 
[10:27:15.300]                         !identical(envir, emptyenv())) {
[10:27:15.300]                         if (exists("master", mode = "list", envir = envir, 
[10:27:15.300]                           inherits = FALSE)) {
[10:27:15.300]                           master <- get("master", mode = "list", 
[10:27:15.300]                             envir = envir, inherits = FALSE)
[10:27:15.300]                           if (inherits(master, c("SOCKnode", 
[10:27:15.300]                             "SOCK0node"))) {
[10:27:15.300]                             sendCondition <<- function(cond) {
[10:27:15.300]                               data <- list(type = "VALUE", value = cond, 
[10:27:15.300]                                 success = TRUE)
[10:27:15.300]                               parallel_sendData(master, data)
[10:27:15.300]                             }
[10:27:15.300]                             return(sendCondition)
[10:27:15.300]                           }
[10:27:15.300]                         }
[10:27:15.300]                         frame <- frame + 1L
[10:27:15.300]                         envir <- sys.frame(frame)
[10:27:15.300]                       }
[10:27:15.300]                     }
[10:27:15.300]                     sendCondition <<- function(cond) NULL
[10:27:15.300]                   }
[10:27:15.300]                 })
[10:27:15.300]                 withCallingHandlers({
[10:27:15.300]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:27:15.300]                 }, immediateCondition = function(cond) {
[10:27:15.300]                   sendCondition <- ...future.makeSendCondition()
[10:27:15.300]                   sendCondition(cond)
[10:27:15.300]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:15.300]                   {
[10:27:15.300]                     inherits <- base::inherits
[10:27:15.300]                     invokeRestart <- base::invokeRestart
[10:27:15.300]                     is.null <- base::is.null
[10:27:15.300]                     muffled <- FALSE
[10:27:15.300]                     if (inherits(cond, "message")) {
[10:27:15.300]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:15.300]                       if (muffled) 
[10:27:15.300]                         invokeRestart("muffleMessage")
[10:27:15.300]                     }
[10:27:15.300]                     else if (inherits(cond, "warning")) {
[10:27:15.300]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:15.300]                       if (muffled) 
[10:27:15.300]                         invokeRestart("muffleWarning")
[10:27:15.300]                     }
[10:27:15.300]                     else if (inherits(cond, "condition")) {
[10:27:15.300]                       if (!is.null(pattern)) {
[10:27:15.300]                         computeRestarts <- base::computeRestarts
[10:27:15.300]                         grepl <- base::grepl
[10:27:15.300]                         restarts <- computeRestarts(cond)
[10:27:15.300]                         for (restart in restarts) {
[10:27:15.300]                           name <- restart$name
[10:27:15.300]                           if (is.null(name)) 
[10:27:15.300]                             next
[10:27:15.300]                           if (!grepl(pattern, name)) 
[10:27:15.300]                             next
[10:27:15.300]                           invokeRestart(restart)
[10:27:15.300]                           muffled <- TRUE
[10:27:15.300]                           break
[10:27:15.300]                         }
[10:27:15.300]                       }
[10:27:15.300]                     }
[10:27:15.300]                     invisible(muffled)
[10:27:15.300]                   }
[10:27:15.300]                   muffleCondition(cond)
[10:27:15.300]                 })
[10:27:15.300]             }))
[10:27:15.300]             future::FutureResult(value = ...future.value$value, 
[10:27:15.300]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:15.300]                   ...future.rng), globalenv = if (FALSE) 
[10:27:15.300]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:15.300]                     ...future.globalenv.names))
[10:27:15.300]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:15.300]         }, condition = base::local({
[10:27:15.300]             c <- base::c
[10:27:15.300]             inherits <- base::inherits
[10:27:15.300]             invokeRestart <- base::invokeRestart
[10:27:15.300]             length <- base::length
[10:27:15.300]             list <- base::list
[10:27:15.300]             seq.int <- base::seq.int
[10:27:15.300]             signalCondition <- base::signalCondition
[10:27:15.300]             sys.calls <- base::sys.calls
[10:27:15.300]             `[[` <- base::`[[`
[10:27:15.300]             `+` <- base::`+`
[10:27:15.300]             `<<-` <- base::`<<-`
[10:27:15.300]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:15.300]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:15.300]                   3L)]
[10:27:15.300]             }
[10:27:15.300]             function(cond) {
[10:27:15.300]                 is_error <- inherits(cond, "error")
[10:27:15.300]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:15.300]                   NULL)
[10:27:15.300]                 if (is_error) {
[10:27:15.300]                   sessionInformation <- function() {
[10:27:15.300]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:15.300]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:15.300]                       search = base::search(), system = base::Sys.info())
[10:27:15.300]                   }
[10:27:15.300]                   ...future.conditions[[length(...future.conditions) + 
[10:27:15.300]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:15.300]                     cond$call), session = sessionInformation(), 
[10:27:15.300]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:15.300]                   signalCondition(cond)
[10:27:15.300]                 }
[10:27:15.300]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:15.300]                 "immediateCondition"))) {
[10:27:15.300]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:15.300]                   ...future.conditions[[length(...future.conditions) + 
[10:27:15.300]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:15.300]                   if (TRUE && !signal) {
[10:27:15.300]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:15.300]                     {
[10:27:15.300]                       inherits <- base::inherits
[10:27:15.300]                       invokeRestart <- base::invokeRestart
[10:27:15.300]                       is.null <- base::is.null
[10:27:15.300]                       muffled <- FALSE
[10:27:15.300]                       if (inherits(cond, "message")) {
[10:27:15.300]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:15.300]                         if (muffled) 
[10:27:15.300]                           invokeRestart("muffleMessage")
[10:27:15.300]                       }
[10:27:15.300]                       else if (inherits(cond, "warning")) {
[10:27:15.300]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:15.300]                         if (muffled) 
[10:27:15.300]                           invokeRestart("muffleWarning")
[10:27:15.300]                       }
[10:27:15.300]                       else if (inherits(cond, "condition")) {
[10:27:15.300]                         if (!is.null(pattern)) {
[10:27:15.300]                           computeRestarts <- base::computeRestarts
[10:27:15.300]                           grepl <- base::grepl
[10:27:15.300]                           restarts <- computeRestarts(cond)
[10:27:15.300]                           for (restart in restarts) {
[10:27:15.300]                             name <- restart$name
[10:27:15.300]                             if (is.null(name)) 
[10:27:15.300]                               next
[10:27:15.300]                             if (!grepl(pattern, name)) 
[10:27:15.300]                               next
[10:27:15.300]                             invokeRestart(restart)
[10:27:15.300]                             muffled <- TRUE
[10:27:15.300]                             break
[10:27:15.300]                           }
[10:27:15.300]                         }
[10:27:15.300]                       }
[10:27:15.300]                       invisible(muffled)
[10:27:15.300]                     }
[10:27:15.300]                     muffleCondition(cond, pattern = "^muffle")
[10:27:15.300]                   }
[10:27:15.300]                 }
[10:27:15.300]                 else {
[10:27:15.300]                   if (TRUE) {
[10:27:15.300]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:15.300]                     {
[10:27:15.300]                       inherits <- base::inherits
[10:27:15.300]                       invokeRestart <- base::invokeRestart
[10:27:15.300]                       is.null <- base::is.null
[10:27:15.300]                       muffled <- FALSE
[10:27:15.300]                       if (inherits(cond, "message")) {
[10:27:15.300]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:15.300]                         if (muffled) 
[10:27:15.300]                           invokeRestart("muffleMessage")
[10:27:15.300]                       }
[10:27:15.300]                       else if (inherits(cond, "warning")) {
[10:27:15.300]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:15.300]                         if (muffled) 
[10:27:15.300]                           invokeRestart("muffleWarning")
[10:27:15.300]                       }
[10:27:15.300]                       else if (inherits(cond, "condition")) {
[10:27:15.300]                         if (!is.null(pattern)) {
[10:27:15.300]                           computeRestarts <- base::computeRestarts
[10:27:15.300]                           grepl <- base::grepl
[10:27:15.300]                           restarts <- computeRestarts(cond)
[10:27:15.300]                           for (restart in restarts) {
[10:27:15.300]                             name <- restart$name
[10:27:15.300]                             if (is.null(name)) 
[10:27:15.300]                               next
[10:27:15.300]                             if (!grepl(pattern, name)) 
[10:27:15.300]                               next
[10:27:15.300]                             invokeRestart(restart)
[10:27:15.300]                             muffled <- TRUE
[10:27:15.300]                             break
[10:27:15.300]                           }
[10:27:15.300]                         }
[10:27:15.300]                       }
[10:27:15.300]                       invisible(muffled)
[10:27:15.300]                     }
[10:27:15.300]                     muffleCondition(cond, pattern = "^muffle")
[10:27:15.300]                   }
[10:27:15.300]                 }
[10:27:15.300]             }
[10:27:15.300]         }))
[10:27:15.300]     }, error = function(ex) {
[10:27:15.300]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:15.300]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:15.300]                 ...future.rng), started = ...future.startTime, 
[10:27:15.300]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:15.300]             version = "1.8"), class = "FutureResult")
[10:27:15.300]     }, finally = {
[10:27:15.300]         if (!identical(...future.workdir, getwd())) 
[10:27:15.300]             setwd(...future.workdir)
[10:27:15.300]         {
[10:27:15.300]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:15.300]                 ...future.oldOptions$nwarnings <- NULL
[10:27:15.300]             }
[10:27:15.300]             base::options(...future.oldOptions)
[10:27:15.300]             if (.Platform$OS.type == "windows") {
[10:27:15.300]                 old_names <- names(...future.oldEnvVars)
[10:27:15.300]                 envs <- base::Sys.getenv()
[10:27:15.300]                 names <- names(envs)
[10:27:15.300]                 common <- intersect(names, old_names)
[10:27:15.300]                 added <- setdiff(names, old_names)
[10:27:15.300]                 removed <- setdiff(old_names, names)
[10:27:15.300]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:15.300]                   envs[common]]
[10:27:15.300]                 NAMES <- toupper(changed)
[10:27:15.300]                 args <- list()
[10:27:15.300]                 for (kk in seq_along(NAMES)) {
[10:27:15.300]                   name <- changed[[kk]]
[10:27:15.300]                   NAME <- NAMES[[kk]]
[10:27:15.300]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:15.300]                     next
[10:27:15.300]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:15.300]                 }
[10:27:15.300]                 NAMES <- toupper(added)
[10:27:15.300]                 for (kk in seq_along(NAMES)) {
[10:27:15.300]                   name <- added[[kk]]
[10:27:15.300]                   NAME <- NAMES[[kk]]
[10:27:15.300]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:15.300]                     next
[10:27:15.300]                   args[[name]] <- ""
[10:27:15.300]                 }
[10:27:15.300]                 NAMES <- toupper(removed)
[10:27:15.300]                 for (kk in seq_along(NAMES)) {
[10:27:15.300]                   name <- removed[[kk]]
[10:27:15.300]                   NAME <- NAMES[[kk]]
[10:27:15.300]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:15.300]                     next
[10:27:15.300]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:15.300]                 }
[10:27:15.300]                 if (length(args) > 0) 
[10:27:15.300]                   base::do.call(base::Sys.setenv, args = args)
[10:27:15.300]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:15.300]             }
[10:27:15.300]             else {
[10:27:15.300]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:15.300]             }
[10:27:15.300]             {
[10:27:15.300]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:15.300]                   0L) {
[10:27:15.300]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:15.300]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:15.300]                   base::options(opts)
[10:27:15.300]                 }
[10:27:15.300]                 {
[10:27:15.300]                   {
[10:27:15.300]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:15.300]                     NULL
[10:27:15.300]                   }
[10:27:15.300]                   options(future.plan = NULL)
[10:27:15.300]                   if (is.na(NA_character_)) 
[10:27:15.300]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:15.300]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:15.300]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:15.300]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:15.300]                     envir = parent.frame()) 
[10:27:15.300]                   {
[10:27:15.300]                     if (is.function(workers)) 
[10:27:15.300]                       workers <- workers()
[10:27:15.300]                     workers <- structure(as.integer(workers), 
[10:27:15.300]                       class = class(workers))
[10:27:15.300]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:15.300]                       workers >= 1)
[10:27:15.300]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:15.300]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:15.300]                     }
[10:27:15.300]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:15.300]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:15.300]                       envir = envir)
[10:27:15.300]                     if (!future$lazy) 
[10:27:15.300]                       future <- run(future)
[10:27:15.300]                     invisible(future)
[10:27:15.300]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:15.300]                 }
[10:27:15.300]             }
[10:27:15.300]         }
[10:27:15.300]     })
[10:27:15.300]     if (TRUE) {
[10:27:15.300]         base::sink(type = "output", split = FALSE)
[10:27:15.300]         if (TRUE) {
[10:27:15.300]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:15.300]         }
[10:27:15.300]         else {
[10:27:15.300]             ...future.result["stdout"] <- base::list(NULL)
[10:27:15.300]         }
[10:27:15.300]         base::close(...future.stdout)
[10:27:15.300]         ...future.stdout <- NULL
[10:27:15.300]     }
[10:27:15.300]     ...future.result$conditions <- ...future.conditions
[10:27:15.300]     ...future.result$finished <- base::Sys.time()
[10:27:15.300]     ...future.result
[10:27:15.300] }
[10:27:15.303] Poll #1 (0): usedNodes() = 2, workers = 2
[10:27:15.313] receiveMessageFromWorker() for ClusterFuture ...
[10:27:15.314] - Validating connection of MultisessionFuture
[10:27:15.314] - received message: FutureResult
[10:27:15.314] - Received FutureResult
[10:27:15.314] - Erased future from FutureRegistry
[10:27:15.314] result() for ClusterFuture ...
[10:27:15.314] - result already collected: FutureResult
[10:27:15.314] result() for ClusterFuture ... done
[10:27:15.314] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:15.315] result() for ClusterFuture ...
[10:27:15.315] - result already collected: FutureResult
[10:27:15.315] result() for ClusterFuture ... done
[10:27:15.315] result() for ClusterFuture ...
[10:27:15.315] - result already collected: FutureResult
[10:27:15.315] result() for ClusterFuture ... done
[10:27:15.316] MultisessionFuture started
[10:27:15.316] - Launch lazy future ... done
[10:27:15.317] run() for ‘MultisessionFuture’ ... done
[10:27:15.317] getGlobalsAndPackages() ...
[10:27:15.317] Searching for globals...
[10:27:15.317] - globals found: [2] ‘list’, ‘stop’
[10:27:15.318] Searching for globals ... DONE
[10:27:15.318] Resolving globals: FALSE
[10:27:15.318] 
[10:27:15.318] 
[10:27:15.318] getGlobalsAndPackages() ... DONE
- result = TRUE, recursive = -1 ... DONE
- result = TRUE, recursive = 0 ...
[10:27:15.319] getGlobalsAndPackages() ...
[10:27:15.319] Searching for globals...
[10:27:15.320] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:27:15.320] Searching for globals ... DONE
[10:27:15.320] Resolving globals: FALSE
[10:27:15.320] 
[10:27:15.320] 
[10:27:15.320] getGlobalsAndPackages() ... DONE
[10:27:15.321] run() for ‘Future’ ...
[10:27:15.321] - state: ‘created’
[10:27:15.321] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:15.335] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:15.335] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:15.335]   - Field: ‘node’
[10:27:15.335]   - Field: ‘label’
[10:27:15.335]   - Field: ‘local’
[10:27:15.335]   - Field: ‘owner’
[10:27:15.336]   - Field: ‘envir’
[10:27:15.336]   - Field: ‘workers’
[10:27:15.336]   - Field: ‘packages’
[10:27:15.336]   - Field: ‘gc’
[10:27:15.336]   - Field: ‘conditions’
[10:27:15.336]   - Field: ‘persistent’
[10:27:15.336]   - Field: ‘expr’
[10:27:15.336]   - Field: ‘uuid’
[10:27:15.336]   - Field: ‘seed’
[10:27:15.336]   - Field: ‘version’
[10:27:15.336]   - Field: ‘result’
[10:27:15.337]   - Field: ‘asynchronous’
[10:27:15.337]   - Field: ‘calls’
[10:27:15.337]   - Field: ‘globals’
[10:27:15.337]   - Field: ‘stdout’
[10:27:15.337]   - Field: ‘earlySignal’
[10:27:15.337]   - Field: ‘lazy’
[10:27:15.337]   - Field: ‘state’
[10:27:15.337] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:15.337] - Launch lazy future ...
[10:27:15.338] Packages needed by the future expression (n = 0): <none>
[10:27:15.338] Packages needed by future strategies (n = 0): <none>
[10:27:15.338] {
[10:27:15.338]     {
[10:27:15.338]         {
[10:27:15.338]             ...future.startTime <- base::Sys.time()
[10:27:15.338]             {
[10:27:15.338]                 {
[10:27:15.338]                   {
[10:27:15.338]                     {
[10:27:15.338]                       base::local({
[10:27:15.338]                         has_future <- base::requireNamespace("future", 
[10:27:15.338]                           quietly = TRUE)
[10:27:15.338]                         if (has_future) {
[10:27:15.338]                           ns <- base::getNamespace("future")
[10:27:15.338]                           version <- ns[[".package"]][["version"]]
[10:27:15.338]                           if (is.null(version)) 
[10:27:15.338]                             version <- utils::packageVersion("future")
[10:27:15.338]                         }
[10:27:15.338]                         else {
[10:27:15.338]                           version <- NULL
[10:27:15.338]                         }
[10:27:15.338]                         if (!has_future || version < "1.8.0") {
[10:27:15.338]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:15.338]                             "", base::R.version$version.string), 
[10:27:15.338]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:15.338]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:15.338]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:15.338]                               "release", "version")], collapse = " "), 
[10:27:15.338]                             hostname = base::Sys.info()[["nodename"]])
[10:27:15.338]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:15.338]                             info)
[10:27:15.338]                           info <- base::paste(info, collapse = "; ")
[10:27:15.338]                           if (!has_future) {
[10:27:15.338]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:15.338]                               info)
[10:27:15.338]                           }
[10:27:15.338]                           else {
[10:27:15.338]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:15.338]                               info, version)
[10:27:15.338]                           }
[10:27:15.338]                           base::stop(msg)
[10:27:15.338]                         }
[10:27:15.338]                       })
[10:27:15.338]                     }
[10:27:15.338]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:15.338]                     base::options(mc.cores = 1L)
[10:27:15.338]                   }
[10:27:15.338]                   options(future.plan = NULL)
[10:27:15.338]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:15.338]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:15.338]                 }
[10:27:15.338]                 ...future.workdir <- getwd()
[10:27:15.338]             }
[10:27:15.338]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:15.338]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:15.338]         }
[10:27:15.338]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:15.338]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:15.338]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:15.338]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:15.338]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:15.338]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:15.338]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:15.338]             base::names(...future.oldOptions))
[10:27:15.338]     }
[10:27:15.338]     if (FALSE) {
[10:27:15.338]     }
[10:27:15.338]     else {
[10:27:15.338]         if (TRUE) {
[10:27:15.338]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:15.338]                 open = "w")
[10:27:15.338]         }
[10:27:15.338]         else {
[10:27:15.338]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:15.338]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:15.338]         }
[10:27:15.338]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:15.338]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:15.338]             base::sink(type = "output", split = FALSE)
[10:27:15.338]             base::close(...future.stdout)
[10:27:15.338]         }, add = TRUE)
[10:27:15.338]     }
[10:27:15.338]     ...future.frame <- base::sys.nframe()
[10:27:15.338]     ...future.conditions <- base::list()
[10:27:15.338]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:15.338]     if (FALSE) {
[10:27:15.338]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:15.338]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:15.338]     }
[10:27:15.338]     ...future.result <- base::tryCatch({
[10:27:15.338]         base::withCallingHandlers({
[10:27:15.338]             ...future.value <- base::withVisible(base::local({
[10:27:15.338]                 ...future.makeSendCondition <- base::local({
[10:27:15.338]                   sendCondition <- NULL
[10:27:15.338]                   function(frame = 1L) {
[10:27:15.338]                     if (is.function(sendCondition)) 
[10:27:15.338]                       return(sendCondition)
[10:27:15.338]                     ns <- getNamespace("parallel")
[10:27:15.338]                     if (exists("sendData", mode = "function", 
[10:27:15.338]                       envir = ns)) {
[10:27:15.338]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:15.338]                         envir = ns)
[10:27:15.338]                       envir <- sys.frame(frame)
[10:27:15.338]                       master <- NULL
[10:27:15.338]                       while (!identical(envir, .GlobalEnv) && 
[10:27:15.338]                         !identical(envir, emptyenv())) {
[10:27:15.338]                         if (exists("master", mode = "list", envir = envir, 
[10:27:15.338]                           inherits = FALSE)) {
[10:27:15.338]                           master <- get("master", mode = "list", 
[10:27:15.338]                             envir = envir, inherits = FALSE)
[10:27:15.338]                           if (inherits(master, c("SOCKnode", 
[10:27:15.338]                             "SOCK0node"))) {
[10:27:15.338]                             sendCondition <<- function(cond) {
[10:27:15.338]                               data <- list(type = "VALUE", value = cond, 
[10:27:15.338]                                 success = TRUE)
[10:27:15.338]                               parallel_sendData(master, data)
[10:27:15.338]                             }
[10:27:15.338]                             return(sendCondition)
[10:27:15.338]                           }
[10:27:15.338]                         }
[10:27:15.338]                         frame <- frame + 1L
[10:27:15.338]                         envir <- sys.frame(frame)
[10:27:15.338]                       }
[10:27:15.338]                     }
[10:27:15.338]                     sendCondition <<- function(cond) NULL
[10:27:15.338]                   }
[10:27:15.338]                 })
[10:27:15.338]                 withCallingHandlers({
[10:27:15.338]                   {
[10:27:15.338]                     Sys.sleep(0.5)
[10:27:15.338]                     list(a = 1, b = 42L)
[10:27:15.338]                   }
[10:27:15.338]                 }, immediateCondition = function(cond) {
[10:27:15.338]                   sendCondition <- ...future.makeSendCondition()
[10:27:15.338]                   sendCondition(cond)
[10:27:15.338]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:15.338]                   {
[10:27:15.338]                     inherits <- base::inherits
[10:27:15.338]                     invokeRestart <- base::invokeRestart
[10:27:15.338]                     is.null <- base::is.null
[10:27:15.338]                     muffled <- FALSE
[10:27:15.338]                     if (inherits(cond, "message")) {
[10:27:15.338]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:15.338]                       if (muffled) 
[10:27:15.338]                         invokeRestart("muffleMessage")
[10:27:15.338]                     }
[10:27:15.338]                     else if (inherits(cond, "warning")) {
[10:27:15.338]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:15.338]                       if (muffled) 
[10:27:15.338]                         invokeRestart("muffleWarning")
[10:27:15.338]                     }
[10:27:15.338]                     else if (inherits(cond, "condition")) {
[10:27:15.338]                       if (!is.null(pattern)) {
[10:27:15.338]                         computeRestarts <- base::computeRestarts
[10:27:15.338]                         grepl <- base::grepl
[10:27:15.338]                         restarts <- computeRestarts(cond)
[10:27:15.338]                         for (restart in restarts) {
[10:27:15.338]                           name <- restart$name
[10:27:15.338]                           if (is.null(name)) 
[10:27:15.338]                             next
[10:27:15.338]                           if (!grepl(pattern, name)) 
[10:27:15.338]                             next
[10:27:15.338]                           invokeRestart(restart)
[10:27:15.338]                           muffled <- TRUE
[10:27:15.338]                           break
[10:27:15.338]                         }
[10:27:15.338]                       }
[10:27:15.338]                     }
[10:27:15.338]                     invisible(muffled)
[10:27:15.338]                   }
[10:27:15.338]                   muffleCondition(cond)
[10:27:15.338]                 })
[10:27:15.338]             }))
[10:27:15.338]             future::FutureResult(value = ...future.value$value, 
[10:27:15.338]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:15.338]                   ...future.rng), globalenv = if (FALSE) 
[10:27:15.338]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:15.338]                     ...future.globalenv.names))
[10:27:15.338]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:15.338]         }, condition = base::local({
[10:27:15.338]             c <- base::c
[10:27:15.338]             inherits <- base::inherits
[10:27:15.338]             invokeRestart <- base::invokeRestart
[10:27:15.338]             length <- base::length
[10:27:15.338]             list <- base::list
[10:27:15.338]             seq.int <- base::seq.int
[10:27:15.338]             signalCondition <- base::signalCondition
[10:27:15.338]             sys.calls <- base::sys.calls
[10:27:15.338]             `[[` <- base::`[[`
[10:27:15.338]             `+` <- base::`+`
[10:27:15.338]             `<<-` <- base::`<<-`
[10:27:15.338]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:15.338]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:15.338]                   3L)]
[10:27:15.338]             }
[10:27:15.338]             function(cond) {
[10:27:15.338]                 is_error <- inherits(cond, "error")
[10:27:15.338]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:15.338]                   NULL)
[10:27:15.338]                 if (is_error) {
[10:27:15.338]                   sessionInformation <- function() {
[10:27:15.338]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:15.338]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:15.338]                       search = base::search(), system = base::Sys.info())
[10:27:15.338]                   }
[10:27:15.338]                   ...future.conditions[[length(...future.conditions) + 
[10:27:15.338]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:15.338]                     cond$call), session = sessionInformation(), 
[10:27:15.338]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:15.338]                   signalCondition(cond)
[10:27:15.338]                 }
[10:27:15.338]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:15.338]                 "immediateCondition"))) {
[10:27:15.338]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:15.338]                   ...future.conditions[[length(...future.conditions) + 
[10:27:15.338]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:15.338]                   if (TRUE && !signal) {
[10:27:15.338]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:15.338]                     {
[10:27:15.338]                       inherits <- base::inherits
[10:27:15.338]                       invokeRestart <- base::invokeRestart
[10:27:15.338]                       is.null <- base::is.null
[10:27:15.338]                       muffled <- FALSE
[10:27:15.338]                       if (inherits(cond, "message")) {
[10:27:15.338]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:15.338]                         if (muffled) 
[10:27:15.338]                           invokeRestart("muffleMessage")
[10:27:15.338]                       }
[10:27:15.338]                       else if (inherits(cond, "warning")) {
[10:27:15.338]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:15.338]                         if (muffled) 
[10:27:15.338]                           invokeRestart("muffleWarning")
[10:27:15.338]                       }
[10:27:15.338]                       else if (inherits(cond, "condition")) {
[10:27:15.338]                         if (!is.null(pattern)) {
[10:27:15.338]                           computeRestarts <- base::computeRestarts
[10:27:15.338]                           grepl <- base::grepl
[10:27:15.338]                           restarts <- computeRestarts(cond)
[10:27:15.338]                           for (restart in restarts) {
[10:27:15.338]                             name <- restart$name
[10:27:15.338]                             if (is.null(name)) 
[10:27:15.338]                               next
[10:27:15.338]                             if (!grepl(pattern, name)) 
[10:27:15.338]                               next
[10:27:15.338]                             invokeRestart(restart)
[10:27:15.338]                             muffled <- TRUE
[10:27:15.338]                             break
[10:27:15.338]                           }
[10:27:15.338]                         }
[10:27:15.338]                       }
[10:27:15.338]                       invisible(muffled)
[10:27:15.338]                     }
[10:27:15.338]                     muffleCondition(cond, pattern = "^muffle")
[10:27:15.338]                   }
[10:27:15.338]                 }
[10:27:15.338]                 else {
[10:27:15.338]                   if (TRUE) {
[10:27:15.338]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:15.338]                     {
[10:27:15.338]                       inherits <- base::inherits
[10:27:15.338]                       invokeRestart <- base::invokeRestart
[10:27:15.338]                       is.null <- base::is.null
[10:27:15.338]                       muffled <- FALSE
[10:27:15.338]                       if (inherits(cond, "message")) {
[10:27:15.338]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:15.338]                         if (muffled) 
[10:27:15.338]                           invokeRestart("muffleMessage")
[10:27:15.338]                       }
[10:27:15.338]                       else if (inherits(cond, "warning")) {
[10:27:15.338]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:15.338]                         if (muffled) 
[10:27:15.338]                           invokeRestart("muffleWarning")
[10:27:15.338]                       }
[10:27:15.338]                       else if (inherits(cond, "condition")) {
[10:27:15.338]                         if (!is.null(pattern)) {
[10:27:15.338]                           computeRestarts <- base::computeRestarts
[10:27:15.338]                           grepl <- base::grepl
[10:27:15.338]                           restarts <- computeRestarts(cond)
[10:27:15.338]                           for (restart in restarts) {
[10:27:15.338]                             name <- restart$name
[10:27:15.338]                             if (is.null(name)) 
[10:27:15.338]                               next
[10:27:15.338]                             if (!grepl(pattern, name)) 
[10:27:15.338]                               next
[10:27:15.338]                             invokeRestart(restart)
[10:27:15.338]                             muffled <- TRUE
[10:27:15.338]                             break
[10:27:15.338]                           }
[10:27:15.338]                         }
[10:27:15.338]                       }
[10:27:15.338]                       invisible(muffled)
[10:27:15.338]                     }
[10:27:15.338]                     muffleCondition(cond, pattern = "^muffle")
[10:27:15.338]                   }
[10:27:15.338]                 }
[10:27:15.338]             }
[10:27:15.338]         }))
[10:27:15.338]     }, error = function(ex) {
[10:27:15.338]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:15.338]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:15.338]                 ...future.rng), started = ...future.startTime, 
[10:27:15.338]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:15.338]             version = "1.8"), class = "FutureResult")
[10:27:15.338]     }, finally = {
[10:27:15.338]         if (!identical(...future.workdir, getwd())) 
[10:27:15.338]             setwd(...future.workdir)
[10:27:15.338]         {
[10:27:15.338]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:15.338]                 ...future.oldOptions$nwarnings <- NULL
[10:27:15.338]             }
[10:27:15.338]             base::options(...future.oldOptions)
[10:27:15.338]             if (.Platform$OS.type == "windows") {
[10:27:15.338]                 old_names <- names(...future.oldEnvVars)
[10:27:15.338]                 envs <- base::Sys.getenv()
[10:27:15.338]                 names <- names(envs)
[10:27:15.338]                 common <- intersect(names, old_names)
[10:27:15.338]                 added <- setdiff(names, old_names)
[10:27:15.338]                 removed <- setdiff(old_names, names)
[10:27:15.338]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:15.338]                   envs[common]]
[10:27:15.338]                 NAMES <- toupper(changed)
[10:27:15.338]                 args <- list()
[10:27:15.338]                 for (kk in seq_along(NAMES)) {
[10:27:15.338]                   name <- changed[[kk]]
[10:27:15.338]                   NAME <- NAMES[[kk]]
[10:27:15.338]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:15.338]                     next
[10:27:15.338]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:15.338]                 }
[10:27:15.338]                 NAMES <- toupper(added)
[10:27:15.338]                 for (kk in seq_along(NAMES)) {
[10:27:15.338]                   name <- added[[kk]]
[10:27:15.338]                   NAME <- NAMES[[kk]]
[10:27:15.338]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:15.338]                     next
[10:27:15.338]                   args[[name]] <- ""
[10:27:15.338]                 }
[10:27:15.338]                 NAMES <- toupper(removed)
[10:27:15.338]                 for (kk in seq_along(NAMES)) {
[10:27:15.338]                   name <- removed[[kk]]
[10:27:15.338]                   NAME <- NAMES[[kk]]
[10:27:15.338]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:15.338]                     next
[10:27:15.338]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:15.338]                 }
[10:27:15.338]                 if (length(args) > 0) 
[10:27:15.338]                   base::do.call(base::Sys.setenv, args = args)
[10:27:15.338]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:15.338]             }
[10:27:15.338]             else {
[10:27:15.338]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:15.338]             }
[10:27:15.338]             {
[10:27:15.338]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:15.338]                   0L) {
[10:27:15.338]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:15.338]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:15.338]                   base::options(opts)
[10:27:15.338]                 }
[10:27:15.338]                 {
[10:27:15.338]                   {
[10:27:15.338]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:15.338]                     NULL
[10:27:15.338]                   }
[10:27:15.338]                   options(future.plan = NULL)
[10:27:15.338]                   if (is.na(NA_character_)) 
[10:27:15.338]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:15.338]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:15.338]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:15.338]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:15.338]                     envir = parent.frame()) 
[10:27:15.338]                   {
[10:27:15.338]                     if (is.function(workers)) 
[10:27:15.338]                       workers <- workers()
[10:27:15.338]                     workers <- structure(as.integer(workers), 
[10:27:15.338]                       class = class(workers))
[10:27:15.338]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:15.338]                       workers >= 1)
[10:27:15.338]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:15.338]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:15.338]                     }
[10:27:15.338]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:15.338]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:15.338]                       envir = envir)
[10:27:15.338]                     if (!future$lazy) 
[10:27:15.338]                       future <- run(future)
[10:27:15.338]                     invisible(future)
[10:27:15.338]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:15.338]                 }
[10:27:15.338]             }
[10:27:15.338]         }
[10:27:15.338]     })
[10:27:15.338]     if (TRUE) {
[10:27:15.338]         base::sink(type = "output", split = FALSE)
[10:27:15.338]         if (TRUE) {
[10:27:15.338]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:15.338]         }
[10:27:15.338]         else {
[10:27:15.338]             ...future.result["stdout"] <- base::list(NULL)
[10:27:15.338]         }
[10:27:15.338]         base::close(...future.stdout)
[10:27:15.338]         ...future.stdout <- NULL
[10:27:15.338]     }
[10:27:15.338]     ...future.result$conditions <- ...future.conditions
[10:27:15.338]     ...future.result$finished <- base::Sys.time()
[10:27:15.338]     ...future.result
[10:27:15.338] }
[10:27:15.341] Poll #1 (0): usedNodes() = 2, workers = 2
[10:27:15.363] receiveMessageFromWorker() for ClusterFuture ...
[10:27:15.363] - Validating connection of MultisessionFuture
[10:27:15.366] - received message: FutureResult
[10:27:15.367] - Received FutureResult
[10:27:15.367] - Erased future from FutureRegistry
[10:27:15.367] result() for ClusterFuture ...
[10:27:15.367] - result already collected: FutureResult
[10:27:15.367] result() for ClusterFuture ... done
[10:27:15.367] signalConditions() ...
[10:27:15.367]  - include = ‘immediateCondition’
[10:27:15.367]  - exclude = 
[10:27:15.368]  - resignal = FALSE
[10:27:15.368]  - Number of conditions: 1
[10:27:15.368] signalConditions() ... done
[10:27:15.368] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:15.368] result() for ClusterFuture ...
[10:27:15.368] - result already collected: FutureResult
[10:27:15.368] result() for ClusterFuture ... done
[10:27:15.368] result() for ClusterFuture ...
[10:27:15.368] - result already collected: FutureResult
[10:27:15.369] result() for ClusterFuture ... done
[10:27:15.369] signalConditions() ...
[10:27:15.369]  - include = ‘immediateCondition’
[10:27:15.369]  - exclude = 
[10:27:15.369]  - resignal = FALSE
[10:27:15.369]  - Number of conditions: 1
[10:27:15.369] signalConditions() ... done
[10:27:15.371] MultisessionFuture started
[10:27:15.371] - Launch lazy future ... done
[10:27:15.371] run() for ‘MultisessionFuture’ ... done
[10:27:15.928] receiveMessageFromWorker() for ClusterFuture ...
[10:27:15.928] - Validating connection of MultisessionFuture
[10:27:15.928] - received message: FutureResult
[10:27:15.928] - Received FutureResult
[10:27:15.928] - Erased future from FutureRegistry
[10:27:15.928] result() for ClusterFuture ...
[10:27:15.929] - result already collected: FutureResult
[10:27:15.929] result() for ClusterFuture ... done
[10:27:15.929] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:15.929] A MultisessionFuture was resolved
[10:27:15.929] getGlobalsAndPackages() ...
[10:27:15.929] Searching for globals...
[10:27:15.930] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:27:15.930] Searching for globals ... DONE
[10:27:15.930] Resolving globals: FALSE
[10:27:15.931] 
[10:27:15.931] 
[10:27:15.931] getGlobalsAndPackages() ... DONE
[10:27:15.931] run() for ‘Future’ ...
[10:27:15.931] - state: ‘created’
[10:27:15.931] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:15.945] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:15.945] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:15.946]   - Field: ‘node’
[10:27:15.946]   - Field: ‘label’
[10:27:15.946]   - Field: ‘local’
[10:27:15.946]   - Field: ‘owner’
[10:27:15.946]   - Field: ‘envir’
[10:27:15.946]   - Field: ‘workers’
[10:27:15.946]   - Field: ‘packages’
[10:27:15.946]   - Field: ‘gc’
[10:27:15.946]   - Field: ‘conditions’
[10:27:15.946]   - Field: ‘persistent’
[10:27:15.946]   - Field: ‘expr’
[10:27:15.947]   - Field: ‘uuid’
[10:27:15.947]   - Field: ‘seed’
[10:27:15.947]   - Field: ‘version’
[10:27:15.947]   - Field: ‘result’
[10:27:15.947]   - Field: ‘asynchronous’
[10:27:15.947]   - Field: ‘calls’
[10:27:15.947]   - Field: ‘globals’
[10:27:15.947]   - Field: ‘stdout’
[10:27:15.947]   - Field: ‘earlySignal’
[10:27:15.947]   - Field: ‘lazy’
[10:27:15.947]   - Field: ‘state’
[10:27:15.948] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:15.948] - Launch lazy future ...
[10:27:15.948] Packages needed by the future expression (n = 0): <none>
[10:27:15.948] Packages needed by future strategies (n = 0): <none>
[10:27:15.949] {
[10:27:15.949]     {
[10:27:15.949]         {
[10:27:15.949]             ...future.startTime <- base::Sys.time()
[10:27:15.949]             {
[10:27:15.949]                 {
[10:27:15.949]                   {
[10:27:15.949]                     {
[10:27:15.949]                       base::local({
[10:27:15.949]                         has_future <- base::requireNamespace("future", 
[10:27:15.949]                           quietly = TRUE)
[10:27:15.949]                         if (has_future) {
[10:27:15.949]                           ns <- base::getNamespace("future")
[10:27:15.949]                           version <- ns[[".package"]][["version"]]
[10:27:15.949]                           if (is.null(version)) 
[10:27:15.949]                             version <- utils::packageVersion("future")
[10:27:15.949]                         }
[10:27:15.949]                         else {
[10:27:15.949]                           version <- NULL
[10:27:15.949]                         }
[10:27:15.949]                         if (!has_future || version < "1.8.0") {
[10:27:15.949]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:15.949]                             "", base::R.version$version.string), 
[10:27:15.949]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:15.949]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:15.949]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:15.949]                               "release", "version")], collapse = " "), 
[10:27:15.949]                             hostname = base::Sys.info()[["nodename"]])
[10:27:15.949]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:15.949]                             info)
[10:27:15.949]                           info <- base::paste(info, collapse = "; ")
[10:27:15.949]                           if (!has_future) {
[10:27:15.949]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:15.949]                               info)
[10:27:15.949]                           }
[10:27:15.949]                           else {
[10:27:15.949]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:15.949]                               info, version)
[10:27:15.949]                           }
[10:27:15.949]                           base::stop(msg)
[10:27:15.949]                         }
[10:27:15.949]                       })
[10:27:15.949]                     }
[10:27:15.949]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:15.949]                     base::options(mc.cores = 1L)
[10:27:15.949]                   }
[10:27:15.949]                   options(future.plan = NULL)
[10:27:15.949]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:15.949]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:15.949]                 }
[10:27:15.949]                 ...future.workdir <- getwd()
[10:27:15.949]             }
[10:27:15.949]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:15.949]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:15.949]         }
[10:27:15.949]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:15.949]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:15.949]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:15.949]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:15.949]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:15.949]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:15.949]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:15.949]             base::names(...future.oldOptions))
[10:27:15.949]     }
[10:27:15.949]     if (FALSE) {
[10:27:15.949]     }
[10:27:15.949]     else {
[10:27:15.949]         if (TRUE) {
[10:27:15.949]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:15.949]                 open = "w")
[10:27:15.949]         }
[10:27:15.949]         else {
[10:27:15.949]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:15.949]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:15.949]         }
[10:27:15.949]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:15.949]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:15.949]             base::sink(type = "output", split = FALSE)
[10:27:15.949]             base::close(...future.stdout)
[10:27:15.949]         }, add = TRUE)
[10:27:15.949]     }
[10:27:15.949]     ...future.frame <- base::sys.nframe()
[10:27:15.949]     ...future.conditions <- base::list()
[10:27:15.949]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:15.949]     if (FALSE) {
[10:27:15.949]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:15.949]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:15.949]     }
[10:27:15.949]     ...future.result <- base::tryCatch({
[10:27:15.949]         base::withCallingHandlers({
[10:27:15.949]             ...future.value <- base::withVisible(base::local({
[10:27:15.949]                 ...future.makeSendCondition <- base::local({
[10:27:15.949]                   sendCondition <- NULL
[10:27:15.949]                   function(frame = 1L) {
[10:27:15.949]                     if (is.function(sendCondition)) 
[10:27:15.949]                       return(sendCondition)
[10:27:15.949]                     ns <- getNamespace("parallel")
[10:27:15.949]                     if (exists("sendData", mode = "function", 
[10:27:15.949]                       envir = ns)) {
[10:27:15.949]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:15.949]                         envir = ns)
[10:27:15.949]                       envir <- sys.frame(frame)
[10:27:15.949]                       master <- NULL
[10:27:15.949]                       while (!identical(envir, .GlobalEnv) && 
[10:27:15.949]                         !identical(envir, emptyenv())) {
[10:27:15.949]                         if (exists("master", mode = "list", envir = envir, 
[10:27:15.949]                           inherits = FALSE)) {
[10:27:15.949]                           master <- get("master", mode = "list", 
[10:27:15.949]                             envir = envir, inherits = FALSE)
[10:27:15.949]                           if (inherits(master, c("SOCKnode", 
[10:27:15.949]                             "SOCK0node"))) {
[10:27:15.949]                             sendCondition <<- function(cond) {
[10:27:15.949]                               data <- list(type = "VALUE", value = cond, 
[10:27:15.949]                                 success = TRUE)
[10:27:15.949]                               parallel_sendData(master, data)
[10:27:15.949]                             }
[10:27:15.949]                             return(sendCondition)
[10:27:15.949]                           }
[10:27:15.949]                         }
[10:27:15.949]                         frame <- frame + 1L
[10:27:15.949]                         envir <- sys.frame(frame)
[10:27:15.949]                       }
[10:27:15.949]                     }
[10:27:15.949]                     sendCondition <<- function(cond) NULL
[10:27:15.949]                   }
[10:27:15.949]                 })
[10:27:15.949]                 withCallingHandlers({
[10:27:15.949]                   {
[10:27:15.949]                     Sys.sleep(0.5)
[10:27:15.949]                     list(a = 1, b = 42L)
[10:27:15.949]                   }
[10:27:15.949]                 }, immediateCondition = function(cond) {
[10:27:15.949]                   sendCondition <- ...future.makeSendCondition()
[10:27:15.949]                   sendCondition(cond)
[10:27:15.949]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:15.949]                   {
[10:27:15.949]                     inherits <- base::inherits
[10:27:15.949]                     invokeRestart <- base::invokeRestart
[10:27:15.949]                     is.null <- base::is.null
[10:27:15.949]                     muffled <- FALSE
[10:27:15.949]                     if (inherits(cond, "message")) {
[10:27:15.949]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:15.949]                       if (muffled) 
[10:27:15.949]                         invokeRestart("muffleMessage")
[10:27:15.949]                     }
[10:27:15.949]                     else if (inherits(cond, "warning")) {
[10:27:15.949]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:15.949]                       if (muffled) 
[10:27:15.949]                         invokeRestart("muffleWarning")
[10:27:15.949]                     }
[10:27:15.949]                     else if (inherits(cond, "condition")) {
[10:27:15.949]                       if (!is.null(pattern)) {
[10:27:15.949]                         computeRestarts <- base::computeRestarts
[10:27:15.949]                         grepl <- base::grepl
[10:27:15.949]                         restarts <- computeRestarts(cond)
[10:27:15.949]                         for (restart in restarts) {
[10:27:15.949]                           name <- restart$name
[10:27:15.949]                           if (is.null(name)) 
[10:27:15.949]                             next
[10:27:15.949]                           if (!grepl(pattern, name)) 
[10:27:15.949]                             next
[10:27:15.949]                           invokeRestart(restart)
[10:27:15.949]                           muffled <- TRUE
[10:27:15.949]                           break
[10:27:15.949]                         }
[10:27:15.949]                       }
[10:27:15.949]                     }
[10:27:15.949]                     invisible(muffled)
[10:27:15.949]                   }
[10:27:15.949]                   muffleCondition(cond)
[10:27:15.949]                 })
[10:27:15.949]             }))
[10:27:15.949]             future::FutureResult(value = ...future.value$value, 
[10:27:15.949]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:15.949]                   ...future.rng), globalenv = if (FALSE) 
[10:27:15.949]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:15.949]                     ...future.globalenv.names))
[10:27:15.949]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:15.949]         }, condition = base::local({
[10:27:15.949]             c <- base::c
[10:27:15.949]             inherits <- base::inherits
[10:27:15.949]             invokeRestart <- base::invokeRestart
[10:27:15.949]             length <- base::length
[10:27:15.949]             list <- base::list
[10:27:15.949]             seq.int <- base::seq.int
[10:27:15.949]             signalCondition <- base::signalCondition
[10:27:15.949]             sys.calls <- base::sys.calls
[10:27:15.949]             `[[` <- base::`[[`
[10:27:15.949]             `+` <- base::`+`
[10:27:15.949]             `<<-` <- base::`<<-`
[10:27:15.949]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:15.949]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:15.949]                   3L)]
[10:27:15.949]             }
[10:27:15.949]             function(cond) {
[10:27:15.949]                 is_error <- inherits(cond, "error")
[10:27:15.949]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:15.949]                   NULL)
[10:27:15.949]                 if (is_error) {
[10:27:15.949]                   sessionInformation <- function() {
[10:27:15.949]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:15.949]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:15.949]                       search = base::search(), system = base::Sys.info())
[10:27:15.949]                   }
[10:27:15.949]                   ...future.conditions[[length(...future.conditions) + 
[10:27:15.949]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:15.949]                     cond$call), session = sessionInformation(), 
[10:27:15.949]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:15.949]                   signalCondition(cond)
[10:27:15.949]                 }
[10:27:15.949]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:15.949]                 "immediateCondition"))) {
[10:27:15.949]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:15.949]                   ...future.conditions[[length(...future.conditions) + 
[10:27:15.949]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:15.949]                   if (TRUE && !signal) {
[10:27:15.949]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:15.949]                     {
[10:27:15.949]                       inherits <- base::inherits
[10:27:15.949]                       invokeRestart <- base::invokeRestart
[10:27:15.949]                       is.null <- base::is.null
[10:27:15.949]                       muffled <- FALSE
[10:27:15.949]                       if (inherits(cond, "message")) {
[10:27:15.949]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:15.949]                         if (muffled) 
[10:27:15.949]                           invokeRestart("muffleMessage")
[10:27:15.949]                       }
[10:27:15.949]                       else if (inherits(cond, "warning")) {
[10:27:15.949]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:15.949]                         if (muffled) 
[10:27:15.949]                           invokeRestart("muffleWarning")
[10:27:15.949]                       }
[10:27:15.949]                       else if (inherits(cond, "condition")) {
[10:27:15.949]                         if (!is.null(pattern)) {
[10:27:15.949]                           computeRestarts <- base::computeRestarts
[10:27:15.949]                           grepl <- base::grepl
[10:27:15.949]                           restarts <- computeRestarts(cond)
[10:27:15.949]                           for (restart in restarts) {
[10:27:15.949]                             name <- restart$name
[10:27:15.949]                             if (is.null(name)) 
[10:27:15.949]                               next
[10:27:15.949]                             if (!grepl(pattern, name)) 
[10:27:15.949]                               next
[10:27:15.949]                             invokeRestart(restart)
[10:27:15.949]                             muffled <- TRUE
[10:27:15.949]                             break
[10:27:15.949]                           }
[10:27:15.949]                         }
[10:27:15.949]                       }
[10:27:15.949]                       invisible(muffled)
[10:27:15.949]                     }
[10:27:15.949]                     muffleCondition(cond, pattern = "^muffle")
[10:27:15.949]                   }
[10:27:15.949]                 }
[10:27:15.949]                 else {
[10:27:15.949]                   if (TRUE) {
[10:27:15.949]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:15.949]                     {
[10:27:15.949]                       inherits <- base::inherits
[10:27:15.949]                       invokeRestart <- base::invokeRestart
[10:27:15.949]                       is.null <- base::is.null
[10:27:15.949]                       muffled <- FALSE
[10:27:15.949]                       if (inherits(cond, "message")) {
[10:27:15.949]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:15.949]                         if (muffled) 
[10:27:15.949]                           invokeRestart("muffleMessage")
[10:27:15.949]                       }
[10:27:15.949]                       else if (inherits(cond, "warning")) {
[10:27:15.949]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:15.949]                         if (muffled) 
[10:27:15.949]                           invokeRestart("muffleWarning")
[10:27:15.949]                       }
[10:27:15.949]                       else if (inherits(cond, "condition")) {
[10:27:15.949]                         if (!is.null(pattern)) {
[10:27:15.949]                           computeRestarts <- base::computeRestarts
[10:27:15.949]                           grepl <- base::grepl
[10:27:15.949]                           restarts <- computeRestarts(cond)
[10:27:15.949]                           for (restart in restarts) {
[10:27:15.949]                             name <- restart$name
[10:27:15.949]                             if (is.null(name)) 
[10:27:15.949]                               next
[10:27:15.949]                             if (!grepl(pattern, name)) 
[10:27:15.949]                               next
[10:27:15.949]                             invokeRestart(restart)
[10:27:15.949]                             muffled <- TRUE
[10:27:15.949]                             break
[10:27:15.949]                           }
[10:27:15.949]                         }
[10:27:15.949]                       }
[10:27:15.949]                       invisible(muffled)
[10:27:15.949]                     }
[10:27:15.949]                     muffleCondition(cond, pattern = "^muffle")
[10:27:15.949]                   }
[10:27:15.949]                 }
[10:27:15.949]             }
[10:27:15.949]         }))
[10:27:15.949]     }, error = function(ex) {
[10:27:15.949]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:15.949]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:15.949]                 ...future.rng), started = ...future.startTime, 
[10:27:15.949]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:15.949]             version = "1.8"), class = "FutureResult")
[10:27:15.949]     }, finally = {
[10:27:15.949]         if (!identical(...future.workdir, getwd())) 
[10:27:15.949]             setwd(...future.workdir)
[10:27:15.949]         {
[10:27:15.949]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:15.949]                 ...future.oldOptions$nwarnings <- NULL
[10:27:15.949]             }
[10:27:15.949]             base::options(...future.oldOptions)
[10:27:15.949]             if (.Platform$OS.type == "windows") {
[10:27:15.949]                 old_names <- names(...future.oldEnvVars)
[10:27:15.949]                 envs <- base::Sys.getenv()
[10:27:15.949]                 names <- names(envs)
[10:27:15.949]                 common <- intersect(names, old_names)
[10:27:15.949]                 added <- setdiff(names, old_names)
[10:27:15.949]                 removed <- setdiff(old_names, names)
[10:27:15.949]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:15.949]                   envs[common]]
[10:27:15.949]                 NAMES <- toupper(changed)
[10:27:15.949]                 args <- list()
[10:27:15.949]                 for (kk in seq_along(NAMES)) {
[10:27:15.949]                   name <- changed[[kk]]
[10:27:15.949]                   NAME <- NAMES[[kk]]
[10:27:15.949]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:15.949]                     next
[10:27:15.949]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:15.949]                 }
[10:27:15.949]                 NAMES <- toupper(added)
[10:27:15.949]                 for (kk in seq_along(NAMES)) {
[10:27:15.949]                   name <- added[[kk]]
[10:27:15.949]                   NAME <- NAMES[[kk]]
[10:27:15.949]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:15.949]                     next
[10:27:15.949]                   args[[name]] <- ""
[10:27:15.949]                 }
[10:27:15.949]                 NAMES <- toupper(removed)
[10:27:15.949]                 for (kk in seq_along(NAMES)) {
[10:27:15.949]                   name <- removed[[kk]]
[10:27:15.949]                   NAME <- NAMES[[kk]]
[10:27:15.949]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:15.949]                     next
[10:27:15.949]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:15.949]                 }
[10:27:15.949]                 if (length(args) > 0) 
[10:27:15.949]                   base::do.call(base::Sys.setenv, args = args)
[10:27:15.949]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:15.949]             }
[10:27:15.949]             else {
[10:27:15.949]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:15.949]             }
[10:27:15.949]             {
[10:27:15.949]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:15.949]                   0L) {
[10:27:15.949]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:15.949]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:15.949]                   base::options(opts)
[10:27:15.949]                 }
[10:27:15.949]                 {
[10:27:15.949]                   {
[10:27:15.949]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:15.949]                     NULL
[10:27:15.949]                   }
[10:27:15.949]                   options(future.plan = NULL)
[10:27:15.949]                   if (is.na(NA_character_)) 
[10:27:15.949]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:15.949]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:15.949]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:15.949]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:15.949]                     envir = parent.frame()) 
[10:27:15.949]                   {
[10:27:15.949]                     if (is.function(workers)) 
[10:27:15.949]                       workers <- workers()
[10:27:15.949]                     workers <- structure(as.integer(workers), 
[10:27:15.949]                       class = class(workers))
[10:27:15.949]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:15.949]                       workers >= 1)
[10:27:15.949]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:15.949]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:15.949]                     }
[10:27:15.949]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:15.949]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:15.949]                       envir = envir)
[10:27:15.949]                     if (!future$lazy) 
[10:27:15.949]                       future <- run(future)
[10:27:15.949]                     invisible(future)
[10:27:15.949]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:15.949]                 }
[10:27:15.949]             }
[10:27:15.949]         }
[10:27:15.949]     })
[10:27:15.949]     if (TRUE) {
[10:27:15.949]         base::sink(type = "output", split = FALSE)
[10:27:15.949]         if (TRUE) {
[10:27:15.949]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:15.949]         }
[10:27:15.949]         else {
[10:27:15.949]             ...future.result["stdout"] <- base::list(NULL)
[10:27:15.949]         }
[10:27:15.949]         base::close(...future.stdout)
[10:27:15.949]         ...future.stdout <- NULL
[10:27:15.949]     }
[10:27:15.949]     ...future.result$conditions <- ...future.conditions
[10:27:15.949]     ...future.result$finished <- base::Sys.time()
[10:27:15.949]     ...future.result
[10:27:15.949] }
[10:27:15.952] MultisessionFuture started
[10:27:15.952] - Launch lazy future ... done
[10:27:15.952] run() for ‘MultisessionFuture’ ... done
[10:27:16.510] receiveMessageFromWorker() for ClusterFuture ...
[10:27:16.510] - Validating connection of MultisessionFuture
[10:27:16.510] - received message: FutureResult
[10:27:16.510] - Received FutureResult
[10:27:16.510] - Erased future from FutureRegistry
[10:27:16.511] result() for ClusterFuture ...
[10:27:16.511] - result already collected: FutureResult
[10:27:16.511] result() for ClusterFuture ... done
[10:27:16.511] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:16.511] A MultisessionFuture was resolved
- w/ exception ...
[10:27:16.512] getGlobalsAndPackages() ...
[10:27:16.512] Searching for globals...
[10:27:16.513] - globals found: [2] ‘list’, ‘stop’
[10:27:16.513] Searching for globals ... DONE
[10:27:16.513] Resolving globals: FALSE
[10:27:16.514] 
[10:27:16.515] 
[10:27:16.515] getGlobalsAndPackages() ... DONE
[10:27:16.515] run() for ‘Future’ ...
[10:27:16.516] - state: ‘created’
[10:27:16.516] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:16.530] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:16.530] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:16.530]   - Field: ‘node’
[10:27:16.530]   - Field: ‘label’
[10:27:16.531]   - Field: ‘local’
[10:27:16.531]   - Field: ‘owner’
[10:27:16.531]   - Field: ‘envir’
[10:27:16.531]   - Field: ‘workers’
[10:27:16.531]   - Field: ‘packages’
[10:27:16.531]   - Field: ‘gc’
[10:27:16.531]   - Field: ‘conditions’
[10:27:16.531]   - Field: ‘persistent’
[10:27:16.531]   - Field: ‘expr’
[10:27:16.531]   - Field: ‘uuid’
[10:27:16.532]   - Field: ‘seed’
[10:27:16.532]   - Field: ‘version’
[10:27:16.532]   - Field: ‘result’
[10:27:16.532]   - Field: ‘asynchronous’
[10:27:16.532]   - Field: ‘calls’
[10:27:16.532]   - Field: ‘globals’
[10:27:16.532]   - Field: ‘stdout’
[10:27:16.532]   - Field: ‘earlySignal’
[10:27:16.532]   - Field: ‘lazy’
[10:27:16.532]   - Field: ‘state’
[10:27:16.533] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:16.533] - Launch lazy future ...
[10:27:16.533] Packages needed by the future expression (n = 0): <none>
[10:27:16.533] Packages needed by future strategies (n = 0): <none>
[10:27:16.534] {
[10:27:16.534]     {
[10:27:16.534]         {
[10:27:16.534]             ...future.startTime <- base::Sys.time()
[10:27:16.534]             {
[10:27:16.534]                 {
[10:27:16.534]                   {
[10:27:16.534]                     {
[10:27:16.534]                       base::local({
[10:27:16.534]                         has_future <- base::requireNamespace("future", 
[10:27:16.534]                           quietly = TRUE)
[10:27:16.534]                         if (has_future) {
[10:27:16.534]                           ns <- base::getNamespace("future")
[10:27:16.534]                           version <- ns[[".package"]][["version"]]
[10:27:16.534]                           if (is.null(version)) 
[10:27:16.534]                             version <- utils::packageVersion("future")
[10:27:16.534]                         }
[10:27:16.534]                         else {
[10:27:16.534]                           version <- NULL
[10:27:16.534]                         }
[10:27:16.534]                         if (!has_future || version < "1.8.0") {
[10:27:16.534]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:16.534]                             "", base::R.version$version.string), 
[10:27:16.534]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:16.534]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:16.534]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:16.534]                               "release", "version")], collapse = " "), 
[10:27:16.534]                             hostname = base::Sys.info()[["nodename"]])
[10:27:16.534]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:16.534]                             info)
[10:27:16.534]                           info <- base::paste(info, collapse = "; ")
[10:27:16.534]                           if (!has_future) {
[10:27:16.534]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:16.534]                               info)
[10:27:16.534]                           }
[10:27:16.534]                           else {
[10:27:16.534]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:16.534]                               info, version)
[10:27:16.534]                           }
[10:27:16.534]                           base::stop(msg)
[10:27:16.534]                         }
[10:27:16.534]                       })
[10:27:16.534]                     }
[10:27:16.534]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:16.534]                     base::options(mc.cores = 1L)
[10:27:16.534]                   }
[10:27:16.534]                   options(future.plan = NULL)
[10:27:16.534]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:16.534]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:16.534]                 }
[10:27:16.534]                 ...future.workdir <- getwd()
[10:27:16.534]             }
[10:27:16.534]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:16.534]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:16.534]         }
[10:27:16.534]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:16.534]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:16.534]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:16.534]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:16.534]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:16.534]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:16.534]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:16.534]             base::names(...future.oldOptions))
[10:27:16.534]     }
[10:27:16.534]     if (FALSE) {
[10:27:16.534]     }
[10:27:16.534]     else {
[10:27:16.534]         if (TRUE) {
[10:27:16.534]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:16.534]                 open = "w")
[10:27:16.534]         }
[10:27:16.534]         else {
[10:27:16.534]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:16.534]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:16.534]         }
[10:27:16.534]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:16.534]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:16.534]             base::sink(type = "output", split = FALSE)
[10:27:16.534]             base::close(...future.stdout)
[10:27:16.534]         }, add = TRUE)
[10:27:16.534]     }
[10:27:16.534]     ...future.frame <- base::sys.nframe()
[10:27:16.534]     ...future.conditions <- base::list()
[10:27:16.534]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:16.534]     if (FALSE) {
[10:27:16.534]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:16.534]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:16.534]     }
[10:27:16.534]     ...future.result <- base::tryCatch({
[10:27:16.534]         base::withCallingHandlers({
[10:27:16.534]             ...future.value <- base::withVisible(base::local({
[10:27:16.534]                 ...future.makeSendCondition <- base::local({
[10:27:16.534]                   sendCondition <- NULL
[10:27:16.534]                   function(frame = 1L) {
[10:27:16.534]                     if (is.function(sendCondition)) 
[10:27:16.534]                       return(sendCondition)
[10:27:16.534]                     ns <- getNamespace("parallel")
[10:27:16.534]                     if (exists("sendData", mode = "function", 
[10:27:16.534]                       envir = ns)) {
[10:27:16.534]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:16.534]                         envir = ns)
[10:27:16.534]                       envir <- sys.frame(frame)
[10:27:16.534]                       master <- NULL
[10:27:16.534]                       while (!identical(envir, .GlobalEnv) && 
[10:27:16.534]                         !identical(envir, emptyenv())) {
[10:27:16.534]                         if (exists("master", mode = "list", envir = envir, 
[10:27:16.534]                           inherits = FALSE)) {
[10:27:16.534]                           master <- get("master", mode = "list", 
[10:27:16.534]                             envir = envir, inherits = FALSE)
[10:27:16.534]                           if (inherits(master, c("SOCKnode", 
[10:27:16.534]                             "SOCK0node"))) {
[10:27:16.534]                             sendCondition <<- function(cond) {
[10:27:16.534]                               data <- list(type = "VALUE", value = cond, 
[10:27:16.534]                                 success = TRUE)
[10:27:16.534]                               parallel_sendData(master, data)
[10:27:16.534]                             }
[10:27:16.534]                             return(sendCondition)
[10:27:16.534]                           }
[10:27:16.534]                         }
[10:27:16.534]                         frame <- frame + 1L
[10:27:16.534]                         envir <- sys.frame(frame)
[10:27:16.534]                       }
[10:27:16.534]                     }
[10:27:16.534]                     sendCondition <<- function(cond) NULL
[10:27:16.534]                   }
[10:27:16.534]                 })
[10:27:16.534]                 withCallingHandlers({
[10:27:16.534]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:27:16.534]                 }, immediateCondition = function(cond) {
[10:27:16.534]                   sendCondition <- ...future.makeSendCondition()
[10:27:16.534]                   sendCondition(cond)
[10:27:16.534]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:16.534]                   {
[10:27:16.534]                     inherits <- base::inherits
[10:27:16.534]                     invokeRestart <- base::invokeRestart
[10:27:16.534]                     is.null <- base::is.null
[10:27:16.534]                     muffled <- FALSE
[10:27:16.534]                     if (inherits(cond, "message")) {
[10:27:16.534]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:16.534]                       if (muffled) 
[10:27:16.534]                         invokeRestart("muffleMessage")
[10:27:16.534]                     }
[10:27:16.534]                     else if (inherits(cond, "warning")) {
[10:27:16.534]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:16.534]                       if (muffled) 
[10:27:16.534]                         invokeRestart("muffleWarning")
[10:27:16.534]                     }
[10:27:16.534]                     else if (inherits(cond, "condition")) {
[10:27:16.534]                       if (!is.null(pattern)) {
[10:27:16.534]                         computeRestarts <- base::computeRestarts
[10:27:16.534]                         grepl <- base::grepl
[10:27:16.534]                         restarts <- computeRestarts(cond)
[10:27:16.534]                         for (restart in restarts) {
[10:27:16.534]                           name <- restart$name
[10:27:16.534]                           if (is.null(name)) 
[10:27:16.534]                             next
[10:27:16.534]                           if (!grepl(pattern, name)) 
[10:27:16.534]                             next
[10:27:16.534]                           invokeRestart(restart)
[10:27:16.534]                           muffled <- TRUE
[10:27:16.534]                           break
[10:27:16.534]                         }
[10:27:16.534]                       }
[10:27:16.534]                     }
[10:27:16.534]                     invisible(muffled)
[10:27:16.534]                   }
[10:27:16.534]                   muffleCondition(cond)
[10:27:16.534]                 })
[10:27:16.534]             }))
[10:27:16.534]             future::FutureResult(value = ...future.value$value, 
[10:27:16.534]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:16.534]                   ...future.rng), globalenv = if (FALSE) 
[10:27:16.534]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:16.534]                     ...future.globalenv.names))
[10:27:16.534]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:16.534]         }, condition = base::local({
[10:27:16.534]             c <- base::c
[10:27:16.534]             inherits <- base::inherits
[10:27:16.534]             invokeRestart <- base::invokeRestart
[10:27:16.534]             length <- base::length
[10:27:16.534]             list <- base::list
[10:27:16.534]             seq.int <- base::seq.int
[10:27:16.534]             signalCondition <- base::signalCondition
[10:27:16.534]             sys.calls <- base::sys.calls
[10:27:16.534]             `[[` <- base::`[[`
[10:27:16.534]             `+` <- base::`+`
[10:27:16.534]             `<<-` <- base::`<<-`
[10:27:16.534]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:16.534]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:16.534]                   3L)]
[10:27:16.534]             }
[10:27:16.534]             function(cond) {
[10:27:16.534]                 is_error <- inherits(cond, "error")
[10:27:16.534]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:16.534]                   NULL)
[10:27:16.534]                 if (is_error) {
[10:27:16.534]                   sessionInformation <- function() {
[10:27:16.534]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:16.534]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:16.534]                       search = base::search(), system = base::Sys.info())
[10:27:16.534]                   }
[10:27:16.534]                   ...future.conditions[[length(...future.conditions) + 
[10:27:16.534]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:16.534]                     cond$call), session = sessionInformation(), 
[10:27:16.534]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:16.534]                   signalCondition(cond)
[10:27:16.534]                 }
[10:27:16.534]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:16.534]                 "immediateCondition"))) {
[10:27:16.534]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:16.534]                   ...future.conditions[[length(...future.conditions) + 
[10:27:16.534]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:16.534]                   if (TRUE && !signal) {
[10:27:16.534]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:16.534]                     {
[10:27:16.534]                       inherits <- base::inherits
[10:27:16.534]                       invokeRestart <- base::invokeRestart
[10:27:16.534]                       is.null <- base::is.null
[10:27:16.534]                       muffled <- FALSE
[10:27:16.534]                       if (inherits(cond, "message")) {
[10:27:16.534]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:16.534]                         if (muffled) 
[10:27:16.534]                           invokeRestart("muffleMessage")
[10:27:16.534]                       }
[10:27:16.534]                       else if (inherits(cond, "warning")) {
[10:27:16.534]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:16.534]                         if (muffled) 
[10:27:16.534]                           invokeRestart("muffleWarning")
[10:27:16.534]                       }
[10:27:16.534]                       else if (inherits(cond, "condition")) {
[10:27:16.534]                         if (!is.null(pattern)) {
[10:27:16.534]                           computeRestarts <- base::computeRestarts
[10:27:16.534]                           grepl <- base::grepl
[10:27:16.534]                           restarts <- computeRestarts(cond)
[10:27:16.534]                           for (restart in restarts) {
[10:27:16.534]                             name <- restart$name
[10:27:16.534]                             if (is.null(name)) 
[10:27:16.534]                               next
[10:27:16.534]                             if (!grepl(pattern, name)) 
[10:27:16.534]                               next
[10:27:16.534]                             invokeRestart(restart)
[10:27:16.534]                             muffled <- TRUE
[10:27:16.534]                             break
[10:27:16.534]                           }
[10:27:16.534]                         }
[10:27:16.534]                       }
[10:27:16.534]                       invisible(muffled)
[10:27:16.534]                     }
[10:27:16.534]                     muffleCondition(cond, pattern = "^muffle")
[10:27:16.534]                   }
[10:27:16.534]                 }
[10:27:16.534]                 else {
[10:27:16.534]                   if (TRUE) {
[10:27:16.534]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:16.534]                     {
[10:27:16.534]                       inherits <- base::inherits
[10:27:16.534]                       invokeRestart <- base::invokeRestart
[10:27:16.534]                       is.null <- base::is.null
[10:27:16.534]                       muffled <- FALSE
[10:27:16.534]                       if (inherits(cond, "message")) {
[10:27:16.534]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:16.534]                         if (muffled) 
[10:27:16.534]                           invokeRestart("muffleMessage")
[10:27:16.534]                       }
[10:27:16.534]                       else if (inherits(cond, "warning")) {
[10:27:16.534]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:16.534]                         if (muffled) 
[10:27:16.534]                           invokeRestart("muffleWarning")
[10:27:16.534]                       }
[10:27:16.534]                       else if (inherits(cond, "condition")) {
[10:27:16.534]                         if (!is.null(pattern)) {
[10:27:16.534]                           computeRestarts <- base::computeRestarts
[10:27:16.534]                           grepl <- base::grepl
[10:27:16.534]                           restarts <- computeRestarts(cond)
[10:27:16.534]                           for (restart in restarts) {
[10:27:16.534]                             name <- restart$name
[10:27:16.534]                             if (is.null(name)) 
[10:27:16.534]                               next
[10:27:16.534]                             if (!grepl(pattern, name)) 
[10:27:16.534]                               next
[10:27:16.534]                             invokeRestart(restart)
[10:27:16.534]                             muffled <- TRUE
[10:27:16.534]                             break
[10:27:16.534]                           }
[10:27:16.534]                         }
[10:27:16.534]                       }
[10:27:16.534]                       invisible(muffled)
[10:27:16.534]                     }
[10:27:16.534]                     muffleCondition(cond, pattern = "^muffle")
[10:27:16.534]                   }
[10:27:16.534]                 }
[10:27:16.534]             }
[10:27:16.534]         }))
[10:27:16.534]     }, error = function(ex) {
[10:27:16.534]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:16.534]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:16.534]                 ...future.rng), started = ...future.startTime, 
[10:27:16.534]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:16.534]             version = "1.8"), class = "FutureResult")
[10:27:16.534]     }, finally = {
[10:27:16.534]         if (!identical(...future.workdir, getwd())) 
[10:27:16.534]             setwd(...future.workdir)
[10:27:16.534]         {
[10:27:16.534]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:16.534]                 ...future.oldOptions$nwarnings <- NULL
[10:27:16.534]             }
[10:27:16.534]             base::options(...future.oldOptions)
[10:27:16.534]             if (.Platform$OS.type == "windows") {
[10:27:16.534]                 old_names <- names(...future.oldEnvVars)
[10:27:16.534]                 envs <- base::Sys.getenv()
[10:27:16.534]                 names <- names(envs)
[10:27:16.534]                 common <- intersect(names, old_names)
[10:27:16.534]                 added <- setdiff(names, old_names)
[10:27:16.534]                 removed <- setdiff(old_names, names)
[10:27:16.534]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:16.534]                   envs[common]]
[10:27:16.534]                 NAMES <- toupper(changed)
[10:27:16.534]                 args <- list()
[10:27:16.534]                 for (kk in seq_along(NAMES)) {
[10:27:16.534]                   name <- changed[[kk]]
[10:27:16.534]                   NAME <- NAMES[[kk]]
[10:27:16.534]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:16.534]                     next
[10:27:16.534]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:16.534]                 }
[10:27:16.534]                 NAMES <- toupper(added)
[10:27:16.534]                 for (kk in seq_along(NAMES)) {
[10:27:16.534]                   name <- added[[kk]]
[10:27:16.534]                   NAME <- NAMES[[kk]]
[10:27:16.534]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:16.534]                     next
[10:27:16.534]                   args[[name]] <- ""
[10:27:16.534]                 }
[10:27:16.534]                 NAMES <- toupper(removed)
[10:27:16.534]                 for (kk in seq_along(NAMES)) {
[10:27:16.534]                   name <- removed[[kk]]
[10:27:16.534]                   NAME <- NAMES[[kk]]
[10:27:16.534]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:16.534]                     next
[10:27:16.534]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:16.534]                 }
[10:27:16.534]                 if (length(args) > 0) 
[10:27:16.534]                   base::do.call(base::Sys.setenv, args = args)
[10:27:16.534]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:16.534]             }
[10:27:16.534]             else {
[10:27:16.534]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:16.534]             }
[10:27:16.534]             {
[10:27:16.534]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:16.534]                   0L) {
[10:27:16.534]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:16.534]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:16.534]                   base::options(opts)
[10:27:16.534]                 }
[10:27:16.534]                 {
[10:27:16.534]                   {
[10:27:16.534]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:16.534]                     NULL
[10:27:16.534]                   }
[10:27:16.534]                   options(future.plan = NULL)
[10:27:16.534]                   if (is.na(NA_character_)) 
[10:27:16.534]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:16.534]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:16.534]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:16.534]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:16.534]                     envir = parent.frame()) 
[10:27:16.534]                   {
[10:27:16.534]                     if (is.function(workers)) 
[10:27:16.534]                       workers <- workers()
[10:27:16.534]                     workers <- structure(as.integer(workers), 
[10:27:16.534]                       class = class(workers))
[10:27:16.534]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:16.534]                       workers >= 1)
[10:27:16.534]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:16.534]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:16.534]                     }
[10:27:16.534]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:16.534]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:16.534]                       envir = envir)
[10:27:16.534]                     if (!future$lazy) 
[10:27:16.534]                       future <- run(future)
[10:27:16.534]                     invisible(future)
[10:27:16.534]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:16.534]                 }
[10:27:16.534]             }
[10:27:16.534]         }
[10:27:16.534]     })
[10:27:16.534]     if (TRUE) {
[10:27:16.534]         base::sink(type = "output", split = FALSE)
[10:27:16.534]         if (TRUE) {
[10:27:16.534]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:16.534]         }
[10:27:16.534]         else {
[10:27:16.534]             ...future.result["stdout"] <- base::list(NULL)
[10:27:16.534]         }
[10:27:16.534]         base::close(...future.stdout)
[10:27:16.534]         ...future.stdout <- NULL
[10:27:16.534]     }
[10:27:16.534]     ...future.result$conditions <- ...future.conditions
[10:27:16.534]     ...future.result$finished <- base::Sys.time()
[10:27:16.534]     ...future.result
[10:27:16.534] }
[10:27:16.537] MultisessionFuture started
[10:27:16.537] - Launch lazy future ... done
[10:27:16.537] run() for ‘MultisessionFuture’ ... done
[10:27:16.584] receiveMessageFromWorker() for ClusterFuture ...
[10:27:16.584] - Validating connection of MultisessionFuture
[10:27:16.584] - received message: FutureResult
[10:27:16.585] - Received FutureResult
[10:27:16.585] - Erased future from FutureRegistry
[10:27:16.585] result() for ClusterFuture ...
[10:27:16.585] - result already collected: FutureResult
[10:27:16.585] result() for ClusterFuture ... done
[10:27:16.585] signalConditions() ...
[10:27:16.585]  - include = ‘immediateCondition’
[10:27:16.585]  - exclude = 
[10:27:16.585]  - resignal = FALSE
[10:27:16.586]  - Number of conditions: 1
[10:27:16.586] signalConditions() ... done
[10:27:16.586] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:16.586] A MultisessionFuture was resolved
[10:27:16.586] getGlobalsAndPackages() ...
[10:27:16.586] Searching for globals...
[10:27:16.587] - globals found: [2] ‘list’, ‘stop’
[10:27:16.587] Searching for globals ... DONE
[10:27:16.587] Resolving globals: FALSE
[10:27:16.587] 
[10:27:16.587] 
[10:27:16.588] getGlobalsAndPackages() ... DONE
[10:27:16.588] run() for ‘Future’ ...
[10:27:16.588] - state: ‘created’
[10:27:16.588] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:16.602] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:16.602] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:16.602]   - Field: ‘node’
[10:27:16.602]   - Field: ‘label’
[10:27:16.602]   - Field: ‘local’
[10:27:16.602]   - Field: ‘owner’
[10:27:16.602]   - Field: ‘envir’
[10:27:16.603]   - Field: ‘workers’
[10:27:16.603]   - Field: ‘packages’
[10:27:16.603]   - Field: ‘gc’
[10:27:16.603]   - Field: ‘conditions’
[10:27:16.603]   - Field: ‘persistent’
[10:27:16.603]   - Field: ‘expr’
[10:27:16.603]   - Field: ‘uuid’
[10:27:16.603]   - Field: ‘seed’
[10:27:16.603]   - Field: ‘version’
[10:27:16.603]   - Field: ‘result’
[10:27:16.603]   - Field: ‘asynchronous’
[10:27:16.604]   - Field: ‘calls’
[10:27:16.604]   - Field: ‘globals’
[10:27:16.604]   - Field: ‘stdout’
[10:27:16.604]   - Field: ‘earlySignal’
[10:27:16.604]   - Field: ‘lazy’
[10:27:16.604]   - Field: ‘state’
[10:27:16.604] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:16.604] - Launch lazy future ...
[10:27:16.604] Packages needed by the future expression (n = 0): <none>
[10:27:16.605] Packages needed by future strategies (n = 0): <none>
[10:27:16.605] {
[10:27:16.605]     {
[10:27:16.605]         {
[10:27:16.605]             ...future.startTime <- base::Sys.time()
[10:27:16.605]             {
[10:27:16.605]                 {
[10:27:16.605]                   {
[10:27:16.605]                     {
[10:27:16.605]                       base::local({
[10:27:16.605]                         has_future <- base::requireNamespace("future", 
[10:27:16.605]                           quietly = TRUE)
[10:27:16.605]                         if (has_future) {
[10:27:16.605]                           ns <- base::getNamespace("future")
[10:27:16.605]                           version <- ns[[".package"]][["version"]]
[10:27:16.605]                           if (is.null(version)) 
[10:27:16.605]                             version <- utils::packageVersion("future")
[10:27:16.605]                         }
[10:27:16.605]                         else {
[10:27:16.605]                           version <- NULL
[10:27:16.605]                         }
[10:27:16.605]                         if (!has_future || version < "1.8.0") {
[10:27:16.605]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:16.605]                             "", base::R.version$version.string), 
[10:27:16.605]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:16.605]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:16.605]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:16.605]                               "release", "version")], collapse = " "), 
[10:27:16.605]                             hostname = base::Sys.info()[["nodename"]])
[10:27:16.605]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:16.605]                             info)
[10:27:16.605]                           info <- base::paste(info, collapse = "; ")
[10:27:16.605]                           if (!has_future) {
[10:27:16.605]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:16.605]                               info)
[10:27:16.605]                           }
[10:27:16.605]                           else {
[10:27:16.605]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:16.605]                               info, version)
[10:27:16.605]                           }
[10:27:16.605]                           base::stop(msg)
[10:27:16.605]                         }
[10:27:16.605]                       })
[10:27:16.605]                     }
[10:27:16.605]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:16.605]                     base::options(mc.cores = 1L)
[10:27:16.605]                   }
[10:27:16.605]                   options(future.plan = NULL)
[10:27:16.605]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:16.605]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:16.605]                 }
[10:27:16.605]                 ...future.workdir <- getwd()
[10:27:16.605]             }
[10:27:16.605]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:16.605]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:16.605]         }
[10:27:16.605]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:16.605]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:16.605]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:16.605]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:16.605]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:16.605]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:16.605]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:16.605]             base::names(...future.oldOptions))
[10:27:16.605]     }
[10:27:16.605]     if (FALSE) {
[10:27:16.605]     }
[10:27:16.605]     else {
[10:27:16.605]         if (TRUE) {
[10:27:16.605]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:16.605]                 open = "w")
[10:27:16.605]         }
[10:27:16.605]         else {
[10:27:16.605]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:16.605]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:16.605]         }
[10:27:16.605]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:16.605]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:16.605]             base::sink(type = "output", split = FALSE)
[10:27:16.605]             base::close(...future.stdout)
[10:27:16.605]         }, add = TRUE)
[10:27:16.605]     }
[10:27:16.605]     ...future.frame <- base::sys.nframe()
[10:27:16.605]     ...future.conditions <- base::list()
[10:27:16.605]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:16.605]     if (FALSE) {
[10:27:16.605]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:16.605]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:16.605]     }
[10:27:16.605]     ...future.result <- base::tryCatch({
[10:27:16.605]         base::withCallingHandlers({
[10:27:16.605]             ...future.value <- base::withVisible(base::local({
[10:27:16.605]                 ...future.makeSendCondition <- base::local({
[10:27:16.605]                   sendCondition <- NULL
[10:27:16.605]                   function(frame = 1L) {
[10:27:16.605]                     if (is.function(sendCondition)) 
[10:27:16.605]                       return(sendCondition)
[10:27:16.605]                     ns <- getNamespace("parallel")
[10:27:16.605]                     if (exists("sendData", mode = "function", 
[10:27:16.605]                       envir = ns)) {
[10:27:16.605]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:16.605]                         envir = ns)
[10:27:16.605]                       envir <- sys.frame(frame)
[10:27:16.605]                       master <- NULL
[10:27:16.605]                       while (!identical(envir, .GlobalEnv) && 
[10:27:16.605]                         !identical(envir, emptyenv())) {
[10:27:16.605]                         if (exists("master", mode = "list", envir = envir, 
[10:27:16.605]                           inherits = FALSE)) {
[10:27:16.605]                           master <- get("master", mode = "list", 
[10:27:16.605]                             envir = envir, inherits = FALSE)
[10:27:16.605]                           if (inherits(master, c("SOCKnode", 
[10:27:16.605]                             "SOCK0node"))) {
[10:27:16.605]                             sendCondition <<- function(cond) {
[10:27:16.605]                               data <- list(type = "VALUE", value = cond, 
[10:27:16.605]                                 success = TRUE)
[10:27:16.605]                               parallel_sendData(master, data)
[10:27:16.605]                             }
[10:27:16.605]                             return(sendCondition)
[10:27:16.605]                           }
[10:27:16.605]                         }
[10:27:16.605]                         frame <- frame + 1L
[10:27:16.605]                         envir <- sys.frame(frame)
[10:27:16.605]                       }
[10:27:16.605]                     }
[10:27:16.605]                     sendCondition <<- function(cond) NULL
[10:27:16.605]                   }
[10:27:16.605]                 })
[10:27:16.605]                 withCallingHandlers({
[10:27:16.605]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:27:16.605]                 }, immediateCondition = function(cond) {
[10:27:16.605]                   sendCondition <- ...future.makeSendCondition()
[10:27:16.605]                   sendCondition(cond)
[10:27:16.605]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:16.605]                   {
[10:27:16.605]                     inherits <- base::inherits
[10:27:16.605]                     invokeRestart <- base::invokeRestart
[10:27:16.605]                     is.null <- base::is.null
[10:27:16.605]                     muffled <- FALSE
[10:27:16.605]                     if (inherits(cond, "message")) {
[10:27:16.605]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:16.605]                       if (muffled) 
[10:27:16.605]                         invokeRestart("muffleMessage")
[10:27:16.605]                     }
[10:27:16.605]                     else if (inherits(cond, "warning")) {
[10:27:16.605]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:16.605]                       if (muffled) 
[10:27:16.605]                         invokeRestart("muffleWarning")
[10:27:16.605]                     }
[10:27:16.605]                     else if (inherits(cond, "condition")) {
[10:27:16.605]                       if (!is.null(pattern)) {
[10:27:16.605]                         computeRestarts <- base::computeRestarts
[10:27:16.605]                         grepl <- base::grepl
[10:27:16.605]                         restarts <- computeRestarts(cond)
[10:27:16.605]                         for (restart in restarts) {
[10:27:16.605]                           name <- restart$name
[10:27:16.605]                           if (is.null(name)) 
[10:27:16.605]                             next
[10:27:16.605]                           if (!grepl(pattern, name)) 
[10:27:16.605]                             next
[10:27:16.605]                           invokeRestart(restart)
[10:27:16.605]                           muffled <- TRUE
[10:27:16.605]                           break
[10:27:16.605]                         }
[10:27:16.605]                       }
[10:27:16.605]                     }
[10:27:16.605]                     invisible(muffled)
[10:27:16.605]                   }
[10:27:16.605]                   muffleCondition(cond)
[10:27:16.605]                 })
[10:27:16.605]             }))
[10:27:16.605]             future::FutureResult(value = ...future.value$value, 
[10:27:16.605]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:16.605]                   ...future.rng), globalenv = if (FALSE) 
[10:27:16.605]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:16.605]                     ...future.globalenv.names))
[10:27:16.605]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:16.605]         }, condition = base::local({
[10:27:16.605]             c <- base::c
[10:27:16.605]             inherits <- base::inherits
[10:27:16.605]             invokeRestart <- base::invokeRestart
[10:27:16.605]             length <- base::length
[10:27:16.605]             list <- base::list
[10:27:16.605]             seq.int <- base::seq.int
[10:27:16.605]             signalCondition <- base::signalCondition
[10:27:16.605]             sys.calls <- base::sys.calls
[10:27:16.605]             `[[` <- base::`[[`
[10:27:16.605]             `+` <- base::`+`
[10:27:16.605]             `<<-` <- base::`<<-`
[10:27:16.605]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:16.605]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:16.605]                   3L)]
[10:27:16.605]             }
[10:27:16.605]             function(cond) {
[10:27:16.605]                 is_error <- inherits(cond, "error")
[10:27:16.605]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:16.605]                   NULL)
[10:27:16.605]                 if (is_error) {
[10:27:16.605]                   sessionInformation <- function() {
[10:27:16.605]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:16.605]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:16.605]                       search = base::search(), system = base::Sys.info())
[10:27:16.605]                   }
[10:27:16.605]                   ...future.conditions[[length(...future.conditions) + 
[10:27:16.605]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:16.605]                     cond$call), session = sessionInformation(), 
[10:27:16.605]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:16.605]                   signalCondition(cond)
[10:27:16.605]                 }
[10:27:16.605]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:16.605]                 "immediateCondition"))) {
[10:27:16.605]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:16.605]                   ...future.conditions[[length(...future.conditions) + 
[10:27:16.605]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:16.605]                   if (TRUE && !signal) {
[10:27:16.605]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:16.605]                     {
[10:27:16.605]                       inherits <- base::inherits
[10:27:16.605]                       invokeRestart <- base::invokeRestart
[10:27:16.605]                       is.null <- base::is.null
[10:27:16.605]                       muffled <- FALSE
[10:27:16.605]                       if (inherits(cond, "message")) {
[10:27:16.605]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:16.605]                         if (muffled) 
[10:27:16.605]                           invokeRestart("muffleMessage")
[10:27:16.605]                       }
[10:27:16.605]                       else if (inherits(cond, "warning")) {
[10:27:16.605]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:16.605]                         if (muffled) 
[10:27:16.605]                           invokeRestart("muffleWarning")
[10:27:16.605]                       }
[10:27:16.605]                       else if (inherits(cond, "condition")) {
[10:27:16.605]                         if (!is.null(pattern)) {
[10:27:16.605]                           computeRestarts <- base::computeRestarts
[10:27:16.605]                           grepl <- base::grepl
[10:27:16.605]                           restarts <- computeRestarts(cond)
[10:27:16.605]                           for (restart in restarts) {
[10:27:16.605]                             name <- restart$name
[10:27:16.605]                             if (is.null(name)) 
[10:27:16.605]                               next
[10:27:16.605]                             if (!grepl(pattern, name)) 
[10:27:16.605]                               next
[10:27:16.605]                             invokeRestart(restart)
[10:27:16.605]                             muffled <- TRUE
[10:27:16.605]                             break
[10:27:16.605]                           }
[10:27:16.605]                         }
[10:27:16.605]                       }
[10:27:16.605]                       invisible(muffled)
[10:27:16.605]                     }
[10:27:16.605]                     muffleCondition(cond, pattern = "^muffle")
[10:27:16.605]                   }
[10:27:16.605]                 }
[10:27:16.605]                 else {
[10:27:16.605]                   if (TRUE) {
[10:27:16.605]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:16.605]                     {
[10:27:16.605]                       inherits <- base::inherits
[10:27:16.605]                       invokeRestart <- base::invokeRestart
[10:27:16.605]                       is.null <- base::is.null
[10:27:16.605]                       muffled <- FALSE
[10:27:16.605]                       if (inherits(cond, "message")) {
[10:27:16.605]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:16.605]                         if (muffled) 
[10:27:16.605]                           invokeRestart("muffleMessage")
[10:27:16.605]                       }
[10:27:16.605]                       else if (inherits(cond, "warning")) {
[10:27:16.605]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:16.605]                         if (muffled) 
[10:27:16.605]                           invokeRestart("muffleWarning")
[10:27:16.605]                       }
[10:27:16.605]                       else if (inherits(cond, "condition")) {
[10:27:16.605]                         if (!is.null(pattern)) {
[10:27:16.605]                           computeRestarts <- base::computeRestarts
[10:27:16.605]                           grepl <- base::grepl
[10:27:16.605]                           restarts <- computeRestarts(cond)
[10:27:16.605]                           for (restart in restarts) {
[10:27:16.605]                             name <- restart$name
[10:27:16.605]                             if (is.null(name)) 
[10:27:16.605]                               next
[10:27:16.605]                             if (!grepl(pattern, name)) 
[10:27:16.605]                               next
[10:27:16.605]                             invokeRestart(restart)
[10:27:16.605]                             muffled <- TRUE
[10:27:16.605]                             break
[10:27:16.605]                           }
[10:27:16.605]                         }
[10:27:16.605]                       }
[10:27:16.605]                       invisible(muffled)
[10:27:16.605]                     }
[10:27:16.605]                     muffleCondition(cond, pattern = "^muffle")
[10:27:16.605]                   }
[10:27:16.605]                 }
[10:27:16.605]             }
[10:27:16.605]         }))
[10:27:16.605]     }, error = function(ex) {
[10:27:16.605]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:16.605]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:16.605]                 ...future.rng), started = ...future.startTime, 
[10:27:16.605]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:16.605]             version = "1.8"), class = "FutureResult")
[10:27:16.605]     }, finally = {
[10:27:16.605]         if (!identical(...future.workdir, getwd())) 
[10:27:16.605]             setwd(...future.workdir)
[10:27:16.605]         {
[10:27:16.605]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:16.605]                 ...future.oldOptions$nwarnings <- NULL
[10:27:16.605]             }
[10:27:16.605]             base::options(...future.oldOptions)
[10:27:16.605]             if (.Platform$OS.type == "windows") {
[10:27:16.605]                 old_names <- names(...future.oldEnvVars)
[10:27:16.605]                 envs <- base::Sys.getenv()
[10:27:16.605]                 names <- names(envs)
[10:27:16.605]                 common <- intersect(names, old_names)
[10:27:16.605]                 added <- setdiff(names, old_names)
[10:27:16.605]                 removed <- setdiff(old_names, names)
[10:27:16.605]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:16.605]                   envs[common]]
[10:27:16.605]                 NAMES <- toupper(changed)
[10:27:16.605]                 args <- list()
[10:27:16.605]                 for (kk in seq_along(NAMES)) {
[10:27:16.605]                   name <- changed[[kk]]
[10:27:16.605]                   NAME <- NAMES[[kk]]
[10:27:16.605]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:16.605]                     next
[10:27:16.605]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:16.605]                 }
[10:27:16.605]                 NAMES <- toupper(added)
[10:27:16.605]                 for (kk in seq_along(NAMES)) {
[10:27:16.605]                   name <- added[[kk]]
[10:27:16.605]                   NAME <- NAMES[[kk]]
[10:27:16.605]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:16.605]                     next
[10:27:16.605]                   args[[name]] <- ""
[10:27:16.605]                 }
[10:27:16.605]                 NAMES <- toupper(removed)
[10:27:16.605]                 for (kk in seq_along(NAMES)) {
[10:27:16.605]                   name <- removed[[kk]]
[10:27:16.605]                   NAME <- NAMES[[kk]]
[10:27:16.605]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:16.605]                     next
[10:27:16.605]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:16.605]                 }
[10:27:16.605]                 if (length(args) > 0) 
[10:27:16.605]                   base::do.call(base::Sys.setenv, args = args)
[10:27:16.605]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:16.605]             }
[10:27:16.605]             else {
[10:27:16.605]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:16.605]             }
[10:27:16.605]             {
[10:27:16.605]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:16.605]                   0L) {
[10:27:16.605]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:16.605]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:16.605]                   base::options(opts)
[10:27:16.605]                 }
[10:27:16.605]                 {
[10:27:16.605]                   {
[10:27:16.605]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:16.605]                     NULL
[10:27:16.605]                   }
[10:27:16.605]                   options(future.plan = NULL)
[10:27:16.605]                   if (is.na(NA_character_)) 
[10:27:16.605]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:16.605]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:16.605]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:16.605]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:16.605]                     envir = parent.frame()) 
[10:27:16.605]                   {
[10:27:16.605]                     if (is.function(workers)) 
[10:27:16.605]                       workers <- workers()
[10:27:16.605]                     workers <- structure(as.integer(workers), 
[10:27:16.605]                       class = class(workers))
[10:27:16.605]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:16.605]                       workers >= 1)
[10:27:16.605]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:16.605]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:16.605]                     }
[10:27:16.605]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:16.605]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:16.605]                       envir = envir)
[10:27:16.605]                     if (!future$lazy) 
[10:27:16.605]                       future <- run(future)
[10:27:16.605]                     invisible(future)
[10:27:16.605]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:16.605]                 }
[10:27:16.605]             }
[10:27:16.605]         }
[10:27:16.605]     })
[10:27:16.605]     if (TRUE) {
[10:27:16.605]         base::sink(type = "output", split = FALSE)
[10:27:16.605]         if (TRUE) {
[10:27:16.605]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:16.605]         }
[10:27:16.605]         else {
[10:27:16.605]             ...future.result["stdout"] <- base::list(NULL)
[10:27:16.605]         }
[10:27:16.605]         base::close(...future.stdout)
[10:27:16.605]         ...future.stdout <- NULL
[10:27:16.605]     }
[10:27:16.605]     ...future.result$conditions <- ...future.conditions
[10:27:16.605]     ...future.result$finished <- base::Sys.time()
[10:27:16.605]     ...future.result
[10:27:16.605] }
[10:27:16.608] MultisessionFuture started
[10:27:16.608] - Launch lazy future ... done
[10:27:16.609] run() for ‘MultisessionFuture’ ... done
[10:27:16.654] receiveMessageFromWorker() for ClusterFuture ...
[10:27:16.655] - Validating connection of MultisessionFuture
[10:27:16.655] - received message: FutureResult
[10:27:16.655] - Received FutureResult
[10:27:16.655] - Erased future from FutureRegistry
[10:27:16.656] result() for ClusterFuture ...
[10:27:16.656] - result already collected: FutureResult
[10:27:16.656] result() for ClusterFuture ... done
[10:27:16.656] signalConditions() ...
[10:27:16.656]  - include = ‘immediateCondition’
[10:27:16.656]  - exclude = 
[10:27:16.656]  - resignal = FALSE
[10:27:16.656]  - Number of conditions: 1
[10:27:16.656] signalConditions() ... done
[10:27:16.656] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:16.657] A MultisessionFuture was resolved
- result = TRUE, recursive = 0 ... DONE
- result = TRUE, recursive = 1 ...
[10:27:16.657] getGlobalsAndPackages() ...
[10:27:16.657] Searching for globals...
[10:27:16.658] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:27:16.658] Searching for globals ... DONE
[10:27:16.658] Resolving globals: FALSE
[10:27:16.659] 
[10:27:16.659] 
[10:27:16.659] getGlobalsAndPackages() ... DONE
[10:27:16.659] run() for ‘Future’ ...
[10:27:16.659] - state: ‘created’
[10:27:16.659] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:16.673] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:16.673] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:16.673]   - Field: ‘node’
[10:27:16.674]   - Field: ‘label’
[10:27:16.674]   - Field: ‘local’
[10:27:16.674]   - Field: ‘owner’
[10:27:16.674]   - Field: ‘envir’
[10:27:16.674]   - Field: ‘workers’
[10:27:16.674]   - Field: ‘packages’
[10:27:16.674]   - Field: ‘gc’
[10:27:16.674]   - Field: ‘conditions’
[10:27:16.674]   - Field: ‘persistent’
[10:27:16.674]   - Field: ‘expr’
[10:27:16.674]   - Field: ‘uuid’
[10:27:16.675]   - Field: ‘seed’
[10:27:16.675]   - Field: ‘version’
[10:27:16.675]   - Field: ‘result’
[10:27:16.675]   - Field: ‘asynchronous’
[10:27:16.675]   - Field: ‘calls’
[10:27:16.675]   - Field: ‘globals’
[10:27:16.675]   - Field: ‘stdout’
[10:27:16.675]   - Field: ‘earlySignal’
[10:27:16.675]   - Field: ‘lazy’
[10:27:16.675]   - Field: ‘state’
[10:27:16.675] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:16.676] - Launch lazy future ...
[10:27:16.676] Packages needed by the future expression (n = 0): <none>
[10:27:16.676] Packages needed by future strategies (n = 0): <none>
[10:27:16.676] {
[10:27:16.676]     {
[10:27:16.676]         {
[10:27:16.676]             ...future.startTime <- base::Sys.time()
[10:27:16.676]             {
[10:27:16.676]                 {
[10:27:16.676]                   {
[10:27:16.676]                     {
[10:27:16.676]                       base::local({
[10:27:16.676]                         has_future <- base::requireNamespace("future", 
[10:27:16.676]                           quietly = TRUE)
[10:27:16.676]                         if (has_future) {
[10:27:16.676]                           ns <- base::getNamespace("future")
[10:27:16.676]                           version <- ns[[".package"]][["version"]]
[10:27:16.676]                           if (is.null(version)) 
[10:27:16.676]                             version <- utils::packageVersion("future")
[10:27:16.676]                         }
[10:27:16.676]                         else {
[10:27:16.676]                           version <- NULL
[10:27:16.676]                         }
[10:27:16.676]                         if (!has_future || version < "1.8.0") {
[10:27:16.676]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:16.676]                             "", base::R.version$version.string), 
[10:27:16.676]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:16.676]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:16.676]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:16.676]                               "release", "version")], collapse = " "), 
[10:27:16.676]                             hostname = base::Sys.info()[["nodename"]])
[10:27:16.676]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:16.676]                             info)
[10:27:16.676]                           info <- base::paste(info, collapse = "; ")
[10:27:16.676]                           if (!has_future) {
[10:27:16.676]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:16.676]                               info)
[10:27:16.676]                           }
[10:27:16.676]                           else {
[10:27:16.676]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:16.676]                               info, version)
[10:27:16.676]                           }
[10:27:16.676]                           base::stop(msg)
[10:27:16.676]                         }
[10:27:16.676]                       })
[10:27:16.676]                     }
[10:27:16.676]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:16.676]                     base::options(mc.cores = 1L)
[10:27:16.676]                   }
[10:27:16.676]                   options(future.plan = NULL)
[10:27:16.676]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:16.676]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:16.676]                 }
[10:27:16.676]                 ...future.workdir <- getwd()
[10:27:16.676]             }
[10:27:16.676]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:16.676]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:16.676]         }
[10:27:16.676]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:16.676]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:16.676]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:16.676]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:16.676]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:16.676]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:16.676]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:16.676]             base::names(...future.oldOptions))
[10:27:16.676]     }
[10:27:16.676]     if (FALSE) {
[10:27:16.676]     }
[10:27:16.676]     else {
[10:27:16.676]         if (TRUE) {
[10:27:16.676]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:16.676]                 open = "w")
[10:27:16.676]         }
[10:27:16.676]         else {
[10:27:16.676]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:16.676]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:16.676]         }
[10:27:16.676]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:16.676]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:16.676]             base::sink(type = "output", split = FALSE)
[10:27:16.676]             base::close(...future.stdout)
[10:27:16.676]         }, add = TRUE)
[10:27:16.676]     }
[10:27:16.676]     ...future.frame <- base::sys.nframe()
[10:27:16.676]     ...future.conditions <- base::list()
[10:27:16.676]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:16.676]     if (FALSE) {
[10:27:16.676]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:16.676]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:16.676]     }
[10:27:16.676]     ...future.result <- base::tryCatch({
[10:27:16.676]         base::withCallingHandlers({
[10:27:16.676]             ...future.value <- base::withVisible(base::local({
[10:27:16.676]                 ...future.makeSendCondition <- base::local({
[10:27:16.676]                   sendCondition <- NULL
[10:27:16.676]                   function(frame = 1L) {
[10:27:16.676]                     if (is.function(sendCondition)) 
[10:27:16.676]                       return(sendCondition)
[10:27:16.676]                     ns <- getNamespace("parallel")
[10:27:16.676]                     if (exists("sendData", mode = "function", 
[10:27:16.676]                       envir = ns)) {
[10:27:16.676]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:16.676]                         envir = ns)
[10:27:16.676]                       envir <- sys.frame(frame)
[10:27:16.676]                       master <- NULL
[10:27:16.676]                       while (!identical(envir, .GlobalEnv) && 
[10:27:16.676]                         !identical(envir, emptyenv())) {
[10:27:16.676]                         if (exists("master", mode = "list", envir = envir, 
[10:27:16.676]                           inherits = FALSE)) {
[10:27:16.676]                           master <- get("master", mode = "list", 
[10:27:16.676]                             envir = envir, inherits = FALSE)
[10:27:16.676]                           if (inherits(master, c("SOCKnode", 
[10:27:16.676]                             "SOCK0node"))) {
[10:27:16.676]                             sendCondition <<- function(cond) {
[10:27:16.676]                               data <- list(type = "VALUE", value = cond, 
[10:27:16.676]                                 success = TRUE)
[10:27:16.676]                               parallel_sendData(master, data)
[10:27:16.676]                             }
[10:27:16.676]                             return(sendCondition)
[10:27:16.676]                           }
[10:27:16.676]                         }
[10:27:16.676]                         frame <- frame + 1L
[10:27:16.676]                         envir <- sys.frame(frame)
[10:27:16.676]                       }
[10:27:16.676]                     }
[10:27:16.676]                     sendCondition <<- function(cond) NULL
[10:27:16.676]                   }
[10:27:16.676]                 })
[10:27:16.676]                 withCallingHandlers({
[10:27:16.676]                   {
[10:27:16.676]                     Sys.sleep(0.5)
[10:27:16.676]                     list(a = 1, b = 42L)
[10:27:16.676]                   }
[10:27:16.676]                 }, immediateCondition = function(cond) {
[10:27:16.676]                   sendCondition <- ...future.makeSendCondition()
[10:27:16.676]                   sendCondition(cond)
[10:27:16.676]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:16.676]                   {
[10:27:16.676]                     inherits <- base::inherits
[10:27:16.676]                     invokeRestart <- base::invokeRestart
[10:27:16.676]                     is.null <- base::is.null
[10:27:16.676]                     muffled <- FALSE
[10:27:16.676]                     if (inherits(cond, "message")) {
[10:27:16.676]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:16.676]                       if (muffled) 
[10:27:16.676]                         invokeRestart("muffleMessage")
[10:27:16.676]                     }
[10:27:16.676]                     else if (inherits(cond, "warning")) {
[10:27:16.676]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:16.676]                       if (muffled) 
[10:27:16.676]                         invokeRestart("muffleWarning")
[10:27:16.676]                     }
[10:27:16.676]                     else if (inherits(cond, "condition")) {
[10:27:16.676]                       if (!is.null(pattern)) {
[10:27:16.676]                         computeRestarts <- base::computeRestarts
[10:27:16.676]                         grepl <- base::grepl
[10:27:16.676]                         restarts <- computeRestarts(cond)
[10:27:16.676]                         for (restart in restarts) {
[10:27:16.676]                           name <- restart$name
[10:27:16.676]                           if (is.null(name)) 
[10:27:16.676]                             next
[10:27:16.676]                           if (!grepl(pattern, name)) 
[10:27:16.676]                             next
[10:27:16.676]                           invokeRestart(restart)
[10:27:16.676]                           muffled <- TRUE
[10:27:16.676]                           break
[10:27:16.676]                         }
[10:27:16.676]                       }
[10:27:16.676]                     }
[10:27:16.676]                     invisible(muffled)
[10:27:16.676]                   }
[10:27:16.676]                   muffleCondition(cond)
[10:27:16.676]                 })
[10:27:16.676]             }))
[10:27:16.676]             future::FutureResult(value = ...future.value$value, 
[10:27:16.676]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:16.676]                   ...future.rng), globalenv = if (FALSE) 
[10:27:16.676]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:16.676]                     ...future.globalenv.names))
[10:27:16.676]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:16.676]         }, condition = base::local({
[10:27:16.676]             c <- base::c
[10:27:16.676]             inherits <- base::inherits
[10:27:16.676]             invokeRestart <- base::invokeRestart
[10:27:16.676]             length <- base::length
[10:27:16.676]             list <- base::list
[10:27:16.676]             seq.int <- base::seq.int
[10:27:16.676]             signalCondition <- base::signalCondition
[10:27:16.676]             sys.calls <- base::sys.calls
[10:27:16.676]             `[[` <- base::`[[`
[10:27:16.676]             `+` <- base::`+`
[10:27:16.676]             `<<-` <- base::`<<-`
[10:27:16.676]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:16.676]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:16.676]                   3L)]
[10:27:16.676]             }
[10:27:16.676]             function(cond) {
[10:27:16.676]                 is_error <- inherits(cond, "error")
[10:27:16.676]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:16.676]                   NULL)
[10:27:16.676]                 if (is_error) {
[10:27:16.676]                   sessionInformation <- function() {
[10:27:16.676]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:16.676]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:16.676]                       search = base::search(), system = base::Sys.info())
[10:27:16.676]                   }
[10:27:16.676]                   ...future.conditions[[length(...future.conditions) + 
[10:27:16.676]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:16.676]                     cond$call), session = sessionInformation(), 
[10:27:16.676]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:16.676]                   signalCondition(cond)
[10:27:16.676]                 }
[10:27:16.676]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:16.676]                 "immediateCondition"))) {
[10:27:16.676]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:16.676]                   ...future.conditions[[length(...future.conditions) + 
[10:27:16.676]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:16.676]                   if (TRUE && !signal) {
[10:27:16.676]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:16.676]                     {
[10:27:16.676]                       inherits <- base::inherits
[10:27:16.676]                       invokeRestart <- base::invokeRestart
[10:27:16.676]                       is.null <- base::is.null
[10:27:16.676]                       muffled <- FALSE
[10:27:16.676]                       if (inherits(cond, "message")) {
[10:27:16.676]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:16.676]                         if (muffled) 
[10:27:16.676]                           invokeRestart("muffleMessage")
[10:27:16.676]                       }
[10:27:16.676]                       else if (inherits(cond, "warning")) {
[10:27:16.676]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:16.676]                         if (muffled) 
[10:27:16.676]                           invokeRestart("muffleWarning")
[10:27:16.676]                       }
[10:27:16.676]                       else if (inherits(cond, "condition")) {
[10:27:16.676]                         if (!is.null(pattern)) {
[10:27:16.676]                           computeRestarts <- base::computeRestarts
[10:27:16.676]                           grepl <- base::grepl
[10:27:16.676]                           restarts <- computeRestarts(cond)
[10:27:16.676]                           for (restart in restarts) {
[10:27:16.676]                             name <- restart$name
[10:27:16.676]                             if (is.null(name)) 
[10:27:16.676]                               next
[10:27:16.676]                             if (!grepl(pattern, name)) 
[10:27:16.676]                               next
[10:27:16.676]                             invokeRestart(restart)
[10:27:16.676]                             muffled <- TRUE
[10:27:16.676]                             break
[10:27:16.676]                           }
[10:27:16.676]                         }
[10:27:16.676]                       }
[10:27:16.676]                       invisible(muffled)
[10:27:16.676]                     }
[10:27:16.676]                     muffleCondition(cond, pattern = "^muffle")
[10:27:16.676]                   }
[10:27:16.676]                 }
[10:27:16.676]                 else {
[10:27:16.676]                   if (TRUE) {
[10:27:16.676]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:16.676]                     {
[10:27:16.676]                       inherits <- base::inherits
[10:27:16.676]                       invokeRestart <- base::invokeRestart
[10:27:16.676]                       is.null <- base::is.null
[10:27:16.676]                       muffled <- FALSE
[10:27:16.676]                       if (inherits(cond, "message")) {
[10:27:16.676]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:16.676]                         if (muffled) 
[10:27:16.676]                           invokeRestart("muffleMessage")
[10:27:16.676]                       }
[10:27:16.676]                       else if (inherits(cond, "warning")) {
[10:27:16.676]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:16.676]                         if (muffled) 
[10:27:16.676]                           invokeRestart("muffleWarning")
[10:27:16.676]                       }
[10:27:16.676]                       else if (inherits(cond, "condition")) {
[10:27:16.676]                         if (!is.null(pattern)) {
[10:27:16.676]                           computeRestarts <- base::computeRestarts
[10:27:16.676]                           grepl <- base::grepl
[10:27:16.676]                           restarts <- computeRestarts(cond)
[10:27:16.676]                           for (restart in restarts) {
[10:27:16.676]                             name <- restart$name
[10:27:16.676]                             if (is.null(name)) 
[10:27:16.676]                               next
[10:27:16.676]                             if (!grepl(pattern, name)) 
[10:27:16.676]                               next
[10:27:16.676]                             invokeRestart(restart)
[10:27:16.676]                             muffled <- TRUE
[10:27:16.676]                             break
[10:27:16.676]                           }
[10:27:16.676]                         }
[10:27:16.676]                       }
[10:27:16.676]                       invisible(muffled)
[10:27:16.676]                     }
[10:27:16.676]                     muffleCondition(cond, pattern = "^muffle")
[10:27:16.676]                   }
[10:27:16.676]                 }
[10:27:16.676]             }
[10:27:16.676]         }))
[10:27:16.676]     }, error = function(ex) {
[10:27:16.676]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:16.676]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:16.676]                 ...future.rng), started = ...future.startTime, 
[10:27:16.676]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:16.676]             version = "1.8"), class = "FutureResult")
[10:27:16.676]     }, finally = {
[10:27:16.676]         if (!identical(...future.workdir, getwd())) 
[10:27:16.676]             setwd(...future.workdir)
[10:27:16.676]         {
[10:27:16.676]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:16.676]                 ...future.oldOptions$nwarnings <- NULL
[10:27:16.676]             }
[10:27:16.676]             base::options(...future.oldOptions)
[10:27:16.676]             if (.Platform$OS.type == "windows") {
[10:27:16.676]                 old_names <- names(...future.oldEnvVars)
[10:27:16.676]                 envs <- base::Sys.getenv()
[10:27:16.676]                 names <- names(envs)
[10:27:16.676]                 common <- intersect(names, old_names)
[10:27:16.676]                 added <- setdiff(names, old_names)
[10:27:16.676]                 removed <- setdiff(old_names, names)
[10:27:16.676]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:16.676]                   envs[common]]
[10:27:16.676]                 NAMES <- toupper(changed)
[10:27:16.676]                 args <- list()
[10:27:16.676]                 for (kk in seq_along(NAMES)) {
[10:27:16.676]                   name <- changed[[kk]]
[10:27:16.676]                   NAME <- NAMES[[kk]]
[10:27:16.676]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:16.676]                     next
[10:27:16.676]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:16.676]                 }
[10:27:16.676]                 NAMES <- toupper(added)
[10:27:16.676]                 for (kk in seq_along(NAMES)) {
[10:27:16.676]                   name <- added[[kk]]
[10:27:16.676]                   NAME <- NAMES[[kk]]
[10:27:16.676]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:16.676]                     next
[10:27:16.676]                   args[[name]] <- ""
[10:27:16.676]                 }
[10:27:16.676]                 NAMES <- toupper(removed)
[10:27:16.676]                 for (kk in seq_along(NAMES)) {
[10:27:16.676]                   name <- removed[[kk]]
[10:27:16.676]                   NAME <- NAMES[[kk]]
[10:27:16.676]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:16.676]                     next
[10:27:16.676]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:16.676]                 }
[10:27:16.676]                 if (length(args) > 0) 
[10:27:16.676]                   base::do.call(base::Sys.setenv, args = args)
[10:27:16.676]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:16.676]             }
[10:27:16.676]             else {
[10:27:16.676]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:16.676]             }
[10:27:16.676]             {
[10:27:16.676]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:16.676]                   0L) {
[10:27:16.676]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:16.676]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:16.676]                   base::options(opts)
[10:27:16.676]                 }
[10:27:16.676]                 {
[10:27:16.676]                   {
[10:27:16.676]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:16.676]                     NULL
[10:27:16.676]                   }
[10:27:16.676]                   options(future.plan = NULL)
[10:27:16.676]                   if (is.na(NA_character_)) 
[10:27:16.676]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:16.676]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:16.676]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:16.676]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:16.676]                     envir = parent.frame()) 
[10:27:16.676]                   {
[10:27:16.676]                     if (is.function(workers)) 
[10:27:16.676]                       workers <- workers()
[10:27:16.676]                     workers <- structure(as.integer(workers), 
[10:27:16.676]                       class = class(workers))
[10:27:16.676]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:16.676]                       workers >= 1)
[10:27:16.676]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:16.676]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:16.676]                     }
[10:27:16.676]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:16.676]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:16.676]                       envir = envir)
[10:27:16.676]                     if (!future$lazy) 
[10:27:16.676]                       future <- run(future)
[10:27:16.676]                     invisible(future)
[10:27:16.676]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:16.676]                 }
[10:27:16.676]             }
[10:27:16.676]         }
[10:27:16.676]     })
[10:27:16.676]     if (TRUE) {
[10:27:16.676]         base::sink(type = "output", split = FALSE)
[10:27:16.676]         if (TRUE) {
[10:27:16.676]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:16.676]         }
[10:27:16.676]         else {
[10:27:16.676]             ...future.result["stdout"] <- base::list(NULL)
[10:27:16.676]         }
[10:27:16.676]         base::close(...future.stdout)
[10:27:16.676]         ...future.stdout <- NULL
[10:27:16.676]     }
[10:27:16.676]     ...future.result$conditions <- ...future.conditions
[10:27:16.676]     ...future.result$finished <- base::Sys.time()
[10:27:16.676]     ...future.result
[10:27:16.676] }
[10:27:16.680] MultisessionFuture started
[10:27:16.680] - Launch lazy future ... done
[10:27:16.680] run() for ‘MultisessionFuture’ ... done
[10:27:17.229] receiveMessageFromWorker() for ClusterFuture ...
[10:27:17.229] - Validating connection of MultisessionFuture
[10:27:17.230] - received message: FutureResult
[10:27:17.230] - Received FutureResult
[10:27:17.230] - Erased future from FutureRegistry
[10:27:17.230] result() for ClusterFuture ...
[10:27:17.230] - result already collected: FutureResult
[10:27:17.230] result() for ClusterFuture ... done
[10:27:17.230] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:17.230] resolve() on list ...
[10:27:17.231]  recursive: 0
[10:27:17.233]  length: 2
[10:27:17.233]  elements: ‘a’, ‘b’
[10:27:17.234]  length: 1 (resolved future 1)
[10:27:17.234]  length: 0 (resolved future 2)
[10:27:17.234] resolve() on list ... DONE
[10:27:17.234] A MultisessionFuture was resolved (and resolved itself)
[10:27:17.234] getGlobalsAndPackages() ...
[10:27:17.234] Searching for globals...
[10:27:17.236] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:27:17.236] Searching for globals ... DONE
[10:27:17.236] Resolving globals: FALSE
[10:27:17.236] 
[10:27:17.236] 
[10:27:17.237] getGlobalsAndPackages() ... DONE
[10:27:17.237] run() for ‘Future’ ...
[10:27:17.237] - state: ‘created’
[10:27:17.237] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:17.257] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:17.258] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:17.258]   - Field: ‘node’
[10:27:17.258]   - Field: ‘label’
[10:27:17.258]   - Field: ‘local’
[10:27:17.258]   - Field: ‘owner’
[10:27:17.258]   - Field: ‘envir’
[10:27:17.258]   - Field: ‘workers’
[10:27:17.258]   - Field: ‘packages’
[10:27:17.258]   - Field: ‘gc’
[10:27:17.258]   - Field: ‘conditions’
[10:27:17.259]   - Field: ‘persistent’
[10:27:17.259]   - Field: ‘expr’
[10:27:17.259]   - Field: ‘uuid’
[10:27:17.259]   - Field: ‘seed’
[10:27:17.259]   - Field: ‘version’
[10:27:17.259]   - Field: ‘result’
[10:27:17.259]   - Field: ‘asynchronous’
[10:27:17.259]   - Field: ‘calls’
[10:27:17.259]   - Field: ‘globals’
[10:27:17.259]   - Field: ‘stdout’
[10:27:17.260]   - Field: ‘earlySignal’
[10:27:17.260]   - Field: ‘lazy’
[10:27:17.260]   - Field: ‘state’
[10:27:17.260] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:17.260] - Launch lazy future ...
[10:27:17.260] Packages needed by the future expression (n = 0): <none>
[10:27:17.260] Packages needed by future strategies (n = 0): <none>
[10:27:17.261] {
[10:27:17.261]     {
[10:27:17.261]         {
[10:27:17.261]             ...future.startTime <- base::Sys.time()
[10:27:17.261]             {
[10:27:17.261]                 {
[10:27:17.261]                   {
[10:27:17.261]                     {
[10:27:17.261]                       base::local({
[10:27:17.261]                         has_future <- base::requireNamespace("future", 
[10:27:17.261]                           quietly = TRUE)
[10:27:17.261]                         if (has_future) {
[10:27:17.261]                           ns <- base::getNamespace("future")
[10:27:17.261]                           version <- ns[[".package"]][["version"]]
[10:27:17.261]                           if (is.null(version)) 
[10:27:17.261]                             version <- utils::packageVersion("future")
[10:27:17.261]                         }
[10:27:17.261]                         else {
[10:27:17.261]                           version <- NULL
[10:27:17.261]                         }
[10:27:17.261]                         if (!has_future || version < "1.8.0") {
[10:27:17.261]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:17.261]                             "", base::R.version$version.string), 
[10:27:17.261]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:17.261]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:17.261]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:17.261]                               "release", "version")], collapse = " "), 
[10:27:17.261]                             hostname = base::Sys.info()[["nodename"]])
[10:27:17.261]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:17.261]                             info)
[10:27:17.261]                           info <- base::paste(info, collapse = "; ")
[10:27:17.261]                           if (!has_future) {
[10:27:17.261]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:17.261]                               info)
[10:27:17.261]                           }
[10:27:17.261]                           else {
[10:27:17.261]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:17.261]                               info, version)
[10:27:17.261]                           }
[10:27:17.261]                           base::stop(msg)
[10:27:17.261]                         }
[10:27:17.261]                       })
[10:27:17.261]                     }
[10:27:17.261]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:17.261]                     base::options(mc.cores = 1L)
[10:27:17.261]                   }
[10:27:17.261]                   options(future.plan = NULL)
[10:27:17.261]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:17.261]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:17.261]                 }
[10:27:17.261]                 ...future.workdir <- getwd()
[10:27:17.261]             }
[10:27:17.261]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:17.261]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:17.261]         }
[10:27:17.261]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:17.261]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:17.261]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:17.261]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:17.261]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:17.261]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:17.261]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:17.261]             base::names(...future.oldOptions))
[10:27:17.261]     }
[10:27:17.261]     if (FALSE) {
[10:27:17.261]     }
[10:27:17.261]     else {
[10:27:17.261]         if (TRUE) {
[10:27:17.261]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:17.261]                 open = "w")
[10:27:17.261]         }
[10:27:17.261]         else {
[10:27:17.261]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:17.261]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:17.261]         }
[10:27:17.261]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:17.261]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:17.261]             base::sink(type = "output", split = FALSE)
[10:27:17.261]             base::close(...future.stdout)
[10:27:17.261]         }, add = TRUE)
[10:27:17.261]     }
[10:27:17.261]     ...future.frame <- base::sys.nframe()
[10:27:17.261]     ...future.conditions <- base::list()
[10:27:17.261]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:17.261]     if (FALSE) {
[10:27:17.261]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:17.261]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:17.261]     }
[10:27:17.261]     ...future.result <- base::tryCatch({
[10:27:17.261]         base::withCallingHandlers({
[10:27:17.261]             ...future.value <- base::withVisible(base::local({
[10:27:17.261]                 ...future.makeSendCondition <- base::local({
[10:27:17.261]                   sendCondition <- NULL
[10:27:17.261]                   function(frame = 1L) {
[10:27:17.261]                     if (is.function(sendCondition)) 
[10:27:17.261]                       return(sendCondition)
[10:27:17.261]                     ns <- getNamespace("parallel")
[10:27:17.261]                     if (exists("sendData", mode = "function", 
[10:27:17.261]                       envir = ns)) {
[10:27:17.261]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:17.261]                         envir = ns)
[10:27:17.261]                       envir <- sys.frame(frame)
[10:27:17.261]                       master <- NULL
[10:27:17.261]                       while (!identical(envir, .GlobalEnv) && 
[10:27:17.261]                         !identical(envir, emptyenv())) {
[10:27:17.261]                         if (exists("master", mode = "list", envir = envir, 
[10:27:17.261]                           inherits = FALSE)) {
[10:27:17.261]                           master <- get("master", mode = "list", 
[10:27:17.261]                             envir = envir, inherits = FALSE)
[10:27:17.261]                           if (inherits(master, c("SOCKnode", 
[10:27:17.261]                             "SOCK0node"))) {
[10:27:17.261]                             sendCondition <<- function(cond) {
[10:27:17.261]                               data <- list(type = "VALUE", value = cond, 
[10:27:17.261]                                 success = TRUE)
[10:27:17.261]                               parallel_sendData(master, data)
[10:27:17.261]                             }
[10:27:17.261]                             return(sendCondition)
[10:27:17.261]                           }
[10:27:17.261]                         }
[10:27:17.261]                         frame <- frame + 1L
[10:27:17.261]                         envir <- sys.frame(frame)
[10:27:17.261]                       }
[10:27:17.261]                     }
[10:27:17.261]                     sendCondition <<- function(cond) NULL
[10:27:17.261]                   }
[10:27:17.261]                 })
[10:27:17.261]                 withCallingHandlers({
[10:27:17.261]                   {
[10:27:17.261]                     Sys.sleep(0.5)
[10:27:17.261]                     list(a = 1, b = 42L)
[10:27:17.261]                   }
[10:27:17.261]                 }, immediateCondition = function(cond) {
[10:27:17.261]                   sendCondition <- ...future.makeSendCondition()
[10:27:17.261]                   sendCondition(cond)
[10:27:17.261]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:17.261]                   {
[10:27:17.261]                     inherits <- base::inherits
[10:27:17.261]                     invokeRestart <- base::invokeRestart
[10:27:17.261]                     is.null <- base::is.null
[10:27:17.261]                     muffled <- FALSE
[10:27:17.261]                     if (inherits(cond, "message")) {
[10:27:17.261]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:17.261]                       if (muffled) 
[10:27:17.261]                         invokeRestart("muffleMessage")
[10:27:17.261]                     }
[10:27:17.261]                     else if (inherits(cond, "warning")) {
[10:27:17.261]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:17.261]                       if (muffled) 
[10:27:17.261]                         invokeRestart("muffleWarning")
[10:27:17.261]                     }
[10:27:17.261]                     else if (inherits(cond, "condition")) {
[10:27:17.261]                       if (!is.null(pattern)) {
[10:27:17.261]                         computeRestarts <- base::computeRestarts
[10:27:17.261]                         grepl <- base::grepl
[10:27:17.261]                         restarts <- computeRestarts(cond)
[10:27:17.261]                         for (restart in restarts) {
[10:27:17.261]                           name <- restart$name
[10:27:17.261]                           if (is.null(name)) 
[10:27:17.261]                             next
[10:27:17.261]                           if (!grepl(pattern, name)) 
[10:27:17.261]                             next
[10:27:17.261]                           invokeRestart(restart)
[10:27:17.261]                           muffled <- TRUE
[10:27:17.261]                           break
[10:27:17.261]                         }
[10:27:17.261]                       }
[10:27:17.261]                     }
[10:27:17.261]                     invisible(muffled)
[10:27:17.261]                   }
[10:27:17.261]                   muffleCondition(cond)
[10:27:17.261]                 })
[10:27:17.261]             }))
[10:27:17.261]             future::FutureResult(value = ...future.value$value, 
[10:27:17.261]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:17.261]                   ...future.rng), globalenv = if (FALSE) 
[10:27:17.261]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:17.261]                     ...future.globalenv.names))
[10:27:17.261]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:17.261]         }, condition = base::local({
[10:27:17.261]             c <- base::c
[10:27:17.261]             inherits <- base::inherits
[10:27:17.261]             invokeRestart <- base::invokeRestart
[10:27:17.261]             length <- base::length
[10:27:17.261]             list <- base::list
[10:27:17.261]             seq.int <- base::seq.int
[10:27:17.261]             signalCondition <- base::signalCondition
[10:27:17.261]             sys.calls <- base::sys.calls
[10:27:17.261]             `[[` <- base::`[[`
[10:27:17.261]             `+` <- base::`+`
[10:27:17.261]             `<<-` <- base::`<<-`
[10:27:17.261]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:17.261]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:17.261]                   3L)]
[10:27:17.261]             }
[10:27:17.261]             function(cond) {
[10:27:17.261]                 is_error <- inherits(cond, "error")
[10:27:17.261]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:17.261]                   NULL)
[10:27:17.261]                 if (is_error) {
[10:27:17.261]                   sessionInformation <- function() {
[10:27:17.261]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:17.261]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:17.261]                       search = base::search(), system = base::Sys.info())
[10:27:17.261]                   }
[10:27:17.261]                   ...future.conditions[[length(...future.conditions) + 
[10:27:17.261]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:17.261]                     cond$call), session = sessionInformation(), 
[10:27:17.261]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:17.261]                   signalCondition(cond)
[10:27:17.261]                 }
[10:27:17.261]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:17.261]                 "immediateCondition"))) {
[10:27:17.261]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:17.261]                   ...future.conditions[[length(...future.conditions) + 
[10:27:17.261]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:17.261]                   if (TRUE && !signal) {
[10:27:17.261]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:17.261]                     {
[10:27:17.261]                       inherits <- base::inherits
[10:27:17.261]                       invokeRestart <- base::invokeRestart
[10:27:17.261]                       is.null <- base::is.null
[10:27:17.261]                       muffled <- FALSE
[10:27:17.261]                       if (inherits(cond, "message")) {
[10:27:17.261]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:17.261]                         if (muffled) 
[10:27:17.261]                           invokeRestart("muffleMessage")
[10:27:17.261]                       }
[10:27:17.261]                       else if (inherits(cond, "warning")) {
[10:27:17.261]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:17.261]                         if (muffled) 
[10:27:17.261]                           invokeRestart("muffleWarning")
[10:27:17.261]                       }
[10:27:17.261]                       else if (inherits(cond, "condition")) {
[10:27:17.261]                         if (!is.null(pattern)) {
[10:27:17.261]                           computeRestarts <- base::computeRestarts
[10:27:17.261]                           grepl <- base::grepl
[10:27:17.261]                           restarts <- computeRestarts(cond)
[10:27:17.261]                           for (restart in restarts) {
[10:27:17.261]                             name <- restart$name
[10:27:17.261]                             if (is.null(name)) 
[10:27:17.261]                               next
[10:27:17.261]                             if (!grepl(pattern, name)) 
[10:27:17.261]                               next
[10:27:17.261]                             invokeRestart(restart)
[10:27:17.261]                             muffled <- TRUE
[10:27:17.261]                             break
[10:27:17.261]                           }
[10:27:17.261]                         }
[10:27:17.261]                       }
[10:27:17.261]                       invisible(muffled)
[10:27:17.261]                     }
[10:27:17.261]                     muffleCondition(cond, pattern = "^muffle")
[10:27:17.261]                   }
[10:27:17.261]                 }
[10:27:17.261]                 else {
[10:27:17.261]                   if (TRUE) {
[10:27:17.261]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:17.261]                     {
[10:27:17.261]                       inherits <- base::inherits
[10:27:17.261]                       invokeRestart <- base::invokeRestart
[10:27:17.261]                       is.null <- base::is.null
[10:27:17.261]                       muffled <- FALSE
[10:27:17.261]                       if (inherits(cond, "message")) {
[10:27:17.261]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:17.261]                         if (muffled) 
[10:27:17.261]                           invokeRestart("muffleMessage")
[10:27:17.261]                       }
[10:27:17.261]                       else if (inherits(cond, "warning")) {
[10:27:17.261]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:17.261]                         if (muffled) 
[10:27:17.261]                           invokeRestart("muffleWarning")
[10:27:17.261]                       }
[10:27:17.261]                       else if (inherits(cond, "condition")) {
[10:27:17.261]                         if (!is.null(pattern)) {
[10:27:17.261]                           computeRestarts <- base::computeRestarts
[10:27:17.261]                           grepl <- base::grepl
[10:27:17.261]                           restarts <- computeRestarts(cond)
[10:27:17.261]                           for (restart in restarts) {
[10:27:17.261]                             name <- restart$name
[10:27:17.261]                             if (is.null(name)) 
[10:27:17.261]                               next
[10:27:17.261]                             if (!grepl(pattern, name)) 
[10:27:17.261]                               next
[10:27:17.261]                             invokeRestart(restart)
[10:27:17.261]                             muffled <- TRUE
[10:27:17.261]                             break
[10:27:17.261]                           }
[10:27:17.261]                         }
[10:27:17.261]                       }
[10:27:17.261]                       invisible(muffled)
[10:27:17.261]                     }
[10:27:17.261]                     muffleCondition(cond, pattern = "^muffle")
[10:27:17.261]                   }
[10:27:17.261]                 }
[10:27:17.261]             }
[10:27:17.261]         }))
[10:27:17.261]     }, error = function(ex) {
[10:27:17.261]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:17.261]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:17.261]                 ...future.rng), started = ...future.startTime, 
[10:27:17.261]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:17.261]             version = "1.8"), class = "FutureResult")
[10:27:17.261]     }, finally = {
[10:27:17.261]         if (!identical(...future.workdir, getwd())) 
[10:27:17.261]             setwd(...future.workdir)
[10:27:17.261]         {
[10:27:17.261]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:17.261]                 ...future.oldOptions$nwarnings <- NULL
[10:27:17.261]             }
[10:27:17.261]             base::options(...future.oldOptions)
[10:27:17.261]             if (.Platform$OS.type == "windows") {
[10:27:17.261]                 old_names <- names(...future.oldEnvVars)
[10:27:17.261]                 envs <- base::Sys.getenv()
[10:27:17.261]                 names <- names(envs)
[10:27:17.261]                 common <- intersect(names, old_names)
[10:27:17.261]                 added <- setdiff(names, old_names)
[10:27:17.261]                 removed <- setdiff(old_names, names)
[10:27:17.261]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:17.261]                   envs[common]]
[10:27:17.261]                 NAMES <- toupper(changed)
[10:27:17.261]                 args <- list()
[10:27:17.261]                 for (kk in seq_along(NAMES)) {
[10:27:17.261]                   name <- changed[[kk]]
[10:27:17.261]                   NAME <- NAMES[[kk]]
[10:27:17.261]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:17.261]                     next
[10:27:17.261]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:17.261]                 }
[10:27:17.261]                 NAMES <- toupper(added)
[10:27:17.261]                 for (kk in seq_along(NAMES)) {
[10:27:17.261]                   name <- added[[kk]]
[10:27:17.261]                   NAME <- NAMES[[kk]]
[10:27:17.261]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:17.261]                     next
[10:27:17.261]                   args[[name]] <- ""
[10:27:17.261]                 }
[10:27:17.261]                 NAMES <- toupper(removed)
[10:27:17.261]                 for (kk in seq_along(NAMES)) {
[10:27:17.261]                   name <- removed[[kk]]
[10:27:17.261]                   NAME <- NAMES[[kk]]
[10:27:17.261]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:17.261]                     next
[10:27:17.261]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:17.261]                 }
[10:27:17.261]                 if (length(args) > 0) 
[10:27:17.261]                   base::do.call(base::Sys.setenv, args = args)
[10:27:17.261]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:17.261]             }
[10:27:17.261]             else {
[10:27:17.261]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:17.261]             }
[10:27:17.261]             {
[10:27:17.261]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:17.261]                   0L) {
[10:27:17.261]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:17.261]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:17.261]                   base::options(opts)
[10:27:17.261]                 }
[10:27:17.261]                 {
[10:27:17.261]                   {
[10:27:17.261]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:17.261]                     NULL
[10:27:17.261]                   }
[10:27:17.261]                   options(future.plan = NULL)
[10:27:17.261]                   if (is.na(NA_character_)) 
[10:27:17.261]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:17.261]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:17.261]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:17.261]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:17.261]                     envir = parent.frame()) 
[10:27:17.261]                   {
[10:27:17.261]                     if (is.function(workers)) 
[10:27:17.261]                       workers <- workers()
[10:27:17.261]                     workers <- structure(as.integer(workers), 
[10:27:17.261]                       class = class(workers))
[10:27:17.261]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:17.261]                       workers >= 1)
[10:27:17.261]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:17.261]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:17.261]                     }
[10:27:17.261]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:17.261]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:17.261]                       envir = envir)
[10:27:17.261]                     if (!future$lazy) 
[10:27:17.261]                       future <- run(future)
[10:27:17.261]                     invisible(future)
[10:27:17.261]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:17.261]                 }
[10:27:17.261]             }
[10:27:17.261]         }
[10:27:17.261]     })
[10:27:17.261]     if (TRUE) {
[10:27:17.261]         base::sink(type = "output", split = FALSE)
[10:27:17.261]         if (TRUE) {
[10:27:17.261]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:17.261]         }
[10:27:17.261]         else {
[10:27:17.261]             ...future.result["stdout"] <- base::list(NULL)
[10:27:17.261]         }
[10:27:17.261]         base::close(...future.stdout)
[10:27:17.261]         ...future.stdout <- NULL
[10:27:17.261]     }
[10:27:17.261]     ...future.result$conditions <- ...future.conditions
[10:27:17.261]     ...future.result$finished <- base::Sys.time()
[10:27:17.261]     ...future.result
[10:27:17.261] }
[10:27:17.264] MultisessionFuture started
[10:27:17.264] - Launch lazy future ... done
[10:27:17.264] run() for ‘MultisessionFuture’ ... done
[10:27:17.814] receiveMessageFromWorker() for ClusterFuture ...
[10:27:17.814] - Validating connection of MultisessionFuture
[10:27:17.814] - received message: FutureResult
[10:27:17.814] - Received FutureResult
[10:27:17.815] - Erased future from FutureRegistry
[10:27:17.815] result() for ClusterFuture ...
[10:27:17.815] - result already collected: FutureResult
[10:27:17.815] result() for ClusterFuture ... done
[10:27:17.815] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:17.815] resolve() on list ...
[10:27:17.815]  recursive: 0
[10:27:17.815]  length: 2
[10:27:17.815]  elements: ‘a’, ‘b’
[10:27:17.815]  length: 1 (resolved future 1)
[10:27:17.816]  length: 0 (resolved future 2)
[10:27:17.816] resolve() on list ... DONE
[10:27:17.816] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[10:27:17.816] getGlobalsAndPackages() ...
[10:27:17.816] Searching for globals...
[10:27:17.817] - globals found: [2] ‘list’, ‘stop’
[10:27:17.817] Searching for globals ... DONE
[10:27:17.817] Resolving globals: FALSE
[10:27:17.817] 
[10:27:17.817] 
[10:27:17.818] getGlobalsAndPackages() ... DONE
[10:27:17.818] run() for ‘Future’ ...
[10:27:17.818] - state: ‘created’
[10:27:17.818] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:17.835] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:17.836] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:17.836]   - Field: ‘node’
[10:27:17.836]   - Field: ‘label’
[10:27:17.836]   - Field: ‘local’
[10:27:17.836]   - Field: ‘owner’
[10:27:17.836]   - Field: ‘envir’
[10:27:17.836]   - Field: ‘workers’
[10:27:17.836]   - Field: ‘packages’
[10:27:17.837]   - Field: ‘gc’
[10:27:17.837]   - Field: ‘conditions’
[10:27:17.837]   - Field: ‘persistent’
[10:27:17.837]   - Field: ‘expr’
[10:27:17.837]   - Field: ‘uuid’
[10:27:17.837]   - Field: ‘seed’
[10:27:17.837]   - Field: ‘version’
[10:27:17.837]   - Field: ‘result’
[10:27:17.837]   - Field: ‘asynchronous’
[10:27:17.838]   - Field: ‘calls’
[10:27:17.838]   - Field: ‘globals’
[10:27:17.838]   - Field: ‘stdout’
[10:27:17.838]   - Field: ‘earlySignal’
[10:27:17.838]   - Field: ‘lazy’
[10:27:17.838]   - Field: ‘state’
[10:27:17.838] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:17.838] - Launch lazy future ...
[10:27:17.839] Packages needed by the future expression (n = 0): <none>
[10:27:17.839] Packages needed by future strategies (n = 0): <none>
[10:27:17.839] {
[10:27:17.839]     {
[10:27:17.839]         {
[10:27:17.839]             ...future.startTime <- base::Sys.time()
[10:27:17.839]             {
[10:27:17.839]                 {
[10:27:17.839]                   {
[10:27:17.839]                     {
[10:27:17.839]                       base::local({
[10:27:17.839]                         has_future <- base::requireNamespace("future", 
[10:27:17.839]                           quietly = TRUE)
[10:27:17.839]                         if (has_future) {
[10:27:17.839]                           ns <- base::getNamespace("future")
[10:27:17.839]                           version <- ns[[".package"]][["version"]]
[10:27:17.839]                           if (is.null(version)) 
[10:27:17.839]                             version <- utils::packageVersion("future")
[10:27:17.839]                         }
[10:27:17.839]                         else {
[10:27:17.839]                           version <- NULL
[10:27:17.839]                         }
[10:27:17.839]                         if (!has_future || version < "1.8.0") {
[10:27:17.839]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:17.839]                             "", base::R.version$version.string), 
[10:27:17.839]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:17.839]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:17.839]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:17.839]                               "release", "version")], collapse = " "), 
[10:27:17.839]                             hostname = base::Sys.info()[["nodename"]])
[10:27:17.839]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:17.839]                             info)
[10:27:17.839]                           info <- base::paste(info, collapse = "; ")
[10:27:17.839]                           if (!has_future) {
[10:27:17.839]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:17.839]                               info)
[10:27:17.839]                           }
[10:27:17.839]                           else {
[10:27:17.839]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:17.839]                               info, version)
[10:27:17.839]                           }
[10:27:17.839]                           base::stop(msg)
[10:27:17.839]                         }
[10:27:17.839]                       })
[10:27:17.839]                     }
[10:27:17.839]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:17.839]                     base::options(mc.cores = 1L)
[10:27:17.839]                   }
[10:27:17.839]                   options(future.plan = NULL)
[10:27:17.839]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:17.839]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:17.839]                 }
[10:27:17.839]                 ...future.workdir <- getwd()
[10:27:17.839]             }
[10:27:17.839]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:17.839]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:17.839]         }
[10:27:17.839]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:17.839]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:17.839]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:17.839]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:17.839]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:17.839]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:17.839]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:17.839]             base::names(...future.oldOptions))
[10:27:17.839]     }
[10:27:17.839]     if (FALSE) {
[10:27:17.839]     }
[10:27:17.839]     else {
[10:27:17.839]         if (TRUE) {
[10:27:17.839]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:17.839]                 open = "w")
[10:27:17.839]         }
[10:27:17.839]         else {
[10:27:17.839]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:17.839]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:17.839]         }
[10:27:17.839]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:17.839]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:17.839]             base::sink(type = "output", split = FALSE)
[10:27:17.839]             base::close(...future.stdout)
[10:27:17.839]         }, add = TRUE)
[10:27:17.839]     }
[10:27:17.839]     ...future.frame <- base::sys.nframe()
[10:27:17.839]     ...future.conditions <- base::list()
[10:27:17.839]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:17.839]     if (FALSE) {
[10:27:17.839]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:17.839]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:17.839]     }
[10:27:17.839]     ...future.result <- base::tryCatch({
[10:27:17.839]         base::withCallingHandlers({
[10:27:17.839]             ...future.value <- base::withVisible(base::local({
[10:27:17.839]                 ...future.makeSendCondition <- base::local({
[10:27:17.839]                   sendCondition <- NULL
[10:27:17.839]                   function(frame = 1L) {
[10:27:17.839]                     if (is.function(sendCondition)) 
[10:27:17.839]                       return(sendCondition)
[10:27:17.839]                     ns <- getNamespace("parallel")
[10:27:17.839]                     if (exists("sendData", mode = "function", 
[10:27:17.839]                       envir = ns)) {
[10:27:17.839]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:17.839]                         envir = ns)
[10:27:17.839]                       envir <- sys.frame(frame)
[10:27:17.839]                       master <- NULL
[10:27:17.839]                       while (!identical(envir, .GlobalEnv) && 
[10:27:17.839]                         !identical(envir, emptyenv())) {
[10:27:17.839]                         if (exists("master", mode = "list", envir = envir, 
[10:27:17.839]                           inherits = FALSE)) {
[10:27:17.839]                           master <- get("master", mode = "list", 
[10:27:17.839]                             envir = envir, inherits = FALSE)
[10:27:17.839]                           if (inherits(master, c("SOCKnode", 
[10:27:17.839]                             "SOCK0node"))) {
[10:27:17.839]                             sendCondition <<- function(cond) {
[10:27:17.839]                               data <- list(type = "VALUE", value = cond, 
[10:27:17.839]                                 success = TRUE)
[10:27:17.839]                               parallel_sendData(master, data)
[10:27:17.839]                             }
[10:27:17.839]                             return(sendCondition)
[10:27:17.839]                           }
[10:27:17.839]                         }
[10:27:17.839]                         frame <- frame + 1L
[10:27:17.839]                         envir <- sys.frame(frame)
[10:27:17.839]                       }
[10:27:17.839]                     }
[10:27:17.839]                     sendCondition <<- function(cond) NULL
[10:27:17.839]                   }
[10:27:17.839]                 })
[10:27:17.839]                 withCallingHandlers({
[10:27:17.839]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:27:17.839]                 }, immediateCondition = function(cond) {
[10:27:17.839]                   sendCondition <- ...future.makeSendCondition()
[10:27:17.839]                   sendCondition(cond)
[10:27:17.839]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:17.839]                   {
[10:27:17.839]                     inherits <- base::inherits
[10:27:17.839]                     invokeRestart <- base::invokeRestart
[10:27:17.839]                     is.null <- base::is.null
[10:27:17.839]                     muffled <- FALSE
[10:27:17.839]                     if (inherits(cond, "message")) {
[10:27:17.839]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:17.839]                       if (muffled) 
[10:27:17.839]                         invokeRestart("muffleMessage")
[10:27:17.839]                     }
[10:27:17.839]                     else if (inherits(cond, "warning")) {
[10:27:17.839]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:17.839]                       if (muffled) 
[10:27:17.839]                         invokeRestart("muffleWarning")
[10:27:17.839]                     }
[10:27:17.839]                     else if (inherits(cond, "condition")) {
[10:27:17.839]                       if (!is.null(pattern)) {
[10:27:17.839]                         computeRestarts <- base::computeRestarts
[10:27:17.839]                         grepl <- base::grepl
[10:27:17.839]                         restarts <- computeRestarts(cond)
[10:27:17.839]                         for (restart in restarts) {
[10:27:17.839]                           name <- restart$name
[10:27:17.839]                           if (is.null(name)) 
[10:27:17.839]                             next
[10:27:17.839]                           if (!grepl(pattern, name)) 
[10:27:17.839]                             next
[10:27:17.839]                           invokeRestart(restart)
[10:27:17.839]                           muffled <- TRUE
[10:27:17.839]                           break
[10:27:17.839]                         }
[10:27:17.839]                       }
[10:27:17.839]                     }
[10:27:17.839]                     invisible(muffled)
[10:27:17.839]                   }
[10:27:17.839]                   muffleCondition(cond)
[10:27:17.839]                 })
[10:27:17.839]             }))
[10:27:17.839]             future::FutureResult(value = ...future.value$value, 
[10:27:17.839]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:17.839]                   ...future.rng), globalenv = if (FALSE) 
[10:27:17.839]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:17.839]                     ...future.globalenv.names))
[10:27:17.839]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:17.839]         }, condition = base::local({
[10:27:17.839]             c <- base::c
[10:27:17.839]             inherits <- base::inherits
[10:27:17.839]             invokeRestart <- base::invokeRestart
[10:27:17.839]             length <- base::length
[10:27:17.839]             list <- base::list
[10:27:17.839]             seq.int <- base::seq.int
[10:27:17.839]             signalCondition <- base::signalCondition
[10:27:17.839]             sys.calls <- base::sys.calls
[10:27:17.839]             `[[` <- base::`[[`
[10:27:17.839]             `+` <- base::`+`
[10:27:17.839]             `<<-` <- base::`<<-`
[10:27:17.839]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:17.839]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:17.839]                   3L)]
[10:27:17.839]             }
[10:27:17.839]             function(cond) {
[10:27:17.839]                 is_error <- inherits(cond, "error")
[10:27:17.839]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:17.839]                   NULL)
[10:27:17.839]                 if (is_error) {
[10:27:17.839]                   sessionInformation <- function() {
[10:27:17.839]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:17.839]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:17.839]                       search = base::search(), system = base::Sys.info())
[10:27:17.839]                   }
[10:27:17.839]                   ...future.conditions[[length(...future.conditions) + 
[10:27:17.839]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:17.839]                     cond$call), session = sessionInformation(), 
[10:27:17.839]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:17.839]                   signalCondition(cond)
[10:27:17.839]                 }
[10:27:17.839]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:17.839]                 "immediateCondition"))) {
[10:27:17.839]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:17.839]                   ...future.conditions[[length(...future.conditions) + 
[10:27:17.839]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:17.839]                   if (TRUE && !signal) {
[10:27:17.839]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:17.839]                     {
[10:27:17.839]                       inherits <- base::inherits
[10:27:17.839]                       invokeRestart <- base::invokeRestart
[10:27:17.839]                       is.null <- base::is.null
[10:27:17.839]                       muffled <- FALSE
[10:27:17.839]                       if (inherits(cond, "message")) {
[10:27:17.839]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:17.839]                         if (muffled) 
[10:27:17.839]                           invokeRestart("muffleMessage")
[10:27:17.839]                       }
[10:27:17.839]                       else if (inherits(cond, "warning")) {
[10:27:17.839]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:17.839]                         if (muffled) 
[10:27:17.839]                           invokeRestart("muffleWarning")
[10:27:17.839]                       }
[10:27:17.839]                       else if (inherits(cond, "condition")) {
[10:27:17.839]                         if (!is.null(pattern)) {
[10:27:17.839]                           computeRestarts <- base::computeRestarts
[10:27:17.839]                           grepl <- base::grepl
[10:27:17.839]                           restarts <- computeRestarts(cond)
[10:27:17.839]                           for (restart in restarts) {
[10:27:17.839]                             name <- restart$name
[10:27:17.839]                             if (is.null(name)) 
[10:27:17.839]                               next
[10:27:17.839]                             if (!grepl(pattern, name)) 
[10:27:17.839]                               next
[10:27:17.839]                             invokeRestart(restart)
[10:27:17.839]                             muffled <- TRUE
[10:27:17.839]                             break
[10:27:17.839]                           }
[10:27:17.839]                         }
[10:27:17.839]                       }
[10:27:17.839]                       invisible(muffled)
[10:27:17.839]                     }
[10:27:17.839]                     muffleCondition(cond, pattern = "^muffle")
[10:27:17.839]                   }
[10:27:17.839]                 }
[10:27:17.839]                 else {
[10:27:17.839]                   if (TRUE) {
[10:27:17.839]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:17.839]                     {
[10:27:17.839]                       inherits <- base::inherits
[10:27:17.839]                       invokeRestart <- base::invokeRestart
[10:27:17.839]                       is.null <- base::is.null
[10:27:17.839]                       muffled <- FALSE
[10:27:17.839]                       if (inherits(cond, "message")) {
[10:27:17.839]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:17.839]                         if (muffled) 
[10:27:17.839]                           invokeRestart("muffleMessage")
[10:27:17.839]                       }
[10:27:17.839]                       else if (inherits(cond, "warning")) {
[10:27:17.839]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:17.839]                         if (muffled) 
[10:27:17.839]                           invokeRestart("muffleWarning")
[10:27:17.839]                       }
[10:27:17.839]                       else if (inherits(cond, "condition")) {
[10:27:17.839]                         if (!is.null(pattern)) {
[10:27:17.839]                           computeRestarts <- base::computeRestarts
[10:27:17.839]                           grepl <- base::grepl
[10:27:17.839]                           restarts <- computeRestarts(cond)
[10:27:17.839]                           for (restart in restarts) {
[10:27:17.839]                             name <- restart$name
[10:27:17.839]                             if (is.null(name)) 
[10:27:17.839]                               next
[10:27:17.839]                             if (!grepl(pattern, name)) 
[10:27:17.839]                               next
[10:27:17.839]                             invokeRestart(restart)
[10:27:17.839]                             muffled <- TRUE
[10:27:17.839]                             break
[10:27:17.839]                           }
[10:27:17.839]                         }
[10:27:17.839]                       }
[10:27:17.839]                       invisible(muffled)
[10:27:17.839]                     }
[10:27:17.839]                     muffleCondition(cond, pattern = "^muffle")
[10:27:17.839]                   }
[10:27:17.839]                 }
[10:27:17.839]             }
[10:27:17.839]         }))
[10:27:17.839]     }, error = function(ex) {
[10:27:17.839]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:17.839]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:17.839]                 ...future.rng), started = ...future.startTime, 
[10:27:17.839]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:17.839]             version = "1.8"), class = "FutureResult")
[10:27:17.839]     }, finally = {
[10:27:17.839]         if (!identical(...future.workdir, getwd())) 
[10:27:17.839]             setwd(...future.workdir)
[10:27:17.839]         {
[10:27:17.839]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:17.839]                 ...future.oldOptions$nwarnings <- NULL
[10:27:17.839]             }
[10:27:17.839]             base::options(...future.oldOptions)
[10:27:17.839]             if (.Platform$OS.type == "windows") {
[10:27:17.839]                 old_names <- names(...future.oldEnvVars)
[10:27:17.839]                 envs <- base::Sys.getenv()
[10:27:17.839]                 names <- names(envs)
[10:27:17.839]                 common <- intersect(names, old_names)
[10:27:17.839]                 added <- setdiff(names, old_names)
[10:27:17.839]                 removed <- setdiff(old_names, names)
[10:27:17.839]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:17.839]                   envs[common]]
[10:27:17.839]                 NAMES <- toupper(changed)
[10:27:17.839]                 args <- list()
[10:27:17.839]                 for (kk in seq_along(NAMES)) {
[10:27:17.839]                   name <- changed[[kk]]
[10:27:17.839]                   NAME <- NAMES[[kk]]
[10:27:17.839]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:17.839]                     next
[10:27:17.839]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:17.839]                 }
[10:27:17.839]                 NAMES <- toupper(added)
[10:27:17.839]                 for (kk in seq_along(NAMES)) {
[10:27:17.839]                   name <- added[[kk]]
[10:27:17.839]                   NAME <- NAMES[[kk]]
[10:27:17.839]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:17.839]                     next
[10:27:17.839]                   args[[name]] <- ""
[10:27:17.839]                 }
[10:27:17.839]                 NAMES <- toupper(removed)
[10:27:17.839]                 for (kk in seq_along(NAMES)) {
[10:27:17.839]                   name <- removed[[kk]]
[10:27:17.839]                   NAME <- NAMES[[kk]]
[10:27:17.839]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:17.839]                     next
[10:27:17.839]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:17.839]                 }
[10:27:17.839]                 if (length(args) > 0) 
[10:27:17.839]                   base::do.call(base::Sys.setenv, args = args)
[10:27:17.839]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:17.839]             }
[10:27:17.839]             else {
[10:27:17.839]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:17.839]             }
[10:27:17.839]             {
[10:27:17.839]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:17.839]                   0L) {
[10:27:17.839]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:17.839]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:17.839]                   base::options(opts)
[10:27:17.839]                 }
[10:27:17.839]                 {
[10:27:17.839]                   {
[10:27:17.839]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:17.839]                     NULL
[10:27:17.839]                   }
[10:27:17.839]                   options(future.plan = NULL)
[10:27:17.839]                   if (is.na(NA_character_)) 
[10:27:17.839]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:17.839]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:17.839]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:17.839]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:17.839]                     envir = parent.frame()) 
[10:27:17.839]                   {
[10:27:17.839]                     if (is.function(workers)) 
[10:27:17.839]                       workers <- workers()
[10:27:17.839]                     workers <- structure(as.integer(workers), 
[10:27:17.839]                       class = class(workers))
[10:27:17.839]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:17.839]                       workers >= 1)
[10:27:17.839]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:17.839]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:17.839]                     }
[10:27:17.839]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:17.839]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:17.839]                       envir = envir)
[10:27:17.839]                     if (!future$lazy) 
[10:27:17.839]                       future <- run(future)
[10:27:17.839]                     invisible(future)
[10:27:17.839]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:17.839]                 }
[10:27:17.839]             }
[10:27:17.839]         }
[10:27:17.839]     })
[10:27:17.839]     if (TRUE) {
[10:27:17.839]         base::sink(type = "output", split = FALSE)
[10:27:17.839]         if (TRUE) {
[10:27:17.839]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:17.839]         }
[10:27:17.839]         else {
[10:27:17.839]             ...future.result["stdout"] <- base::list(NULL)
[10:27:17.839]         }
[10:27:17.839]         base::close(...future.stdout)
[10:27:17.839]         ...future.stdout <- NULL
[10:27:17.839]     }
[10:27:17.839]     ...future.result$conditions <- ...future.conditions
[10:27:17.839]     ...future.result$finished <- base::Sys.time()
[10:27:17.839]     ...future.result
[10:27:17.839] }
[10:27:17.842] MultisessionFuture started
[10:27:17.842] - Launch lazy future ... done
[10:27:17.843] run() for ‘MultisessionFuture’ ... done
[10:27:17.892] receiveMessageFromWorker() for ClusterFuture ...
[10:27:17.892] - Validating connection of MultisessionFuture
[10:27:17.893] - received message: FutureResult
[10:27:17.893] - Received FutureResult
[10:27:17.893] - Erased future from FutureRegistry
[10:27:17.893] result() for ClusterFuture ...
[10:27:17.894] - result already collected: FutureResult
[10:27:17.894] result() for ClusterFuture ... done
[10:27:17.894] signalConditions() ...
[10:27:17.894]  - include = ‘immediateCondition’
[10:27:17.894]  - exclude = 
[10:27:17.894]  - resignal = FALSE
[10:27:17.894]  - Number of conditions: 1
[10:27:17.894] signalConditions() ... done
[10:27:17.894] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:17.895] A MultisessionFuture was resolved
[10:27:17.895] getGlobalsAndPackages() ...
[10:27:17.895] Searching for globals...
[10:27:17.896] - globals found: [2] ‘list’, ‘stop’
[10:27:17.896] Searching for globals ... DONE
[10:27:17.896] Resolving globals: FALSE
[10:27:17.896] 
[10:27:17.896] 
[10:27:17.897] getGlobalsAndPackages() ... DONE
[10:27:17.897] run() for ‘Future’ ...
[10:27:17.897] - state: ‘created’
[10:27:17.897] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:17.913] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:17.913] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:17.913]   - Field: ‘node’
[10:27:17.913]   - Field: ‘label’
[10:27:17.913]   - Field: ‘local’
[10:27:17.914]   - Field: ‘owner’
[10:27:17.914]   - Field: ‘envir’
[10:27:17.914]   - Field: ‘workers’
[10:27:17.914]   - Field: ‘packages’
[10:27:17.914]   - Field: ‘gc’
[10:27:17.914]   - Field: ‘conditions’
[10:27:17.914]   - Field: ‘persistent’
[10:27:17.914]   - Field: ‘expr’
[10:27:17.914]   - Field: ‘uuid’
[10:27:17.914]   - Field: ‘seed’
[10:27:17.914]   - Field: ‘version’
[10:27:17.915]   - Field: ‘result’
[10:27:17.915]   - Field: ‘asynchronous’
[10:27:17.915]   - Field: ‘calls’
[10:27:17.915]   - Field: ‘globals’
[10:27:17.915]   - Field: ‘stdout’
[10:27:17.915]   - Field: ‘earlySignal’
[10:27:17.915]   - Field: ‘lazy’
[10:27:17.915]   - Field: ‘state’
[10:27:17.915] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:17.915] - Launch lazy future ...
[10:27:17.916] Packages needed by the future expression (n = 0): <none>
[10:27:17.916] Packages needed by future strategies (n = 0): <none>
[10:27:17.916] {
[10:27:17.916]     {
[10:27:17.916]         {
[10:27:17.916]             ...future.startTime <- base::Sys.time()
[10:27:17.916]             {
[10:27:17.916]                 {
[10:27:17.916]                   {
[10:27:17.916]                     {
[10:27:17.916]                       base::local({
[10:27:17.916]                         has_future <- base::requireNamespace("future", 
[10:27:17.916]                           quietly = TRUE)
[10:27:17.916]                         if (has_future) {
[10:27:17.916]                           ns <- base::getNamespace("future")
[10:27:17.916]                           version <- ns[[".package"]][["version"]]
[10:27:17.916]                           if (is.null(version)) 
[10:27:17.916]                             version <- utils::packageVersion("future")
[10:27:17.916]                         }
[10:27:17.916]                         else {
[10:27:17.916]                           version <- NULL
[10:27:17.916]                         }
[10:27:17.916]                         if (!has_future || version < "1.8.0") {
[10:27:17.916]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:17.916]                             "", base::R.version$version.string), 
[10:27:17.916]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:17.916]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:17.916]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:17.916]                               "release", "version")], collapse = " "), 
[10:27:17.916]                             hostname = base::Sys.info()[["nodename"]])
[10:27:17.916]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:17.916]                             info)
[10:27:17.916]                           info <- base::paste(info, collapse = "; ")
[10:27:17.916]                           if (!has_future) {
[10:27:17.916]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:17.916]                               info)
[10:27:17.916]                           }
[10:27:17.916]                           else {
[10:27:17.916]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:17.916]                               info, version)
[10:27:17.916]                           }
[10:27:17.916]                           base::stop(msg)
[10:27:17.916]                         }
[10:27:17.916]                       })
[10:27:17.916]                     }
[10:27:17.916]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:17.916]                     base::options(mc.cores = 1L)
[10:27:17.916]                   }
[10:27:17.916]                   options(future.plan = NULL)
[10:27:17.916]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:17.916]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:17.916]                 }
[10:27:17.916]                 ...future.workdir <- getwd()
[10:27:17.916]             }
[10:27:17.916]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:17.916]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:17.916]         }
[10:27:17.916]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:17.916]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:17.916]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:17.916]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:17.916]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:17.916]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:17.916]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:17.916]             base::names(...future.oldOptions))
[10:27:17.916]     }
[10:27:17.916]     if (FALSE) {
[10:27:17.916]     }
[10:27:17.916]     else {
[10:27:17.916]         if (TRUE) {
[10:27:17.916]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:17.916]                 open = "w")
[10:27:17.916]         }
[10:27:17.916]         else {
[10:27:17.916]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:17.916]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:17.916]         }
[10:27:17.916]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:17.916]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:17.916]             base::sink(type = "output", split = FALSE)
[10:27:17.916]             base::close(...future.stdout)
[10:27:17.916]         }, add = TRUE)
[10:27:17.916]     }
[10:27:17.916]     ...future.frame <- base::sys.nframe()
[10:27:17.916]     ...future.conditions <- base::list()
[10:27:17.916]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:17.916]     if (FALSE) {
[10:27:17.916]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:17.916]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:17.916]     }
[10:27:17.916]     ...future.result <- base::tryCatch({
[10:27:17.916]         base::withCallingHandlers({
[10:27:17.916]             ...future.value <- base::withVisible(base::local({
[10:27:17.916]                 ...future.makeSendCondition <- base::local({
[10:27:17.916]                   sendCondition <- NULL
[10:27:17.916]                   function(frame = 1L) {
[10:27:17.916]                     if (is.function(sendCondition)) 
[10:27:17.916]                       return(sendCondition)
[10:27:17.916]                     ns <- getNamespace("parallel")
[10:27:17.916]                     if (exists("sendData", mode = "function", 
[10:27:17.916]                       envir = ns)) {
[10:27:17.916]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:17.916]                         envir = ns)
[10:27:17.916]                       envir <- sys.frame(frame)
[10:27:17.916]                       master <- NULL
[10:27:17.916]                       while (!identical(envir, .GlobalEnv) && 
[10:27:17.916]                         !identical(envir, emptyenv())) {
[10:27:17.916]                         if (exists("master", mode = "list", envir = envir, 
[10:27:17.916]                           inherits = FALSE)) {
[10:27:17.916]                           master <- get("master", mode = "list", 
[10:27:17.916]                             envir = envir, inherits = FALSE)
[10:27:17.916]                           if (inherits(master, c("SOCKnode", 
[10:27:17.916]                             "SOCK0node"))) {
[10:27:17.916]                             sendCondition <<- function(cond) {
[10:27:17.916]                               data <- list(type = "VALUE", value = cond, 
[10:27:17.916]                                 success = TRUE)
[10:27:17.916]                               parallel_sendData(master, data)
[10:27:17.916]                             }
[10:27:17.916]                             return(sendCondition)
[10:27:17.916]                           }
[10:27:17.916]                         }
[10:27:17.916]                         frame <- frame + 1L
[10:27:17.916]                         envir <- sys.frame(frame)
[10:27:17.916]                       }
[10:27:17.916]                     }
[10:27:17.916]                     sendCondition <<- function(cond) NULL
[10:27:17.916]                   }
[10:27:17.916]                 })
[10:27:17.916]                 withCallingHandlers({
[10:27:17.916]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:27:17.916]                 }, immediateCondition = function(cond) {
[10:27:17.916]                   sendCondition <- ...future.makeSendCondition()
[10:27:17.916]                   sendCondition(cond)
[10:27:17.916]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:17.916]                   {
[10:27:17.916]                     inherits <- base::inherits
[10:27:17.916]                     invokeRestart <- base::invokeRestart
[10:27:17.916]                     is.null <- base::is.null
[10:27:17.916]                     muffled <- FALSE
[10:27:17.916]                     if (inherits(cond, "message")) {
[10:27:17.916]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:17.916]                       if (muffled) 
[10:27:17.916]                         invokeRestart("muffleMessage")
[10:27:17.916]                     }
[10:27:17.916]                     else if (inherits(cond, "warning")) {
[10:27:17.916]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:17.916]                       if (muffled) 
[10:27:17.916]                         invokeRestart("muffleWarning")
[10:27:17.916]                     }
[10:27:17.916]                     else if (inherits(cond, "condition")) {
[10:27:17.916]                       if (!is.null(pattern)) {
[10:27:17.916]                         computeRestarts <- base::computeRestarts
[10:27:17.916]                         grepl <- base::grepl
[10:27:17.916]                         restarts <- computeRestarts(cond)
[10:27:17.916]                         for (restart in restarts) {
[10:27:17.916]                           name <- restart$name
[10:27:17.916]                           if (is.null(name)) 
[10:27:17.916]                             next
[10:27:17.916]                           if (!grepl(pattern, name)) 
[10:27:17.916]                             next
[10:27:17.916]                           invokeRestart(restart)
[10:27:17.916]                           muffled <- TRUE
[10:27:17.916]                           break
[10:27:17.916]                         }
[10:27:17.916]                       }
[10:27:17.916]                     }
[10:27:17.916]                     invisible(muffled)
[10:27:17.916]                   }
[10:27:17.916]                   muffleCondition(cond)
[10:27:17.916]                 })
[10:27:17.916]             }))
[10:27:17.916]             future::FutureResult(value = ...future.value$value, 
[10:27:17.916]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:17.916]                   ...future.rng), globalenv = if (FALSE) 
[10:27:17.916]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:17.916]                     ...future.globalenv.names))
[10:27:17.916]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:17.916]         }, condition = base::local({
[10:27:17.916]             c <- base::c
[10:27:17.916]             inherits <- base::inherits
[10:27:17.916]             invokeRestart <- base::invokeRestart
[10:27:17.916]             length <- base::length
[10:27:17.916]             list <- base::list
[10:27:17.916]             seq.int <- base::seq.int
[10:27:17.916]             signalCondition <- base::signalCondition
[10:27:17.916]             sys.calls <- base::sys.calls
[10:27:17.916]             `[[` <- base::`[[`
[10:27:17.916]             `+` <- base::`+`
[10:27:17.916]             `<<-` <- base::`<<-`
[10:27:17.916]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:17.916]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:17.916]                   3L)]
[10:27:17.916]             }
[10:27:17.916]             function(cond) {
[10:27:17.916]                 is_error <- inherits(cond, "error")
[10:27:17.916]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:17.916]                   NULL)
[10:27:17.916]                 if (is_error) {
[10:27:17.916]                   sessionInformation <- function() {
[10:27:17.916]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:17.916]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:17.916]                       search = base::search(), system = base::Sys.info())
[10:27:17.916]                   }
[10:27:17.916]                   ...future.conditions[[length(...future.conditions) + 
[10:27:17.916]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:17.916]                     cond$call), session = sessionInformation(), 
[10:27:17.916]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:17.916]                   signalCondition(cond)
[10:27:17.916]                 }
[10:27:17.916]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:17.916]                 "immediateCondition"))) {
[10:27:17.916]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:17.916]                   ...future.conditions[[length(...future.conditions) + 
[10:27:17.916]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:17.916]                   if (TRUE && !signal) {
[10:27:17.916]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:17.916]                     {
[10:27:17.916]                       inherits <- base::inherits
[10:27:17.916]                       invokeRestart <- base::invokeRestart
[10:27:17.916]                       is.null <- base::is.null
[10:27:17.916]                       muffled <- FALSE
[10:27:17.916]                       if (inherits(cond, "message")) {
[10:27:17.916]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:17.916]                         if (muffled) 
[10:27:17.916]                           invokeRestart("muffleMessage")
[10:27:17.916]                       }
[10:27:17.916]                       else if (inherits(cond, "warning")) {
[10:27:17.916]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:17.916]                         if (muffled) 
[10:27:17.916]                           invokeRestart("muffleWarning")
[10:27:17.916]                       }
[10:27:17.916]                       else if (inherits(cond, "condition")) {
[10:27:17.916]                         if (!is.null(pattern)) {
[10:27:17.916]                           computeRestarts <- base::computeRestarts
[10:27:17.916]                           grepl <- base::grepl
[10:27:17.916]                           restarts <- computeRestarts(cond)
[10:27:17.916]                           for (restart in restarts) {
[10:27:17.916]                             name <- restart$name
[10:27:17.916]                             if (is.null(name)) 
[10:27:17.916]                               next
[10:27:17.916]                             if (!grepl(pattern, name)) 
[10:27:17.916]                               next
[10:27:17.916]                             invokeRestart(restart)
[10:27:17.916]                             muffled <- TRUE
[10:27:17.916]                             break
[10:27:17.916]                           }
[10:27:17.916]                         }
[10:27:17.916]                       }
[10:27:17.916]                       invisible(muffled)
[10:27:17.916]                     }
[10:27:17.916]                     muffleCondition(cond, pattern = "^muffle")
[10:27:17.916]                   }
[10:27:17.916]                 }
[10:27:17.916]                 else {
[10:27:17.916]                   if (TRUE) {
[10:27:17.916]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:17.916]                     {
[10:27:17.916]                       inherits <- base::inherits
[10:27:17.916]                       invokeRestart <- base::invokeRestart
[10:27:17.916]                       is.null <- base::is.null
[10:27:17.916]                       muffled <- FALSE
[10:27:17.916]                       if (inherits(cond, "message")) {
[10:27:17.916]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:17.916]                         if (muffled) 
[10:27:17.916]                           invokeRestart("muffleMessage")
[10:27:17.916]                       }
[10:27:17.916]                       else if (inherits(cond, "warning")) {
[10:27:17.916]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:17.916]                         if (muffled) 
[10:27:17.916]                           invokeRestart("muffleWarning")
[10:27:17.916]                       }
[10:27:17.916]                       else if (inherits(cond, "condition")) {
[10:27:17.916]                         if (!is.null(pattern)) {
[10:27:17.916]                           computeRestarts <- base::computeRestarts
[10:27:17.916]                           grepl <- base::grepl
[10:27:17.916]                           restarts <- computeRestarts(cond)
[10:27:17.916]                           for (restart in restarts) {
[10:27:17.916]                             name <- restart$name
[10:27:17.916]                             if (is.null(name)) 
[10:27:17.916]                               next
[10:27:17.916]                             if (!grepl(pattern, name)) 
[10:27:17.916]                               next
[10:27:17.916]                             invokeRestart(restart)
[10:27:17.916]                             muffled <- TRUE
[10:27:17.916]                             break
[10:27:17.916]                           }
[10:27:17.916]                         }
[10:27:17.916]                       }
[10:27:17.916]                       invisible(muffled)
[10:27:17.916]                     }
[10:27:17.916]                     muffleCondition(cond, pattern = "^muffle")
[10:27:17.916]                   }
[10:27:17.916]                 }
[10:27:17.916]             }
[10:27:17.916]         }))
[10:27:17.916]     }, error = function(ex) {
[10:27:17.916]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:17.916]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:17.916]                 ...future.rng), started = ...future.startTime, 
[10:27:17.916]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:17.916]             version = "1.8"), class = "FutureResult")
[10:27:17.916]     }, finally = {
[10:27:17.916]         if (!identical(...future.workdir, getwd())) 
[10:27:17.916]             setwd(...future.workdir)
[10:27:17.916]         {
[10:27:17.916]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:17.916]                 ...future.oldOptions$nwarnings <- NULL
[10:27:17.916]             }
[10:27:17.916]             base::options(...future.oldOptions)
[10:27:17.916]             if (.Platform$OS.type == "windows") {
[10:27:17.916]                 old_names <- names(...future.oldEnvVars)
[10:27:17.916]                 envs <- base::Sys.getenv()
[10:27:17.916]                 names <- names(envs)
[10:27:17.916]                 common <- intersect(names, old_names)
[10:27:17.916]                 added <- setdiff(names, old_names)
[10:27:17.916]                 removed <- setdiff(old_names, names)
[10:27:17.916]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:17.916]                   envs[common]]
[10:27:17.916]                 NAMES <- toupper(changed)
[10:27:17.916]                 args <- list()
[10:27:17.916]                 for (kk in seq_along(NAMES)) {
[10:27:17.916]                   name <- changed[[kk]]
[10:27:17.916]                   NAME <- NAMES[[kk]]
[10:27:17.916]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:17.916]                     next
[10:27:17.916]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:17.916]                 }
[10:27:17.916]                 NAMES <- toupper(added)
[10:27:17.916]                 for (kk in seq_along(NAMES)) {
[10:27:17.916]                   name <- added[[kk]]
[10:27:17.916]                   NAME <- NAMES[[kk]]
[10:27:17.916]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:17.916]                     next
[10:27:17.916]                   args[[name]] <- ""
[10:27:17.916]                 }
[10:27:17.916]                 NAMES <- toupper(removed)
[10:27:17.916]                 for (kk in seq_along(NAMES)) {
[10:27:17.916]                   name <- removed[[kk]]
[10:27:17.916]                   NAME <- NAMES[[kk]]
[10:27:17.916]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:17.916]                     next
[10:27:17.916]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:17.916]                 }
[10:27:17.916]                 if (length(args) > 0) 
[10:27:17.916]                   base::do.call(base::Sys.setenv, args = args)
[10:27:17.916]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:17.916]             }
[10:27:17.916]             else {
[10:27:17.916]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:17.916]             }
[10:27:17.916]             {
[10:27:17.916]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:17.916]                   0L) {
[10:27:17.916]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:17.916]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:17.916]                   base::options(opts)
[10:27:17.916]                 }
[10:27:17.916]                 {
[10:27:17.916]                   {
[10:27:17.916]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:17.916]                     NULL
[10:27:17.916]                   }
[10:27:17.916]                   options(future.plan = NULL)
[10:27:17.916]                   if (is.na(NA_character_)) 
[10:27:17.916]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:17.916]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:17.916]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:17.916]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:17.916]                     envir = parent.frame()) 
[10:27:17.916]                   {
[10:27:17.916]                     if (is.function(workers)) 
[10:27:17.916]                       workers <- workers()
[10:27:17.916]                     workers <- structure(as.integer(workers), 
[10:27:17.916]                       class = class(workers))
[10:27:17.916]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:17.916]                       workers >= 1)
[10:27:17.916]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:17.916]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:17.916]                     }
[10:27:17.916]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:17.916]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:17.916]                       envir = envir)
[10:27:17.916]                     if (!future$lazy) 
[10:27:17.916]                       future <- run(future)
[10:27:17.916]                     invisible(future)
[10:27:17.916]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:17.916]                 }
[10:27:17.916]             }
[10:27:17.916]         }
[10:27:17.916]     })
[10:27:17.916]     if (TRUE) {
[10:27:17.916]         base::sink(type = "output", split = FALSE)
[10:27:17.916]         if (TRUE) {
[10:27:17.916]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:17.916]         }
[10:27:17.916]         else {
[10:27:17.916]             ...future.result["stdout"] <- base::list(NULL)
[10:27:17.916]         }
[10:27:17.916]         base::close(...future.stdout)
[10:27:17.916]         ...future.stdout <- NULL
[10:27:17.916]     }
[10:27:17.916]     ...future.result$conditions <- ...future.conditions
[10:27:17.916]     ...future.result$finished <- base::Sys.time()
[10:27:17.916]     ...future.result
[10:27:17.916] }
[10:27:17.920] MultisessionFuture started
[10:27:17.920] - Launch lazy future ... done
[10:27:17.920] run() for ‘MultisessionFuture’ ... done
[10:27:17.967] receiveMessageFromWorker() for ClusterFuture ...
[10:27:17.967] - Validating connection of MultisessionFuture
[10:27:17.968] - received message: FutureResult
[10:27:17.968] - Received FutureResult
[10:27:17.968] - Erased future from FutureRegistry
[10:27:17.968] result() for ClusterFuture ...
[10:27:17.968] - result already collected: FutureResult
[10:27:17.968] result() for ClusterFuture ... done
[10:27:17.969] signalConditions() ...
[10:27:17.969]  - include = ‘immediateCondition’
[10:27:17.969]  - exclude = 
[10:27:17.969]  - resignal = FALSE
[10:27:17.969]  - Number of conditions: 1
[10:27:17.969] signalConditions() ... done
[10:27:17.969] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:17.969] A MultisessionFuture was resolved
- result = TRUE, recursive = 1 ... DONE
- result = TRUE, recursive = 2 ...
[10:27:17.970] getGlobalsAndPackages() ...
[10:27:17.970] Searching for globals...
[10:27:17.971] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:27:17.971] Searching for globals ... DONE
[10:27:17.971] Resolving globals: FALSE
[10:27:17.971] 
[10:27:17.971] 
[10:27:17.972] getGlobalsAndPackages() ... DONE
[10:27:17.972] run() for ‘Future’ ...
[10:27:17.972] - state: ‘created’
[10:27:17.972] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:17.986] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:17.986] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:17.986]   - Field: ‘node’
[10:27:17.986]   - Field: ‘label’
[10:27:17.987]   - Field: ‘local’
[10:27:17.987]   - Field: ‘owner’
[10:27:17.987]   - Field: ‘envir’
[10:27:17.987]   - Field: ‘workers’
[10:27:17.987]   - Field: ‘packages’
[10:27:17.987]   - Field: ‘gc’
[10:27:17.987]   - Field: ‘conditions’
[10:27:17.987]   - Field: ‘persistent’
[10:27:17.987]   - Field: ‘expr’
[10:27:17.987]   - Field: ‘uuid’
[10:27:17.988]   - Field: ‘seed’
[10:27:17.988]   - Field: ‘version’
[10:27:17.988]   - Field: ‘result’
[10:27:17.988]   - Field: ‘asynchronous’
[10:27:17.988]   - Field: ‘calls’
[10:27:17.988]   - Field: ‘globals’
[10:27:17.988]   - Field: ‘stdout’
[10:27:17.988]   - Field: ‘earlySignal’
[10:27:17.988]   - Field: ‘lazy’
[10:27:17.988]   - Field: ‘state’
[10:27:17.988] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:17.989] - Launch lazy future ...
[10:27:17.989] Packages needed by the future expression (n = 0): <none>
[10:27:17.989] Packages needed by future strategies (n = 0): <none>
[10:27:17.990] {
[10:27:17.990]     {
[10:27:17.990]         {
[10:27:17.990]             ...future.startTime <- base::Sys.time()
[10:27:17.990]             {
[10:27:17.990]                 {
[10:27:17.990]                   {
[10:27:17.990]                     {
[10:27:17.990]                       base::local({
[10:27:17.990]                         has_future <- base::requireNamespace("future", 
[10:27:17.990]                           quietly = TRUE)
[10:27:17.990]                         if (has_future) {
[10:27:17.990]                           ns <- base::getNamespace("future")
[10:27:17.990]                           version <- ns[[".package"]][["version"]]
[10:27:17.990]                           if (is.null(version)) 
[10:27:17.990]                             version <- utils::packageVersion("future")
[10:27:17.990]                         }
[10:27:17.990]                         else {
[10:27:17.990]                           version <- NULL
[10:27:17.990]                         }
[10:27:17.990]                         if (!has_future || version < "1.8.0") {
[10:27:17.990]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:17.990]                             "", base::R.version$version.string), 
[10:27:17.990]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:17.990]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:17.990]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:17.990]                               "release", "version")], collapse = " "), 
[10:27:17.990]                             hostname = base::Sys.info()[["nodename"]])
[10:27:17.990]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:17.990]                             info)
[10:27:17.990]                           info <- base::paste(info, collapse = "; ")
[10:27:17.990]                           if (!has_future) {
[10:27:17.990]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:17.990]                               info)
[10:27:17.990]                           }
[10:27:17.990]                           else {
[10:27:17.990]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:17.990]                               info, version)
[10:27:17.990]                           }
[10:27:17.990]                           base::stop(msg)
[10:27:17.990]                         }
[10:27:17.990]                       })
[10:27:17.990]                     }
[10:27:17.990]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:17.990]                     base::options(mc.cores = 1L)
[10:27:17.990]                   }
[10:27:17.990]                   options(future.plan = NULL)
[10:27:17.990]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:17.990]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:17.990]                 }
[10:27:17.990]                 ...future.workdir <- getwd()
[10:27:17.990]             }
[10:27:17.990]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:17.990]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:17.990]         }
[10:27:17.990]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:17.990]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:17.990]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:17.990]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:17.990]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:17.990]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:17.990]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:17.990]             base::names(...future.oldOptions))
[10:27:17.990]     }
[10:27:17.990]     if (FALSE) {
[10:27:17.990]     }
[10:27:17.990]     else {
[10:27:17.990]         if (TRUE) {
[10:27:17.990]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:17.990]                 open = "w")
[10:27:17.990]         }
[10:27:17.990]         else {
[10:27:17.990]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:17.990]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:17.990]         }
[10:27:17.990]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:17.990]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:17.990]             base::sink(type = "output", split = FALSE)
[10:27:17.990]             base::close(...future.stdout)
[10:27:17.990]         }, add = TRUE)
[10:27:17.990]     }
[10:27:17.990]     ...future.frame <- base::sys.nframe()
[10:27:17.990]     ...future.conditions <- base::list()
[10:27:17.990]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:17.990]     if (FALSE) {
[10:27:17.990]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:17.990]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:17.990]     }
[10:27:17.990]     ...future.result <- base::tryCatch({
[10:27:17.990]         base::withCallingHandlers({
[10:27:17.990]             ...future.value <- base::withVisible(base::local({
[10:27:17.990]                 ...future.makeSendCondition <- base::local({
[10:27:17.990]                   sendCondition <- NULL
[10:27:17.990]                   function(frame = 1L) {
[10:27:17.990]                     if (is.function(sendCondition)) 
[10:27:17.990]                       return(sendCondition)
[10:27:17.990]                     ns <- getNamespace("parallel")
[10:27:17.990]                     if (exists("sendData", mode = "function", 
[10:27:17.990]                       envir = ns)) {
[10:27:17.990]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:17.990]                         envir = ns)
[10:27:17.990]                       envir <- sys.frame(frame)
[10:27:17.990]                       master <- NULL
[10:27:17.990]                       while (!identical(envir, .GlobalEnv) && 
[10:27:17.990]                         !identical(envir, emptyenv())) {
[10:27:17.990]                         if (exists("master", mode = "list", envir = envir, 
[10:27:17.990]                           inherits = FALSE)) {
[10:27:17.990]                           master <- get("master", mode = "list", 
[10:27:17.990]                             envir = envir, inherits = FALSE)
[10:27:17.990]                           if (inherits(master, c("SOCKnode", 
[10:27:17.990]                             "SOCK0node"))) {
[10:27:17.990]                             sendCondition <<- function(cond) {
[10:27:17.990]                               data <- list(type = "VALUE", value = cond, 
[10:27:17.990]                                 success = TRUE)
[10:27:17.990]                               parallel_sendData(master, data)
[10:27:17.990]                             }
[10:27:17.990]                             return(sendCondition)
[10:27:17.990]                           }
[10:27:17.990]                         }
[10:27:17.990]                         frame <- frame + 1L
[10:27:17.990]                         envir <- sys.frame(frame)
[10:27:17.990]                       }
[10:27:17.990]                     }
[10:27:17.990]                     sendCondition <<- function(cond) NULL
[10:27:17.990]                   }
[10:27:17.990]                 })
[10:27:17.990]                 withCallingHandlers({
[10:27:17.990]                   {
[10:27:17.990]                     Sys.sleep(0.5)
[10:27:17.990]                     list(a = 1, b = 42L)
[10:27:17.990]                   }
[10:27:17.990]                 }, immediateCondition = function(cond) {
[10:27:17.990]                   sendCondition <- ...future.makeSendCondition()
[10:27:17.990]                   sendCondition(cond)
[10:27:17.990]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:17.990]                   {
[10:27:17.990]                     inherits <- base::inherits
[10:27:17.990]                     invokeRestart <- base::invokeRestart
[10:27:17.990]                     is.null <- base::is.null
[10:27:17.990]                     muffled <- FALSE
[10:27:17.990]                     if (inherits(cond, "message")) {
[10:27:17.990]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:17.990]                       if (muffled) 
[10:27:17.990]                         invokeRestart("muffleMessage")
[10:27:17.990]                     }
[10:27:17.990]                     else if (inherits(cond, "warning")) {
[10:27:17.990]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:17.990]                       if (muffled) 
[10:27:17.990]                         invokeRestart("muffleWarning")
[10:27:17.990]                     }
[10:27:17.990]                     else if (inherits(cond, "condition")) {
[10:27:17.990]                       if (!is.null(pattern)) {
[10:27:17.990]                         computeRestarts <- base::computeRestarts
[10:27:17.990]                         grepl <- base::grepl
[10:27:17.990]                         restarts <- computeRestarts(cond)
[10:27:17.990]                         for (restart in restarts) {
[10:27:17.990]                           name <- restart$name
[10:27:17.990]                           if (is.null(name)) 
[10:27:17.990]                             next
[10:27:17.990]                           if (!grepl(pattern, name)) 
[10:27:17.990]                             next
[10:27:17.990]                           invokeRestart(restart)
[10:27:17.990]                           muffled <- TRUE
[10:27:17.990]                           break
[10:27:17.990]                         }
[10:27:17.990]                       }
[10:27:17.990]                     }
[10:27:17.990]                     invisible(muffled)
[10:27:17.990]                   }
[10:27:17.990]                   muffleCondition(cond)
[10:27:17.990]                 })
[10:27:17.990]             }))
[10:27:17.990]             future::FutureResult(value = ...future.value$value, 
[10:27:17.990]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:17.990]                   ...future.rng), globalenv = if (FALSE) 
[10:27:17.990]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:17.990]                     ...future.globalenv.names))
[10:27:17.990]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:17.990]         }, condition = base::local({
[10:27:17.990]             c <- base::c
[10:27:17.990]             inherits <- base::inherits
[10:27:17.990]             invokeRestart <- base::invokeRestart
[10:27:17.990]             length <- base::length
[10:27:17.990]             list <- base::list
[10:27:17.990]             seq.int <- base::seq.int
[10:27:17.990]             signalCondition <- base::signalCondition
[10:27:17.990]             sys.calls <- base::sys.calls
[10:27:17.990]             `[[` <- base::`[[`
[10:27:17.990]             `+` <- base::`+`
[10:27:17.990]             `<<-` <- base::`<<-`
[10:27:17.990]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:17.990]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:17.990]                   3L)]
[10:27:17.990]             }
[10:27:17.990]             function(cond) {
[10:27:17.990]                 is_error <- inherits(cond, "error")
[10:27:17.990]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:17.990]                   NULL)
[10:27:17.990]                 if (is_error) {
[10:27:17.990]                   sessionInformation <- function() {
[10:27:17.990]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:17.990]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:17.990]                       search = base::search(), system = base::Sys.info())
[10:27:17.990]                   }
[10:27:17.990]                   ...future.conditions[[length(...future.conditions) + 
[10:27:17.990]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:17.990]                     cond$call), session = sessionInformation(), 
[10:27:17.990]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:17.990]                   signalCondition(cond)
[10:27:17.990]                 }
[10:27:17.990]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:17.990]                 "immediateCondition"))) {
[10:27:17.990]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:17.990]                   ...future.conditions[[length(...future.conditions) + 
[10:27:17.990]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:17.990]                   if (TRUE && !signal) {
[10:27:17.990]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:17.990]                     {
[10:27:17.990]                       inherits <- base::inherits
[10:27:17.990]                       invokeRestart <- base::invokeRestart
[10:27:17.990]                       is.null <- base::is.null
[10:27:17.990]                       muffled <- FALSE
[10:27:17.990]                       if (inherits(cond, "message")) {
[10:27:17.990]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:17.990]                         if (muffled) 
[10:27:17.990]                           invokeRestart("muffleMessage")
[10:27:17.990]                       }
[10:27:17.990]                       else if (inherits(cond, "warning")) {
[10:27:17.990]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:17.990]                         if (muffled) 
[10:27:17.990]                           invokeRestart("muffleWarning")
[10:27:17.990]                       }
[10:27:17.990]                       else if (inherits(cond, "condition")) {
[10:27:17.990]                         if (!is.null(pattern)) {
[10:27:17.990]                           computeRestarts <- base::computeRestarts
[10:27:17.990]                           grepl <- base::grepl
[10:27:17.990]                           restarts <- computeRestarts(cond)
[10:27:17.990]                           for (restart in restarts) {
[10:27:17.990]                             name <- restart$name
[10:27:17.990]                             if (is.null(name)) 
[10:27:17.990]                               next
[10:27:17.990]                             if (!grepl(pattern, name)) 
[10:27:17.990]                               next
[10:27:17.990]                             invokeRestart(restart)
[10:27:17.990]                             muffled <- TRUE
[10:27:17.990]                             break
[10:27:17.990]                           }
[10:27:17.990]                         }
[10:27:17.990]                       }
[10:27:17.990]                       invisible(muffled)
[10:27:17.990]                     }
[10:27:17.990]                     muffleCondition(cond, pattern = "^muffle")
[10:27:17.990]                   }
[10:27:17.990]                 }
[10:27:17.990]                 else {
[10:27:17.990]                   if (TRUE) {
[10:27:17.990]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:17.990]                     {
[10:27:17.990]                       inherits <- base::inherits
[10:27:17.990]                       invokeRestart <- base::invokeRestart
[10:27:17.990]                       is.null <- base::is.null
[10:27:17.990]                       muffled <- FALSE
[10:27:17.990]                       if (inherits(cond, "message")) {
[10:27:17.990]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:17.990]                         if (muffled) 
[10:27:17.990]                           invokeRestart("muffleMessage")
[10:27:17.990]                       }
[10:27:17.990]                       else if (inherits(cond, "warning")) {
[10:27:17.990]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:17.990]                         if (muffled) 
[10:27:17.990]                           invokeRestart("muffleWarning")
[10:27:17.990]                       }
[10:27:17.990]                       else if (inherits(cond, "condition")) {
[10:27:17.990]                         if (!is.null(pattern)) {
[10:27:17.990]                           computeRestarts <- base::computeRestarts
[10:27:17.990]                           grepl <- base::grepl
[10:27:17.990]                           restarts <- computeRestarts(cond)
[10:27:17.990]                           for (restart in restarts) {
[10:27:17.990]                             name <- restart$name
[10:27:17.990]                             if (is.null(name)) 
[10:27:17.990]                               next
[10:27:17.990]                             if (!grepl(pattern, name)) 
[10:27:17.990]                               next
[10:27:17.990]                             invokeRestart(restart)
[10:27:17.990]                             muffled <- TRUE
[10:27:17.990]                             break
[10:27:17.990]                           }
[10:27:17.990]                         }
[10:27:17.990]                       }
[10:27:17.990]                       invisible(muffled)
[10:27:17.990]                     }
[10:27:17.990]                     muffleCondition(cond, pattern = "^muffle")
[10:27:17.990]                   }
[10:27:17.990]                 }
[10:27:17.990]             }
[10:27:17.990]         }))
[10:27:17.990]     }, error = function(ex) {
[10:27:17.990]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:17.990]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:17.990]                 ...future.rng), started = ...future.startTime, 
[10:27:17.990]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:17.990]             version = "1.8"), class = "FutureResult")
[10:27:17.990]     }, finally = {
[10:27:17.990]         if (!identical(...future.workdir, getwd())) 
[10:27:17.990]             setwd(...future.workdir)
[10:27:17.990]         {
[10:27:17.990]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:17.990]                 ...future.oldOptions$nwarnings <- NULL
[10:27:17.990]             }
[10:27:17.990]             base::options(...future.oldOptions)
[10:27:17.990]             if (.Platform$OS.type == "windows") {
[10:27:17.990]                 old_names <- names(...future.oldEnvVars)
[10:27:17.990]                 envs <- base::Sys.getenv()
[10:27:17.990]                 names <- names(envs)
[10:27:17.990]                 common <- intersect(names, old_names)
[10:27:17.990]                 added <- setdiff(names, old_names)
[10:27:17.990]                 removed <- setdiff(old_names, names)
[10:27:17.990]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:17.990]                   envs[common]]
[10:27:17.990]                 NAMES <- toupper(changed)
[10:27:17.990]                 args <- list()
[10:27:17.990]                 for (kk in seq_along(NAMES)) {
[10:27:17.990]                   name <- changed[[kk]]
[10:27:17.990]                   NAME <- NAMES[[kk]]
[10:27:17.990]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:17.990]                     next
[10:27:17.990]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:17.990]                 }
[10:27:17.990]                 NAMES <- toupper(added)
[10:27:17.990]                 for (kk in seq_along(NAMES)) {
[10:27:17.990]                   name <- added[[kk]]
[10:27:17.990]                   NAME <- NAMES[[kk]]
[10:27:17.990]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:17.990]                     next
[10:27:17.990]                   args[[name]] <- ""
[10:27:17.990]                 }
[10:27:17.990]                 NAMES <- toupper(removed)
[10:27:17.990]                 for (kk in seq_along(NAMES)) {
[10:27:17.990]                   name <- removed[[kk]]
[10:27:17.990]                   NAME <- NAMES[[kk]]
[10:27:17.990]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:17.990]                     next
[10:27:17.990]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:17.990]                 }
[10:27:17.990]                 if (length(args) > 0) 
[10:27:17.990]                   base::do.call(base::Sys.setenv, args = args)
[10:27:17.990]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:17.990]             }
[10:27:17.990]             else {
[10:27:17.990]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:17.990]             }
[10:27:17.990]             {
[10:27:17.990]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:17.990]                   0L) {
[10:27:17.990]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:17.990]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:17.990]                   base::options(opts)
[10:27:17.990]                 }
[10:27:17.990]                 {
[10:27:17.990]                   {
[10:27:17.990]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:17.990]                     NULL
[10:27:17.990]                   }
[10:27:17.990]                   options(future.plan = NULL)
[10:27:17.990]                   if (is.na(NA_character_)) 
[10:27:17.990]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:17.990]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:17.990]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:17.990]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:17.990]                     envir = parent.frame()) 
[10:27:17.990]                   {
[10:27:17.990]                     if (is.function(workers)) 
[10:27:17.990]                       workers <- workers()
[10:27:17.990]                     workers <- structure(as.integer(workers), 
[10:27:17.990]                       class = class(workers))
[10:27:17.990]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:17.990]                       workers >= 1)
[10:27:17.990]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:17.990]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:17.990]                     }
[10:27:17.990]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:17.990]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:17.990]                       envir = envir)
[10:27:17.990]                     if (!future$lazy) 
[10:27:17.990]                       future <- run(future)
[10:27:17.990]                     invisible(future)
[10:27:17.990]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:17.990]                 }
[10:27:17.990]             }
[10:27:17.990]         }
[10:27:17.990]     })
[10:27:17.990]     if (TRUE) {
[10:27:17.990]         base::sink(type = "output", split = FALSE)
[10:27:17.990]         if (TRUE) {
[10:27:17.990]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:17.990]         }
[10:27:17.990]         else {
[10:27:17.990]             ...future.result["stdout"] <- base::list(NULL)
[10:27:17.990]         }
[10:27:17.990]         base::close(...future.stdout)
[10:27:17.990]         ...future.stdout <- NULL
[10:27:17.990]     }
[10:27:17.990]     ...future.result$conditions <- ...future.conditions
[10:27:17.990]     ...future.result$finished <- base::Sys.time()
[10:27:17.990]     ...future.result
[10:27:17.990] }
[10:27:17.993] MultisessionFuture started
[10:27:17.993] - Launch lazy future ... done
[10:27:17.993] run() for ‘MultisessionFuture’ ... done
[10:27:18.541] receiveMessageFromWorker() for ClusterFuture ...
[10:27:18.541] - Validating connection of MultisessionFuture
[10:27:18.541] - received message: FutureResult
[10:27:18.542] - Received FutureResult
[10:27:18.542] - Erased future from FutureRegistry
[10:27:18.542] result() for ClusterFuture ...
[10:27:18.542] - result already collected: FutureResult
[10:27:18.542] result() for ClusterFuture ... done
[10:27:18.542] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:18.542] resolve() on list ...
[10:27:18.542]  recursive: 1
[10:27:18.542]  length: 2
[10:27:18.542]  elements: ‘a’, ‘b’
[10:27:18.543]  length: 1 (resolved future 1)
[10:27:18.543]  length: 0 (resolved future 2)
[10:27:18.543] resolve() on list ... DONE
[10:27:18.543] A MultisessionFuture was resolved (and resolved itself)
[10:27:18.543] getGlobalsAndPackages() ...
[10:27:18.543] Searching for globals...
[10:27:18.544] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:27:18.544] Searching for globals ... DONE
[10:27:18.545] Resolving globals: FALSE
[10:27:18.545] 
[10:27:18.545] 
[10:27:18.545] getGlobalsAndPackages() ... DONE
[10:27:18.546] run() for ‘Future’ ...
[10:27:18.546] - state: ‘created’
[10:27:18.546] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:18.560] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:18.560] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:18.561]   - Field: ‘node’
[10:27:18.561]   - Field: ‘label’
[10:27:18.561]   - Field: ‘local’
[10:27:18.561]   - Field: ‘owner’
[10:27:18.561]   - Field: ‘envir’
[10:27:18.561]   - Field: ‘workers’
[10:27:18.561]   - Field: ‘packages’
[10:27:18.561]   - Field: ‘gc’
[10:27:18.561]   - Field: ‘conditions’
[10:27:18.562]   - Field: ‘persistent’
[10:27:18.562]   - Field: ‘expr’
[10:27:18.562]   - Field: ‘uuid’
[10:27:18.562]   - Field: ‘seed’
[10:27:18.562]   - Field: ‘version’
[10:27:18.562]   - Field: ‘result’
[10:27:18.562]   - Field: ‘asynchronous’
[10:27:18.562]   - Field: ‘calls’
[10:27:18.562]   - Field: ‘globals’
[10:27:18.562]   - Field: ‘stdout’
[10:27:18.563]   - Field: ‘earlySignal’
[10:27:18.563]   - Field: ‘lazy’
[10:27:18.563]   - Field: ‘state’
[10:27:18.563] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:18.563] - Launch lazy future ...
[10:27:18.563] Packages needed by the future expression (n = 0): <none>
[10:27:18.563] Packages needed by future strategies (n = 0): <none>
[10:27:18.564] {
[10:27:18.564]     {
[10:27:18.564]         {
[10:27:18.564]             ...future.startTime <- base::Sys.time()
[10:27:18.564]             {
[10:27:18.564]                 {
[10:27:18.564]                   {
[10:27:18.564]                     {
[10:27:18.564]                       base::local({
[10:27:18.564]                         has_future <- base::requireNamespace("future", 
[10:27:18.564]                           quietly = TRUE)
[10:27:18.564]                         if (has_future) {
[10:27:18.564]                           ns <- base::getNamespace("future")
[10:27:18.564]                           version <- ns[[".package"]][["version"]]
[10:27:18.564]                           if (is.null(version)) 
[10:27:18.564]                             version <- utils::packageVersion("future")
[10:27:18.564]                         }
[10:27:18.564]                         else {
[10:27:18.564]                           version <- NULL
[10:27:18.564]                         }
[10:27:18.564]                         if (!has_future || version < "1.8.0") {
[10:27:18.564]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:18.564]                             "", base::R.version$version.string), 
[10:27:18.564]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:18.564]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:18.564]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:18.564]                               "release", "version")], collapse = " "), 
[10:27:18.564]                             hostname = base::Sys.info()[["nodename"]])
[10:27:18.564]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:18.564]                             info)
[10:27:18.564]                           info <- base::paste(info, collapse = "; ")
[10:27:18.564]                           if (!has_future) {
[10:27:18.564]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:18.564]                               info)
[10:27:18.564]                           }
[10:27:18.564]                           else {
[10:27:18.564]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:18.564]                               info, version)
[10:27:18.564]                           }
[10:27:18.564]                           base::stop(msg)
[10:27:18.564]                         }
[10:27:18.564]                       })
[10:27:18.564]                     }
[10:27:18.564]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:18.564]                     base::options(mc.cores = 1L)
[10:27:18.564]                   }
[10:27:18.564]                   options(future.plan = NULL)
[10:27:18.564]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:18.564]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:18.564]                 }
[10:27:18.564]                 ...future.workdir <- getwd()
[10:27:18.564]             }
[10:27:18.564]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:18.564]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:18.564]         }
[10:27:18.564]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:18.564]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:18.564]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:18.564]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:18.564]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:18.564]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:18.564]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:18.564]             base::names(...future.oldOptions))
[10:27:18.564]     }
[10:27:18.564]     if (FALSE) {
[10:27:18.564]     }
[10:27:18.564]     else {
[10:27:18.564]         if (TRUE) {
[10:27:18.564]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:18.564]                 open = "w")
[10:27:18.564]         }
[10:27:18.564]         else {
[10:27:18.564]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:18.564]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:18.564]         }
[10:27:18.564]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:18.564]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:18.564]             base::sink(type = "output", split = FALSE)
[10:27:18.564]             base::close(...future.stdout)
[10:27:18.564]         }, add = TRUE)
[10:27:18.564]     }
[10:27:18.564]     ...future.frame <- base::sys.nframe()
[10:27:18.564]     ...future.conditions <- base::list()
[10:27:18.564]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:18.564]     if (FALSE) {
[10:27:18.564]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:18.564]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:18.564]     }
[10:27:18.564]     ...future.result <- base::tryCatch({
[10:27:18.564]         base::withCallingHandlers({
[10:27:18.564]             ...future.value <- base::withVisible(base::local({
[10:27:18.564]                 ...future.makeSendCondition <- base::local({
[10:27:18.564]                   sendCondition <- NULL
[10:27:18.564]                   function(frame = 1L) {
[10:27:18.564]                     if (is.function(sendCondition)) 
[10:27:18.564]                       return(sendCondition)
[10:27:18.564]                     ns <- getNamespace("parallel")
[10:27:18.564]                     if (exists("sendData", mode = "function", 
[10:27:18.564]                       envir = ns)) {
[10:27:18.564]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:18.564]                         envir = ns)
[10:27:18.564]                       envir <- sys.frame(frame)
[10:27:18.564]                       master <- NULL
[10:27:18.564]                       while (!identical(envir, .GlobalEnv) && 
[10:27:18.564]                         !identical(envir, emptyenv())) {
[10:27:18.564]                         if (exists("master", mode = "list", envir = envir, 
[10:27:18.564]                           inherits = FALSE)) {
[10:27:18.564]                           master <- get("master", mode = "list", 
[10:27:18.564]                             envir = envir, inherits = FALSE)
[10:27:18.564]                           if (inherits(master, c("SOCKnode", 
[10:27:18.564]                             "SOCK0node"))) {
[10:27:18.564]                             sendCondition <<- function(cond) {
[10:27:18.564]                               data <- list(type = "VALUE", value = cond, 
[10:27:18.564]                                 success = TRUE)
[10:27:18.564]                               parallel_sendData(master, data)
[10:27:18.564]                             }
[10:27:18.564]                             return(sendCondition)
[10:27:18.564]                           }
[10:27:18.564]                         }
[10:27:18.564]                         frame <- frame + 1L
[10:27:18.564]                         envir <- sys.frame(frame)
[10:27:18.564]                       }
[10:27:18.564]                     }
[10:27:18.564]                     sendCondition <<- function(cond) NULL
[10:27:18.564]                   }
[10:27:18.564]                 })
[10:27:18.564]                 withCallingHandlers({
[10:27:18.564]                   {
[10:27:18.564]                     Sys.sleep(0.5)
[10:27:18.564]                     list(a = 1, b = 42L)
[10:27:18.564]                   }
[10:27:18.564]                 }, immediateCondition = function(cond) {
[10:27:18.564]                   sendCondition <- ...future.makeSendCondition()
[10:27:18.564]                   sendCondition(cond)
[10:27:18.564]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:18.564]                   {
[10:27:18.564]                     inherits <- base::inherits
[10:27:18.564]                     invokeRestart <- base::invokeRestart
[10:27:18.564]                     is.null <- base::is.null
[10:27:18.564]                     muffled <- FALSE
[10:27:18.564]                     if (inherits(cond, "message")) {
[10:27:18.564]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:18.564]                       if (muffled) 
[10:27:18.564]                         invokeRestart("muffleMessage")
[10:27:18.564]                     }
[10:27:18.564]                     else if (inherits(cond, "warning")) {
[10:27:18.564]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:18.564]                       if (muffled) 
[10:27:18.564]                         invokeRestart("muffleWarning")
[10:27:18.564]                     }
[10:27:18.564]                     else if (inherits(cond, "condition")) {
[10:27:18.564]                       if (!is.null(pattern)) {
[10:27:18.564]                         computeRestarts <- base::computeRestarts
[10:27:18.564]                         grepl <- base::grepl
[10:27:18.564]                         restarts <- computeRestarts(cond)
[10:27:18.564]                         for (restart in restarts) {
[10:27:18.564]                           name <- restart$name
[10:27:18.564]                           if (is.null(name)) 
[10:27:18.564]                             next
[10:27:18.564]                           if (!grepl(pattern, name)) 
[10:27:18.564]                             next
[10:27:18.564]                           invokeRestart(restart)
[10:27:18.564]                           muffled <- TRUE
[10:27:18.564]                           break
[10:27:18.564]                         }
[10:27:18.564]                       }
[10:27:18.564]                     }
[10:27:18.564]                     invisible(muffled)
[10:27:18.564]                   }
[10:27:18.564]                   muffleCondition(cond)
[10:27:18.564]                 })
[10:27:18.564]             }))
[10:27:18.564]             future::FutureResult(value = ...future.value$value, 
[10:27:18.564]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:18.564]                   ...future.rng), globalenv = if (FALSE) 
[10:27:18.564]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:18.564]                     ...future.globalenv.names))
[10:27:18.564]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:18.564]         }, condition = base::local({
[10:27:18.564]             c <- base::c
[10:27:18.564]             inherits <- base::inherits
[10:27:18.564]             invokeRestart <- base::invokeRestart
[10:27:18.564]             length <- base::length
[10:27:18.564]             list <- base::list
[10:27:18.564]             seq.int <- base::seq.int
[10:27:18.564]             signalCondition <- base::signalCondition
[10:27:18.564]             sys.calls <- base::sys.calls
[10:27:18.564]             `[[` <- base::`[[`
[10:27:18.564]             `+` <- base::`+`
[10:27:18.564]             `<<-` <- base::`<<-`
[10:27:18.564]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:18.564]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:18.564]                   3L)]
[10:27:18.564]             }
[10:27:18.564]             function(cond) {
[10:27:18.564]                 is_error <- inherits(cond, "error")
[10:27:18.564]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:18.564]                   NULL)
[10:27:18.564]                 if (is_error) {
[10:27:18.564]                   sessionInformation <- function() {
[10:27:18.564]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:18.564]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:18.564]                       search = base::search(), system = base::Sys.info())
[10:27:18.564]                   }
[10:27:18.564]                   ...future.conditions[[length(...future.conditions) + 
[10:27:18.564]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:18.564]                     cond$call), session = sessionInformation(), 
[10:27:18.564]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:18.564]                   signalCondition(cond)
[10:27:18.564]                 }
[10:27:18.564]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:18.564]                 "immediateCondition"))) {
[10:27:18.564]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:18.564]                   ...future.conditions[[length(...future.conditions) + 
[10:27:18.564]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:18.564]                   if (TRUE && !signal) {
[10:27:18.564]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:18.564]                     {
[10:27:18.564]                       inherits <- base::inherits
[10:27:18.564]                       invokeRestart <- base::invokeRestart
[10:27:18.564]                       is.null <- base::is.null
[10:27:18.564]                       muffled <- FALSE
[10:27:18.564]                       if (inherits(cond, "message")) {
[10:27:18.564]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:18.564]                         if (muffled) 
[10:27:18.564]                           invokeRestart("muffleMessage")
[10:27:18.564]                       }
[10:27:18.564]                       else if (inherits(cond, "warning")) {
[10:27:18.564]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:18.564]                         if (muffled) 
[10:27:18.564]                           invokeRestart("muffleWarning")
[10:27:18.564]                       }
[10:27:18.564]                       else if (inherits(cond, "condition")) {
[10:27:18.564]                         if (!is.null(pattern)) {
[10:27:18.564]                           computeRestarts <- base::computeRestarts
[10:27:18.564]                           grepl <- base::grepl
[10:27:18.564]                           restarts <- computeRestarts(cond)
[10:27:18.564]                           for (restart in restarts) {
[10:27:18.564]                             name <- restart$name
[10:27:18.564]                             if (is.null(name)) 
[10:27:18.564]                               next
[10:27:18.564]                             if (!grepl(pattern, name)) 
[10:27:18.564]                               next
[10:27:18.564]                             invokeRestart(restart)
[10:27:18.564]                             muffled <- TRUE
[10:27:18.564]                             break
[10:27:18.564]                           }
[10:27:18.564]                         }
[10:27:18.564]                       }
[10:27:18.564]                       invisible(muffled)
[10:27:18.564]                     }
[10:27:18.564]                     muffleCondition(cond, pattern = "^muffle")
[10:27:18.564]                   }
[10:27:18.564]                 }
[10:27:18.564]                 else {
[10:27:18.564]                   if (TRUE) {
[10:27:18.564]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:18.564]                     {
[10:27:18.564]                       inherits <- base::inherits
[10:27:18.564]                       invokeRestart <- base::invokeRestart
[10:27:18.564]                       is.null <- base::is.null
[10:27:18.564]                       muffled <- FALSE
[10:27:18.564]                       if (inherits(cond, "message")) {
[10:27:18.564]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:18.564]                         if (muffled) 
[10:27:18.564]                           invokeRestart("muffleMessage")
[10:27:18.564]                       }
[10:27:18.564]                       else if (inherits(cond, "warning")) {
[10:27:18.564]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:18.564]                         if (muffled) 
[10:27:18.564]                           invokeRestart("muffleWarning")
[10:27:18.564]                       }
[10:27:18.564]                       else if (inherits(cond, "condition")) {
[10:27:18.564]                         if (!is.null(pattern)) {
[10:27:18.564]                           computeRestarts <- base::computeRestarts
[10:27:18.564]                           grepl <- base::grepl
[10:27:18.564]                           restarts <- computeRestarts(cond)
[10:27:18.564]                           for (restart in restarts) {
[10:27:18.564]                             name <- restart$name
[10:27:18.564]                             if (is.null(name)) 
[10:27:18.564]                               next
[10:27:18.564]                             if (!grepl(pattern, name)) 
[10:27:18.564]                               next
[10:27:18.564]                             invokeRestart(restart)
[10:27:18.564]                             muffled <- TRUE
[10:27:18.564]                             break
[10:27:18.564]                           }
[10:27:18.564]                         }
[10:27:18.564]                       }
[10:27:18.564]                       invisible(muffled)
[10:27:18.564]                     }
[10:27:18.564]                     muffleCondition(cond, pattern = "^muffle")
[10:27:18.564]                   }
[10:27:18.564]                 }
[10:27:18.564]             }
[10:27:18.564]         }))
[10:27:18.564]     }, error = function(ex) {
[10:27:18.564]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:18.564]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:18.564]                 ...future.rng), started = ...future.startTime, 
[10:27:18.564]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:18.564]             version = "1.8"), class = "FutureResult")
[10:27:18.564]     }, finally = {
[10:27:18.564]         if (!identical(...future.workdir, getwd())) 
[10:27:18.564]             setwd(...future.workdir)
[10:27:18.564]         {
[10:27:18.564]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:18.564]                 ...future.oldOptions$nwarnings <- NULL
[10:27:18.564]             }
[10:27:18.564]             base::options(...future.oldOptions)
[10:27:18.564]             if (.Platform$OS.type == "windows") {
[10:27:18.564]                 old_names <- names(...future.oldEnvVars)
[10:27:18.564]                 envs <- base::Sys.getenv()
[10:27:18.564]                 names <- names(envs)
[10:27:18.564]                 common <- intersect(names, old_names)
[10:27:18.564]                 added <- setdiff(names, old_names)
[10:27:18.564]                 removed <- setdiff(old_names, names)
[10:27:18.564]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:18.564]                   envs[common]]
[10:27:18.564]                 NAMES <- toupper(changed)
[10:27:18.564]                 args <- list()
[10:27:18.564]                 for (kk in seq_along(NAMES)) {
[10:27:18.564]                   name <- changed[[kk]]
[10:27:18.564]                   NAME <- NAMES[[kk]]
[10:27:18.564]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:18.564]                     next
[10:27:18.564]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:18.564]                 }
[10:27:18.564]                 NAMES <- toupper(added)
[10:27:18.564]                 for (kk in seq_along(NAMES)) {
[10:27:18.564]                   name <- added[[kk]]
[10:27:18.564]                   NAME <- NAMES[[kk]]
[10:27:18.564]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:18.564]                     next
[10:27:18.564]                   args[[name]] <- ""
[10:27:18.564]                 }
[10:27:18.564]                 NAMES <- toupper(removed)
[10:27:18.564]                 for (kk in seq_along(NAMES)) {
[10:27:18.564]                   name <- removed[[kk]]
[10:27:18.564]                   NAME <- NAMES[[kk]]
[10:27:18.564]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:18.564]                     next
[10:27:18.564]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:18.564]                 }
[10:27:18.564]                 if (length(args) > 0) 
[10:27:18.564]                   base::do.call(base::Sys.setenv, args = args)
[10:27:18.564]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:18.564]             }
[10:27:18.564]             else {
[10:27:18.564]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:18.564]             }
[10:27:18.564]             {
[10:27:18.564]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:18.564]                   0L) {
[10:27:18.564]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:18.564]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:18.564]                   base::options(opts)
[10:27:18.564]                 }
[10:27:18.564]                 {
[10:27:18.564]                   {
[10:27:18.564]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:18.564]                     NULL
[10:27:18.564]                   }
[10:27:18.564]                   options(future.plan = NULL)
[10:27:18.564]                   if (is.na(NA_character_)) 
[10:27:18.564]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:18.564]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:18.564]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:18.564]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:18.564]                     envir = parent.frame()) 
[10:27:18.564]                   {
[10:27:18.564]                     if (is.function(workers)) 
[10:27:18.564]                       workers <- workers()
[10:27:18.564]                     workers <- structure(as.integer(workers), 
[10:27:18.564]                       class = class(workers))
[10:27:18.564]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:18.564]                       workers >= 1)
[10:27:18.564]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:18.564]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:18.564]                     }
[10:27:18.564]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:18.564]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:18.564]                       envir = envir)
[10:27:18.564]                     if (!future$lazy) 
[10:27:18.564]                       future <- run(future)
[10:27:18.564]                     invisible(future)
[10:27:18.564]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:18.564]                 }
[10:27:18.564]             }
[10:27:18.564]         }
[10:27:18.564]     })
[10:27:18.564]     if (TRUE) {
[10:27:18.564]         base::sink(type = "output", split = FALSE)
[10:27:18.564]         if (TRUE) {
[10:27:18.564]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:18.564]         }
[10:27:18.564]         else {
[10:27:18.564]             ...future.result["stdout"] <- base::list(NULL)
[10:27:18.564]         }
[10:27:18.564]         base::close(...future.stdout)
[10:27:18.564]         ...future.stdout <- NULL
[10:27:18.564]     }
[10:27:18.564]     ...future.result$conditions <- ...future.conditions
[10:27:18.564]     ...future.result$finished <- base::Sys.time()
[10:27:18.564]     ...future.result
[10:27:18.564] }
[10:27:18.571] MultisessionFuture started
[10:27:18.571] - Launch lazy future ... done
[10:27:18.571] run() for ‘MultisessionFuture’ ... done
[10:27:19.120] receiveMessageFromWorker() for ClusterFuture ...
[10:27:19.120] - Validating connection of MultisessionFuture
[10:27:19.120] - received message: FutureResult
[10:27:19.120] - Received FutureResult
[10:27:19.120] - Erased future from FutureRegistry
[10:27:19.121] result() for ClusterFuture ...
[10:27:19.121] - result already collected: FutureResult
[10:27:19.121] result() for ClusterFuture ... done
[10:27:19.121] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:19.121] resolve() on list ...
[10:27:19.121]  recursive: 1
[10:27:19.121]  length: 2
[10:27:19.121]  elements: ‘a’, ‘b’
[10:27:19.121]  length: 1 (resolved future 1)
[10:27:19.122]  length: 0 (resolved future 2)
[10:27:19.122] resolve() on list ... DONE
[10:27:19.122] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[10:27:19.122] getGlobalsAndPackages() ...
[10:27:19.122] Searching for globals...
[10:27:19.123] - globals found: [2] ‘list’, ‘stop’
[10:27:19.123] Searching for globals ... DONE
[10:27:19.123] Resolving globals: FALSE
[10:27:19.123] 
[10:27:19.123] 
[10:27:19.123] getGlobalsAndPackages() ... DONE
[10:27:19.124] run() for ‘Future’ ...
[10:27:19.124] - state: ‘created’
[10:27:19.124] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:19.138] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:19.139] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:19.139]   - Field: ‘node’
[10:27:19.139]   - Field: ‘label’
[10:27:19.139]   - Field: ‘local’
[10:27:19.139]   - Field: ‘owner’
[10:27:19.139]   - Field: ‘envir’
[10:27:19.139]   - Field: ‘workers’
[10:27:19.139]   - Field: ‘packages’
[10:27:19.139]   - Field: ‘gc’
[10:27:19.140]   - Field: ‘conditions’
[10:27:19.140]   - Field: ‘persistent’
[10:27:19.140]   - Field: ‘expr’
[10:27:19.140]   - Field: ‘uuid’
[10:27:19.140]   - Field: ‘seed’
[10:27:19.140]   - Field: ‘version’
[10:27:19.140]   - Field: ‘result’
[10:27:19.140]   - Field: ‘asynchronous’
[10:27:19.140]   - Field: ‘calls’
[10:27:19.140]   - Field: ‘globals’
[10:27:19.140]   - Field: ‘stdout’
[10:27:19.141]   - Field: ‘earlySignal’
[10:27:19.141]   - Field: ‘lazy’
[10:27:19.141]   - Field: ‘state’
[10:27:19.141] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:19.141] - Launch lazy future ...
[10:27:19.141] Packages needed by the future expression (n = 0): <none>
[10:27:19.141] Packages needed by future strategies (n = 0): <none>
[10:27:19.142] {
[10:27:19.142]     {
[10:27:19.142]         {
[10:27:19.142]             ...future.startTime <- base::Sys.time()
[10:27:19.142]             {
[10:27:19.142]                 {
[10:27:19.142]                   {
[10:27:19.142]                     {
[10:27:19.142]                       base::local({
[10:27:19.142]                         has_future <- base::requireNamespace("future", 
[10:27:19.142]                           quietly = TRUE)
[10:27:19.142]                         if (has_future) {
[10:27:19.142]                           ns <- base::getNamespace("future")
[10:27:19.142]                           version <- ns[[".package"]][["version"]]
[10:27:19.142]                           if (is.null(version)) 
[10:27:19.142]                             version <- utils::packageVersion("future")
[10:27:19.142]                         }
[10:27:19.142]                         else {
[10:27:19.142]                           version <- NULL
[10:27:19.142]                         }
[10:27:19.142]                         if (!has_future || version < "1.8.0") {
[10:27:19.142]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:19.142]                             "", base::R.version$version.string), 
[10:27:19.142]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:19.142]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:19.142]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:19.142]                               "release", "version")], collapse = " "), 
[10:27:19.142]                             hostname = base::Sys.info()[["nodename"]])
[10:27:19.142]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:19.142]                             info)
[10:27:19.142]                           info <- base::paste(info, collapse = "; ")
[10:27:19.142]                           if (!has_future) {
[10:27:19.142]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:19.142]                               info)
[10:27:19.142]                           }
[10:27:19.142]                           else {
[10:27:19.142]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:19.142]                               info, version)
[10:27:19.142]                           }
[10:27:19.142]                           base::stop(msg)
[10:27:19.142]                         }
[10:27:19.142]                       })
[10:27:19.142]                     }
[10:27:19.142]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:19.142]                     base::options(mc.cores = 1L)
[10:27:19.142]                   }
[10:27:19.142]                   options(future.plan = NULL)
[10:27:19.142]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:19.142]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:19.142]                 }
[10:27:19.142]                 ...future.workdir <- getwd()
[10:27:19.142]             }
[10:27:19.142]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:19.142]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:19.142]         }
[10:27:19.142]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:19.142]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:19.142]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:19.142]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:19.142]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:19.142]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:19.142]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:19.142]             base::names(...future.oldOptions))
[10:27:19.142]     }
[10:27:19.142]     if (FALSE) {
[10:27:19.142]     }
[10:27:19.142]     else {
[10:27:19.142]         if (TRUE) {
[10:27:19.142]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:19.142]                 open = "w")
[10:27:19.142]         }
[10:27:19.142]         else {
[10:27:19.142]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:19.142]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:19.142]         }
[10:27:19.142]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:19.142]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:19.142]             base::sink(type = "output", split = FALSE)
[10:27:19.142]             base::close(...future.stdout)
[10:27:19.142]         }, add = TRUE)
[10:27:19.142]     }
[10:27:19.142]     ...future.frame <- base::sys.nframe()
[10:27:19.142]     ...future.conditions <- base::list()
[10:27:19.142]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:19.142]     if (FALSE) {
[10:27:19.142]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:19.142]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:19.142]     }
[10:27:19.142]     ...future.result <- base::tryCatch({
[10:27:19.142]         base::withCallingHandlers({
[10:27:19.142]             ...future.value <- base::withVisible(base::local({
[10:27:19.142]                 ...future.makeSendCondition <- base::local({
[10:27:19.142]                   sendCondition <- NULL
[10:27:19.142]                   function(frame = 1L) {
[10:27:19.142]                     if (is.function(sendCondition)) 
[10:27:19.142]                       return(sendCondition)
[10:27:19.142]                     ns <- getNamespace("parallel")
[10:27:19.142]                     if (exists("sendData", mode = "function", 
[10:27:19.142]                       envir = ns)) {
[10:27:19.142]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:19.142]                         envir = ns)
[10:27:19.142]                       envir <- sys.frame(frame)
[10:27:19.142]                       master <- NULL
[10:27:19.142]                       while (!identical(envir, .GlobalEnv) && 
[10:27:19.142]                         !identical(envir, emptyenv())) {
[10:27:19.142]                         if (exists("master", mode = "list", envir = envir, 
[10:27:19.142]                           inherits = FALSE)) {
[10:27:19.142]                           master <- get("master", mode = "list", 
[10:27:19.142]                             envir = envir, inherits = FALSE)
[10:27:19.142]                           if (inherits(master, c("SOCKnode", 
[10:27:19.142]                             "SOCK0node"))) {
[10:27:19.142]                             sendCondition <<- function(cond) {
[10:27:19.142]                               data <- list(type = "VALUE", value = cond, 
[10:27:19.142]                                 success = TRUE)
[10:27:19.142]                               parallel_sendData(master, data)
[10:27:19.142]                             }
[10:27:19.142]                             return(sendCondition)
[10:27:19.142]                           }
[10:27:19.142]                         }
[10:27:19.142]                         frame <- frame + 1L
[10:27:19.142]                         envir <- sys.frame(frame)
[10:27:19.142]                       }
[10:27:19.142]                     }
[10:27:19.142]                     sendCondition <<- function(cond) NULL
[10:27:19.142]                   }
[10:27:19.142]                 })
[10:27:19.142]                 withCallingHandlers({
[10:27:19.142]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:27:19.142]                 }, immediateCondition = function(cond) {
[10:27:19.142]                   sendCondition <- ...future.makeSendCondition()
[10:27:19.142]                   sendCondition(cond)
[10:27:19.142]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:19.142]                   {
[10:27:19.142]                     inherits <- base::inherits
[10:27:19.142]                     invokeRestart <- base::invokeRestart
[10:27:19.142]                     is.null <- base::is.null
[10:27:19.142]                     muffled <- FALSE
[10:27:19.142]                     if (inherits(cond, "message")) {
[10:27:19.142]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:19.142]                       if (muffled) 
[10:27:19.142]                         invokeRestart("muffleMessage")
[10:27:19.142]                     }
[10:27:19.142]                     else if (inherits(cond, "warning")) {
[10:27:19.142]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:19.142]                       if (muffled) 
[10:27:19.142]                         invokeRestart("muffleWarning")
[10:27:19.142]                     }
[10:27:19.142]                     else if (inherits(cond, "condition")) {
[10:27:19.142]                       if (!is.null(pattern)) {
[10:27:19.142]                         computeRestarts <- base::computeRestarts
[10:27:19.142]                         grepl <- base::grepl
[10:27:19.142]                         restarts <- computeRestarts(cond)
[10:27:19.142]                         for (restart in restarts) {
[10:27:19.142]                           name <- restart$name
[10:27:19.142]                           if (is.null(name)) 
[10:27:19.142]                             next
[10:27:19.142]                           if (!grepl(pattern, name)) 
[10:27:19.142]                             next
[10:27:19.142]                           invokeRestart(restart)
[10:27:19.142]                           muffled <- TRUE
[10:27:19.142]                           break
[10:27:19.142]                         }
[10:27:19.142]                       }
[10:27:19.142]                     }
[10:27:19.142]                     invisible(muffled)
[10:27:19.142]                   }
[10:27:19.142]                   muffleCondition(cond)
[10:27:19.142]                 })
[10:27:19.142]             }))
[10:27:19.142]             future::FutureResult(value = ...future.value$value, 
[10:27:19.142]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:19.142]                   ...future.rng), globalenv = if (FALSE) 
[10:27:19.142]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:19.142]                     ...future.globalenv.names))
[10:27:19.142]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:19.142]         }, condition = base::local({
[10:27:19.142]             c <- base::c
[10:27:19.142]             inherits <- base::inherits
[10:27:19.142]             invokeRestart <- base::invokeRestart
[10:27:19.142]             length <- base::length
[10:27:19.142]             list <- base::list
[10:27:19.142]             seq.int <- base::seq.int
[10:27:19.142]             signalCondition <- base::signalCondition
[10:27:19.142]             sys.calls <- base::sys.calls
[10:27:19.142]             `[[` <- base::`[[`
[10:27:19.142]             `+` <- base::`+`
[10:27:19.142]             `<<-` <- base::`<<-`
[10:27:19.142]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:19.142]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:19.142]                   3L)]
[10:27:19.142]             }
[10:27:19.142]             function(cond) {
[10:27:19.142]                 is_error <- inherits(cond, "error")
[10:27:19.142]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:19.142]                   NULL)
[10:27:19.142]                 if (is_error) {
[10:27:19.142]                   sessionInformation <- function() {
[10:27:19.142]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:19.142]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:19.142]                       search = base::search(), system = base::Sys.info())
[10:27:19.142]                   }
[10:27:19.142]                   ...future.conditions[[length(...future.conditions) + 
[10:27:19.142]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:19.142]                     cond$call), session = sessionInformation(), 
[10:27:19.142]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:19.142]                   signalCondition(cond)
[10:27:19.142]                 }
[10:27:19.142]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:19.142]                 "immediateCondition"))) {
[10:27:19.142]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:19.142]                   ...future.conditions[[length(...future.conditions) + 
[10:27:19.142]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:19.142]                   if (TRUE && !signal) {
[10:27:19.142]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:19.142]                     {
[10:27:19.142]                       inherits <- base::inherits
[10:27:19.142]                       invokeRestart <- base::invokeRestart
[10:27:19.142]                       is.null <- base::is.null
[10:27:19.142]                       muffled <- FALSE
[10:27:19.142]                       if (inherits(cond, "message")) {
[10:27:19.142]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:19.142]                         if (muffled) 
[10:27:19.142]                           invokeRestart("muffleMessage")
[10:27:19.142]                       }
[10:27:19.142]                       else if (inherits(cond, "warning")) {
[10:27:19.142]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:19.142]                         if (muffled) 
[10:27:19.142]                           invokeRestart("muffleWarning")
[10:27:19.142]                       }
[10:27:19.142]                       else if (inherits(cond, "condition")) {
[10:27:19.142]                         if (!is.null(pattern)) {
[10:27:19.142]                           computeRestarts <- base::computeRestarts
[10:27:19.142]                           grepl <- base::grepl
[10:27:19.142]                           restarts <- computeRestarts(cond)
[10:27:19.142]                           for (restart in restarts) {
[10:27:19.142]                             name <- restart$name
[10:27:19.142]                             if (is.null(name)) 
[10:27:19.142]                               next
[10:27:19.142]                             if (!grepl(pattern, name)) 
[10:27:19.142]                               next
[10:27:19.142]                             invokeRestart(restart)
[10:27:19.142]                             muffled <- TRUE
[10:27:19.142]                             break
[10:27:19.142]                           }
[10:27:19.142]                         }
[10:27:19.142]                       }
[10:27:19.142]                       invisible(muffled)
[10:27:19.142]                     }
[10:27:19.142]                     muffleCondition(cond, pattern = "^muffle")
[10:27:19.142]                   }
[10:27:19.142]                 }
[10:27:19.142]                 else {
[10:27:19.142]                   if (TRUE) {
[10:27:19.142]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:19.142]                     {
[10:27:19.142]                       inherits <- base::inherits
[10:27:19.142]                       invokeRestart <- base::invokeRestart
[10:27:19.142]                       is.null <- base::is.null
[10:27:19.142]                       muffled <- FALSE
[10:27:19.142]                       if (inherits(cond, "message")) {
[10:27:19.142]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:19.142]                         if (muffled) 
[10:27:19.142]                           invokeRestart("muffleMessage")
[10:27:19.142]                       }
[10:27:19.142]                       else if (inherits(cond, "warning")) {
[10:27:19.142]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:19.142]                         if (muffled) 
[10:27:19.142]                           invokeRestart("muffleWarning")
[10:27:19.142]                       }
[10:27:19.142]                       else if (inherits(cond, "condition")) {
[10:27:19.142]                         if (!is.null(pattern)) {
[10:27:19.142]                           computeRestarts <- base::computeRestarts
[10:27:19.142]                           grepl <- base::grepl
[10:27:19.142]                           restarts <- computeRestarts(cond)
[10:27:19.142]                           for (restart in restarts) {
[10:27:19.142]                             name <- restart$name
[10:27:19.142]                             if (is.null(name)) 
[10:27:19.142]                               next
[10:27:19.142]                             if (!grepl(pattern, name)) 
[10:27:19.142]                               next
[10:27:19.142]                             invokeRestart(restart)
[10:27:19.142]                             muffled <- TRUE
[10:27:19.142]                             break
[10:27:19.142]                           }
[10:27:19.142]                         }
[10:27:19.142]                       }
[10:27:19.142]                       invisible(muffled)
[10:27:19.142]                     }
[10:27:19.142]                     muffleCondition(cond, pattern = "^muffle")
[10:27:19.142]                   }
[10:27:19.142]                 }
[10:27:19.142]             }
[10:27:19.142]         }))
[10:27:19.142]     }, error = function(ex) {
[10:27:19.142]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:19.142]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:19.142]                 ...future.rng), started = ...future.startTime, 
[10:27:19.142]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:19.142]             version = "1.8"), class = "FutureResult")
[10:27:19.142]     }, finally = {
[10:27:19.142]         if (!identical(...future.workdir, getwd())) 
[10:27:19.142]             setwd(...future.workdir)
[10:27:19.142]         {
[10:27:19.142]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:19.142]                 ...future.oldOptions$nwarnings <- NULL
[10:27:19.142]             }
[10:27:19.142]             base::options(...future.oldOptions)
[10:27:19.142]             if (.Platform$OS.type == "windows") {
[10:27:19.142]                 old_names <- names(...future.oldEnvVars)
[10:27:19.142]                 envs <- base::Sys.getenv()
[10:27:19.142]                 names <- names(envs)
[10:27:19.142]                 common <- intersect(names, old_names)
[10:27:19.142]                 added <- setdiff(names, old_names)
[10:27:19.142]                 removed <- setdiff(old_names, names)
[10:27:19.142]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:19.142]                   envs[common]]
[10:27:19.142]                 NAMES <- toupper(changed)
[10:27:19.142]                 args <- list()
[10:27:19.142]                 for (kk in seq_along(NAMES)) {
[10:27:19.142]                   name <- changed[[kk]]
[10:27:19.142]                   NAME <- NAMES[[kk]]
[10:27:19.142]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:19.142]                     next
[10:27:19.142]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:19.142]                 }
[10:27:19.142]                 NAMES <- toupper(added)
[10:27:19.142]                 for (kk in seq_along(NAMES)) {
[10:27:19.142]                   name <- added[[kk]]
[10:27:19.142]                   NAME <- NAMES[[kk]]
[10:27:19.142]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:19.142]                     next
[10:27:19.142]                   args[[name]] <- ""
[10:27:19.142]                 }
[10:27:19.142]                 NAMES <- toupper(removed)
[10:27:19.142]                 for (kk in seq_along(NAMES)) {
[10:27:19.142]                   name <- removed[[kk]]
[10:27:19.142]                   NAME <- NAMES[[kk]]
[10:27:19.142]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:19.142]                     next
[10:27:19.142]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:19.142]                 }
[10:27:19.142]                 if (length(args) > 0) 
[10:27:19.142]                   base::do.call(base::Sys.setenv, args = args)
[10:27:19.142]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:19.142]             }
[10:27:19.142]             else {
[10:27:19.142]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:19.142]             }
[10:27:19.142]             {
[10:27:19.142]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:19.142]                   0L) {
[10:27:19.142]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:19.142]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:19.142]                   base::options(opts)
[10:27:19.142]                 }
[10:27:19.142]                 {
[10:27:19.142]                   {
[10:27:19.142]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:19.142]                     NULL
[10:27:19.142]                   }
[10:27:19.142]                   options(future.plan = NULL)
[10:27:19.142]                   if (is.na(NA_character_)) 
[10:27:19.142]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:19.142]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:19.142]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:19.142]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:19.142]                     envir = parent.frame()) 
[10:27:19.142]                   {
[10:27:19.142]                     if (is.function(workers)) 
[10:27:19.142]                       workers <- workers()
[10:27:19.142]                     workers <- structure(as.integer(workers), 
[10:27:19.142]                       class = class(workers))
[10:27:19.142]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:19.142]                       workers >= 1)
[10:27:19.142]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:19.142]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:19.142]                     }
[10:27:19.142]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:19.142]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:19.142]                       envir = envir)
[10:27:19.142]                     if (!future$lazy) 
[10:27:19.142]                       future <- run(future)
[10:27:19.142]                     invisible(future)
[10:27:19.142]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:19.142]                 }
[10:27:19.142]             }
[10:27:19.142]         }
[10:27:19.142]     })
[10:27:19.142]     if (TRUE) {
[10:27:19.142]         base::sink(type = "output", split = FALSE)
[10:27:19.142]         if (TRUE) {
[10:27:19.142]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:19.142]         }
[10:27:19.142]         else {
[10:27:19.142]             ...future.result["stdout"] <- base::list(NULL)
[10:27:19.142]         }
[10:27:19.142]         base::close(...future.stdout)
[10:27:19.142]         ...future.stdout <- NULL
[10:27:19.142]     }
[10:27:19.142]     ...future.result$conditions <- ...future.conditions
[10:27:19.142]     ...future.result$finished <- base::Sys.time()
[10:27:19.142]     ...future.result
[10:27:19.142] }
[10:27:19.145] MultisessionFuture started
[10:27:19.145] - Launch lazy future ... done
[10:27:19.145] run() for ‘MultisessionFuture’ ... done
[10:27:19.192] receiveMessageFromWorker() for ClusterFuture ...
[10:27:19.192] - Validating connection of MultisessionFuture
[10:27:19.193] - received message: FutureResult
[10:27:19.193] - Received FutureResult
[10:27:19.193] - Erased future from FutureRegistry
[10:27:19.193] result() for ClusterFuture ...
[10:27:19.193] - result already collected: FutureResult
[10:27:19.193] result() for ClusterFuture ... done
[10:27:19.194] signalConditions() ...
[10:27:19.194]  - include = ‘immediateCondition’
[10:27:19.194]  - exclude = 
[10:27:19.194]  - resignal = FALSE
[10:27:19.194]  - Number of conditions: 1
[10:27:19.194] signalConditions() ... done
[10:27:19.194] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:19.194] A MultisessionFuture was resolved
[10:27:19.194] getGlobalsAndPackages() ...
[10:27:19.194] Searching for globals...
[10:27:19.195] - globals found: [2] ‘list’, ‘stop’
[10:27:19.195] Searching for globals ... DONE
[10:27:19.195] Resolving globals: FALSE
[10:27:19.196] 
[10:27:19.196] 
[10:27:19.196] getGlobalsAndPackages() ... DONE
[10:27:19.196] run() for ‘Future’ ...
[10:27:19.196] - state: ‘created’
[10:27:19.196] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:19.212] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:19.212] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:19.212]   - Field: ‘node’
[10:27:19.212]   - Field: ‘label’
[10:27:19.213]   - Field: ‘local’
[10:27:19.213]   - Field: ‘owner’
[10:27:19.213]   - Field: ‘envir’
[10:27:19.213]   - Field: ‘workers’
[10:27:19.213]   - Field: ‘packages’
[10:27:19.213]   - Field: ‘gc’
[10:27:19.213]   - Field: ‘conditions’
[10:27:19.213]   - Field: ‘persistent’
[10:27:19.213]   - Field: ‘expr’
[10:27:19.214]   - Field: ‘uuid’
[10:27:19.214]   - Field: ‘seed’
[10:27:19.214]   - Field: ‘version’
[10:27:19.214]   - Field: ‘result’
[10:27:19.214]   - Field: ‘asynchronous’
[10:27:19.214]   - Field: ‘calls’
[10:27:19.214]   - Field: ‘globals’
[10:27:19.214]   - Field: ‘stdout’
[10:27:19.214]   - Field: ‘earlySignal’
[10:27:19.214]   - Field: ‘lazy’
[10:27:19.214]   - Field: ‘state’
[10:27:19.215] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:19.215] - Launch lazy future ...
[10:27:19.215] Packages needed by the future expression (n = 0): <none>
[10:27:19.215] Packages needed by future strategies (n = 0): <none>
[10:27:19.216] {
[10:27:19.216]     {
[10:27:19.216]         {
[10:27:19.216]             ...future.startTime <- base::Sys.time()
[10:27:19.216]             {
[10:27:19.216]                 {
[10:27:19.216]                   {
[10:27:19.216]                     {
[10:27:19.216]                       base::local({
[10:27:19.216]                         has_future <- base::requireNamespace("future", 
[10:27:19.216]                           quietly = TRUE)
[10:27:19.216]                         if (has_future) {
[10:27:19.216]                           ns <- base::getNamespace("future")
[10:27:19.216]                           version <- ns[[".package"]][["version"]]
[10:27:19.216]                           if (is.null(version)) 
[10:27:19.216]                             version <- utils::packageVersion("future")
[10:27:19.216]                         }
[10:27:19.216]                         else {
[10:27:19.216]                           version <- NULL
[10:27:19.216]                         }
[10:27:19.216]                         if (!has_future || version < "1.8.0") {
[10:27:19.216]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:19.216]                             "", base::R.version$version.string), 
[10:27:19.216]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:19.216]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:19.216]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:19.216]                               "release", "version")], collapse = " "), 
[10:27:19.216]                             hostname = base::Sys.info()[["nodename"]])
[10:27:19.216]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:19.216]                             info)
[10:27:19.216]                           info <- base::paste(info, collapse = "; ")
[10:27:19.216]                           if (!has_future) {
[10:27:19.216]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:19.216]                               info)
[10:27:19.216]                           }
[10:27:19.216]                           else {
[10:27:19.216]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:19.216]                               info, version)
[10:27:19.216]                           }
[10:27:19.216]                           base::stop(msg)
[10:27:19.216]                         }
[10:27:19.216]                       })
[10:27:19.216]                     }
[10:27:19.216]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:19.216]                     base::options(mc.cores = 1L)
[10:27:19.216]                   }
[10:27:19.216]                   options(future.plan = NULL)
[10:27:19.216]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:19.216]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:19.216]                 }
[10:27:19.216]                 ...future.workdir <- getwd()
[10:27:19.216]             }
[10:27:19.216]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:19.216]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:19.216]         }
[10:27:19.216]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:19.216]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:19.216]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:19.216]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:19.216]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:19.216]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:19.216]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:19.216]             base::names(...future.oldOptions))
[10:27:19.216]     }
[10:27:19.216]     if (FALSE) {
[10:27:19.216]     }
[10:27:19.216]     else {
[10:27:19.216]         if (TRUE) {
[10:27:19.216]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:19.216]                 open = "w")
[10:27:19.216]         }
[10:27:19.216]         else {
[10:27:19.216]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:19.216]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:19.216]         }
[10:27:19.216]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:19.216]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:19.216]             base::sink(type = "output", split = FALSE)
[10:27:19.216]             base::close(...future.stdout)
[10:27:19.216]         }, add = TRUE)
[10:27:19.216]     }
[10:27:19.216]     ...future.frame <- base::sys.nframe()
[10:27:19.216]     ...future.conditions <- base::list()
[10:27:19.216]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:19.216]     if (FALSE) {
[10:27:19.216]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:19.216]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:19.216]     }
[10:27:19.216]     ...future.result <- base::tryCatch({
[10:27:19.216]         base::withCallingHandlers({
[10:27:19.216]             ...future.value <- base::withVisible(base::local({
[10:27:19.216]                 ...future.makeSendCondition <- base::local({
[10:27:19.216]                   sendCondition <- NULL
[10:27:19.216]                   function(frame = 1L) {
[10:27:19.216]                     if (is.function(sendCondition)) 
[10:27:19.216]                       return(sendCondition)
[10:27:19.216]                     ns <- getNamespace("parallel")
[10:27:19.216]                     if (exists("sendData", mode = "function", 
[10:27:19.216]                       envir = ns)) {
[10:27:19.216]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:19.216]                         envir = ns)
[10:27:19.216]                       envir <- sys.frame(frame)
[10:27:19.216]                       master <- NULL
[10:27:19.216]                       while (!identical(envir, .GlobalEnv) && 
[10:27:19.216]                         !identical(envir, emptyenv())) {
[10:27:19.216]                         if (exists("master", mode = "list", envir = envir, 
[10:27:19.216]                           inherits = FALSE)) {
[10:27:19.216]                           master <- get("master", mode = "list", 
[10:27:19.216]                             envir = envir, inherits = FALSE)
[10:27:19.216]                           if (inherits(master, c("SOCKnode", 
[10:27:19.216]                             "SOCK0node"))) {
[10:27:19.216]                             sendCondition <<- function(cond) {
[10:27:19.216]                               data <- list(type = "VALUE", value = cond, 
[10:27:19.216]                                 success = TRUE)
[10:27:19.216]                               parallel_sendData(master, data)
[10:27:19.216]                             }
[10:27:19.216]                             return(sendCondition)
[10:27:19.216]                           }
[10:27:19.216]                         }
[10:27:19.216]                         frame <- frame + 1L
[10:27:19.216]                         envir <- sys.frame(frame)
[10:27:19.216]                       }
[10:27:19.216]                     }
[10:27:19.216]                     sendCondition <<- function(cond) NULL
[10:27:19.216]                   }
[10:27:19.216]                 })
[10:27:19.216]                 withCallingHandlers({
[10:27:19.216]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:27:19.216]                 }, immediateCondition = function(cond) {
[10:27:19.216]                   sendCondition <- ...future.makeSendCondition()
[10:27:19.216]                   sendCondition(cond)
[10:27:19.216]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:19.216]                   {
[10:27:19.216]                     inherits <- base::inherits
[10:27:19.216]                     invokeRestart <- base::invokeRestart
[10:27:19.216]                     is.null <- base::is.null
[10:27:19.216]                     muffled <- FALSE
[10:27:19.216]                     if (inherits(cond, "message")) {
[10:27:19.216]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:19.216]                       if (muffled) 
[10:27:19.216]                         invokeRestart("muffleMessage")
[10:27:19.216]                     }
[10:27:19.216]                     else if (inherits(cond, "warning")) {
[10:27:19.216]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:19.216]                       if (muffled) 
[10:27:19.216]                         invokeRestart("muffleWarning")
[10:27:19.216]                     }
[10:27:19.216]                     else if (inherits(cond, "condition")) {
[10:27:19.216]                       if (!is.null(pattern)) {
[10:27:19.216]                         computeRestarts <- base::computeRestarts
[10:27:19.216]                         grepl <- base::grepl
[10:27:19.216]                         restarts <- computeRestarts(cond)
[10:27:19.216]                         for (restart in restarts) {
[10:27:19.216]                           name <- restart$name
[10:27:19.216]                           if (is.null(name)) 
[10:27:19.216]                             next
[10:27:19.216]                           if (!grepl(pattern, name)) 
[10:27:19.216]                             next
[10:27:19.216]                           invokeRestart(restart)
[10:27:19.216]                           muffled <- TRUE
[10:27:19.216]                           break
[10:27:19.216]                         }
[10:27:19.216]                       }
[10:27:19.216]                     }
[10:27:19.216]                     invisible(muffled)
[10:27:19.216]                   }
[10:27:19.216]                   muffleCondition(cond)
[10:27:19.216]                 })
[10:27:19.216]             }))
[10:27:19.216]             future::FutureResult(value = ...future.value$value, 
[10:27:19.216]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:19.216]                   ...future.rng), globalenv = if (FALSE) 
[10:27:19.216]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:19.216]                     ...future.globalenv.names))
[10:27:19.216]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:19.216]         }, condition = base::local({
[10:27:19.216]             c <- base::c
[10:27:19.216]             inherits <- base::inherits
[10:27:19.216]             invokeRestart <- base::invokeRestart
[10:27:19.216]             length <- base::length
[10:27:19.216]             list <- base::list
[10:27:19.216]             seq.int <- base::seq.int
[10:27:19.216]             signalCondition <- base::signalCondition
[10:27:19.216]             sys.calls <- base::sys.calls
[10:27:19.216]             `[[` <- base::`[[`
[10:27:19.216]             `+` <- base::`+`
[10:27:19.216]             `<<-` <- base::`<<-`
[10:27:19.216]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:19.216]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:19.216]                   3L)]
[10:27:19.216]             }
[10:27:19.216]             function(cond) {
[10:27:19.216]                 is_error <- inherits(cond, "error")
[10:27:19.216]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:19.216]                   NULL)
[10:27:19.216]                 if (is_error) {
[10:27:19.216]                   sessionInformation <- function() {
[10:27:19.216]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:19.216]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:19.216]                       search = base::search(), system = base::Sys.info())
[10:27:19.216]                   }
[10:27:19.216]                   ...future.conditions[[length(...future.conditions) + 
[10:27:19.216]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:19.216]                     cond$call), session = sessionInformation(), 
[10:27:19.216]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:19.216]                   signalCondition(cond)
[10:27:19.216]                 }
[10:27:19.216]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:19.216]                 "immediateCondition"))) {
[10:27:19.216]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:19.216]                   ...future.conditions[[length(...future.conditions) + 
[10:27:19.216]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:19.216]                   if (TRUE && !signal) {
[10:27:19.216]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:19.216]                     {
[10:27:19.216]                       inherits <- base::inherits
[10:27:19.216]                       invokeRestart <- base::invokeRestart
[10:27:19.216]                       is.null <- base::is.null
[10:27:19.216]                       muffled <- FALSE
[10:27:19.216]                       if (inherits(cond, "message")) {
[10:27:19.216]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:19.216]                         if (muffled) 
[10:27:19.216]                           invokeRestart("muffleMessage")
[10:27:19.216]                       }
[10:27:19.216]                       else if (inherits(cond, "warning")) {
[10:27:19.216]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:19.216]                         if (muffled) 
[10:27:19.216]                           invokeRestart("muffleWarning")
[10:27:19.216]                       }
[10:27:19.216]                       else if (inherits(cond, "condition")) {
[10:27:19.216]                         if (!is.null(pattern)) {
[10:27:19.216]                           computeRestarts <- base::computeRestarts
[10:27:19.216]                           grepl <- base::grepl
[10:27:19.216]                           restarts <- computeRestarts(cond)
[10:27:19.216]                           for (restart in restarts) {
[10:27:19.216]                             name <- restart$name
[10:27:19.216]                             if (is.null(name)) 
[10:27:19.216]                               next
[10:27:19.216]                             if (!grepl(pattern, name)) 
[10:27:19.216]                               next
[10:27:19.216]                             invokeRestart(restart)
[10:27:19.216]                             muffled <- TRUE
[10:27:19.216]                             break
[10:27:19.216]                           }
[10:27:19.216]                         }
[10:27:19.216]                       }
[10:27:19.216]                       invisible(muffled)
[10:27:19.216]                     }
[10:27:19.216]                     muffleCondition(cond, pattern = "^muffle")
[10:27:19.216]                   }
[10:27:19.216]                 }
[10:27:19.216]                 else {
[10:27:19.216]                   if (TRUE) {
[10:27:19.216]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:19.216]                     {
[10:27:19.216]                       inherits <- base::inherits
[10:27:19.216]                       invokeRestart <- base::invokeRestart
[10:27:19.216]                       is.null <- base::is.null
[10:27:19.216]                       muffled <- FALSE
[10:27:19.216]                       if (inherits(cond, "message")) {
[10:27:19.216]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:19.216]                         if (muffled) 
[10:27:19.216]                           invokeRestart("muffleMessage")
[10:27:19.216]                       }
[10:27:19.216]                       else if (inherits(cond, "warning")) {
[10:27:19.216]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:19.216]                         if (muffled) 
[10:27:19.216]                           invokeRestart("muffleWarning")
[10:27:19.216]                       }
[10:27:19.216]                       else if (inherits(cond, "condition")) {
[10:27:19.216]                         if (!is.null(pattern)) {
[10:27:19.216]                           computeRestarts <- base::computeRestarts
[10:27:19.216]                           grepl <- base::grepl
[10:27:19.216]                           restarts <- computeRestarts(cond)
[10:27:19.216]                           for (restart in restarts) {
[10:27:19.216]                             name <- restart$name
[10:27:19.216]                             if (is.null(name)) 
[10:27:19.216]                               next
[10:27:19.216]                             if (!grepl(pattern, name)) 
[10:27:19.216]                               next
[10:27:19.216]                             invokeRestart(restart)
[10:27:19.216]                             muffled <- TRUE
[10:27:19.216]                             break
[10:27:19.216]                           }
[10:27:19.216]                         }
[10:27:19.216]                       }
[10:27:19.216]                       invisible(muffled)
[10:27:19.216]                     }
[10:27:19.216]                     muffleCondition(cond, pattern = "^muffle")
[10:27:19.216]                   }
[10:27:19.216]                 }
[10:27:19.216]             }
[10:27:19.216]         }))
[10:27:19.216]     }, error = function(ex) {
[10:27:19.216]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:19.216]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:19.216]                 ...future.rng), started = ...future.startTime, 
[10:27:19.216]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:19.216]             version = "1.8"), class = "FutureResult")
[10:27:19.216]     }, finally = {
[10:27:19.216]         if (!identical(...future.workdir, getwd())) 
[10:27:19.216]             setwd(...future.workdir)
[10:27:19.216]         {
[10:27:19.216]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:19.216]                 ...future.oldOptions$nwarnings <- NULL
[10:27:19.216]             }
[10:27:19.216]             base::options(...future.oldOptions)
[10:27:19.216]             if (.Platform$OS.type == "windows") {
[10:27:19.216]                 old_names <- names(...future.oldEnvVars)
[10:27:19.216]                 envs <- base::Sys.getenv()
[10:27:19.216]                 names <- names(envs)
[10:27:19.216]                 common <- intersect(names, old_names)
[10:27:19.216]                 added <- setdiff(names, old_names)
[10:27:19.216]                 removed <- setdiff(old_names, names)
[10:27:19.216]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:19.216]                   envs[common]]
[10:27:19.216]                 NAMES <- toupper(changed)
[10:27:19.216]                 args <- list()
[10:27:19.216]                 for (kk in seq_along(NAMES)) {
[10:27:19.216]                   name <- changed[[kk]]
[10:27:19.216]                   NAME <- NAMES[[kk]]
[10:27:19.216]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:19.216]                     next
[10:27:19.216]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:19.216]                 }
[10:27:19.216]                 NAMES <- toupper(added)
[10:27:19.216]                 for (kk in seq_along(NAMES)) {
[10:27:19.216]                   name <- added[[kk]]
[10:27:19.216]                   NAME <- NAMES[[kk]]
[10:27:19.216]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:19.216]                     next
[10:27:19.216]                   args[[name]] <- ""
[10:27:19.216]                 }
[10:27:19.216]                 NAMES <- toupper(removed)
[10:27:19.216]                 for (kk in seq_along(NAMES)) {
[10:27:19.216]                   name <- removed[[kk]]
[10:27:19.216]                   NAME <- NAMES[[kk]]
[10:27:19.216]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:19.216]                     next
[10:27:19.216]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:19.216]                 }
[10:27:19.216]                 if (length(args) > 0) 
[10:27:19.216]                   base::do.call(base::Sys.setenv, args = args)
[10:27:19.216]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:19.216]             }
[10:27:19.216]             else {
[10:27:19.216]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:19.216]             }
[10:27:19.216]             {
[10:27:19.216]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:19.216]                   0L) {
[10:27:19.216]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:19.216]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:19.216]                   base::options(opts)
[10:27:19.216]                 }
[10:27:19.216]                 {
[10:27:19.216]                   {
[10:27:19.216]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:19.216]                     NULL
[10:27:19.216]                   }
[10:27:19.216]                   options(future.plan = NULL)
[10:27:19.216]                   if (is.na(NA_character_)) 
[10:27:19.216]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:19.216]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:19.216]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:19.216]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:19.216]                     envir = parent.frame()) 
[10:27:19.216]                   {
[10:27:19.216]                     if (is.function(workers)) 
[10:27:19.216]                       workers <- workers()
[10:27:19.216]                     workers <- structure(as.integer(workers), 
[10:27:19.216]                       class = class(workers))
[10:27:19.216]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:19.216]                       workers >= 1)
[10:27:19.216]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:19.216]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:19.216]                     }
[10:27:19.216]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:19.216]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:19.216]                       envir = envir)
[10:27:19.216]                     if (!future$lazy) 
[10:27:19.216]                       future <- run(future)
[10:27:19.216]                     invisible(future)
[10:27:19.216]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:19.216]                 }
[10:27:19.216]             }
[10:27:19.216]         }
[10:27:19.216]     })
[10:27:19.216]     if (TRUE) {
[10:27:19.216]         base::sink(type = "output", split = FALSE)
[10:27:19.216]         if (TRUE) {
[10:27:19.216]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:19.216]         }
[10:27:19.216]         else {
[10:27:19.216]             ...future.result["stdout"] <- base::list(NULL)
[10:27:19.216]         }
[10:27:19.216]         base::close(...future.stdout)
[10:27:19.216]         ...future.stdout <- NULL
[10:27:19.216]     }
[10:27:19.216]     ...future.result$conditions <- ...future.conditions
[10:27:19.216]     ...future.result$finished <- base::Sys.time()
[10:27:19.216]     ...future.result
[10:27:19.216] }
[10:27:19.219] MultisessionFuture started
[10:27:19.219] - Launch lazy future ... done
[10:27:19.219] run() for ‘MultisessionFuture’ ... done
[10:27:19.269] receiveMessageFromWorker() for ClusterFuture ...
[10:27:19.269] - Validating connection of MultisessionFuture
[10:27:19.270] - received message: FutureResult
[10:27:19.270] - Received FutureResult
[10:27:19.270] - Erased future from FutureRegistry
[10:27:19.270] result() for ClusterFuture ...
[10:27:19.270] - result already collected: FutureResult
[10:27:19.270] result() for ClusterFuture ... done
[10:27:19.270] signalConditions() ...
[10:27:19.270]  - include = ‘immediateCondition’
[10:27:19.270]  - exclude = 
[10:27:19.271]  - resignal = FALSE
[10:27:19.271]  - Number of conditions: 1
[10:27:19.271] signalConditions() ... done
[10:27:19.271] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:19.271] A MultisessionFuture was resolved
- result = TRUE, recursive = 2 ... DONE
- result = TRUE, recursive = Inf ...
[10:27:19.271] getGlobalsAndPackages() ...
[10:27:19.271] Searching for globals...
[10:27:19.273] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:27:19.273] Searching for globals ... DONE
[10:27:19.273] Resolving globals: FALSE
[10:27:19.274] 
[10:27:19.274] 
[10:27:19.274] getGlobalsAndPackages() ... DONE
[10:27:19.274] run() for ‘Future’ ...
[10:27:19.274] - state: ‘created’
[10:27:19.274] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:19.288] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:19.288] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:19.289]   - Field: ‘node’
[10:27:19.289]   - Field: ‘label’
[10:27:19.289]   - Field: ‘local’
[10:27:19.289]   - Field: ‘owner’
[10:27:19.289]   - Field: ‘envir’
[10:27:19.289]   - Field: ‘workers’
[10:27:19.289]   - Field: ‘packages’
[10:27:19.289]   - Field: ‘gc’
[10:27:19.290]   - Field: ‘conditions’
[10:27:19.290]   - Field: ‘persistent’
[10:27:19.290]   - Field: ‘expr’
[10:27:19.290]   - Field: ‘uuid’
[10:27:19.290]   - Field: ‘seed’
[10:27:19.290]   - Field: ‘version’
[10:27:19.290]   - Field: ‘result’
[10:27:19.290]   - Field: ‘asynchronous’
[10:27:19.290]   - Field: ‘calls’
[10:27:19.290]   - Field: ‘globals’
[10:27:19.291]   - Field: ‘stdout’
[10:27:19.291]   - Field: ‘earlySignal’
[10:27:19.291]   - Field: ‘lazy’
[10:27:19.291]   - Field: ‘state’
[10:27:19.291] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:19.291] - Launch lazy future ...
[10:27:19.291] Packages needed by the future expression (n = 0): <none>
[10:27:19.291] Packages needed by future strategies (n = 0): <none>
[10:27:19.292] {
[10:27:19.292]     {
[10:27:19.292]         {
[10:27:19.292]             ...future.startTime <- base::Sys.time()
[10:27:19.292]             {
[10:27:19.292]                 {
[10:27:19.292]                   {
[10:27:19.292]                     {
[10:27:19.292]                       base::local({
[10:27:19.292]                         has_future <- base::requireNamespace("future", 
[10:27:19.292]                           quietly = TRUE)
[10:27:19.292]                         if (has_future) {
[10:27:19.292]                           ns <- base::getNamespace("future")
[10:27:19.292]                           version <- ns[[".package"]][["version"]]
[10:27:19.292]                           if (is.null(version)) 
[10:27:19.292]                             version <- utils::packageVersion("future")
[10:27:19.292]                         }
[10:27:19.292]                         else {
[10:27:19.292]                           version <- NULL
[10:27:19.292]                         }
[10:27:19.292]                         if (!has_future || version < "1.8.0") {
[10:27:19.292]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:19.292]                             "", base::R.version$version.string), 
[10:27:19.292]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:19.292]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:19.292]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:19.292]                               "release", "version")], collapse = " "), 
[10:27:19.292]                             hostname = base::Sys.info()[["nodename"]])
[10:27:19.292]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:19.292]                             info)
[10:27:19.292]                           info <- base::paste(info, collapse = "; ")
[10:27:19.292]                           if (!has_future) {
[10:27:19.292]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:19.292]                               info)
[10:27:19.292]                           }
[10:27:19.292]                           else {
[10:27:19.292]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:19.292]                               info, version)
[10:27:19.292]                           }
[10:27:19.292]                           base::stop(msg)
[10:27:19.292]                         }
[10:27:19.292]                       })
[10:27:19.292]                     }
[10:27:19.292]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:19.292]                     base::options(mc.cores = 1L)
[10:27:19.292]                   }
[10:27:19.292]                   options(future.plan = NULL)
[10:27:19.292]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:19.292]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:19.292]                 }
[10:27:19.292]                 ...future.workdir <- getwd()
[10:27:19.292]             }
[10:27:19.292]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:19.292]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:19.292]         }
[10:27:19.292]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:19.292]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:19.292]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:19.292]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:19.292]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:19.292]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:19.292]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:19.292]             base::names(...future.oldOptions))
[10:27:19.292]     }
[10:27:19.292]     if (FALSE) {
[10:27:19.292]     }
[10:27:19.292]     else {
[10:27:19.292]         if (TRUE) {
[10:27:19.292]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:19.292]                 open = "w")
[10:27:19.292]         }
[10:27:19.292]         else {
[10:27:19.292]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:19.292]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:19.292]         }
[10:27:19.292]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:19.292]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:19.292]             base::sink(type = "output", split = FALSE)
[10:27:19.292]             base::close(...future.stdout)
[10:27:19.292]         }, add = TRUE)
[10:27:19.292]     }
[10:27:19.292]     ...future.frame <- base::sys.nframe()
[10:27:19.292]     ...future.conditions <- base::list()
[10:27:19.292]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:19.292]     if (FALSE) {
[10:27:19.292]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:19.292]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:19.292]     }
[10:27:19.292]     ...future.result <- base::tryCatch({
[10:27:19.292]         base::withCallingHandlers({
[10:27:19.292]             ...future.value <- base::withVisible(base::local({
[10:27:19.292]                 ...future.makeSendCondition <- base::local({
[10:27:19.292]                   sendCondition <- NULL
[10:27:19.292]                   function(frame = 1L) {
[10:27:19.292]                     if (is.function(sendCondition)) 
[10:27:19.292]                       return(sendCondition)
[10:27:19.292]                     ns <- getNamespace("parallel")
[10:27:19.292]                     if (exists("sendData", mode = "function", 
[10:27:19.292]                       envir = ns)) {
[10:27:19.292]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:19.292]                         envir = ns)
[10:27:19.292]                       envir <- sys.frame(frame)
[10:27:19.292]                       master <- NULL
[10:27:19.292]                       while (!identical(envir, .GlobalEnv) && 
[10:27:19.292]                         !identical(envir, emptyenv())) {
[10:27:19.292]                         if (exists("master", mode = "list", envir = envir, 
[10:27:19.292]                           inherits = FALSE)) {
[10:27:19.292]                           master <- get("master", mode = "list", 
[10:27:19.292]                             envir = envir, inherits = FALSE)
[10:27:19.292]                           if (inherits(master, c("SOCKnode", 
[10:27:19.292]                             "SOCK0node"))) {
[10:27:19.292]                             sendCondition <<- function(cond) {
[10:27:19.292]                               data <- list(type = "VALUE", value = cond, 
[10:27:19.292]                                 success = TRUE)
[10:27:19.292]                               parallel_sendData(master, data)
[10:27:19.292]                             }
[10:27:19.292]                             return(sendCondition)
[10:27:19.292]                           }
[10:27:19.292]                         }
[10:27:19.292]                         frame <- frame + 1L
[10:27:19.292]                         envir <- sys.frame(frame)
[10:27:19.292]                       }
[10:27:19.292]                     }
[10:27:19.292]                     sendCondition <<- function(cond) NULL
[10:27:19.292]                   }
[10:27:19.292]                 })
[10:27:19.292]                 withCallingHandlers({
[10:27:19.292]                   {
[10:27:19.292]                     Sys.sleep(0.5)
[10:27:19.292]                     list(a = 1, b = 42L)
[10:27:19.292]                   }
[10:27:19.292]                 }, immediateCondition = function(cond) {
[10:27:19.292]                   sendCondition <- ...future.makeSendCondition()
[10:27:19.292]                   sendCondition(cond)
[10:27:19.292]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:19.292]                   {
[10:27:19.292]                     inherits <- base::inherits
[10:27:19.292]                     invokeRestart <- base::invokeRestart
[10:27:19.292]                     is.null <- base::is.null
[10:27:19.292]                     muffled <- FALSE
[10:27:19.292]                     if (inherits(cond, "message")) {
[10:27:19.292]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:19.292]                       if (muffled) 
[10:27:19.292]                         invokeRestart("muffleMessage")
[10:27:19.292]                     }
[10:27:19.292]                     else if (inherits(cond, "warning")) {
[10:27:19.292]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:19.292]                       if (muffled) 
[10:27:19.292]                         invokeRestart("muffleWarning")
[10:27:19.292]                     }
[10:27:19.292]                     else if (inherits(cond, "condition")) {
[10:27:19.292]                       if (!is.null(pattern)) {
[10:27:19.292]                         computeRestarts <- base::computeRestarts
[10:27:19.292]                         grepl <- base::grepl
[10:27:19.292]                         restarts <- computeRestarts(cond)
[10:27:19.292]                         for (restart in restarts) {
[10:27:19.292]                           name <- restart$name
[10:27:19.292]                           if (is.null(name)) 
[10:27:19.292]                             next
[10:27:19.292]                           if (!grepl(pattern, name)) 
[10:27:19.292]                             next
[10:27:19.292]                           invokeRestart(restart)
[10:27:19.292]                           muffled <- TRUE
[10:27:19.292]                           break
[10:27:19.292]                         }
[10:27:19.292]                       }
[10:27:19.292]                     }
[10:27:19.292]                     invisible(muffled)
[10:27:19.292]                   }
[10:27:19.292]                   muffleCondition(cond)
[10:27:19.292]                 })
[10:27:19.292]             }))
[10:27:19.292]             future::FutureResult(value = ...future.value$value, 
[10:27:19.292]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:19.292]                   ...future.rng), globalenv = if (FALSE) 
[10:27:19.292]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:19.292]                     ...future.globalenv.names))
[10:27:19.292]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:19.292]         }, condition = base::local({
[10:27:19.292]             c <- base::c
[10:27:19.292]             inherits <- base::inherits
[10:27:19.292]             invokeRestart <- base::invokeRestart
[10:27:19.292]             length <- base::length
[10:27:19.292]             list <- base::list
[10:27:19.292]             seq.int <- base::seq.int
[10:27:19.292]             signalCondition <- base::signalCondition
[10:27:19.292]             sys.calls <- base::sys.calls
[10:27:19.292]             `[[` <- base::`[[`
[10:27:19.292]             `+` <- base::`+`
[10:27:19.292]             `<<-` <- base::`<<-`
[10:27:19.292]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:19.292]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:19.292]                   3L)]
[10:27:19.292]             }
[10:27:19.292]             function(cond) {
[10:27:19.292]                 is_error <- inherits(cond, "error")
[10:27:19.292]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:19.292]                   NULL)
[10:27:19.292]                 if (is_error) {
[10:27:19.292]                   sessionInformation <- function() {
[10:27:19.292]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:19.292]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:19.292]                       search = base::search(), system = base::Sys.info())
[10:27:19.292]                   }
[10:27:19.292]                   ...future.conditions[[length(...future.conditions) + 
[10:27:19.292]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:19.292]                     cond$call), session = sessionInformation(), 
[10:27:19.292]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:19.292]                   signalCondition(cond)
[10:27:19.292]                 }
[10:27:19.292]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:19.292]                 "immediateCondition"))) {
[10:27:19.292]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:19.292]                   ...future.conditions[[length(...future.conditions) + 
[10:27:19.292]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:19.292]                   if (TRUE && !signal) {
[10:27:19.292]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:19.292]                     {
[10:27:19.292]                       inherits <- base::inherits
[10:27:19.292]                       invokeRestart <- base::invokeRestart
[10:27:19.292]                       is.null <- base::is.null
[10:27:19.292]                       muffled <- FALSE
[10:27:19.292]                       if (inherits(cond, "message")) {
[10:27:19.292]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:19.292]                         if (muffled) 
[10:27:19.292]                           invokeRestart("muffleMessage")
[10:27:19.292]                       }
[10:27:19.292]                       else if (inherits(cond, "warning")) {
[10:27:19.292]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:19.292]                         if (muffled) 
[10:27:19.292]                           invokeRestart("muffleWarning")
[10:27:19.292]                       }
[10:27:19.292]                       else if (inherits(cond, "condition")) {
[10:27:19.292]                         if (!is.null(pattern)) {
[10:27:19.292]                           computeRestarts <- base::computeRestarts
[10:27:19.292]                           grepl <- base::grepl
[10:27:19.292]                           restarts <- computeRestarts(cond)
[10:27:19.292]                           for (restart in restarts) {
[10:27:19.292]                             name <- restart$name
[10:27:19.292]                             if (is.null(name)) 
[10:27:19.292]                               next
[10:27:19.292]                             if (!grepl(pattern, name)) 
[10:27:19.292]                               next
[10:27:19.292]                             invokeRestart(restart)
[10:27:19.292]                             muffled <- TRUE
[10:27:19.292]                             break
[10:27:19.292]                           }
[10:27:19.292]                         }
[10:27:19.292]                       }
[10:27:19.292]                       invisible(muffled)
[10:27:19.292]                     }
[10:27:19.292]                     muffleCondition(cond, pattern = "^muffle")
[10:27:19.292]                   }
[10:27:19.292]                 }
[10:27:19.292]                 else {
[10:27:19.292]                   if (TRUE) {
[10:27:19.292]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:19.292]                     {
[10:27:19.292]                       inherits <- base::inherits
[10:27:19.292]                       invokeRestart <- base::invokeRestart
[10:27:19.292]                       is.null <- base::is.null
[10:27:19.292]                       muffled <- FALSE
[10:27:19.292]                       if (inherits(cond, "message")) {
[10:27:19.292]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:19.292]                         if (muffled) 
[10:27:19.292]                           invokeRestart("muffleMessage")
[10:27:19.292]                       }
[10:27:19.292]                       else if (inherits(cond, "warning")) {
[10:27:19.292]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:19.292]                         if (muffled) 
[10:27:19.292]                           invokeRestart("muffleWarning")
[10:27:19.292]                       }
[10:27:19.292]                       else if (inherits(cond, "condition")) {
[10:27:19.292]                         if (!is.null(pattern)) {
[10:27:19.292]                           computeRestarts <- base::computeRestarts
[10:27:19.292]                           grepl <- base::grepl
[10:27:19.292]                           restarts <- computeRestarts(cond)
[10:27:19.292]                           for (restart in restarts) {
[10:27:19.292]                             name <- restart$name
[10:27:19.292]                             if (is.null(name)) 
[10:27:19.292]                               next
[10:27:19.292]                             if (!grepl(pattern, name)) 
[10:27:19.292]                               next
[10:27:19.292]                             invokeRestart(restart)
[10:27:19.292]                             muffled <- TRUE
[10:27:19.292]                             break
[10:27:19.292]                           }
[10:27:19.292]                         }
[10:27:19.292]                       }
[10:27:19.292]                       invisible(muffled)
[10:27:19.292]                     }
[10:27:19.292]                     muffleCondition(cond, pattern = "^muffle")
[10:27:19.292]                   }
[10:27:19.292]                 }
[10:27:19.292]             }
[10:27:19.292]         }))
[10:27:19.292]     }, error = function(ex) {
[10:27:19.292]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:19.292]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:19.292]                 ...future.rng), started = ...future.startTime, 
[10:27:19.292]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:19.292]             version = "1.8"), class = "FutureResult")
[10:27:19.292]     }, finally = {
[10:27:19.292]         if (!identical(...future.workdir, getwd())) 
[10:27:19.292]             setwd(...future.workdir)
[10:27:19.292]         {
[10:27:19.292]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:19.292]                 ...future.oldOptions$nwarnings <- NULL
[10:27:19.292]             }
[10:27:19.292]             base::options(...future.oldOptions)
[10:27:19.292]             if (.Platform$OS.type == "windows") {
[10:27:19.292]                 old_names <- names(...future.oldEnvVars)
[10:27:19.292]                 envs <- base::Sys.getenv()
[10:27:19.292]                 names <- names(envs)
[10:27:19.292]                 common <- intersect(names, old_names)
[10:27:19.292]                 added <- setdiff(names, old_names)
[10:27:19.292]                 removed <- setdiff(old_names, names)
[10:27:19.292]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:19.292]                   envs[common]]
[10:27:19.292]                 NAMES <- toupper(changed)
[10:27:19.292]                 args <- list()
[10:27:19.292]                 for (kk in seq_along(NAMES)) {
[10:27:19.292]                   name <- changed[[kk]]
[10:27:19.292]                   NAME <- NAMES[[kk]]
[10:27:19.292]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:19.292]                     next
[10:27:19.292]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:19.292]                 }
[10:27:19.292]                 NAMES <- toupper(added)
[10:27:19.292]                 for (kk in seq_along(NAMES)) {
[10:27:19.292]                   name <- added[[kk]]
[10:27:19.292]                   NAME <- NAMES[[kk]]
[10:27:19.292]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:19.292]                     next
[10:27:19.292]                   args[[name]] <- ""
[10:27:19.292]                 }
[10:27:19.292]                 NAMES <- toupper(removed)
[10:27:19.292]                 for (kk in seq_along(NAMES)) {
[10:27:19.292]                   name <- removed[[kk]]
[10:27:19.292]                   NAME <- NAMES[[kk]]
[10:27:19.292]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:19.292]                     next
[10:27:19.292]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:19.292]                 }
[10:27:19.292]                 if (length(args) > 0) 
[10:27:19.292]                   base::do.call(base::Sys.setenv, args = args)
[10:27:19.292]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:19.292]             }
[10:27:19.292]             else {
[10:27:19.292]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:19.292]             }
[10:27:19.292]             {
[10:27:19.292]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:19.292]                   0L) {
[10:27:19.292]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:19.292]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:19.292]                   base::options(opts)
[10:27:19.292]                 }
[10:27:19.292]                 {
[10:27:19.292]                   {
[10:27:19.292]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:19.292]                     NULL
[10:27:19.292]                   }
[10:27:19.292]                   options(future.plan = NULL)
[10:27:19.292]                   if (is.na(NA_character_)) 
[10:27:19.292]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:19.292]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:19.292]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:19.292]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:19.292]                     envir = parent.frame()) 
[10:27:19.292]                   {
[10:27:19.292]                     if (is.function(workers)) 
[10:27:19.292]                       workers <- workers()
[10:27:19.292]                     workers <- structure(as.integer(workers), 
[10:27:19.292]                       class = class(workers))
[10:27:19.292]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:19.292]                       workers >= 1)
[10:27:19.292]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:19.292]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:19.292]                     }
[10:27:19.292]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:19.292]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:19.292]                       envir = envir)
[10:27:19.292]                     if (!future$lazy) 
[10:27:19.292]                       future <- run(future)
[10:27:19.292]                     invisible(future)
[10:27:19.292]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:19.292]                 }
[10:27:19.292]             }
[10:27:19.292]         }
[10:27:19.292]     })
[10:27:19.292]     if (TRUE) {
[10:27:19.292]         base::sink(type = "output", split = FALSE)
[10:27:19.292]         if (TRUE) {
[10:27:19.292]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:19.292]         }
[10:27:19.292]         else {
[10:27:19.292]             ...future.result["stdout"] <- base::list(NULL)
[10:27:19.292]         }
[10:27:19.292]         base::close(...future.stdout)
[10:27:19.292]         ...future.stdout <- NULL
[10:27:19.292]     }
[10:27:19.292]     ...future.result$conditions <- ...future.conditions
[10:27:19.292]     ...future.result$finished <- base::Sys.time()
[10:27:19.292]     ...future.result
[10:27:19.292] }
[10:27:19.296] MultisessionFuture started
[10:27:19.296] - Launch lazy future ... done
[10:27:19.296] run() for ‘MultisessionFuture’ ... done
[10:27:19.846] receiveMessageFromWorker() for ClusterFuture ...
[10:27:19.846] - Validating connection of MultisessionFuture
[10:27:19.847] - received message: FutureResult
[10:27:19.847] - Received FutureResult
[10:27:19.847] - Erased future from FutureRegistry
[10:27:19.847] result() for ClusterFuture ...
[10:27:19.847] - result already collected: FutureResult
[10:27:19.847] result() for ClusterFuture ... done
[10:27:19.847] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:19.848] resolve() on list ...
[10:27:19.848]  recursive: Inf
[10:27:19.848]  length: 2
[10:27:19.848]  elements: ‘a’, ‘b’
[10:27:19.848]  length: 1 (resolved future 1)
[10:27:19.848]  length: 0 (resolved future 2)
[10:27:19.848] resolve() on list ... DONE
[10:27:19.848] A MultisessionFuture was resolved (and resolved itself)
[10:27:19.848] getGlobalsAndPackages() ...
[10:27:19.848] Searching for globals...
[10:27:19.850] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:27:19.850] Searching for globals ... DONE
[10:27:19.850] Resolving globals: FALSE
[10:27:19.851] 
[10:27:19.851] 
[10:27:19.851] getGlobalsAndPackages() ... DONE
[10:27:19.851] run() for ‘Future’ ...
[10:27:19.851] - state: ‘created’
[10:27:19.852] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:19.866] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:19.866] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:19.866]   - Field: ‘node’
[10:27:19.866]   - Field: ‘label’
[10:27:19.866]   - Field: ‘local’
[10:27:19.867]   - Field: ‘owner’
[10:27:19.867]   - Field: ‘envir’
[10:27:19.867]   - Field: ‘workers’
[10:27:19.867]   - Field: ‘packages’
[10:27:19.867]   - Field: ‘gc’
[10:27:19.867]   - Field: ‘conditions’
[10:27:19.867]   - Field: ‘persistent’
[10:27:19.867]   - Field: ‘expr’
[10:27:19.867]   - Field: ‘uuid’
[10:27:19.867]   - Field: ‘seed’
[10:27:19.867]   - Field: ‘version’
[10:27:19.868]   - Field: ‘result’
[10:27:19.868]   - Field: ‘asynchronous’
[10:27:19.868]   - Field: ‘calls’
[10:27:19.868]   - Field: ‘globals’
[10:27:19.868]   - Field: ‘stdout’
[10:27:19.868]   - Field: ‘earlySignal’
[10:27:19.868]   - Field: ‘lazy’
[10:27:19.868]   - Field: ‘state’
[10:27:19.868] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:19.868] - Launch lazy future ...
[10:27:19.869] Packages needed by the future expression (n = 0): <none>
[10:27:19.869] Packages needed by future strategies (n = 0): <none>
[10:27:19.869] {
[10:27:19.869]     {
[10:27:19.869]         {
[10:27:19.869]             ...future.startTime <- base::Sys.time()
[10:27:19.869]             {
[10:27:19.869]                 {
[10:27:19.869]                   {
[10:27:19.869]                     {
[10:27:19.869]                       base::local({
[10:27:19.869]                         has_future <- base::requireNamespace("future", 
[10:27:19.869]                           quietly = TRUE)
[10:27:19.869]                         if (has_future) {
[10:27:19.869]                           ns <- base::getNamespace("future")
[10:27:19.869]                           version <- ns[[".package"]][["version"]]
[10:27:19.869]                           if (is.null(version)) 
[10:27:19.869]                             version <- utils::packageVersion("future")
[10:27:19.869]                         }
[10:27:19.869]                         else {
[10:27:19.869]                           version <- NULL
[10:27:19.869]                         }
[10:27:19.869]                         if (!has_future || version < "1.8.0") {
[10:27:19.869]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:19.869]                             "", base::R.version$version.string), 
[10:27:19.869]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:19.869]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:19.869]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:19.869]                               "release", "version")], collapse = " "), 
[10:27:19.869]                             hostname = base::Sys.info()[["nodename"]])
[10:27:19.869]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:19.869]                             info)
[10:27:19.869]                           info <- base::paste(info, collapse = "; ")
[10:27:19.869]                           if (!has_future) {
[10:27:19.869]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:19.869]                               info)
[10:27:19.869]                           }
[10:27:19.869]                           else {
[10:27:19.869]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:19.869]                               info, version)
[10:27:19.869]                           }
[10:27:19.869]                           base::stop(msg)
[10:27:19.869]                         }
[10:27:19.869]                       })
[10:27:19.869]                     }
[10:27:19.869]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:19.869]                     base::options(mc.cores = 1L)
[10:27:19.869]                   }
[10:27:19.869]                   options(future.plan = NULL)
[10:27:19.869]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:19.869]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:19.869]                 }
[10:27:19.869]                 ...future.workdir <- getwd()
[10:27:19.869]             }
[10:27:19.869]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:19.869]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:19.869]         }
[10:27:19.869]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:19.869]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:19.869]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:19.869]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:19.869]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:19.869]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:19.869]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:19.869]             base::names(...future.oldOptions))
[10:27:19.869]     }
[10:27:19.869]     if (FALSE) {
[10:27:19.869]     }
[10:27:19.869]     else {
[10:27:19.869]         if (TRUE) {
[10:27:19.869]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:19.869]                 open = "w")
[10:27:19.869]         }
[10:27:19.869]         else {
[10:27:19.869]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:19.869]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:19.869]         }
[10:27:19.869]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:19.869]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:19.869]             base::sink(type = "output", split = FALSE)
[10:27:19.869]             base::close(...future.stdout)
[10:27:19.869]         }, add = TRUE)
[10:27:19.869]     }
[10:27:19.869]     ...future.frame <- base::sys.nframe()
[10:27:19.869]     ...future.conditions <- base::list()
[10:27:19.869]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:19.869]     if (FALSE) {
[10:27:19.869]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:19.869]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:19.869]     }
[10:27:19.869]     ...future.result <- base::tryCatch({
[10:27:19.869]         base::withCallingHandlers({
[10:27:19.869]             ...future.value <- base::withVisible(base::local({
[10:27:19.869]                 ...future.makeSendCondition <- base::local({
[10:27:19.869]                   sendCondition <- NULL
[10:27:19.869]                   function(frame = 1L) {
[10:27:19.869]                     if (is.function(sendCondition)) 
[10:27:19.869]                       return(sendCondition)
[10:27:19.869]                     ns <- getNamespace("parallel")
[10:27:19.869]                     if (exists("sendData", mode = "function", 
[10:27:19.869]                       envir = ns)) {
[10:27:19.869]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:19.869]                         envir = ns)
[10:27:19.869]                       envir <- sys.frame(frame)
[10:27:19.869]                       master <- NULL
[10:27:19.869]                       while (!identical(envir, .GlobalEnv) && 
[10:27:19.869]                         !identical(envir, emptyenv())) {
[10:27:19.869]                         if (exists("master", mode = "list", envir = envir, 
[10:27:19.869]                           inherits = FALSE)) {
[10:27:19.869]                           master <- get("master", mode = "list", 
[10:27:19.869]                             envir = envir, inherits = FALSE)
[10:27:19.869]                           if (inherits(master, c("SOCKnode", 
[10:27:19.869]                             "SOCK0node"))) {
[10:27:19.869]                             sendCondition <<- function(cond) {
[10:27:19.869]                               data <- list(type = "VALUE", value = cond, 
[10:27:19.869]                                 success = TRUE)
[10:27:19.869]                               parallel_sendData(master, data)
[10:27:19.869]                             }
[10:27:19.869]                             return(sendCondition)
[10:27:19.869]                           }
[10:27:19.869]                         }
[10:27:19.869]                         frame <- frame + 1L
[10:27:19.869]                         envir <- sys.frame(frame)
[10:27:19.869]                       }
[10:27:19.869]                     }
[10:27:19.869]                     sendCondition <<- function(cond) NULL
[10:27:19.869]                   }
[10:27:19.869]                 })
[10:27:19.869]                 withCallingHandlers({
[10:27:19.869]                   {
[10:27:19.869]                     Sys.sleep(0.5)
[10:27:19.869]                     list(a = 1, b = 42L)
[10:27:19.869]                   }
[10:27:19.869]                 }, immediateCondition = function(cond) {
[10:27:19.869]                   sendCondition <- ...future.makeSendCondition()
[10:27:19.869]                   sendCondition(cond)
[10:27:19.869]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:19.869]                   {
[10:27:19.869]                     inherits <- base::inherits
[10:27:19.869]                     invokeRestart <- base::invokeRestart
[10:27:19.869]                     is.null <- base::is.null
[10:27:19.869]                     muffled <- FALSE
[10:27:19.869]                     if (inherits(cond, "message")) {
[10:27:19.869]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:19.869]                       if (muffled) 
[10:27:19.869]                         invokeRestart("muffleMessage")
[10:27:19.869]                     }
[10:27:19.869]                     else if (inherits(cond, "warning")) {
[10:27:19.869]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:19.869]                       if (muffled) 
[10:27:19.869]                         invokeRestart("muffleWarning")
[10:27:19.869]                     }
[10:27:19.869]                     else if (inherits(cond, "condition")) {
[10:27:19.869]                       if (!is.null(pattern)) {
[10:27:19.869]                         computeRestarts <- base::computeRestarts
[10:27:19.869]                         grepl <- base::grepl
[10:27:19.869]                         restarts <- computeRestarts(cond)
[10:27:19.869]                         for (restart in restarts) {
[10:27:19.869]                           name <- restart$name
[10:27:19.869]                           if (is.null(name)) 
[10:27:19.869]                             next
[10:27:19.869]                           if (!grepl(pattern, name)) 
[10:27:19.869]                             next
[10:27:19.869]                           invokeRestart(restart)
[10:27:19.869]                           muffled <- TRUE
[10:27:19.869]                           break
[10:27:19.869]                         }
[10:27:19.869]                       }
[10:27:19.869]                     }
[10:27:19.869]                     invisible(muffled)
[10:27:19.869]                   }
[10:27:19.869]                   muffleCondition(cond)
[10:27:19.869]                 })
[10:27:19.869]             }))
[10:27:19.869]             future::FutureResult(value = ...future.value$value, 
[10:27:19.869]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:19.869]                   ...future.rng), globalenv = if (FALSE) 
[10:27:19.869]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:19.869]                     ...future.globalenv.names))
[10:27:19.869]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:19.869]         }, condition = base::local({
[10:27:19.869]             c <- base::c
[10:27:19.869]             inherits <- base::inherits
[10:27:19.869]             invokeRestart <- base::invokeRestart
[10:27:19.869]             length <- base::length
[10:27:19.869]             list <- base::list
[10:27:19.869]             seq.int <- base::seq.int
[10:27:19.869]             signalCondition <- base::signalCondition
[10:27:19.869]             sys.calls <- base::sys.calls
[10:27:19.869]             `[[` <- base::`[[`
[10:27:19.869]             `+` <- base::`+`
[10:27:19.869]             `<<-` <- base::`<<-`
[10:27:19.869]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:19.869]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:19.869]                   3L)]
[10:27:19.869]             }
[10:27:19.869]             function(cond) {
[10:27:19.869]                 is_error <- inherits(cond, "error")
[10:27:19.869]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:19.869]                   NULL)
[10:27:19.869]                 if (is_error) {
[10:27:19.869]                   sessionInformation <- function() {
[10:27:19.869]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:19.869]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:19.869]                       search = base::search(), system = base::Sys.info())
[10:27:19.869]                   }
[10:27:19.869]                   ...future.conditions[[length(...future.conditions) + 
[10:27:19.869]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:19.869]                     cond$call), session = sessionInformation(), 
[10:27:19.869]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:19.869]                   signalCondition(cond)
[10:27:19.869]                 }
[10:27:19.869]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:19.869]                 "immediateCondition"))) {
[10:27:19.869]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:19.869]                   ...future.conditions[[length(...future.conditions) + 
[10:27:19.869]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:19.869]                   if (TRUE && !signal) {
[10:27:19.869]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:19.869]                     {
[10:27:19.869]                       inherits <- base::inherits
[10:27:19.869]                       invokeRestart <- base::invokeRestart
[10:27:19.869]                       is.null <- base::is.null
[10:27:19.869]                       muffled <- FALSE
[10:27:19.869]                       if (inherits(cond, "message")) {
[10:27:19.869]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:19.869]                         if (muffled) 
[10:27:19.869]                           invokeRestart("muffleMessage")
[10:27:19.869]                       }
[10:27:19.869]                       else if (inherits(cond, "warning")) {
[10:27:19.869]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:19.869]                         if (muffled) 
[10:27:19.869]                           invokeRestart("muffleWarning")
[10:27:19.869]                       }
[10:27:19.869]                       else if (inherits(cond, "condition")) {
[10:27:19.869]                         if (!is.null(pattern)) {
[10:27:19.869]                           computeRestarts <- base::computeRestarts
[10:27:19.869]                           grepl <- base::grepl
[10:27:19.869]                           restarts <- computeRestarts(cond)
[10:27:19.869]                           for (restart in restarts) {
[10:27:19.869]                             name <- restart$name
[10:27:19.869]                             if (is.null(name)) 
[10:27:19.869]                               next
[10:27:19.869]                             if (!grepl(pattern, name)) 
[10:27:19.869]                               next
[10:27:19.869]                             invokeRestart(restart)
[10:27:19.869]                             muffled <- TRUE
[10:27:19.869]                             break
[10:27:19.869]                           }
[10:27:19.869]                         }
[10:27:19.869]                       }
[10:27:19.869]                       invisible(muffled)
[10:27:19.869]                     }
[10:27:19.869]                     muffleCondition(cond, pattern = "^muffle")
[10:27:19.869]                   }
[10:27:19.869]                 }
[10:27:19.869]                 else {
[10:27:19.869]                   if (TRUE) {
[10:27:19.869]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:19.869]                     {
[10:27:19.869]                       inherits <- base::inherits
[10:27:19.869]                       invokeRestart <- base::invokeRestart
[10:27:19.869]                       is.null <- base::is.null
[10:27:19.869]                       muffled <- FALSE
[10:27:19.869]                       if (inherits(cond, "message")) {
[10:27:19.869]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:19.869]                         if (muffled) 
[10:27:19.869]                           invokeRestart("muffleMessage")
[10:27:19.869]                       }
[10:27:19.869]                       else if (inherits(cond, "warning")) {
[10:27:19.869]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:19.869]                         if (muffled) 
[10:27:19.869]                           invokeRestart("muffleWarning")
[10:27:19.869]                       }
[10:27:19.869]                       else if (inherits(cond, "condition")) {
[10:27:19.869]                         if (!is.null(pattern)) {
[10:27:19.869]                           computeRestarts <- base::computeRestarts
[10:27:19.869]                           grepl <- base::grepl
[10:27:19.869]                           restarts <- computeRestarts(cond)
[10:27:19.869]                           for (restart in restarts) {
[10:27:19.869]                             name <- restart$name
[10:27:19.869]                             if (is.null(name)) 
[10:27:19.869]                               next
[10:27:19.869]                             if (!grepl(pattern, name)) 
[10:27:19.869]                               next
[10:27:19.869]                             invokeRestart(restart)
[10:27:19.869]                             muffled <- TRUE
[10:27:19.869]                             break
[10:27:19.869]                           }
[10:27:19.869]                         }
[10:27:19.869]                       }
[10:27:19.869]                       invisible(muffled)
[10:27:19.869]                     }
[10:27:19.869]                     muffleCondition(cond, pattern = "^muffle")
[10:27:19.869]                   }
[10:27:19.869]                 }
[10:27:19.869]             }
[10:27:19.869]         }))
[10:27:19.869]     }, error = function(ex) {
[10:27:19.869]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:19.869]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:19.869]                 ...future.rng), started = ...future.startTime, 
[10:27:19.869]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:19.869]             version = "1.8"), class = "FutureResult")
[10:27:19.869]     }, finally = {
[10:27:19.869]         if (!identical(...future.workdir, getwd())) 
[10:27:19.869]             setwd(...future.workdir)
[10:27:19.869]         {
[10:27:19.869]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:19.869]                 ...future.oldOptions$nwarnings <- NULL
[10:27:19.869]             }
[10:27:19.869]             base::options(...future.oldOptions)
[10:27:19.869]             if (.Platform$OS.type == "windows") {
[10:27:19.869]                 old_names <- names(...future.oldEnvVars)
[10:27:19.869]                 envs <- base::Sys.getenv()
[10:27:19.869]                 names <- names(envs)
[10:27:19.869]                 common <- intersect(names, old_names)
[10:27:19.869]                 added <- setdiff(names, old_names)
[10:27:19.869]                 removed <- setdiff(old_names, names)
[10:27:19.869]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:19.869]                   envs[common]]
[10:27:19.869]                 NAMES <- toupper(changed)
[10:27:19.869]                 args <- list()
[10:27:19.869]                 for (kk in seq_along(NAMES)) {
[10:27:19.869]                   name <- changed[[kk]]
[10:27:19.869]                   NAME <- NAMES[[kk]]
[10:27:19.869]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:19.869]                     next
[10:27:19.869]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:19.869]                 }
[10:27:19.869]                 NAMES <- toupper(added)
[10:27:19.869]                 for (kk in seq_along(NAMES)) {
[10:27:19.869]                   name <- added[[kk]]
[10:27:19.869]                   NAME <- NAMES[[kk]]
[10:27:19.869]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:19.869]                     next
[10:27:19.869]                   args[[name]] <- ""
[10:27:19.869]                 }
[10:27:19.869]                 NAMES <- toupper(removed)
[10:27:19.869]                 for (kk in seq_along(NAMES)) {
[10:27:19.869]                   name <- removed[[kk]]
[10:27:19.869]                   NAME <- NAMES[[kk]]
[10:27:19.869]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:19.869]                     next
[10:27:19.869]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:19.869]                 }
[10:27:19.869]                 if (length(args) > 0) 
[10:27:19.869]                   base::do.call(base::Sys.setenv, args = args)
[10:27:19.869]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:19.869]             }
[10:27:19.869]             else {
[10:27:19.869]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:19.869]             }
[10:27:19.869]             {
[10:27:19.869]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:19.869]                   0L) {
[10:27:19.869]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:19.869]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:19.869]                   base::options(opts)
[10:27:19.869]                 }
[10:27:19.869]                 {
[10:27:19.869]                   {
[10:27:19.869]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:19.869]                     NULL
[10:27:19.869]                   }
[10:27:19.869]                   options(future.plan = NULL)
[10:27:19.869]                   if (is.na(NA_character_)) 
[10:27:19.869]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:19.869]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:19.869]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:19.869]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:19.869]                     envir = parent.frame()) 
[10:27:19.869]                   {
[10:27:19.869]                     if (is.function(workers)) 
[10:27:19.869]                       workers <- workers()
[10:27:19.869]                     workers <- structure(as.integer(workers), 
[10:27:19.869]                       class = class(workers))
[10:27:19.869]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:19.869]                       workers >= 1)
[10:27:19.869]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:19.869]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:19.869]                     }
[10:27:19.869]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:19.869]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:19.869]                       envir = envir)
[10:27:19.869]                     if (!future$lazy) 
[10:27:19.869]                       future <- run(future)
[10:27:19.869]                     invisible(future)
[10:27:19.869]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:19.869]                 }
[10:27:19.869]             }
[10:27:19.869]         }
[10:27:19.869]     })
[10:27:19.869]     if (TRUE) {
[10:27:19.869]         base::sink(type = "output", split = FALSE)
[10:27:19.869]         if (TRUE) {
[10:27:19.869]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:19.869]         }
[10:27:19.869]         else {
[10:27:19.869]             ...future.result["stdout"] <- base::list(NULL)
[10:27:19.869]         }
[10:27:19.869]         base::close(...future.stdout)
[10:27:19.869]         ...future.stdout <- NULL
[10:27:19.869]     }
[10:27:19.869]     ...future.result$conditions <- ...future.conditions
[10:27:19.869]     ...future.result$finished <- base::Sys.time()
[10:27:19.869]     ...future.result
[10:27:19.869] }
[10:27:19.873] MultisessionFuture started
[10:27:19.873] - Launch lazy future ... done
[10:27:19.873] run() for ‘MultisessionFuture’ ... done
[10:27:20.419] receiveMessageFromWorker() for ClusterFuture ...
[10:27:20.420] - Validating connection of MultisessionFuture
[10:27:20.420] - received message: FutureResult
[10:27:20.420] - Received FutureResult
[10:27:20.420] - Erased future from FutureRegistry
[10:27:20.420] result() for ClusterFuture ...
[10:27:20.420] - result already collected: FutureResult
[10:27:20.420] result() for ClusterFuture ... done
[10:27:20.420] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:20.421] resolve() on list ...
[10:27:20.421]  recursive: Inf
[10:27:20.421]  length: 2
[10:27:20.421]  elements: ‘a’, ‘b’
[10:27:20.421]  length: 1 (resolved future 1)
[10:27:20.421]  length: 0 (resolved future 2)
[10:27:20.421] resolve() on list ... DONE
[10:27:20.421] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[10:27:20.421] getGlobalsAndPackages() ...
[10:27:20.422] Searching for globals...
[10:27:20.425] - globals found: [2] ‘list’, ‘stop’
[10:27:20.425] Searching for globals ... DONE
[10:27:20.425] Resolving globals: FALSE
[10:27:20.426] 
[10:27:20.426] 
[10:27:20.426] getGlobalsAndPackages() ... DONE
[10:27:20.426] run() for ‘Future’ ...
[10:27:20.426] - state: ‘created’
[10:27:20.426] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:20.441] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:20.441] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:20.441]   - Field: ‘node’
[10:27:20.442]   - Field: ‘label’
[10:27:20.442]   - Field: ‘local’
[10:27:20.442]   - Field: ‘owner’
[10:27:20.442]   - Field: ‘envir’
[10:27:20.442]   - Field: ‘workers’
[10:27:20.442]   - Field: ‘packages’
[10:27:20.442]   - Field: ‘gc’
[10:27:20.442]   - Field: ‘conditions’
[10:27:20.442]   - Field: ‘persistent’
[10:27:20.442]   - Field: ‘expr’
[10:27:20.442]   - Field: ‘uuid’
[10:27:20.443]   - Field: ‘seed’
[10:27:20.443]   - Field: ‘version’
[10:27:20.443]   - Field: ‘result’
[10:27:20.443]   - Field: ‘asynchronous’
[10:27:20.443]   - Field: ‘calls’
[10:27:20.443]   - Field: ‘globals’
[10:27:20.443]   - Field: ‘stdout’
[10:27:20.443]   - Field: ‘earlySignal’
[10:27:20.443]   - Field: ‘lazy’
[10:27:20.443]   - Field: ‘state’
[10:27:20.443] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:20.444] - Launch lazy future ...
[10:27:20.444] Packages needed by the future expression (n = 0): <none>
[10:27:20.444] Packages needed by future strategies (n = 0): <none>
[10:27:20.444] {
[10:27:20.444]     {
[10:27:20.444]         {
[10:27:20.444]             ...future.startTime <- base::Sys.time()
[10:27:20.444]             {
[10:27:20.444]                 {
[10:27:20.444]                   {
[10:27:20.444]                     {
[10:27:20.444]                       base::local({
[10:27:20.444]                         has_future <- base::requireNamespace("future", 
[10:27:20.444]                           quietly = TRUE)
[10:27:20.444]                         if (has_future) {
[10:27:20.444]                           ns <- base::getNamespace("future")
[10:27:20.444]                           version <- ns[[".package"]][["version"]]
[10:27:20.444]                           if (is.null(version)) 
[10:27:20.444]                             version <- utils::packageVersion("future")
[10:27:20.444]                         }
[10:27:20.444]                         else {
[10:27:20.444]                           version <- NULL
[10:27:20.444]                         }
[10:27:20.444]                         if (!has_future || version < "1.8.0") {
[10:27:20.444]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:20.444]                             "", base::R.version$version.string), 
[10:27:20.444]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:20.444]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:20.444]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:20.444]                               "release", "version")], collapse = " "), 
[10:27:20.444]                             hostname = base::Sys.info()[["nodename"]])
[10:27:20.444]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:20.444]                             info)
[10:27:20.444]                           info <- base::paste(info, collapse = "; ")
[10:27:20.444]                           if (!has_future) {
[10:27:20.444]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:20.444]                               info)
[10:27:20.444]                           }
[10:27:20.444]                           else {
[10:27:20.444]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:20.444]                               info, version)
[10:27:20.444]                           }
[10:27:20.444]                           base::stop(msg)
[10:27:20.444]                         }
[10:27:20.444]                       })
[10:27:20.444]                     }
[10:27:20.444]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:20.444]                     base::options(mc.cores = 1L)
[10:27:20.444]                   }
[10:27:20.444]                   options(future.plan = NULL)
[10:27:20.444]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:20.444]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:20.444]                 }
[10:27:20.444]                 ...future.workdir <- getwd()
[10:27:20.444]             }
[10:27:20.444]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:20.444]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:20.444]         }
[10:27:20.444]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:20.444]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:20.444]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:20.444]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:20.444]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:20.444]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:20.444]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:20.444]             base::names(...future.oldOptions))
[10:27:20.444]     }
[10:27:20.444]     if (FALSE) {
[10:27:20.444]     }
[10:27:20.444]     else {
[10:27:20.444]         if (TRUE) {
[10:27:20.444]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:20.444]                 open = "w")
[10:27:20.444]         }
[10:27:20.444]         else {
[10:27:20.444]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:20.444]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:20.444]         }
[10:27:20.444]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:20.444]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:20.444]             base::sink(type = "output", split = FALSE)
[10:27:20.444]             base::close(...future.stdout)
[10:27:20.444]         }, add = TRUE)
[10:27:20.444]     }
[10:27:20.444]     ...future.frame <- base::sys.nframe()
[10:27:20.444]     ...future.conditions <- base::list()
[10:27:20.444]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:20.444]     if (FALSE) {
[10:27:20.444]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:20.444]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:20.444]     }
[10:27:20.444]     ...future.result <- base::tryCatch({
[10:27:20.444]         base::withCallingHandlers({
[10:27:20.444]             ...future.value <- base::withVisible(base::local({
[10:27:20.444]                 ...future.makeSendCondition <- base::local({
[10:27:20.444]                   sendCondition <- NULL
[10:27:20.444]                   function(frame = 1L) {
[10:27:20.444]                     if (is.function(sendCondition)) 
[10:27:20.444]                       return(sendCondition)
[10:27:20.444]                     ns <- getNamespace("parallel")
[10:27:20.444]                     if (exists("sendData", mode = "function", 
[10:27:20.444]                       envir = ns)) {
[10:27:20.444]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:20.444]                         envir = ns)
[10:27:20.444]                       envir <- sys.frame(frame)
[10:27:20.444]                       master <- NULL
[10:27:20.444]                       while (!identical(envir, .GlobalEnv) && 
[10:27:20.444]                         !identical(envir, emptyenv())) {
[10:27:20.444]                         if (exists("master", mode = "list", envir = envir, 
[10:27:20.444]                           inherits = FALSE)) {
[10:27:20.444]                           master <- get("master", mode = "list", 
[10:27:20.444]                             envir = envir, inherits = FALSE)
[10:27:20.444]                           if (inherits(master, c("SOCKnode", 
[10:27:20.444]                             "SOCK0node"))) {
[10:27:20.444]                             sendCondition <<- function(cond) {
[10:27:20.444]                               data <- list(type = "VALUE", value = cond, 
[10:27:20.444]                                 success = TRUE)
[10:27:20.444]                               parallel_sendData(master, data)
[10:27:20.444]                             }
[10:27:20.444]                             return(sendCondition)
[10:27:20.444]                           }
[10:27:20.444]                         }
[10:27:20.444]                         frame <- frame + 1L
[10:27:20.444]                         envir <- sys.frame(frame)
[10:27:20.444]                       }
[10:27:20.444]                     }
[10:27:20.444]                     sendCondition <<- function(cond) NULL
[10:27:20.444]                   }
[10:27:20.444]                 })
[10:27:20.444]                 withCallingHandlers({
[10:27:20.444]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:27:20.444]                 }, immediateCondition = function(cond) {
[10:27:20.444]                   sendCondition <- ...future.makeSendCondition()
[10:27:20.444]                   sendCondition(cond)
[10:27:20.444]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:20.444]                   {
[10:27:20.444]                     inherits <- base::inherits
[10:27:20.444]                     invokeRestart <- base::invokeRestart
[10:27:20.444]                     is.null <- base::is.null
[10:27:20.444]                     muffled <- FALSE
[10:27:20.444]                     if (inherits(cond, "message")) {
[10:27:20.444]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:20.444]                       if (muffled) 
[10:27:20.444]                         invokeRestart("muffleMessage")
[10:27:20.444]                     }
[10:27:20.444]                     else if (inherits(cond, "warning")) {
[10:27:20.444]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:20.444]                       if (muffled) 
[10:27:20.444]                         invokeRestart("muffleWarning")
[10:27:20.444]                     }
[10:27:20.444]                     else if (inherits(cond, "condition")) {
[10:27:20.444]                       if (!is.null(pattern)) {
[10:27:20.444]                         computeRestarts <- base::computeRestarts
[10:27:20.444]                         grepl <- base::grepl
[10:27:20.444]                         restarts <- computeRestarts(cond)
[10:27:20.444]                         for (restart in restarts) {
[10:27:20.444]                           name <- restart$name
[10:27:20.444]                           if (is.null(name)) 
[10:27:20.444]                             next
[10:27:20.444]                           if (!grepl(pattern, name)) 
[10:27:20.444]                             next
[10:27:20.444]                           invokeRestart(restart)
[10:27:20.444]                           muffled <- TRUE
[10:27:20.444]                           break
[10:27:20.444]                         }
[10:27:20.444]                       }
[10:27:20.444]                     }
[10:27:20.444]                     invisible(muffled)
[10:27:20.444]                   }
[10:27:20.444]                   muffleCondition(cond)
[10:27:20.444]                 })
[10:27:20.444]             }))
[10:27:20.444]             future::FutureResult(value = ...future.value$value, 
[10:27:20.444]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:20.444]                   ...future.rng), globalenv = if (FALSE) 
[10:27:20.444]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:20.444]                     ...future.globalenv.names))
[10:27:20.444]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:20.444]         }, condition = base::local({
[10:27:20.444]             c <- base::c
[10:27:20.444]             inherits <- base::inherits
[10:27:20.444]             invokeRestart <- base::invokeRestart
[10:27:20.444]             length <- base::length
[10:27:20.444]             list <- base::list
[10:27:20.444]             seq.int <- base::seq.int
[10:27:20.444]             signalCondition <- base::signalCondition
[10:27:20.444]             sys.calls <- base::sys.calls
[10:27:20.444]             `[[` <- base::`[[`
[10:27:20.444]             `+` <- base::`+`
[10:27:20.444]             `<<-` <- base::`<<-`
[10:27:20.444]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:20.444]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:20.444]                   3L)]
[10:27:20.444]             }
[10:27:20.444]             function(cond) {
[10:27:20.444]                 is_error <- inherits(cond, "error")
[10:27:20.444]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:20.444]                   NULL)
[10:27:20.444]                 if (is_error) {
[10:27:20.444]                   sessionInformation <- function() {
[10:27:20.444]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:20.444]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:20.444]                       search = base::search(), system = base::Sys.info())
[10:27:20.444]                   }
[10:27:20.444]                   ...future.conditions[[length(...future.conditions) + 
[10:27:20.444]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:20.444]                     cond$call), session = sessionInformation(), 
[10:27:20.444]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:20.444]                   signalCondition(cond)
[10:27:20.444]                 }
[10:27:20.444]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:20.444]                 "immediateCondition"))) {
[10:27:20.444]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:20.444]                   ...future.conditions[[length(...future.conditions) + 
[10:27:20.444]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:20.444]                   if (TRUE && !signal) {
[10:27:20.444]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:20.444]                     {
[10:27:20.444]                       inherits <- base::inherits
[10:27:20.444]                       invokeRestart <- base::invokeRestart
[10:27:20.444]                       is.null <- base::is.null
[10:27:20.444]                       muffled <- FALSE
[10:27:20.444]                       if (inherits(cond, "message")) {
[10:27:20.444]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:20.444]                         if (muffled) 
[10:27:20.444]                           invokeRestart("muffleMessage")
[10:27:20.444]                       }
[10:27:20.444]                       else if (inherits(cond, "warning")) {
[10:27:20.444]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:20.444]                         if (muffled) 
[10:27:20.444]                           invokeRestart("muffleWarning")
[10:27:20.444]                       }
[10:27:20.444]                       else if (inherits(cond, "condition")) {
[10:27:20.444]                         if (!is.null(pattern)) {
[10:27:20.444]                           computeRestarts <- base::computeRestarts
[10:27:20.444]                           grepl <- base::grepl
[10:27:20.444]                           restarts <- computeRestarts(cond)
[10:27:20.444]                           for (restart in restarts) {
[10:27:20.444]                             name <- restart$name
[10:27:20.444]                             if (is.null(name)) 
[10:27:20.444]                               next
[10:27:20.444]                             if (!grepl(pattern, name)) 
[10:27:20.444]                               next
[10:27:20.444]                             invokeRestart(restart)
[10:27:20.444]                             muffled <- TRUE
[10:27:20.444]                             break
[10:27:20.444]                           }
[10:27:20.444]                         }
[10:27:20.444]                       }
[10:27:20.444]                       invisible(muffled)
[10:27:20.444]                     }
[10:27:20.444]                     muffleCondition(cond, pattern = "^muffle")
[10:27:20.444]                   }
[10:27:20.444]                 }
[10:27:20.444]                 else {
[10:27:20.444]                   if (TRUE) {
[10:27:20.444]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:20.444]                     {
[10:27:20.444]                       inherits <- base::inherits
[10:27:20.444]                       invokeRestart <- base::invokeRestart
[10:27:20.444]                       is.null <- base::is.null
[10:27:20.444]                       muffled <- FALSE
[10:27:20.444]                       if (inherits(cond, "message")) {
[10:27:20.444]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:20.444]                         if (muffled) 
[10:27:20.444]                           invokeRestart("muffleMessage")
[10:27:20.444]                       }
[10:27:20.444]                       else if (inherits(cond, "warning")) {
[10:27:20.444]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:20.444]                         if (muffled) 
[10:27:20.444]                           invokeRestart("muffleWarning")
[10:27:20.444]                       }
[10:27:20.444]                       else if (inherits(cond, "condition")) {
[10:27:20.444]                         if (!is.null(pattern)) {
[10:27:20.444]                           computeRestarts <- base::computeRestarts
[10:27:20.444]                           grepl <- base::grepl
[10:27:20.444]                           restarts <- computeRestarts(cond)
[10:27:20.444]                           for (restart in restarts) {
[10:27:20.444]                             name <- restart$name
[10:27:20.444]                             if (is.null(name)) 
[10:27:20.444]                               next
[10:27:20.444]                             if (!grepl(pattern, name)) 
[10:27:20.444]                               next
[10:27:20.444]                             invokeRestart(restart)
[10:27:20.444]                             muffled <- TRUE
[10:27:20.444]                             break
[10:27:20.444]                           }
[10:27:20.444]                         }
[10:27:20.444]                       }
[10:27:20.444]                       invisible(muffled)
[10:27:20.444]                     }
[10:27:20.444]                     muffleCondition(cond, pattern = "^muffle")
[10:27:20.444]                   }
[10:27:20.444]                 }
[10:27:20.444]             }
[10:27:20.444]         }))
[10:27:20.444]     }, error = function(ex) {
[10:27:20.444]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:20.444]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:20.444]                 ...future.rng), started = ...future.startTime, 
[10:27:20.444]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:20.444]             version = "1.8"), class = "FutureResult")
[10:27:20.444]     }, finally = {
[10:27:20.444]         if (!identical(...future.workdir, getwd())) 
[10:27:20.444]             setwd(...future.workdir)
[10:27:20.444]         {
[10:27:20.444]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:20.444]                 ...future.oldOptions$nwarnings <- NULL
[10:27:20.444]             }
[10:27:20.444]             base::options(...future.oldOptions)
[10:27:20.444]             if (.Platform$OS.type == "windows") {
[10:27:20.444]                 old_names <- names(...future.oldEnvVars)
[10:27:20.444]                 envs <- base::Sys.getenv()
[10:27:20.444]                 names <- names(envs)
[10:27:20.444]                 common <- intersect(names, old_names)
[10:27:20.444]                 added <- setdiff(names, old_names)
[10:27:20.444]                 removed <- setdiff(old_names, names)
[10:27:20.444]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:20.444]                   envs[common]]
[10:27:20.444]                 NAMES <- toupper(changed)
[10:27:20.444]                 args <- list()
[10:27:20.444]                 for (kk in seq_along(NAMES)) {
[10:27:20.444]                   name <- changed[[kk]]
[10:27:20.444]                   NAME <- NAMES[[kk]]
[10:27:20.444]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:20.444]                     next
[10:27:20.444]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:20.444]                 }
[10:27:20.444]                 NAMES <- toupper(added)
[10:27:20.444]                 for (kk in seq_along(NAMES)) {
[10:27:20.444]                   name <- added[[kk]]
[10:27:20.444]                   NAME <- NAMES[[kk]]
[10:27:20.444]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:20.444]                     next
[10:27:20.444]                   args[[name]] <- ""
[10:27:20.444]                 }
[10:27:20.444]                 NAMES <- toupper(removed)
[10:27:20.444]                 for (kk in seq_along(NAMES)) {
[10:27:20.444]                   name <- removed[[kk]]
[10:27:20.444]                   NAME <- NAMES[[kk]]
[10:27:20.444]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:20.444]                     next
[10:27:20.444]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:20.444]                 }
[10:27:20.444]                 if (length(args) > 0) 
[10:27:20.444]                   base::do.call(base::Sys.setenv, args = args)
[10:27:20.444]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:20.444]             }
[10:27:20.444]             else {
[10:27:20.444]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:20.444]             }
[10:27:20.444]             {
[10:27:20.444]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:20.444]                   0L) {
[10:27:20.444]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:20.444]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:20.444]                   base::options(opts)
[10:27:20.444]                 }
[10:27:20.444]                 {
[10:27:20.444]                   {
[10:27:20.444]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:20.444]                     NULL
[10:27:20.444]                   }
[10:27:20.444]                   options(future.plan = NULL)
[10:27:20.444]                   if (is.na(NA_character_)) 
[10:27:20.444]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:20.444]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:20.444]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:20.444]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:20.444]                     envir = parent.frame()) 
[10:27:20.444]                   {
[10:27:20.444]                     if (is.function(workers)) 
[10:27:20.444]                       workers <- workers()
[10:27:20.444]                     workers <- structure(as.integer(workers), 
[10:27:20.444]                       class = class(workers))
[10:27:20.444]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:20.444]                       workers >= 1)
[10:27:20.444]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:20.444]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:20.444]                     }
[10:27:20.444]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:20.444]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:20.444]                       envir = envir)
[10:27:20.444]                     if (!future$lazy) 
[10:27:20.444]                       future <- run(future)
[10:27:20.444]                     invisible(future)
[10:27:20.444]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:20.444]                 }
[10:27:20.444]             }
[10:27:20.444]         }
[10:27:20.444]     })
[10:27:20.444]     if (TRUE) {
[10:27:20.444]         base::sink(type = "output", split = FALSE)
[10:27:20.444]         if (TRUE) {
[10:27:20.444]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:20.444]         }
[10:27:20.444]         else {
[10:27:20.444]             ...future.result["stdout"] <- base::list(NULL)
[10:27:20.444]         }
[10:27:20.444]         base::close(...future.stdout)
[10:27:20.444]         ...future.stdout <- NULL
[10:27:20.444]     }
[10:27:20.444]     ...future.result$conditions <- ...future.conditions
[10:27:20.444]     ...future.result$finished <- base::Sys.time()
[10:27:20.444]     ...future.result
[10:27:20.444] }
[10:27:20.448] MultisessionFuture started
[10:27:20.448] - Launch lazy future ... done
[10:27:20.448] run() for ‘MultisessionFuture’ ... done
[10:27:20.495] receiveMessageFromWorker() for ClusterFuture ...
[10:27:20.495] - Validating connection of MultisessionFuture
[10:27:20.496] - received message: FutureResult
[10:27:20.496] - Received FutureResult
[10:27:20.496] - Erased future from FutureRegistry
[10:27:20.496] result() for ClusterFuture ...
[10:27:20.496] - result already collected: FutureResult
[10:27:20.496] result() for ClusterFuture ... done
[10:27:20.496] signalConditions() ...
[10:27:20.496]  - include = ‘immediateCondition’
[10:27:20.496]  - exclude = 
[10:27:20.496]  - resignal = FALSE
[10:27:20.497]  - Number of conditions: 1
[10:27:20.497] signalConditions() ... done
[10:27:20.497] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:20.497] A MultisessionFuture was resolved
[10:27:20.497] getGlobalsAndPackages() ...
[10:27:20.497] Searching for globals...
[10:27:20.498] - globals found: [2] ‘list’, ‘stop’
[10:27:20.498] Searching for globals ... DONE
[10:27:20.498] Resolving globals: FALSE
[10:27:20.498] 
[10:27:20.499] 
[10:27:20.499] getGlobalsAndPackages() ... DONE
[10:27:20.499] run() for ‘Future’ ...
[10:27:20.499] - state: ‘created’
[10:27:20.499] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:20.514] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:20.514] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:20.514]   - Field: ‘node’
[10:27:20.514]   - Field: ‘label’
[10:27:20.514]   - Field: ‘local’
[10:27:20.514]   - Field: ‘owner’
[10:27:20.514]   - Field: ‘envir’
[10:27:20.515]   - Field: ‘workers’
[10:27:20.515]   - Field: ‘packages’
[10:27:20.515]   - Field: ‘gc’
[10:27:20.515]   - Field: ‘conditions’
[10:27:20.515]   - Field: ‘persistent’
[10:27:20.515]   - Field: ‘expr’
[10:27:20.515]   - Field: ‘uuid’
[10:27:20.515]   - Field: ‘seed’
[10:27:20.515]   - Field: ‘version’
[10:27:20.515]   - Field: ‘result’
[10:27:20.515]   - Field: ‘asynchronous’
[10:27:20.516]   - Field: ‘calls’
[10:27:20.516]   - Field: ‘globals’
[10:27:20.516]   - Field: ‘stdout’
[10:27:20.516]   - Field: ‘earlySignal’
[10:27:20.516]   - Field: ‘lazy’
[10:27:20.516]   - Field: ‘state’
[10:27:20.516] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:20.516] - Launch lazy future ...
[10:27:20.517] Packages needed by the future expression (n = 0): <none>
[10:27:20.517] Packages needed by future strategies (n = 0): <none>
[10:27:20.517] {
[10:27:20.517]     {
[10:27:20.517]         {
[10:27:20.517]             ...future.startTime <- base::Sys.time()
[10:27:20.517]             {
[10:27:20.517]                 {
[10:27:20.517]                   {
[10:27:20.517]                     {
[10:27:20.517]                       base::local({
[10:27:20.517]                         has_future <- base::requireNamespace("future", 
[10:27:20.517]                           quietly = TRUE)
[10:27:20.517]                         if (has_future) {
[10:27:20.517]                           ns <- base::getNamespace("future")
[10:27:20.517]                           version <- ns[[".package"]][["version"]]
[10:27:20.517]                           if (is.null(version)) 
[10:27:20.517]                             version <- utils::packageVersion("future")
[10:27:20.517]                         }
[10:27:20.517]                         else {
[10:27:20.517]                           version <- NULL
[10:27:20.517]                         }
[10:27:20.517]                         if (!has_future || version < "1.8.0") {
[10:27:20.517]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:20.517]                             "", base::R.version$version.string), 
[10:27:20.517]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:20.517]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:20.517]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:20.517]                               "release", "version")], collapse = " "), 
[10:27:20.517]                             hostname = base::Sys.info()[["nodename"]])
[10:27:20.517]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:20.517]                             info)
[10:27:20.517]                           info <- base::paste(info, collapse = "; ")
[10:27:20.517]                           if (!has_future) {
[10:27:20.517]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:20.517]                               info)
[10:27:20.517]                           }
[10:27:20.517]                           else {
[10:27:20.517]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:20.517]                               info, version)
[10:27:20.517]                           }
[10:27:20.517]                           base::stop(msg)
[10:27:20.517]                         }
[10:27:20.517]                       })
[10:27:20.517]                     }
[10:27:20.517]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:20.517]                     base::options(mc.cores = 1L)
[10:27:20.517]                   }
[10:27:20.517]                   options(future.plan = NULL)
[10:27:20.517]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:20.517]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:20.517]                 }
[10:27:20.517]                 ...future.workdir <- getwd()
[10:27:20.517]             }
[10:27:20.517]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:20.517]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:20.517]         }
[10:27:20.517]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:20.517]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:20.517]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:20.517]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:20.517]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:20.517]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:20.517]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:20.517]             base::names(...future.oldOptions))
[10:27:20.517]     }
[10:27:20.517]     if (FALSE) {
[10:27:20.517]     }
[10:27:20.517]     else {
[10:27:20.517]         if (TRUE) {
[10:27:20.517]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:20.517]                 open = "w")
[10:27:20.517]         }
[10:27:20.517]         else {
[10:27:20.517]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:20.517]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:20.517]         }
[10:27:20.517]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:20.517]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:20.517]             base::sink(type = "output", split = FALSE)
[10:27:20.517]             base::close(...future.stdout)
[10:27:20.517]         }, add = TRUE)
[10:27:20.517]     }
[10:27:20.517]     ...future.frame <- base::sys.nframe()
[10:27:20.517]     ...future.conditions <- base::list()
[10:27:20.517]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:20.517]     if (FALSE) {
[10:27:20.517]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:20.517]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:20.517]     }
[10:27:20.517]     ...future.result <- base::tryCatch({
[10:27:20.517]         base::withCallingHandlers({
[10:27:20.517]             ...future.value <- base::withVisible(base::local({
[10:27:20.517]                 ...future.makeSendCondition <- base::local({
[10:27:20.517]                   sendCondition <- NULL
[10:27:20.517]                   function(frame = 1L) {
[10:27:20.517]                     if (is.function(sendCondition)) 
[10:27:20.517]                       return(sendCondition)
[10:27:20.517]                     ns <- getNamespace("parallel")
[10:27:20.517]                     if (exists("sendData", mode = "function", 
[10:27:20.517]                       envir = ns)) {
[10:27:20.517]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:20.517]                         envir = ns)
[10:27:20.517]                       envir <- sys.frame(frame)
[10:27:20.517]                       master <- NULL
[10:27:20.517]                       while (!identical(envir, .GlobalEnv) && 
[10:27:20.517]                         !identical(envir, emptyenv())) {
[10:27:20.517]                         if (exists("master", mode = "list", envir = envir, 
[10:27:20.517]                           inherits = FALSE)) {
[10:27:20.517]                           master <- get("master", mode = "list", 
[10:27:20.517]                             envir = envir, inherits = FALSE)
[10:27:20.517]                           if (inherits(master, c("SOCKnode", 
[10:27:20.517]                             "SOCK0node"))) {
[10:27:20.517]                             sendCondition <<- function(cond) {
[10:27:20.517]                               data <- list(type = "VALUE", value = cond, 
[10:27:20.517]                                 success = TRUE)
[10:27:20.517]                               parallel_sendData(master, data)
[10:27:20.517]                             }
[10:27:20.517]                             return(sendCondition)
[10:27:20.517]                           }
[10:27:20.517]                         }
[10:27:20.517]                         frame <- frame + 1L
[10:27:20.517]                         envir <- sys.frame(frame)
[10:27:20.517]                       }
[10:27:20.517]                     }
[10:27:20.517]                     sendCondition <<- function(cond) NULL
[10:27:20.517]                   }
[10:27:20.517]                 })
[10:27:20.517]                 withCallingHandlers({
[10:27:20.517]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:27:20.517]                 }, immediateCondition = function(cond) {
[10:27:20.517]                   sendCondition <- ...future.makeSendCondition()
[10:27:20.517]                   sendCondition(cond)
[10:27:20.517]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:20.517]                   {
[10:27:20.517]                     inherits <- base::inherits
[10:27:20.517]                     invokeRestart <- base::invokeRestart
[10:27:20.517]                     is.null <- base::is.null
[10:27:20.517]                     muffled <- FALSE
[10:27:20.517]                     if (inherits(cond, "message")) {
[10:27:20.517]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:20.517]                       if (muffled) 
[10:27:20.517]                         invokeRestart("muffleMessage")
[10:27:20.517]                     }
[10:27:20.517]                     else if (inherits(cond, "warning")) {
[10:27:20.517]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:20.517]                       if (muffled) 
[10:27:20.517]                         invokeRestart("muffleWarning")
[10:27:20.517]                     }
[10:27:20.517]                     else if (inherits(cond, "condition")) {
[10:27:20.517]                       if (!is.null(pattern)) {
[10:27:20.517]                         computeRestarts <- base::computeRestarts
[10:27:20.517]                         grepl <- base::grepl
[10:27:20.517]                         restarts <- computeRestarts(cond)
[10:27:20.517]                         for (restart in restarts) {
[10:27:20.517]                           name <- restart$name
[10:27:20.517]                           if (is.null(name)) 
[10:27:20.517]                             next
[10:27:20.517]                           if (!grepl(pattern, name)) 
[10:27:20.517]                             next
[10:27:20.517]                           invokeRestart(restart)
[10:27:20.517]                           muffled <- TRUE
[10:27:20.517]                           break
[10:27:20.517]                         }
[10:27:20.517]                       }
[10:27:20.517]                     }
[10:27:20.517]                     invisible(muffled)
[10:27:20.517]                   }
[10:27:20.517]                   muffleCondition(cond)
[10:27:20.517]                 })
[10:27:20.517]             }))
[10:27:20.517]             future::FutureResult(value = ...future.value$value, 
[10:27:20.517]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:20.517]                   ...future.rng), globalenv = if (FALSE) 
[10:27:20.517]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:20.517]                     ...future.globalenv.names))
[10:27:20.517]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:20.517]         }, condition = base::local({
[10:27:20.517]             c <- base::c
[10:27:20.517]             inherits <- base::inherits
[10:27:20.517]             invokeRestart <- base::invokeRestart
[10:27:20.517]             length <- base::length
[10:27:20.517]             list <- base::list
[10:27:20.517]             seq.int <- base::seq.int
[10:27:20.517]             signalCondition <- base::signalCondition
[10:27:20.517]             sys.calls <- base::sys.calls
[10:27:20.517]             `[[` <- base::`[[`
[10:27:20.517]             `+` <- base::`+`
[10:27:20.517]             `<<-` <- base::`<<-`
[10:27:20.517]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:20.517]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:20.517]                   3L)]
[10:27:20.517]             }
[10:27:20.517]             function(cond) {
[10:27:20.517]                 is_error <- inherits(cond, "error")
[10:27:20.517]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:20.517]                   NULL)
[10:27:20.517]                 if (is_error) {
[10:27:20.517]                   sessionInformation <- function() {
[10:27:20.517]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:20.517]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:20.517]                       search = base::search(), system = base::Sys.info())
[10:27:20.517]                   }
[10:27:20.517]                   ...future.conditions[[length(...future.conditions) + 
[10:27:20.517]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:20.517]                     cond$call), session = sessionInformation(), 
[10:27:20.517]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:20.517]                   signalCondition(cond)
[10:27:20.517]                 }
[10:27:20.517]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:20.517]                 "immediateCondition"))) {
[10:27:20.517]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:20.517]                   ...future.conditions[[length(...future.conditions) + 
[10:27:20.517]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:20.517]                   if (TRUE && !signal) {
[10:27:20.517]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:20.517]                     {
[10:27:20.517]                       inherits <- base::inherits
[10:27:20.517]                       invokeRestart <- base::invokeRestart
[10:27:20.517]                       is.null <- base::is.null
[10:27:20.517]                       muffled <- FALSE
[10:27:20.517]                       if (inherits(cond, "message")) {
[10:27:20.517]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:20.517]                         if (muffled) 
[10:27:20.517]                           invokeRestart("muffleMessage")
[10:27:20.517]                       }
[10:27:20.517]                       else if (inherits(cond, "warning")) {
[10:27:20.517]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:20.517]                         if (muffled) 
[10:27:20.517]                           invokeRestart("muffleWarning")
[10:27:20.517]                       }
[10:27:20.517]                       else if (inherits(cond, "condition")) {
[10:27:20.517]                         if (!is.null(pattern)) {
[10:27:20.517]                           computeRestarts <- base::computeRestarts
[10:27:20.517]                           grepl <- base::grepl
[10:27:20.517]                           restarts <- computeRestarts(cond)
[10:27:20.517]                           for (restart in restarts) {
[10:27:20.517]                             name <- restart$name
[10:27:20.517]                             if (is.null(name)) 
[10:27:20.517]                               next
[10:27:20.517]                             if (!grepl(pattern, name)) 
[10:27:20.517]                               next
[10:27:20.517]                             invokeRestart(restart)
[10:27:20.517]                             muffled <- TRUE
[10:27:20.517]                             break
[10:27:20.517]                           }
[10:27:20.517]                         }
[10:27:20.517]                       }
[10:27:20.517]                       invisible(muffled)
[10:27:20.517]                     }
[10:27:20.517]                     muffleCondition(cond, pattern = "^muffle")
[10:27:20.517]                   }
[10:27:20.517]                 }
[10:27:20.517]                 else {
[10:27:20.517]                   if (TRUE) {
[10:27:20.517]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:20.517]                     {
[10:27:20.517]                       inherits <- base::inherits
[10:27:20.517]                       invokeRestart <- base::invokeRestart
[10:27:20.517]                       is.null <- base::is.null
[10:27:20.517]                       muffled <- FALSE
[10:27:20.517]                       if (inherits(cond, "message")) {
[10:27:20.517]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:20.517]                         if (muffled) 
[10:27:20.517]                           invokeRestart("muffleMessage")
[10:27:20.517]                       }
[10:27:20.517]                       else if (inherits(cond, "warning")) {
[10:27:20.517]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:20.517]                         if (muffled) 
[10:27:20.517]                           invokeRestart("muffleWarning")
[10:27:20.517]                       }
[10:27:20.517]                       else if (inherits(cond, "condition")) {
[10:27:20.517]                         if (!is.null(pattern)) {
[10:27:20.517]                           computeRestarts <- base::computeRestarts
[10:27:20.517]                           grepl <- base::grepl
[10:27:20.517]                           restarts <- computeRestarts(cond)
[10:27:20.517]                           for (restart in restarts) {
[10:27:20.517]                             name <- restart$name
[10:27:20.517]                             if (is.null(name)) 
[10:27:20.517]                               next
[10:27:20.517]                             if (!grepl(pattern, name)) 
[10:27:20.517]                               next
[10:27:20.517]                             invokeRestart(restart)
[10:27:20.517]                             muffled <- TRUE
[10:27:20.517]                             break
[10:27:20.517]                           }
[10:27:20.517]                         }
[10:27:20.517]                       }
[10:27:20.517]                       invisible(muffled)
[10:27:20.517]                     }
[10:27:20.517]                     muffleCondition(cond, pattern = "^muffle")
[10:27:20.517]                   }
[10:27:20.517]                 }
[10:27:20.517]             }
[10:27:20.517]         }))
[10:27:20.517]     }, error = function(ex) {
[10:27:20.517]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:20.517]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:20.517]                 ...future.rng), started = ...future.startTime, 
[10:27:20.517]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:20.517]             version = "1.8"), class = "FutureResult")
[10:27:20.517]     }, finally = {
[10:27:20.517]         if (!identical(...future.workdir, getwd())) 
[10:27:20.517]             setwd(...future.workdir)
[10:27:20.517]         {
[10:27:20.517]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:20.517]                 ...future.oldOptions$nwarnings <- NULL
[10:27:20.517]             }
[10:27:20.517]             base::options(...future.oldOptions)
[10:27:20.517]             if (.Platform$OS.type == "windows") {
[10:27:20.517]                 old_names <- names(...future.oldEnvVars)
[10:27:20.517]                 envs <- base::Sys.getenv()
[10:27:20.517]                 names <- names(envs)
[10:27:20.517]                 common <- intersect(names, old_names)
[10:27:20.517]                 added <- setdiff(names, old_names)
[10:27:20.517]                 removed <- setdiff(old_names, names)
[10:27:20.517]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:20.517]                   envs[common]]
[10:27:20.517]                 NAMES <- toupper(changed)
[10:27:20.517]                 args <- list()
[10:27:20.517]                 for (kk in seq_along(NAMES)) {
[10:27:20.517]                   name <- changed[[kk]]
[10:27:20.517]                   NAME <- NAMES[[kk]]
[10:27:20.517]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:20.517]                     next
[10:27:20.517]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:20.517]                 }
[10:27:20.517]                 NAMES <- toupper(added)
[10:27:20.517]                 for (kk in seq_along(NAMES)) {
[10:27:20.517]                   name <- added[[kk]]
[10:27:20.517]                   NAME <- NAMES[[kk]]
[10:27:20.517]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:20.517]                     next
[10:27:20.517]                   args[[name]] <- ""
[10:27:20.517]                 }
[10:27:20.517]                 NAMES <- toupper(removed)
[10:27:20.517]                 for (kk in seq_along(NAMES)) {
[10:27:20.517]                   name <- removed[[kk]]
[10:27:20.517]                   NAME <- NAMES[[kk]]
[10:27:20.517]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:20.517]                     next
[10:27:20.517]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:20.517]                 }
[10:27:20.517]                 if (length(args) > 0) 
[10:27:20.517]                   base::do.call(base::Sys.setenv, args = args)
[10:27:20.517]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:20.517]             }
[10:27:20.517]             else {
[10:27:20.517]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:20.517]             }
[10:27:20.517]             {
[10:27:20.517]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:20.517]                   0L) {
[10:27:20.517]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:20.517]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:20.517]                   base::options(opts)
[10:27:20.517]                 }
[10:27:20.517]                 {
[10:27:20.517]                   {
[10:27:20.517]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:20.517]                     NULL
[10:27:20.517]                   }
[10:27:20.517]                   options(future.plan = NULL)
[10:27:20.517]                   if (is.na(NA_character_)) 
[10:27:20.517]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:20.517]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:20.517]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:20.517]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:20.517]                     envir = parent.frame()) 
[10:27:20.517]                   {
[10:27:20.517]                     if (is.function(workers)) 
[10:27:20.517]                       workers <- workers()
[10:27:20.517]                     workers <- structure(as.integer(workers), 
[10:27:20.517]                       class = class(workers))
[10:27:20.517]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:20.517]                       workers >= 1)
[10:27:20.517]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:20.517]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:20.517]                     }
[10:27:20.517]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:20.517]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:20.517]                       envir = envir)
[10:27:20.517]                     if (!future$lazy) 
[10:27:20.517]                       future <- run(future)
[10:27:20.517]                     invisible(future)
[10:27:20.517]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:20.517]                 }
[10:27:20.517]             }
[10:27:20.517]         }
[10:27:20.517]     })
[10:27:20.517]     if (TRUE) {
[10:27:20.517]         base::sink(type = "output", split = FALSE)
[10:27:20.517]         if (TRUE) {
[10:27:20.517]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:20.517]         }
[10:27:20.517]         else {
[10:27:20.517]             ...future.result["stdout"] <- base::list(NULL)
[10:27:20.517]         }
[10:27:20.517]         base::close(...future.stdout)
[10:27:20.517]         ...future.stdout <- NULL
[10:27:20.517]     }
[10:27:20.517]     ...future.result$conditions <- ...future.conditions
[10:27:20.517]     ...future.result$finished <- base::Sys.time()
[10:27:20.517]     ...future.result
[10:27:20.517] }
[10:27:20.521] MultisessionFuture started
[10:27:20.521] - Launch lazy future ... done
[10:27:20.521] run() for ‘MultisessionFuture’ ... done
[10:27:20.567] receiveMessageFromWorker() for ClusterFuture ...
[10:27:20.567] - Validating connection of MultisessionFuture
[10:27:20.568] - received message: FutureResult
[10:27:20.568] - Received FutureResult
[10:27:20.568] - Erased future from FutureRegistry
[10:27:20.568] result() for ClusterFuture ...
[10:27:20.568] - result already collected: FutureResult
[10:27:20.568] result() for ClusterFuture ... done
[10:27:20.568] signalConditions() ...
[10:27:20.568]  - include = ‘immediateCondition’
[10:27:20.569]  - exclude = 
[10:27:20.569]  - resignal = FALSE
[10:27:20.569]  - Number of conditions: 1
[10:27:20.569] signalConditions() ... done
[10:27:20.569] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:20.569] A MultisessionFuture was resolved
- result = TRUE, recursive = Inf ... DONE
*** resolve() for Future objects ... DONE
*** resolve() for lists ...
[10:27:20.569] resolve() on list ...
[10:27:20.569]  recursive: 0
[10:27:20.570]  length: 2
[10:27:20.570]  elements: ‘a’, ‘b’
[10:27:20.570]  length: 1 (resolved future 1)
[10:27:20.570]  length: 0 (resolved future 2)
[10:27:20.570] resolve() on list ... DONE
[10:27:20.570] getGlobalsAndPackages() ...
[10:27:20.570] Searching for globals...
[10:27:20.571] 
[10:27:20.571] Searching for globals ... DONE
[10:27:20.571] - globals: [0] <none>
[10:27:20.571] getGlobalsAndPackages() ... DONE
[10:27:20.571] run() for ‘Future’ ...
[10:27:20.571] - state: ‘created’
[10:27:20.571] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:20.588] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:20.588] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:20.589]   - Field: ‘node’
[10:27:20.589]   - Field: ‘label’
[10:27:20.589]   - Field: ‘local’
[10:27:20.589]   - Field: ‘owner’
[10:27:20.589]   - Field: ‘envir’
[10:27:20.589]   - Field: ‘workers’
[10:27:20.589]   - Field: ‘packages’
[10:27:20.589]   - Field: ‘gc’
[10:27:20.590]   - Field: ‘conditions’
[10:27:20.590]   - Field: ‘persistent’
[10:27:20.590]   - Field: ‘expr’
[10:27:20.590]   - Field: ‘uuid’
[10:27:20.590]   - Field: ‘seed’
[10:27:20.590]   - Field: ‘version’
[10:27:20.590]   - Field: ‘result’
[10:27:20.590]   - Field: ‘asynchronous’
[10:27:20.590]   - Field: ‘calls’
[10:27:20.590]   - Field: ‘globals’
[10:27:20.591]   - Field: ‘stdout’
[10:27:20.591]   - Field: ‘earlySignal’
[10:27:20.591]   - Field: ‘lazy’
[10:27:20.591]   - Field: ‘state’
[10:27:20.591] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:20.591] - Launch lazy future ...
[10:27:20.592] Packages needed by the future expression (n = 0): <none>
[10:27:20.592] Packages needed by future strategies (n = 0): <none>
[10:27:20.592] {
[10:27:20.592]     {
[10:27:20.592]         {
[10:27:20.592]             ...future.startTime <- base::Sys.time()
[10:27:20.592]             {
[10:27:20.592]                 {
[10:27:20.592]                   {
[10:27:20.592]                     {
[10:27:20.592]                       base::local({
[10:27:20.592]                         has_future <- base::requireNamespace("future", 
[10:27:20.592]                           quietly = TRUE)
[10:27:20.592]                         if (has_future) {
[10:27:20.592]                           ns <- base::getNamespace("future")
[10:27:20.592]                           version <- ns[[".package"]][["version"]]
[10:27:20.592]                           if (is.null(version)) 
[10:27:20.592]                             version <- utils::packageVersion("future")
[10:27:20.592]                         }
[10:27:20.592]                         else {
[10:27:20.592]                           version <- NULL
[10:27:20.592]                         }
[10:27:20.592]                         if (!has_future || version < "1.8.0") {
[10:27:20.592]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:20.592]                             "", base::R.version$version.string), 
[10:27:20.592]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:20.592]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:20.592]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:20.592]                               "release", "version")], collapse = " "), 
[10:27:20.592]                             hostname = base::Sys.info()[["nodename"]])
[10:27:20.592]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:20.592]                             info)
[10:27:20.592]                           info <- base::paste(info, collapse = "; ")
[10:27:20.592]                           if (!has_future) {
[10:27:20.592]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:20.592]                               info)
[10:27:20.592]                           }
[10:27:20.592]                           else {
[10:27:20.592]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:20.592]                               info, version)
[10:27:20.592]                           }
[10:27:20.592]                           base::stop(msg)
[10:27:20.592]                         }
[10:27:20.592]                       })
[10:27:20.592]                     }
[10:27:20.592]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:20.592]                     base::options(mc.cores = 1L)
[10:27:20.592]                   }
[10:27:20.592]                   options(future.plan = NULL)
[10:27:20.592]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:20.592]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:20.592]                 }
[10:27:20.592]                 ...future.workdir <- getwd()
[10:27:20.592]             }
[10:27:20.592]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:20.592]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:20.592]         }
[10:27:20.592]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:20.592]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:20.592]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:20.592]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:20.592]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:20.592]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:20.592]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:20.592]             base::names(...future.oldOptions))
[10:27:20.592]     }
[10:27:20.592]     if (FALSE) {
[10:27:20.592]     }
[10:27:20.592]     else {
[10:27:20.592]         if (TRUE) {
[10:27:20.592]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:20.592]                 open = "w")
[10:27:20.592]         }
[10:27:20.592]         else {
[10:27:20.592]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:20.592]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:20.592]         }
[10:27:20.592]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:20.592]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:20.592]             base::sink(type = "output", split = FALSE)
[10:27:20.592]             base::close(...future.stdout)
[10:27:20.592]         }, add = TRUE)
[10:27:20.592]     }
[10:27:20.592]     ...future.frame <- base::sys.nframe()
[10:27:20.592]     ...future.conditions <- base::list()
[10:27:20.592]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:20.592]     if (FALSE) {
[10:27:20.592]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:20.592]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:20.592]     }
[10:27:20.592]     ...future.result <- base::tryCatch({
[10:27:20.592]         base::withCallingHandlers({
[10:27:20.592]             ...future.value <- base::withVisible(base::local({
[10:27:20.592]                 ...future.makeSendCondition <- base::local({
[10:27:20.592]                   sendCondition <- NULL
[10:27:20.592]                   function(frame = 1L) {
[10:27:20.592]                     if (is.function(sendCondition)) 
[10:27:20.592]                       return(sendCondition)
[10:27:20.592]                     ns <- getNamespace("parallel")
[10:27:20.592]                     if (exists("sendData", mode = "function", 
[10:27:20.592]                       envir = ns)) {
[10:27:20.592]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:20.592]                         envir = ns)
[10:27:20.592]                       envir <- sys.frame(frame)
[10:27:20.592]                       master <- NULL
[10:27:20.592]                       while (!identical(envir, .GlobalEnv) && 
[10:27:20.592]                         !identical(envir, emptyenv())) {
[10:27:20.592]                         if (exists("master", mode = "list", envir = envir, 
[10:27:20.592]                           inherits = FALSE)) {
[10:27:20.592]                           master <- get("master", mode = "list", 
[10:27:20.592]                             envir = envir, inherits = FALSE)
[10:27:20.592]                           if (inherits(master, c("SOCKnode", 
[10:27:20.592]                             "SOCK0node"))) {
[10:27:20.592]                             sendCondition <<- function(cond) {
[10:27:20.592]                               data <- list(type = "VALUE", value = cond, 
[10:27:20.592]                                 success = TRUE)
[10:27:20.592]                               parallel_sendData(master, data)
[10:27:20.592]                             }
[10:27:20.592]                             return(sendCondition)
[10:27:20.592]                           }
[10:27:20.592]                         }
[10:27:20.592]                         frame <- frame + 1L
[10:27:20.592]                         envir <- sys.frame(frame)
[10:27:20.592]                       }
[10:27:20.592]                     }
[10:27:20.592]                     sendCondition <<- function(cond) NULL
[10:27:20.592]                   }
[10:27:20.592]                 })
[10:27:20.592]                 withCallingHandlers({
[10:27:20.592]                   1
[10:27:20.592]                 }, immediateCondition = function(cond) {
[10:27:20.592]                   sendCondition <- ...future.makeSendCondition()
[10:27:20.592]                   sendCondition(cond)
[10:27:20.592]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:20.592]                   {
[10:27:20.592]                     inherits <- base::inherits
[10:27:20.592]                     invokeRestart <- base::invokeRestart
[10:27:20.592]                     is.null <- base::is.null
[10:27:20.592]                     muffled <- FALSE
[10:27:20.592]                     if (inherits(cond, "message")) {
[10:27:20.592]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:20.592]                       if (muffled) 
[10:27:20.592]                         invokeRestart("muffleMessage")
[10:27:20.592]                     }
[10:27:20.592]                     else if (inherits(cond, "warning")) {
[10:27:20.592]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:20.592]                       if (muffled) 
[10:27:20.592]                         invokeRestart("muffleWarning")
[10:27:20.592]                     }
[10:27:20.592]                     else if (inherits(cond, "condition")) {
[10:27:20.592]                       if (!is.null(pattern)) {
[10:27:20.592]                         computeRestarts <- base::computeRestarts
[10:27:20.592]                         grepl <- base::grepl
[10:27:20.592]                         restarts <- computeRestarts(cond)
[10:27:20.592]                         for (restart in restarts) {
[10:27:20.592]                           name <- restart$name
[10:27:20.592]                           if (is.null(name)) 
[10:27:20.592]                             next
[10:27:20.592]                           if (!grepl(pattern, name)) 
[10:27:20.592]                             next
[10:27:20.592]                           invokeRestart(restart)
[10:27:20.592]                           muffled <- TRUE
[10:27:20.592]                           break
[10:27:20.592]                         }
[10:27:20.592]                       }
[10:27:20.592]                     }
[10:27:20.592]                     invisible(muffled)
[10:27:20.592]                   }
[10:27:20.592]                   muffleCondition(cond)
[10:27:20.592]                 })
[10:27:20.592]             }))
[10:27:20.592]             future::FutureResult(value = ...future.value$value, 
[10:27:20.592]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:20.592]                   ...future.rng), globalenv = if (FALSE) 
[10:27:20.592]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:20.592]                     ...future.globalenv.names))
[10:27:20.592]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:20.592]         }, condition = base::local({
[10:27:20.592]             c <- base::c
[10:27:20.592]             inherits <- base::inherits
[10:27:20.592]             invokeRestart <- base::invokeRestart
[10:27:20.592]             length <- base::length
[10:27:20.592]             list <- base::list
[10:27:20.592]             seq.int <- base::seq.int
[10:27:20.592]             signalCondition <- base::signalCondition
[10:27:20.592]             sys.calls <- base::sys.calls
[10:27:20.592]             `[[` <- base::`[[`
[10:27:20.592]             `+` <- base::`+`
[10:27:20.592]             `<<-` <- base::`<<-`
[10:27:20.592]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:20.592]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:20.592]                   3L)]
[10:27:20.592]             }
[10:27:20.592]             function(cond) {
[10:27:20.592]                 is_error <- inherits(cond, "error")
[10:27:20.592]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:20.592]                   NULL)
[10:27:20.592]                 if (is_error) {
[10:27:20.592]                   sessionInformation <- function() {
[10:27:20.592]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:20.592]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:20.592]                       search = base::search(), system = base::Sys.info())
[10:27:20.592]                   }
[10:27:20.592]                   ...future.conditions[[length(...future.conditions) + 
[10:27:20.592]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:20.592]                     cond$call), session = sessionInformation(), 
[10:27:20.592]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:20.592]                   signalCondition(cond)
[10:27:20.592]                 }
[10:27:20.592]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:20.592]                 "immediateCondition"))) {
[10:27:20.592]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:20.592]                   ...future.conditions[[length(...future.conditions) + 
[10:27:20.592]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:20.592]                   if (TRUE && !signal) {
[10:27:20.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:20.592]                     {
[10:27:20.592]                       inherits <- base::inherits
[10:27:20.592]                       invokeRestart <- base::invokeRestart
[10:27:20.592]                       is.null <- base::is.null
[10:27:20.592]                       muffled <- FALSE
[10:27:20.592]                       if (inherits(cond, "message")) {
[10:27:20.592]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:20.592]                         if (muffled) 
[10:27:20.592]                           invokeRestart("muffleMessage")
[10:27:20.592]                       }
[10:27:20.592]                       else if (inherits(cond, "warning")) {
[10:27:20.592]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:20.592]                         if (muffled) 
[10:27:20.592]                           invokeRestart("muffleWarning")
[10:27:20.592]                       }
[10:27:20.592]                       else if (inherits(cond, "condition")) {
[10:27:20.592]                         if (!is.null(pattern)) {
[10:27:20.592]                           computeRestarts <- base::computeRestarts
[10:27:20.592]                           grepl <- base::grepl
[10:27:20.592]                           restarts <- computeRestarts(cond)
[10:27:20.592]                           for (restart in restarts) {
[10:27:20.592]                             name <- restart$name
[10:27:20.592]                             if (is.null(name)) 
[10:27:20.592]                               next
[10:27:20.592]                             if (!grepl(pattern, name)) 
[10:27:20.592]                               next
[10:27:20.592]                             invokeRestart(restart)
[10:27:20.592]                             muffled <- TRUE
[10:27:20.592]                             break
[10:27:20.592]                           }
[10:27:20.592]                         }
[10:27:20.592]                       }
[10:27:20.592]                       invisible(muffled)
[10:27:20.592]                     }
[10:27:20.592]                     muffleCondition(cond, pattern = "^muffle")
[10:27:20.592]                   }
[10:27:20.592]                 }
[10:27:20.592]                 else {
[10:27:20.592]                   if (TRUE) {
[10:27:20.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:20.592]                     {
[10:27:20.592]                       inherits <- base::inherits
[10:27:20.592]                       invokeRestart <- base::invokeRestart
[10:27:20.592]                       is.null <- base::is.null
[10:27:20.592]                       muffled <- FALSE
[10:27:20.592]                       if (inherits(cond, "message")) {
[10:27:20.592]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:20.592]                         if (muffled) 
[10:27:20.592]                           invokeRestart("muffleMessage")
[10:27:20.592]                       }
[10:27:20.592]                       else if (inherits(cond, "warning")) {
[10:27:20.592]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:20.592]                         if (muffled) 
[10:27:20.592]                           invokeRestart("muffleWarning")
[10:27:20.592]                       }
[10:27:20.592]                       else if (inherits(cond, "condition")) {
[10:27:20.592]                         if (!is.null(pattern)) {
[10:27:20.592]                           computeRestarts <- base::computeRestarts
[10:27:20.592]                           grepl <- base::grepl
[10:27:20.592]                           restarts <- computeRestarts(cond)
[10:27:20.592]                           for (restart in restarts) {
[10:27:20.592]                             name <- restart$name
[10:27:20.592]                             if (is.null(name)) 
[10:27:20.592]                               next
[10:27:20.592]                             if (!grepl(pattern, name)) 
[10:27:20.592]                               next
[10:27:20.592]                             invokeRestart(restart)
[10:27:20.592]                             muffled <- TRUE
[10:27:20.592]                             break
[10:27:20.592]                           }
[10:27:20.592]                         }
[10:27:20.592]                       }
[10:27:20.592]                       invisible(muffled)
[10:27:20.592]                     }
[10:27:20.592]                     muffleCondition(cond, pattern = "^muffle")
[10:27:20.592]                   }
[10:27:20.592]                 }
[10:27:20.592]             }
[10:27:20.592]         }))
[10:27:20.592]     }, error = function(ex) {
[10:27:20.592]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:20.592]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:20.592]                 ...future.rng), started = ...future.startTime, 
[10:27:20.592]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:20.592]             version = "1.8"), class = "FutureResult")
[10:27:20.592]     }, finally = {
[10:27:20.592]         if (!identical(...future.workdir, getwd())) 
[10:27:20.592]             setwd(...future.workdir)
[10:27:20.592]         {
[10:27:20.592]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:20.592]                 ...future.oldOptions$nwarnings <- NULL
[10:27:20.592]             }
[10:27:20.592]             base::options(...future.oldOptions)
[10:27:20.592]             if (.Platform$OS.type == "windows") {
[10:27:20.592]                 old_names <- names(...future.oldEnvVars)
[10:27:20.592]                 envs <- base::Sys.getenv()
[10:27:20.592]                 names <- names(envs)
[10:27:20.592]                 common <- intersect(names, old_names)
[10:27:20.592]                 added <- setdiff(names, old_names)
[10:27:20.592]                 removed <- setdiff(old_names, names)
[10:27:20.592]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:20.592]                   envs[common]]
[10:27:20.592]                 NAMES <- toupper(changed)
[10:27:20.592]                 args <- list()
[10:27:20.592]                 for (kk in seq_along(NAMES)) {
[10:27:20.592]                   name <- changed[[kk]]
[10:27:20.592]                   NAME <- NAMES[[kk]]
[10:27:20.592]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:20.592]                     next
[10:27:20.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:20.592]                 }
[10:27:20.592]                 NAMES <- toupper(added)
[10:27:20.592]                 for (kk in seq_along(NAMES)) {
[10:27:20.592]                   name <- added[[kk]]
[10:27:20.592]                   NAME <- NAMES[[kk]]
[10:27:20.592]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:20.592]                     next
[10:27:20.592]                   args[[name]] <- ""
[10:27:20.592]                 }
[10:27:20.592]                 NAMES <- toupper(removed)
[10:27:20.592]                 for (kk in seq_along(NAMES)) {
[10:27:20.592]                   name <- removed[[kk]]
[10:27:20.592]                   NAME <- NAMES[[kk]]
[10:27:20.592]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:20.592]                     next
[10:27:20.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:20.592]                 }
[10:27:20.592]                 if (length(args) > 0) 
[10:27:20.592]                   base::do.call(base::Sys.setenv, args = args)
[10:27:20.592]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:20.592]             }
[10:27:20.592]             else {
[10:27:20.592]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:20.592]             }
[10:27:20.592]             {
[10:27:20.592]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:20.592]                   0L) {
[10:27:20.592]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:20.592]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:20.592]                   base::options(opts)
[10:27:20.592]                 }
[10:27:20.592]                 {
[10:27:20.592]                   {
[10:27:20.592]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:20.592]                     NULL
[10:27:20.592]                   }
[10:27:20.592]                   options(future.plan = NULL)
[10:27:20.592]                   if (is.na(NA_character_)) 
[10:27:20.592]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:20.592]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:20.592]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:20.592]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:20.592]                     envir = parent.frame()) 
[10:27:20.592]                   {
[10:27:20.592]                     if (is.function(workers)) 
[10:27:20.592]                       workers <- workers()
[10:27:20.592]                     workers <- structure(as.integer(workers), 
[10:27:20.592]                       class = class(workers))
[10:27:20.592]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:20.592]                       workers >= 1)
[10:27:20.592]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:20.592]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:20.592]                     }
[10:27:20.592]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:20.592]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:20.592]                       envir = envir)
[10:27:20.592]                     if (!future$lazy) 
[10:27:20.592]                       future <- run(future)
[10:27:20.592]                     invisible(future)
[10:27:20.592]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:20.592]                 }
[10:27:20.592]             }
[10:27:20.592]         }
[10:27:20.592]     })
[10:27:20.592]     if (TRUE) {
[10:27:20.592]         base::sink(type = "output", split = FALSE)
[10:27:20.592]         if (TRUE) {
[10:27:20.592]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:20.592]         }
[10:27:20.592]         else {
[10:27:20.592]             ...future.result["stdout"] <- base::list(NULL)
[10:27:20.592]         }
[10:27:20.592]         base::close(...future.stdout)
[10:27:20.592]         ...future.stdout <- NULL
[10:27:20.592]     }
[10:27:20.592]     ...future.result$conditions <- ...future.conditions
[10:27:20.592]     ...future.result$finished <- base::Sys.time()
[10:27:20.592]     ...future.result
[10:27:20.592] }
[10:27:20.596] MultisessionFuture started
[10:27:20.596] - Launch lazy future ... done
[10:27:20.596] run() for ‘MultisessionFuture’ ... done
[10:27:20.596] getGlobalsAndPackages() ...
[10:27:20.596] Searching for globals...
[10:27:20.597] 
[10:27:20.597] Searching for globals ... DONE
[10:27:20.597] - globals: [0] <none>
[10:27:20.597] getGlobalsAndPackages() ... DONE
[10:27:20.597] run() for ‘Future’ ...
[10:27:20.597] - state: ‘created’
[10:27:20.597] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:20.613] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:20.613] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:20.613]   - Field: ‘node’
[10:27:20.613]   - Field: ‘label’
[10:27:20.614]   - Field: ‘local’
[10:27:20.614]   - Field: ‘owner’
[10:27:20.614]   - Field: ‘envir’
[10:27:20.614]   - Field: ‘workers’
[10:27:20.614]   - Field: ‘packages’
[10:27:20.614]   - Field: ‘gc’
[10:27:20.614]   - Field: ‘conditions’
[10:27:20.614]   - Field: ‘persistent’
[10:27:20.614]   - Field: ‘expr’
[10:27:20.614]   - Field: ‘uuid’
[10:27:20.615]   - Field: ‘seed’
[10:27:20.615]   - Field: ‘version’
[10:27:20.615]   - Field: ‘result’
[10:27:20.615]   - Field: ‘asynchronous’
[10:27:20.615]   - Field: ‘calls’
[10:27:20.615]   - Field: ‘globals’
[10:27:20.615]   - Field: ‘stdout’
[10:27:20.615]   - Field: ‘earlySignal’
[10:27:20.615]   - Field: ‘lazy’
[10:27:20.615]   - Field: ‘state’
[10:27:20.616] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:20.616] - Launch lazy future ...
[10:27:20.616] Packages needed by the future expression (n = 0): <none>
[10:27:20.616] Packages needed by future strategies (n = 0): <none>
[10:27:20.617] {
[10:27:20.617]     {
[10:27:20.617]         {
[10:27:20.617]             ...future.startTime <- base::Sys.time()
[10:27:20.617]             {
[10:27:20.617]                 {
[10:27:20.617]                   {
[10:27:20.617]                     {
[10:27:20.617]                       base::local({
[10:27:20.617]                         has_future <- base::requireNamespace("future", 
[10:27:20.617]                           quietly = TRUE)
[10:27:20.617]                         if (has_future) {
[10:27:20.617]                           ns <- base::getNamespace("future")
[10:27:20.617]                           version <- ns[[".package"]][["version"]]
[10:27:20.617]                           if (is.null(version)) 
[10:27:20.617]                             version <- utils::packageVersion("future")
[10:27:20.617]                         }
[10:27:20.617]                         else {
[10:27:20.617]                           version <- NULL
[10:27:20.617]                         }
[10:27:20.617]                         if (!has_future || version < "1.8.0") {
[10:27:20.617]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:20.617]                             "", base::R.version$version.string), 
[10:27:20.617]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:20.617]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:20.617]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:20.617]                               "release", "version")], collapse = " "), 
[10:27:20.617]                             hostname = base::Sys.info()[["nodename"]])
[10:27:20.617]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:20.617]                             info)
[10:27:20.617]                           info <- base::paste(info, collapse = "; ")
[10:27:20.617]                           if (!has_future) {
[10:27:20.617]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:20.617]                               info)
[10:27:20.617]                           }
[10:27:20.617]                           else {
[10:27:20.617]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:20.617]                               info, version)
[10:27:20.617]                           }
[10:27:20.617]                           base::stop(msg)
[10:27:20.617]                         }
[10:27:20.617]                       })
[10:27:20.617]                     }
[10:27:20.617]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:20.617]                     base::options(mc.cores = 1L)
[10:27:20.617]                   }
[10:27:20.617]                   options(future.plan = NULL)
[10:27:20.617]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:20.617]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:20.617]                 }
[10:27:20.617]                 ...future.workdir <- getwd()
[10:27:20.617]             }
[10:27:20.617]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:20.617]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:20.617]         }
[10:27:20.617]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:20.617]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:20.617]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:20.617]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:20.617]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:20.617]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:20.617]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:20.617]             base::names(...future.oldOptions))
[10:27:20.617]     }
[10:27:20.617]     if (FALSE) {
[10:27:20.617]     }
[10:27:20.617]     else {
[10:27:20.617]         if (TRUE) {
[10:27:20.617]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:20.617]                 open = "w")
[10:27:20.617]         }
[10:27:20.617]         else {
[10:27:20.617]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:20.617]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:20.617]         }
[10:27:20.617]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:20.617]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:20.617]             base::sink(type = "output", split = FALSE)
[10:27:20.617]             base::close(...future.stdout)
[10:27:20.617]         }, add = TRUE)
[10:27:20.617]     }
[10:27:20.617]     ...future.frame <- base::sys.nframe()
[10:27:20.617]     ...future.conditions <- base::list()
[10:27:20.617]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:20.617]     if (FALSE) {
[10:27:20.617]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:20.617]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:20.617]     }
[10:27:20.617]     ...future.result <- base::tryCatch({
[10:27:20.617]         base::withCallingHandlers({
[10:27:20.617]             ...future.value <- base::withVisible(base::local({
[10:27:20.617]                 ...future.makeSendCondition <- base::local({
[10:27:20.617]                   sendCondition <- NULL
[10:27:20.617]                   function(frame = 1L) {
[10:27:20.617]                     if (is.function(sendCondition)) 
[10:27:20.617]                       return(sendCondition)
[10:27:20.617]                     ns <- getNamespace("parallel")
[10:27:20.617]                     if (exists("sendData", mode = "function", 
[10:27:20.617]                       envir = ns)) {
[10:27:20.617]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:20.617]                         envir = ns)
[10:27:20.617]                       envir <- sys.frame(frame)
[10:27:20.617]                       master <- NULL
[10:27:20.617]                       while (!identical(envir, .GlobalEnv) && 
[10:27:20.617]                         !identical(envir, emptyenv())) {
[10:27:20.617]                         if (exists("master", mode = "list", envir = envir, 
[10:27:20.617]                           inherits = FALSE)) {
[10:27:20.617]                           master <- get("master", mode = "list", 
[10:27:20.617]                             envir = envir, inherits = FALSE)
[10:27:20.617]                           if (inherits(master, c("SOCKnode", 
[10:27:20.617]                             "SOCK0node"))) {
[10:27:20.617]                             sendCondition <<- function(cond) {
[10:27:20.617]                               data <- list(type = "VALUE", value = cond, 
[10:27:20.617]                                 success = TRUE)
[10:27:20.617]                               parallel_sendData(master, data)
[10:27:20.617]                             }
[10:27:20.617]                             return(sendCondition)
[10:27:20.617]                           }
[10:27:20.617]                         }
[10:27:20.617]                         frame <- frame + 1L
[10:27:20.617]                         envir <- sys.frame(frame)
[10:27:20.617]                       }
[10:27:20.617]                     }
[10:27:20.617]                     sendCondition <<- function(cond) NULL
[10:27:20.617]                   }
[10:27:20.617]                 })
[10:27:20.617]                 withCallingHandlers({
[10:27:20.617]                   2
[10:27:20.617]                 }, immediateCondition = function(cond) {
[10:27:20.617]                   sendCondition <- ...future.makeSendCondition()
[10:27:20.617]                   sendCondition(cond)
[10:27:20.617]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:20.617]                   {
[10:27:20.617]                     inherits <- base::inherits
[10:27:20.617]                     invokeRestart <- base::invokeRestart
[10:27:20.617]                     is.null <- base::is.null
[10:27:20.617]                     muffled <- FALSE
[10:27:20.617]                     if (inherits(cond, "message")) {
[10:27:20.617]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:20.617]                       if (muffled) 
[10:27:20.617]                         invokeRestart("muffleMessage")
[10:27:20.617]                     }
[10:27:20.617]                     else if (inherits(cond, "warning")) {
[10:27:20.617]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:20.617]                       if (muffled) 
[10:27:20.617]                         invokeRestart("muffleWarning")
[10:27:20.617]                     }
[10:27:20.617]                     else if (inherits(cond, "condition")) {
[10:27:20.617]                       if (!is.null(pattern)) {
[10:27:20.617]                         computeRestarts <- base::computeRestarts
[10:27:20.617]                         grepl <- base::grepl
[10:27:20.617]                         restarts <- computeRestarts(cond)
[10:27:20.617]                         for (restart in restarts) {
[10:27:20.617]                           name <- restart$name
[10:27:20.617]                           if (is.null(name)) 
[10:27:20.617]                             next
[10:27:20.617]                           if (!grepl(pattern, name)) 
[10:27:20.617]                             next
[10:27:20.617]                           invokeRestart(restart)
[10:27:20.617]                           muffled <- TRUE
[10:27:20.617]                           break
[10:27:20.617]                         }
[10:27:20.617]                       }
[10:27:20.617]                     }
[10:27:20.617]                     invisible(muffled)
[10:27:20.617]                   }
[10:27:20.617]                   muffleCondition(cond)
[10:27:20.617]                 })
[10:27:20.617]             }))
[10:27:20.617]             future::FutureResult(value = ...future.value$value, 
[10:27:20.617]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:20.617]                   ...future.rng), globalenv = if (FALSE) 
[10:27:20.617]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:20.617]                     ...future.globalenv.names))
[10:27:20.617]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:20.617]         }, condition = base::local({
[10:27:20.617]             c <- base::c
[10:27:20.617]             inherits <- base::inherits
[10:27:20.617]             invokeRestart <- base::invokeRestart
[10:27:20.617]             length <- base::length
[10:27:20.617]             list <- base::list
[10:27:20.617]             seq.int <- base::seq.int
[10:27:20.617]             signalCondition <- base::signalCondition
[10:27:20.617]             sys.calls <- base::sys.calls
[10:27:20.617]             `[[` <- base::`[[`
[10:27:20.617]             `+` <- base::`+`
[10:27:20.617]             `<<-` <- base::`<<-`
[10:27:20.617]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:20.617]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:20.617]                   3L)]
[10:27:20.617]             }
[10:27:20.617]             function(cond) {
[10:27:20.617]                 is_error <- inherits(cond, "error")
[10:27:20.617]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:20.617]                   NULL)
[10:27:20.617]                 if (is_error) {
[10:27:20.617]                   sessionInformation <- function() {
[10:27:20.617]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:20.617]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:20.617]                       search = base::search(), system = base::Sys.info())
[10:27:20.617]                   }
[10:27:20.617]                   ...future.conditions[[length(...future.conditions) + 
[10:27:20.617]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:20.617]                     cond$call), session = sessionInformation(), 
[10:27:20.617]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:20.617]                   signalCondition(cond)
[10:27:20.617]                 }
[10:27:20.617]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:20.617]                 "immediateCondition"))) {
[10:27:20.617]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:20.617]                   ...future.conditions[[length(...future.conditions) + 
[10:27:20.617]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:20.617]                   if (TRUE && !signal) {
[10:27:20.617]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:20.617]                     {
[10:27:20.617]                       inherits <- base::inherits
[10:27:20.617]                       invokeRestart <- base::invokeRestart
[10:27:20.617]                       is.null <- base::is.null
[10:27:20.617]                       muffled <- FALSE
[10:27:20.617]                       if (inherits(cond, "message")) {
[10:27:20.617]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:20.617]                         if (muffled) 
[10:27:20.617]                           invokeRestart("muffleMessage")
[10:27:20.617]                       }
[10:27:20.617]                       else if (inherits(cond, "warning")) {
[10:27:20.617]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:20.617]                         if (muffled) 
[10:27:20.617]                           invokeRestart("muffleWarning")
[10:27:20.617]                       }
[10:27:20.617]                       else if (inherits(cond, "condition")) {
[10:27:20.617]                         if (!is.null(pattern)) {
[10:27:20.617]                           computeRestarts <- base::computeRestarts
[10:27:20.617]                           grepl <- base::grepl
[10:27:20.617]                           restarts <- computeRestarts(cond)
[10:27:20.617]                           for (restart in restarts) {
[10:27:20.617]                             name <- restart$name
[10:27:20.617]                             if (is.null(name)) 
[10:27:20.617]                               next
[10:27:20.617]                             if (!grepl(pattern, name)) 
[10:27:20.617]                               next
[10:27:20.617]                             invokeRestart(restart)
[10:27:20.617]                             muffled <- TRUE
[10:27:20.617]                             break
[10:27:20.617]                           }
[10:27:20.617]                         }
[10:27:20.617]                       }
[10:27:20.617]                       invisible(muffled)
[10:27:20.617]                     }
[10:27:20.617]                     muffleCondition(cond, pattern = "^muffle")
[10:27:20.617]                   }
[10:27:20.617]                 }
[10:27:20.617]                 else {
[10:27:20.617]                   if (TRUE) {
[10:27:20.617]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:20.617]                     {
[10:27:20.617]                       inherits <- base::inherits
[10:27:20.617]                       invokeRestart <- base::invokeRestart
[10:27:20.617]                       is.null <- base::is.null
[10:27:20.617]                       muffled <- FALSE
[10:27:20.617]                       if (inherits(cond, "message")) {
[10:27:20.617]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:20.617]                         if (muffled) 
[10:27:20.617]                           invokeRestart("muffleMessage")
[10:27:20.617]                       }
[10:27:20.617]                       else if (inherits(cond, "warning")) {
[10:27:20.617]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:20.617]                         if (muffled) 
[10:27:20.617]                           invokeRestart("muffleWarning")
[10:27:20.617]                       }
[10:27:20.617]                       else if (inherits(cond, "condition")) {
[10:27:20.617]                         if (!is.null(pattern)) {
[10:27:20.617]                           computeRestarts <- base::computeRestarts
[10:27:20.617]                           grepl <- base::grepl
[10:27:20.617]                           restarts <- computeRestarts(cond)
[10:27:20.617]                           for (restart in restarts) {
[10:27:20.617]                             name <- restart$name
[10:27:20.617]                             if (is.null(name)) 
[10:27:20.617]                               next
[10:27:20.617]                             if (!grepl(pattern, name)) 
[10:27:20.617]                               next
[10:27:20.617]                             invokeRestart(restart)
[10:27:20.617]                             muffled <- TRUE
[10:27:20.617]                             break
[10:27:20.617]                           }
[10:27:20.617]                         }
[10:27:20.617]                       }
[10:27:20.617]                       invisible(muffled)
[10:27:20.617]                     }
[10:27:20.617]                     muffleCondition(cond, pattern = "^muffle")
[10:27:20.617]                   }
[10:27:20.617]                 }
[10:27:20.617]             }
[10:27:20.617]         }))
[10:27:20.617]     }, error = function(ex) {
[10:27:20.617]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:20.617]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:20.617]                 ...future.rng), started = ...future.startTime, 
[10:27:20.617]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:20.617]             version = "1.8"), class = "FutureResult")
[10:27:20.617]     }, finally = {
[10:27:20.617]         if (!identical(...future.workdir, getwd())) 
[10:27:20.617]             setwd(...future.workdir)
[10:27:20.617]         {
[10:27:20.617]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:20.617]                 ...future.oldOptions$nwarnings <- NULL
[10:27:20.617]             }
[10:27:20.617]             base::options(...future.oldOptions)
[10:27:20.617]             if (.Platform$OS.type == "windows") {
[10:27:20.617]                 old_names <- names(...future.oldEnvVars)
[10:27:20.617]                 envs <- base::Sys.getenv()
[10:27:20.617]                 names <- names(envs)
[10:27:20.617]                 common <- intersect(names, old_names)
[10:27:20.617]                 added <- setdiff(names, old_names)
[10:27:20.617]                 removed <- setdiff(old_names, names)
[10:27:20.617]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:20.617]                   envs[common]]
[10:27:20.617]                 NAMES <- toupper(changed)
[10:27:20.617]                 args <- list()
[10:27:20.617]                 for (kk in seq_along(NAMES)) {
[10:27:20.617]                   name <- changed[[kk]]
[10:27:20.617]                   NAME <- NAMES[[kk]]
[10:27:20.617]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:20.617]                     next
[10:27:20.617]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:20.617]                 }
[10:27:20.617]                 NAMES <- toupper(added)
[10:27:20.617]                 for (kk in seq_along(NAMES)) {
[10:27:20.617]                   name <- added[[kk]]
[10:27:20.617]                   NAME <- NAMES[[kk]]
[10:27:20.617]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:20.617]                     next
[10:27:20.617]                   args[[name]] <- ""
[10:27:20.617]                 }
[10:27:20.617]                 NAMES <- toupper(removed)
[10:27:20.617]                 for (kk in seq_along(NAMES)) {
[10:27:20.617]                   name <- removed[[kk]]
[10:27:20.617]                   NAME <- NAMES[[kk]]
[10:27:20.617]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:20.617]                     next
[10:27:20.617]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:20.617]                 }
[10:27:20.617]                 if (length(args) > 0) 
[10:27:20.617]                   base::do.call(base::Sys.setenv, args = args)
[10:27:20.617]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:20.617]             }
[10:27:20.617]             else {
[10:27:20.617]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:20.617]             }
[10:27:20.617]             {
[10:27:20.617]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:20.617]                   0L) {
[10:27:20.617]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:20.617]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:20.617]                   base::options(opts)
[10:27:20.617]                 }
[10:27:20.617]                 {
[10:27:20.617]                   {
[10:27:20.617]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:20.617]                     NULL
[10:27:20.617]                   }
[10:27:20.617]                   options(future.plan = NULL)
[10:27:20.617]                   if (is.na(NA_character_)) 
[10:27:20.617]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:20.617]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:20.617]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:20.617]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:20.617]                     envir = parent.frame()) 
[10:27:20.617]                   {
[10:27:20.617]                     if (is.function(workers)) 
[10:27:20.617]                       workers <- workers()
[10:27:20.617]                     workers <- structure(as.integer(workers), 
[10:27:20.617]                       class = class(workers))
[10:27:20.617]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:20.617]                       workers >= 1)
[10:27:20.617]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:20.617]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:20.617]                     }
[10:27:20.617]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:20.617]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:20.617]                       envir = envir)
[10:27:20.617]                     if (!future$lazy) 
[10:27:20.617]                       future <- run(future)
[10:27:20.617]                     invisible(future)
[10:27:20.617]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:20.617]                 }
[10:27:20.617]             }
[10:27:20.617]         }
[10:27:20.617]     })
[10:27:20.617]     if (TRUE) {
[10:27:20.617]         base::sink(type = "output", split = FALSE)
[10:27:20.617]         if (TRUE) {
[10:27:20.617]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:20.617]         }
[10:27:20.617]         else {
[10:27:20.617]             ...future.result["stdout"] <- base::list(NULL)
[10:27:20.617]         }
[10:27:20.617]         base::close(...future.stdout)
[10:27:20.617]         ...future.stdout <- NULL
[10:27:20.617]     }
[10:27:20.617]     ...future.result$conditions <- ...future.conditions
[10:27:20.617]     ...future.result$finished <- base::Sys.time()
[10:27:20.617]     ...future.result
[10:27:20.617] }
[10:27:20.619] Poll #1 (0): usedNodes() = 2, workers = 2
[10:27:20.630] receiveMessageFromWorker() for ClusterFuture ...
[10:27:20.630] - Validating connection of MultisessionFuture
[10:27:20.630] - received message: FutureResult
[10:27:20.630] - Received FutureResult
[10:27:20.630] - Erased future from FutureRegistry
[10:27:20.631] result() for ClusterFuture ...
[10:27:20.631] - result already collected: FutureResult
[10:27:20.631] result() for ClusterFuture ... done
[10:27:20.631] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:20.631] result() for ClusterFuture ...
[10:27:20.631] - result already collected: FutureResult
[10:27:20.631] result() for ClusterFuture ... done
[10:27:20.631] result() for ClusterFuture ...
[10:27:20.631] - result already collected: FutureResult
[10:27:20.631] result() for ClusterFuture ... done
[10:27:20.633] MultisessionFuture started
[10:27:20.633] - Launch lazy future ... done
[10:27:20.633] run() for ‘MultisessionFuture’ ... done
[10:27:20.633] resolve() on list ...
[10:27:20.633]  recursive: 0
[10:27:20.633]  length: 3
[10:27:20.633]  elements: ‘a’, ‘b’, ‘’
[10:27:20.655]  length: 2 (resolved future 3)
[10:27:20.665] receiveMessageFromWorker() for ClusterFuture ...
[10:27:20.665] - Validating connection of MultisessionFuture
[10:27:20.666] - received message: FutureResult
[10:27:20.666] - Received FutureResult
[10:27:20.666] - Erased future from FutureRegistry
[10:27:20.666] result() for ClusterFuture ...
[10:27:20.666] - result already collected: FutureResult
[10:27:20.666] result() for ClusterFuture ... done
[10:27:20.666] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:20.666] Future #1
[10:27:20.666]  length: 1 (resolved future 1)
[10:27:20.688] receiveMessageFromWorker() for ClusterFuture ...
[10:27:20.688] - Validating connection of MultisessionFuture
[10:27:20.688] - received message: FutureResult
[10:27:20.688] - Received FutureResult
[10:27:20.688] - Erased future from FutureRegistry
[10:27:20.688] result() for ClusterFuture ...
[10:27:20.688] - result already collected: FutureResult
[10:27:20.689] result() for ClusterFuture ... done
[10:27:20.689] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:20.689] Future #2
[10:27:20.689]  length: 0 (resolved future 2)
[10:27:20.689] resolve() on list ... DONE
[10:27:20.689] getGlobalsAndPackages() ...
[10:27:20.689] Searching for globals...
[10:27:20.690] 
[10:27:20.690] Searching for globals ... DONE
[10:27:20.690] - globals: [0] <none>
[10:27:20.690] getGlobalsAndPackages() ... DONE
[10:27:20.690] getGlobalsAndPackages() ...
[10:27:20.690] Searching for globals...
[10:27:20.691] 
[10:27:20.691] Searching for globals ... DONE
[10:27:20.691] - globals: [0] <none>
[10:27:20.691] getGlobalsAndPackages() ... DONE
[10:27:20.691] run() for ‘Future’ ...
[10:27:20.691] - state: ‘created’
[10:27:20.691] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:20.705] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:20.705] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:20.706]   - Field: ‘node’
[10:27:20.706]   - Field: ‘label’
[10:27:20.706]   - Field: ‘local’
[10:27:20.706]   - Field: ‘owner’
[10:27:20.706]   - Field: ‘envir’
[10:27:20.706]   - Field: ‘workers’
[10:27:20.706]   - Field: ‘packages’
[10:27:20.706]   - Field: ‘gc’
[10:27:20.706]   - Field: ‘conditions’
[10:27:20.706]   - Field: ‘persistent’
[10:27:20.706]   - Field: ‘expr’
[10:27:20.707]   - Field: ‘uuid’
[10:27:20.707]   - Field: ‘seed’
[10:27:20.707]   - Field: ‘version’
[10:27:20.707]   - Field: ‘result’
[10:27:20.707]   - Field: ‘asynchronous’
[10:27:20.707]   - Field: ‘calls’
[10:27:20.707]   - Field: ‘globals’
[10:27:20.707]   - Field: ‘stdout’
[10:27:20.707]   - Field: ‘earlySignal’
[10:27:20.707]   - Field: ‘lazy’
[10:27:20.707]   - Field: ‘state’
[10:27:20.708] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:20.708] - Launch lazy future ...
[10:27:20.708] Packages needed by the future expression (n = 0): <none>
[10:27:20.708] Packages needed by future strategies (n = 0): <none>
[10:27:20.708] {
[10:27:20.708]     {
[10:27:20.708]         {
[10:27:20.708]             ...future.startTime <- base::Sys.time()
[10:27:20.708]             {
[10:27:20.708]                 {
[10:27:20.708]                   {
[10:27:20.708]                     {
[10:27:20.708]                       base::local({
[10:27:20.708]                         has_future <- base::requireNamespace("future", 
[10:27:20.708]                           quietly = TRUE)
[10:27:20.708]                         if (has_future) {
[10:27:20.708]                           ns <- base::getNamespace("future")
[10:27:20.708]                           version <- ns[[".package"]][["version"]]
[10:27:20.708]                           if (is.null(version)) 
[10:27:20.708]                             version <- utils::packageVersion("future")
[10:27:20.708]                         }
[10:27:20.708]                         else {
[10:27:20.708]                           version <- NULL
[10:27:20.708]                         }
[10:27:20.708]                         if (!has_future || version < "1.8.0") {
[10:27:20.708]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:20.708]                             "", base::R.version$version.string), 
[10:27:20.708]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:20.708]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:20.708]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:20.708]                               "release", "version")], collapse = " "), 
[10:27:20.708]                             hostname = base::Sys.info()[["nodename"]])
[10:27:20.708]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:20.708]                             info)
[10:27:20.708]                           info <- base::paste(info, collapse = "; ")
[10:27:20.708]                           if (!has_future) {
[10:27:20.708]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:20.708]                               info)
[10:27:20.708]                           }
[10:27:20.708]                           else {
[10:27:20.708]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:20.708]                               info, version)
[10:27:20.708]                           }
[10:27:20.708]                           base::stop(msg)
[10:27:20.708]                         }
[10:27:20.708]                       })
[10:27:20.708]                     }
[10:27:20.708]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:20.708]                     base::options(mc.cores = 1L)
[10:27:20.708]                   }
[10:27:20.708]                   options(future.plan = NULL)
[10:27:20.708]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:20.708]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:20.708]                 }
[10:27:20.708]                 ...future.workdir <- getwd()
[10:27:20.708]             }
[10:27:20.708]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:20.708]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:20.708]         }
[10:27:20.708]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:20.708]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:20.708]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:20.708]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:20.708]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:20.708]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:20.708]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:20.708]             base::names(...future.oldOptions))
[10:27:20.708]     }
[10:27:20.708]     if (FALSE) {
[10:27:20.708]     }
[10:27:20.708]     else {
[10:27:20.708]         if (TRUE) {
[10:27:20.708]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:20.708]                 open = "w")
[10:27:20.708]         }
[10:27:20.708]         else {
[10:27:20.708]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:20.708]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:20.708]         }
[10:27:20.708]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:20.708]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:20.708]             base::sink(type = "output", split = FALSE)
[10:27:20.708]             base::close(...future.stdout)
[10:27:20.708]         }, add = TRUE)
[10:27:20.708]     }
[10:27:20.708]     ...future.frame <- base::sys.nframe()
[10:27:20.708]     ...future.conditions <- base::list()
[10:27:20.708]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:20.708]     if (FALSE) {
[10:27:20.708]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:20.708]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:20.708]     }
[10:27:20.708]     ...future.result <- base::tryCatch({
[10:27:20.708]         base::withCallingHandlers({
[10:27:20.708]             ...future.value <- base::withVisible(base::local({
[10:27:20.708]                 ...future.makeSendCondition <- base::local({
[10:27:20.708]                   sendCondition <- NULL
[10:27:20.708]                   function(frame = 1L) {
[10:27:20.708]                     if (is.function(sendCondition)) 
[10:27:20.708]                       return(sendCondition)
[10:27:20.708]                     ns <- getNamespace("parallel")
[10:27:20.708]                     if (exists("sendData", mode = "function", 
[10:27:20.708]                       envir = ns)) {
[10:27:20.708]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:20.708]                         envir = ns)
[10:27:20.708]                       envir <- sys.frame(frame)
[10:27:20.708]                       master <- NULL
[10:27:20.708]                       while (!identical(envir, .GlobalEnv) && 
[10:27:20.708]                         !identical(envir, emptyenv())) {
[10:27:20.708]                         if (exists("master", mode = "list", envir = envir, 
[10:27:20.708]                           inherits = FALSE)) {
[10:27:20.708]                           master <- get("master", mode = "list", 
[10:27:20.708]                             envir = envir, inherits = FALSE)
[10:27:20.708]                           if (inherits(master, c("SOCKnode", 
[10:27:20.708]                             "SOCK0node"))) {
[10:27:20.708]                             sendCondition <<- function(cond) {
[10:27:20.708]                               data <- list(type = "VALUE", value = cond, 
[10:27:20.708]                                 success = TRUE)
[10:27:20.708]                               parallel_sendData(master, data)
[10:27:20.708]                             }
[10:27:20.708]                             return(sendCondition)
[10:27:20.708]                           }
[10:27:20.708]                         }
[10:27:20.708]                         frame <- frame + 1L
[10:27:20.708]                         envir <- sys.frame(frame)
[10:27:20.708]                       }
[10:27:20.708]                     }
[10:27:20.708]                     sendCondition <<- function(cond) NULL
[10:27:20.708]                   }
[10:27:20.708]                 })
[10:27:20.708]                 withCallingHandlers({
[10:27:20.708]                   2
[10:27:20.708]                 }, immediateCondition = function(cond) {
[10:27:20.708]                   sendCondition <- ...future.makeSendCondition()
[10:27:20.708]                   sendCondition(cond)
[10:27:20.708]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:20.708]                   {
[10:27:20.708]                     inherits <- base::inherits
[10:27:20.708]                     invokeRestart <- base::invokeRestart
[10:27:20.708]                     is.null <- base::is.null
[10:27:20.708]                     muffled <- FALSE
[10:27:20.708]                     if (inherits(cond, "message")) {
[10:27:20.708]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:20.708]                       if (muffled) 
[10:27:20.708]                         invokeRestart("muffleMessage")
[10:27:20.708]                     }
[10:27:20.708]                     else if (inherits(cond, "warning")) {
[10:27:20.708]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:20.708]                       if (muffled) 
[10:27:20.708]                         invokeRestart("muffleWarning")
[10:27:20.708]                     }
[10:27:20.708]                     else if (inherits(cond, "condition")) {
[10:27:20.708]                       if (!is.null(pattern)) {
[10:27:20.708]                         computeRestarts <- base::computeRestarts
[10:27:20.708]                         grepl <- base::grepl
[10:27:20.708]                         restarts <- computeRestarts(cond)
[10:27:20.708]                         for (restart in restarts) {
[10:27:20.708]                           name <- restart$name
[10:27:20.708]                           if (is.null(name)) 
[10:27:20.708]                             next
[10:27:20.708]                           if (!grepl(pattern, name)) 
[10:27:20.708]                             next
[10:27:20.708]                           invokeRestart(restart)
[10:27:20.708]                           muffled <- TRUE
[10:27:20.708]                           break
[10:27:20.708]                         }
[10:27:20.708]                       }
[10:27:20.708]                     }
[10:27:20.708]                     invisible(muffled)
[10:27:20.708]                   }
[10:27:20.708]                   muffleCondition(cond)
[10:27:20.708]                 })
[10:27:20.708]             }))
[10:27:20.708]             future::FutureResult(value = ...future.value$value, 
[10:27:20.708]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:20.708]                   ...future.rng), globalenv = if (FALSE) 
[10:27:20.708]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:20.708]                     ...future.globalenv.names))
[10:27:20.708]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:20.708]         }, condition = base::local({
[10:27:20.708]             c <- base::c
[10:27:20.708]             inherits <- base::inherits
[10:27:20.708]             invokeRestart <- base::invokeRestart
[10:27:20.708]             length <- base::length
[10:27:20.708]             list <- base::list
[10:27:20.708]             seq.int <- base::seq.int
[10:27:20.708]             signalCondition <- base::signalCondition
[10:27:20.708]             sys.calls <- base::sys.calls
[10:27:20.708]             `[[` <- base::`[[`
[10:27:20.708]             `+` <- base::`+`
[10:27:20.708]             `<<-` <- base::`<<-`
[10:27:20.708]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:20.708]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:20.708]                   3L)]
[10:27:20.708]             }
[10:27:20.708]             function(cond) {
[10:27:20.708]                 is_error <- inherits(cond, "error")
[10:27:20.708]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:20.708]                   NULL)
[10:27:20.708]                 if (is_error) {
[10:27:20.708]                   sessionInformation <- function() {
[10:27:20.708]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:20.708]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:20.708]                       search = base::search(), system = base::Sys.info())
[10:27:20.708]                   }
[10:27:20.708]                   ...future.conditions[[length(...future.conditions) + 
[10:27:20.708]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:20.708]                     cond$call), session = sessionInformation(), 
[10:27:20.708]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:20.708]                   signalCondition(cond)
[10:27:20.708]                 }
[10:27:20.708]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:20.708]                 "immediateCondition"))) {
[10:27:20.708]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:20.708]                   ...future.conditions[[length(...future.conditions) + 
[10:27:20.708]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:20.708]                   if (TRUE && !signal) {
[10:27:20.708]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:20.708]                     {
[10:27:20.708]                       inherits <- base::inherits
[10:27:20.708]                       invokeRestart <- base::invokeRestart
[10:27:20.708]                       is.null <- base::is.null
[10:27:20.708]                       muffled <- FALSE
[10:27:20.708]                       if (inherits(cond, "message")) {
[10:27:20.708]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:20.708]                         if (muffled) 
[10:27:20.708]                           invokeRestart("muffleMessage")
[10:27:20.708]                       }
[10:27:20.708]                       else if (inherits(cond, "warning")) {
[10:27:20.708]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:20.708]                         if (muffled) 
[10:27:20.708]                           invokeRestart("muffleWarning")
[10:27:20.708]                       }
[10:27:20.708]                       else if (inherits(cond, "condition")) {
[10:27:20.708]                         if (!is.null(pattern)) {
[10:27:20.708]                           computeRestarts <- base::computeRestarts
[10:27:20.708]                           grepl <- base::grepl
[10:27:20.708]                           restarts <- computeRestarts(cond)
[10:27:20.708]                           for (restart in restarts) {
[10:27:20.708]                             name <- restart$name
[10:27:20.708]                             if (is.null(name)) 
[10:27:20.708]                               next
[10:27:20.708]                             if (!grepl(pattern, name)) 
[10:27:20.708]                               next
[10:27:20.708]                             invokeRestart(restart)
[10:27:20.708]                             muffled <- TRUE
[10:27:20.708]                             break
[10:27:20.708]                           }
[10:27:20.708]                         }
[10:27:20.708]                       }
[10:27:20.708]                       invisible(muffled)
[10:27:20.708]                     }
[10:27:20.708]                     muffleCondition(cond, pattern = "^muffle")
[10:27:20.708]                   }
[10:27:20.708]                 }
[10:27:20.708]                 else {
[10:27:20.708]                   if (TRUE) {
[10:27:20.708]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:20.708]                     {
[10:27:20.708]                       inherits <- base::inherits
[10:27:20.708]                       invokeRestart <- base::invokeRestart
[10:27:20.708]                       is.null <- base::is.null
[10:27:20.708]                       muffled <- FALSE
[10:27:20.708]                       if (inherits(cond, "message")) {
[10:27:20.708]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:20.708]                         if (muffled) 
[10:27:20.708]                           invokeRestart("muffleMessage")
[10:27:20.708]                       }
[10:27:20.708]                       else if (inherits(cond, "warning")) {
[10:27:20.708]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:20.708]                         if (muffled) 
[10:27:20.708]                           invokeRestart("muffleWarning")
[10:27:20.708]                       }
[10:27:20.708]                       else if (inherits(cond, "condition")) {
[10:27:20.708]                         if (!is.null(pattern)) {
[10:27:20.708]                           computeRestarts <- base::computeRestarts
[10:27:20.708]                           grepl <- base::grepl
[10:27:20.708]                           restarts <- computeRestarts(cond)
[10:27:20.708]                           for (restart in restarts) {
[10:27:20.708]                             name <- restart$name
[10:27:20.708]                             if (is.null(name)) 
[10:27:20.708]                               next
[10:27:20.708]                             if (!grepl(pattern, name)) 
[10:27:20.708]                               next
[10:27:20.708]                             invokeRestart(restart)
[10:27:20.708]                             muffled <- TRUE
[10:27:20.708]                             break
[10:27:20.708]                           }
[10:27:20.708]                         }
[10:27:20.708]                       }
[10:27:20.708]                       invisible(muffled)
[10:27:20.708]                     }
[10:27:20.708]                     muffleCondition(cond, pattern = "^muffle")
[10:27:20.708]                   }
[10:27:20.708]                 }
[10:27:20.708]             }
[10:27:20.708]         }))
[10:27:20.708]     }, error = function(ex) {
[10:27:20.708]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:20.708]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:20.708]                 ...future.rng), started = ...future.startTime, 
[10:27:20.708]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:20.708]             version = "1.8"), class = "FutureResult")
[10:27:20.708]     }, finally = {
[10:27:20.708]         if (!identical(...future.workdir, getwd())) 
[10:27:20.708]             setwd(...future.workdir)
[10:27:20.708]         {
[10:27:20.708]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:20.708]                 ...future.oldOptions$nwarnings <- NULL
[10:27:20.708]             }
[10:27:20.708]             base::options(...future.oldOptions)
[10:27:20.708]             if (.Platform$OS.type == "windows") {
[10:27:20.708]                 old_names <- names(...future.oldEnvVars)
[10:27:20.708]                 envs <- base::Sys.getenv()
[10:27:20.708]                 names <- names(envs)
[10:27:20.708]                 common <- intersect(names, old_names)
[10:27:20.708]                 added <- setdiff(names, old_names)
[10:27:20.708]                 removed <- setdiff(old_names, names)
[10:27:20.708]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:20.708]                   envs[common]]
[10:27:20.708]                 NAMES <- toupper(changed)
[10:27:20.708]                 args <- list()
[10:27:20.708]                 for (kk in seq_along(NAMES)) {
[10:27:20.708]                   name <- changed[[kk]]
[10:27:20.708]                   NAME <- NAMES[[kk]]
[10:27:20.708]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:20.708]                     next
[10:27:20.708]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:20.708]                 }
[10:27:20.708]                 NAMES <- toupper(added)
[10:27:20.708]                 for (kk in seq_along(NAMES)) {
[10:27:20.708]                   name <- added[[kk]]
[10:27:20.708]                   NAME <- NAMES[[kk]]
[10:27:20.708]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:20.708]                     next
[10:27:20.708]                   args[[name]] <- ""
[10:27:20.708]                 }
[10:27:20.708]                 NAMES <- toupper(removed)
[10:27:20.708]                 for (kk in seq_along(NAMES)) {
[10:27:20.708]                   name <- removed[[kk]]
[10:27:20.708]                   NAME <- NAMES[[kk]]
[10:27:20.708]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:20.708]                     next
[10:27:20.708]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:20.708]                 }
[10:27:20.708]                 if (length(args) > 0) 
[10:27:20.708]                   base::do.call(base::Sys.setenv, args = args)
[10:27:20.708]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:20.708]             }
[10:27:20.708]             else {
[10:27:20.708]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:20.708]             }
[10:27:20.708]             {
[10:27:20.708]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:20.708]                   0L) {
[10:27:20.708]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:20.708]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:20.708]                   base::options(opts)
[10:27:20.708]                 }
[10:27:20.708]                 {
[10:27:20.708]                   {
[10:27:20.708]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:20.708]                     NULL
[10:27:20.708]                   }
[10:27:20.708]                   options(future.plan = NULL)
[10:27:20.708]                   if (is.na(NA_character_)) 
[10:27:20.708]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:20.708]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:20.708]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:20.708]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:20.708]                     envir = parent.frame()) 
[10:27:20.708]                   {
[10:27:20.708]                     if (is.function(workers)) 
[10:27:20.708]                       workers <- workers()
[10:27:20.708]                     workers <- structure(as.integer(workers), 
[10:27:20.708]                       class = class(workers))
[10:27:20.708]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:20.708]                       workers >= 1)
[10:27:20.708]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:20.708]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:20.708]                     }
[10:27:20.708]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:20.708]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:20.708]                       envir = envir)
[10:27:20.708]                     if (!future$lazy) 
[10:27:20.708]                       future <- run(future)
[10:27:20.708]                     invisible(future)
[10:27:20.708]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:20.708]                 }
[10:27:20.708]             }
[10:27:20.708]         }
[10:27:20.708]     })
[10:27:20.708]     if (TRUE) {
[10:27:20.708]         base::sink(type = "output", split = FALSE)
[10:27:20.708]         if (TRUE) {
[10:27:20.708]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:20.708]         }
[10:27:20.708]         else {
[10:27:20.708]             ...future.result["stdout"] <- base::list(NULL)
[10:27:20.708]         }
[10:27:20.708]         base::close(...future.stdout)
[10:27:20.708]         ...future.stdout <- NULL
[10:27:20.708]     }
[10:27:20.708]     ...future.result$conditions <- ...future.conditions
[10:27:20.708]     ...future.result$finished <- base::Sys.time()
[10:27:20.708]     ...future.result
[10:27:20.708] }
[10:27:20.712] MultisessionFuture started
[10:27:20.712] - Launch lazy future ... done
[10:27:20.712] run() for ‘MultisessionFuture’ ... done
[10:27:20.712] resolve() on list ...
[10:27:20.712]  recursive: 0
[10:27:20.712]  length: 3
[10:27:20.712]  elements: ‘a’, ‘b’, ‘’
[10:27:20.713] run() for ‘Future’ ...
[10:27:20.713] - state: ‘created’
[10:27:20.713] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:20.727] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:20.727] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:20.727]   - Field: ‘node’
[10:27:20.727]   - Field: ‘label’
[10:27:20.727]   - Field: ‘local’
[10:27:20.728]   - Field: ‘owner’
[10:27:20.728]   - Field: ‘envir’
[10:27:20.728]   - Field: ‘workers’
[10:27:20.728]   - Field: ‘packages’
[10:27:20.728]   - Field: ‘gc’
[10:27:20.728]   - Field: ‘conditions’
[10:27:20.728]   - Field: ‘persistent’
[10:27:20.728]   - Field: ‘expr’
[10:27:20.728]   - Field: ‘uuid’
[10:27:20.728]   - Field: ‘seed’
[10:27:20.729]   - Field: ‘version’
[10:27:20.729]   - Field: ‘result’
[10:27:20.729]   - Field: ‘asynchronous’
[10:27:20.729]   - Field: ‘calls’
[10:27:20.729]   - Field: ‘globals’
[10:27:20.729]   - Field: ‘stdout’
[10:27:20.729]   - Field: ‘earlySignal’
[10:27:20.729]   - Field: ‘lazy’
[10:27:20.729]   - Field: ‘state’
[10:27:20.729] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:20.729] - Launch lazy future ...
[10:27:20.730] Packages needed by the future expression (n = 0): <none>
[10:27:20.730] Packages needed by future strategies (n = 0): <none>
[10:27:20.730] {
[10:27:20.730]     {
[10:27:20.730]         {
[10:27:20.730]             ...future.startTime <- base::Sys.time()
[10:27:20.730]             {
[10:27:20.730]                 {
[10:27:20.730]                   {
[10:27:20.730]                     {
[10:27:20.730]                       base::local({
[10:27:20.730]                         has_future <- base::requireNamespace("future", 
[10:27:20.730]                           quietly = TRUE)
[10:27:20.730]                         if (has_future) {
[10:27:20.730]                           ns <- base::getNamespace("future")
[10:27:20.730]                           version <- ns[[".package"]][["version"]]
[10:27:20.730]                           if (is.null(version)) 
[10:27:20.730]                             version <- utils::packageVersion("future")
[10:27:20.730]                         }
[10:27:20.730]                         else {
[10:27:20.730]                           version <- NULL
[10:27:20.730]                         }
[10:27:20.730]                         if (!has_future || version < "1.8.0") {
[10:27:20.730]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:20.730]                             "", base::R.version$version.string), 
[10:27:20.730]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:20.730]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:20.730]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:20.730]                               "release", "version")], collapse = " "), 
[10:27:20.730]                             hostname = base::Sys.info()[["nodename"]])
[10:27:20.730]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:20.730]                             info)
[10:27:20.730]                           info <- base::paste(info, collapse = "; ")
[10:27:20.730]                           if (!has_future) {
[10:27:20.730]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:20.730]                               info)
[10:27:20.730]                           }
[10:27:20.730]                           else {
[10:27:20.730]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:20.730]                               info, version)
[10:27:20.730]                           }
[10:27:20.730]                           base::stop(msg)
[10:27:20.730]                         }
[10:27:20.730]                       })
[10:27:20.730]                     }
[10:27:20.730]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:20.730]                     base::options(mc.cores = 1L)
[10:27:20.730]                   }
[10:27:20.730]                   options(future.plan = NULL)
[10:27:20.730]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:20.730]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:20.730]                 }
[10:27:20.730]                 ...future.workdir <- getwd()
[10:27:20.730]             }
[10:27:20.730]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:20.730]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:20.730]         }
[10:27:20.730]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:20.730]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:20.730]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:20.730]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:20.730]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:20.730]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:20.730]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:20.730]             base::names(...future.oldOptions))
[10:27:20.730]     }
[10:27:20.730]     if (FALSE) {
[10:27:20.730]     }
[10:27:20.730]     else {
[10:27:20.730]         if (TRUE) {
[10:27:20.730]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:20.730]                 open = "w")
[10:27:20.730]         }
[10:27:20.730]         else {
[10:27:20.730]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:20.730]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:20.730]         }
[10:27:20.730]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:20.730]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:20.730]             base::sink(type = "output", split = FALSE)
[10:27:20.730]             base::close(...future.stdout)
[10:27:20.730]         }, add = TRUE)
[10:27:20.730]     }
[10:27:20.730]     ...future.frame <- base::sys.nframe()
[10:27:20.730]     ...future.conditions <- base::list()
[10:27:20.730]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:20.730]     if (FALSE) {
[10:27:20.730]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:20.730]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:20.730]     }
[10:27:20.730]     ...future.result <- base::tryCatch({
[10:27:20.730]         base::withCallingHandlers({
[10:27:20.730]             ...future.value <- base::withVisible(base::local({
[10:27:20.730]                 ...future.makeSendCondition <- base::local({
[10:27:20.730]                   sendCondition <- NULL
[10:27:20.730]                   function(frame = 1L) {
[10:27:20.730]                     if (is.function(sendCondition)) 
[10:27:20.730]                       return(sendCondition)
[10:27:20.730]                     ns <- getNamespace("parallel")
[10:27:20.730]                     if (exists("sendData", mode = "function", 
[10:27:20.730]                       envir = ns)) {
[10:27:20.730]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:20.730]                         envir = ns)
[10:27:20.730]                       envir <- sys.frame(frame)
[10:27:20.730]                       master <- NULL
[10:27:20.730]                       while (!identical(envir, .GlobalEnv) && 
[10:27:20.730]                         !identical(envir, emptyenv())) {
[10:27:20.730]                         if (exists("master", mode = "list", envir = envir, 
[10:27:20.730]                           inherits = FALSE)) {
[10:27:20.730]                           master <- get("master", mode = "list", 
[10:27:20.730]                             envir = envir, inherits = FALSE)
[10:27:20.730]                           if (inherits(master, c("SOCKnode", 
[10:27:20.730]                             "SOCK0node"))) {
[10:27:20.730]                             sendCondition <<- function(cond) {
[10:27:20.730]                               data <- list(type = "VALUE", value = cond, 
[10:27:20.730]                                 success = TRUE)
[10:27:20.730]                               parallel_sendData(master, data)
[10:27:20.730]                             }
[10:27:20.730]                             return(sendCondition)
[10:27:20.730]                           }
[10:27:20.730]                         }
[10:27:20.730]                         frame <- frame + 1L
[10:27:20.730]                         envir <- sys.frame(frame)
[10:27:20.730]                       }
[10:27:20.730]                     }
[10:27:20.730]                     sendCondition <<- function(cond) NULL
[10:27:20.730]                   }
[10:27:20.730]                 })
[10:27:20.730]                 withCallingHandlers({
[10:27:20.730]                   1
[10:27:20.730]                 }, immediateCondition = function(cond) {
[10:27:20.730]                   sendCondition <- ...future.makeSendCondition()
[10:27:20.730]                   sendCondition(cond)
[10:27:20.730]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:20.730]                   {
[10:27:20.730]                     inherits <- base::inherits
[10:27:20.730]                     invokeRestart <- base::invokeRestart
[10:27:20.730]                     is.null <- base::is.null
[10:27:20.730]                     muffled <- FALSE
[10:27:20.730]                     if (inherits(cond, "message")) {
[10:27:20.730]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:20.730]                       if (muffled) 
[10:27:20.730]                         invokeRestart("muffleMessage")
[10:27:20.730]                     }
[10:27:20.730]                     else if (inherits(cond, "warning")) {
[10:27:20.730]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:20.730]                       if (muffled) 
[10:27:20.730]                         invokeRestart("muffleWarning")
[10:27:20.730]                     }
[10:27:20.730]                     else if (inherits(cond, "condition")) {
[10:27:20.730]                       if (!is.null(pattern)) {
[10:27:20.730]                         computeRestarts <- base::computeRestarts
[10:27:20.730]                         grepl <- base::grepl
[10:27:20.730]                         restarts <- computeRestarts(cond)
[10:27:20.730]                         for (restart in restarts) {
[10:27:20.730]                           name <- restart$name
[10:27:20.730]                           if (is.null(name)) 
[10:27:20.730]                             next
[10:27:20.730]                           if (!grepl(pattern, name)) 
[10:27:20.730]                             next
[10:27:20.730]                           invokeRestart(restart)
[10:27:20.730]                           muffled <- TRUE
[10:27:20.730]                           break
[10:27:20.730]                         }
[10:27:20.730]                       }
[10:27:20.730]                     }
[10:27:20.730]                     invisible(muffled)
[10:27:20.730]                   }
[10:27:20.730]                   muffleCondition(cond)
[10:27:20.730]                 })
[10:27:20.730]             }))
[10:27:20.730]             future::FutureResult(value = ...future.value$value, 
[10:27:20.730]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:20.730]                   ...future.rng), globalenv = if (FALSE) 
[10:27:20.730]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:20.730]                     ...future.globalenv.names))
[10:27:20.730]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:20.730]         }, condition = base::local({
[10:27:20.730]             c <- base::c
[10:27:20.730]             inherits <- base::inherits
[10:27:20.730]             invokeRestart <- base::invokeRestart
[10:27:20.730]             length <- base::length
[10:27:20.730]             list <- base::list
[10:27:20.730]             seq.int <- base::seq.int
[10:27:20.730]             signalCondition <- base::signalCondition
[10:27:20.730]             sys.calls <- base::sys.calls
[10:27:20.730]             `[[` <- base::`[[`
[10:27:20.730]             `+` <- base::`+`
[10:27:20.730]             `<<-` <- base::`<<-`
[10:27:20.730]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:20.730]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:20.730]                   3L)]
[10:27:20.730]             }
[10:27:20.730]             function(cond) {
[10:27:20.730]                 is_error <- inherits(cond, "error")
[10:27:20.730]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:20.730]                   NULL)
[10:27:20.730]                 if (is_error) {
[10:27:20.730]                   sessionInformation <- function() {
[10:27:20.730]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:20.730]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:20.730]                       search = base::search(), system = base::Sys.info())
[10:27:20.730]                   }
[10:27:20.730]                   ...future.conditions[[length(...future.conditions) + 
[10:27:20.730]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:20.730]                     cond$call), session = sessionInformation(), 
[10:27:20.730]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:20.730]                   signalCondition(cond)
[10:27:20.730]                 }
[10:27:20.730]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:20.730]                 "immediateCondition"))) {
[10:27:20.730]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:20.730]                   ...future.conditions[[length(...future.conditions) + 
[10:27:20.730]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:20.730]                   if (TRUE && !signal) {
[10:27:20.730]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:20.730]                     {
[10:27:20.730]                       inherits <- base::inherits
[10:27:20.730]                       invokeRestart <- base::invokeRestart
[10:27:20.730]                       is.null <- base::is.null
[10:27:20.730]                       muffled <- FALSE
[10:27:20.730]                       if (inherits(cond, "message")) {
[10:27:20.730]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:20.730]                         if (muffled) 
[10:27:20.730]                           invokeRestart("muffleMessage")
[10:27:20.730]                       }
[10:27:20.730]                       else if (inherits(cond, "warning")) {
[10:27:20.730]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:20.730]                         if (muffled) 
[10:27:20.730]                           invokeRestart("muffleWarning")
[10:27:20.730]                       }
[10:27:20.730]                       else if (inherits(cond, "condition")) {
[10:27:20.730]                         if (!is.null(pattern)) {
[10:27:20.730]                           computeRestarts <- base::computeRestarts
[10:27:20.730]                           grepl <- base::grepl
[10:27:20.730]                           restarts <- computeRestarts(cond)
[10:27:20.730]                           for (restart in restarts) {
[10:27:20.730]                             name <- restart$name
[10:27:20.730]                             if (is.null(name)) 
[10:27:20.730]                               next
[10:27:20.730]                             if (!grepl(pattern, name)) 
[10:27:20.730]                               next
[10:27:20.730]                             invokeRestart(restart)
[10:27:20.730]                             muffled <- TRUE
[10:27:20.730]                             break
[10:27:20.730]                           }
[10:27:20.730]                         }
[10:27:20.730]                       }
[10:27:20.730]                       invisible(muffled)
[10:27:20.730]                     }
[10:27:20.730]                     muffleCondition(cond, pattern = "^muffle")
[10:27:20.730]                   }
[10:27:20.730]                 }
[10:27:20.730]                 else {
[10:27:20.730]                   if (TRUE) {
[10:27:20.730]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:20.730]                     {
[10:27:20.730]                       inherits <- base::inherits
[10:27:20.730]                       invokeRestart <- base::invokeRestart
[10:27:20.730]                       is.null <- base::is.null
[10:27:20.730]                       muffled <- FALSE
[10:27:20.730]                       if (inherits(cond, "message")) {
[10:27:20.730]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:20.730]                         if (muffled) 
[10:27:20.730]                           invokeRestart("muffleMessage")
[10:27:20.730]                       }
[10:27:20.730]                       else if (inherits(cond, "warning")) {
[10:27:20.730]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:20.730]                         if (muffled) 
[10:27:20.730]                           invokeRestart("muffleWarning")
[10:27:20.730]                       }
[10:27:20.730]                       else if (inherits(cond, "condition")) {
[10:27:20.730]                         if (!is.null(pattern)) {
[10:27:20.730]                           computeRestarts <- base::computeRestarts
[10:27:20.730]                           grepl <- base::grepl
[10:27:20.730]                           restarts <- computeRestarts(cond)
[10:27:20.730]                           for (restart in restarts) {
[10:27:20.730]                             name <- restart$name
[10:27:20.730]                             if (is.null(name)) 
[10:27:20.730]                               next
[10:27:20.730]                             if (!grepl(pattern, name)) 
[10:27:20.730]                               next
[10:27:20.730]                             invokeRestart(restart)
[10:27:20.730]                             muffled <- TRUE
[10:27:20.730]                             break
[10:27:20.730]                           }
[10:27:20.730]                         }
[10:27:20.730]                       }
[10:27:20.730]                       invisible(muffled)
[10:27:20.730]                     }
[10:27:20.730]                     muffleCondition(cond, pattern = "^muffle")
[10:27:20.730]                   }
[10:27:20.730]                 }
[10:27:20.730]             }
[10:27:20.730]         }))
[10:27:20.730]     }, error = function(ex) {
[10:27:20.730]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:20.730]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:20.730]                 ...future.rng), started = ...future.startTime, 
[10:27:20.730]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:20.730]             version = "1.8"), class = "FutureResult")
[10:27:20.730]     }, finally = {
[10:27:20.730]         if (!identical(...future.workdir, getwd())) 
[10:27:20.730]             setwd(...future.workdir)
[10:27:20.730]         {
[10:27:20.730]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:20.730]                 ...future.oldOptions$nwarnings <- NULL
[10:27:20.730]             }
[10:27:20.730]             base::options(...future.oldOptions)
[10:27:20.730]             if (.Platform$OS.type == "windows") {
[10:27:20.730]                 old_names <- names(...future.oldEnvVars)
[10:27:20.730]                 envs <- base::Sys.getenv()
[10:27:20.730]                 names <- names(envs)
[10:27:20.730]                 common <- intersect(names, old_names)
[10:27:20.730]                 added <- setdiff(names, old_names)
[10:27:20.730]                 removed <- setdiff(old_names, names)
[10:27:20.730]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:20.730]                   envs[common]]
[10:27:20.730]                 NAMES <- toupper(changed)
[10:27:20.730]                 args <- list()
[10:27:20.730]                 for (kk in seq_along(NAMES)) {
[10:27:20.730]                   name <- changed[[kk]]
[10:27:20.730]                   NAME <- NAMES[[kk]]
[10:27:20.730]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:20.730]                     next
[10:27:20.730]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:20.730]                 }
[10:27:20.730]                 NAMES <- toupper(added)
[10:27:20.730]                 for (kk in seq_along(NAMES)) {
[10:27:20.730]                   name <- added[[kk]]
[10:27:20.730]                   NAME <- NAMES[[kk]]
[10:27:20.730]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:20.730]                     next
[10:27:20.730]                   args[[name]] <- ""
[10:27:20.730]                 }
[10:27:20.730]                 NAMES <- toupper(removed)
[10:27:20.730]                 for (kk in seq_along(NAMES)) {
[10:27:20.730]                   name <- removed[[kk]]
[10:27:20.730]                   NAME <- NAMES[[kk]]
[10:27:20.730]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:20.730]                     next
[10:27:20.730]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:20.730]                 }
[10:27:20.730]                 if (length(args) > 0) 
[10:27:20.730]                   base::do.call(base::Sys.setenv, args = args)
[10:27:20.730]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:20.730]             }
[10:27:20.730]             else {
[10:27:20.730]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:20.730]             }
[10:27:20.730]             {
[10:27:20.730]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:20.730]                   0L) {
[10:27:20.730]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:20.730]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:20.730]                   base::options(opts)
[10:27:20.730]                 }
[10:27:20.730]                 {
[10:27:20.730]                   {
[10:27:20.730]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:20.730]                     NULL
[10:27:20.730]                   }
[10:27:20.730]                   options(future.plan = NULL)
[10:27:20.730]                   if (is.na(NA_character_)) 
[10:27:20.730]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:20.730]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:20.730]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:20.730]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:20.730]                     envir = parent.frame()) 
[10:27:20.730]                   {
[10:27:20.730]                     if (is.function(workers)) 
[10:27:20.730]                       workers <- workers()
[10:27:20.730]                     workers <- structure(as.integer(workers), 
[10:27:20.730]                       class = class(workers))
[10:27:20.730]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:20.730]                       workers >= 1)
[10:27:20.730]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:20.730]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:20.730]                     }
[10:27:20.730]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:20.730]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:20.730]                       envir = envir)
[10:27:20.730]                     if (!future$lazy) 
[10:27:20.730]                       future <- run(future)
[10:27:20.730]                     invisible(future)
[10:27:20.730]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:20.730]                 }
[10:27:20.730]             }
[10:27:20.730]         }
[10:27:20.730]     })
[10:27:20.730]     if (TRUE) {
[10:27:20.730]         base::sink(type = "output", split = FALSE)
[10:27:20.730]         if (TRUE) {
[10:27:20.730]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:20.730]         }
[10:27:20.730]         else {
[10:27:20.730]             ...future.result["stdout"] <- base::list(NULL)
[10:27:20.730]         }
[10:27:20.730]         base::close(...future.stdout)
[10:27:20.730]         ...future.stdout <- NULL
[10:27:20.730]     }
[10:27:20.730]     ...future.result$conditions <- ...future.conditions
[10:27:20.730]     ...future.result$finished <- base::Sys.time()
[10:27:20.730]     ...future.result
[10:27:20.730] }
[10:27:20.734] MultisessionFuture started
[10:27:20.734] - Launch lazy future ... done
[10:27:20.734] run() for ‘MultisessionFuture’ ... done
[10:27:20.755]  length: 2 (resolved future 3)
[10:27:20.776] receiveMessageFromWorker() for ClusterFuture ...
[10:27:20.777] - Validating connection of MultisessionFuture
[10:27:20.777] - received message: FutureResult
[10:27:20.777] - Received FutureResult
[10:27:20.777] - Erased future from FutureRegistry
[10:27:20.777] result() for ClusterFuture ...
[10:27:20.777] - result already collected: FutureResult
[10:27:20.778] result() for ClusterFuture ... done
[10:27:20.778] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:20.778] Future #2
[10:27:20.778]  length: 1 (resolved future 2)
[10:27:20.789] receiveMessageFromWorker() for ClusterFuture ...
[10:27:20.789] - Validating connection of MultisessionFuture
[10:27:20.789] - received message: FutureResult
[10:27:20.789] - Received FutureResult
[10:27:20.789] - Erased future from FutureRegistry
[10:27:20.789] result() for ClusterFuture ...
[10:27:20.789] - result already collected: FutureResult
[10:27:20.790] result() for ClusterFuture ... done
[10:27:20.790] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:20.790] Future #1
[10:27:20.790]  length: 0 (resolved future 1)
[10:27:20.790] resolve() on list ... DONE
[10:27:20.790] getGlobalsAndPackages() ...
[10:27:20.790] Searching for globals...
[10:27:20.791] 
[10:27:20.791] Searching for globals ... DONE
[10:27:20.791] - globals: [0] <none>
[10:27:20.791] getGlobalsAndPackages() ... DONE
[10:27:20.791] getGlobalsAndPackages() ...
[10:27:20.791] Searching for globals...
[10:27:20.791] 
[10:27:20.792] Searching for globals ... DONE
[10:27:20.792] - globals: [0] <none>
[10:27:20.792] getGlobalsAndPackages() ... DONE
[10:27:20.792] resolve() on list ...
[10:27:20.792]  recursive: 0
[10:27:20.792]  length: 3
[10:27:20.792]  elements: ‘a’, ‘b’, ‘’
[10:27:20.792] run() for ‘Future’ ...
[10:27:20.792] - state: ‘created’
[10:27:20.795] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:20.813] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:20.813] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:20.813]   - Field: ‘node’
[10:27:20.813]   - Field: ‘label’
[10:27:20.813]   - Field: ‘local’
[10:27:20.814]   - Field: ‘owner’
[10:27:20.814]   - Field: ‘envir’
[10:27:20.814]   - Field: ‘workers’
[10:27:20.814]   - Field: ‘packages’
[10:27:20.814]   - Field: ‘gc’
[10:27:20.814]   - Field: ‘conditions’
[10:27:20.814]   - Field: ‘persistent’
[10:27:20.814]   - Field: ‘expr’
[10:27:20.814]   - Field: ‘uuid’
[10:27:20.814]   - Field: ‘seed’
[10:27:20.814]   - Field: ‘version’
[10:27:20.815]   - Field: ‘result’
[10:27:20.815]   - Field: ‘asynchronous’
[10:27:20.815]   - Field: ‘calls’
[10:27:20.815]   - Field: ‘globals’
[10:27:20.815]   - Field: ‘stdout’
[10:27:20.815]   - Field: ‘earlySignal’
[10:27:20.815]   - Field: ‘lazy’
[10:27:20.815]   - Field: ‘state’
[10:27:20.815] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:20.815] - Launch lazy future ...
[10:27:20.816] Packages needed by the future expression (n = 0): <none>
[10:27:20.816] Packages needed by future strategies (n = 0): <none>
[10:27:20.816] {
[10:27:20.816]     {
[10:27:20.816]         {
[10:27:20.816]             ...future.startTime <- base::Sys.time()
[10:27:20.816]             {
[10:27:20.816]                 {
[10:27:20.816]                   {
[10:27:20.816]                     {
[10:27:20.816]                       base::local({
[10:27:20.816]                         has_future <- base::requireNamespace("future", 
[10:27:20.816]                           quietly = TRUE)
[10:27:20.816]                         if (has_future) {
[10:27:20.816]                           ns <- base::getNamespace("future")
[10:27:20.816]                           version <- ns[[".package"]][["version"]]
[10:27:20.816]                           if (is.null(version)) 
[10:27:20.816]                             version <- utils::packageVersion("future")
[10:27:20.816]                         }
[10:27:20.816]                         else {
[10:27:20.816]                           version <- NULL
[10:27:20.816]                         }
[10:27:20.816]                         if (!has_future || version < "1.8.0") {
[10:27:20.816]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:20.816]                             "", base::R.version$version.string), 
[10:27:20.816]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:20.816]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:20.816]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:20.816]                               "release", "version")], collapse = " "), 
[10:27:20.816]                             hostname = base::Sys.info()[["nodename"]])
[10:27:20.816]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:20.816]                             info)
[10:27:20.816]                           info <- base::paste(info, collapse = "; ")
[10:27:20.816]                           if (!has_future) {
[10:27:20.816]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:20.816]                               info)
[10:27:20.816]                           }
[10:27:20.816]                           else {
[10:27:20.816]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:20.816]                               info, version)
[10:27:20.816]                           }
[10:27:20.816]                           base::stop(msg)
[10:27:20.816]                         }
[10:27:20.816]                       })
[10:27:20.816]                     }
[10:27:20.816]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:20.816]                     base::options(mc.cores = 1L)
[10:27:20.816]                   }
[10:27:20.816]                   options(future.plan = NULL)
[10:27:20.816]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:20.816]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:20.816]                 }
[10:27:20.816]                 ...future.workdir <- getwd()
[10:27:20.816]             }
[10:27:20.816]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:20.816]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:20.816]         }
[10:27:20.816]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:20.816]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:20.816]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:20.816]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:20.816]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:20.816]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:20.816]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:20.816]             base::names(...future.oldOptions))
[10:27:20.816]     }
[10:27:20.816]     if (FALSE) {
[10:27:20.816]     }
[10:27:20.816]     else {
[10:27:20.816]         if (TRUE) {
[10:27:20.816]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:20.816]                 open = "w")
[10:27:20.816]         }
[10:27:20.816]         else {
[10:27:20.816]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:20.816]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:20.816]         }
[10:27:20.816]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:20.816]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:20.816]             base::sink(type = "output", split = FALSE)
[10:27:20.816]             base::close(...future.stdout)
[10:27:20.816]         }, add = TRUE)
[10:27:20.816]     }
[10:27:20.816]     ...future.frame <- base::sys.nframe()
[10:27:20.816]     ...future.conditions <- base::list()
[10:27:20.816]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:20.816]     if (FALSE) {
[10:27:20.816]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:20.816]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:20.816]     }
[10:27:20.816]     ...future.result <- base::tryCatch({
[10:27:20.816]         base::withCallingHandlers({
[10:27:20.816]             ...future.value <- base::withVisible(base::local({
[10:27:20.816]                 ...future.makeSendCondition <- base::local({
[10:27:20.816]                   sendCondition <- NULL
[10:27:20.816]                   function(frame = 1L) {
[10:27:20.816]                     if (is.function(sendCondition)) 
[10:27:20.816]                       return(sendCondition)
[10:27:20.816]                     ns <- getNamespace("parallel")
[10:27:20.816]                     if (exists("sendData", mode = "function", 
[10:27:20.816]                       envir = ns)) {
[10:27:20.816]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:20.816]                         envir = ns)
[10:27:20.816]                       envir <- sys.frame(frame)
[10:27:20.816]                       master <- NULL
[10:27:20.816]                       while (!identical(envir, .GlobalEnv) && 
[10:27:20.816]                         !identical(envir, emptyenv())) {
[10:27:20.816]                         if (exists("master", mode = "list", envir = envir, 
[10:27:20.816]                           inherits = FALSE)) {
[10:27:20.816]                           master <- get("master", mode = "list", 
[10:27:20.816]                             envir = envir, inherits = FALSE)
[10:27:20.816]                           if (inherits(master, c("SOCKnode", 
[10:27:20.816]                             "SOCK0node"))) {
[10:27:20.816]                             sendCondition <<- function(cond) {
[10:27:20.816]                               data <- list(type = "VALUE", value = cond, 
[10:27:20.816]                                 success = TRUE)
[10:27:20.816]                               parallel_sendData(master, data)
[10:27:20.816]                             }
[10:27:20.816]                             return(sendCondition)
[10:27:20.816]                           }
[10:27:20.816]                         }
[10:27:20.816]                         frame <- frame + 1L
[10:27:20.816]                         envir <- sys.frame(frame)
[10:27:20.816]                       }
[10:27:20.816]                     }
[10:27:20.816]                     sendCondition <<- function(cond) NULL
[10:27:20.816]                   }
[10:27:20.816]                 })
[10:27:20.816]                 withCallingHandlers({
[10:27:20.816]                   1
[10:27:20.816]                 }, immediateCondition = function(cond) {
[10:27:20.816]                   sendCondition <- ...future.makeSendCondition()
[10:27:20.816]                   sendCondition(cond)
[10:27:20.816]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:20.816]                   {
[10:27:20.816]                     inherits <- base::inherits
[10:27:20.816]                     invokeRestart <- base::invokeRestart
[10:27:20.816]                     is.null <- base::is.null
[10:27:20.816]                     muffled <- FALSE
[10:27:20.816]                     if (inherits(cond, "message")) {
[10:27:20.816]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:20.816]                       if (muffled) 
[10:27:20.816]                         invokeRestart("muffleMessage")
[10:27:20.816]                     }
[10:27:20.816]                     else if (inherits(cond, "warning")) {
[10:27:20.816]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:20.816]                       if (muffled) 
[10:27:20.816]                         invokeRestart("muffleWarning")
[10:27:20.816]                     }
[10:27:20.816]                     else if (inherits(cond, "condition")) {
[10:27:20.816]                       if (!is.null(pattern)) {
[10:27:20.816]                         computeRestarts <- base::computeRestarts
[10:27:20.816]                         grepl <- base::grepl
[10:27:20.816]                         restarts <- computeRestarts(cond)
[10:27:20.816]                         for (restart in restarts) {
[10:27:20.816]                           name <- restart$name
[10:27:20.816]                           if (is.null(name)) 
[10:27:20.816]                             next
[10:27:20.816]                           if (!grepl(pattern, name)) 
[10:27:20.816]                             next
[10:27:20.816]                           invokeRestart(restart)
[10:27:20.816]                           muffled <- TRUE
[10:27:20.816]                           break
[10:27:20.816]                         }
[10:27:20.816]                       }
[10:27:20.816]                     }
[10:27:20.816]                     invisible(muffled)
[10:27:20.816]                   }
[10:27:20.816]                   muffleCondition(cond)
[10:27:20.816]                 })
[10:27:20.816]             }))
[10:27:20.816]             future::FutureResult(value = ...future.value$value, 
[10:27:20.816]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:20.816]                   ...future.rng), globalenv = if (FALSE) 
[10:27:20.816]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:20.816]                     ...future.globalenv.names))
[10:27:20.816]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:20.816]         }, condition = base::local({
[10:27:20.816]             c <- base::c
[10:27:20.816]             inherits <- base::inherits
[10:27:20.816]             invokeRestart <- base::invokeRestart
[10:27:20.816]             length <- base::length
[10:27:20.816]             list <- base::list
[10:27:20.816]             seq.int <- base::seq.int
[10:27:20.816]             signalCondition <- base::signalCondition
[10:27:20.816]             sys.calls <- base::sys.calls
[10:27:20.816]             `[[` <- base::`[[`
[10:27:20.816]             `+` <- base::`+`
[10:27:20.816]             `<<-` <- base::`<<-`
[10:27:20.816]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:20.816]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:20.816]                   3L)]
[10:27:20.816]             }
[10:27:20.816]             function(cond) {
[10:27:20.816]                 is_error <- inherits(cond, "error")
[10:27:20.816]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:20.816]                   NULL)
[10:27:20.816]                 if (is_error) {
[10:27:20.816]                   sessionInformation <- function() {
[10:27:20.816]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:20.816]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:20.816]                       search = base::search(), system = base::Sys.info())
[10:27:20.816]                   }
[10:27:20.816]                   ...future.conditions[[length(...future.conditions) + 
[10:27:20.816]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:20.816]                     cond$call), session = sessionInformation(), 
[10:27:20.816]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:20.816]                   signalCondition(cond)
[10:27:20.816]                 }
[10:27:20.816]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:20.816]                 "immediateCondition"))) {
[10:27:20.816]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:20.816]                   ...future.conditions[[length(...future.conditions) + 
[10:27:20.816]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:20.816]                   if (TRUE && !signal) {
[10:27:20.816]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:20.816]                     {
[10:27:20.816]                       inherits <- base::inherits
[10:27:20.816]                       invokeRestart <- base::invokeRestart
[10:27:20.816]                       is.null <- base::is.null
[10:27:20.816]                       muffled <- FALSE
[10:27:20.816]                       if (inherits(cond, "message")) {
[10:27:20.816]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:20.816]                         if (muffled) 
[10:27:20.816]                           invokeRestart("muffleMessage")
[10:27:20.816]                       }
[10:27:20.816]                       else if (inherits(cond, "warning")) {
[10:27:20.816]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:20.816]                         if (muffled) 
[10:27:20.816]                           invokeRestart("muffleWarning")
[10:27:20.816]                       }
[10:27:20.816]                       else if (inherits(cond, "condition")) {
[10:27:20.816]                         if (!is.null(pattern)) {
[10:27:20.816]                           computeRestarts <- base::computeRestarts
[10:27:20.816]                           grepl <- base::grepl
[10:27:20.816]                           restarts <- computeRestarts(cond)
[10:27:20.816]                           for (restart in restarts) {
[10:27:20.816]                             name <- restart$name
[10:27:20.816]                             if (is.null(name)) 
[10:27:20.816]                               next
[10:27:20.816]                             if (!grepl(pattern, name)) 
[10:27:20.816]                               next
[10:27:20.816]                             invokeRestart(restart)
[10:27:20.816]                             muffled <- TRUE
[10:27:20.816]                             break
[10:27:20.816]                           }
[10:27:20.816]                         }
[10:27:20.816]                       }
[10:27:20.816]                       invisible(muffled)
[10:27:20.816]                     }
[10:27:20.816]                     muffleCondition(cond, pattern = "^muffle")
[10:27:20.816]                   }
[10:27:20.816]                 }
[10:27:20.816]                 else {
[10:27:20.816]                   if (TRUE) {
[10:27:20.816]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:20.816]                     {
[10:27:20.816]                       inherits <- base::inherits
[10:27:20.816]                       invokeRestart <- base::invokeRestart
[10:27:20.816]                       is.null <- base::is.null
[10:27:20.816]                       muffled <- FALSE
[10:27:20.816]                       if (inherits(cond, "message")) {
[10:27:20.816]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:20.816]                         if (muffled) 
[10:27:20.816]                           invokeRestart("muffleMessage")
[10:27:20.816]                       }
[10:27:20.816]                       else if (inherits(cond, "warning")) {
[10:27:20.816]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:20.816]                         if (muffled) 
[10:27:20.816]                           invokeRestart("muffleWarning")
[10:27:20.816]                       }
[10:27:20.816]                       else if (inherits(cond, "condition")) {
[10:27:20.816]                         if (!is.null(pattern)) {
[10:27:20.816]                           computeRestarts <- base::computeRestarts
[10:27:20.816]                           grepl <- base::grepl
[10:27:20.816]                           restarts <- computeRestarts(cond)
[10:27:20.816]                           for (restart in restarts) {
[10:27:20.816]                             name <- restart$name
[10:27:20.816]                             if (is.null(name)) 
[10:27:20.816]                               next
[10:27:20.816]                             if (!grepl(pattern, name)) 
[10:27:20.816]                               next
[10:27:20.816]                             invokeRestart(restart)
[10:27:20.816]                             muffled <- TRUE
[10:27:20.816]                             break
[10:27:20.816]                           }
[10:27:20.816]                         }
[10:27:20.816]                       }
[10:27:20.816]                       invisible(muffled)
[10:27:20.816]                     }
[10:27:20.816]                     muffleCondition(cond, pattern = "^muffle")
[10:27:20.816]                   }
[10:27:20.816]                 }
[10:27:20.816]             }
[10:27:20.816]         }))
[10:27:20.816]     }, error = function(ex) {
[10:27:20.816]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:20.816]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:20.816]                 ...future.rng), started = ...future.startTime, 
[10:27:20.816]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:20.816]             version = "1.8"), class = "FutureResult")
[10:27:20.816]     }, finally = {
[10:27:20.816]         if (!identical(...future.workdir, getwd())) 
[10:27:20.816]             setwd(...future.workdir)
[10:27:20.816]         {
[10:27:20.816]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:20.816]                 ...future.oldOptions$nwarnings <- NULL
[10:27:20.816]             }
[10:27:20.816]             base::options(...future.oldOptions)
[10:27:20.816]             if (.Platform$OS.type == "windows") {
[10:27:20.816]                 old_names <- names(...future.oldEnvVars)
[10:27:20.816]                 envs <- base::Sys.getenv()
[10:27:20.816]                 names <- names(envs)
[10:27:20.816]                 common <- intersect(names, old_names)
[10:27:20.816]                 added <- setdiff(names, old_names)
[10:27:20.816]                 removed <- setdiff(old_names, names)
[10:27:20.816]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:20.816]                   envs[common]]
[10:27:20.816]                 NAMES <- toupper(changed)
[10:27:20.816]                 args <- list()
[10:27:20.816]                 for (kk in seq_along(NAMES)) {
[10:27:20.816]                   name <- changed[[kk]]
[10:27:20.816]                   NAME <- NAMES[[kk]]
[10:27:20.816]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:20.816]                     next
[10:27:20.816]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:20.816]                 }
[10:27:20.816]                 NAMES <- toupper(added)
[10:27:20.816]                 for (kk in seq_along(NAMES)) {
[10:27:20.816]                   name <- added[[kk]]
[10:27:20.816]                   NAME <- NAMES[[kk]]
[10:27:20.816]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:20.816]                     next
[10:27:20.816]                   args[[name]] <- ""
[10:27:20.816]                 }
[10:27:20.816]                 NAMES <- toupper(removed)
[10:27:20.816]                 for (kk in seq_along(NAMES)) {
[10:27:20.816]                   name <- removed[[kk]]
[10:27:20.816]                   NAME <- NAMES[[kk]]
[10:27:20.816]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:20.816]                     next
[10:27:20.816]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:20.816]                 }
[10:27:20.816]                 if (length(args) > 0) 
[10:27:20.816]                   base::do.call(base::Sys.setenv, args = args)
[10:27:20.816]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:20.816]             }
[10:27:20.816]             else {
[10:27:20.816]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:20.816]             }
[10:27:20.816]             {
[10:27:20.816]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:20.816]                   0L) {
[10:27:20.816]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:20.816]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:20.816]                   base::options(opts)
[10:27:20.816]                 }
[10:27:20.816]                 {
[10:27:20.816]                   {
[10:27:20.816]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:20.816]                     NULL
[10:27:20.816]                   }
[10:27:20.816]                   options(future.plan = NULL)
[10:27:20.816]                   if (is.na(NA_character_)) 
[10:27:20.816]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:20.816]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:20.816]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:20.816]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:20.816]                     envir = parent.frame()) 
[10:27:20.816]                   {
[10:27:20.816]                     if (is.function(workers)) 
[10:27:20.816]                       workers <- workers()
[10:27:20.816]                     workers <- structure(as.integer(workers), 
[10:27:20.816]                       class = class(workers))
[10:27:20.816]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:20.816]                       workers >= 1)
[10:27:20.816]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:20.816]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:20.816]                     }
[10:27:20.816]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:20.816]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:20.816]                       envir = envir)
[10:27:20.816]                     if (!future$lazy) 
[10:27:20.816]                       future <- run(future)
[10:27:20.816]                     invisible(future)
[10:27:20.816]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:20.816]                 }
[10:27:20.816]             }
[10:27:20.816]         }
[10:27:20.816]     })
[10:27:20.816]     if (TRUE) {
[10:27:20.816]         base::sink(type = "output", split = FALSE)
[10:27:20.816]         if (TRUE) {
[10:27:20.816]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:20.816]         }
[10:27:20.816]         else {
[10:27:20.816]             ...future.result["stdout"] <- base::list(NULL)
[10:27:20.816]         }
[10:27:20.816]         base::close(...future.stdout)
[10:27:20.816]         ...future.stdout <- NULL
[10:27:20.816]     }
[10:27:20.816]     ...future.result$conditions <- ...future.conditions
[10:27:20.816]     ...future.result$finished <- base::Sys.time()
[10:27:20.816]     ...future.result
[10:27:20.816] }
[10:27:20.819] MultisessionFuture started
[10:27:20.820] - Launch lazy future ... done
[10:27:20.820] run() for ‘MultisessionFuture’ ... done
[10:27:20.831] run() for ‘Future’ ...
[10:27:20.831] - state: ‘created’
[10:27:20.831] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:20.845] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:20.845] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:20.846]   - Field: ‘node’
[10:27:20.846]   - Field: ‘label’
[10:27:20.846]   - Field: ‘local’
[10:27:20.846]   - Field: ‘owner’
[10:27:20.846]   - Field: ‘envir’
[10:27:20.846]   - Field: ‘workers’
[10:27:20.846]   - Field: ‘packages’
[10:27:20.846]   - Field: ‘gc’
[10:27:20.846]   - Field: ‘conditions’
[10:27:20.846]   - Field: ‘persistent’
[10:27:20.847]   - Field: ‘expr’
[10:27:20.847]   - Field: ‘uuid’
[10:27:20.847]   - Field: ‘seed’
[10:27:20.847]   - Field: ‘version’
[10:27:20.847]   - Field: ‘result’
[10:27:20.847]   - Field: ‘asynchronous’
[10:27:20.847]   - Field: ‘calls’
[10:27:20.847]   - Field: ‘globals’
[10:27:20.847]   - Field: ‘stdout’
[10:27:20.847]   - Field: ‘earlySignal’
[10:27:20.847]   - Field: ‘lazy’
[10:27:20.847]   - Field: ‘state’
[10:27:20.848] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:20.848] - Launch lazy future ...
[10:27:20.848] Packages needed by the future expression (n = 0): <none>
[10:27:20.848] Packages needed by future strategies (n = 0): <none>
[10:27:20.849] {
[10:27:20.849]     {
[10:27:20.849]         {
[10:27:20.849]             ...future.startTime <- base::Sys.time()
[10:27:20.849]             {
[10:27:20.849]                 {
[10:27:20.849]                   {
[10:27:20.849]                     {
[10:27:20.849]                       base::local({
[10:27:20.849]                         has_future <- base::requireNamespace("future", 
[10:27:20.849]                           quietly = TRUE)
[10:27:20.849]                         if (has_future) {
[10:27:20.849]                           ns <- base::getNamespace("future")
[10:27:20.849]                           version <- ns[[".package"]][["version"]]
[10:27:20.849]                           if (is.null(version)) 
[10:27:20.849]                             version <- utils::packageVersion("future")
[10:27:20.849]                         }
[10:27:20.849]                         else {
[10:27:20.849]                           version <- NULL
[10:27:20.849]                         }
[10:27:20.849]                         if (!has_future || version < "1.8.0") {
[10:27:20.849]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:20.849]                             "", base::R.version$version.string), 
[10:27:20.849]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:20.849]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:20.849]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:20.849]                               "release", "version")], collapse = " "), 
[10:27:20.849]                             hostname = base::Sys.info()[["nodename"]])
[10:27:20.849]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:20.849]                             info)
[10:27:20.849]                           info <- base::paste(info, collapse = "; ")
[10:27:20.849]                           if (!has_future) {
[10:27:20.849]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:20.849]                               info)
[10:27:20.849]                           }
[10:27:20.849]                           else {
[10:27:20.849]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:20.849]                               info, version)
[10:27:20.849]                           }
[10:27:20.849]                           base::stop(msg)
[10:27:20.849]                         }
[10:27:20.849]                       })
[10:27:20.849]                     }
[10:27:20.849]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:20.849]                     base::options(mc.cores = 1L)
[10:27:20.849]                   }
[10:27:20.849]                   options(future.plan = NULL)
[10:27:20.849]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:20.849]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:20.849]                 }
[10:27:20.849]                 ...future.workdir <- getwd()
[10:27:20.849]             }
[10:27:20.849]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:20.849]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:20.849]         }
[10:27:20.849]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:20.849]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:20.849]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:20.849]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:20.849]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:20.849]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:20.849]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:20.849]             base::names(...future.oldOptions))
[10:27:20.849]     }
[10:27:20.849]     if (FALSE) {
[10:27:20.849]     }
[10:27:20.849]     else {
[10:27:20.849]         if (TRUE) {
[10:27:20.849]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:20.849]                 open = "w")
[10:27:20.849]         }
[10:27:20.849]         else {
[10:27:20.849]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:20.849]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:20.849]         }
[10:27:20.849]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:20.849]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:20.849]             base::sink(type = "output", split = FALSE)
[10:27:20.849]             base::close(...future.stdout)
[10:27:20.849]         }, add = TRUE)
[10:27:20.849]     }
[10:27:20.849]     ...future.frame <- base::sys.nframe()
[10:27:20.849]     ...future.conditions <- base::list()
[10:27:20.849]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:20.849]     if (FALSE) {
[10:27:20.849]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:20.849]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:20.849]     }
[10:27:20.849]     ...future.result <- base::tryCatch({
[10:27:20.849]         base::withCallingHandlers({
[10:27:20.849]             ...future.value <- base::withVisible(base::local({
[10:27:20.849]                 ...future.makeSendCondition <- base::local({
[10:27:20.849]                   sendCondition <- NULL
[10:27:20.849]                   function(frame = 1L) {
[10:27:20.849]                     if (is.function(sendCondition)) 
[10:27:20.849]                       return(sendCondition)
[10:27:20.849]                     ns <- getNamespace("parallel")
[10:27:20.849]                     if (exists("sendData", mode = "function", 
[10:27:20.849]                       envir = ns)) {
[10:27:20.849]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:20.849]                         envir = ns)
[10:27:20.849]                       envir <- sys.frame(frame)
[10:27:20.849]                       master <- NULL
[10:27:20.849]                       while (!identical(envir, .GlobalEnv) && 
[10:27:20.849]                         !identical(envir, emptyenv())) {
[10:27:20.849]                         if (exists("master", mode = "list", envir = envir, 
[10:27:20.849]                           inherits = FALSE)) {
[10:27:20.849]                           master <- get("master", mode = "list", 
[10:27:20.849]                             envir = envir, inherits = FALSE)
[10:27:20.849]                           if (inherits(master, c("SOCKnode", 
[10:27:20.849]                             "SOCK0node"))) {
[10:27:20.849]                             sendCondition <<- function(cond) {
[10:27:20.849]                               data <- list(type = "VALUE", value = cond, 
[10:27:20.849]                                 success = TRUE)
[10:27:20.849]                               parallel_sendData(master, data)
[10:27:20.849]                             }
[10:27:20.849]                             return(sendCondition)
[10:27:20.849]                           }
[10:27:20.849]                         }
[10:27:20.849]                         frame <- frame + 1L
[10:27:20.849]                         envir <- sys.frame(frame)
[10:27:20.849]                       }
[10:27:20.849]                     }
[10:27:20.849]                     sendCondition <<- function(cond) NULL
[10:27:20.849]                   }
[10:27:20.849]                 })
[10:27:20.849]                 withCallingHandlers({
[10:27:20.849]                   2
[10:27:20.849]                 }, immediateCondition = function(cond) {
[10:27:20.849]                   sendCondition <- ...future.makeSendCondition()
[10:27:20.849]                   sendCondition(cond)
[10:27:20.849]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:20.849]                   {
[10:27:20.849]                     inherits <- base::inherits
[10:27:20.849]                     invokeRestart <- base::invokeRestart
[10:27:20.849]                     is.null <- base::is.null
[10:27:20.849]                     muffled <- FALSE
[10:27:20.849]                     if (inherits(cond, "message")) {
[10:27:20.849]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:20.849]                       if (muffled) 
[10:27:20.849]                         invokeRestart("muffleMessage")
[10:27:20.849]                     }
[10:27:20.849]                     else if (inherits(cond, "warning")) {
[10:27:20.849]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:20.849]                       if (muffled) 
[10:27:20.849]                         invokeRestart("muffleWarning")
[10:27:20.849]                     }
[10:27:20.849]                     else if (inherits(cond, "condition")) {
[10:27:20.849]                       if (!is.null(pattern)) {
[10:27:20.849]                         computeRestarts <- base::computeRestarts
[10:27:20.849]                         grepl <- base::grepl
[10:27:20.849]                         restarts <- computeRestarts(cond)
[10:27:20.849]                         for (restart in restarts) {
[10:27:20.849]                           name <- restart$name
[10:27:20.849]                           if (is.null(name)) 
[10:27:20.849]                             next
[10:27:20.849]                           if (!grepl(pattern, name)) 
[10:27:20.849]                             next
[10:27:20.849]                           invokeRestart(restart)
[10:27:20.849]                           muffled <- TRUE
[10:27:20.849]                           break
[10:27:20.849]                         }
[10:27:20.849]                       }
[10:27:20.849]                     }
[10:27:20.849]                     invisible(muffled)
[10:27:20.849]                   }
[10:27:20.849]                   muffleCondition(cond)
[10:27:20.849]                 })
[10:27:20.849]             }))
[10:27:20.849]             future::FutureResult(value = ...future.value$value, 
[10:27:20.849]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:20.849]                   ...future.rng), globalenv = if (FALSE) 
[10:27:20.849]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:20.849]                     ...future.globalenv.names))
[10:27:20.849]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:20.849]         }, condition = base::local({
[10:27:20.849]             c <- base::c
[10:27:20.849]             inherits <- base::inherits
[10:27:20.849]             invokeRestart <- base::invokeRestart
[10:27:20.849]             length <- base::length
[10:27:20.849]             list <- base::list
[10:27:20.849]             seq.int <- base::seq.int
[10:27:20.849]             signalCondition <- base::signalCondition
[10:27:20.849]             sys.calls <- base::sys.calls
[10:27:20.849]             `[[` <- base::`[[`
[10:27:20.849]             `+` <- base::`+`
[10:27:20.849]             `<<-` <- base::`<<-`
[10:27:20.849]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:20.849]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:20.849]                   3L)]
[10:27:20.849]             }
[10:27:20.849]             function(cond) {
[10:27:20.849]                 is_error <- inherits(cond, "error")
[10:27:20.849]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:20.849]                   NULL)
[10:27:20.849]                 if (is_error) {
[10:27:20.849]                   sessionInformation <- function() {
[10:27:20.849]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:20.849]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:20.849]                       search = base::search(), system = base::Sys.info())
[10:27:20.849]                   }
[10:27:20.849]                   ...future.conditions[[length(...future.conditions) + 
[10:27:20.849]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:20.849]                     cond$call), session = sessionInformation(), 
[10:27:20.849]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:20.849]                   signalCondition(cond)
[10:27:20.849]                 }
[10:27:20.849]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:20.849]                 "immediateCondition"))) {
[10:27:20.849]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:20.849]                   ...future.conditions[[length(...future.conditions) + 
[10:27:20.849]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:20.849]                   if (TRUE && !signal) {
[10:27:20.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:20.849]                     {
[10:27:20.849]                       inherits <- base::inherits
[10:27:20.849]                       invokeRestart <- base::invokeRestart
[10:27:20.849]                       is.null <- base::is.null
[10:27:20.849]                       muffled <- FALSE
[10:27:20.849]                       if (inherits(cond, "message")) {
[10:27:20.849]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:20.849]                         if (muffled) 
[10:27:20.849]                           invokeRestart("muffleMessage")
[10:27:20.849]                       }
[10:27:20.849]                       else if (inherits(cond, "warning")) {
[10:27:20.849]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:20.849]                         if (muffled) 
[10:27:20.849]                           invokeRestart("muffleWarning")
[10:27:20.849]                       }
[10:27:20.849]                       else if (inherits(cond, "condition")) {
[10:27:20.849]                         if (!is.null(pattern)) {
[10:27:20.849]                           computeRestarts <- base::computeRestarts
[10:27:20.849]                           grepl <- base::grepl
[10:27:20.849]                           restarts <- computeRestarts(cond)
[10:27:20.849]                           for (restart in restarts) {
[10:27:20.849]                             name <- restart$name
[10:27:20.849]                             if (is.null(name)) 
[10:27:20.849]                               next
[10:27:20.849]                             if (!grepl(pattern, name)) 
[10:27:20.849]                               next
[10:27:20.849]                             invokeRestart(restart)
[10:27:20.849]                             muffled <- TRUE
[10:27:20.849]                             break
[10:27:20.849]                           }
[10:27:20.849]                         }
[10:27:20.849]                       }
[10:27:20.849]                       invisible(muffled)
[10:27:20.849]                     }
[10:27:20.849]                     muffleCondition(cond, pattern = "^muffle")
[10:27:20.849]                   }
[10:27:20.849]                 }
[10:27:20.849]                 else {
[10:27:20.849]                   if (TRUE) {
[10:27:20.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:20.849]                     {
[10:27:20.849]                       inherits <- base::inherits
[10:27:20.849]                       invokeRestart <- base::invokeRestart
[10:27:20.849]                       is.null <- base::is.null
[10:27:20.849]                       muffled <- FALSE
[10:27:20.849]                       if (inherits(cond, "message")) {
[10:27:20.849]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:20.849]                         if (muffled) 
[10:27:20.849]                           invokeRestart("muffleMessage")
[10:27:20.849]                       }
[10:27:20.849]                       else if (inherits(cond, "warning")) {
[10:27:20.849]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:20.849]                         if (muffled) 
[10:27:20.849]                           invokeRestart("muffleWarning")
[10:27:20.849]                       }
[10:27:20.849]                       else if (inherits(cond, "condition")) {
[10:27:20.849]                         if (!is.null(pattern)) {
[10:27:20.849]                           computeRestarts <- base::computeRestarts
[10:27:20.849]                           grepl <- base::grepl
[10:27:20.849]                           restarts <- computeRestarts(cond)
[10:27:20.849]                           for (restart in restarts) {
[10:27:20.849]                             name <- restart$name
[10:27:20.849]                             if (is.null(name)) 
[10:27:20.849]                               next
[10:27:20.849]                             if (!grepl(pattern, name)) 
[10:27:20.849]                               next
[10:27:20.849]                             invokeRestart(restart)
[10:27:20.849]                             muffled <- TRUE
[10:27:20.849]                             break
[10:27:20.849]                           }
[10:27:20.849]                         }
[10:27:20.849]                       }
[10:27:20.849]                       invisible(muffled)
[10:27:20.849]                     }
[10:27:20.849]                     muffleCondition(cond, pattern = "^muffle")
[10:27:20.849]                   }
[10:27:20.849]                 }
[10:27:20.849]             }
[10:27:20.849]         }))
[10:27:20.849]     }, error = function(ex) {
[10:27:20.849]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:20.849]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:20.849]                 ...future.rng), started = ...future.startTime, 
[10:27:20.849]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:20.849]             version = "1.8"), class = "FutureResult")
[10:27:20.849]     }, finally = {
[10:27:20.849]         if (!identical(...future.workdir, getwd())) 
[10:27:20.849]             setwd(...future.workdir)
[10:27:20.849]         {
[10:27:20.849]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:20.849]                 ...future.oldOptions$nwarnings <- NULL
[10:27:20.849]             }
[10:27:20.849]             base::options(...future.oldOptions)
[10:27:20.849]             if (.Platform$OS.type == "windows") {
[10:27:20.849]                 old_names <- names(...future.oldEnvVars)
[10:27:20.849]                 envs <- base::Sys.getenv()
[10:27:20.849]                 names <- names(envs)
[10:27:20.849]                 common <- intersect(names, old_names)
[10:27:20.849]                 added <- setdiff(names, old_names)
[10:27:20.849]                 removed <- setdiff(old_names, names)
[10:27:20.849]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:20.849]                   envs[common]]
[10:27:20.849]                 NAMES <- toupper(changed)
[10:27:20.849]                 args <- list()
[10:27:20.849]                 for (kk in seq_along(NAMES)) {
[10:27:20.849]                   name <- changed[[kk]]
[10:27:20.849]                   NAME <- NAMES[[kk]]
[10:27:20.849]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:20.849]                     next
[10:27:20.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:20.849]                 }
[10:27:20.849]                 NAMES <- toupper(added)
[10:27:20.849]                 for (kk in seq_along(NAMES)) {
[10:27:20.849]                   name <- added[[kk]]
[10:27:20.849]                   NAME <- NAMES[[kk]]
[10:27:20.849]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:20.849]                     next
[10:27:20.849]                   args[[name]] <- ""
[10:27:20.849]                 }
[10:27:20.849]                 NAMES <- toupper(removed)
[10:27:20.849]                 for (kk in seq_along(NAMES)) {
[10:27:20.849]                   name <- removed[[kk]]
[10:27:20.849]                   NAME <- NAMES[[kk]]
[10:27:20.849]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:20.849]                     next
[10:27:20.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:20.849]                 }
[10:27:20.849]                 if (length(args) > 0) 
[10:27:20.849]                   base::do.call(base::Sys.setenv, args = args)
[10:27:20.849]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:20.849]             }
[10:27:20.849]             else {
[10:27:20.849]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:20.849]             }
[10:27:20.849]             {
[10:27:20.849]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:20.849]                   0L) {
[10:27:20.849]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:20.849]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:20.849]                   base::options(opts)
[10:27:20.849]                 }
[10:27:20.849]                 {
[10:27:20.849]                   {
[10:27:20.849]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:20.849]                     NULL
[10:27:20.849]                   }
[10:27:20.849]                   options(future.plan = NULL)
[10:27:20.849]                   if (is.na(NA_character_)) 
[10:27:20.849]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:20.849]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:20.849]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:20.849]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:20.849]                     envir = parent.frame()) 
[10:27:20.849]                   {
[10:27:20.849]                     if (is.function(workers)) 
[10:27:20.849]                       workers <- workers()
[10:27:20.849]                     workers <- structure(as.integer(workers), 
[10:27:20.849]                       class = class(workers))
[10:27:20.849]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:20.849]                       workers >= 1)
[10:27:20.849]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:20.849]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:20.849]                     }
[10:27:20.849]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:20.849]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:20.849]                       envir = envir)
[10:27:20.849]                     if (!future$lazy) 
[10:27:20.849]                       future <- run(future)
[10:27:20.849]                     invisible(future)
[10:27:20.849]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:20.849]                 }
[10:27:20.849]             }
[10:27:20.849]         }
[10:27:20.849]     })
[10:27:20.849]     if (TRUE) {
[10:27:20.849]         base::sink(type = "output", split = FALSE)
[10:27:20.849]         if (TRUE) {
[10:27:20.849]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:20.849]         }
[10:27:20.849]         else {
[10:27:20.849]             ...future.result["stdout"] <- base::list(NULL)
[10:27:20.849]         }
[10:27:20.849]         base::close(...future.stdout)
[10:27:20.849]         ...future.stdout <- NULL
[10:27:20.849]     }
[10:27:20.849]     ...future.result$conditions <- ...future.conditions
[10:27:20.849]     ...future.result$finished <- base::Sys.time()
[10:27:20.849]     ...future.result
[10:27:20.849] }
[10:27:20.852] MultisessionFuture started
[10:27:20.852] - Launch lazy future ... done
[10:27:20.852] run() for ‘MultisessionFuture’ ... done
[10:27:20.863]  length: 2 (resolved future 3)
[10:27:20.874] receiveMessageFromWorker() for ClusterFuture ...
[10:27:20.874] - Validating connection of MultisessionFuture
[10:27:20.874] - received message: FutureResult
[10:27:20.874] - Received FutureResult
[10:27:20.874] - Erased future from FutureRegistry
[10:27:20.874] result() for ClusterFuture ...
[10:27:20.874] - result already collected: FutureResult
[10:27:20.875] result() for ClusterFuture ... done
[10:27:20.875] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:20.875] Future #1
[10:27:20.875]  length: 1 (resolved future 1)
[10:27:20.898] receiveMessageFromWorker() for ClusterFuture ...
[10:27:20.899] - Validating connection of MultisessionFuture
[10:27:20.899] - received message: FutureResult
[10:27:20.899] - Received FutureResult
[10:27:20.899] - Erased future from FutureRegistry
[10:27:20.899] result() for ClusterFuture ...
[10:27:20.899] - result already collected: FutureResult
[10:27:20.899] result() for ClusterFuture ... done
[10:27:20.899] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:20.900] Future #2
[10:27:20.900]  length: 0 (resolved future 2)
[10:27:20.900] resolve() on list ... DONE
[10:27:20.900] getGlobalsAndPackages() ...
[10:27:20.900] Searching for globals...
[10:27:20.900] 
[10:27:20.900] Searching for globals ... DONE
[10:27:20.901] - globals: [0] <none>
[10:27:20.901] getGlobalsAndPackages() ... DONE
[10:27:20.901] run() for ‘Future’ ...
[10:27:20.901] - state: ‘created’
[10:27:20.901] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:20.915] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:20.915] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:20.916]   - Field: ‘node’
[10:27:20.916]   - Field: ‘label’
[10:27:20.916]   - Field: ‘local’
[10:27:20.916]   - Field: ‘owner’
[10:27:20.916]   - Field: ‘envir’
[10:27:20.916]   - Field: ‘workers’
[10:27:20.916]   - Field: ‘packages’
[10:27:20.916]   - Field: ‘gc’
[10:27:20.916]   - Field: ‘conditions’
[10:27:20.916]   - Field: ‘persistent’
[10:27:20.916]   - Field: ‘expr’
[10:27:20.917]   - Field: ‘uuid’
[10:27:20.917]   - Field: ‘seed’
[10:27:20.917]   - Field: ‘version’
[10:27:20.917]   - Field: ‘result’
[10:27:20.917]   - Field: ‘asynchronous’
[10:27:20.917]   - Field: ‘calls’
[10:27:20.917]   - Field: ‘globals’
[10:27:20.917]   - Field: ‘stdout’
[10:27:20.917]   - Field: ‘earlySignal’
[10:27:20.918]   - Field: ‘lazy’
[10:27:20.918]   - Field: ‘state’
[10:27:20.918] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:20.918] - Launch lazy future ...
[10:27:20.918] Packages needed by the future expression (n = 0): <none>
[10:27:20.918] Packages needed by future strategies (n = 0): <none>
[10:27:20.919] {
[10:27:20.919]     {
[10:27:20.919]         {
[10:27:20.919]             ...future.startTime <- base::Sys.time()
[10:27:20.919]             {
[10:27:20.919]                 {
[10:27:20.919]                   {
[10:27:20.919]                     {
[10:27:20.919]                       base::local({
[10:27:20.919]                         has_future <- base::requireNamespace("future", 
[10:27:20.919]                           quietly = TRUE)
[10:27:20.919]                         if (has_future) {
[10:27:20.919]                           ns <- base::getNamespace("future")
[10:27:20.919]                           version <- ns[[".package"]][["version"]]
[10:27:20.919]                           if (is.null(version)) 
[10:27:20.919]                             version <- utils::packageVersion("future")
[10:27:20.919]                         }
[10:27:20.919]                         else {
[10:27:20.919]                           version <- NULL
[10:27:20.919]                         }
[10:27:20.919]                         if (!has_future || version < "1.8.0") {
[10:27:20.919]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:20.919]                             "", base::R.version$version.string), 
[10:27:20.919]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:20.919]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:20.919]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:20.919]                               "release", "version")], collapse = " "), 
[10:27:20.919]                             hostname = base::Sys.info()[["nodename"]])
[10:27:20.919]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:20.919]                             info)
[10:27:20.919]                           info <- base::paste(info, collapse = "; ")
[10:27:20.919]                           if (!has_future) {
[10:27:20.919]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:20.919]                               info)
[10:27:20.919]                           }
[10:27:20.919]                           else {
[10:27:20.919]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:20.919]                               info, version)
[10:27:20.919]                           }
[10:27:20.919]                           base::stop(msg)
[10:27:20.919]                         }
[10:27:20.919]                       })
[10:27:20.919]                     }
[10:27:20.919]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:20.919]                     base::options(mc.cores = 1L)
[10:27:20.919]                   }
[10:27:20.919]                   options(future.plan = NULL)
[10:27:20.919]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:20.919]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:20.919]                 }
[10:27:20.919]                 ...future.workdir <- getwd()
[10:27:20.919]             }
[10:27:20.919]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:20.919]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:20.919]         }
[10:27:20.919]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:20.919]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:20.919]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:20.919]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:20.919]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:20.919]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:20.919]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:20.919]             base::names(...future.oldOptions))
[10:27:20.919]     }
[10:27:20.919]     if (FALSE) {
[10:27:20.919]     }
[10:27:20.919]     else {
[10:27:20.919]         if (TRUE) {
[10:27:20.919]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:20.919]                 open = "w")
[10:27:20.919]         }
[10:27:20.919]         else {
[10:27:20.919]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:20.919]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:20.919]         }
[10:27:20.919]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:20.919]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:20.919]             base::sink(type = "output", split = FALSE)
[10:27:20.919]             base::close(...future.stdout)
[10:27:20.919]         }, add = TRUE)
[10:27:20.919]     }
[10:27:20.919]     ...future.frame <- base::sys.nframe()
[10:27:20.919]     ...future.conditions <- base::list()
[10:27:20.919]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:20.919]     if (FALSE) {
[10:27:20.919]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:20.919]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:20.919]     }
[10:27:20.919]     ...future.result <- base::tryCatch({
[10:27:20.919]         base::withCallingHandlers({
[10:27:20.919]             ...future.value <- base::withVisible(base::local({
[10:27:20.919]                 ...future.makeSendCondition <- base::local({
[10:27:20.919]                   sendCondition <- NULL
[10:27:20.919]                   function(frame = 1L) {
[10:27:20.919]                     if (is.function(sendCondition)) 
[10:27:20.919]                       return(sendCondition)
[10:27:20.919]                     ns <- getNamespace("parallel")
[10:27:20.919]                     if (exists("sendData", mode = "function", 
[10:27:20.919]                       envir = ns)) {
[10:27:20.919]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:20.919]                         envir = ns)
[10:27:20.919]                       envir <- sys.frame(frame)
[10:27:20.919]                       master <- NULL
[10:27:20.919]                       while (!identical(envir, .GlobalEnv) && 
[10:27:20.919]                         !identical(envir, emptyenv())) {
[10:27:20.919]                         if (exists("master", mode = "list", envir = envir, 
[10:27:20.919]                           inherits = FALSE)) {
[10:27:20.919]                           master <- get("master", mode = "list", 
[10:27:20.919]                             envir = envir, inherits = FALSE)
[10:27:20.919]                           if (inherits(master, c("SOCKnode", 
[10:27:20.919]                             "SOCK0node"))) {
[10:27:20.919]                             sendCondition <<- function(cond) {
[10:27:20.919]                               data <- list(type = "VALUE", value = cond, 
[10:27:20.919]                                 success = TRUE)
[10:27:20.919]                               parallel_sendData(master, data)
[10:27:20.919]                             }
[10:27:20.919]                             return(sendCondition)
[10:27:20.919]                           }
[10:27:20.919]                         }
[10:27:20.919]                         frame <- frame + 1L
[10:27:20.919]                         envir <- sys.frame(frame)
[10:27:20.919]                       }
[10:27:20.919]                     }
[10:27:20.919]                     sendCondition <<- function(cond) NULL
[10:27:20.919]                   }
[10:27:20.919]                 })
[10:27:20.919]                 withCallingHandlers({
[10:27:20.919]                   1
[10:27:20.919]                 }, immediateCondition = function(cond) {
[10:27:20.919]                   sendCondition <- ...future.makeSendCondition()
[10:27:20.919]                   sendCondition(cond)
[10:27:20.919]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:20.919]                   {
[10:27:20.919]                     inherits <- base::inherits
[10:27:20.919]                     invokeRestart <- base::invokeRestart
[10:27:20.919]                     is.null <- base::is.null
[10:27:20.919]                     muffled <- FALSE
[10:27:20.919]                     if (inherits(cond, "message")) {
[10:27:20.919]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:20.919]                       if (muffled) 
[10:27:20.919]                         invokeRestart("muffleMessage")
[10:27:20.919]                     }
[10:27:20.919]                     else if (inherits(cond, "warning")) {
[10:27:20.919]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:20.919]                       if (muffled) 
[10:27:20.919]                         invokeRestart("muffleWarning")
[10:27:20.919]                     }
[10:27:20.919]                     else if (inherits(cond, "condition")) {
[10:27:20.919]                       if (!is.null(pattern)) {
[10:27:20.919]                         computeRestarts <- base::computeRestarts
[10:27:20.919]                         grepl <- base::grepl
[10:27:20.919]                         restarts <- computeRestarts(cond)
[10:27:20.919]                         for (restart in restarts) {
[10:27:20.919]                           name <- restart$name
[10:27:20.919]                           if (is.null(name)) 
[10:27:20.919]                             next
[10:27:20.919]                           if (!grepl(pattern, name)) 
[10:27:20.919]                             next
[10:27:20.919]                           invokeRestart(restart)
[10:27:20.919]                           muffled <- TRUE
[10:27:20.919]                           break
[10:27:20.919]                         }
[10:27:20.919]                       }
[10:27:20.919]                     }
[10:27:20.919]                     invisible(muffled)
[10:27:20.919]                   }
[10:27:20.919]                   muffleCondition(cond)
[10:27:20.919]                 })
[10:27:20.919]             }))
[10:27:20.919]             future::FutureResult(value = ...future.value$value, 
[10:27:20.919]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:20.919]                   ...future.rng), globalenv = if (FALSE) 
[10:27:20.919]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:20.919]                     ...future.globalenv.names))
[10:27:20.919]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:20.919]         }, condition = base::local({
[10:27:20.919]             c <- base::c
[10:27:20.919]             inherits <- base::inherits
[10:27:20.919]             invokeRestart <- base::invokeRestart
[10:27:20.919]             length <- base::length
[10:27:20.919]             list <- base::list
[10:27:20.919]             seq.int <- base::seq.int
[10:27:20.919]             signalCondition <- base::signalCondition
[10:27:20.919]             sys.calls <- base::sys.calls
[10:27:20.919]             `[[` <- base::`[[`
[10:27:20.919]             `+` <- base::`+`
[10:27:20.919]             `<<-` <- base::`<<-`
[10:27:20.919]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:20.919]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:20.919]                   3L)]
[10:27:20.919]             }
[10:27:20.919]             function(cond) {
[10:27:20.919]                 is_error <- inherits(cond, "error")
[10:27:20.919]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:20.919]                   NULL)
[10:27:20.919]                 if (is_error) {
[10:27:20.919]                   sessionInformation <- function() {
[10:27:20.919]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:20.919]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:20.919]                       search = base::search(), system = base::Sys.info())
[10:27:20.919]                   }
[10:27:20.919]                   ...future.conditions[[length(...future.conditions) + 
[10:27:20.919]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:20.919]                     cond$call), session = sessionInformation(), 
[10:27:20.919]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:20.919]                   signalCondition(cond)
[10:27:20.919]                 }
[10:27:20.919]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:20.919]                 "immediateCondition"))) {
[10:27:20.919]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:20.919]                   ...future.conditions[[length(...future.conditions) + 
[10:27:20.919]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:20.919]                   if (TRUE && !signal) {
[10:27:20.919]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:20.919]                     {
[10:27:20.919]                       inherits <- base::inherits
[10:27:20.919]                       invokeRestart <- base::invokeRestart
[10:27:20.919]                       is.null <- base::is.null
[10:27:20.919]                       muffled <- FALSE
[10:27:20.919]                       if (inherits(cond, "message")) {
[10:27:20.919]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:20.919]                         if (muffled) 
[10:27:20.919]                           invokeRestart("muffleMessage")
[10:27:20.919]                       }
[10:27:20.919]                       else if (inherits(cond, "warning")) {
[10:27:20.919]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:20.919]                         if (muffled) 
[10:27:20.919]                           invokeRestart("muffleWarning")
[10:27:20.919]                       }
[10:27:20.919]                       else if (inherits(cond, "condition")) {
[10:27:20.919]                         if (!is.null(pattern)) {
[10:27:20.919]                           computeRestarts <- base::computeRestarts
[10:27:20.919]                           grepl <- base::grepl
[10:27:20.919]                           restarts <- computeRestarts(cond)
[10:27:20.919]                           for (restart in restarts) {
[10:27:20.919]                             name <- restart$name
[10:27:20.919]                             if (is.null(name)) 
[10:27:20.919]                               next
[10:27:20.919]                             if (!grepl(pattern, name)) 
[10:27:20.919]                               next
[10:27:20.919]                             invokeRestart(restart)
[10:27:20.919]                             muffled <- TRUE
[10:27:20.919]                             break
[10:27:20.919]                           }
[10:27:20.919]                         }
[10:27:20.919]                       }
[10:27:20.919]                       invisible(muffled)
[10:27:20.919]                     }
[10:27:20.919]                     muffleCondition(cond, pattern = "^muffle")
[10:27:20.919]                   }
[10:27:20.919]                 }
[10:27:20.919]                 else {
[10:27:20.919]                   if (TRUE) {
[10:27:20.919]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:20.919]                     {
[10:27:20.919]                       inherits <- base::inherits
[10:27:20.919]                       invokeRestart <- base::invokeRestart
[10:27:20.919]                       is.null <- base::is.null
[10:27:20.919]                       muffled <- FALSE
[10:27:20.919]                       if (inherits(cond, "message")) {
[10:27:20.919]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:20.919]                         if (muffled) 
[10:27:20.919]                           invokeRestart("muffleMessage")
[10:27:20.919]                       }
[10:27:20.919]                       else if (inherits(cond, "warning")) {
[10:27:20.919]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:20.919]                         if (muffled) 
[10:27:20.919]                           invokeRestart("muffleWarning")
[10:27:20.919]                       }
[10:27:20.919]                       else if (inherits(cond, "condition")) {
[10:27:20.919]                         if (!is.null(pattern)) {
[10:27:20.919]                           computeRestarts <- base::computeRestarts
[10:27:20.919]                           grepl <- base::grepl
[10:27:20.919]                           restarts <- computeRestarts(cond)
[10:27:20.919]                           for (restart in restarts) {
[10:27:20.919]                             name <- restart$name
[10:27:20.919]                             if (is.null(name)) 
[10:27:20.919]                               next
[10:27:20.919]                             if (!grepl(pattern, name)) 
[10:27:20.919]                               next
[10:27:20.919]                             invokeRestart(restart)
[10:27:20.919]                             muffled <- TRUE
[10:27:20.919]                             break
[10:27:20.919]                           }
[10:27:20.919]                         }
[10:27:20.919]                       }
[10:27:20.919]                       invisible(muffled)
[10:27:20.919]                     }
[10:27:20.919]                     muffleCondition(cond, pattern = "^muffle")
[10:27:20.919]                   }
[10:27:20.919]                 }
[10:27:20.919]             }
[10:27:20.919]         }))
[10:27:20.919]     }, error = function(ex) {
[10:27:20.919]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:20.919]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:20.919]                 ...future.rng), started = ...future.startTime, 
[10:27:20.919]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:20.919]             version = "1.8"), class = "FutureResult")
[10:27:20.919]     }, finally = {
[10:27:20.919]         if (!identical(...future.workdir, getwd())) 
[10:27:20.919]             setwd(...future.workdir)
[10:27:20.919]         {
[10:27:20.919]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:20.919]                 ...future.oldOptions$nwarnings <- NULL
[10:27:20.919]             }
[10:27:20.919]             base::options(...future.oldOptions)
[10:27:20.919]             if (.Platform$OS.type == "windows") {
[10:27:20.919]                 old_names <- names(...future.oldEnvVars)
[10:27:20.919]                 envs <- base::Sys.getenv()
[10:27:20.919]                 names <- names(envs)
[10:27:20.919]                 common <- intersect(names, old_names)
[10:27:20.919]                 added <- setdiff(names, old_names)
[10:27:20.919]                 removed <- setdiff(old_names, names)
[10:27:20.919]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:20.919]                   envs[common]]
[10:27:20.919]                 NAMES <- toupper(changed)
[10:27:20.919]                 args <- list()
[10:27:20.919]                 for (kk in seq_along(NAMES)) {
[10:27:20.919]                   name <- changed[[kk]]
[10:27:20.919]                   NAME <- NAMES[[kk]]
[10:27:20.919]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:20.919]                     next
[10:27:20.919]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:20.919]                 }
[10:27:20.919]                 NAMES <- toupper(added)
[10:27:20.919]                 for (kk in seq_along(NAMES)) {
[10:27:20.919]                   name <- added[[kk]]
[10:27:20.919]                   NAME <- NAMES[[kk]]
[10:27:20.919]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:20.919]                     next
[10:27:20.919]                   args[[name]] <- ""
[10:27:20.919]                 }
[10:27:20.919]                 NAMES <- toupper(removed)
[10:27:20.919]                 for (kk in seq_along(NAMES)) {
[10:27:20.919]                   name <- removed[[kk]]
[10:27:20.919]                   NAME <- NAMES[[kk]]
[10:27:20.919]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:20.919]                     next
[10:27:20.919]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:20.919]                 }
[10:27:20.919]                 if (length(args) > 0) 
[10:27:20.919]                   base::do.call(base::Sys.setenv, args = args)
[10:27:20.919]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:20.919]             }
[10:27:20.919]             else {
[10:27:20.919]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:20.919]             }
[10:27:20.919]             {
[10:27:20.919]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:20.919]                   0L) {
[10:27:20.919]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:20.919]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:20.919]                   base::options(opts)
[10:27:20.919]                 }
[10:27:20.919]                 {
[10:27:20.919]                   {
[10:27:20.919]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:20.919]                     NULL
[10:27:20.919]                   }
[10:27:20.919]                   options(future.plan = NULL)
[10:27:20.919]                   if (is.na(NA_character_)) 
[10:27:20.919]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:20.919]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:20.919]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:20.919]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:20.919]                     envir = parent.frame()) 
[10:27:20.919]                   {
[10:27:20.919]                     if (is.function(workers)) 
[10:27:20.919]                       workers <- workers()
[10:27:20.919]                     workers <- structure(as.integer(workers), 
[10:27:20.919]                       class = class(workers))
[10:27:20.919]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:20.919]                       workers >= 1)
[10:27:20.919]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:20.919]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:20.919]                     }
[10:27:20.919]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:20.919]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:20.919]                       envir = envir)
[10:27:20.919]                     if (!future$lazy) 
[10:27:20.919]                       future <- run(future)
[10:27:20.919]                     invisible(future)
[10:27:20.919]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:20.919]                 }
[10:27:20.919]             }
[10:27:20.919]         }
[10:27:20.919]     })
[10:27:20.919]     if (TRUE) {
[10:27:20.919]         base::sink(type = "output", split = FALSE)
[10:27:20.919]         if (TRUE) {
[10:27:20.919]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:20.919]         }
[10:27:20.919]         else {
[10:27:20.919]             ...future.result["stdout"] <- base::list(NULL)
[10:27:20.919]         }
[10:27:20.919]         base::close(...future.stdout)
[10:27:20.919]         ...future.stdout <- NULL
[10:27:20.919]     }
[10:27:20.919]     ...future.result$conditions <- ...future.conditions
[10:27:20.919]     ...future.result$finished <- base::Sys.time()
[10:27:20.919]     ...future.result
[10:27:20.919] }
[10:27:20.922] MultisessionFuture started
[10:27:20.922] - Launch lazy future ... done
[10:27:20.922] run() for ‘MultisessionFuture’ ... done
[10:27:20.923] getGlobalsAndPackages() ...
[10:27:20.923] Searching for globals...
[10:27:20.924] - globals found: [2] ‘{’, ‘Sys.sleep’
[10:27:20.924] Searching for globals ... DONE
[10:27:20.924] Resolving globals: FALSE
[10:27:20.924] 
[10:27:20.924] 
[10:27:20.924] getGlobalsAndPackages() ... DONE
[10:27:20.925] run() for ‘Future’ ...
[10:27:20.925] - state: ‘created’
[10:27:20.925] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:20.939] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:20.939] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:20.939]   - Field: ‘node’
[10:27:20.939]   - Field: ‘label’
[10:27:20.939]   - Field: ‘local’
[10:27:20.939]   - Field: ‘owner’
[10:27:20.940]   - Field: ‘envir’
[10:27:20.940]   - Field: ‘workers’
[10:27:20.940]   - Field: ‘packages’
[10:27:20.940]   - Field: ‘gc’
[10:27:20.940]   - Field: ‘conditions’
[10:27:20.940]   - Field: ‘persistent’
[10:27:20.940]   - Field: ‘expr’
[10:27:20.940]   - Field: ‘uuid’
[10:27:20.940]   - Field: ‘seed’
[10:27:20.940]   - Field: ‘version’
[10:27:20.941]   - Field: ‘result’
[10:27:20.941]   - Field: ‘asynchronous’
[10:27:20.941]   - Field: ‘calls’
[10:27:20.941]   - Field: ‘globals’
[10:27:20.941]   - Field: ‘stdout’
[10:27:20.941]   - Field: ‘earlySignal’
[10:27:20.941]   - Field: ‘lazy’
[10:27:20.941]   - Field: ‘state’
[10:27:20.941] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:20.941] - Launch lazy future ...
[10:27:20.942] Packages needed by the future expression (n = 0): <none>
[10:27:20.942] Packages needed by future strategies (n = 0): <none>
[10:27:20.942] {
[10:27:20.942]     {
[10:27:20.942]         {
[10:27:20.942]             ...future.startTime <- base::Sys.time()
[10:27:20.942]             {
[10:27:20.942]                 {
[10:27:20.942]                   {
[10:27:20.942]                     {
[10:27:20.942]                       base::local({
[10:27:20.942]                         has_future <- base::requireNamespace("future", 
[10:27:20.942]                           quietly = TRUE)
[10:27:20.942]                         if (has_future) {
[10:27:20.942]                           ns <- base::getNamespace("future")
[10:27:20.942]                           version <- ns[[".package"]][["version"]]
[10:27:20.942]                           if (is.null(version)) 
[10:27:20.942]                             version <- utils::packageVersion("future")
[10:27:20.942]                         }
[10:27:20.942]                         else {
[10:27:20.942]                           version <- NULL
[10:27:20.942]                         }
[10:27:20.942]                         if (!has_future || version < "1.8.0") {
[10:27:20.942]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:20.942]                             "", base::R.version$version.string), 
[10:27:20.942]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:20.942]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:20.942]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:20.942]                               "release", "version")], collapse = " "), 
[10:27:20.942]                             hostname = base::Sys.info()[["nodename"]])
[10:27:20.942]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:20.942]                             info)
[10:27:20.942]                           info <- base::paste(info, collapse = "; ")
[10:27:20.942]                           if (!has_future) {
[10:27:20.942]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:20.942]                               info)
[10:27:20.942]                           }
[10:27:20.942]                           else {
[10:27:20.942]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:20.942]                               info, version)
[10:27:20.942]                           }
[10:27:20.942]                           base::stop(msg)
[10:27:20.942]                         }
[10:27:20.942]                       })
[10:27:20.942]                     }
[10:27:20.942]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:20.942]                     base::options(mc.cores = 1L)
[10:27:20.942]                   }
[10:27:20.942]                   options(future.plan = NULL)
[10:27:20.942]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:20.942]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:20.942]                 }
[10:27:20.942]                 ...future.workdir <- getwd()
[10:27:20.942]             }
[10:27:20.942]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:20.942]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:20.942]         }
[10:27:20.942]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:20.942]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:20.942]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:20.942]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:20.942]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:20.942]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:20.942]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:20.942]             base::names(...future.oldOptions))
[10:27:20.942]     }
[10:27:20.942]     if (FALSE) {
[10:27:20.942]     }
[10:27:20.942]     else {
[10:27:20.942]         if (TRUE) {
[10:27:20.942]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:20.942]                 open = "w")
[10:27:20.942]         }
[10:27:20.942]         else {
[10:27:20.942]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:20.942]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:20.942]         }
[10:27:20.942]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:20.942]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:20.942]             base::sink(type = "output", split = FALSE)
[10:27:20.942]             base::close(...future.stdout)
[10:27:20.942]         }, add = TRUE)
[10:27:20.942]     }
[10:27:20.942]     ...future.frame <- base::sys.nframe()
[10:27:20.942]     ...future.conditions <- base::list()
[10:27:20.942]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:20.942]     if (FALSE) {
[10:27:20.942]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:20.942]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:20.942]     }
[10:27:20.942]     ...future.result <- base::tryCatch({
[10:27:20.942]         base::withCallingHandlers({
[10:27:20.942]             ...future.value <- base::withVisible(base::local({
[10:27:20.942]                 ...future.makeSendCondition <- base::local({
[10:27:20.942]                   sendCondition <- NULL
[10:27:20.942]                   function(frame = 1L) {
[10:27:20.942]                     if (is.function(sendCondition)) 
[10:27:20.942]                       return(sendCondition)
[10:27:20.942]                     ns <- getNamespace("parallel")
[10:27:20.942]                     if (exists("sendData", mode = "function", 
[10:27:20.942]                       envir = ns)) {
[10:27:20.942]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:20.942]                         envir = ns)
[10:27:20.942]                       envir <- sys.frame(frame)
[10:27:20.942]                       master <- NULL
[10:27:20.942]                       while (!identical(envir, .GlobalEnv) && 
[10:27:20.942]                         !identical(envir, emptyenv())) {
[10:27:20.942]                         if (exists("master", mode = "list", envir = envir, 
[10:27:20.942]                           inherits = FALSE)) {
[10:27:20.942]                           master <- get("master", mode = "list", 
[10:27:20.942]                             envir = envir, inherits = FALSE)
[10:27:20.942]                           if (inherits(master, c("SOCKnode", 
[10:27:20.942]                             "SOCK0node"))) {
[10:27:20.942]                             sendCondition <<- function(cond) {
[10:27:20.942]                               data <- list(type = "VALUE", value = cond, 
[10:27:20.942]                                 success = TRUE)
[10:27:20.942]                               parallel_sendData(master, data)
[10:27:20.942]                             }
[10:27:20.942]                             return(sendCondition)
[10:27:20.942]                           }
[10:27:20.942]                         }
[10:27:20.942]                         frame <- frame + 1L
[10:27:20.942]                         envir <- sys.frame(frame)
[10:27:20.942]                       }
[10:27:20.942]                     }
[10:27:20.942]                     sendCondition <<- function(cond) NULL
[10:27:20.942]                   }
[10:27:20.942]                 })
[10:27:20.942]                 withCallingHandlers({
[10:27:20.942]                   {
[10:27:20.942]                     Sys.sleep(0.5)
[10:27:20.942]                     2
[10:27:20.942]                   }
[10:27:20.942]                 }, immediateCondition = function(cond) {
[10:27:20.942]                   sendCondition <- ...future.makeSendCondition()
[10:27:20.942]                   sendCondition(cond)
[10:27:20.942]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:20.942]                   {
[10:27:20.942]                     inherits <- base::inherits
[10:27:20.942]                     invokeRestart <- base::invokeRestart
[10:27:20.942]                     is.null <- base::is.null
[10:27:20.942]                     muffled <- FALSE
[10:27:20.942]                     if (inherits(cond, "message")) {
[10:27:20.942]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:20.942]                       if (muffled) 
[10:27:20.942]                         invokeRestart("muffleMessage")
[10:27:20.942]                     }
[10:27:20.942]                     else if (inherits(cond, "warning")) {
[10:27:20.942]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:20.942]                       if (muffled) 
[10:27:20.942]                         invokeRestart("muffleWarning")
[10:27:20.942]                     }
[10:27:20.942]                     else if (inherits(cond, "condition")) {
[10:27:20.942]                       if (!is.null(pattern)) {
[10:27:20.942]                         computeRestarts <- base::computeRestarts
[10:27:20.942]                         grepl <- base::grepl
[10:27:20.942]                         restarts <- computeRestarts(cond)
[10:27:20.942]                         for (restart in restarts) {
[10:27:20.942]                           name <- restart$name
[10:27:20.942]                           if (is.null(name)) 
[10:27:20.942]                             next
[10:27:20.942]                           if (!grepl(pattern, name)) 
[10:27:20.942]                             next
[10:27:20.942]                           invokeRestart(restart)
[10:27:20.942]                           muffled <- TRUE
[10:27:20.942]                           break
[10:27:20.942]                         }
[10:27:20.942]                       }
[10:27:20.942]                     }
[10:27:20.942]                     invisible(muffled)
[10:27:20.942]                   }
[10:27:20.942]                   muffleCondition(cond)
[10:27:20.942]                 })
[10:27:20.942]             }))
[10:27:20.942]             future::FutureResult(value = ...future.value$value, 
[10:27:20.942]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:20.942]                   ...future.rng), globalenv = if (FALSE) 
[10:27:20.942]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:20.942]                     ...future.globalenv.names))
[10:27:20.942]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:20.942]         }, condition = base::local({
[10:27:20.942]             c <- base::c
[10:27:20.942]             inherits <- base::inherits
[10:27:20.942]             invokeRestart <- base::invokeRestart
[10:27:20.942]             length <- base::length
[10:27:20.942]             list <- base::list
[10:27:20.942]             seq.int <- base::seq.int
[10:27:20.942]             signalCondition <- base::signalCondition
[10:27:20.942]             sys.calls <- base::sys.calls
[10:27:20.942]             `[[` <- base::`[[`
[10:27:20.942]             `+` <- base::`+`
[10:27:20.942]             `<<-` <- base::`<<-`
[10:27:20.942]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:20.942]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:20.942]                   3L)]
[10:27:20.942]             }
[10:27:20.942]             function(cond) {
[10:27:20.942]                 is_error <- inherits(cond, "error")
[10:27:20.942]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:20.942]                   NULL)
[10:27:20.942]                 if (is_error) {
[10:27:20.942]                   sessionInformation <- function() {
[10:27:20.942]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:20.942]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:20.942]                       search = base::search(), system = base::Sys.info())
[10:27:20.942]                   }
[10:27:20.942]                   ...future.conditions[[length(...future.conditions) + 
[10:27:20.942]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:20.942]                     cond$call), session = sessionInformation(), 
[10:27:20.942]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:20.942]                   signalCondition(cond)
[10:27:20.942]                 }
[10:27:20.942]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:20.942]                 "immediateCondition"))) {
[10:27:20.942]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:20.942]                   ...future.conditions[[length(...future.conditions) + 
[10:27:20.942]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:20.942]                   if (TRUE && !signal) {
[10:27:20.942]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:20.942]                     {
[10:27:20.942]                       inherits <- base::inherits
[10:27:20.942]                       invokeRestart <- base::invokeRestart
[10:27:20.942]                       is.null <- base::is.null
[10:27:20.942]                       muffled <- FALSE
[10:27:20.942]                       if (inherits(cond, "message")) {
[10:27:20.942]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:20.942]                         if (muffled) 
[10:27:20.942]                           invokeRestart("muffleMessage")
[10:27:20.942]                       }
[10:27:20.942]                       else if (inherits(cond, "warning")) {
[10:27:20.942]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:20.942]                         if (muffled) 
[10:27:20.942]                           invokeRestart("muffleWarning")
[10:27:20.942]                       }
[10:27:20.942]                       else if (inherits(cond, "condition")) {
[10:27:20.942]                         if (!is.null(pattern)) {
[10:27:20.942]                           computeRestarts <- base::computeRestarts
[10:27:20.942]                           grepl <- base::grepl
[10:27:20.942]                           restarts <- computeRestarts(cond)
[10:27:20.942]                           for (restart in restarts) {
[10:27:20.942]                             name <- restart$name
[10:27:20.942]                             if (is.null(name)) 
[10:27:20.942]                               next
[10:27:20.942]                             if (!grepl(pattern, name)) 
[10:27:20.942]                               next
[10:27:20.942]                             invokeRestart(restart)
[10:27:20.942]                             muffled <- TRUE
[10:27:20.942]                             break
[10:27:20.942]                           }
[10:27:20.942]                         }
[10:27:20.942]                       }
[10:27:20.942]                       invisible(muffled)
[10:27:20.942]                     }
[10:27:20.942]                     muffleCondition(cond, pattern = "^muffle")
[10:27:20.942]                   }
[10:27:20.942]                 }
[10:27:20.942]                 else {
[10:27:20.942]                   if (TRUE) {
[10:27:20.942]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:20.942]                     {
[10:27:20.942]                       inherits <- base::inherits
[10:27:20.942]                       invokeRestart <- base::invokeRestart
[10:27:20.942]                       is.null <- base::is.null
[10:27:20.942]                       muffled <- FALSE
[10:27:20.942]                       if (inherits(cond, "message")) {
[10:27:20.942]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:20.942]                         if (muffled) 
[10:27:20.942]                           invokeRestart("muffleMessage")
[10:27:20.942]                       }
[10:27:20.942]                       else if (inherits(cond, "warning")) {
[10:27:20.942]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:20.942]                         if (muffled) 
[10:27:20.942]                           invokeRestart("muffleWarning")
[10:27:20.942]                       }
[10:27:20.942]                       else if (inherits(cond, "condition")) {
[10:27:20.942]                         if (!is.null(pattern)) {
[10:27:20.942]                           computeRestarts <- base::computeRestarts
[10:27:20.942]                           grepl <- base::grepl
[10:27:20.942]                           restarts <- computeRestarts(cond)
[10:27:20.942]                           for (restart in restarts) {
[10:27:20.942]                             name <- restart$name
[10:27:20.942]                             if (is.null(name)) 
[10:27:20.942]                               next
[10:27:20.942]                             if (!grepl(pattern, name)) 
[10:27:20.942]                               next
[10:27:20.942]                             invokeRestart(restart)
[10:27:20.942]                             muffled <- TRUE
[10:27:20.942]                             break
[10:27:20.942]                           }
[10:27:20.942]                         }
[10:27:20.942]                       }
[10:27:20.942]                       invisible(muffled)
[10:27:20.942]                     }
[10:27:20.942]                     muffleCondition(cond, pattern = "^muffle")
[10:27:20.942]                   }
[10:27:20.942]                 }
[10:27:20.942]             }
[10:27:20.942]         }))
[10:27:20.942]     }, error = function(ex) {
[10:27:20.942]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:20.942]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:20.942]                 ...future.rng), started = ...future.startTime, 
[10:27:20.942]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:20.942]             version = "1.8"), class = "FutureResult")
[10:27:20.942]     }, finally = {
[10:27:20.942]         if (!identical(...future.workdir, getwd())) 
[10:27:20.942]             setwd(...future.workdir)
[10:27:20.942]         {
[10:27:20.942]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:20.942]                 ...future.oldOptions$nwarnings <- NULL
[10:27:20.942]             }
[10:27:20.942]             base::options(...future.oldOptions)
[10:27:20.942]             if (.Platform$OS.type == "windows") {
[10:27:20.942]                 old_names <- names(...future.oldEnvVars)
[10:27:20.942]                 envs <- base::Sys.getenv()
[10:27:20.942]                 names <- names(envs)
[10:27:20.942]                 common <- intersect(names, old_names)
[10:27:20.942]                 added <- setdiff(names, old_names)
[10:27:20.942]                 removed <- setdiff(old_names, names)
[10:27:20.942]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:20.942]                   envs[common]]
[10:27:20.942]                 NAMES <- toupper(changed)
[10:27:20.942]                 args <- list()
[10:27:20.942]                 for (kk in seq_along(NAMES)) {
[10:27:20.942]                   name <- changed[[kk]]
[10:27:20.942]                   NAME <- NAMES[[kk]]
[10:27:20.942]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:20.942]                     next
[10:27:20.942]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:20.942]                 }
[10:27:20.942]                 NAMES <- toupper(added)
[10:27:20.942]                 for (kk in seq_along(NAMES)) {
[10:27:20.942]                   name <- added[[kk]]
[10:27:20.942]                   NAME <- NAMES[[kk]]
[10:27:20.942]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:20.942]                     next
[10:27:20.942]                   args[[name]] <- ""
[10:27:20.942]                 }
[10:27:20.942]                 NAMES <- toupper(removed)
[10:27:20.942]                 for (kk in seq_along(NAMES)) {
[10:27:20.942]                   name <- removed[[kk]]
[10:27:20.942]                   NAME <- NAMES[[kk]]
[10:27:20.942]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:20.942]                     next
[10:27:20.942]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:20.942]                 }
[10:27:20.942]                 if (length(args) > 0) 
[10:27:20.942]                   base::do.call(base::Sys.setenv, args = args)
[10:27:20.942]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:20.942]             }
[10:27:20.942]             else {
[10:27:20.942]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:20.942]             }
[10:27:20.942]             {
[10:27:20.942]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:20.942]                   0L) {
[10:27:20.942]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:20.942]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:20.942]                   base::options(opts)
[10:27:20.942]                 }
[10:27:20.942]                 {
[10:27:20.942]                   {
[10:27:20.942]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:20.942]                     NULL
[10:27:20.942]                   }
[10:27:20.942]                   options(future.plan = NULL)
[10:27:20.942]                   if (is.na(NA_character_)) 
[10:27:20.942]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:20.942]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:20.942]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:20.942]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:20.942]                     envir = parent.frame()) 
[10:27:20.942]                   {
[10:27:20.942]                     if (is.function(workers)) 
[10:27:20.942]                       workers <- workers()
[10:27:20.942]                     workers <- structure(as.integer(workers), 
[10:27:20.942]                       class = class(workers))
[10:27:20.942]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:20.942]                       workers >= 1)
[10:27:20.942]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:20.942]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:20.942]                     }
[10:27:20.942]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:20.942]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:20.942]                       envir = envir)
[10:27:20.942]                     if (!future$lazy) 
[10:27:20.942]                       future <- run(future)
[10:27:20.942]                     invisible(future)
[10:27:20.942]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:20.942]                 }
[10:27:20.942]             }
[10:27:20.942]         }
[10:27:20.942]     })
[10:27:20.942]     if (TRUE) {
[10:27:20.942]         base::sink(type = "output", split = FALSE)
[10:27:20.942]         if (TRUE) {
[10:27:20.942]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:20.942]         }
[10:27:20.942]         else {
[10:27:20.942]             ...future.result["stdout"] <- base::list(NULL)
[10:27:20.942]         }
[10:27:20.942]         base::close(...future.stdout)
[10:27:20.942]         ...future.stdout <- NULL
[10:27:20.942]     }
[10:27:20.942]     ...future.result$conditions <- ...future.conditions
[10:27:20.942]     ...future.result$finished <- base::Sys.time()
[10:27:20.942]     ...future.result
[10:27:20.942] }
[10:27:20.945] MultisessionFuture started
[10:27:20.946] - Launch lazy future ... done
[10:27:20.946] run() for ‘MultisessionFuture’ ... done
[10:27:20.946] resolve() on list ...
[10:27:20.946]  recursive: 0
[10:27:20.946]  length: 1
[10:27:20.946] 
[10:27:20.971] receiveMessageFromWorker() for ClusterFuture ...
[10:27:20.971] - Validating connection of MultisessionFuture
[10:27:20.971] - received message: FutureResult
[10:27:20.971] - Received FutureResult
[10:27:20.972] - Erased future from FutureRegistry
[10:27:20.972] result() for ClusterFuture ...
[10:27:20.972] - result already collected: FutureResult
[10:27:20.972] result() for ClusterFuture ... done
[10:27:20.972] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:20.972] Future #1
[10:27:20.972]  length: 0 (resolved future 1)
[10:27:20.972] resolve() on list ... DONE
[10:27:20.973] resolve() on list ...
[10:27:20.973]  recursive: 0
[10:27:20.973]  length: 1
[10:27:20.973] 
[10:27:21.501] receiveMessageFromWorker() for ClusterFuture ...
[10:27:21.501] - Validating connection of MultisessionFuture
[10:27:21.501] - received message: FutureResult
[10:27:21.502] - Received FutureResult
[10:27:21.502] - Erased future from FutureRegistry
[10:27:21.502] result() for ClusterFuture ...
[10:27:21.502] - result already collected: FutureResult
[10:27:21.502] result() for ClusterFuture ... done
[10:27:21.502] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:21.502] Future #1
[10:27:21.502]  length: 0 (resolved future 1)
[10:27:21.502] resolve() on list ... DONE
[10:27:21.503] resolve() on list ...
[10:27:21.503]  recursive: 0
[10:27:21.503]  length: 1
[10:27:21.503] 
[10:27:21.503]  length: 0 (resolved future 1)
[10:27:21.503] resolve() on list ... DONE
[10:27:21.503] resolve() on list ...
[10:27:21.503]  recursive: 0
[10:27:21.504]  length: 4
[10:27:21.504] 
[10:27:21.504] Future #1
[10:27:21.504]  length: 3 (resolved future 1)
[10:27:21.504] Future #2
[10:27:21.504]  length: 2 (resolved future 2)
[10:27:21.504]  length: 1 (resolved future 3)
[10:27:21.504]  length: 0 (resolved future 4)
[10:27:21.504] resolve() on list ... DONE
[10:27:21.505] resolve() on list ...
[10:27:21.505]  recursive: 0
[10:27:21.505]  length: 4
[10:27:21.505] 
[10:27:21.505] Future #1
[10:27:21.505]  length: 3 (resolved future 1)
[10:27:21.505] Future #2
[10:27:21.505]  length: 2 (resolved future 2)
[10:27:21.505]  length: 1 (resolved future 3)
[10:27:21.505]  length: 0 (resolved future 4)
[10:27:21.506] resolve() on list ... DONE
[10:27:21.506] resolve() on list ...
[10:27:21.506]  recursive: 0
[10:27:21.506]  length: 1
[10:27:21.506] 
[10:27:21.506]  length: 0 (resolved future 1)
[10:27:21.506] resolve() on list ... DONE
[10:27:21.506] getGlobalsAndPackages() ...
[10:27:21.506] Searching for globals...
[10:27:21.508] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:27:21.508] Searching for globals ... DONE
[10:27:21.508] Resolving globals: FALSE
[10:27:21.508] The total size of the 1 globals is 56 bytes (56 bytes)
[10:27:21.509] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[10:27:21.509] - globals: [1] ‘kk’
[10:27:21.509] 
[10:27:21.509] getGlobalsAndPackages() ... DONE
[10:27:21.509] run() for ‘Future’ ...
[10:27:21.509] - state: ‘created’
[10:27:21.509] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:21.526] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:21.526] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:21.527]   - Field: ‘node’
[10:27:21.527]   - Field: ‘label’
[10:27:21.527]   - Field: ‘local’
[10:27:21.527]   - Field: ‘owner’
[10:27:21.527]   - Field: ‘envir’
[10:27:21.527]   - Field: ‘workers’
[10:27:21.527]   - Field: ‘packages’
[10:27:21.527]   - Field: ‘gc’
[10:27:21.527]   - Field: ‘conditions’
[10:27:21.527]   - Field: ‘persistent’
[10:27:21.528]   - Field: ‘expr’
[10:27:21.528]   - Field: ‘uuid’
[10:27:21.528]   - Field: ‘seed’
[10:27:21.528]   - Field: ‘version’
[10:27:21.528]   - Field: ‘result’
[10:27:21.528]   - Field: ‘asynchronous’
[10:27:21.528]   - Field: ‘calls’
[10:27:21.528]   - Field: ‘globals’
[10:27:21.528]   - Field: ‘stdout’
[10:27:21.528]   - Field: ‘earlySignal’
[10:27:21.528]   - Field: ‘lazy’
[10:27:21.529]   - Field: ‘state’
[10:27:21.529] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:21.529] - Launch lazy future ...
[10:27:21.529] Packages needed by the future expression (n = 0): <none>
[10:27:21.529] Packages needed by future strategies (n = 0): <none>
[10:27:21.530] {
[10:27:21.530]     {
[10:27:21.530]         {
[10:27:21.530]             ...future.startTime <- base::Sys.time()
[10:27:21.530]             {
[10:27:21.530]                 {
[10:27:21.530]                   {
[10:27:21.530]                     {
[10:27:21.530]                       base::local({
[10:27:21.530]                         has_future <- base::requireNamespace("future", 
[10:27:21.530]                           quietly = TRUE)
[10:27:21.530]                         if (has_future) {
[10:27:21.530]                           ns <- base::getNamespace("future")
[10:27:21.530]                           version <- ns[[".package"]][["version"]]
[10:27:21.530]                           if (is.null(version)) 
[10:27:21.530]                             version <- utils::packageVersion("future")
[10:27:21.530]                         }
[10:27:21.530]                         else {
[10:27:21.530]                           version <- NULL
[10:27:21.530]                         }
[10:27:21.530]                         if (!has_future || version < "1.8.0") {
[10:27:21.530]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:21.530]                             "", base::R.version$version.string), 
[10:27:21.530]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:21.530]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:21.530]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:21.530]                               "release", "version")], collapse = " "), 
[10:27:21.530]                             hostname = base::Sys.info()[["nodename"]])
[10:27:21.530]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:21.530]                             info)
[10:27:21.530]                           info <- base::paste(info, collapse = "; ")
[10:27:21.530]                           if (!has_future) {
[10:27:21.530]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:21.530]                               info)
[10:27:21.530]                           }
[10:27:21.530]                           else {
[10:27:21.530]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:21.530]                               info, version)
[10:27:21.530]                           }
[10:27:21.530]                           base::stop(msg)
[10:27:21.530]                         }
[10:27:21.530]                       })
[10:27:21.530]                     }
[10:27:21.530]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:21.530]                     base::options(mc.cores = 1L)
[10:27:21.530]                   }
[10:27:21.530]                   options(future.plan = NULL)
[10:27:21.530]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:21.530]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:21.530]                 }
[10:27:21.530]                 ...future.workdir <- getwd()
[10:27:21.530]             }
[10:27:21.530]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:21.530]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:21.530]         }
[10:27:21.530]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:21.530]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:21.530]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:21.530]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:21.530]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:21.530]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:21.530]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:21.530]             base::names(...future.oldOptions))
[10:27:21.530]     }
[10:27:21.530]     if (FALSE) {
[10:27:21.530]     }
[10:27:21.530]     else {
[10:27:21.530]         if (TRUE) {
[10:27:21.530]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:21.530]                 open = "w")
[10:27:21.530]         }
[10:27:21.530]         else {
[10:27:21.530]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:21.530]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:21.530]         }
[10:27:21.530]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:21.530]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:21.530]             base::sink(type = "output", split = FALSE)
[10:27:21.530]             base::close(...future.stdout)
[10:27:21.530]         }, add = TRUE)
[10:27:21.530]     }
[10:27:21.530]     ...future.frame <- base::sys.nframe()
[10:27:21.530]     ...future.conditions <- base::list()
[10:27:21.530]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:21.530]     if (FALSE) {
[10:27:21.530]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:21.530]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:21.530]     }
[10:27:21.530]     ...future.result <- base::tryCatch({
[10:27:21.530]         base::withCallingHandlers({
[10:27:21.530]             ...future.value <- base::withVisible(base::local({
[10:27:21.530]                 ...future.makeSendCondition <- base::local({
[10:27:21.530]                   sendCondition <- NULL
[10:27:21.530]                   function(frame = 1L) {
[10:27:21.530]                     if (is.function(sendCondition)) 
[10:27:21.530]                       return(sendCondition)
[10:27:21.530]                     ns <- getNamespace("parallel")
[10:27:21.530]                     if (exists("sendData", mode = "function", 
[10:27:21.530]                       envir = ns)) {
[10:27:21.530]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:21.530]                         envir = ns)
[10:27:21.530]                       envir <- sys.frame(frame)
[10:27:21.530]                       master <- NULL
[10:27:21.530]                       while (!identical(envir, .GlobalEnv) && 
[10:27:21.530]                         !identical(envir, emptyenv())) {
[10:27:21.530]                         if (exists("master", mode = "list", envir = envir, 
[10:27:21.530]                           inherits = FALSE)) {
[10:27:21.530]                           master <- get("master", mode = "list", 
[10:27:21.530]                             envir = envir, inherits = FALSE)
[10:27:21.530]                           if (inherits(master, c("SOCKnode", 
[10:27:21.530]                             "SOCK0node"))) {
[10:27:21.530]                             sendCondition <<- function(cond) {
[10:27:21.530]                               data <- list(type = "VALUE", value = cond, 
[10:27:21.530]                                 success = TRUE)
[10:27:21.530]                               parallel_sendData(master, data)
[10:27:21.530]                             }
[10:27:21.530]                             return(sendCondition)
[10:27:21.530]                           }
[10:27:21.530]                         }
[10:27:21.530]                         frame <- frame + 1L
[10:27:21.530]                         envir <- sys.frame(frame)
[10:27:21.530]                       }
[10:27:21.530]                     }
[10:27:21.530]                     sendCondition <<- function(cond) NULL
[10:27:21.530]                   }
[10:27:21.530]                 })
[10:27:21.530]                 withCallingHandlers({
[10:27:21.530]                   {
[10:27:21.530]                     Sys.sleep(0.1)
[10:27:21.530]                     kk
[10:27:21.530]                   }
[10:27:21.530]                 }, immediateCondition = function(cond) {
[10:27:21.530]                   sendCondition <- ...future.makeSendCondition()
[10:27:21.530]                   sendCondition(cond)
[10:27:21.530]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:21.530]                   {
[10:27:21.530]                     inherits <- base::inherits
[10:27:21.530]                     invokeRestart <- base::invokeRestart
[10:27:21.530]                     is.null <- base::is.null
[10:27:21.530]                     muffled <- FALSE
[10:27:21.530]                     if (inherits(cond, "message")) {
[10:27:21.530]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:21.530]                       if (muffled) 
[10:27:21.530]                         invokeRestart("muffleMessage")
[10:27:21.530]                     }
[10:27:21.530]                     else if (inherits(cond, "warning")) {
[10:27:21.530]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:21.530]                       if (muffled) 
[10:27:21.530]                         invokeRestart("muffleWarning")
[10:27:21.530]                     }
[10:27:21.530]                     else if (inherits(cond, "condition")) {
[10:27:21.530]                       if (!is.null(pattern)) {
[10:27:21.530]                         computeRestarts <- base::computeRestarts
[10:27:21.530]                         grepl <- base::grepl
[10:27:21.530]                         restarts <- computeRestarts(cond)
[10:27:21.530]                         for (restart in restarts) {
[10:27:21.530]                           name <- restart$name
[10:27:21.530]                           if (is.null(name)) 
[10:27:21.530]                             next
[10:27:21.530]                           if (!grepl(pattern, name)) 
[10:27:21.530]                             next
[10:27:21.530]                           invokeRestart(restart)
[10:27:21.530]                           muffled <- TRUE
[10:27:21.530]                           break
[10:27:21.530]                         }
[10:27:21.530]                       }
[10:27:21.530]                     }
[10:27:21.530]                     invisible(muffled)
[10:27:21.530]                   }
[10:27:21.530]                   muffleCondition(cond)
[10:27:21.530]                 })
[10:27:21.530]             }))
[10:27:21.530]             future::FutureResult(value = ...future.value$value, 
[10:27:21.530]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:21.530]                   ...future.rng), globalenv = if (FALSE) 
[10:27:21.530]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:21.530]                     ...future.globalenv.names))
[10:27:21.530]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:21.530]         }, condition = base::local({
[10:27:21.530]             c <- base::c
[10:27:21.530]             inherits <- base::inherits
[10:27:21.530]             invokeRestart <- base::invokeRestart
[10:27:21.530]             length <- base::length
[10:27:21.530]             list <- base::list
[10:27:21.530]             seq.int <- base::seq.int
[10:27:21.530]             signalCondition <- base::signalCondition
[10:27:21.530]             sys.calls <- base::sys.calls
[10:27:21.530]             `[[` <- base::`[[`
[10:27:21.530]             `+` <- base::`+`
[10:27:21.530]             `<<-` <- base::`<<-`
[10:27:21.530]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:21.530]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:21.530]                   3L)]
[10:27:21.530]             }
[10:27:21.530]             function(cond) {
[10:27:21.530]                 is_error <- inherits(cond, "error")
[10:27:21.530]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:21.530]                   NULL)
[10:27:21.530]                 if (is_error) {
[10:27:21.530]                   sessionInformation <- function() {
[10:27:21.530]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:21.530]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:21.530]                       search = base::search(), system = base::Sys.info())
[10:27:21.530]                   }
[10:27:21.530]                   ...future.conditions[[length(...future.conditions) + 
[10:27:21.530]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:21.530]                     cond$call), session = sessionInformation(), 
[10:27:21.530]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:21.530]                   signalCondition(cond)
[10:27:21.530]                 }
[10:27:21.530]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:21.530]                 "immediateCondition"))) {
[10:27:21.530]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:21.530]                   ...future.conditions[[length(...future.conditions) + 
[10:27:21.530]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:21.530]                   if (TRUE && !signal) {
[10:27:21.530]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:21.530]                     {
[10:27:21.530]                       inherits <- base::inherits
[10:27:21.530]                       invokeRestart <- base::invokeRestart
[10:27:21.530]                       is.null <- base::is.null
[10:27:21.530]                       muffled <- FALSE
[10:27:21.530]                       if (inherits(cond, "message")) {
[10:27:21.530]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:21.530]                         if (muffled) 
[10:27:21.530]                           invokeRestart("muffleMessage")
[10:27:21.530]                       }
[10:27:21.530]                       else if (inherits(cond, "warning")) {
[10:27:21.530]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:21.530]                         if (muffled) 
[10:27:21.530]                           invokeRestart("muffleWarning")
[10:27:21.530]                       }
[10:27:21.530]                       else if (inherits(cond, "condition")) {
[10:27:21.530]                         if (!is.null(pattern)) {
[10:27:21.530]                           computeRestarts <- base::computeRestarts
[10:27:21.530]                           grepl <- base::grepl
[10:27:21.530]                           restarts <- computeRestarts(cond)
[10:27:21.530]                           for (restart in restarts) {
[10:27:21.530]                             name <- restart$name
[10:27:21.530]                             if (is.null(name)) 
[10:27:21.530]                               next
[10:27:21.530]                             if (!grepl(pattern, name)) 
[10:27:21.530]                               next
[10:27:21.530]                             invokeRestart(restart)
[10:27:21.530]                             muffled <- TRUE
[10:27:21.530]                             break
[10:27:21.530]                           }
[10:27:21.530]                         }
[10:27:21.530]                       }
[10:27:21.530]                       invisible(muffled)
[10:27:21.530]                     }
[10:27:21.530]                     muffleCondition(cond, pattern = "^muffle")
[10:27:21.530]                   }
[10:27:21.530]                 }
[10:27:21.530]                 else {
[10:27:21.530]                   if (TRUE) {
[10:27:21.530]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:21.530]                     {
[10:27:21.530]                       inherits <- base::inherits
[10:27:21.530]                       invokeRestart <- base::invokeRestart
[10:27:21.530]                       is.null <- base::is.null
[10:27:21.530]                       muffled <- FALSE
[10:27:21.530]                       if (inherits(cond, "message")) {
[10:27:21.530]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:21.530]                         if (muffled) 
[10:27:21.530]                           invokeRestart("muffleMessage")
[10:27:21.530]                       }
[10:27:21.530]                       else if (inherits(cond, "warning")) {
[10:27:21.530]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:21.530]                         if (muffled) 
[10:27:21.530]                           invokeRestart("muffleWarning")
[10:27:21.530]                       }
[10:27:21.530]                       else if (inherits(cond, "condition")) {
[10:27:21.530]                         if (!is.null(pattern)) {
[10:27:21.530]                           computeRestarts <- base::computeRestarts
[10:27:21.530]                           grepl <- base::grepl
[10:27:21.530]                           restarts <- computeRestarts(cond)
[10:27:21.530]                           for (restart in restarts) {
[10:27:21.530]                             name <- restart$name
[10:27:21.530]                             if (is.null(name)) 
[10:27:21.530]                               next
[10:27:21.530]                             if (!grepl(pattern, name)) 
[10:27:21.530]                               next
[10:27:21.530]                             invokeRestart(restart)
[10:27:21.530]                             muffled <- TRUE
[10:27:21.530]                             break
[10:27:21.530]                           }
[10:27:21.530]                         }
[10:27:21.530]                       }
[10:27:21.530]                       invisible(muffled)
[10:27:21.530]                     }
[10:27:21.530]                     muffleCondition(cond, pattern = "^muffle")
[10:27:21.530]                   }
[10:27:21.530]                 }
[10:27:21.530]             }
[10:27:21.530]         }))
[10:27:21.530]     }, error = function(ex) {
[10:27:21.530]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:21.530]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:21.530]                 ...future.rng), started = ...future.startTime, 
[10:27:21.530]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:21.530]             version = "1.8"), class = "FutureResult")
[10:27:21.530]     }, finally = {
[10:27:21.530]         if (!identical(...future.workdir, getwd())) 
[10:27:21.530]             setwd(...future.workdir)
[10:27:21.530]         {
[10:27:21.530]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:21.530]                 ...future.oldOptions$nwarnings <- NULL
[10:27:21.530]             }
[10:27:21.530]             base::options(...future.oldOptions)
[10:27:21.530]             if (.Platform$OS.type == "windows") {
[10:27:21.530]                 old_names <- names(...future.oldEnvVars)
[10:27:21.530]                 envs <- base::Sys.getenv()
[10:27:21.530]                 names <- names(envs)
[10:27:21.530]                 common <- intersect(names, old_names)
[10:27:21.530]                 added <- setdiff(names, old_names)
[10:27:21.530]                 removed <- setdiff(old_names, names)
[10:27:21.530]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:21.530]                   envs[common]]
[10:27:21.530]                 NAMES <- toupper(changed)
[10:27:21.530]                 args <- list()
[10:27:21.530]                 for (kk in seq_along(NAMES)) {
[10:27:21.530]                   name <- changed[[kk]]
[10:27:21.530]                   NAME <- NAMES[[kk]]
[10:27:21.530]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:21.530]                     next
[10:27:21.530]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:21.530]                 }
[10:27:21.530]                 NAMES <- toupper(added)
[10:27:21.530]                 for (kk in seq_along(NAMES)) {
[10:27:21.530]                   name <- added[[kk]]
[10:27:21.530]                   NAME <- NAMES[[kk]]
[10:27:21.530]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:21.530]                     next
[10:27:21.530]                   args[[name]] <- ""
[10:27:21.530]                 }
[10:27:21.530]                 NAMES <- toupper(removed)
[10:27:21.530]                 for (kk in seq_along(NAMES)) {
[10:27:21.530]                   name <- removed[[kk]]
[10:27:21.530]                   NAME <- NAMES[[kk]]
[10:27:21.530]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:21.530]                     next
[10:27:21.530]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:21.530]                 }
[10:27:21.530]                 if (length(args) > 0) 
[10:27:21.530]                   base::do.call(base::Sys.setenv, args = args)
[10:27:21.530]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:21.530]             }
[10:27:21.530]             else {
[10:27:21.530]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:21.530]             }
[10:27:21.530]             {
[10:27:21.530]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:21.530]                   0L) {
[10:27:21.530]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:21.530]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:21.530]                   base::options(opts)
[10:27:21.530]                 }
[10:27:21.530]                 {
[10:27:21.530]                   {
[10:27:21.530]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:21.530]                     NULL
[10:27:21.530]                   }
[10:27:21.530]                   options(future.plan = NULL)
[10:27:21.530]                   if (is.na(NA_character_)) 
[10:27:21.530]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:21.530]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:21.530]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:21.530]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:21.530]                     envir = parent.frame()) 
[10:27:21.530]                   {
[10:27:21.530]                     if (is.function(workers)) 
[10:27:21.530]                       workers <- workers()
[10:27:21.530]                     workers <- structure(as.integer(workers), 
[10:27:21.530]                       class = class(workers))
[10:27:21.530]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:21.530]                       workers >= 1)
[10:27:21.530]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:21.530]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:21.530]                     }
[10:27:21.530]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:21.530]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:21.530]                       envir = envir)
[10:27:21.530]                     if (!future$lazy) 
[10:27:21.530]                       future <- run(future)
[10:27:21.530]                     invisible(future)
[10:27:21.530]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:21.530]                 }
[10:27:21.530]             }
[10:27:21.530]         }
[10:27:21.530]     })
[10:27:21.530]     if (TRUE) {
[10:27:21.530]         base::sink(type = "output", split = FALSE)
[10:27:21.530]         if (TRUE) {
[10:27:21.530]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:21.530]         }
[10:27:21.530]         else {
[10:27:21.530]             ...future.result["stdout"] <- base::list(NULL)
[10:27:21.530]         }
[10:27:21.530]         base::close(...future.stdout)
[10:27:21.530]         ...future.stdout <- NULL
[10:27:21.530]     }
[10:27:21.530]     ...future.result$conditions <- ...future.conditions
[10:27:21.530]     ...future.result$finished <- base::Sys.time()
[10:27:21.530]     ...future.result
[10:27:21.530] }
[10:27:21.533] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[10:27:21.533] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[10:27:21.533] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[10:27:21.533] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[10:27:21.534] MultisessionFuture started
[10:27:21.534] - Launch lazy future ... done
[10:27:21.534] run() for ‘MultisessionFuture’ ... done
[10:27:21.534] getGlobalsAndPackages() ...
[10:27:21.534] Searching for globals...
[10:27:21.535] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:27:21.535] Searching for globals ... DONE
[10:27:21.536] Resolving globals: FALSE
[10:27:21.536] The total size of the 1 globals is 56 bytes (56 bytes)
[10:27:21.536] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[10:27:21.536] - globals: [1] ‘kk’
[10:27:21.537] 
[10:27:21.537] getGlobalsAndPackages() ... DONE
[10:27:21.537] run() for ‘Future’ ...
[10:27:21.537] - state: ‘created’
[10:27:21.537] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:21.552] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:21.553] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:21.553]   - Field: ‘node’
[10:27:21.553]   - Field: ‘label’
[10:27:21.553]   - Field: ‘local’
[10:27:21.553]   - Field: ‘owner’
[10:27:21.553]   - Field: ‘envir’
[10:27:21.553]   - Field: ‘workers’
[10:27:21.553]   - Field: ‘packages’
[10:27:21.554]   - Field: ‘gc’
[10:27:21.554]   - Field: ‘conditions’
[10:27:21.554]   - Field: ‘persistent’
[10:27:21.554]   - Field: ‘expr’
[10:27:21.554]   - Field: ‘uuid’
[10:27:21.554]   - Field: ‘seed’
[10:27:21.554]   - Field: ‘version’
[10:27:21.554]   - Field: ‘result’
[10:27:21.554]   - Field: ‘asynchronous’
[10:27:21.554]   - Field: ‘calls’
[10:27:21.557]   - Field: ‘globals’
[10:27:21.558]   - Field: ‘stdout’
[10:27:21.558]   - Field: ‘earlySignal’
[10:27:21.558]   - Field: ‘lazy’
[10:27:21.558]   - Field: ‘state’
[10:27:21.558] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:21.558] - Launch lazy future ...
[10:27:21.559] Packages needed by the future expression (n = 0): <none>
[10:27:21.559] Packages needed by future strategies (n = 0): <none>
[10:27:21.559] {
[10:27:21.559]     {
[10:27:21.559]         {
[10:27:21.559]             ...future.startTime <- base::Sys.time()
[10:27:21.559]             {
[10:27:21.559]                 {
[10:27:21.559]                   {
[10:27:21.559]                     {
[10:27:21.559]                       base::local({
[10:27:21.559]                         has_future <- base::requireNamespace("future", 
[10:27:21.559]                           quietly = TRUE)
[10:27:21.559]                         if (has_future) {
[10:27:21.559]                           ns <- base::getNamespace("future")
[10:27:21.559]                           version <- ns[[".package"]][["version"]]
[10:27:21.559]                           if (is.null(version)) 
[10:27:21.559]                             version <- utils::packageVersion("future")
[10:27:21.559]                         }
[10:27:21.559]                         else {
[10:27:21.559]                           version <- NULL
[10:27:21.559]                         }
[10:27:21.559]                         if (!has_future || version < "1.8.0") {
[10:27:21.559]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:21.559]                             "", base::R.version$version.string), 
[10:27:21.559]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:21.559]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:21.559]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:21.559]                               "release", "version")], collapse = " "), 
[10:27:21.559]                             hostname = base::Sys.info()[["nodename"]])
[10:27:21.559]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:21.559]                             info)
[10:27:21.559]                           info <- base::paste(info, collapse = "; ")
[10:27:21.559]                           if (!has_future) {
[10:27:21.559]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:21.559]                               info)
[10:27:21.559]                           }
[10:27:21.559]                           else {
[10:27:21.559]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:21.559]                               info, version)
[10:27:21.559]                           }
[10:27:21.559]                           base::stop(msg)
[10:27:21.559]                         }
[10:27:21.559]                       })
[10:27:21.559]                     }
[10:27:21.559]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:21.559]                     base::options(mc.cores = 1L)
[10:27:21.559]                   }
[10:27:21.559]                   options(future.plan = NULL)
[10:27:21.559]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:21.559]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:21.559]                 }
[10:27:21.559]                 ...future.workdir <- getwd()
[10:27:21.559]             }
[10:27:21.559]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:21.559]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:21.559]         }
[10:27:21.559]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:21.559]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:21.559]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:21.559]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:21.559]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:21.559]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:21.559]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:21.559]             base::names(...future.oldOptions))
[10:27:21.559]     }
[10:27:21.559]     if (FALSE) {
[10:27:21.559]     }
[10:27:21.559]     else {
[10:27:21.559]         if (TRUE) {
[10:27:21.559]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:21.559]                 open = "w")
[10:27:21.559]         }
[10:27:21.559]         else {
[10:27:21.559]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:21.559]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:21.559]         }
[10:27:21.559]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:21.559]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:21.559]             base::sink(type = "output", split = FALSE)
[10:27:21.559]             base::close(...future.stdout)
[10:27:21.559]         }, add = TRUE)
[10:27:21.559]     }
[10:27:21.559]     ...future.frame <- base::sys.nframe()
[10:27:21.559]     ...future.conditions <- base::list()
[10:27:21.559]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:21.559]     if (FALSE) {
[10:27:21.559]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:21.559]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:21.559]     }
[10:27:21.559]     ...future.result <- base::tryCatch({
[10:27:21.559]         base::withCallingHandlers({
[10:27:21.559]             ...future.value <- base::withVisible(base::local({
[10:27:21.559]                 ...future.makeSendCondition <- base::local({
[10:27:21.559]                   sendCondition <- NULL
[10:27:21.559]                   function(frame = 1L) {
[10:27:21.559]                     if (is.function(sendCondition)) 
[10:27:21.559]                       return(sendCondition)
[10:27:21.559]                     ns <- getNamespace("parallel")
[10:27:21.559]                     if (exists("sendData", mode = "function", 
[10:27:21.559]                       envir = ns)) {
[10:27:21.559]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:21.559]                         envir = ns)
[10:27:21.559]                       envir <- sys.frame(frame)
[10:27:21.559]                       master <- NULL
[10:27:21.559]                       while (!identical(envir, .GlobalEnv) && 
[10:27:21.559]                         !identical(envir, emptyenv())) {
[10:27:21.559]                         if (exists("master", mode = "list", envir = envir, 
[10:27:21.559]                           inherits = FALSE)) {
[10:27:21.559]                           master <- get("master", mode = "list", 
[10:27:21.559]                             envir = envir, inherits = FALSE)
[10:27:21.559]                           if (inherits(master, c("SOCKnode", 
[10:27:21.559]                             "SOCK0node"))) {
[10:27:21.559]                             sendCondition <<- function(cond) {
[10:27:21.559]                               data <- list(type = "VALUE", value = cond, 
[10:27:21.559]                                 success = TRUE)
[10:27:21.559]                               parallel_sendData(master, data)
[10:27:21.559]                             }
[10:27:21.559]                             return(sendCondition)
[10:27:21.559]                           }
[10:27:21.559]                         }
[10:27:21.559]                         frame <- frame + 1L
[10:27:21.559]                         envir <- sys.frame(frame)
[10:27:21.559]                       }
[10:27:21.559]                     }
[10:27:21.559]                     sendCondition <<- function(cond) NULL
[10:27:21.559]                   }
[10:27:21.559]                 })
[10:27:21.559]                 withCallingHandlers({
[10:27:21.559]                   {
[10:27:21.559]                     Sys.sleep(0.1)
[10:27:21.559]                     kk
[10:27:21.559]                   }
[10:27:21.559]                 }, immediateCondition = function(cond) {
[10:27:21.559]                   sendCondition <- ...future.makeSendCondition()
[10:27:21.559]                   sendCondition(cond)
[10:27:21.559]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:21.559]                   {
[10:27:21.559]                     inherits <- base::inherits
[10:27:21.559]                     invokeRestart <- base::invokeRestart
[10:27:21.559]                     is.null <- base::is.null
[10:27:21.559]                     muffled <- FALSE
[10:27:21.559]                     if (inherits(cond, "message")) {
[10:27:21.559]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:21.559]                       if (muffled) 
[10:27:21.559]                         invokeRestart("muffleMessage")
[10:27:21.559]                     }
[10:27:21.559]                     else if (inherits(cond, "warning")) {
[10:27:21.559]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:21.559]                       if (muffled) 
[10:27:21.559]                         invokeRestart("muffleWarning")
[10:27:21.559]                     }
[10:27:21.559]                     else if (inherits(cond, "condition")) {
[10:27:21.559]                       if (!is.null(pattern)) {
[10:27:21.559]                         computeRestarts <- base::computeRestarts
[10:27:21.559]                         grepl <- base::grepl
[10:27:21.559]                         restarts <- computeRestarts(cond)
[10:27:21.559]                         for (restart in restarts) {
[10:27:21.559]                           name <- restart$name
[10:27:21.559]                           if (is.null(name)) 
[10:27:21.559]                             next
[10:27:21.559]                           if (!grepl(pattern, name)) 
[10:27:21.559]                             next
[10:27:21.559]                           invokeRestart(restart)
[10:27:21.559]                           muffled <- TRUE
[10:27:21.559]                           break
[10:27:21.559]                         }
[10:27:21.559]                       }
[10:27:21.559]                     }
[10:27:21.559]                     invisible(muffled)
[10:27:21.559]                   }
[10:27:21.559]                   muffleCondition(cond)
[10:27:21.559]                 })
[10:27:21.559]             }))
[10:27:21.559]             future::FutureResult(value = ...future.value$value, 
[10:27:21.559]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:21.559]                   ...future.rng), globalenv = if (FALSE) 
[10:27:21.559]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:21.559]                     ...future.globalenv.names))
[10:27:21.559]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:21.559]         }, condition = base::local({
[10:27:21.559]             c <- base::c
[10:27:21.559]             inherits <- base::inherits
[10:27:21.559]             invokeRestart <- base::invokeRestart
[10:27:21.559]             length <- base::length
[10:27:21.559]             list <- base::list
[10:27:21.559]             seq.int <- base::seq.int
[10:27:21.559]             signalCondition <- base::signalCondition
[10:27:21.559]             sys.calls <- base::sys.calls
[10:27:21.559]             `[[` <- base::`[[`
[10:27:21.559]             `+` <- base::`+`
[10:27:21.559]             `<<-` <- base::`<<-`
[10:27:21.559]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:21.559]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:21.559]                   3L)]
[10:27:21.559]             }
[10:27:21.559]             function(cond) {
[10:27:21.559]                 is_error <- inherits(cond, "error")
[10:27:21.559]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:21.559]                   NULL)
[10:27:21.559]                 if (is_error) {
[10:27:21.559]                   sessionInformation <- function() {
[10:27:21.559]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:21.559]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:21.559]                       search = base::search(), system = base::Sys.info())
[10:27:21.559]                   }
[10:27:21.559]                   ...future.conditions[[length(...future.conditions) + 
[10:27:21.559]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:21.559]                     cond$call), session = sessionInformation(), 
[10:27:21.559]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:21.559]                   signalCondition(cond)
[10:27:21.559]                 }
[10:27:21.559]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:21.559]                 "immediateCondition"))) {
[10:27:21.559]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:21.559]                   ...future.conditions[[length(...future.conditions) + 
[10:27:21.559]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:21.559]                   if (TRUE && !signal) {
[10:27:21.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:21.559]                     {
[10:27:21.559]                       inherits <- base::inherits
[10:27:21.559]                       invokeRestart <- base::invokeRestart
[10:27:21.559]                       is.null <- base::is.null
[10:27:21.559]                       muffled <- FALSE
[10:27:21.559]                       if (inherits(cond, "message")) {
[10:27:21.559]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:21.559]                         if (muffled) 
[10:27:21.559]                           invokeRestart("muffleMessage")
[10:27:21.559]                       }
[10:27:21.559]                       else if (inherits(cond, "warning")) {
[10:27:21.559]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:21.559]                         if (muffled) 
[10:27:21.559]                           invokeRestart("muffleWarning")
[10:27:21.559]                       }
[10:27:21.559]                       else if (inherits(cond, "condition")) {
[10:27:21.559]                         if (!is.null(pattern)) {
[10:27:21.559]                           computeRestarts <- base::computeRestarts
[10:27:21.559]                           grepl <- base::grepl
[10:27:21.559]                           restarts <- computeRestarts(cond)
[10:27:21.559]                           for (restart in restarts) {
[10:27:21.559]                             name <- restart$name
[10:27:21.559]                             if (is.null(name)) 
[10:27:21.559]                               next
[10:27:21.559]                             if (!grepl(pattern, name)) 
[10:27:21.559]                               next
[10:27:21.559]                             invokeRestart(restart)
[10:27:21.559]                             muffled <- TRUE
[10:27:21.559]                             break
[10:27:21.559]                           }
[10:27:21.559]                         }
[10:27:21.559]                       }
[10:27:21.559]                       invisible(muffled)
[10:27:21.559]                     }
[10:27:21.559]                     muffleCondition(cond, pattern = "^muffle")
[10:27:21.559]                   }
[10:27:21.559]                 }
[10:27:21.559]                 else {
[10:27:21.559]                   if (TRUE) {
[10:27:21.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:21.559]                     {
[10:27:21.559]                       inherits <- base::inherits
[10:27:21.559]                       invokeRestart <- base::invokeRestart
[10:27:21.559]                       is.null <- base::is.null
[10:27:21.559]                       muffled <- FALSE
[10:27:21.559]                       if (inherits(cond, "message")) {
[10:27:21.559]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:21.559]                         if (muffled) 
[10:27:21.559]                           invokeRestart("muffleMessage")
[10:27:21.559]                       }
[10:27:21.559]                       else if (inherits(cond, "warning")) {
[10:27:21.559]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:21.559]                         if (muffled) 
[10:27:21.559]                           invokeRestart("muffleWarning")
[10:27:21.559]                       }
[10:27:21.559]                       else if (inherits(cond, "condition")) {
[10:27:21.559]                         if (!is.null(pattern)) {
[10:27:21.559]                           computeRestarts <- base::computeRestarts
[10:27:21.559]                           grepl <- base::grepl
[10:27:21.559]                           restarts <- computeRestarts(cond)
[10:27:21.559]                           for (restart in restarts) {
[10:27:21.559]                             name <- restart$name
[10:27:21.559]                             if (is.null(name)) 
[10:27:21.559]                               next
[10:27:21.559]                             if (!grepl(pattern, name)) 
[10:27:21.559]                               next
[10:27:21.559]                             invokeRestart(restart)
[10:27:21.559]                             muffled <- TRUE
[10:27:21.559]                             break
[10:27:21.559]                           }
[10:27:21.559]                         }
[10:27:21.559]                       }
[10:27:21.559]                       invisible(muffled)
[10:27:21.559]                     }
[10:27:21.559]                     muffleCondition(cond, pattern = "^muffle")
[10:27:21.559]                   }
[10:27:21.559]                 }
[10:27:21.559]             }
[10:27:21.559]         }))
[10:27:21.559]     }, error = function(ex) {
[10:27:21.559]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:21.559]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:21.559]                 ...future.rng), started = ...future.startTime, 
[10:27:21.559]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:21.559]             version = "1.8"), class = "FutureResult")
[10:27:21.559]     }, finally = {
[10:27:21.559]         if (!identical(...future.workdir, getwd())) 
[10:27:21.559]             setwd(...future.workdir)
[10:27:21.559]         {
[10:27:21.559]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:21.559]                 ...future.oldOptions$nwarnings <- NULL
[10:27:21.559]             }
[10:27:21.559]             base::options(...future.oldOptions)
[10:27:21.559]             if (.Platform$OS.type == "windows") {
[10:27:21.559]                 old_names <- names(...future.oldEnvVars)
[10:27:21.559]                 envs <- base::Sys.getenv()
[10:27:21.559]                 names <- names(envs)
[10:27:21.559]                 common <- intersect(names, old_names)
[10:27:21.559]                 added <- setdiff(names, old_names)
[10:27:21.559]                 removed <- setdiff(old_names, names)
[10:27:21.559]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:21.559]                   envs[common]]
[10:27:21.559]                 NAMES <- toupper(changed)
[10:27:21.559]                 args <- list()
[10:27:21.559]                 for (kk in seq_along(NAMES)) {
[10:27:21.559]                   name <- changed[[kk]]
[10:27:21.559]                   NAME <- NAMES[[kk]]
[10:27:21.559]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:21.559]                     next
[10:27:21.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:21.559]                 }
[10:27:21.559]                 NAMES <- toupper(added)
[10:27:21.559]                 for (kk in seq_along(NAMES)) {
[10:27:21.559]                   name <- added[[kk]]
[10:27:21.559]                   NAME <- NAMES[[kk]]
[10:27:21.559]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:21.559]                     next
[10:27:21.559]                   args[[name]] <- ""
[10:27:21.559]                 }
[10:27:21.559]                 NAMES <- toupper(removed)
[10:27:21.559]                 for (kk in seq_along(NAMES)) {
[10:27:21.559]                   name <- removed[[kk]]
[10:27:21.559]                   NAME <- NAMES[[kk]]
[10:27:21.559]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:21.559]                     next
[10:27:21.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:21.559]                 }
[10:27:21.559]                 if (length(args) > 0) 
[10:27:21.559]                   base::do.call(base::Sys.setenv, args = args)
[10:27:21.559]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:21.559]             }
[10:27:21.559]             else {
[10:27:21.559]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:21.559]             }
[10:27:21.559]             {
[10:27:21.559]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:21.559]                   0L) {
[10:27:21.559]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:21.559]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:21.559]                   base::options(opts)
[10:27:21.559]                 }
[10:27:21.559]                 {
[10:27:21.559]                   {
[10:27:21.559]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:21.559]                     NULL
[10:27:21.559]                   }
[10:27:21.559]                   options(future.plan = NULL)
[10:27:21.559]                   if (is.na(NA_character_)) 
[10:27:21.559]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:21.559]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:21.559]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:21.559]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:21.559]                     envir = parent.frame()) 
[10:27:21.559]                   {
[10:27:21.559]                     if (is.function(workers)) 
[10:27:21.559]                       workers <- workers()
[10:27:21.559]                     workers <- structure(as.integer(workers), 
[10:27:21.559]                       class = class(workers))
[10:27:21.559]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:21.559]                       workers >= 1)
[10:27:21.559]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:21.559]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:21.559]                     }
[10:27:21.559]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:21.559]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:21.559]                       envir = envir)
[10:27:21.559]                     if (!future$lazy) 
[10:27:21.559]                       future <- run(future)
[10:27:21.559]                     invisible(future)
[10:27:21.559]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:21.559]                 }
[10:27:21.559]             }
[10:27:21.559]         }
[10:27:21.559]     })
[10:27:21.559]     if (TRUE) {
[10:27:21.559]         base::sink(type = "output", split = FALSE)
[10:27:21.559]         if (TRUE) {
[10:27:21.559]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:21.559]         }
[10:27:21.559]         else {
[10:27:21.559]             ...future.result["stdout"] <- base::list(NULL)
[10:27:21.559]         }
[10:27:21.559]         base::close(...future.stdout)
[10:27:21.559]         ...future.stdout <- NULL
[10:27:21.559]     }
[10:27:21.559]     ...future.result$conditions <- ...future.conditions
[10:27:21.559]     ...future.result$finished <- base::Sys.time()
[10:27:21.559]     ...future.result
[10:27:21.559] }
[10:27:21.562] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[10:27:21.562] Exporting ‘kk’ (56 bytes) to cluster node #2 ...
[10:27:21.563] Exporting ‘kk’ (56 bytes) to cluster node #2 ... DONE
[10:27:21.563] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[10:27:21.564] MultisessionFuture started
[10:27:21.564] - Launch lazy future ... done
[10:27:21.564] run() for ‘MultisessionFuture’ ... done
[10:27:21.564] getGlobalsAndPackages() ...
[10:27:21.564] Searching for globals...
[10:27:21.565] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:27:21.565] Searching for globals ... DONE
[10:27:21.565] Resolving globals: FALSE
[10:27:21.566] The total size of the 1 globals is 56 bytes (56 bytes)
[10:27:21.566] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[10:27:21.566] - globals: [1] ‘kk’
[10:27:21.566] 
[10:27:21.566] getGlobalsAndPackages() ... DONE
[10:27:21.567] run() for ‘Future’ ...
[10:27:21.567] - state: ‘created’
[10:27:21.567] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:21.582] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:21.582] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:21.582]   - Field: ‘node’
[10:27:21.582]   - Field: ‘label’
[10:27:21.582]   - Field: ‘local’
[10:27:21.582]   - Field: ‘owner’
[10:27:21.582]   - Field: ‘envir’
[10:27:21.583]   - Field: ‘workers’
[10:27:21.583]   - Field: ‘packages’
[10:27:21.583]   - Field: ‘gc’
[10:27:21.583]   - Field: ‘conditions’
[10:27:21.583]   - Field: ‘persistent’
[10:27:21.583]   - Field: ‘expr’
[10:27:21.583]   - Field: ‘uuid’
[10:27:21.583]   - Field: ‘seed’
[10:27:21.583]   - Field: ‘version’
[10:27:21.583]   - Field: ‘result’
[10:27:21.583]   - Field: ‘asynchronous’
[10:27:21.584]   - Field: ‘calls’
[10:27:21.584]   - Field: ‘globals’
[10:27:21.584]   - Field: ‘stdout’
[10:27:21.584]   - Field: ‘earlySignal’
[10:27:21.584]   - Field: ‘lazy’
[10:27:21.584]   - Field: ‘state’
[10:27:21.584] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:21.584] - Launch lazy future ...
[10:27:21.585] Packages needed by the future expression (n = 0): <none>
[10:27:21.585] Packages needed by future strategies (n = 0): <none>
[10:27:21.585] {
[10:27:21.585]     {
[10:27:21.585]         {
[10:27:21.585]             ...future.startTime <- base::Sys.time()
[10:27:21.585]             {
[10:27:21.585]                 {
[10:27:21.585]                   {
[10:27:21.585]                     {
[10:27:21.585]                       base::local({
[10:27:21.585]                         has_future <- base::requireNamespace("future", 
[10:27:21.585]                           quietly = TRUE)
[10:27:21.585]                         if (has_future) {
[10:27:21.585]                           ns <- base::getNamespace("future")
[10:27:21.585]                           version <- ns[[".package"]][["version"]]
[10:27:21.585]                           if (is.null(version)) 
[10:27:21.585]                             version <- utils::packageVersion("future")
[10:27:21.585]                         }
[10:27:21.585]                         else {
[10:27:21.585]                           version <- NULL
[10:27:21.585]                         }
[10:27:21.585]                         if (!has_future || version < "1.8.0") {
[10:27:21.585]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:21.585]                             "", base::R.version$version.string), 
[10:27:21.585]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:21.585]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:21.585]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:21.585]                               "release", "version")], collapse = " "), 
[10:27:21.585]                             hostname = base::Sys.info()[["nodename"]])
[10:27:21.585]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:21.585]                             info)
[10:27:21.585]                           info <- base::paste(info, collapse = "; ")
[10:27:21.585]                           if (!has_future) {
[10:27:21.585]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:21.585]                               info)
[10:27:21.585]                           }
[10:27:21.585]                           else {
[10:27:21.585]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:21.585]                               info, version)
[10:27:21.585]                           }
[10:27:21.585]                           base::stop(msg)
[10:27:21.585]                         }
[10:27:21.585]                       })
[10:27:21.585]                     }
[10:27:21.585]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:21.585]                     base::options(mc.cores = 1L)
[10:27:21.585]                   }
[10:27:21.585]                   options(future.plan = NULL)
[10:27:21.585]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:21.585]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:21.585]                 }
[10:27:21.585]                 ...future.workdir <- getwd()
[10:27:21.585]             }
[10:27:21.585]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:21.585]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:21.585]         }
[10:27:21.585]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:21.585]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:21.585]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:21.585]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:21.585]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:21.585]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:21.585]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:21.585]             base::names(...future.oldOptions))
[10:27:21.585]     }
[10:27:21.585]     if (FALSE) {
[10:27:21.585]     }
[10:27:21.585]     else {
[10:27:21.585]         if (TRUE) {
[10:27:21.585]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:21.585]                 open = "w")
[10:27:21.585]         }
[10:27:21.585]         else {
[10:27:21.585]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:21.585]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:21.585]         }
[10:27:21.585]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:21.585]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:21.585]             base::sink(type = "output", split = FALSE)
[10:27:21.585]             base::close(...future.stdout)
[10:27:21.585]         }, add = TRUE)
[10:27:21.585]     }
[10:27:21.585]     ...future.frame <- base::sys.nframe()
[10:27:21.585]     ...future.conditions <- base::list()
[10:27:21.585]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:21.585]     if (FALSE) {
[10:27:21.585]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:21.585]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:21.585]     }
[10:27:21.585]     ...future.result <- base::tryCatch({
[10:27:21.585]         base::withCallingHandlers({
[10:27:21.585]             ...future.value <- base::withVisible(base::local({
[10:27:21.585]                 ...future.makeSendCondition <- base::local({
[10:27:21.585]                   sendCondition <- NULL
[10:27:21.585]                   function(frame = 1L) {
[10:27:21.585]                     if (is.function(sendCondition)) 
[10:27:21.585]                       return(sendCondition)
[10:27:21.585]                     ns <- getNamespace("parallel")
[10:27:21.585]                     if (exists("sendData", mode = "function", 
[10:27:21.585]                       envir = ns)) {
[10:27:21.585]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:21.585]                         envir = ns)
[10:27:21.585]                       envir <- sys.frame(frame)
[10:27:21.585]                       master <- NULL
[10:27:21.585]                       while (!identical(envir, .GlobalEnv) && 
[10:27:21.585]                         !identical(envir, emptyenv())) {
[10:27:21.585]                         if (exists("master", mode = "list", envir = envir, 
[10:27:21.585]                           inherits = FALSE)) {
[10:27:21.585]                           master <- get("master", mode = "list", 
[10:27:21.585]                             envir = envir, inherits = FALSE)
[10:27:21.585]                           if (inherits(master, c("SOCKnode", 
[10:27:21.585]                             "SOCK0node"))) {
[10:27:21.585]                             sendCondition <<- function(cond) {
[10:27:21.585]                               data <- list(type = "VALUE", value = cond, 
[10:27:21.585]                                 success = TRUE)
[10:27:21.585]                               parallel_sendData(master, data)
[10:27:21.585]                             }
[10:27:21.585]                             return(sendCondition)
[10:27:21.585]                           }
[10:27:21.585]                         }
[10:27:21.585]                         frame <- frame + 1L
[10:27:21.585]                         envir <- sys.frame(frame)
[10:27:21.585]                       }
[10:27:21.585]                     }
[10:27:21.585]                     sendCondition <<- function(cond) NULL
[10:27:21.585]                   }
[10:27:21.585]                 })
[10:27:21.585]                 withCallingHandlers({
[10:27:21.585]                   {
[10:27:21.585]                     Sys.sleep(0.1)
[10:27:21.585]                     kk
[10:27:21.585]                   }
[10:27:21.585]                 }, immediateCondition = function(cond) {
[10:27:21.585]                   sendCondition <- ...future.makeSendCondition()
[10:27:21.585]                   sendCondition(cond)
[10:27:21.585]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:21.585]                   {
[10:27:21.585]                     inherits <- base::inherits
[10:27:21.585]                     invokeRestart <- base::invokeRestart
[10:27:21.585]                     is.null <- base::is.null
[10:27:21.585]                     muffled <- FALSE
[10:27:21.585]                     if (inherits(cond, "message")) {
[10:27:21.585]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:21.585]                       if (muffled) 
[10:27:21.585]                         invokeRestart("muffleMessage")
[10:27:21.585]                     }
[10:27:21.585]                     else if (inherits(cond, "warning")) {
[10:27:21.585]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:21.585]                       if (muffled) 
[10:27:21.585]                         invokeRestart("muffleWarning")
[10:27:21.585]                     }
[10:27:21.585]                     else if (inherits(cond, "condition")) {
[10:27:21.585]                       if (!is.null(pattern)) {
[10:27:21.585]                         computeRestarts <- base::computeRestarts
[10:27:21.585]                         grepl <- base::grepl
[10:27:21.585]                         restarts <- computeRestarts(cond)
[10:27:21.585]                         for (restart in restarts) {
[10:27:21.585]                           name <- restart$name
[10:27:21.585]                           if (is.null(name)) 
[10:27:21.585]                             next
[10:27:21.585]                           if (!grepl(pattern, name)) 
[10:27:21.585]                             next
[10:27:21.585]                           invokeRestart(restart)
[10:27:21.585]                           muffled <- TRUE
[10:27:21.585]                           break
[10:27:21.585]                         }
[10:27:21.585]                       }
[10:27:21.585]                     }
[10:27:21.585]                     invisible(muffled)
[10:27:21.585]                   }
[10:27:21.585]                   muffleCondition(cond)
[10:27:21.585]                 })
[10:27:21.585]             }))
[10:27:21.585]             future::FutureResult(value = ...future.value$value, 
[10:27:21.585]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:21.585]                   ...future.rng), globalenv = if (FALSE) 
[10:27:21.585]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:21.585]                     ...future.globalenv.names))
[10:27:21.585]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:21.585]         }, condition = base::local({
[10:27:21.585]             c <- base::c
[10:27:21.585]             inherits <- base::inherits
[10:27:21.585]             invokeRestart <- base::invokeRestart
[10:27:21.585]             length <- base::length
[10:27:21.585]             list <- base::list
[10:27:21.585]             seq.int <- base::seq.int
[10:27:21.585]             signalCondition <- base::signalCondition
[10:27:21.585]             sys.calls <- base::sys.calls
[10:27:21.585]             `[[` <- base::`[[`
[10:27:21.585]             `+` <- base::`+`
[10:27:21.585]             `<<-` <- base::`<<-`
[10:27:21.585]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:21.585]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:21.585]                   3L)]
[10:27:21.585]             }
[10:27:21.585]             function(cond) {
[10:27:21.585]                 is_error <- inherits(cond, "error")
[10:27:21.585]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:21.585]                   NULL)
[10:27:21.585]                 if (is_error) {
[10:27:21.585]                   sessionInformation <- function() {
[10:27:21.585]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:21.585]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:21.585]                       search = base::search(), system = base::Sys.info())
[10:27:21.585]                   }
[10:27:21.585]                   ...future.conditions[[length(...future.conditions) + 
[10:27:21.585]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:21.585]                     cond$call), session = sessionInformation(), 
[10:27:21.585]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:21.585]                   signalCondition(cond)
[10:27:21.585]                 }
[10:27:21.585]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:21.585]                 "immediateCondition"))) {
[10:27:21.585]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:21.585]                   ...future.conditions[[length(...future.conditions) + 
[10:27:21.585]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:21.585]                   if (TRUE && !signal) {
[10:27:21.585]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:21.585]                     {
[10:27:21.585]                       inherits <- base::inherits
[10:27:21.585]                       invokeRestart <- base::invokeRestart
[10:27:21.585]                       is.null <- base::is.null
[10:27:21.585]                       muffled <- FALSE
[10:27:21.585]                       if (inherits(cond, "message")) {
[10:27:21.585]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:21.585]                         if (muffled) 
[10:27:21.585]                           invokeRestart("muffleMessage")
[10:27:21.585]                       }
[10:27:21.585]                       else if (inherits(cond, "warning")) {
[10:27:21.585]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:21.585]                         if (muffled) 
[10:27:21.585]                           invokeRestart("muffleWarning")
[10:27:21.585]                       }
[10:27:21.585]                       else if (inherits(cond, "condition")) {
[10:27:21.585]                         if (!is.null(pattern)) {
[10:27:21.585]                           computeRestarts <- base::computeRestarts
[10:27:21.585]                           grepl <- base::grepl
[10:27:21.585]                           restarts <- computeRestarts(cond)
[10:27:21.585]                           for (restart in restarts) {
[10:27:21.585]                             name <- restart$name
[10:27:21.585]                             if (is.null(name)) 
[10:27:21.585]                               next
[10:27:21.585]                             if (!grepl(pattern, name)) 
[10:27:21.585]                               next
[10:27:21.585]                             invokeRestart(restart)
[10:27:21.585]                             muffled <- TRUE
[10:27:21.585]                             break
[10:27:21.585]                           }
[10:27:21.585]                         }
[10:27:21.585]                       }
[10:27:21.585]                       invisible(muffled)
[10:27:21.585]                     }
[10:27:21.585]                     muffleCondition(cond, pattern = "^muffle")
[10:27:21.585]                   }
[10:27:21.585]                 }
[10:27:21.585]                 else {
[10:27:21.585]                   if (TRUE) {
[10:27:21.585]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:21.585]                     {
[10:27:21.585]                       inherits <- base::inherits
[10:27:21.585]                       invokeRestart <- base::invokeRestart
[10:27:21.585]                       is.null <- base::is.null
[10:27:21.585]                       muffled <- FALSE
[10:27:21.585]                       if (inherits(cond, "message")) {
[10:27:21.585]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:21.585]                         if (muffled) 
[10:27:21.585]                           invokeRestart("muffleMessage")
[10:27:21.585]                       }
[10:27:21.585]                       else if (inherits(cond, "warning")) {
[10:27:21.585]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:21.585]                         if (muffled) 
[10:27:21.585]                           invokeRestart("muffleWarning")
[10:27:21.585]                       }
[10:27:21.585]                       else if (inherits(cond, "condition")) {
[10:27:21.585]                         if (!is.null(pattern)) {
[10:27:21.585]                           computeRestarts <- base::computeRestarts
[10:27:21.585]                           grepl <- base::grepl
[10:27:21.585]                           restarts <- computeRestarts(cond)
[10:27:21.585]                           for (restart in restarts) {
[10:27:21.585]                             name <- restart$name
[10:27:21.585]                             if (is.null(name)) 
[10:27:21.585]                               next
[10:27:21.585]                             if (!grepl(pattern, name)) 
[10:27:21.585]                               next
[10:27:21.585]                             invokeRestart(restart)
[10:27:21.585]                             muffled <- TRUE
[10:27:21.585]                             break
[10:27:21.585]                           }
[10:27:21.585]                         }
[10:27:21.585]                       }
[10:27:21.585]                       invisible(muffled)
[10:27:21.585]                     }
[10:27:21.585]                     muffleCondition(cond, pattern = "^muffle")
[10:27:21.585]                   }
[10:27:21.585]                 }
[10:27:21.585]             }
[10:27:21.585]         }))
[10:27:21.585]     }, error = function(ex) {
[10:27:21.585]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:21.585]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:21.585]                 ...future.rng), started = ...future.startTime, 
[10:27:21.585]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:21.585]             version = "1.8"), class = "FutureResult")
[10:27:21.585]     }, finally = {
[10:27:21.585]         if (!identical(...future.workdir, getwd())) 
[10:27:21.585]             setwd(...future.workdir)
[10:27:21.585]         {
[10:27:21.585]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:21.585]                 ...future.oldOptions$nwarnings <- NULL
[10:27:21.585]             }
[10:27:21.585]             base::options(...future.oldOptions)
[10:27:21.585]             if (.Platform$OS.type == "windows") {
[10:27:21.585]                 old_names <- names(...future.oldEnvVars)
[10:27:21.585]                 envs <- base::Sys.getenv()
[10:27:21.585]                 names <- names(envs)
[10:27:21.585]                 common <- intersect(names, old_names)
[10:27:21.585]                 added <- setdiff(names, old_names)
[10:27:21.585]                 removed <- setdiff(old_names, names)
[10:27:21.585]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:21.585]                   envs[common]]
[10:27:21.585]                 NAMES <- toupper(changed)
[10:27:21.585]                 args <- list()
[10:27:21.585]                 for (kk in seq_along(NAMES)) {
[10:27:21.585]                   name <- changed[[kk]]
[10:27:21.585]                   NAME <- NAMES[[kk]]
[10:27:21.585]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:21.585]                     next
[10:27:21.585]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:21.585]                 }
[10:27:21.585]                 NAMES <- toupper(added)
[10:27:21.585]                 for (kk in seq_along(NAMES)) {
[10:27:21.585]                   name <- added[[kk]]
[10:27:21.585]                   NAME <- NAMES[[kk]]
[10:27:21.585]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:21.585]                     next
[10:27:21.585]                   args[[name]] <- ""
[10:27:21.585]                 }
[10:27:21.585]                 NAMES <- toupper(removed)
[10:27:21.585]                 for (kk in seq_along(NAMES)) {
[10:27:21.585]                   name <- removed[[kk]]
[10:27:21.585]                   NAME <- NAMES[[kk]]
[10:27:21.585]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:21.585]                     next
[10:27:21.585]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:21.585]                 }
[10:27:21.585]                 if (length(args) > 0) 
[10:27:21.585]                   base::do.call(base::Sys.setenv, args = args)
[10:27:21.585]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:21.585]             }
[10:27:21.585]             else {
[10:27:21.585]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:21.585]             }
[10:27:21.585]             {
[10:27:21.585]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:21.585]                   0L) {
[10:27:21.585]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:21.585]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:21.585]                   base::options(opts)
[10:27:21.585]                 }
[10:27:21.585]                 {
[10:27:21.585]                   {
[10:27:21.585]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:21.585]                     NULL
[10:27:21.585]                   }
[10:27:21.585]                   options(future.plan = NULL)
[10:27:21.585]                   if (is.na(NA_character_)) 
[10:27:21.585]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:21.585]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:21.585]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:21.585]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:21.585]                     envir = parent.frame()) 
[10:27:21.585]                   {
[10:27:21.585]                     if (is.function(workers)) 
[10:27:21.585]                       workers <- workers()
[10:27:21.585]                     workers <- structure(as.integer(workers), 
[10:27:21.585]                       class = class(workers))
[10:27:21.585]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:21.585]                       workers >= 1)
[10:27:21.585]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:21.585]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:21.585]                     }
[10:27:21.585]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:21.585]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:21.585]                       envir = envir)
[10:27:21.585]                     if (!future$lazy) 
[10:27:21.585]                       future <- run(future)
[10:27:21.585]                     invisible(future)
[10:27:21.585]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:21.585]                 }
[10:27:21.585]             }
[10:27:21.585]         }
[10:27:21.585]     })
[10:27:21.585]     if (TRUE) {
[10:27:21.585]         base::sink(type = "output", split = FALSE)
[10:27:21.585]         if (TRUE) {
[10:27:21.585]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:21.585]         }
[10:27:21.585]         else {
[10:27:21.585]             ...future.result["stdout"] <- base::list(NULL)
[10:27:21.585]         }
[10:27:21.585]         base::close(...future.stdout)
[10:27:21.585]         ...future.stdout <- NULL
[10:27:21.585]     }
[10:27:21.585]     ...future.result$conditions <- ...future.conditions
[10:27:21.585]     ...future.result$finished <- base::Sys.time()
[10:27:21.585]     ...future.result
[10:27:21.585] }
[10:27:21.587] Poll #1 (0): usedNodes() = 2, workers = 2
[10:27:21.619] Poll #2 (0.03 secs): usedNodes() = 2, workers = 2
[10:27:21.651] Poll #3 (0.06 secs): usedNodes() = 2, workers = 2
[10:27:21.683] Poll #4 (0.1 secs): usedNodes() = 2, workers = 2
[10:27:21.695] receiveMessageFromWorker() for ClusterFuture ...
[10:27:21.695] - Validating connection of MultisessionFuture
[10:27:21.695] - received message: FutureResult
[10:27:21.695] - Received FutureResult
[10:27:21.695] - Erased future from FutureRegistry
[10:27:21.696] result() for ClusterFuture ...
[10:27:21.696] - result already collected: FutureResult
[10:27:21.696] result() for ClusterFuture ... done
[10:27:21.696] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:21.696] result() for ClusterFuture ...
[10:27:21.696] - result already collected: FutureResult
[10:27:21.696] result() for ClusterFuture ... done
[10:27:21.696] result() for ClusterFuture ...
[10:27:21.696] - result already collected: FutureResult
[10:27:21.696] result() for ClusterFuture ... done
[10:27:21.697] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[10:27:21.697] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[10:27:21.698] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[10:27:21.698] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[10:27:21.698] MultisessionFuture started
[10:27:21.699] - Launch lazy future ... done
[10:27:21.699] run() for ‘MultisessionFuture’ ... done
[10:27:21.699] resolve() on list ...
[10:27:21.699]  recursive: 0
[10:27:21.699]  length: 3
[10:27:21.699] 
[10:27:21.699] Future #1
[10:27:21.700]  length: 2 (resolved future 1)
[10:27:21.732] receiveMessageFromWorker() for ClusterFuture ...
[10:27:21.732] - Validating connection of MultisessionFuture
[10:27:21.733] - received message: FutureResult
[10:27:21.733] - Received FutureResult
[10:27:21.733] - Erased future from FutureRegistry
[10:27:21.733] result() for ClusterFuture ...
[10:27:21.733] - result already collected: FutureResult
[10:27:21.733] result() for ClusterFuture ... done
[10:27:21.733] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:21.733] Future #2
[10:27:21.734]  length: 1 (resolved future 2)
[10:27:21.847] receiveMessageFromWorker() for ClusterFuture ...
[10:27:21.847] - Validating connection of MultisessionFuture
[10:27:21.848] - received message: FutureResult
[10:27:21.848] - Received FutureResult
[10:27:21.848] - Erased future from FutureRegistry
[10:27:21.848] result() for ClusterFuture ...
[10:27:21.848] - result already collected: FutureResult
[10:27:21.848] result() for ClusterFuture ... done
[10:27:21.848] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:21.848] Future #3
[10:27:21.848]  length: 0 (resolved future 3)
[10:27:21.849] resolve() on list ... DONE
[10:27:21.849] getGlobalsAndPackages() ...
[10:27:21.849] Searching for globals...
[10:27:21.850] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:27:21.850] Searching for globals ... DONE
[10:27:21.850] Resolving globals: FALSE
[10:27:21.851] The total size of the 1 globals is 56 bytes (56 bytes)
[10:27:21.851] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[10:27:21.851] - globals: [1] ‘kk’
[10:27:21.851] 
[10:27:21.851] getGlobalsAndPackages() ... DONE
[10:27:21.851] getGlobalsAndPackages() ...
[10:27:21.852] Searching for globals...
[10:27:21.852] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:27:21.853] Searching for globals ... DONE
[10:27:21.853] Resolving globals: FALSE
[10:27:21.853] The total size of the 1 globals is 56 bytes (56 bytes)
[10:27:21.853] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[10:27:21.854] - globals: [1] ‘kk’
[10:27:21.854] 
[10:27:21.854] getGlobalsAndPackages() ... DONE
[10:27:21.854] getGlobalsAndPackages() ...
[10:27:21.854] Searching for globals...
[10:27:21.855] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:27:21.855] Searching for globals ... DONE
[10:27:21.855] Resolving globals: FALSE
[10:27:21.856] The total size of the 1 globals is 56 bytes (56 bytes)
[10:27:21.856] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[10:27:21.856] - globals: [1] ‘kk’
[10:27:21.856] 
[10:27:21.856] getGlobalsAndPackages() ... DONE
[10:27:21.857] resolve() on list ...
[10:27:21.857]  recursive: 0
[10:27:21.857]  length: 3
[10:27:21.857] 
[10:27:21.857] run() for ‘Future’ ...
[10:27:21.857] - state: ‘created’
[10:27:21.857] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:21.871] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:21.871] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:21.871]   - Field: ‘node’
[10:27:21.871]   - Field: ‘label’
[10:27:21.871]   - Field: ‘local’
[10:27:21.871]   - Field: ‘owner’
[10:27:21.871]   - Field: ‘envir’
[10:27:21.872]   - Field: ‘workers’
[10:27:21.872]   - Field: ‘packages’
[10:27:21.872]   - Field: ‘gc’
[10:27:21.872]   - Field: ‘conditions’
[10:27:21.872]   - Field: ‘persistent’
[10:27:21.872]   - Field: ‘expr’
[10:27:21.872]   - Field: ‘uuid’
[10:27:21.872]   - Field: ‘seed’
[10:27:21.872]   - Field: ‘version’
[10:27:21.872]   - Field: ‘result’
[10:27:21.872]   - Field: ‘asynchronous’
[10:27:21.873]   - Field: ‘calls’
[10:27:21.873]   - Field: ‘globals’
[10:27:21.873]   - Field: ‘stdout’
[10:27:21.873]   - Field: ‘earlySignal’
[10:27:21.873]   - Field: ‘lazy’
[10:27:21.873]   - Field: ‘state’
[10:27:21.873] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:21.873] - Launch lazy future ...
[10:27:21.874] Packages needed by the future expression (n = 0): <none>
[10:27:21.874] Packages needed by future strategies (n = 0): <none>
[10:27:21.874] {
[10:27:21.874]     {
[10:27:21.874]         {
[10:27:21.874]             ...future.startTime <- base::Sys.time()
[10:27:21.874]             {
[10:27:21.874]                 {
[10:27:21.874]                   {
[10:27:21.874]                     {
[10:27:21.874]                       base::local({
[10:27:21.874]                         has_future <- base::requireNamespace("future", 
[10:27:21.874]                           quietly = TRUE)
[10:27:21.874]                         if (has_future) {
[10:27:21.874]                           ns <- base::getNamespace("future")
[10:27:21.874]                           version <- ns[[".package"]][["version"]]
[10:27:21.874]                           if (is.null(version)) 
[10:27:21.874]                             version <- utils::packageVersion("future")
[10:27:21.874]                         }
[10:27:21.874]                         else {
[10:27:21.874]                           version <- NULL
[10:27:21.874]                         }
[10:27:21.874]                         if (!has_future || version < "1.8.0") {
[10:27:21.874]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:21.874]                             "", base::R.version$version.string), 
[10:27:21.874]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:21.874]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:21.874]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:21.874]                               "release", "version")], collapse = " "), 
[10:27:21.874]                             hostname = base::Sys.info()[["nodename"]])
[10:27:21.874]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:21.874]                             info)
[10:27:21.874]                           info <- base::paste(info, collapse = "; ")
[10:27:21.874]                           if (!has_future) {
[10:27:21.874]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:21.874]                               info)
[10:27:21.874]                           }
[10:27:21.874]                           else {
[10:27:21.874]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:21.874]                               info, version)
[10:27:21.874]                           }
[10:27:21.874]                           base::stop(msg)
[10:27:21.874]                         }
[10:27:21.874]                       })
[10:27:21.874]                     }
[10:27:21.874]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:21.874]                     base::options(mc.cores = 1L)
[10:27:21.874]                   }
[10:27:21.874]                   options(future.plan = NULL)
[10:27:21.874]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:21.874]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:21.874]                 }
[10:27:21.874]                 ...future.workdir <- getwd()
[10:27:21.874]             }
[10:27:21.874]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:21.874]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:21.874]         }
[10:27:21.874]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:21.874]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:21.874]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:21.874]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:21.874]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:21.874]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:21.874]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:21.874]             base::names(...future.oldOptions))
[10:27:21.874]     }
[10:27:21.874]     if (FALSE) {
[10:27:21.874]     }
[10:27:21.874]     else {
[10:27:21.874]         if (TRUE) {
[10:27:21.874]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:21.874]                 open = "w")
[10:27:21.874]         }
[10:27:21.874]         else {
[10:27:21.874]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:21.874]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:21.874]         }
[10:27:21.874]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:21.874]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:21.874]             base::sink(type = "output", split = FALSE)
[10:27:21.874]             base::close(...future.stdout)
[10:27:21.874]         }, add = TRUE)
[10:27:21.874]     }
[10:27:21.874]     ...future.frame <- base::sys.nframe()
[10:27:21.874]     ...future.conditions <- base::list()
[10:27:21.874]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:21.874]     if (FALSE) {
[10:27:21.874]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:21.874]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:21.874]     }
[10:27:21.874]     ...future.result <- base::tryCatch({
[10:27:21.874]         base::withCallingHandlers({
[10:27:21.874]             ...future.value <- base::withVisible(base::local({
[10:27:21.874]                 ...future.makeSendCondition <- base::local({
[10:27:21.874]                   sendCondition <- NULL
[10:27:21.874]                   function(frame = 1L) {
[10:27:21.874]                     if (is.function(sendCondition)) 
[10:27:21.874]                       return(sendCondition)
[10:27:21.874]                     ns <- getNamespace("parallel")
[10:27:21.874]                     if (exists("sendData", mode = "function", 
[10:27:21.874]                       envir = ns)) {
[10:27:21.874]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:21.874]                         envir = ns)
[10:27:21.874]                       envir <- sys.frame(frame)
[10:27:21.874]                       master <- NULL
[10:27:21.874]                       while (!identical(envir, .GlobalEnv) && 
[10:27:21.874]                         !identical(envir, emptyenv())) {
[10:27:21.874]                         if (exists("master", mode = "list", envir = envir, 
[10:27:21.874]                           inherits = FALSE)) {
[10:27:21.874]                           master <- get("master", mode = "list", 
[10:27:21.874]                             envir = envir, inherits = FALSE)
[10:27:21.874]                           if (inherits(master, c("SOCKnode", 
[10:27:21.874]                             "SOCK0node"))) {
[10:27:21.874]                             sendCondition <<- function(cond) {
[10:27:21.874]                               data <- list(type = "VALUE", value = cond, 
[10:27:21.874]                                 success = TRUE)
[10:27:21.874]                               parallel_sendData(master, data)
[10:27:21.874]                             }
[10:27:21.874]                             return(sendCondition)
[10:27:21.874]                           }
[10:27:21.874]                         }
[10:27:21.874]                         frame <- frame + 1L
[10:27:21.874]                         envir <- sys.frame(frame)
[10:27:21.874]                       }
[10:27:21.874]                     }
[10:27:21.874]                     sendCondition <<- function(cond) NULL
[10:27:21.874]                   }
[10:27:21.874]                 })
[10:27:21.874]                 withCallingHandlers({
[10:27:21.874]                   {
[10:27:21.874]                     Sys.sleep(0.1)
[10:27:21.874]                     kk
[10:27:21.874]                   }
[10:27:21.874]                 }, immediateCondition = function(cond) {
[10:27:21.874]                   sendCondition <- ...future.makeSendCondition()
[10:27:21.874]                   sendCondition(cond)
[10:27:21.874]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:21.874]                   {
[10:27:21.874]                     inherits <- base::inherits
[10:27:21.874]                     invokeRestart <- base::invokeRestart
[10:27:21.874]                     is.null <- base::is.null
[10:27:21.874]                     muffled <- FALSE
[10:27:21.874]                     if (inherits(cond, "message")) {
[10:27:21.874]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:21.874]                       if (muffled) 
[10:27:21.874]                         invokeRestart("muffleMessage")
[10:27:21.874]                     }
[10:27:21.874]                     else if (inherits(cond, "warning")) {
[10:27:21.874]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:21.874]                       if (muffled) 
[10:27:21.874]                         invokeRestart("muffleWarning")
[10:27:21.874]                     }
[10:27:21.874]                     else if (inherits(cond, "condition")) {
[10:27:21.874]                       if (!is.null(pattern)) {
[10:27:21.874]                         computeRestarts <- base::computeRestarts
[10:27:21.874]                         grepl <- base::grepl
[10:27:21.874]                         restarts <- computeRestarts(cond)
[10:27:21.874]                         for (restart in restarts) {
[10:27:21.874]                           name <- restart$name
[10:27:21.874]                           if (is.null(name)) 
[10:27:21.874]                             next
[10:27:21.874]                           if (!grepl(pattern, name)) 
[10:27:21.874]                             next
[10:27:21.874]                           invokeRestart(restart)
[10:27:21.874]                           muffled <- TRUE
[10:27:21.874]                           break
[10:27:21.874]                         }
[10:27:21.874]                       }
[10:27:21.874]                     }
[10:27:21.874]                     invisible(muffled)
[10:27:21.874]                   }
[10:27:21.874]                   muffleCondition(cond)
[10:27:21.874]                 })
[10:27:21.874]             }))
[10:27:21.874]             future::FutureResult(value = ...future.value$value, 
[10:27:21.874]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:21.874]                   ...future.rng), globalenv = if (FALSE) 
[10:27:21.874]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:21.874]                     ...future.globalenv.names))
[10:27:21.874]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:21.874]         }, condition = base::local({
[10:27:21.874]             c <- base::c
[10:27:21.874]             inherits <- base::inherits
[10:27:21.874]             invokeRestart <- base::invokeRestart
[10:27:21.874]             length <- base::length
[10:27:21.874]             list <- base::list
[10:27:21.874]             seq.int <- base::seq.int
[10:27:21.874]             signalCondition <- base::signalCondition
[10:27:21.874]             sys.calls <- base::sys.calls
[10:27:21.874]             `[[` <- base::`[[`
[10:27:21.874]             `+` <- base::`+`
[10:27:21.874]             `<<-` <- base::`<<-`
[10:27:21.874]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:21.874]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:21.874]                   3L)]
[10:27:21.874]             }
[10:27:21.874]             function(cond) {
[10:27:21.874]                 is_error <- inherits(cond, "error")
[10:27:21.874]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:21.874]                   NULL)
[10:27:21.874]                 if (is_error) {
[10:27:21.874]                   sessionInformation <- function() {
[10:27:21.874]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:21.874]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:21.874]                       search = base::search(), system = base::Sys.info())
[10:27:21.874]                   }
[10:27:21.874]                   ...future.conditions[[length(...future.conditions) + 
[10:27:21.874]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:21.874]                     cond$call), session = sessionInformation(), 
[10:27:21.874]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:21.874]                   signalCondition(cond)
[10:27:21.874]                 }
[10:27:21.874]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:21.874]                 "immediateCondition"))) {
[10:27:21.874]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:21.874]                   ...future.conditions[[length(...future.conditions) + 
[10:27:21.874]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:21.874]                   if (TRUE && !signal) {
[10:27:21.874]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:21.874]                     {
[10:27:21.874]                       inherits <- base::inherits
[10:27:21.874]                       invokeRestart <- base::invokeRestart
[10:27:21.874]                       is.null <- base::is.null
[10:27:21.874]                       muffled <- FALSE
[10:27:21.874]                       if (inherits(cond, "message")) {
[10:27:21.874]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:21.874]                         if (muffled) 
[10:27:21.874]                           invokeRestart("muffleMessage")
[10:27:21.874]                       }
[10:27:21.874]                       else if (inherits(cond, "warning")) {
[10:27:21.874]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:21.874]                         if (muffled) 
[10:27:21.874]                           invokeRestart("muffleWarning")
[10:27:21.874]                       }
[10:27:21.874]                       else if (inherits(cond, "condition")) {
[10:27:21.874]                         if (!is.null(pattern)) {
[10:27:21.874]                           computeRestarts <- base::computeRestarts
[10:27:21.874]                           grepl <- base::grepl
[10:27:21.874]                           restarts <- computeRestarts(cond)
[10:27:21.874]                           for (restart in restarts) {
[10:27:21.874]                             name <- restart$name
[10:27:21.874]                             if (is.null(name)) 
[10:27:21.874]                               next
[10:27:21.874]                             if (!grepl(pattern, name)) 
[10:27:21.874]                               next
[10:27:21.874]                             invokeRestart(restart)
[10:27:21.874]                             muffled <- TRUE
[10:27:21.874]                             break
[10:27:21.874]                           }
[10:27:21.874]                         }
[10:27:21.874]                       }
[10:27:21.874]                       invisible(muffled)
[10:27:21.874]                     }
[10:27:21.874]                     muffleCondition(cond, pattern = "^muffle")
[10:27:21.874]                   }
[10:27:21.874]                 }
[10:27:21.874]                 else {
[10:27:21.874]                   if (TRUE) {
[10:27:21.874]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:21.874]                     {
[10:27:21.874]                       inherits <- base::inherits
[10:27:21.874]                       invokeRestart <- base::invokeRestart
[10:27:21.874]                       is.null <- base::is.null
[10:27:21.874]                       muffled <- FALSE
[10:27:21.874]                       if (inherits(cond, "message")) {
[10:27:21.874]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:21.874]                         if (muffled) 
[10:27:21.874]                           invokeRestart("muffleMessage")
[10:27:21.874]                       }
[10:27:21.874]                       else if (inherits(cond, "warning")) {
[10:27:21.874]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:21.874]                         if (muffled) 
[10:27:21.874]                           invokeRestart("muffleWarning")
[10:27:21.874]                       }
[10:27:21.874]                       else if (inherits(cond, "condition")) {
[10:27:21.874]                         if (!is.null(pattern)) {
[10:27:21.874]                           computeRestarts <- base::computeRestarts
[10:27:21.874]                           grepl <- base::grepl
[10:27:21.874]                           restarts <- computeRestarts(cond)
[10:27:21.874]                           for (restart in restarts) {
[10:27:21.874]                             name <- restart$name
[10:27:21.874]                             if (is.null(name)) 
[10:27:21.874]                               next
[10:27:21.874]                             if (!grepl(pattern, name)) 
[10:27:21.874]                               next
[10:27:21.874]                             invokeRestart(restart)
[10:27:21.874]                             muffled <- TRUE
[10:27:21.874]                             break
[10:27:21.874]                           }
[10:27:21.874]                         }
[10:27:21.874]                       }
[10:27:21.874]                       invisible(muffled)
[10:27:21.874]                     }
[10:27:21.874]                     muffleCondition(cond, pattern = "^muffle")
[10:27:21.874]                   }
[10:27:21.874]                 }
[10:27:21.874]             }
[10:27:21.874]         }))
[10:27:21.874]     }, error = function(ex) {
[10:27:21.874]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:21.874]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:21.874]                 ...future.rng), started = ...future.startTime, 
[10:27:21.874]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:21.874]             version = "1.8"), class = "FutureResult")
[10:27:21.874]     }, finally = {
[10:27:21.874]         if (!identical(...future.workdir, getwd())) 
[10:27:21.874]             setwd(...future.workdir)
[10:27:21.874]         {
[10:27:21.874]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:21.874]                 ...future.oldOptions$nwarnings <- NULL
[10:27:21.874]             }
[10:27:21.874]             base::options(...future.oldOptions)
[10:27:21.874]             if (.Platform$OS.type == "windows") {
[10:27:21.874]                 old_names <- names(...future.oldEnvVars)
[10:27:21.874]                 envs <- base::Sys.getenv()
[10:27:21.874]                 names <- names(envs)
[10:27:21.874]                 common <- intersect(names, old_names)
[10:27:21.874]                 added <- setdiff(names, old_names)
[10:27:21.874]                 removed <- setdiff(old_names, names)
[10:27:21.874]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:21.874]                   envs[common]]
[10:27:21.874]                 NAMES <- toupper(changed)
[10:27:21.874]                 args <- list()
[10:27:21.874]                 for (kk in seq_along(NAMES)) {
[10:27:21.874]                   name <- changed[[kk]]
[10:27:21.874]                   NAME <- NAMES[[kk]]
[10:27:21.874]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:21.874]                     next
[10:27:21.874]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:21.874]                 }
[10:27:21.874]                 NAMES <- toupper(added)
[10:27:21.874]                 for (kk in seq_along(NAMES)) {
[10:27:21.874]                   name <- added[[kk]]
[10:27:21.874]                   NAME <- NAMES[[kk]]
[10:27:21.874]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:21.874]                     next
[10:27:21.874]                   args[[name]] <- ""
[10:27:21.874]                 }
[10:27:21.874]                 NAMES <- toupper(removed)
[10:27:21.874]                 for (kk in seq_along(NAMES)) {
[10:27:21.874]                   name <- removed[[kk]]
[10:27:21.874]                   NAME <- NAMES[[kk]]
[10:27:21.874]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:21.874]                     next
[10:27:21.874]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:21.874]                 }
[10:27:21.874]                 if (length(args) > 0) 
[10:27:21.874]                   base::do.call(base::Sys.setenv, args = args)
[10:27:21.874]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:21.874]             }
[10:27:21.874]             else {
[10:27:21.874]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:21.874]             }
[10:27:21.874]             {
[10:27:21.874]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:21.874]                   0L) {
[10:27:21.874]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:21.874]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:21.874]                   base::options(opts)
[10:27:21.874]                 }
[10:27:21.874]                 {
[10:27:21.874]                   {
[10:27:21.874]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:21.874]                     NULL
[10:27:21.874]                   }
[10:27:21.874]                   options(future.plan = NULL)
[10:27:21.874]                   if (is.na(NA_character_)) 
[10:27:21.874]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:21.874]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:21.874]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:21.874]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:21.874]                     envir = parent.frame()) 
[10:27:21.874]                   {
[10:27:21.874]                     if (is.function(workers)) 
[10:27:21.874]                       workers <- workers()
[10:27:21.874]                     workers <- structure(as.integer(workers), 
[10:27:21.874]                       class = class(workers))
[10:27:21.874]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:21.874]                       workers >= 1)
[10:27:21.874]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:21.874]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:21.874]                     }
[10:27:21.874]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:21.874]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:21.874]                       envir = envir)
[10:27:21.874]                     if (!future$lazy) 
[10:27:21.874]                       future <- run(future)
[10:27:21.874]                     invisible(future)
[10:27:21.874]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:21.874]                 }
[10:27:21.874]             }
[10:27:21.874]         }
[10:27:21.874]     })
[10:27:21.874]     if (TRUE) {
[10:27:21.874]         base::sink(type = "output", split = FALSE)
[10:27:21.874]         if (TRUE) {
[10:27:21.874]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:21.874]         }
[10:27:21.874]         else {
[10:27:21.874]             ...future.result["stdout"] <- base::list(NULL)
[10:27:21.874]         }
[10:27:21.874]         base::close(...future.stdout)
[10:27:21.874]         ...future.stdout <- NULL
[10:27:21.874]     }
[10:27:21.874]     ...future.result$conditions <- ...future.conditions
[10:27:21.874]     ...future.result$finished <- base::Sys.time()
[10:27:21.874]     ...future.result
[10:27:21.874] }
[10:27:21.877] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[10:27:21.877] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[10:27:21.877] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[10:27:21.878] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[10:27:21.878] MultisessionFuture started
[10:27:21.878] - Launch lazy future ... done
[10:27:21.878] run() for ‘MultisessionFuture’ ... done
[10:27:21.889] run() for ‘Future’ ...
[10:27:21.889] - state: ‘created’
[10:27:21.889] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:21.903] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:21.903] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:21.903]   - Field: ‘node’
[10:27:21.903]   - Field: ‘label’
[10:27:21.903]   - Field: ‘local’
[10:27:21.904]   - Field: ‘owner’
[10:27:21.904]   - Field: ‘envir’
[10:27:21.904]   - Field: ‘workers’
[10:27:21.904]   - Field: ‘packages’
[10:27:21.904]   - Field: ‘gc’
[10:27:21.904]   - Field: ‘conditions’
[10:27:21.904]   - Field: ‘persistent’
[10:27:21.904]   - Field: ‘expr’
[10:27:21.904]   - Field: ‘uuid’
[10:27:21.904]   - Field: ‘seed’
[10:27:21.904]   - Field: ‘version’
[10:27:21.905]   - Field: ‘result’
[10:27:21.905]   - Field: ‘asynchronous’
[10:27:21.905]   - Field: ‘calls’
[10:27:21.905]   - Field: ‘globals’
[10:27:21.905]   - Field: ‘stdout’
[10:27:21.905]   - Field: ‘earlySignal’
[10:27:21.905]   - Field: ‘lazy’
[10:27:21.905]   - Field: ‘state’
[10:27:21.905] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:21.905] - Launch lazy future ...
[10:27:21.906] Packages needed by the future expression (n = 0): <none>
[10:27:21.906] Packages needed by future strategies (n = 0): <none>
[10:27:21.906] {
[10:27:21.906]     {
[10:27:21.906]         {
[10:27:21.906]             ...future.startTime <- base::Sys.time()
[10:27:21.906]             {
[10:27:21.906]                 {
[10:27:21.906]                   {
[10:27:21.906]                     {
[10:27:21.906]                       base::local({
[10:27:21.906]                         has_future <- base::requireNamespace("future", 
[10:27:21.906]                           quietly = TRUE)
[10:27:21.906]                         if (has_future) {
[10:27:21.906]                           ns <- base::getNamespace("future")
[10:27:21.906]                           version <- ns[[".package"]][["version"]]
[10:27:21.906]                           if (is.null(version)) 
[10:27:21.906]                             version <- utils::packageVersion("future")
[10:27:21.906]                         }
[10:27:21.906]                         else {
[10:27:21.906]                           version <- NULL
[10:27:21.906]                         }
[10:27:21.906]                         if (!has_future || version < "1.8.0") {
[10:27:21.906]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:21.906]                             "", base::R.version$version.string), 
[10:27:21.906]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:21.906]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:21.906]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:21.906]                               "release", "version")], collapse = " "), 
[10:27:21.906]                             hostname = base::Sys.info()[["nodename"]])
[10:27:21.906]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:21.906]                             info)
[10:27:21.906]                           info <- base::paste(info, collapse = "; ")
[10:27:21.906]                           if (!has_future) {
[10:27:21.906]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:21.906]                               info)
[10:27:21.906]                           }
[10:27:21.906]                           else {
[10:27:21.906]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:21.906]                               info, version)
[10:27:21.906]                           }
[10:27:21.906]                           base::stop(msg)
[10:27:21.906]                         }
[10:27:21.906]                       })
[10:27:21.906]                     }
[10:27:21.906]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:21.906]                     base::options(mc.cores = 1L)
[10:27:21.906]                   }
[10:27:21.906]                   options(future.plan = NULL)
[10:27:21.906]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:21.906]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:21.906]                 }
[10:27:21.906]                 ...future.workdir <- getwd()
[10:27:21.906]             }
[10:27:21.906]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:21.906]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:21.906]         }
[10:27:21.906]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:21.906]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:21.906]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:21.906]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:21.906]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:21.906]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:21.906]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:21.906]             base::names(...future.oldOptions))
[10:27:21.906]     }
[10:27:21.906]     if (FALSE) {
[10:27:21.906]     }
[10:27:21.906]     else {
[10:27:21.906]         if (TRUE) {
[10:27:21.906]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:21.906]                 open = "w")
[10:27:21.906]         }
[10:27:21.906]         else {
[10:27:21.906]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:21.906]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:21.906]         }
[10:27:21.906]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:21.906]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:21.906]             base::sink(type = "output", split = FALSE)
[10:27:21.906]             base::close(...future.stdout)
[10:27:21.906]         }, add = TRUE)
[10:27:21.906]     }
[10:27:21.906]     ...future.frame <- base::sys.nframe()
[10:27:21.906]     ...future.conditions <- base::list()
[10:27:21.906]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:21.906]     if (FALSE) {
[10:27:21.906]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:21.906]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:21.906]     }
[10:27:21.906]     ...future.result <- base::tryCatch({
[10:27:21.906]         base::withCallingHandlers({
[10:27:21.906]             ...future.value <- base::withVisible(base::local({
[10:27:21.906]                 ...future.makeSendCondition <- base::local({
[10:27:21.906]                   sendCondition <- NULL
[10:27:21.906]                   function(frame = 1L) {
[10:27:21.906]                     if (is.function(sendCondition)) 
[10:27:21.906]                       return(sendCondition)
[10:27:21.906]                     ns <- getNamespace("parallel")
[10:27:21.906]                     if (exists("sendData", mode = "function", 
[10:27:21.906]                       envir = ns)) {
[10:27:21.906]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:21.906]                         envir = ns)
[10:27:21.906]                       envir <- sys.frame(frame)
[10:27:21.906]                       master <- NULL
[10:27:21.906]                       while (!identical(envir, .GlobalEnv) && 
[10:27:21.906]                         !identical(envir, emptyenv())) {
[10:27:21.906]                         if (exists("master", mode = "list", envir = envir, 
[10:27:21.906]                           inherits = FALSE)) {
[10:27:21.906]                           master <- get("master", mode = "list", 
[10:27:21.906]                             envir = envir, inherits = FALSE)
[10:27:21.906]                           if (inherits(master, c("SOCKnode", 
[10:27:21.906]                             "SOCK0node"))) {
[10:27:21.906]                             sendCondition <<- function(cond) {
[10:27:21.906]                               data <- list(type = "VALUE", value = cond, 
[10:27:21.906]                                 success = TRUE)
[10:27:21.906]                               parallel_sendData(master, data)
[10:27:21.906]                             }
[10:27:21.906]                             return(sendCondition)
[10:27:21.906]                           }
[10:27:21.906]                         }
[10:27:21.906]                         frame <- frame + 1L
[10:27:21.906]                         envir <- sys.frame(frame)
[10:27:21.906]                       }
[10:27:21.906]                     }
[10:27:21.906]                     sendCondition <<- function(cond) NULL
[10:27:21.906]                   }
[10:27:21.906]                 })
[10:27:21.906]                 withCallingHandlers({
[10:27:21.906]                   {
[10:27:21.906]                     Sys.sleep(0.1)
[10:27:21.906]                     kk
[10:27:21.906]                   }
[10:27:21.906]                 }, immediateCondition = function(cond) {
[10:27:21.906]                   sendCondition <- ...future.makeSendCondition()
[10:27:21.906]                   sendCondition(cond)
[10:27:21.906]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:21.906]                   {
[10:27:21.906]                     inherits <- base::inherits
[10:27:21.906]                     invokeRestart <- base::invokeRestart
[10:27:21.906]                     is.null <- base::is.null
[10:27:21.906]                     muffled <- FALSE
[10:27:21.906]                     if (inherits(cond, "message")) {
[10:27:21.906]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:21.906]                       if (muffled) 
[10:27:21.906]                         invokeRestart("muffleMessage")
[10:27:21.906]                     }
[10:27:21.906]                     else if (inherits(cond, "warning")) {
[10:27:21.906]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:21.906]                       if (muffled) 
[10:27:21.906]                         invokeRestart("muffleWarning")
[10:27:21.906]                     }
[10:27:21.906]                     else if (inherits(cond, "condition")) {
[10:27:21.906]                       if (!is.null(pattern)) {
[10:27:21.906]                         computeRestarts <- base::computeRestarts
[10:27:21.906]                         grepl <- base::grepl
[10:27:21.906]                         restarts <- computeRestarts(cond)
[10:27:21.906]                         for (restart in restarts) {
[10:27:21.906]                           name <- restart$name
[10:27:21.906]                           if (is.null(name)) 
[10:27:21.906]                             next
[10:27:21.906]                           if (!grepl(pattern, name)) 
[10:27:21.906]                             next
[10:27:21.906]                           invokeRestart(restart)
[10:27:21.906]                           muffled <- TRUE
[10:27:21.906]                           break
[10:27:21.906]                         }
[10:27:21.906]                       }
[10:27:21.906]                     }
[10:27:21.906]                     invisible(muffled)
[10:27:21.906]                   }
[10:27:21.906]                   muffleCondition(cond)
[10:27:21.906]                 })
[10:27:21.906]             }))
[10:27:21.906]             future::FutureResult(value = ...future.value$value, 
[10:27:21.906]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:21.906]                   ...future.rng), globalenv = if (FALSE) 
[10:27:21.906]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:21.906]                     ...future.globalenv.names))
[10:27:21.906]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:21.906]         }, condition = base::local({
[10:27:21.906]             c <- base::c
[10:27:21.906]             inherits <- base::inherits
[10:27:21.906]             invokeRestart <- base::invokeRestart
[10:27:21.906]             length <- base::length
[10:27:21.906]             list <- base::list
[10:27:21.906]             seq.int <- base::seq.int
[10:27:21.906]             signalCondition <- base::signalCondition
[10:27:21.906]             sys.calls <- base::sys.calls
[10:27:21.906]             `[[` <- base::`[[`
[10:27:21.906]             `+` <- base::`+`
[10:27:21.906]             `<<-` <- base::`<<-`
[10:27:21.906]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:21.906]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:21.906]                   3L)]
[10:27:21.906]             }
[10:27:21.906]             function(cond) {
[10:27:21.906]                 is_error <- inherits(cond, "error")
[10:27:21.906]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:21.906]                   NULL)
[10:27:21.906]                 if (is_error) {
[10:27:21.906]                   sessionInformation <- function() {
[10:27:21.906]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:21.906]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:21.906]                       search = base::search(), system = base::Sys.info())
[10:27:21.906]                   }
[10:27:21.906]                   ...future.conditions[[length(...future.conditions) + 
[10:27:21.906]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:21.906]                     cond$call), session = sessionInformation(), 
[10:27:21.906]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:21.906]                   signalCondition(cond)
[10:27:21.906]                 }
[10:27:21.906]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:21.906]                 "immediateCondition"))) {
[10:27:21.906]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:21.906]                   ...future.conditions[[length(...future.conditions) + 
[10:27:21.906]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:21.906]                   if (TRUE && !signal) {
[10:27:21.906]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:21.906]                     {
[10:27:21.906]                       inherits <- base::inherits
[10:27:21.906]                       invokeRestart <- base::invokeRestart
[10:27:21.906]                       is.null <- base::is.null
[10:27:21.906]                       muffled <- FALSE
[10:27:21.906]                       if (inherits(cond, "message")) {
[10:27:21.906]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:21.906]                         if (muffled) 
[10:27:21.906]                           invokeRestart("muffleMessage")
[10:27:21.906]                       }
[10:27:21.906]                       else if (inherits(cond, "warning")) {
[10:27:21.906]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:21.906]                         if (muffled) 
[10:27:21.906]                           invokeRestart("muffleWarning")
[10:27:21.906]                       }
[10:27:21.906]                       else if (inherits(cond, "condition")) {
[10:27:21.906]                         if (!is.null(pattern)) {
[10:27:21.906]                           computeRestarts <- base::computeRestarts
[10:27:21.906]                           grepl <- base::grepl
[10:27:21.906]                           restarts <- computeRestarts(cond)
[10:27:21.906]                           for (restart in restarts) {
[10:27:21.906]                             name <- restart$name
[10:27:21.906]                             if (is.null(name)) 
[10:27:21.906]                               next
[10:27:21.906]                             if (!grepl(pattern, name)) 
[10:27:21.906]                               next
[10:27:21.906]                             invokeRestart(restart)
[10:27:21.906]                             muffled <- TRUE
[10:27:21.906]                             break
[10:27:21.906]                           }
[10:27:21.906]                         }
[10:27:21.906]                       }
[10:27:21.906]                       invisible(muffled)
[10:27:21.906]                     }
[10:27:21.906]                     muffleCondition(cond, pattern = "^muffle")
[10:27:21.906]                   }
[10:27:21.906]                 }
[10:27:21.906]                 else {
[10:27:21.906]                   if (TRUE) {
[10:27:21.906]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:21.906]                     {
[10:27:21.906]                       inherits <- base::inherits
[10:27:21.906]                       invokeRestart <- base::invokeRestart
[10:27:21.906]                       is.null <- base::is.null
[10:27:21.906]                       muffled <- FALSE
[10:27:21.906]                       if (inherits(cond, "message")) {
[10:27:21.906]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:21.906]                         if (muffled) 
[10:27:21.906]                           invokeRestart("muffleMessage")
[10:27:21.906]                       }
[10:27:21.906]                       else if (inherits(cond, "warning")) {
[10:27:21.906]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:21.906]                         if (muffled) 
[10:27:21.906]                           invokeRestart("muffleWarning")
[10:27:21.906]                       }
[10:27:21.906]                       else if (inherits(cond, "condition")) {
[10:27:21.906]                         if (!is.null(pattern)) {
[10:27:21.906]                           computeRestarts <- base::computeRestarts
[10:27:21.906]                           grepl <- base::grepl
[10:27:21.906]                           restarts <- computeRestarts(cond)
[10:27:21.906]                           for (restart in restarts) {
[10:27:21.906]                             name <- restart$name
[10:27:21.906]                             if (is.null(name)) 
[10:27:21.906]                               next
[10:27:21.906]                             if (!grepl(pattern, name)) 
[10:27:21.906]                               next
[10:27:21.906]                             invokeRestart(restart)
[10:27:21.906]                             muffled <- TRUE
[10:27:21.906]                             break
[10:27:21.906]                           }
[10:27:21.906]                         }
[10:27:21.906]                       }
[10:27:21.906]                       invisible(muffled)
[10:27:21.906]                     }
[10:27:21.906]                     muffleCondition(cond, pattern = "^muffle")
[10:27:21.906]                   }
[10:27:21.906]                 }
[10:27:21.906]             }
[10:27:21.906]         }))
[10:27:21.906]     }, error = function(ex) {
[10:27:21.906]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:21.906]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:21.906]                 ...future.rng), started = ...future.startTime, 
[10:27:21.906]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:21.906]             version = "1.8"), class = "FutureResult")
[10:27:21.906]     }, finally = {
[10:27:21.906]         if (!identical(...future.workdir, getwd())) 
[10:27:21.906]             setwd(...future.workdir)
[10:27:21.906]         {
[10:27:21.906]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:21.906]                 ...future.oldOptions$nwarnings <- NULL
[10:27:21.906]             }
[10:27:21.906]             base::options(...future.oldOptions)
[10:27:21.906]             if (.Platform$OS.type == "windows") {
[10:27:21.906]                 old_names <- names(...future.oldEnvVars)
[10:27:21.906]                 envs <- base::Sys.getenv()
[10:27:21.906]                 names <- names(envs)
[10:27:21.906]                 common <- intersect(names, old_names)
[10:27:21.906]                 added <- setdiff(names, old_names)
[10:27:21.906]                 removed <- setdiff(old_names, names)
[10:27:21.906]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:21.906]                   envs[common]]
[10:27:21.906]                 NAMES <- toupper(changed)
[10:27:21.906]                 args <- list()
[10:27:21.906]                 for (kk in seq_along(NAMES)) {
[10:27:21.906]                   name <- changed[[kk]]
[10:27:21.906]                   NAME <- NAMES[[kk]]
[10:27:21.906]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:21.906]                     next
[10:27:21.906]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:21.906]                 }
[10:27:21.906]                 NAMES <- toupper(added)
[10:27:21.906]                 for (kk in seq_along(NAMES)) {
[10:27:21.906]                   name <- added[[kk]]
[10:27:21.906]                   NAME <- NAMES[[kk]]
[10:27:21.906]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:21.906]                     next
[10:27:21.906]                   args[[name]] <- ""
[10:27:21.906]                 }
[10:27:21.906]                 NAMES <- toupper(removed)
[10:27:21.906]                 for (kk in seq_along(NAMES)) {
[10:27:21.906]                   name <- removed[[kk]]
[10:27:21.906]                   NAME <- NAMES[[kk]]
[10:27:21.906]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:21.906]                     next
[10:27:21.906]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:21.906]                 }
[10:27:21.906]                 if (length(args) > 0) 
[10:27:21.906]                   base::do.call(base::Sys.setenv, args = args)
[10:27:21.906]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:21.906]             }
[10:27:21.906]             else {
[10:27:21.906]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:21.906]             }
[10:27:21.906]             {
[10:27:21.906]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:21.906]                   0L) {
[10:27:21.906]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:21.906]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:21.906]                   base::options(opts)
[10:27:21.906]                 }
[10:27:21.906]                 {
[10:27:21.906]                   {
[10:27:21.906]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:21.906]                     NULL
[10:27:21.906]                   }
[10:27:21.906]                   options(future.plan = NULL)
[10:27:21.906]                   if (is.na(NA_character_)) 
[10:27:21.906]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:21.906]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:21.906]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:21.906]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:21.906]                     envir = parent.frame()) 
[10:27:21.906]                   {
[10:27:21.906]                     if (is.function(workers)) 
[10:27:21.906]                       workers <- workers()
[10:27:21.906]                     workers <- structure(as.integer(workers), 
[10:27:21.906]                       class = class(workers))
[10:27:21.906]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:21.906]                       workers >= 1)
[10:27:21.906]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:21.906]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:21.906]                     }
[10:27:21.906]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:21.906]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:21.906]                       envir = envir)
[10:27:21.906]                     if (!future$lazy) 
[10:27:21.906]                       future <- run(future)
[10:27:21.906]                     invisible(future)
[10:27:21.906]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:21.906]                 }
[10:27:21.906]             }
[10:27:21.906]         }
[10:27:21.906]     })
[10:27:21.906]     if (TRUE) {
[10:27:21.906]         base::sink(type = "output", split = FALSE)
[10:27:21.906]         if (TRUE) {
[10:27:21.906]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:21.906]         }
[10:27:21.906]         else {
[10:27:21.906]             ...future.result["stdout"] <- base::list(NULL)
[10:27:21.906]         }
[10:27:21.906]         base::close(...future.stdout)
[10:27:21.906]         ...future.stdout <- NULL
[10:27:21.906]     }
[10:27:21.906]     ...future.result$conditions <- ...future.conditions
[10:27:21.906]     ...future.result$finished <- base::Sys.time()
[10:27:21.906]     ...future.result
[10:27:21.906] }
[10:27:21.909] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[10:27:21.909] Exporting ‘kk’ (56 bytes) to cluster node #2 ...
[10:27:21.909] Exporting ‘kk’ (56 bytes) to cluster node #2 ... DONE
[10:27:21.910] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[10:27:21.910] MultisessionFuture started
[10:27:21.910] - Launch lazy future ... done
[10:27:21.910] run() for ‘MultisessionFuture’ ... done
[10:27:21.921] run() for ‘Future’ ...
[10:27:21.921] - state: ‘created’
[10:27:21.921] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:21.935] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:21.935] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:21.935]   - Field: ‘node’
[10:27:21.935]   - Field: ‘label’
[10:27:21.935]   - Field: ‘local’
[10:27:21.935]   - Field: ‘owner’
[10:27:21.935]   - Field: ‘envir’
[10:27:21.935]   - Field: ‘workers’
[10:27:21.935]   - Field: ‘packages’
[10:27:21.936]   - Field: ‘gc’
[10:27:21.936]   - Field: ‘conditions’
[10:27:21.936]   - Field: ‘persistent’
[10:27:21.936]   - Field: ‘expr’
[10:27:21.936]   - Field: ‘uuid’
[10:27:21.936]   - Field: ‘seed’
[10:27:21.936]   - Field: ‘version’
[10:27:21.936]   - Field: ‘result’
[10:27:21.936]   - Field: ‘asynchronous’
[10:27:21.936]   - Field: ‘calls’
[10:27:21.936]   - Field: ‘globals’
[10:27:21.937]   - Field: ‘stdout’
[10:27:21.937]   - Field: ‘earlySignal’
[10:27:21.937]   - Field: ‘lazy’
[10:27:21.937]   - Field: ‘state’
[10:27:21.937] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:21.937] - Launch lazy future ...
[10:27:21.937] Packages needed by the future expression (n = 0): <none>
[10:27:21.937] Packages needed by future strategies (n = 0): <none>
[10:27:21.938] {
[10:27:21.938]     {
[10:27:21.938]         {
[10:27:21.938]             ...future.startTime <- base::Sys.time()
[10:27:21.938]             {
[10:27:21.938]                 {
[10:27:21.938]                   {
[10:27:21.938]                     {
[10:27:21.938]                       base::local({
[10:27:21.938]                         has_future <- base::requireNamespace("future", 
[10:27:21.938]                           quietly = TRUE)
[10:27:21.938]                         if (has_future) {
[10:27:21.938]                           ns <- base::getNamespace("future")
[10:27:21.938]                           version <- ns[[".package"]][["version"]]
[10:27:21.938]                           if (is.null(version)) 
[10:27:21.938]                             version <- utils::packageVersion("future")
[10:27:21.938]                         }
[10:27:21.938]                         else {
[10:27:21.938]                           version <- NULL
[10:27:21.938]                         }
[10:27:21.938]                         if (!has_future || version < "1.8.0") {
[10:27:21.938]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:21.938]                             "", base::R.version$version.string), 
[10:27:21.938]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:21.938]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:21.938]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:21.938]                               "release", "version")], collapse = " "), 
[10:27:21.938]                             hostname = base::Sys.info()[["nodename"]])
[10:27:21.938]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:21.938]                             info)
[10:27:21.938]                           info <- base::paste(info, collapse = "; ")
[10:27:21.938]                           if (!has_future) {
[10:27:21.938]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:21.938]                               info)
[10:27:21.938]                           }
[10:27:21.938]                           else {
[10:27:21.938]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:21.938]                               info, version)
[10:27:21.938]                           }
[10:27:21.938]                           base::stop(msg)
[10:27:21.938]                         }
[10:27:21.938]                       })
[10:27:21.938]                     }
[10:27:21.938]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:21.938]                     base::options(mc.cores = 1L)
[10:27:21.938]                   }
[10:27:21.938]                   options(future.plan = NULL)
[10:27:21.938]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:21.938]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:21.938]                 }
[10:27:21.938]                 ...future.workdir <- getwd()
[10:27:21.938]             }
[10:27:21.938]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:21.938]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:21.938]         }
[10:27:21.938]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:21.938]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:21.938]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:21.938]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:21.938]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:21.938]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:21.938]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:21.938]             base::names(...future.oldOptions))
[10:27:21.938]     }
[10:27:21.938]     if (FALSE) {
[10:27:21.938]     }
[10:27:21.938]     else {
[10:27:21.938]         if (TRUE) {
[10:27:21.938]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:21.938]                 open = "w")
[10:27:21.938]         }
[10:27:21.938]         else {
[10:27:21.938]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:21.938]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:21.938]         }
[10:27:21.938]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:21.938]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:21.938]             base::sink(type = "output", split = FALSE)
[10:27:21.938]             base::close(...future.stdout)
[10:27:21.938]         }, add = TRUE)
[10:27:21.938]     }
[10:27:21.938]     ...future.frame <- base::sys.nframe()
[10:27:21.938]     ...future.conditions <- base::list()
[10:27:21.938]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:21.938]     if (FALSE) {
[10:27:21.938]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:21.938]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:21.938]     }
[10:27:21.938]     ...future.result <- base::tryCatch({
[10:27:21.938]         base::withCallingHandlers({
[10:27:21.938]             ...future.value <- base::withVisible(base::local({
[10:27:21.938]                 ...future.makeSendCondition <- base::local({
[10:27:21.938]                   sendCondition <- NULL
[10:27:21.938]                   function(frame = 1L) {
[10:27:21.938]                     if (is.function(sendCondition)) 
[10:27:21.938]                       return(sendCondition)
[10:27:21.938]                     ns <- getNamespace("parallel")
[10:27:21.938]                     if (exists("sendData", mode = "function", 
[10:27:21.938]                       envir = ns)) {
[10:27:21.938]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:21.938]                         envir = ns)
[10:27:21.938]                       envir <- sys.frame(frame)
[10:27:21.938]                       master <- NULL
[10:27:21.938]                       while (!identical(envir, .GlobalEnv) && 
[10:27:21.938]                         !identical(envir, emptyenv())) {
[10:27:21.938]                         if (exists("master", mode = "list", envir = envir, 
[10:27:21.938]                           inherits = FALSE)) {
[10:27:21.938]                           master <- get("master", mode = "list", 
[10:27:21.938]                             envir = envir, inherits = FALSE)
[10:27:21.938]                           if (inherits(master, c("SOCKnode", 
[10:27:21.938]                             "SOCK0node"))) {
[10:27:21.938]                             sendCondition <<- function(cond) {
[10:27:21.938]                               data <- list(type = "VALUE", value = cond, 
[10:27:21.938]                                 success = TRUE)
[10:27:21.938]                               parallel_sendData(master, data)
[10:27:21.938]                             }
[10:27:21.938]                             return(sendCondition)
[10:27:21.938]                           }
[10:27:21.938]                         }
[10:27:21.938]                         frame <- frame + 1L
[10:27:21.938]                         envir <- sys.frame(frame)
[10:27:21.938]                       }
[10:27:21.938]                     }
[10:27:21.938]                     sendCondition <<- function(cond) NULL
[10:27:21.938]                   }
[10:27:21.938]                 })
[10:27:21.938]                 withCallingHandlers({
[10:27:21.938]                   {
[10:27:21.938]                     Sys.sleep(0.1)
[10:27:21.938]                     kk
[10:27:21.938]                   }
[10:27:21.938]                 }, immediateCondition = function(cond) {
[10:27:21.938]                   sendCondition <- ...future.makeSendCondition()
[10:27:21.938]                   sendCondition(cond)
[10:27:21.938]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:21.938]                   {
[10:27:21.938]                     inherits <- base::inherits
[10:27:21.938]                     invokeRestart <- base::invokeRestart
[10:27:21.938]                     is.null <- base::is.null
[10:27:21.938]                     muffled <- FALSE
[10:27:21.938]                     if (inherits(cond, "message")) {
[10:27:21.938]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:21.938]                       if (muffled) 
[10:27:21.938]                         invokeRestart("muffleMessage")
[10:27:21.938]                     }
[10:27:21.938]                     else if (inherits(cond, "warning")) {
[10:27:21.938]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:21.938]                       if (muffled) 
[10:27:21.938]                         invokeRestart("muffleWarning")
[10:27:21.938]                     }
[10:27:21.938]                     else if (inherits(cond, "condition")) {
[10:27:21.938]                       if (!is.null(pattern)) {
[10:27:21.938]                         computeRestarts <- base::computeRestarts
[10:27:21.938]                         grepl <- base::grepl
[10:27:21.938]                         restarts <- computeRestarts(cond)
[10:27:21.938]                         for (restart in restarts) {
[10:27:21.938]                           name <- restart$name
[10:27:21.938]                           if (is.null(name)) 
[10:27:21.938]                             next
[10:27:21.938]                           if (!grepl(pattern, name)) 
[10:27:21.938]                             next
[10:27:21.938]                           invokeRestart(restart)
[10:27:21.938]                           muffled <- TRUE
[10:27:21.938]                           break
[10:27:21.938]                         }
[10:27:21.938]                       }
[10:27:21.938]                     }
[10:27:21.938]                     invisible(muffled)
[10:27:21.938]                   }
[10:27:21.938]                   muffleCondition(cond)
[10:27:21.938]                 })
[10:27:21.938]             }))
[10:27:21.938]             future::FutureResult(value = ...future.value$value, 
[10:27:21.938]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:21.938]                   ...future.rng), globalenv = if (FALSE) 
[10:27:21.938]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:21.938]                     ...future.globalenv.names))
[10:27:21.938]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:21.938]         }, condition = base::local({
[10:27:21.938]             c <- base::c
[10:27:21.938]             inherits <- base::inherits
[10:27:21.938]             invokeRestart <- base::invokeRestart
[10:27:21.938]             length <- base::length
[10:27:21.938]             list <- base::list
[10:27:21.938]             seq.int <- base::seq.int
[10:27:21.938]             signalCondition <- base::signalCondition
[10:27:21.938]             sys.calls <- base::sys.calls
[10:27:21.938]             `[[` <- base::`[[`
[10:27:21.938]             `+` <- base::`+`
[10:27:21.938]             `<<-` <- base::`<<-`
[10:27:21.938]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:21.938]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:21.938]                   3L)]
[10:27:21.938]             }
[10:27:21.938]             function(cond) {
[10:27:21.938]                 is_error <- inherits(cond, "error")
[10:27:21.938]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:21.938]                   NULL)
[10:27:21.938]                 if (is_error) {
[10:27:21.938]                   sessionInformation <- function() {
[10:27:21.938]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:21.938]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:21.938]                       search = base::search(), system = base::Sys.info())
[10:27:21.938]                   }
[10:27:21.938]                   ...future.conditions[[length(...future.conditions) + 
[10:27:21.938]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:21.938]                     cond$call), session = sessionInformation(), 
[10:27:21.938]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:21.938]                   signalCondition(cond)
[10:27:21.938]                 }
[10:27:21.938]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:21.938]                 "immediateCondition"))) {
[10:27:21.938]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:21.938]                   ...future.conditions[[length(...future.conditions) + 
[10:27:21.938]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:21.938]                   if (TRUE && !signal) {
[10:27:21.938]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:21.938]                     {
[10:27:21.938]                       inherits <- base::inherits
[10:27:21.938]                       invokeRestart <- base::invokeRestart
[10:27:21.938]                       is.null <- base::is.null
[10:27:21.938]                       muffled <- FALSE
[10:27:21.938]                       if (inherits(cond, "message")) {
[10:27:21.938]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:21.938]                         if (muffled) 
[10:27:21.938]                           invokeRestart("muffleMessage")
[10:27:21.938]                       }
[10:27:21.938]                       else if (inherits(cond, "warning")) {
[10:27:21.938]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:21.938]                         if (muffled) 
[10:27:21.938]                           invokeRestart("muffleWarning")
[10:27:21.938]                       }
[10:27:21.938]                       else if (inherits(cond, "condition")) {
[10:27:21.938]                         if (!is.null(pattern)) {
[10:27:21.938]                           computeRestarts <- base::computeRestarts
[10:27:21.938]                           grepl <- base::grepl
[10:27:21.938]                           restarts <- computeRestarts(cond)
[10:27:21.938]                           for (restart in restarts) {
[10:27:21.938]                             name <- restart$name
[10:27:21.938]                             if (is.null(name)) 
[10:27:21.938]                               next
[10:27:21.938]                             if (!grepl(pattern, name)) 
[10:27:21.938]                               next
[10:27:21.938]                             invokeRestart(restart)
[10:27:21.938]                             muffled <- TRUE
[10:27:21.938]                             break
[10:27:21.938]                           }
[10:27:21.938]                         }
[10:27:21.938]                       }
[10:27:21.938]                       invisible(muffled)
[10:27:21.938]                     }
[10:27:21.938]                     muffleCondition(cond, pattern = "^muffle")
[10:27:21.938]                   }
[10:27:21.938]                 }
[10:27:21.938]                 else {
[10:27:21.938]                   if (TRUE) {
[10:27:21.938]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:21.938]                     {
[10:27:21.938]                       inherits <- base::inherits
[10:27:21.938]                       invokeRestart <- base::invokeRestart
[10:27:21.938]                       is.null <- base::is.null
[10:27:21.938]                       muffled <- FALSE
[10:27:21.938]                       if (inherits(cond, "message")) {
[10:27:21.938]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:21.938]                         if (muffled) 
[10:27:21.938]                           invokeRestart("muffleMessage")
[10:27:21.938]                       }
[10:27:21.938]                       else if (inherits(cond, "warning")) {
[10:27:21.938]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:21.938]                         if (muffled) 
[10:27:21.938]                           invokeRestart("muffleWarning")
[10:27:21.938]                       }
[10:27:21.938]                       else if (inherits(cond, "condition")) {
[10:27:21.938]                         if (!is.null(pattern)) {
[10:27:21.938]                           computeRestarts <- base::computeRestarts
[10:27:21.938]                           grepl <- base::grepl
[10:27:21.938]                           restarts <- computeRestarts(cond)
[10:27:21.938]                           for (restart in restarts) {
[10:27:21.938]                             name <- restart$name
[10:27:21.938]                             if (is.null(name)) 
[10:27:21.938]                               next
[10:27:21.938]                             if (!grepl(pattern, name)) 
[10:27:21.938]                               next
[10:27:21.938]                             invokeRestart(restart)
[10:27:21.938]                             muffled <- TRUE
[10:27:21.938]                             break
[10:27:21.938]                           }
[10:27:21.938]                         }
[10:27:21.938]                       }
[10:27:21.938]                       invisible(muffled)
[10:27:21.938]                     }
[10:27:21.938]                     muffleCondition(cond, pattern = "^muffle")
[10:27:21.938]                   }
[10:27:21.938]                 }
[10:27:21.938]             }
[10:27:21.938]         }))
[10:27:21.938]     }, error = function(ex) {
[10:27:21.938]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:21.938]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:21.938]                 ...future.rng), started = ...future.startTime, 
[10:27:21.938]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:21.938]             version = "1.8"), class = "FutureResult")
[10:27:21.938]     }, finally = {
[10:27:21.938]         if (!identical(...future.workdir, getwd())) 
[10:27:21.938]             setwd(...future.workdir)
[10:27:21.938]         {
[10:27:21.938]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:21.938]                 ...future.oldOptions$nwarnings <- NULL
[10:27:21.938]             }
[10:27:21.938]             base::options(...future.oldOptions)
[10:27:21.938]             if (.Platform$OS.type == "windows") {
[10:27:21.938]                 old_names <- names(...future.oldEnvVars)
[10:27:21.938]                 envs <- base::Sys.getenv()
[10:27:21.938]                 names <- names(envs)
[10:27:21.938]                 common <- intersect(names, old_names)
[10:27:21.938]                 added <- setdiff(names, old_names)
[10:27:21.938]                 removed <- setdiff(old_names, names)
[10:27:21.938]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:21.938]                   envs[common]]
[10:27:21.938]                 NAMES <- toupper(changed)
[10:27:21.938]                 args <- list()
[10:27:21.938]                 for (kk in seq_along(NAMES)) {
[10:27:21.938]                   name <- changed[[kk]]
[10:27:21.938]                   NAME <- NAMES[[kk]]
[10:27:21.938]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:21.938]                     next
[10:27:21.938]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:21.938]                 }
[10:27:21.938]                 NAMES <- toupper(added)
[10:27:21.938]                 for (kk in seq_along(NAMES)) {
[10:27:21.938]                   name <- added[[kk]]
[10:27:21.938]                   NAME <- NAMES[[kk]]
[10:27:21.938]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:21.938]                     next
[10:27:21.938]                   args[[name]] <- ""
[10:27:21.938]                 }
[10:27:21.938]                 NAMES <- toupper(removed)
[10:27:21.938]                 for (kk in seq_along(NAMES)) {
[10:27:21.938]                   name <- removed[[kk]]
[10:27:21.938]                   NAME <- NAMES[[kk]]
[10:27:21.938]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:21.938]                     next
[10:27:21.938]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:21.938]                 }
[10:27:21.938]                 if (length(args) > 0) 
[10:27:21.938]                   base::do.call(base::Sys.setenv, args = args)
[10:27:21.938]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:21.938]             }
[10:27:21.938]             else {
[10:27:21.938]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:21.938]             }
[10:27:21.938]             {
[10:27:21.938]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:21.938]                   0L) {
[10:27:21.938]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:21.938]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:21.938]                   base::options(opts)
[10:27:21.938]                 }
[10:27:21.938]                 {
[10:27:21.938]                   {
[10:27:21.938]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:21.938]                     NULL
[10:27:21.938]                   }
[10:27:21.938]                   options(future.plan = NULL)
[10:27:21.938]                   if (is.na(NA_character_)) 
[10:27:21.938]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:21.938]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:21.938]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:21.938]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:21.938]                     envir = parent.frame()) 
[10:27:21.938]                   {
[10:27:21.938]                     if (is.function(workers)) 
[10:27:21.938]                       workers <- workers()
[10:27:21.938]                     workers <- structure(as.integer(workers), 
[10:27:21.938]                       class = class(workers))
[10:27:21.938]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:21.938]                       workers >= 1)
[10:27:21.938]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:21.938]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:21.938]                     }
[10:27:21.938]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:21.938]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:21.938]                       envir = envir)
[10:27:21.938]                     if (!future$lazy) 
[10:27:21.938]                       future <- run(future)
[10:27:21.938]                     invisible(future)
[10:27:21.938]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:21.938]                 }
[10:27:21.938]             }
[10:27:21.938]         }
[10:27:21.938]     })
[10:27:21.938]     if (TRUE) {
[10:27:21.938]         base::sink(type = "output", split = FALSE)
[10:27:21.938]         if (TRUE) {
[10:27:21.938]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:21.938]         }
[10:27:21.938]         else {
[10:27:21.938]             ...future.result["stdout"] <- base::list(NULL)
[10:27:21.938]         }
[10:27:21.938]         base::close(...future.stdout)
[10:27:21.938]         ...future.stdout <- NULL
[10:27:21.938]     }
[10:27:21.938]     ...future.result$conditions <- ...future.conditions
[10:27:21.938]     ...future.result$finished <- base::Sys.time()
[10:27:21.938]     ...future.result
[10:27:21.938] }
[10:27:21.940] Poll #1 (0): usedNodes() = 2, workers = 2
[10:27:21.971] Poll #2 (0.03 secs): usedNodes() = 2, workers = 2
[10:27:22.003] Poll #3 (0.06 secs): usedNodes() = 2, workers = 2
[10:27:22.034] Poll #4 (0.09 secs): usedNodes() = 2, workers = 2
[10:27:22.046] receiveMessageFromWorker() for ClusterFuture ...
[10:27:22.046] - Validating connection of MultisessionFuture
[10:27:22.046] - received message: FutureResult
[10:27:22.046] - Received FutureResult
[10:27:22.046] - Erased future from FutureRegistry
[10:27:22.047] result() for ClusterFuture ...
[10:27:22.047] - result already collected: FutureResult
[10:27:22.047] result() for ClusterFuture ... done
[10:27:22.047] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:22.047] result() for ClusterFuture ...
[10:27:22.047] - result already collected: FutureResult
[10:27:22.047] result() for ClusterFuture ... done
[10:27:22.047] result() for ClusterFuture ...
[10:27:22.048] - result already collected: FutureResult
[10:27:22.048] result() for ClusterFuture ... done
[10:27:22.048] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[10:27:22.049] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[10:27:22.049] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[10:27:22.049] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[10:27:22.050] MultisessionFuture started
[10:27:22.050] - Launch lazy future ... done
[10:27:22.050] run() for ‘MultisessionFuture’ ... done
[10:27:22.071] Future #1
[10:27:22.071]  length: 2 (resolved future 1)
[10:27:22.072] receiveMessageFromWorker() for ClusterFuture ...
[10:27:22.072] - Validating connection of MultisessionFuture
[10:27:22.072] - received message: FutureResult
[10:27:22.072] - Received FutureResult
[10:27:22.072] - Erased future from FutureRegistry
[10:27:22.072] result() for ClusterFuture ...
[10:27:22.073] - result already collected: FutureResult
[10:27:22.073] result() for ClusterFuture ... done
[10:27:22.073] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:22.073] Future #2
[10:27:22.073]  length: 1 (resolved future 2)
[10:27:22.200] receiveMessageFromWorker() for ClusterFuture ...
[10:27:22.200] - Validating connection of MultisessionFuture
[10:27:22.200] - received message: FutureResult
[10:27:22.200] - Received FutureResult
[10:27:22.200] - Erased future from FutureRegistry
[10:27:22.200] result() for ClusterFuture ...
[10:27:22.201] - result already collected: FutureResult
[10:27:22.201] result() for ClusterFuture ... done
[10:27:22.201] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:22.201] Future #3
[10:27:22.201]  length: 0 (resolved future 3)
[10:27:22.201] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[10:27:22.202] resolve() on environment ...
[10:27:22.202]  recursive: 0
[10:27:22.205]  elements: [2] ‘a’, ‘b’
[10:27:22.206]  length: 1 (resolved future 1)
[10:27:22.208]  length: 0 (resolved future 2)
[10:27:22.208] resolve() on environment ... DONE
[10:27:22.209] getGlobalsAndPackages() ...
[10:27:22.209] Searching for globals...
[10:27:22.209] 
[10:27:22.210] Searching for globals ... DONE
[10:27:22.210] - globals: [0] <none>
[10:27:22.210] getGlobalsAndPackages() ... DONE
[10:27:22.210] run() for ‘Future’ ...
[10:27:22.210] - state: ‘created’
[10:27:22.210] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:22.239] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:22.239] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:22.239]   - Field: ‘node’
[10:27:22.240]   - Field: ‘label’
[10:27:22.240]   - Field: ‘local’
[10:27:22.240]   - Field: ‘owner’
[10:27:22.240]   - Field: ‘envir’
[10:27:22.240]   - Field: ‘workers’
[10:27:22.240]   - Field: ‘packages’
[10:27:22.240]   - Field: ‘gc’
[10:27:22.240]   - Field: ‘conditions’
[10:27:22.241]   - Field: ‘persistent’
[10:27:22.241]   - Field: ‘expr’
[10:27:22.241]   - Field: ‘uuid’
[10:27:22.241]   - Field: ‘seed’
[10:27:22.241]   - Field: ‘version’
[10:27:22.241]   - Field: ‘result’
[10:27:22.241]   - Field: ‘asynchronous’
[10:27:22.241]   - Field: ‘calls’
[10:27:22.241]   - Field: ‘globals’
[10:27:22.241]   - Field: ‘stdout’
[10:27:22.242]   - Field: ‘earlySignal’
[10:27:22.242]   - Field: ‘lazy’
[10:27:22.242]   - Field: ‘state’
[10:27:22.242] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:22.242] - Launch lazy future ...
[10:27:22.242] Packages needed by the future expression (n = 0): <none>
[10:27:22.242] Packages needed by future strategies (n = 0): <none>
[10:27:22.243] {
[10:27:22.243]     {
[10:27:22.243]         {
[10:27:22.243]             ...future.startTime <- base::Sys.time()
[10:27:22.243]             {
[10:27:22.243]                 {
[10:27:22.243]                   {
[10:27:22.243]                     {
[10:27:22.243]                       base::local({
[10:27:22.243]                         has_future <- base::requireNamespace("future", 
[10:27:22.243]                           quietly = TRUE)
[10:27:22.243]                         if (has_future) {
[10:27:22.243]                           ns <- base::getNamespace("future")
[10:27:22.243]                           version <- ns[[".package"]][["version"]]
[10:27:22.243]                           if (is.null(version)) 
[10:27:22.243]                             version <- utils::packageVersion("future")
[10:27:22.243]                         }
[10:27:22.243]                         else {
[10:27:22.243]                           version <- NULL
[10:27:22.243]                         }
[10:27:22.243]                         if (!has_future || version < "1.8.0") {
[10:27:22.243]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:22.243]                             "", base::R.version$version.string), 
[10:27:22.243]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:22.243]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:22.243]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:22.243]                               "release", "version")], collapse = " "), 
[10:27:22.243]                             hostname = base::Sys.info()[["nodename"]])
[10:27:22.243]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:22.243]                             info)
[10:27:22.243]                           info <- base::paste(info, collapse = "; ")
[10:27:22.243]                           if (!has_future) {
[10:27:22.243]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:22.243]                               info)
[10:27:22.243]                           }
[10:27:22.243]                           else {
[10:27:22.243]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:22.243]                               info, version)
[10:27:22.243]                           }
[10:27:22.243]                           base::stop(msg)
[10:27:22.243]                         }
[10:27:22.243]                       })
[10:27:22.243]                     }
[10:27:22.243]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:22.243]                     base::options(mc.cores = 1L)
[10:27:22.243]                   }
[10:27:22.243]                   options(future.plan = NULL)
[10:27:22.243]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:22.243]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:22.243]                 }
[10:27:22.243]                 ...future.workdir <- getwd()
[10:27:22.243]             }
[10:27:22.243]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:22.243]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:22.243]         }
[10:27:22.243]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:22.243]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:22.243]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:22.243]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:22.243]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:22.243]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:22.243]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:22.243]             base::names(...future.oldOptions))
[10:27:22.243]     }
[10:27:22.243]     if (FALSE) {
[10:27:22.243]     }
[10:27:22.243]     else {
[10:27:22.243]         if (TRUE) {
[10:27:22.243]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:22.243]                 open = "w")
[10:27:22.243]         }
[10:27:22.243]         else {
[10:27:22.243]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:22.243]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:22.243]         }
[10:27:22.243]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:22.243]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:22.243]             base::sink(type = "output", split = FALSE)
[10:27:22.243]             base::close(...future.stdout)
[10:27:22.243]         }, add = TRUE)
[10:27:22.243]     }
[10:27:22.243]     ...future.frame <- base::sys.nframe()
[10:27:22.243]     ...future.conditions <- base::list()
[10:27:22.243]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:22.243]     if (FALSE) {
[10:27:22.243]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:22.243]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:22.243]     }
[10:27:22.243]     ...future.result <- base::tryCatch({
[10:27:22.243]         base::withCallingHandlers({
[10:27:22.243]             ...future.value <- base::withVisible(base::local({
[10:27:22.243]                 ...future.makeSendCondition <- base::local({
[10:27:22.243]                   sendCondition <- NULL
[10:27:22.243]                   function(frame = 1L) {
[10:27:22.243]                     if (is.function(sendCondition)) 
[10:27:22.243]                       return(sendCondition)
[10:27:22.243]                     ns <- getNamespace("parallel")
[10:27:22.243]                     if (exists("sendData", mode = "function", 
[10:27:22.243]                       envir = ns)) {
[10:27:22.243]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:22.243]                         envir = ns)
[10:27:22.243]                       envir <- sys.frame(frame)
[10:27:22.243]                       master <- NULL
[10:27:22.243]                       while (!identical(envir, .GlobalEnv) && 
[10:27:22.243]                         !identical(envir, emptyenv())) {
[10:27:22.243]                         if (exists("master", mode = "list", envir = envir, 
[10:27:22.243]                           inherits = FALSE)) {
[10:27:22.243]                           master <- get("master", mode = "list", 
[10:27:22.243]                             envir = envir, inherits = FALSE)
[10:27:22.243]                           if (inherits(master, c("SOCKnode", 
[10:27:22.243]                             "SOCK0node"))) {
[10:27:22.243]                             sendCondition <<- function(cond) {
[10:27:22.243]                               data <- list(type = "VALUE", value = cond, 
[10:27:22.243]                                 success = TRUE)
[10:27:22.243]                               parallel_sendData(master, data)
[10:27:22.243]                             }
[10:27:22.243]                             return(sendCondition)
[10:27:22.243]                           }
[10:27:22.243]                         }
[10:27:22.243]                         frame <- frame + 1L
[10:27:22.243]                         envir <- sys.frame(frame)
[10:27:22.243]                       }
[10:27:22.243]                     }
[10:27:22.243]                     sendCondition <<- function(cond) NULL
[10:27:22.243]                   }
[10:27:22.243]                 })
[10:27:22.243]                 withCallingHandlers({
[10:27:22.243]                   1
[10:27:22.243]                 }, immediateCondition = function(cond) {
[10:27:22.243]                   sendCondition <- ...future.makeSendCondition()
[10:27:22.243]                   sendCondition(cond)
[10:27:22.243]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.243]                   {
[10:27:22.243]                     inherits <- base::inherits
[10:27:22.243]                     invokeRestart <- base::invokeRestart
[10:27:22.243]                     is.null <- base::is.null
[10:27:22.243]                     muffled <- FALSE
[10:27:22.243]                     if (inherits(cond, "message")) {
[10:27:22.243]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:22.243]                       if (muffled) 
[10:27:22.243]                         invokeRestart("muffleMessage")
[10:27:22.243]                     }
[10:27:22.243]                     else if (inherits(cond, "warning")) {
[10:27:22.243]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:22.243]                       if (muffled) 
[10:27:22.243]                         invokeRestart("muffleWarning")
[10:27:22.243]                     }
[10:27:22.243]                     else if (inherits(cond, "condition")) {
[10:27:22.243]                       if (!is.null(pattern)) {
[10:27:22.243]                         computeRestarts <- base::computeRestarts
[10:27:22.243]                         grepl <- base::grepl
[10:27:22.243]                         restarts <- computeRestarts(cond)
[10:27:22.243]                         for (restart in restarts) {
[10:27:22.243]                           name <- restart$name
[10:27:22.243]                           if (is.null(name)) 
[10:27:22.243]                             next
[10:27:22.243]                           if (!grepl(pattern, name)) 
[10:27:22.243]                             next
[10:27:22.243]                           invokeRestart(restart)
[10:27:22.243]                           muffled <- TRUE
[10:27:22.243]                           break
[10:27:22.243]                         }
[10:27:22.243]                       }
[10:27:22.243]                     }
[10:27:22.243]                     invisible(muffled)
[10:27:22.243]                   }
[10:27:22.243]                   muffleCondition(cond)
[10:27:22.243]                 })
[10:27:22.243]             }))
[10:27:22.243]             future::FutureResult(value = ...future.value$value, 
[10:27:22.243]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:22.243]                   ...future.rng), globalenv = if (FALSE) 
[10:27:22.243]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:22.243]                     ...future.globalenv.names))
[10:27:22.243]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:22.243]         }, condition = base::local({
[10:27:22.243]             c <- base::c
[10:27:22.243]             inherits <- base::inherits
[10:27:22.243]             invokeRestart <- base::invokeRestart
[10:27:22.243]             length <- base::length
[10:27:22.243]             list <- base::list
[10:27:22.243]             seq.int <- base::seq.int
[10:27:22.243]             signalCondition <- base::signalCondition
[10:27:22.243]             sys.calls <- base::sys.calls
[10:27:22.243]             `[[` <- base::`[[`
[10:27:22.243]             `+` <- base::`+`
[10:27:22.243]             `<<-` <- base::`<<-`
[10:27:22.243]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:22.243]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:22.243]                   3L)]
[10:27:22.243]             }
[10:27:22.243]             function(cond) {
[10:27:22.243]                 is_error <- inherits(cond, "error")
[10:27:22.243]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:22.243]                   NULL)
[10:27:22.243]                 if (is_error) {
[10:27:22.243]                   sessionInformation <- function() {
[10:27:22.243]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:22.243]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:22.243]                       search = base::search(), system = base::Sys.info())
[10:27:22.243]                   }
[10:27:22.243]                   ...future.conditions[[length(...future.conditions) + 
[10:27:22.243]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:22.243]                     cond$call), session = sessionInformation(), 
[10:27:22.243]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:22.243]                   signalCondition(cond)
[10:27:22.243]                 }
[10:27:22.243]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:22.243]                 "immediateCondition"))) {
[10:27:22.243]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:22.243]                   ...future.conditions[[length(...future.conditions) + 
[10:27:22.243]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:22.243]                   if (TRUE && !signal) {
[10:27:22.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.243]                     {
[10:27:22.243]                       inherits <- base::inherits
[10:27:22.243]                       invokeRestart <- base::invokeRestart
[10:27:22.243]                       is.null <- base::is.null
[10:27:22.243]                       muffled <- FALSE
[10:27:22.243]                       if (inherits(cond, "message")) {
[10:27:22.243]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:22.243]                         if (muffled) 
[10:27:22.243]                           invokeRestart("muffleMessage")
[10:27:22.243]                       }
[10:27:22.243]                       else if (inherits(cond, "warning")) {
[10:27:22.243]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:22.243]                         if (muffled) 
[10:27:22.243]                           invokeRestart("muffleWarning")
[10:27:22.243]                       }
[10:27:22.243]                       else if (inherits(cond, "condition")) {
[10:27:22.243]                         if (!is.null(pattern)) {
[10:27:22.243]                           computeRestarts <- base::computeRestarts
[10:27:22.243]                           grepl <- base::grepl
[10:27:22.243]                           restarts <- computeRestarts(cond)
[10:27:22.243]                           for (restart in restarts) {
[10:27:22.243]                             name <- restart$name
[10:27:22.243]                             if (is.null(name)) 
[10:27:22.243]                               next
[10:27:22.243]                             if (!grepl(pattern, name)) 
[10:27:22.243]                               next
[10:27:22.243]                             invokeRestart(restart)
[10:27:22.243]                             muffled <- TRUE
[10:27:22.243]                             break
[10:27:22.243]                           }
[10:27:22.243]                         }
[10:27:22.243]                       }
[10:27:22.243]                       invisible(muffled)
[10:27:22.243]                     }
[10:27:22.243]                     muffleCondition(cond, pattern = "^muffle")
[10:27:22.243]                   }
[10:27:22.243]                 }
[10:27:22.243]                 else {
[10:27:22.243]                   if (TRUE) {
[10:27:22.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.243]                     {
[10:27:22.243]                       inherits <- base::inherits
[10:27:22.243]                       invokeRestart <- base::invokeRestart
[10:27:22.243]                       is.null <- base::is.null
[10:27:22.243]                       muffled <- FALSE
[10:27:22.243]                       if (inherits(cond, "message")) {
[10:27:22.243]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:22.243]                         if (muffled) 
[10:27:22.243]                           invokeRestart("muffleMessage")
[10:27:22.243]                       }
[10:27:22.243]                       else if (inherits(cond, "warning")) {
[10:27:22.243]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:22.243]                         if (muffled) 
[10:27:22.243]                           invokeRestart("muffleWarning")
[10:27:22.243]                       }
[10:27:22.243]                       else if (inherits(cond, "condition")) {
[10:27:22.243]                         if (!is.null(pattern)) {
[10:27:22.243]                           computeRestarts <- base::computeRestarts
[10:27:22.243]                           grepl <- base::grepl
[10:27:22.243]                           restarts <- computeRestarts(cond)
[10:27:22.243]                           for (restart in restarts) {
[10:27:22.243]                             name <- restart$name
[10:27:22.243]                             if (is.null(name)) 
[10:27:22.243]                               next
[10:27:22.243]                             if (!grepl(pattern, name)) 
[10:27:22.243]                               next
[10:27:22.243]                             invokeRestart(restart)
[10:27:22.243]                             muffled <- TRUE
[10:27:22.243]                             break
[10:27:22.243]                           }
[10:27:22.243]                         }
[10:27:22.243]                       }
[10:27:22.243]                       invisible(muffled)
[10:27:22.243]                     }
[10:27:22.243]                     muffleCondition(cond, pattern = "^muffle")
[10:27:22.243]                   }
[10:27:22.243]                 }
[10:27:22.243]             }
[10:27:22.243]         }))
[10:27:22.243]     }, error = function(ex) {
[10:27:22.243]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:22.243]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:22.243]                 ...future.rng), started = ...future.startTime, 
[10:27:22.243]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:22.243]             version = "1.8"), class = "FutureResult")
[10:27:22.243]     }, finally = {
[10:27:22.243]         if (!identical(...future.workdir, getwd())) 
[10:27:22.243]             setwd(...future.workdir)
[10:27:22.243]         {
[10:27:22.243]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:22.243]                 ...future.oldOptions$nwarnings <- NULL
[10:27:22.243]             }
[10:27:22.243]             base::options(...future.oldOptions)
[10:27:22.243]             if (.Platform$OS.type == "windows") {
[10:27:22.243]                 old_names <- names(...future.oldEnvVars)
[10:27:22.243]                 envs <- base::Sys.getenv()
[10:27:22.243]                 names <- names(envs)
[10:27:22.243]                 common <- intersect(names, old_names)
[10:27:22.243]                 added <- setdiff(names, old_names)
[10:27:22.243]                 removed <- setdiff(old_names, names)
[10:27:22.243]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:22.243]                   envs[common]]
[10:27:22.243]                 NAMES <- toupper(changed)
[10:27:22.243]                 args <- list()
[10:27:22.243]                 for (kk in seq_along(NAMES)) {
[10:27:22.243]                   name <- changed[[kk]]
[10:27:22.243]                   NAME <- NAMES[[kk]]
[10:27:22.243]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.243]                     next
[10:27:22.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:22.243]                 }
[10:27:22.243]                 NAMES <- toupper(added)
[10:27:22.243]                 for (kk in seq_along(NAMES)) {
[10:27:22.243]                   name <- added[[kk]]
[10:27:22.243]                   NAME <- NAMES[[kk]]
[10:27:22.243]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.243]                     next
[10:27:22.243]                   args[[name]] <- ""
[10:27:22.243]                 }
[10:27:22.243]                 NAMES <- toupper(removed)
[10:27:22.243]                 for (kk in seq_along(NAMES)) {
[10:27:22.243]                   name <- removed[[kk]]
[10:27:22.243]                   NAME <- NAMES[[kk]]
[10:27:22.243]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.243]                     next
[10:27:22.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:22.243]                 }
[10:27:22.243]                 if (length(args) > 0) 
[10:27:22.243]                   base::do.call(base::Sys.setenv, args = args)
[10:27:22.243]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:22.243]             }
[10:27:22.243]             else {
[10:27:22.243]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:22.243]             }
[10:27:22.243]             {
[10:27:22.243]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:22.243]                   0L) {
[10:27:22.243]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:22.243]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:22.243]                   base::options(opts)
[10:27:22.243]                 }
[10:27:22.243]                 {
[10:27:22.243]                   {
[10:27:22.243]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:22.243]                     NULL
[10:27:22.243]                   }
[10:27:22.243]                   options(future.plan = NULL)
[10:27:22.243]                   if (is.na(NA_character_)) 
[10:27:22.243]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:22.243]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:22.243]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:22.243]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:22.243]                     envir = parent.frame()) 
[10:27:22.243]                   {
[10:27:22.243]                     if (is.function(workers)) 
[10:27:22.243]                       workers <- workers()
[10:27:22.243]                     workers <- structure(as.integer(workers), 
[10:27:22.243]                       class = class(workers))
[10:27:22.243]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:22.243]                       workers >= 1)
[10:27:22.243]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:22.243]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:22.243]                     }
[10:27:22.243]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:22.243]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:22.243]                       envir = envir)
[10:27:22.243]                     if (!future$lazy) 
[10:27:22.243]                       future <- run(future)
[10:27:22.243]                     invisible(future)
[10:27:22.243]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:22.243]                 }
[10:27:22.243]             }
[10:27:22.243]         }
[10:27:22.243]     })
[10:27:22.243]     if (TRUE) {
[10:27:22.243]         base::sink(type = "output", split = FALSE)
[10:27:22.243]         if (TRUE) {
[10:27:22.243]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:22.243]         }
[10:27:22.243]         else {
[10:27:22.243]             ...future.result["stdout"] <- base::list(NULL)
[10:27:22.243]         }
[10:27:22.243]         base::close(...future.stdout)
[10:27:22.243]         ...future.stdout <- NULL
[10:27:22.243]     }
[10:27:22.243]     ...future.result$conditions <- ...future.conditions
[10:27:22.243]     ...future.result$finished <- base::Sys.time()
[10:27:22.243]     ...future.result
[10:27:22.243] }
[10:27:22.246] MultisessionFuture started
[10:27:22.246] - Launch lazy future ... done
[10:27:22.247] run() for ‘MultisessionFuture’ ... done
[10:27:22.247] getGlobalsAndPackages() ...
[10:27:22.247] Searching for globals...
[10:27:22.247] 
[10:27:22.247] Searching for globals ... DONE
[10:27:22.247] - globals: [0] <none>
[10:27:22.247] getGlobalsAndPackages() ... DONE
[10:27:22.248] run() for ‘Future’ ...
[10:27:22.248] - state: ‘created’
[10:27:22.248] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:22.266] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:22.266] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:22.267]   - Field: ‘node’
[10:27:22.267]   - Field: ‘label’
[10:27:22.267]   - Field: ‘local’
[10:27:22.267]   - Field: ‘owner’
[10:27:22.267]   - Field: ‘envir’
[10:27:22.267]   - Field: ‘workers’
[10:27:22.267]   - Field: ‘packages’
[10:27:22.267]   - Field: ‘gc’
[10:27:22.267]   - Field: ‘conditions’
[10:27:22.267]   - Field: ‘persistent’
[10:27:22.268]   - Field: ‘expr’
[10:27:22.268]   - Field: ‘uuid’
[10:27:22.268]   - Field: ‘seed’
[10:27:22.268]   - Field: ‘version’
[10:27:22.268]   - Field: ‘result’
[10:27:22.268]   - Field: ‘asynchronous’
[10:27:22.268]   - Field: ‘calls’
[10:27:22.268]   - Field: ‘globals’
[10:27:22.268]   - Field: ‘stdout’
[10:27:22.269]   - Field: ‘earlySignal’
[10:27:22.269]   - Field: ‘lazy’
[10:27:22.269]   - Field: ‘state’
[10:27:22.269] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:22.269] - Launch lazy future ...
[10:27:22.269] Packages needed by the future expression (n = 0): <none>
[10:27:22.270] Packages needed by future strategies (n = 0): <none>
[10:27:22.270] {
[10:27:22.270]     {
[10:27:22.270]         {
[10:27:22.270]             ...future.startTime <- base::Sys.time()
[10:27:22.270]             {
[10:27:22.270]                 {
[10:27:22.270]                   {
[10:27:22.270]                     {
[10:27:22.270]                       base::local({
[10:27:22.270]                         has_future <- base::requireNamespace("future", 
[10:27:22.270]                           quietly = TRUE)
[10:27:22.270]                         if (has_future) {
[10:27:22.270]                           ns <- base::getNamespace("future")
[10:27:22.270]                           version <- ns[[".package"]][["version"]]
[10:27:22.270]                           if (is.null(version)) 
[10:27:22.270]                             version <- utils::packageVersion("future")
[10:27:22.270]                         }
[10:27:22.270]                         else {
[10:27:22.270]                           version <- NULL
[10:27:22.270]                         }
[10:27:22.270]                         if (!has_future || version < "1.8.0") {
[10:27:22.270]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:22.270]                             "", base::R.version$version.string), 
[10:27:22.270]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:22.270]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:22.270]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:22.270]                               "release", "version")], collapse = " "), 
[10:27:22.270]                             hostname = base::Sys.info()[["nodename"]])
[10:27:22.270]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:22.270]                             info)
[10:27:22.270]                           info <- base::paste(info, collapse = "; ")
[10:27:22.270]                           if (!has_future) {
[10:27:22.270]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:22.270]                               info)
[10:27:22.270]                           }
[10:27:22.270]                           else {
[10:27:22.270]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:22.270]                               info, version)
[10:27:22.270]                           }
[10:27:22.270]                           base::stop(msg)
[10:27:22.270]                         }
[10:27:22.270]                       })
[10:27:22.270]                     }
[10:27:22.270]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:22.270]                     base::options(mc.cores = 1L)
[10:27:22.270]                   }
[10:27:22.270]                   options(future.plan = NULL)
[10:27:22.270]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:22.270]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:22.270]                 }
[10:27:22.270]                 ...future.workdir <- getwd()
[10:27:22.270]             }
[10:27:22.270]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:22.270]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:22.270]         }
[10:27:22.270]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:22.270]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:22.270]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:22.270]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:22.270]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:22.270]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:22.270]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:22.270]             base::names(...future.oldOptions))
[10:27:22.270]     }
[10:27:22.270]     if (FALSE) {
[10:27:22.270]     }
[10:27:22.270]     else {
[10:27:22.270]         if (TRUE) {
[10:27:22.270]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:22.270]                 open = "w")
[10:27:22.270]         }
[10:27:22.270]         else {
[10:27:22.270]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:22.270]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:22.270]         }
[10:27:22.270]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:22.270]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:22.270]             base::sink(type = "output", split = FALSE)
[10:27:22.270]             base::close(...future.stdout)
[10:27:22.270]         }, add = TRUE)
[10:27:22.270]     }
[10:27:22.270]     ...future.frame <- base::sys.nframe()
[10:27:22.270]     ...future.conditions <- base::list()
[10:27:22.270]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:22.270]     if (FALSE) {
[10:27:22.270]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:22.270]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:22.270]     }
[10:27:22.270]     ...future.result <- base::tryCatch({
[10:27:22.270]         base::withCallingHandlers({
[10:27:22.270]             ...future.value <- base::withVisible(base::local({
[10:27:22.270]                 ...future.makeSendCondition <- base::local({
[10:27:22.270]                   sendCondition <- NULL
[10:27:22.270]                   function(frame = 1L) {
[10:27:22.270]                     if (is.function(sendCondition)) 
[10:27:22.270]                       return(sendCondition)
[10:27:22.270]                     ns <- getNamespace("parallel")
[10:27:22.270]                     if (exists("sendData", mode = "function", 
[10:27:22.270]                       envir = ns)) {
[10:27:22.270]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:22.270]                         envir = ns)
[10:27:22.270]                       envir <- sys.frame(frame)
[10:27:22.270]                       master <- NULL
[10:27:22.270]                       while (!identical(envir, .GlobalEnv) && 
[10:27:22.270]                         !identical(envir, emptyenv())) {
[10:27:22.270]                         if (exists("master", mode = "list", envir = envir, 
[10:27:22.270]                           inherits = FALSE)) {
[10:27:22.270]                           master <- get("master", mode = "list", 
[10:27:22.270]                             envir = envir, inherits = FALSE)
[10:27:22.270]                           if (inherits(master, c("SOCKnode", 
[10:27:22.270]                             "SOCK0node"))) {
[10:27:22.270]                             sendCondition <<- function(cond) {
[10:27:22.270]                               data <- list(type = "VALUE", value = cond, 
[10:27:22.270]                                 success = TRUE)
[10:27:22.270]                               parallel_sendData(master, data)
[10:27:22.270]                             }
[10:27:22.270]                             return(sendCondition)
[10:27:22.270]                           }
[10:27:22.270]                         }
[10:27:22.270]                         frame <- frame + 1L
[10:27:22.270]                         envir <- sys.frame(frame)
[10:27:22.270]                       }
[10:27:22.270]                     }
[10:27:22.270]                     sendCondition <<- function(cond) NULL
[10:27:22.270]                   }
[10:27:22.270]                 })
[10:27:22.270]                 withCallingHandlers({
[10:27:22.270]                   2
[10:27:22.270]                 }, immediateCondition = function(cond) {
[10:27:22.270]                   sendCondition <- ...future.makeSendCondition()
[10:27:22.270]                   sendCondition(cond)
[10:27:22.270]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.270]                   {
[10:27:22.270]                     inherits <- base::inherits
[10:27:22.270]                     invokeRestart <- base::invokeRestart
[10:27:22.270]                     is.null <- base::is.null
[10:27:22.270]                     muffled <- FALSE
[10:27:22.270]                     if (inherits(cond, "message")) {
[10:27:22.270]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:22.270]                       if (muffled) 
[10:27:22.270]                         invokeRestart("muffleMessage")
[10:27:22.270]                     }
[10:27:22.270]                     else if (inherits(cond, "warning")) {
[10:27:22.270]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:22.270]                       if (muffled) 
[10:27:22.270]                         invokeRestart("muffleWarning")
[10:27:22.270]                     }
[10:27:22.270]                     else if (inherits(cond, "condition")) {
[10:27:22.270]                       if (!is.null(pattern)) {
[10:27:22.270]                         computeRestarts <- base::computeRestarts
[10:27:22.270]                         grepl <- base::grepl
[10:27:22.270]                         restarts <- computeRestarts(cond)
[10:27:22.270]                         for (restart in restarts) {
[10:27:22.270]                           name <- restart$name
[10:27:22.270]                           if (is.null(name)) 
[10:27:22.270]                             next
[10:27:22.270]                           if (!grepl(pattern, name)) 
[10:27:22.270]                             next
[10:27:22.270]                           invokeRestart(restart)
[10:27:22.270]                           muffled <- TRUE
[10:27:22.270]                           break
[10:27:22.270]                         }
[10:27:22.270]                       }
[10:27:22.270]                     }
[10:27:22.270]                     invisible(muffled)
[10:27:22.270]                   }
[10:27:22.270]                   muffleCondition(cond)
[10:27:22.270]                 })
[10:27:22.270]             }))
[10:27:22.270]             future::FutureResult(value = ...future.value$value, 
[10:27:22.270]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:22.270]                   ...future.rng), globalenv = if (FALSE) 
[10:27:22.270]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:22.270]                     ...future.globalenv.names))
[10:27:22.270]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:22.270]         }, condition = base::local({
[10:27:22.270]             c <- base::c
[10:27:22.270]             inherits <- base::inherits
[10:27:22.270]             invokeRestart <- base::invokeRestart
[10:27:22.270]             length <- base::length
[10:27:22.270]             list <- base::list
[10:27:22.270]             seq.int <- base::seq.int
[10:27:22.270]             signalCondition <- base::signalCondition
[10:27:22.270]             sys.calls <- base::sys.calls
[10:27:22.270]             `[[` <- base::`[[`
[10:27:22.270]             `+` <- base::`+`
[10:27:22.270]             `<<-` <- base::`<<-`
[10:27:22.270]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:22.270]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:22.270]                   3L)]
[10:27:22.270]             }
[10:27:22.270]             function(cond) {
[10:27:22.270]                 is_error <- inherits(cond, "error")
[10:27:22.270]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:22.270]                   NULL)
[10:27:22.270]                 if (is_error) {
[10:27:22.270]                   sessionInformation <- function() {
[10:27:22.270]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:22.270]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:22.270]                       search = base::search(), system = base::Sys.info())
[10:27:22.270]                   }
[10:27:22.270]                   ...future.conditions[[length(...future.conditions) + 
[10:27:22.270]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:22.270]                     cond$call), session = sessionInformation(), 
[10:27:22.270]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:22.270]                   signalCondition(cond)
[10:27:22.270]                 }
[10:27:22.270]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:22.270]                 "immediateCondition"))) {
[10:27:22.270]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:22.270]                   ...future.conditions[[length(...future.conditions) + 
[10:27:22.270]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:22.270]                   if (TRUE && !signal) {
[10:27:22.270]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.270]                     {
[10:27:22.270]                       inherits <- base::inherits
[10:27:22.270]                       invokeRestart <- base::invokeRestart
[10:27:22.270]                       is.null <- base::is.null
[10:27:22.270]                       muffled <- FALSE
[10:27:22.270]                       if (inherits(cond, "message")) {
[10:27:22.270]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:22.270]                         if (muffled) 
[10:27:22.270]                           invokeRestart("muffleMessage")
[10:27:22.270]                       }
[10:27:22.270]                       else if (inherits(cond, "warning")) {
[10:27:22.270]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:22.270]                         if (muffled) 
[10:27:22.270]                           invokeRestart("muffleWarning")
[10:27:22.270]                       }
[10:27:22.270]                       else if (inherits(cond, "condition")) {
[10:27:22.270]                         if (!is.null(pattern)) {
[10:27:22.270]                           computeRestarts <- base::computeRestarts
[10:27:22.270]                           grepl <- base::grepl
[10:27:22.270]                           restarts <- computeRestarts(cond)
[10:27:22.270]                           for (restart in restarts) {
[10:27:22.270]                             name <- restart$name
[10:27:22.270]                             if (is.null(name)) 
[10:27:22.270]                               next
[10:27:22.270]                             if (!grepl(pattern, name)) 
[10:27:22.270]                               next
[10:27:22.270]                             invokeRestart(restart)
[10:27:22.270]                             muffled <- TRUE
[10:27:22.270]                             break
[10:27:22.270]                           }
[10:27:22.270]                         }
[10:27:22.270]                       }
[10:27:22.270]                       invisible(muffled)
[10:27:22.270]                     }
[10:27:22.270]                     muffleCondition(cond, pattern = "^muffle")
[10:27:22.270]                   }
[10:27:22.270]                 }
[10:27:22.270]                 else {
[10:27:22.270]                   if (TRUE) {
[10:27:22.270]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.270]                     {
[10:27:22.270]                       inherits <- base::inherits
[10:27:22.270]                       invokeRestart <- base::invokeRestart
[10:27:22.270]                       is.null <- base::is.null
[10:27:22.270]                       muffled <- FALSE
[10:27:22.270]                       if (inherits(cond, "message")) {
[10:27:22.270]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:22.270]                         if (muffled) 
[10:27:22.270]                           invokeRestart("muffleMessage")
[10:27:22.270]                       }
[10:27:22.270]                       else if (inherits(cond, "warning")) {
[10:27:22.270]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:22.270]                         if (muffled) 
[10:27:22.270]                           invokeRestart("muffleWarning")
[10:27:22.270]                       }
[10:27:22.270]                       else if (inherits(cond, "condition")) {
[10:27:22.270]                         if (!is.null(pattern)) {
[10:27:22.270]                           computeRestarts <- base::computeRestarts
[10:27:22.270]                           grepl <- base::grepl
[10:27:22.270]                           restarts <- computeRestarts(cond)
[10:27:22.270]                           for (restart in restarts) {
[10:27:22.270]                             name <- restart$name
[10:27:22.270]                             if (is.null(name)) 
[10:27:22.270]                               next
[10:27:22.270]                             if (!grepl(pattern, name)) 
[10:27:22.270]                               next
[10:27:22.270]                             invokeRestart(restart)
[10:27:22.270]                             muffled <- TRUE
[10:27:22.270]                             break
[10:27:22.270]                           }
[10:27:22.270]                         }
[10:27:22.270]                       }
[10:27:22.270]                       invisible(muffled)
[10:27:22.270]                     }
[10:27:22.270]                     muffleCondition(cond, pattern = "^muffle")
[10:27:22.270]                   }
[10:27:22.270]                 }
[10:27:22.270]             }
[10:27:22.270]         }))
[10:27:22.270]     }, error = function(ex) {
[10:27:22.270]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:22.270]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:22.270]                 ...future.rng), started = ...future.startTime, 
[10:27:22.270]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:22.270]             version = "1.8"), class = "FutureResult")
[10:27:22.270]     }, finally = {
[10:27:22.270]         if (!identical(...future.workdir, getwd())) 
[10:27:22.270]             setwd(...future.workdir)
[10:27:22.270]         {
[10:27:22.270]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:22.270]                 ...future.oldOptions$nwarnings <- NULL
[10:27:22.270]             }
[10:27:22.270]             base::options(...future.oldOptions)
[10:27:22.270]             if (.Platform$OS.type == "windows") {
[10:27:22.270]                 old_names <- names(...future.oldEnvVars)
[10:27:22.270]                 envs <- base::Sys.getenv()
[10:27:22.270]                 names <- names(envs)
[10:27:22.270]                 common <- intersect(names, old_names)
[10:27:22.270]                 added <- setdiff(names, old_names)
[10:27:22.270]                 removed <- setdiff(old_names, names)
[10:27:22.270]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:22.270]                   envs[common]]
[10:27:22.270]                 NAMES <- toupper(changed)
[10:27:22.270]                 args <- list()
[10:27:22.270]                 for (kk in seq_along(NAMES)) {
[10:27:22.270]                   name <- changed[[kk]]
[10:27:22.270]                   NAME <- NAMES[[kk]]
[10:27:22.270]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.270]                     next
[10:27:22.270]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:22.270]                 }
[10:27:22.270]                 NAMES <- toupper(added)
[10:27:22.270]                 for (kk in seq_along(NAMES)) {
[10:27:22.270]                   name <- added[[kk]]
[10:27:22.270]                   NAME <- NAMES[[kk]]
[10:27:22.270]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.270]                     next
[10:27:22.270]                   args[[name]] <- ""
[10:27:22.270]                 }
[10:27:22.270]                 NAMES <- toupper(removed)
[10:27:22.270]                 for (kk in seq_along(NAMES)) {
[10:27:22.270]                   name <- removed[[kk]]
[10:27:22.270]                   NAME <- NAMES[[kk]]
[10:27:22.270]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.270]                     next
[10:27:22.270]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:22.270]                 }
[10:27:22.270]                 if (length(args) > 0) 
[10:27:22.270]                   base::do.call(base::Sys.setenv, args = args)
[10:27:22.270]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:22.270]             }
[10:27:22.270]             else {
[10:27:22.270]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:22.270]             }
[10:27:22.270]             {
[10:27:22.270]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:22.270]                   0L) {
[10:27:22.270]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:22.270]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:22.270]                   base::options(opts)
[10:27:22.270]                 }
[10:27:22.270]                 {
[10:27:22.270]                   {
[10:27:22.270]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:22.270]                     NULL
[10:27:22.270]                   }
[10:27:22.270]                   options(future.plan = NULL)
[10:27:22.270]                   if (is.na(NA_character_)) 
[10:27:22.270]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:22.270]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:22.270]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:22.270]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:22.270]                     envir = parent.frame()) 
[10:27:22.270]                   {
[10:27:22.270]                     if (is.function(workers)) 
[10:27:22.270]                       workers <- workers()
[10:27:22.270]                     workers <- structure(as.integer(workers), 
[10:27:22.270]                       class = class(workers))
[10:27:22.270]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:22.270]                       workers >= 1)
[10:27:22.270]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:22.270]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:22.270]                     }
[10:27:22.270]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:22.270]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:22.270]                       envir = envir)
[10:27:22.270]                     if (!future$lazy) 
[10:27:22.270]                       future <- run(future)
[10:27:22.270]                     invisible(future)
[10:27:22.270]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:22.270]                 }
[10:27:22.270]             }
[10:27:22.270]         }
[10:27:22.270]     })
[10:27:22.270]     if (TRUE) {
[10:27:22.270]         base::sink(type = "output", split = FALSE)
[10:27:22.270]         if (TRUE) {
[10:27:22.270]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:22.270]         }
[10:27:22.270]         else {
[10:27:22.270]             ...future.result["stdout"] <- base::list(NULL)
[10:27:22.270]         }
[10:27:22.270]         base::close(...future.stdout)
[10:27:22.270]         ...future.stdout <- NULL
[10:27:22.270]     }
[10:27:22.270]     ...future.result$conditions <- ...future.conditions
[10:27:22.270]     ...future.result$finished <- base::Sys.time()
[10:27:22.270]     ...future.result
[10:27:22.270] }
[10:27:22.275] MultisessionFuture started
[10:27:22.275] - Launch lazy future ... done
[10:27:22.276] run() for ‘MultisessionFuture’ ... done
[10:27:22.277] resolve() on environment ...
[10:27:22.277]  recursive: 0
[10:27:22.278]  elements: [3] ‘a’, ‘b’, ‘c’
[10:27:22.299]  length: 2 (resolved future 3)
[10:27:22.311] receiveMessageFromWorker() for ClusterFuture ...
[10:27:22.311] - Validating connection of MultisessionFuture
[10:27:22.311] - received message: FutureResult
[10:27:22.311] - Received FutureResult
[10:27:22.311] - Erased future from FutureRegistry
[10:27:22.312] result() for ClusterFuture ...
[10:27:22.312] - result already collected: FutureResult
[10:27:22.312] result() for ClusterFuture ... done
[10:27:22.312] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:22.312] Future #1
[10:27:22.312]  length: 1 (resolved future 1)
[10:27:22.333] receiveMessageFromWorker() for ClusterFuture ...
[10:27:22.334] - Validating connection of MultisessionFuture
[10:27:22.334] - received message: FutureResult
[10:27:22.334] - Received FutureResult
[10:27:22.334] - Erased future from FutureRegistry
[10:27:22.334] result() for ClusterFuture ...
[10:27:22.334] - result already collected: FutureResult
[10:27:22.334] result() for ClusterFuture ... done
[10:27:22.335] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:22.335] Future #2
[10:27:22.335]  length: 0 (resolved future 2)
[10:27:22.335] resolve() on environment ... DONE
[10:27:22.336] getGlobalsAndPackages() ...
[10:27:22.336] Searching for globals...
[10:27:22.336] - globals found: [1] ‘{’
[10:27:22.337] Searching for globals ... DONE
[10:27:22.337] Resolving globals: FALSE
[10:27:22.337] 
[10:27:22.337] 
[10:27:22.337] getGlobalsAndPackages() ... DONE
[10:27:22.338] run() for ‘Future’ ...
[10:27:22.338] - state: ‘created’
[10:27:22.338] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:22.353] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:22.353] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:22.353]   - Field: ‘node’
[10:27:22.353]   - Field: ‘label’
[10:27:22.353]   - Field: ‘local’
[10:27:22.353]   - Field: ‘owner’
[10:27:22.353]   - Field: ‘envir’
[10:27:22.353]   - Field: ‘workers’
[10:27:22.354]   - Field: ‘packages’
[10:27:22.354]   - Field: ‘gc’
[10:27:22.354]   - Field: ‘conditions’
[10:27:22.354]   - Field: ‘persistent’
[10:27:22.354]   - Field: ‘expr’
[10:27:22.354]   - Field: ‘uuid’
[10:27:22.354]   - Field: ‘seed’
[10:27:22.354]   - Field: ‘version’
[10:27:22.354]   - Field: ‘result’
[10:27:22.354]   - Field: ‘asynchronous’
[10:27:22.355]   - Field: ‘calls’
[10:27:22.355]   - Field: ‘globals’
[10:27:22.355]   - Field: ‘stdout’
[10:27:22.355]   - Field: ‘earlySignal’
[10:27:22.355]   - Field: ‘lazy’
[10:27:22.355]   - Field: ‘state’
[10:27:22.355] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:22.355] - Launch lazy future ...
[10:27:22.356] Packages needed by the future expression (n = 0): <none>
[10:27:22.356] Packages needed by future strategies (n = 0): <none>
[10:27:22.356] {
[10:27:22.356]     {
[10:27:22.356]         {
[10:27:22.356]             ...future.startTime <- base::Sys.time()
[10:27:22.356]             {
[10:27:22.356]                 {
[10:27:22.356]                   {
[10:27:22.356]                     {
[10:27:22.356]                       base::local({
[10:27:22.356]                         has_future <- base::requireNamespace("future", 
[10:27:22.356]                           quietly = TRUE)
[10:27:22.356]                         if (has_future) {
[10:27:22.356]                           ns <- base::getNamespace("future")
[10:27:22.356]                           version <- ns[[".package"]][["version"]]
[10:27:22.356]                           if (is.null(version)) 
[10:27:22.356]                             version <- utils::packageVersion("future")
[10:27:22.356]                         }
[10:27:22.356]                         else {
[10:27:22.356]                           version <- NULL
[10:27:22.356]                         }
[10:27:22.356]                         if (!has_future || version < "1.8.0") {
[10:27:22.356]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:22.356]                             "", base::R.version$version.string), 
[10:27:22.356]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:22.356]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:22.356]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:22.356]                               "release", "version")], collapse = " "), 
[10:27:22.356]                             hostname = base::Sys.info()[["nodename"]])
[10:27:22.356]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:22.356]                             info)
[10:27:22.356]                           info <- base::paste(info, collapse = "; ")
[10:27:22.356]                           if (!has_future) {
[10:27:22.356]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:22.356]                               info)
[10:27:22.356]                           }
[10:27:22.356]                           else {
[10:27:22.356]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:22.356]                               info, version)
[10:27:22.356]                           }
[10:27:22.356]                           base::stop(msg)
[10:27:22.356]                         }
[10:27:22.356]                       })
[10:27:22.356]                     }
[10:27:22.356]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:22.356]                     base::options(mc.cores = 1L)
[10:27:22.356]                   }
[10:27:22.356]                   options(future.plan = NULL)
[10:27:22.356]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:22.356]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:22.356]                 }
[10:27:22.356]                 ...future.workdir <- getwd()
[10:27:22.356]             }
[10:27:22.356]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:22.356]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:22.356]         }
[10:27:22.356]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:22.356]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:22.356]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:22.356]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:22.356]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:22.356]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:22.356]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:22.356]             base::names(...future.oldOptions))
[10:27:22.356]     }
[10:27:22.356]     if (FALSE) {
[10:27:22.356]     }
[10:27:22.356]     else {
[10:27:22.356]         if (TRUE) {
[10:27:22.356]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:22.356]                 open = "w")
[10:27:22.356]         }
[10:27:22.356]         else {
[10:27:22.356]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:22.356]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:22.356]         }
[10:27:22.356]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:22.356]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:22.356]             base::sink(type = "output", split = FALSE)
[10:27:22.356]             base::close(...future.stdout)
[10:27:22.356]         }, add = TRUE)
[10:27:22.356]     }
[10:27:22.356]     ...future.frame <- base::sys.nframe()
[10:27:22.356]     ...future.conditions <- base::list()
[10:27:22.356]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:22.356]     if (FALSE) {
[10:27:22.356]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:22.356]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:22.356]     }
[10:27:22.356]     ...future.result <- base::tryCatch({
[10:27:22.356]         base::withCallingHandlers({
[10:27:22.356]             ...future.value <- base::withVisible(base::local({
[10:27:22.356]                 ...future.makeSendCondition <- base::local({
[10:27:22.356]                   sendCondition <- NULL
[10:27:22.356]                   function(frame = 1L) {
[10:27:22.356]                     if (is.function(sendCondition)) 
[10:27:22.356]                       return(sendCondition)
[10:27:22.356]                     ns <- getNamespace("parallel")
[10:27:22.356]                     if (exists("sendData", mode = "function", 
[10:27:22.356]                       envir = ns)) {
[10:27:22.356]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:22.356]                         envir = ns)
[10:27:22.356]                       envir <- sys.frame(frame)
[10:27:22.356]                       master <- NULL
[10:27:22.356]                       while (!identical(envir, .GlobalEnv) && 
[10:27:22.356]                         !identical(envir, emptyenv())) {
[10:27:22.356]                         if (exists("master", mode = "list", envir = envir, 
[10:27:22.356]                           inherits = FALSE)) {
[10:27:22.356]                           master <- get("master", mode = "list", 
[10:27:22.356]                             envir = envir, inherits = FALSE)
[10:27:22.356]                           if (inherits(master, c("SOCKnode", 
[10:27:22.356]                             "SOCK0node"))) {
[10:27:22.356]                             sendCondition <<- function(cond) {
[10:27:22.356]                               data <- list(type = "VALUE", value = cond, 
[10:27:22.356]                                 success = TRUE)
[10:27:22.356]                               parallel_sendData(master, data)
[10:27:22.356]                             }
[10:27:22.356]                             return(sendCondition)
[10:27:22.356]                           }
[10:27:22.356]                         }
[10:27:22.356]                         frame <- frame + 1L
[10:27:22.356]                         envir <- sys.frame(frame)
[10:27:22.356]                       }
[10:27:22.356]                     }
[10:27:22.356]                     sendCondition <<- function(cond) NULL
[10:27:22.356]                   }
[10:27:22.356]                 })
[10:27:22.356]                 withCallingHandlers({
[10:27:22.356]                   {
[10:27:22.356]                     1
[10:27:22.356]                   }
[10:27:22.356]                 }, immediateCondition = function(cond) {
[10:27:22.356]                   sendCondition <- ...future.makeSendCondition()
[10:27:22.356]                   sendCondition(cond)
[10:27:22.356]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.356]                   {
[10:27:22.356]                     inherits <- base::inherits
[10:27:22.356]                     invokeRestart <- base::invokeRestart
[10:27:22.356]                     is.null <- base::is.null
[10:27:22.356]                     muffled <- FALSE
[10:27:22.356]                     if (inherits(cond, "message")) {
[10:27:22.356]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:22.356]                       if (muffled) 
[10:27:22.356]                         invokeRestart("muffleMessage")
[10:27:22.356]                     }
[10:27:22.356]                     else if (inherits(cond, "warning")) {
[10:27:22.356]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:22.356]                       if (muffled) 
[10:27:22.356]                         invokeRestart("muffleWarning")
[10:27:22.356]                     }
[10:27:22.356]                     else if (inherits(cond, "condition")) {
[10:27:22.356]                       if (!is.null(pattern)) {
[10:27:22.356]                         computeRestarts <- base::computeRestarts
[10:27:22.356]                         grepl <- base::grepl
[10:27:22.356]                         restarts <- computeRestarts(cond)
[10:27:22.356]                         for (restart in restarts) {
[10:27:22.356]                           name <- restart$name
[10:27:22.356]                           if (is.null(name)) 
[10:27:22.356]                             next
[10:27:22.356]                           if (!grepl(pattern, name)) 
[10:27:22.356]                             next
[10:27:22.356]                           invokeRestart(restart)
[10:27:22.356]                           muffled <- TRUE
[10:27:22.356]                           break
[10:27:22.356]                         }
[10:27:22.356]                       }
[10:27:22.356]                     }
[10:27:22.356]                     invisible(muffled)
[10:27:22.356]                   }
[10:27:22.356]                   muffleCondition(cond)
[10:27:22.356]                 })
[10:27:22.356]             }))
[10:27:22.356]             future::FutureResult(value = ...future.value$value, 
[10:27:22.356]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:22.356]                   ...future.rng), globalenv = if (FALSE) 
[10:27:22.356]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:22.356]                     ...future.globalenv.names))
[10:27:22.356]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:22.356]         }, condition = base::local({
[10:27:22.356]             c <- base::c
[10:27:22.356]             inherits <- base::inherits
[10:27:22.356]             invokeRestart <- base::invokeRestart
[10:27:22.356]             length <- base::length
[10:27:22.356]             list <- base::list
[10:27:22.356]             seq.int <- base::seq.int
[10:27:22.356]             signalCondition <- base::signalCondition
[10:27:22.356]             sys.calls <- base::sys.calls
[10:27:22.356]             `[[` <- base::`[[`
[10:27:22.356]             `+` <- base::`+`
[10:27:22.356]             `<<-` <- base::`<<-`
[10:27:22.356]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:22.356]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:22.356]                   3L)]
[10:27:22.356]             }
[10:27:22.356]             function(cond) {
[10:27:22.356]                 is_error <- inherits(cond, "error")
[10:27:22.356]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:22.356]                   NULL)
[10:27:22.356]                 if (is_error) {
[10:27:22.356]                   sessionInformation <- function() {
[10:27:22.356]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:22.356]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:22.356]                       search = base::search(), system = base::Sys.info())
[10:27:22.356]                   }
[10:27:22.356]                   ...future.conditions[[length(...future.conditions) + 
[10:27:22.356]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:22.356]                     cond$call), session = sessionInformation(), 
[10:27:22.356]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:22.356]                   signalCondition(cond)
[10:27:22.356]                 }
[10:27:22.356]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:22.356]                 "immediateCondition"))) {
[10:27:22.356]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:22.356]                   ...future.conditions[[length(...future.conditions) + 
[10:27:22.356]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:22.356]                   if (TRUE && !signal) {
[10:27:22.356]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.356]                     {
[10:27:22.356]                       inherits <- base::inherits
[10:27:22.356]                       invokeRestart <- base::invokeRestart
[10:27:22.356]                       is.null <- base::is.null
[10:27:22.356]                       muffled <- FALSE
[10:27:22.356]                       if (inherits(cond, "message")) {
[10:27:22.356]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:22.356]                         if (muffled) 
[10:27:22.356]                           invokeRestart("muffleMessage")
[10:27:22.356]                       }
[10:27:22.356]                       else if (inherits(cond, "warning")) {
[10:27:22.356]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:22.356]                         if (muffled) 
[10:27:22.356]                           invokeRestart("muffleWarning")
[10:27:22.356]                       }
[10:27:22.356]                       else if (inherits(cond, "condition")) {
[10:27:22.356]                         if (!is.null(pattern)) {
[10:27:22.356]                           computeRestarts <- base::computeRestarts
[10:27:22.356]                           grepl <- base::grepl
[10:27:22.356]                           restarts <- computeRestarts(cond)
[10:27:22.356]                           for (restart in restarts) {
[10:27:22.356]                             name <- restart$name
[10:27:22.356]                             if (is.null(name)) 
[10:27:22.356]                               next
[10:27:22.356]                             if (!grepl(pattern, name)) 
[10:27:22.356]                               next
[10:27:22.356]                             invokeRestart(restart)
[10:27:22.356]                             muffled <- TRUE
[10:27:22.356]                             break
[10:27:22.356]                           }
[10:27:22.356]                         }
[10:27:22.356]                       }
[10:27:22.356]                       invisible(muffled)
[10:27:22.356]                     }
[10:27:22.356]                     muffleCondition(cond, pattern = "^muffle")
[10:27:22.356]                   }
[10:27:22.356]                 }
[10:27:22.356]                 else {
[10:27:22.356]                   if (TRUE) {
[10:27:22.356]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.356]                     {
[10:27:22.356]                       inherits <- base::inherits
[10:27:22.356]                       invokeRestart <- base::invokeRestart
[10:27:22.356]                       is.null <- base::is.null
[10:27:22.356]                       muffled <- FALSE
[10:27:22.356]                       if (inherits(cond, "message")) {
[10:27:22.356]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:22.356]                         if (muffled) 
[10:27:22.356]                           invokeRestart("muffleMessage")
[10:27:22.356]                       }
[10:27:22.356]                       else if (inherits(cond, "warning")) {
[10:27:22.356]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:22.356]                         if (muffled) 
[10:27:22.356]                           invokeRestart("muffleWarning")
[10:27:22.356]                       }
[10:27:22.356]                       else if (inherits(cond, "condition")) {
[10:27:22.356]                         if (!is.null(pattern)) {
[10:27:22.356]                           computeRestarts <- base::computeRestarts
[10:27:22.356]                           grepl <- base::grepl
[10:27:22.356]                           restarts <- computeRestarts(cond)
[10:27:22.356]                           for (restart in restarts) {
[10:27:22.356]                             name <- restart$name
[10:27:22.356]                             if (is.null(name)) 
[10:27:22.356]                               next
[10:27:22.356]                             if (!grepl(pattern, name)) 
[10:27:22.356]                               next
[10:27:22.356]                             invokeRestart(restart)
[10:27:22.356]                             muffled <- TRUE
[10:27:22.356]                             break
[10:27:22.356]                           }
[10:27:22.356]                         }
[10:27:22.356]                       }
[10:27:22.356]                       invisible(muffled)
[10:27:22.356]                     }
[10:27:22.356]                     muffleCondition(cond, pattern = "^muffle")
[10:27:22.356]                   }
[10:27:22.356]                 }
[10:27:22.356]             }
[10:27:22.356]         }))
[10:27:22.356]     }, error = function(ex) {
[10:27:22.356]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:22.356]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:22.356]                 ...future.rng), started = ...future.startTime, 
[10:27:22.356]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:22.356]             version = "1.8"), class = "FutureResult")
[10:27:22.356]     }, finally = {
[10:27:22.356]         if (!identical(...future.workdir, getwd())) 
[10:27:22.356]             setwd(...future.workdir)
[10:27:22.356]         {
[10:27:22.356]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:22.356]                 ...future.oldOptions$nwarnings <- NULL
[10:27:22.356]             }
[10:27:22.356]             base::options(...future.oldOptions)
[10:27:22.356]             if (.Platform$OS.type == "windows") {
[10:27:22.356]                 old_names <- names(...future.oldEnvVars)
[10:27:22.356]                 envs <- base::Sys.getenv()
[10:27:22.356]                 names <- names(envs)
[10:27:22.356]                 common <- intersect(names, old_names)
[10:27:22.356]                 added <- setdiff(names, old_names)
[10:27:22.356]                 removed <- setdiff(old_names, names)
[10:27:22.356]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:22.356]                   envs[common]]
[10:27:22.356]                 NAMES <- toupper(changed)
[10:27:22.356]                 args <- list()
[10:27:22.356]                 for (kk in seq_along(NAMES)) {
[10:27:22.356]                   name <- changed[[kk]]
[10:27:22.356]                   NAME <- NAMES[[kk]]
[10:27:22.356]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.356]                     next
[10:27:22.356]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:22.356]                 }
[10:27:22.356]                 NAMES <- toupper(added)
[10:27:22.356]                 for (kk in seq_along(NAMES)) {
[10:27:22.356]                   name <- added[[kk]]
[10:27:22.356]                   NAME <- NAMES[[kk]]
[10:27:22.356]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.356]                     next
[10:27:22.356]                   args[[name]] <- ""
[10:27:22.356]                 }
[10:27:22.356]                 NAMES <- toupper(removed)
[10:27:22.356]                 for (kk in seq_along(NAMES)) {
[10:27:22.356]                   name <- removed[[kk]]
[10:27:22.356]                   NAME <- NAMES[[kk]]
[10:27:22.356]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.356]                     next
[10:27:22.356]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:22.356]                 }
[10:27:22.356]                 if (length(args) > 0) 
[10:27:22.356]                   base::do.call(base::Sys.setenv, args = args)
[10:27:22.356]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:22.356]             }
[10:27:22.356]             else {
[10:27:22.356]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:22.356]             }
[10:27:22.356]             {
[10:27:22.356]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:22.356]                   0L) {
[10:27:22.356]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:22.356]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:22.356]                   base::options(opts)
[10:27:22.356]                 }
[10:27:22.356]                 {
[10:27:22.356]                   {
[10:27:22.356]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:22.356]                     NULL
[10:27:22.356]                   }
[10:27:22.356]                   options(future.plan = NULL)
[10:27:22.356]                   if (is.na(NA_character_)) 
[10:27:22.356]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:22.356]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:22.356]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:22.356]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:22.356]                     envir = parent.frame()) 
[10:27:22.356]                   {
[10:27:22.356]                     if (is.function(workers)) 
[10:27:22.356]                       workers <- workers()
[10:27:22.356]                     workers <- structure(as.integer(workers), 
[10:27:22.356]                       class = class(workers))
[10:27:22.356]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:22.356]                       workers >= 1)
[10:27:22.356]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:22.356]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:22.356]                     }
[10:27:22.356]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:22.356]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:22.356]                       envir = envir)
[10:27:22.356]                     if (!future$lazy) 
[10:27:22.356]                       future <- run(future)
[10:27:22.356]                     invisible(future)
[10:27:22.356]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:22.356]                 }
[10:27:22.356]             }
[10:27:22.356]         }
[10:27:22.356]     })
[10:27:22.356]     if (TRUE) {
[10:27:22.356]         base::sink(type = "output", split = FALSE)
[10:27:22.356]         if (TRUE) {
[10:27:22.356]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:22.356]         }
[10:27:22.356]         else {
[10:27:22.356]             ...future.result["stdout"] <- base::list(NULL)
[10:27:22.356]         }
[10:27:22.356]         base::close(...future.stdout)
[10:27:22.356]         ...future.stdout <- NULL
[10:27:22.356]     }
[10:27:22.356]     ...future.result$conditions <- ...future.conditions
[10:27:22.356]     ...future.result$finished <- base::Sys.time()
[10:27:22.356]     ...future.result
[10:27:22.356] }
[10:27:22.360] MultisessionFuture started
[10:27:22.360] - Launch lazy future ... done
[10:27:22.360] run() for ‘MultisessionFuture’ ... done
[10:27:22.360] getGlobalsAndPackages() ...
[10:27:22.360] Searching for globals...
[10:27:22.361] - globals found: [1] ‘{’
[10:27:22.361] Searching for globals ... DONE
[10:27:22.361] Resolving globals: FALSE
[10:27:22.362] 
[10:27:22.362] 
[10:27:22.362] getGlobalsAndPackages() ... DONE
[10:27:22.362] run() for ‘Future’ ...
[10:27:22.362] - state: ‘created’
[10:27:22.362] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:22.379] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:22.379] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:22.379]   - Field: ‘node’
[10:27:22.379]   - Field: ‘label’
[10:27:22.379]   - Field: ‘local’
[10:27:22.379]   - Field: ‘owner’
[10:27:22.380]   - Field: ‘envir’
[10:27:22.380]   - Field: ‘workers’
[10:27:22.380]   - Field: ‘packages’
[10:27:22.380]   - Field: ‘gc’
[10:27:22.380]   - Field: ‘conditions’
[10:27:22.380]   - Field: ‘persistent’
[10:27:22.380]   - Field: ‘expr’
[10:27:22.380]   - Field: ‘uuid’
[10:27:22.380]   - Field: ‘seed’
[10:27:22.380]   - Field: ‘version’
[10:27:22.380]   - Field: ‘result’
[10:27:22.381]   - Field: ‘asynchronous’
[10:27:22.381]   - Field: ‘calls’
[10:27:22.381]   - Field: ‘globals’
[10:27:22.381]   - Field: ‘stdout’
[10:27:22.381]   - Field: ‘earlySignal’
[10:27:22.381]   - Field: ‘lazy’
[10:27:22.381]   - Field: ‘state’
[10:27:22.381] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:22.381] - Launch lazy future ...
[10:27:22.382] Packages needed by the future expression (n = 0): <none>
[10:27:22.382] Packages needed by future strategies (n = 0): <none>
[10:27:22.382] {
[10:27:22.382]     {
[10:27:22.382]         {
[10:27:22.382]             ...future.startTime <- base::Sys.time()
[10:27:22.382]             {
[10:27:22.382]                 {
[10:27:22.382]                   {
[10:27:22.382]                     {
[10:27:22.382]                       base::local({
[10:27:22.382]                         has_future <- base::requireNamespace("future", 
[10:27:22.382]                           quietly = TRUE)
[10:27:22.382]                         if (has_future) {
[10:27:22.382]                           ns <- base::getNamespace("future")
[10:27:22.382]                           version <- ns[[".package"]][["version"]]
[10:27:22.382]                           if (is.null(version)) 
[10:27:22.382]                             version <- utils::packageVersion("future")
[10:27:22.382]                         }
[10:27:22.382]                         else {
[10:27:22.382]                           version <- NULL
[10:27:22.382]                         }
[10:27:22.382]                         if (!has_future || version < "1.8.0") {
[10:27:22.382]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:22.382]                             "", base::R.version$version.string), 
[10:27:22.382]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:22.382]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:22.382]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:22.382]                               "release", "version")], collapse = " "), 
[10:27:22.382]                             hostname = base::Sys.info()[["nodename"]])
[10:27:22.382]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:22.382]                             info)
[10:27:22.382]                           info <- base::paste(info, collapse = "; ")
[10:27:22.382]                           if (!has_future) {
[10:27:22.382]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:22.382]                               info)
[10:27:22.382]                           }
[10:27:22.382]                           else {
[10:27:22.382]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:22.382]                               info, version)
[10:27:22.382]                           }
[10:27:22.382]                           base::stop(msg)
[10:27:22.382]                         }
[10:27:22.382]                       })
[10:27:22.382]                     }
[10:27:22.382]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:22.382]                     base::options(mc.cores = 1L)
[10:27:22.382]                   }
[10:27:22.382]                   options(future.plan = NULL)
[10:27:22.382]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:22.382]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:22.382]                 }
[10:27:22.382]                 ...future.workdir <- getwd()
[10:27:22.382]             }
[10:27:22.382]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:22.382]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:22.382]         }
[10:27:22.382]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:22.382]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:22.382]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:22.382]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:22.382]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:22.382]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:22.382]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:22.382]             base::names(...future.oldOptions))
[10:27:22.382]     }
[10:27:22.382]     if (FALSE) {
[10:27:22.382]     }
[10:27:22.382]     else {
[10:27:22.382]         if (TRUE) {
[10:27:22.382]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:22.382]                 open = "w")
[10:27:22.382]         }
[10:27:22.382]         else {
[10:27:22.382]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:22.382]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:22.382]         }
[10:27:22.382]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:22.382]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:22.382]             base::sink(type = "output", split = FALSE)
[10:27:22.382]             base::close(...future.stdout)
[10:27:22.382]         }, add = TRUE)
[10:27:22.382]     }
[10:27:22.382]     ...future.frame <- base::sys.nframe()
[10:27:22.382]     ...future.conditions <- base::list()
[10:27:22.382]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:22.382]     if (FALSE) {
[10:27:22.382]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:22.382]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:22.382]     }
[10:27:22.382]     ...future.result <- base::tryCatch({
[10:27:22.382]         base::withCallingHandlers({
[10:27:22.382]             ...future.value <- base::withVisible(base::local({
[10:27:22.382]                 ...future.makeSendCondition <- base::local({
[10:27:22.382]                   sendCondition <- NULL
[10:27:22.382]                   function(frame = 1L) {
[10:27:22.382]                     if (is.function(sendCondition)) 
[10:27:22.382]                       return(sendCondition)
[10:27:22.382]                     ns <- getNamespace("parallel")
[10:27:22.382]                     if (exists("sendData", mode = "function", 
[10:27:22.382]                       envir = ns)) {
[10:27:22.382]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:22.382]                         envir = ns)
[10:27:22.382]                       envir <- sys.frame(frame)
[10:27:22.382]                       master <- NULL
[10:27:22.382]                       while (!identical(envir, .GlobalEnv) && 
[10:27:22.382]                         !identical(envir, emptyenv())) {
[10:27:22.382]                         if (exists("master", mode = "list", envir = envir, 
[10:27:22.382]                           inherits = FALSE)) {
[10:27:22.382]                           master <- get("master", mode = "list", 
[10:27:22.382]                             envir = envir, inherits = FALSE)
[10:27:22.382]                           if (inherits(master, c("SOCKnode", 
[10:27:22.382]                             "SOCK0node"))) {
[10:27:22.382]                             sendCondition <<- function(cond) {
[10:27:22.382]                               data <- list(type = "VALUE", value = cond, 
[10:27:22.382]                                 success = TRUE)
[10:27:22.382]                               parallel_sendData(master, data)
[10:27:22.382]                             }
[10:27:22.382]                             return(sendCondition)
[10:27:22.382]                           }
[10:27:22.382]                         }
[10:27:22.382]                         frame <- frame + 1L
[10:27:22.382]                         envir <- sys.frame(frame)
[10:27:22.382]                       }
[10:27:22.382]                     }
[10:27:22.382]                     sendCondition <<- function(cond) NULL
[10:27:22.382]                   }
[10:27:22.382]                 })
[10:27:22.382]                 withCallingHandlers({
[10:27:22.382]                   {
[10:27:22.382]                     2
[10:27:22.382]                   }
[10:27:22.382]                 }, immediateCondition = function(cond) {
[10:27:22.382]                   sendCondition <- ...future.makeSendCondition()
[10:27:22.382]                   sendCondition(cond)
[10:27:22.382]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.382]                   {
[10:27:22.382]                     inherits <- base::inherits
[10:27:22.382]                     invokeRestart <- base::invokeRestart
[10:27:22.382]                     is.null <- base::is.null
[10:27:22.382]                     muffled <- FALSE
[10:27:22.382]                     if (inherits(cond, "message")) {
[10:27:22.382]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:22.382]                       if (muffled) 
[10:27:22.382]                         invokeRestart("muffleMessage")
[10:27:22.382]                     }
[10:27:22.382]                     else if (inherits(cond, "warning")) {
[10:27:22.382]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:22.382]                       if (muffled) 
[10:27:22.382]                         invokeRestart("muffleWarning")
[10:27:22.382]                     }
[10:27:22.382]                     else if (inherits(cond, "condition")) {
[10:27:22.382]                       if (!is.null(pattern)) {
[10:27:22.382]                         computeRestarts <- base::computeRestarts
[10:27:22.382]                         grepl <- base::grepl
[10:27:22.382]                         restarts <- computeRestarts(cond)
[10:27:22.382]                         for (restart in restarts) {
[10:27:22.382]                           name <- restart$name
[10:27:22.382]                           if (is.null(name)) 
[10:27:22.382]                             next
[10:27:22.382]                           if (!grepl(pattern, name)) 
[10:27:22.382]                             next
[10:27:22.382]                           invokeRestart(restart)
[10:27:22.382]                           muffled <- TRUE
[10:27:22.382]                           break
[10:27:22.382]                         }
[10:27:22.382]                       }
[10:27:22.382]                     }
[10:27:22.382]                     invisible(muffled)
[10:27:22.382]                   }
[10:27:22.382]                   muffleCondition(cond)
[10:27:22.382]                 })
[10:27:22.382]             }))
[10:27:22.382]             future::FutureResult(value = ...future.value$value, 
[10:27:22.382]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:22.382]                   ...future.rng), globalenv = if (FALSE) 
[10:27:22.382]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:22.382]                     ...future.globalenv.names))
[10:27:22.382]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:22.382]         }, condition = base::local({
[10:27:22.382]             c <- base::c
[10:27:22.382]             inherits <- base::inherits
[10:27:22.382]             invokeRestart <- base::invokeRestart
[10:27:22.382]             length <- base::length
[10:27:22.382]             list <- base::list
[10:27:22.382]             seq.int <- base::seq.int
[10:27:22.382]             signalCondition <- base::signalCondition
[10:27:22.382]             sys.calls <- base::sys.calls
[10:27:22.382]             `[[` <- base::`[[`
[10:27:22.382]             `+` <- base::`+`
[10:27:22.382]             `<<-` <- base::`<<-`
[10:27:22.382]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:22.382]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:22.382]                   3L)]
[10:27:22.382]             }
[10:27:22.382]             function(cond) {
[10:27:22.382]                 is_error <- inherits(cond, "error")
[10:27:22.382]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:22.382]                   NULL)
[10:27:22.382]                 if (is_error) {
[10:27:22.382]                   sessionInformation <- function() {
[10:27:22.382]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:22.382]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:22.382]                       search = base::search(), system = base::Sys.info())
[10:27:22.382]                   }
[10:27:22.382]                   ...future.conditions[[length(...future.conditions) + 
[10:27:22.382]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:22.382]                     cond$call), session = sessionInformation(), 
[10:27:22.382]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:22.382]                   signalCondition(cond)
[10:27:22.382]                 }
[10:27:22.382]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:22.382]                 "immediateCondition"))) {
[10:27:22.382]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:22.382]                   ...future.conditions[[length(...future.conditions) + 
[10:27:22.382]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:22.382]                   if (TRUE && !signal) {
[10:27:22.382]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.382]                     {
[10:27:22.382]                       inherits <- base::inherits
[10:27:22.382]                       invokeRestart <- base::invokeRestart
[10:27:22.382]                       is.null <- base::is.null
[10:27:22.382]                       muffled <- FALSE
[10:27:22.382]                       if (inherits(cond, "message")) {
[10:27:22.382]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:22.382]                         if (muffled) 
[10:27:22.382]                           invokeRestart("muffleMessage")
[10:27:22.382]                       }
[10:27:22.382]                       else if (inherits(cond, "warning")) {
[10:27:22.382]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:22.382]                         if (muffled) 
[10:27:22.382]                           invokeRestart("muffleWarning")
[10:27:22.382]                       }
[10:27:22.382]                       else if (inherits(cond, "condition")) {
[10:27:22.382]                         if (!is.null(pattern)) {
[10:27:22.382]                           computeRestarts <- base::computeRestarts
[10:27:22.382]                           grepl <- base::grepl
[10:27:22.382]                           restarts <- computeRestarts(cond)
[10:27:22.382]                           for (restart in restarts) {
[10:27:22.382]                             name <- restart$name
[10:27:22.382]                             if (is.null(name)) 
[10:27:22.382]                               next
[10:27:22.382]                             if (!grepl(pattern, name)) 
[10:27:22.382]                               next
[10:27:22.382]                             invokeRestart(restart)
[10:27:22.382]                             muffled <- TRUE
[10:27:22.382]                             break
[10:27:22.382]                           }
[10:27:22.382]                         }
[10:27:22.382]                       }
[10:27:22.382]                       invisible(muffled)
[10:27:22.382]                     }
[10:27:22.382]                     muffleCondition(cond, pattern = "^muffle")
[10:27:22.382]                   }
[10:27:22.382]                 }
[10:27:22.382]                 else {
[10:27:22.382]                   if (TRUE) {
[10:27:22.382]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.382]                     {
[10:27:22.382]                       inherits <- base::inherits
[10:27:22.382]                       invokeRestart <- base::invokeRestart
[10:27:22.382]                       is.null <- base::is.null
[10:27:22.382]                       muffled <- FALSE
[10:27:22.382]                       if (inherits(cond, "message")) {
[10:27:22.382]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:22.382]                         if (muffled) 
[10:27:22.382]                           invokeRestart("muffleMessage")
[10:27:22.382]                       }
[10:27:22.382]                       else if (inherits(cond, "warning")) {
[10:27:22.382]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:22.382]                         if (muffled) 
[10:27:22.382]                           invokeRestart("muffleWarning")
[10:27:22.382]                       }
[10:27:22.382]                       else if (inherits(cond, "condition")) {
[10:27:22.382]                         if (!is.null(pattern)) {
[10:27:22.382]                           computeRestarts <- base::computeRestarts
[10:27:22.382]                           grepl <- base::grepl
[10:27:22.382]                           restarts <- computeRestarts(cond)
[10:27:22.382]                           for (restart in restarts) {
[10:27:22.382]                             name <- restart$name
[10:27:22.382]                             if (is.null(name)) 
[10:27:22.382]                               next
[10:27:22.382]                             if (!grepl(pattern, name)) 
[10:27:22.382]                               next
[10:27:22.382]                             invokeRestart(restart)
[10:27:22.382]                             muffled <- TRUE
[10:27:22.382]                             break
[10:27:22.382]                           }
[10:27:22.382]                         }
[10:27:22.382]                       }
[10:27:22.382]                       invisible(muffled)
[10:27:22.382]                     }
[10:27:22.382]                     muffleCondition(cond, pattern = "^muffle")
[10:27:22.382]                   }
[10:27:22.382]                 }
[10:27:22.382]             }
[10:27:22.382]         }))
[10:27:22.382]     }, error = function(ex) {
[10:27:22.382]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:22.382]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:22.382]                 ...future.rng), started = ...future.startTime, 
[10:27:22.382]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:22.382]             version = "1.8"), class = "FutureResult")
[10:27:22.382]     }, finally = {
[10:27:22.382]         if (!identical(...future.workdir, getwd())) 
[10:27:22.382]             setwd(...future.workdir)
[10:27:22.382]         {
[10:27:22.382]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:22.382]                 ...future.oldOptions$nwarnings <- NULL
[10:27:22.382]             }
[10:27:22.382]             base::options(...future.oldOptions)
[10:27:22.382]             if (.Platform$OS.type == "windows") {
[10:27:22.382]                 old_names <- names(...future.oldEnvVars)
[10:27:22.382]                 envs <- base::Sys.getenv()
[10:27:22.382]                 names <- names(envs)
[10:27:22.382]                 common <- intersect(names, old_names)
[10:27:22.382]                 added <- setdiff(names, old_names)
[10:27:22.382]                 removed <- setdiff(old_names, names)
[10:27:22.382]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:22.382]                   envs[common]]
[10:27:22.382]                 NAMES <- toupper(changed)
[10:27:22.382]                 args <- list()
[10:27:22.382]                 for (kk in seq_along(NAMES)) {
[10:27:22.382]                   name <- changed[[kk]]
[10:27:22.382]                   NAME <- NAMES[[kk]]
[10:27:22.382]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.382]                     next
[10:27:22.382]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:22.382]                 }
[10:27:22.382]                 NAMES <- toupper(added)
[10:27:22.382]                 for (kk in seq_along(NAMES)) {
[10:27:22.382]                   name <- added[[kk]]
[10:27:22.382]                   NAME <- NAMES[[kk]]
[10:27:22.382]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.382]                     next
[10:27:22.382]                   args[[name]] <- ""
[10:27:22.382]                 }
[10:27:22.382]                 NAMES <- toupper(removed)
[10:27:22.382]                 for (kk in seq_along(NAMES)) {
[10:27:22.382]                   name <- removed[[kk]]
[10:27:22.382]                   NAME <- NAMES[[kk]]
[10:27:22.382]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.382]                     next
[10:27:22.382]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:22.382]                 }
[10:27:22.382]                 if (length(args) > 0) 
[10:27:22.382]                   base::do.call(base::Sys.setenv, args = args)
[10:27:22.382]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:22.382]             }
[10:27:22.382]             else {
[10:27:22.382]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:22.382]             }
[10:27:22.382]             {
[10:27:22.382]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:22.382]                   0L) {
[10:27:22.382]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:22.382]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:22.382]                   base::options(opts)
[10:27:22.382]                 }
[10:27:22.382]                 {
[10:27:22.382]                   {
[10:27:22.382]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:22.382]                     NULL
[10:27:22.382]                   }
[10:27:22.382]                   options(future.plan = NULL)
[10:27:22.382]                   if (is.na(NA_character_)) 
[10:27:22.382]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:22.382]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:22.382]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:22.382]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:22.382]                     envir = parent.frame()) 
[10:27:22.382]                   {
[10:27:22.382]                     if (is.function(workers)) 
[10:27:22.382]                       workers <- workers()
[10:27:22.382]                     workers <- structure(as.integer(workers), 
[10:27:22.382]                       class = class(workers))
[10:27:22.382]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:22.382]                       workers >= 1)
[10:27:22.382]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:22.382]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:22.382]                     }
[10:27:22.382]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:22.382]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:22.382]                       envir = envir)
[10:27:22.382]                     if (!future$lazy) 
[10:27:22.382]                       future <- run(future)
[10:27:22.382]                     invisible(future)
[10:27:22.382]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:22.382]                 }
[10:27:22.382]             }
[10:27:22.382]         }
[10:27:22.382]     })
[10:27:22.382]     if (TRUE) {
[10:27:22.382]         base::sink(type = "output", split = FALSE)
[10:27:22.382]         if (TRUE) {
[10:27:22.382]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:22.382]         }
[10:27:22.382]         else {
[10:27:22.382]             ...future.result["stdout"] <- base::list(NULL)
[10:27:22.382]         }
[10:27:22.382]         base::close(...future.stdout)
[10:27:22.382]         ...future.stdout <- NULL
[10:27:22.382]     }
[10:27:22.382]     ...future.result$conditions <- ...future.conditions
[10:27:22.382]     ...future.result$finished <- base::Sys.time()
[10:27:22.382]     ...future.result
[10:27:22.382] }
[10:27:22.386] MultisessionFuture started
[10:27:22.386] - Launch lazy future ... done
[10:27:22.386] run() for ‘MultisessionFuture’ ... done
[10:27:22.387] resolve() on environment ...
[10:27:22.387]  recursive: 0
[10:27:22.387]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[10:27:22.408]  length: 2 (resolved future 3)
[10:27:22.419] receiveMessageFromWorker() for ClusterFuture ...
[10:27:22.419] - Validating connection of MultisessionFuture
[10:27:22.420] - received message: FutureResult
[10:27:22.420] - Received FutureResult
[10:27:22.420] - Erased future from FutureRegistry
[10:27:22.420] result() for ClusterFuture ...
[10:27:22.420] - result already collected: FutureResult
[10:27:22.420] result() for ClusterFuture ... done
[10:27:22.420] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:22.420] Future #1
[10:27:22.420]  length: 1 (resolved future 1)
[10:27:22.442] receiveMessageFromWorker() for ClusterFuture ...
[10:27:22.442] - Validating connection of MultisessionFuture
[10:27:22.442] - received message: FutureResult
[10:27:22.442] - Received FutureResult
[10:27:22.442] - Erased future from FutureRegistry
[10:27:22.442] result() for ClusterFuture ...
[10:27:22.442] - result already collected: FutureResult
[10:27:22.443] result() for ClusterFuture ... done
[10:27:22.443] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:22.443] Future #2
[10:27:22.443]  length: 0 (resolved future 2)
[10:27:22.443] resolve() on environment ... DONE
[10:27:22.443] getGlobalsAndPackages() ...
[10:27:22.443] Searching for globals...
[10:27:22.444] - globals found: [1] ‘{’
[10:27:22.444] Searching for globals ... DONE
[10:27:22.444] Resolving globals: FALSE
[10:27:22.445] 
[10:27:22.445] 
[10:27:22.445] getGlobalsAndPackages() ... DONE
[10:27:22.445] run() for ‘Future’ ...
[10:27:22.445] - state: ‘created’
[10:27:22.445] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:22.461] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:22.461] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:22.461]   - Field: ‘node’
[10:27:22.461]   - Field: ‘label’
[10:27:22.461]   - Field: ‘local’
[10:27:22.462]   - Field: ‘owner’
[10:27:22.462]   - Field: ‘envir’
[10:27:22.462]   - Field: ‘workers’
[10:27:22.462]   - Field: ‘packages’
[10:27:22.462]   - Field: ‘gc’
[10:27:22.462]   - Field: ‘conditions’
[10:27:22.462]   - Field: ‘persistent’
[10:27:22.462]   - Field: ‘expr’
[10:27:22.462]   - Field: ‘uuid’
[10:27:22.462]   - Field: ‘seed’
[10:27:22.462]   - Field: ‘version’
[10:27:22.463]   - Field: ‘result’
[10:27:22.463]   - Field: ‘asynchronous’
[10:27:22.463]   - Field: ‘calls’
[10:27:22.463]   - Field: ‘globals’
[10:27:22.463]   - Field: ‘stdout’
[10:27:22.463]   - Field: ‘earlySignal’
[10:27:22.463]   - Field: ‘lazy’
[10:27:22.463]   - Field: ‘state’
[10:27:22.463] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:22.463] - Launch lazy future ...
[10:27:22.464] Packages needed by the future expression (n = 0): <none>
[10:27:22.464] Packages needed by future strategies (n = 0): <none>
[10:27:22.464] {
[10:27:22.464]     {
[10:27:22.464]         {
[10:27:22.464]             ...future.startTime <- base::Sys.time()
[10:27:22.464]             {
[10:27:22.464]                 {
[10:27:22.464]                   {
[10:27:22.464]                     {
[10:27:22.464]                       base::local({
[10:27:22.464]                         has_future <- base::requireNamespace("future", 
[10:27:22.464]                           quietly = TRUE)
[10:27:22.464]                         if (has_future) {
[10:27:22.464]                           ns <- base::getNamespace("future")
[10:27:22.464]                           version <- ns[[".package"]][["version"]]
[10:27:22.464]                           if (is.null(version)) 
[10:27:22.464]                             version <- utils::packageVersion("future")
[10:27:22.464]                         }
[10:27:22.464]                         else {
[10:27:22.464]                           version <- NULL
[10:27:22.464]                         }
[10:27:22.464]                         if (!has_future || version < "1.8.0") {
[10:27:22.464]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:22.464]                             "", base::R.version$version.string), 
[10:27:22.464]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:22.464]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:22.464]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:22.464]                               "release", "version")], collapse = " "), 
[10:27:22.464]                             hostname = base::Sys.info()[["nodename"]])
[10:27:22.464]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:22.464]                             info)
[10:27:22.464]                           info <- base::paste(info, collapse = "; ")
[10:27:22.464]                           if (!has_future) {
[10:27:22.464]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:22.464]                               info)
[10:27:22.464]                           }
[10:27:22.464]                           else {
[10:27:22.464]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:22.464]                               info, version)
[10:27:22.464]                           }
[10:27:22.464]                           base::stop(msg)
[10:27:22.464]                         }
[10:27:22.464]                       })
[10:27:22.464]                     }
[10:27:22.464]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:22.464]                     base::options(mc.cores = 1L)
[10:27:22.464]                   }
[10:27:22.464]                   options(future.plan = NULL)
[10:27:22.464]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:22.464]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:22.464]                 }
[10:27:22.464]                 ...future.workdir <- getwd()
[10:27:22.464]             }
[10:27:22.464]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:22.464]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:22.464]         }
[10:27:22.464]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:22.464]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:22.464]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:22.464]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:22.464]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:22.464]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:22.464]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:22.464]             base::names(...future.oldOptions))
[10:27:22.464]     }
[10:27:22.464]     if (FALSE) {
[10:27:22.464]     }
[10:27:22.464]     else {
[10:27:22.464]         if (TRUE) {
[10:27:22.464]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:22.464]                 open = "w")
[10:27:22.464]         }
[10:27:22.464]         else {
[10:27:22.464]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:22.464]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:22.464]         }
[10:27:22.464]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:22.464]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:22.464]             base::sink(type = "output", split = FALSE)
[10:27:22.464]             base::close(...future.stdout)
[10:27:22.464]         }, add = TRUE)
[10:27:22.464]     }
[10:27:22.464]     ...future.frame <- base::sys.nframe()
[10:27:22.464]     ...future.conditions <- base::list()
[10:27:22.464]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:22.464]     if (FALSE) {
[10:27:22.464]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:22.464]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:22.464]     }
[10:27:22.464]     ...future.result <- base::tryCatch({
[10:27:22.464]         base::withCallingHandlers({
[10:27:22.464]             ...future.value <- base::withVisible(base::local({
[10:27:22.464]                 ...future.makeSendCondition <- base::local({
[10:27:22.464]                   sendCondition <- NULL
[10:27:22.464]                   function(frame = 1L) {
[10:27:22.464]                     if (is.function(sendCondition)) 
[10:27:22.464]                       return(sendCondition)
[10:27:22.464]                     ns <- getNamespace("parallel")
[10:27:22.464]                     if (exists("sendData", mode = "function", 
[10:27:22.464]                       envir = ns)) {
[10:27:22.464]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:22.464]                         envir = ns)
[10:27:22.464]                       envir <- sys.frame(frame)
[10:27:22.464]                       master <- NULL
[10:27:22.464]                       while (!identical(envir, .GlobalEnv) && 
[10:27:22.464]                         !identical(envir, emptyenv())) {
[10:27:22.464]                         if (exists("master", mode = "list", envir = envir, 
[10:27:22.464]                           inherits = FALSE)) {
[10:27:22.464]                           master <- get("master", mode = "list", 
[10:27:22.464]                             envir = envir, inherits = FALSE)
[10:27:22.464]                           if (inherits(master, c("SOCKnode", 
[10:27:22.464]                             "SOCK0node"))) {
[10:27:22.464]                             sendCondition <<- function(cond) {
[10:27:22.464]                               data <- list(type = "VALUE", value = cond, 
[10:27:22.464]                                 success = TRUE)
[10:27:22.464]                               parallel_sendData(master, data)
[10:27:22.464]                             }
[10:27:22.464]                             return(sendCondition)
[10:27:22.464]                           }
[10:27:22.464]                         }
[10:27:22.464]                         frame <- frame + 1L
[10:27:22.464]                         envir <- sys.frame(frame)
[10:27:22.464]                       }
[10:27:22.464]                     }
[10:27:22.464]                     sendCondition <<- function(cond) NULL
[10:27:22.464]                   }
[10:27:22.464]                 })
[10:27:22.464]                 withCallingHandlers({
[10:27:22.464]                   {
[10:27:22.464]                     1
[10:27:22.464]                   }
[10:27:22.464]                 }, immediateCondition = function(cond) {
[10:27:22.464]                   sendCondition <- ...future.makeSendCondition()
[10:27:22.464]                   sendCondition(cond)
[10:27:22.464]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.464]                   {
[10:27:22.464]                     inherits <- base::inherits
[10:27:22.464]                     invokeRestart <- base::invokeRestart
[10:27:22.464]                     is.null <- base::is.null
[10:27:22.464]                     muffled <- FALSE
[10:27:22.464]                     if (inherits(cond, "message")) {
[10:27:22.464]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:22.464]                       if (muffled) 
[10:27:22.464]                         invokeRestart("muffleMessage")
[10:27:22.464]                     }
[10:27:22.464]                     else if (inherits(cond, "warning")) {
[10:27:22.464]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:22.464]                       if (muffled) 
[10:27:22.464]                         invokeRestart("muffleWarning")
[10:27:22.464]                     }
[10:27:22.464]                     else if (inherits(cond, "condition")) {
[10:27:22.464]                       if (!is.null(pattern)) {
[10:27:22.464]                         computeRestarts <- base::computeRestarts
[10:27:22.464]                         grepl <- base::grepl
[10:27:22.464]                         restarts <- computeRestarts(cond)
[10:27:22.464]                         for (restart in restarts) {
[10:27:22.464]                           name <- restart$name
[10:27:22.464]                           if (is.null(name)) 
[10:27:22.464]                             next
[10:27:22.464]                           if (!grepl(pattern, name)) 
[10:27:22.464]                             next
[10:27:22.464]                           invokeRestart(restart)
[10:27:22.464]                           muffled <- TRUE
[10:27:22.464]                           break
[10:27:22.464]                         }
[10:27:22.464]                       }
[10:27:22.464]                     }
[10:27:22.464]                     invisible(muffled)
[10:27:22.464]                   }
[10:27:22.464]                   muffleCondition(cond)
[10:27:22.464]                 })
[10:27:22.464]             }))
[10:27:22.464]             future::FutureResult(value = ...future.value$value, 
[10:27:22.464]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:22.464]                   ...future.rng), globalenv = if (FALSE) 
[10:27:22.464]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:22.464]                     ...future.globalenv.names))
[10:27:22.464]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:22.464]         }, condition = base::local({
[10:27:22.464]             c <- base::c
[10:27:22.464]             inherits <- base::inherits
[10:27:22.464]             invokeRestart <- base::invokeRestart
[10:27:22.464]             length <- base::length
[10:27:22.464]             list <- base::list
[10:27:22.464]             seq.int <- base::seq.int
[10:27:22.464]             signalCondition <- base::signalCondition
[10:27:22.464]             sys.calls <- base::sys.calls
[10:27:22.464]             `[[` <- base::`[[`
[10:27:22.464]             `+` <- base::`+`
[10:27:22.464]             `<<-` <- base::`<<-`
[10:27:22.464]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:22.464]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:22.464]                   3L)]
[10:27:22.464]             }
[10:27:22.464]             function(cond) {
[10:27:22.464]                 is_error <- inherits(cond, "error")
[10:27:22.464]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:22.464]                   NULL)
[10:27:22.464]                 if (is_error) {
[10:27:22.464]                   sessionInformation <- function() {
[10:27:22.464]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:22.464]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:22.464]                       search = base::search(), system = base::Sys.info())
[10:27:22.464]                   }
[10:27:22.464]                   ...future.conditions[[length(...future.conditions) + 
[10:27:22.464]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:22.464]                     cond$call), session = sessionInformation(), 
[10:27:22.464]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:22.464]                   signalCondition(cond)
[10:27:22.464]                 }
[10:27:22.464]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:22.464]                 "immediateCondition"))) {
[10:27:22.464]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:22.464]                   ...future.conditions[[length(...future.conditions) + 
[10:27:22.464]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:22.464]                   if (TRUE && !signal) {
[10:27:22.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.464]                     {
[10:27:22.464]                       inherits <- base::inherits
[10:27:22.464]                       invokeRestart <- base::invokeRestart
[10:27:22.464]                       is.null <- base::is.null
[10:27:22.464]                       muffled <- FALSE
[10:27:22.464]                       if (inherits(cond, "message")) {
[10:27:22.464]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:22.464]                         if (muffled) 
[10:27:22.464]                           invokeRestart("muffleMessage")
[10:27:22.464]                       }
[10:27:22.464]                       else if (inherits(cond, "warning")) {
[10:27:22.464]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:22.464]                         if (muffled) 
[10:27:22.464]                           invokeRestart("muffleWarning")
[10:27:22.464]                       }
[10:27:22.464]                       else if (inherits(cond, "condition")) {
[10:27:22.464]                         if (!is.null(pattern)) {
[10:27:22.464]                           computeRestarts <- base::computeRestarts
[10:27:22.464]                           grepl <- base::grepl
[10:27:22.464]                           restarts <- computeRestarts(cond)
[10:27:22.464]                           for (restart in restarts) {
[10:27:22.464]                             name <- restart$name
[10:27:22.464]                             if (is.null(name)) 
[10:27:22.464]                               next
[10:27:22.464]                             if (!grepl(pattern, name)) 
[10:27:22.464]                               next
[10:27:22.464]                             invokeRestart(restart)
[10:27:22.464]                             muffled <- TRUE
[10:27:22.464]                             break
[10:27:22.464]                           }
[10:27:22.464]                         }
[10:27:22.464]                       }
[10:27:22.464]                       invisible(muffled)
[10:27:22.464]                     }
[10:27:22.464]                     muffleCondition(cond, pattern = "^muffle")
[10:27:22.464]                   }
[10:27:22.464]                 }
[10:27:22.464]                 else {
[10:27:22.464]                   if (TRUE) {
[10:27:22.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.464]                     {
[10:27:22.464]                       inherits <- base::inherits
[10:27:22.464]                       invokeRestart <- base::invokeRestart
[10:27:22.464]                       is.null <- base::is.null
[10:27:22.464]                       muffled <- FALSE
[10:27:22.464]                       if (inherits(cond, "message")) {
[10:27:22.464]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:22.464]                         if (muffled) 
[10:27:22.464]                           invokeRestart("muffleMessage")
[10:27:22.464]                       }
[10:27:22.464]                       else if (inherits(cond, "warning")) {
[10:27:22.464]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:22.464]                         if (muffled) 
[10:27:22.464]                           invokeRestart("muffleWarning")
[10:27:22.464]                       }
[10:27:22.464]                       else if (inherits(cond, "condition")) {
[10:27:22.464]                         if (!is.null(pattern)) {
[10:27:22.464]                           computeRestarts <- base::computeRestarts
[10:27:22.464]                           grepl <- base::grepl
[10:27:22.464]                           restarts <- computeRestarts(cond)
[10:27:22.464]                           for (restart in restarts) {
[10:27:22.464]                             name <- restart$name
[10:27:22.464]                             if (is.null(name)) 
[10:27:22.464]                               next
[10:27:22.464]                             if (!grepl(pattern, name)) 
[10:27:22.464]                               next
[10:27:22.464]                             invokeRestart(restart)
[10:27:22.464]                             muffled <- TRUE
[10:27:22.464]                             break
[10:27:22.464]                           }
[10:27:22.464]                         }
[10:27:22.464]                       }
[10:27:22.464]                       invisible(muffled)
[10:27:22.464]                     }
[10:27:22.464]                     muffleCondition(cond, pattern = "^muffle")
[10:27:22.464]                   }
[10:27:22.464]                 }
[10:27:22.464]             }
[10:27:22.464]         }))
[10:27:22.464]     }, error = function(ex) {
[10:27:22.464]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:22.464]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:22.464]                 ...future.rng), started = ...future.startTime, 
[10:27:22.464]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:22.464]             version = "1.8"), class = "FutureResult")
[10:27:22.464]     }, finally = {
[10:27:22.464]         if (!identical(...future.workdir, getwd())) 
[10:27:22.464]             setwd(...future.workdir)
[10:27:22.464]         {
[10:27:22.464]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:22.464]                 ...future.oldOptions$nwarnings <- NULL
[10:27:22.464]             }
[10:27:22.464]             base::options(...future.oldOptions)
[10:27:22.464]             if (.Platform$OS.type == "windows") {
[10:27:22.464]                 old_names <- names(...future.oldEnvVars)
[10:27:22.464]                 envs <- base::Sys.getenv()
[10:27:22.464]                 names <- names(envs)
[10:27:22.464]                 common <- intersect(names, old_names)
[10:27:22.464]                 added <- setdiff(names, old_names)
[10:27:22.464]                 removed <- setdiff(old_names, names)
[10:27:22.464]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:22.464]                   envs[common]]
[10:27:22.464]                 NAMES <- toupper(changed)
[10:27:22.464]                 args <- list()
[10:27:22.464]                 for (kk in seq_along(NAMES)) {
[10:27:22.464]                   name <- changed[[kk]]
[10:27:22.464]                   NAME <- NAMES[[kk]]
[10:27:22.464]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.464]                     next
[10:27:22.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:22.464]                 }
[10:27:22.464]                 NAMES <- toupper(added)
[10:27:22.464]                 for (kk in seq_along(NAMES)) {
[10:27:22.464]                   name <- added[[kk]]
[10:27:22.464]                   NAME <- NAMES[[kk]]
[10:27:22.464]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.464]                     next
[10:27:22.464]                   args[[name]] <- ""
[10:27:22.464]                 }
[10:27:22.464]                 NAMES <- toupper(removed)
[10:27:22.464]                 for (kk in seq_along(NAMES)) {
[10:27:22.464]                   name <- removed[[kk]]
[10:27:22.464]                   NAME <- NAMES[[kk]]
[10:27:22.464]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.464]                     next
[10:27:22.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:22.464]                 }
[10:27:22.464]                 if (length(args) > 0) 
[10:27:22.464]                   base::do.call(base::Sys.setenv, args = args)
[10:27:22.464]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:22.464]             }
[10:27:22.464]             else {
[10:27:22.464]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:22.464]             }
[10:27:22.464]             {
[10:27:22.464]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:22.464]                   0L) {
[10:27:22.464]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:22.464]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:22.464]                   base::options(opts)
[10:27:22.464]                 }
[10:27:22.464]                 {
[10:27:22.464]                   {
[10:27:22.464]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:22.464]                     NULL
[10:27:22.464]                   }
[10:27:22.464]                   options(future.plan = NULL)
[10:27:22.464]                   if (is.na(NA_character_)) 
[10:27:22.464]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:22.464]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:22.464]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:22.464]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:22.464]                     envir = parent.frame()) 
[10:27:22.464]                   {
[10:27:22.464]                     if (is.function(workers)) 
[10:27:22.464]                       workers <- workers()
[10:27:22.464]                     workers <- structure(as.integer(workers), 
[10:27:22.464]                       class = class(workers))
[10:27:22.464]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:22.464]                       workers >= 1)
[10:27:22.464]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:22.464]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:22.464]                     }
[10:27:22.464]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:22.464]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:22.464]                       envir = envir)
[10:27:22.464]                     if (!future$lazy) 
[10:27:22.464]                       future <- run(future)
[10:27:22.464]                     invisible(future)
[10:27:22.464]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:22.464]                 }
[10:27:22.464]             }
[10:27:22.464]         }
[10:27:22.464]     })
[10:27:22.464]     if (TRUE) {
[10:27:22.464]         base::sink(type = "output", split = FALSE)
[10:27:22.464]         if (TRUE) {
[10:27:22.464]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:22.464]         }
[10:27:22.464]         else {
[10:27:22.464]             ...future.result["stdout"] <- base::list(NULL)
[10:27:22.464]         }
[10:27:22.464]         base::close(...future.stdout)
[10:27:22.464]         ...future.stdout <- NULL
[10:27:22.464]     }
[10:27:22.464]     ...future.result$conditions <- ...future.conditions
[10:27:22.464]     ...future.result$finished <- base::Sys.time()
[10:27:22.464]     ...future.result
[10:27:22.464] }
[10:27:22.467] MultisessionFuture started
[10:27:22.468] - Launch lazy future ... done
[10:27:22.468] run() for ‘MultisessionFuture’ ... done
[10:27:22.468] getGlobalsAndPackages() ...
[10:27:22.468] Searching for globals...
[10:27:22.469] - globals found: [1] ‘{’
[10:27:22.469] Searching for globals ... DONE
[10:27:22.469] Resolving globals: FALSE
[10:27:22.469] 
[10:27:22.469] 
[10:27:22.469] getGlobalsAndPackages() ... DONE
[10:27:22.470] run() for ‘Future’ ...
[10:27:22.470] - state: ‘created’
[10:27:22.470] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:22.484] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:22.484] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:22.484]   - Field: ‘node’
[10:27:22.484]   - Field: ‘label’
[10:27:22.484]   - Field: ‘local’
[10:27:22.484]   - Field: ‘owner’
[10:27:22.484]   - Field: ‘envir’
[10:27:22.485]   - Field: ‘workers’
[10:27:22.485]   - Field: ‘packages’
[10:27:22.485]   - Field: ‘gc’
[10:27:22.485]   - Field: ‘conditions’
[10:27:22.485]   - Field: ‘persistent’
[10:27:22.485]   - Field: ‘expr’
[10:27:22.485]   - Field: ‘uuid’
[10:27:22.485]   - Field: ‘seed’
[10:27:22.485]   - Field: ‘version’
[10:27:22.485]   - Field: ‘result’
[10:27:22.486]   - Field: ‘asynchronous’
[10:27:22.486]   - Field: ‘calls’
[10:27:22.486]   - Field: ‘globals’
[10:27:22.486]   - Field: ‘stdout’
[10:27:22.486]   - Field: ‘earlySignal’
[10:27:22.486]   - Field: ‘lazy’
[10:27:22.486]   - Field: ‘state’
[10:27:22.486] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:22.486] - Launch lazy future ...
[10:27:22.487] Packages needed by the future expression (n = 0): <none>
[10:27:22.487] Packages needed by future strategies (n = 0): <none>
[10:27:22.487] {
[10:27:22.487]     {
[10:27:22.487]         {
[10:27:22.487]             ...future.startTime <- base::Sys.time()
[10:27:22.487]             {
[10:27:22.487]                 {
[10:27:22.487]                   {
[10:27:22.487]                     {
[10:27:22.487]                       base::local({
[10:27:22.487]                         has_future <- base::requireNamespace("future", 
[10:27:22.487]                           quietly = TRUE)
[10:27:22.487]                         if (has_future) {
[10:27:22.487]                           ns <- base::getNamespace("future")
[10:27:22.487]                           version <- ns[[".package"]][["version"]]
[10:27:22.487]                           if (is.null(version)) 
[10:27:22.487]                             version <- utils::packageVersion("future")
[10:27:22.487]                         }
[10:27:22.487]                         else {
[10:27:22.487]                           version <- NULL
[10:27:22.487]                         }
[10:27:22.487]                         if (!has_future || version < "1.8.0") {
[10:27:22.487]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:22.487]                             "", base::R.version$version.string), 
[10:27:22.487]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:22.487]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:22.487]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:22.487]                               "release", "version")], collapse = " "), 
[10:27:22.487]                             hostname = base::Sys.info()[["nodename"]])
[10:27:22.487]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:22.487]                             info)
[10:27:22.487]                           info <- base::paste(info, collapse = "; ")
[10:27:22.487]                           if (!has_future) {
[10:27:22.487]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:22.487]                               info)
[10:27:22.487]                           }
[10:27:22.487]                           else {
[10:27:22.487]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:22.487]                               info, version)
[10:27:22.487]                           }
[10:27:22.487]                           base::stop(msg)
[10:27:22.487]                         }
[10:27:22.487]                       })
[10:27:22.487]                     }
[10:27:22.487]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:22.487]                     base::options(mc.cores = 1L)
[10:27:22.487]                   }
[10:27:22.487]                   options(future.plan = NULL)
[10:27:22.487]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:22.487]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:22.487]                 }
[10:27:22.487]                 ...future.workdir <- getwd()
[10:27:22.487]             }
[10:27:22.487]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:22.487]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:22.487]         }
[10:27:22.487]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:22.487]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:22.487]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:22.487]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:22.487]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:22.487]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:22.487]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:22.487]             base::names(...future.oldOptions))
[10:27:22.487]     }
[10:27:22.487]     if (FALSE) {
[10:27:22.487]     }
[10:27:22.487]     else {
[10:27:22.487]         if (TRUE) {
[10:27:22.487]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:22.487]                 open = "w")
[10:27:22.487]         }
[10:27:22.487]         else {
[10:27:22.487]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:22.487]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:22.487]         }
[10:27:22.487]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:22.487]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:22.487]             base::sink(type = "output", split = FALSE)
[10:27:22.487]             base::close(...future.stdout)
[10:27:22.487]         }, add = TRUE)
[10:27:22.487]     }
[10:27:22.487]     ...future.frame <- base::sys.nframe()
[10:27:22.487]     ...future.conditions <- base::list()
[10:27:22.487]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:22.487]     if (FALSE) {
[10:27:22.487]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:22.487]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:22.487]     }
[10:27:22.487]     ...future.result <- base::tryCatch({
[10:27:22.487]         base::withCallingHandlers({
[10:27:22.487]             ...future.value <- base::withVisible(base::local({
[10:27:22.487]                 ...future.makeSendCondition <- base::local({
[10:27:22.487]                   sendCondition <- NULL
[10:27:22.487]                   function(frame = 1L) {
[10:27:22.487]                     if (is.function(sendCondition)) 
[10:27:22.487]                       return(sendCondition)
[10:27:22.487]                     ns <- getNamespace("parallel")
[10:27:22.487]                     if (exists("sendData", mode = "function", 
[10:27:22.487]                       envir = ns)) {
[10:27:22.487]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:22.487]                         envir = ns)
[10:27:22.487]                       envir <- sys.frame(frame)
[10:27:22.487]                       master <- NULL
[10:27:22.487]                       while (!identical(envir, .GlobalEnv) && 
[10:27:22.487]                         !identical(envir, emptyenv())) {
[10:27:22.487]                         if (exists("master", mode = "list", envir = envir, 
[10:27:22.487]                           inherits = FALSE)) {
[10:27:22.487]                           master <- get("master", mode = "list", 
[10:27:22.487]                             envir = envir, inherits = FALSE)
[10:27:22.487]                           if (inherits(master, c("SOCKnode", 
[10:27:22.487]                             "SOCK0node"))) {
[10:27:22.487]                             sendCondition <<- function(cond) {
[10:27:22.487]                               data <- list(type = "VALUE", value = cond, 
[10:27:22.487]                                 success = TRUE)
[10:27:22.487]                               parallel_sendData(master, data)
[10:27:22.487]                             }
[10:27:22.487]                             return(sendCondition)
[10:27:22.487]                           }
[10:27:22.487]                         }
[10:27:22.487]                         frame <- frame + 1L
[10:27:22.487]                         envir <- sys.frame(frame)
[10:27:22.487]                       }
[10:27:22.487]                     }
[10:27:22.487]                     sendCondition <<- function(cond) NULL
[10:27:22.487]                   }
[10:27:22.487]                 })
[10:27:22.487]                 withCallingHandlers({
[10:27:22.487]                   {
[10:27:22.487]                     2
[10:27:22.487]                   }
[10:27:22.487]                 }, immediateCondition = function(cond) {
[10:27:22.487]                   sendCondition <- ...future.makeSendCondition()
[10:27:22.487]                   sendCondition(cond)
[10:27:22.487]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.487]                   {
[10:27:22.487]                     inherits <- base::inherits
[10:27:22.487]                     invokeRestart <- base::invokeRestart
[10:27:22.487]                     is.null <- base::is.null
[10:27:22.487]                     muffled <- FALSE
[10:27:22.487]                     if (inherits(cond, "message")) {
[10:27:22.487]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:22.487]                       if (muffled) 
[10:27:22.487]                         invokeRestart("muffleMessage")
[10:27:22.487]                     }
[10:27:22.487]                     else if (inherits(cond, "warning")) {
[10:27:22.487]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:22.487]                       if (muffled) 
[10:27:22.487]                         invokeRestart("muffleWarning")
[10:27:22.487]                     }
[10:27:22.487]                     else if (inherits(cond, "condition")) {
[10:27:22.487]                       if (!is.null(pattern)) {
[10:27:22.487]                         computeRestarts <- base::computeRestarts
[10:27:22.487]                         grepl <- base::grepl
[10:27:22.487]                         restarts <- computeRestarts(cond)
[10:27:22.487]                         for (restart in restarts) {
[10:27:22.487]                           name <- restart$name
[10:27:22.487]                           if (is.null(name)) 
[10:27:22.487]                             next
[10:27:22.487]                           if (!grepl(pattern, name)) 
[10:27:22.487]                             next
[10:27:22.487]                           invokeRestart(restart)
[10:27:22.487]                           muffled <- TRUE
[10:27:22.487]                           break
[10:27:22.487]                         }
[10:27:22.487]                       }
[10:27:22.487]                     }
[10:27:22.487]                     invisible(muffled)
[10:27:22.487]                   }
[10:27:22.487]                   muffleCondition(cond)
[10:27:22.487]                 })
[10:27:22.487]             }))
[10:27:22.487]             future::FutureResult(value = ...future.value$value, 
[10:27:22.487]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:22.487]                   ...future.rng), globalenv = if (FALSE) 
[10:27:22.487]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:22.487]                     ...future.globalenv.names))
[10:27:22.487]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:22.487]         }, condition = base::local({
[10:27:22.487]             c <- base::c
[10:27:22.487]             inherits <- base::inherits
[10:27:22.487]             invokeRestart <- base::invokeRestart
[10:27:22.487]             length <- base::length
[10:27:22.487]             list <- base::list
[10:27:22.487]             seq.int <- base::seq.int
[10:27:22.487]             signalCondition <- base::signalCondition
[10:27:22.487]             sys.calls <- base::sys.calls
[10:27:22.487]             `[[` <- base::`[[`
[10:27:22.487]             `+` <- base::`+`
[10:27:22.487]             `<<-` <- base::`<<-`
[10:27:22.487]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:22.487]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:22.487]                   3L)]
[10:27:22.487]             }
[10:27:22.487]             function(cond) {
[10:27:22.487]                 is_error <- inherits(cond, "error")
[10:27:22.487]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:22.487]                   NULL)
[10:27:22.487]                 if (is_error) {
[10:27:22.487]                   sessionInformation <- function() {
[10:27:22.487]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:22.487]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:22.487]                       search = base::search(), system = base::Sys.info())
[10:27:22.487]                   }
[10:27:22.487]                   ...future.conditions[[length(...future.conditions) + 
[10:27:22.487]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:22.487]                     cond$call), session = sessionInformation(), 
[10:27:22.487]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:22.487]                   signalCondition(cond)
[10:27:22.487]                 }
[10:27:22.487]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:22.487]                 "immediateCondition"))) {
[10:27:22.487]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:22.487]                   ...future.conditions[[length(...future.conditions) + 
[10:27:22.487]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:22.487]                   if (TRUE && !signal) {
[10:27:22.487]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.487]                     {
[10:27:22.487]                       inherits <- base::inherits
[10:27:22.487]                       invokeRestart <- base::invokeRestart
[10:27:22.487]                       is.null <- base::is.null
[10:27:22.487]                       muffled <- FALSE
[10:27:22.487]                       if (inherits(cond, "message")) {
[10:27:22.487]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:22.487]                         if (muffled) 
[10:27:22.487]                           invokeRestart("muffleMessage")
[10:27:22.487]                       }
[10:27:22.487]                       else if (inherits(cond, "warning")) {
[10:27:22.487]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:22.487]                         if (muffled) 
[10:27:22.487]                           invokeRestart("muffleWarning")
[10:27:22.487]                       }
[10:27:22.487]                       else if (inherits(cond, "condition")) {
[10:27:22.487]                         if (!is.null(pattern)) {
[10:27:22.487]                           computeRestarts <- base::computeRestarts
[10:27:22.487]                           grepl <- base::grepl
[10:27:22.487]                           restarts <- computeRestarts(cond)
[10:27:22.487]                           for (restart in restarts) {
[10:27:22.487]                             name <- restart$name
[10:27:22.487]                             if (is.null(name)) 
[10:27:22.487]                               next
[10:27:22.487]                             if (!grepl(pattern, name)) 
[10:27:22.487]                               next
[10:27:22.487]                             invokeRestart(restart)
[10:27:22.487]                             muffled <- TRUE
[10:27:22.487]                             break
[10:27:22.487]                           }
[10:27:22.487]                         }
[10:27:22.487]                       }
[10:27:22.487]                       invisible(muffled)
[10:27:22.487]                     }
[10:27:22.487]                     muffleCondition(cond, pattern = "^muffle")
[10:27:22.487]                   }
[10:27:22.487]                 }
[10:27:22.487]                 else {
[10:27:22.487]                   if (TRUE) {
[10:27:22.487]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.487]                     {
[10:27:22.487]                       inherits <- base::inherits
[10:27:22.487]                       invokeRestart <- base::invokeRestart
[10:27:22.487]                       is.null <- base::is.null
[10:27:22.487]                       muffled <- FALSE
[10:27:22.487]                       if (inherits(cond, "message")) {
[10:27:22.487]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:22.487]                         if (muffled) 
[10:27:22.487]                           invokeRestart("muffleMessage")
[10:27:22.487]                       }
[10:27:22.487]                       else if (inherits(cond, "warning")) {
[10:27:22.487]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:22.487]                         if (muffled) 
[10:27:22.487]                           invokeRestart("muffleWarning")
[10:27:22.487]                       }
[10:27:22.487]                       else if (inherits(cond, "condition")) {
[10:27:22.487]                         if (!is.null(pattern)) {
[10:27:22.487]                           computeRestarts <- base::computeRestarts
[10:27:22.487]                           grepl <- base::grepl
[10:27:22.487]                           restarts <- computeRestarts(cond)
[10:27:22.487]                           for (restart in restarts) {
[10:27:22.487]                             name <- restart$name
[10:27:22.487]                             if (is.null(name)) 
[10:27:22.487]                               next
[10:27:22.487]                             if (!grepl(pattern, name)) 
[10:27:22.487]                               next
[10:27:22.487]                             invokeRestart(restart)
[10:27:22.487]                             muffled <- TRUE
[10:27:22.487]                             break
[10:27:22.487]                           }
[10:27:22.487]                         }
[10:27:22.487]                       }
[10:27:22.487]                       invisible(muffled)
[10:27:22.487]                     }
[10:27:22.487]                     muffleCondition(cond, pattern = "^muffle")
[10:27:22.487]                   }
[10:27:22.487]                 }
[10:27:22.487]             }
[10:27:22.487]         }))
[10:27:22.487]     }, error = function(ex) {
[10:27:22.487]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:22.487]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:22.487]                 ...future.rng), started = ...future.startTime, 
[10:27:22.487]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:22.487]             version = "1.8"), class = "FutureResult")
[10:27:22.487]     }, finally = {
[10:27:22.487]         if (!identical(...future.workdir, getwd())) 
[10:27:22.487]             setwd(...future.workdir)
[10:27:22.487]         {
[10:27:22.487]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:22.487]                 ...future.oldOptions$nwarnings <- NULL
[10:27:22.487]             }
[10:27:22.487]             base::options(...future.oldOptions)
[10:27:22.487]             if (.Platform$OS.type == "windows") {
[10:27:22.487]                 old_names <- names(...future.oldEnvVars)
[10:27:22.487]                 envs <- base::Sys.getenv()
[10:27:22.487]                 names <- names(envs)
[10:27:22.487]                 common <- intersect(names, old_names)
[10:27:22.487]                 added <- setdiff(names, old_names)
[10:27:22.487]                 removed <- setdiff(old_names, names)
[10:27:22.487]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:22.487]                   envs[common]]
[10:27:22.487]                 NAMES <- toupper(changed)
[10:27:22.487]                 args <- list()
[10:27:22.487]                 for (kk in seq_along(NAMES)) {
[10:27:22.487]                   name <- changed[[kk]]
[10:27:22.487]                   NAME <- NAMES[[kk]]
[10:27:22.487]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.487]                     next
[10:27:22.487]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:22.487]                 }
[10:27:22.487]                 NAMES <- toupper(added)
[10:27:22.487]                 for (kk in seq_along(NAMES)) {
[10:27:22.487]                   name <- added[[kk]]
[10:27:22.487]                   NAME <- NAMES[[kk]]
[10:27:22.487]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.487]                     next
[10:27:22.487]                   args[[name]] <- ""
[10:27:22.487]                 }
[10:27:22.487]                 NAMES <- toupper(removed)
[10:27:22.487]                 for (kk in seq_along(NAMES)) {
[10:27:22.487]                   name <- removed[[kk]]
[10:27:22.487]                   NAME <- NAMES[[kk]]
[10:27:22.487]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.487]                     next
[10:27:22.487]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:22.487]                 }
[10:27:22.487]                 if (length(args) > 0) 
[10:27:22.487]                   base::do.call(base::Sys.setenv, args = args)
[10:27:22.487]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:22.487]             }
[10:27:22.487]             else {
[10:27:22.487]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:22.487]             }
[10:27:22.487]             {
[10:27:22.487]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:22.487]                   0L) {
[10:27:22.487]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:22.487]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:22.487]                   base::options(opts)
[10:27:22.487]                 }
[10:27:22.487]                 {
[10:27:22.487]                   {
[10:27:22.487]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:22.487]                     NULL
[10:27:22.487]                   }
[10:27:22.487]                   options(future.plan = NULL)
[10:27:22.487]                   if (is.na(NA_character_)) 
[10:27:22.487]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:22.487]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:22.487]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:22.487]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:22.487]                     envir = parent.frame()) 
[10:27:22.487]                   {
[10:27:22.487]                     if (is.function(workers)) 
[10:27:22.487]                       workers <- workers()
[10:27:22.487]                     workers <- structure(as.integer(workers), 
[10:27:22.487]                       class = class(workers))
[10:27:22.487]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:22.487]                       workers >= 1)
[10:27:22.487]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:22.487]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:22.487]                     }
[10:27:22.487]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:22.487]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:22.487]                       envir = envir)
[10:27:22.487]                     if (!future$lazy) 
[10:27:22.487]                       future <- run(future)
[10:27:22.487]                     invisible(future)
[10:27:22.487]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:22.487]                 }
[10:27:22.487]             }
[10:27:22.487]         }
[10:27:22.487]     })
[10:27:22.487]     if (TRUE) {
[10:27:22.487]         base::sink(type = "output", split = FALSE)
[10:27:22.487]         if (TRUE) {
[10:27:22.487]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:22.487]         }
[10:27:22.487]         else {
[10:27:22.487]             ...future.result["stdout"] <- base::list(NULL)
[10:27:22.487]         }
[10:27:22.487]         base::close(...future.stdout)
[10:27:22.487]         ...future.stdout <- NULL
[10:27:22.487]     }
[10:27:22.487]     ...future.result$conditions <- ...future.conditions
[10:27:22.487]     ...future.result$finished <- base::Sys.time()
[10:27:22.487]     ...future.result
[10:27:22.487] }
[10:27:22.491] MultisessionFuture started
[10:27:22.491] - Launch lazy future ... done
[10:27:22.491] run() for ‘MultisessionFuture’ ... done
[10:27:22.492] resolve() on environment ...
[10:27:22.492]  recursive: 0
[10:27:22.492]  elements: [3] ‘a’
[10:27:22.513]  length: 2 (resolved future 3)
[10:27:22.524] receiveMessageFromWorker() for ClusterFuture ...
[10:27:22.524] - Validating connection of MultisessionFuture
[10:27:22.524] - received message: FutureResult
[10:27:22.524] - Received FutureResult
[10:27:22.525] - Erased future from FutureRegistry
[10:27:22.525] result() for ClusterFuture ...
[10:27:22.525] - result already collected: FutureResult
[10:27:22.525] result() for ClusterFuture ... done
[10:27:22.525] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:22.525] Future #1
[10:27:22.525]  length: 1 (resolved future 1)
[10:27:22.546] receiveMessageFromWorker() for ClusterFuture ...
[10:27:22.546] - Validating connection of MultisessionFuture
[10:27:22.547] - received message: FutureResult
[10:27:22.547] - Received FutureResult
[10:27:22.547] - Erased future from FutureRegistry
[10:27:22.547] result() for ClusterFuture ...
[10:27:22.547] - result already collected: FutureResult
[10:27:22.547] result() for ClusterFuture ... done
[10:27:22.547] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:22.547] Future #2
[10:27:22.547]  length: 0 (resolved future 2)
[10:27:22.548] resolve() on environment ... DONE
[10:27:22.548] resolve() on environment ...
[10:27:22.548]  recursive: 0
[10:27:22.549]  elements: [3] ‘b’
[10:27:22.549] Future #1
[10:27:22.549]  length: 2 (resolved future 1)
[10:27:22.549] Future #2
[10:27:22.552]  length: 1 (resolved future 2)
[10:27:22.552]  length: 0 (resolved future 3)
[10:27:22.552] resolve() on environment ... DONE
[10:27:22.553] resolve() on environment ...
[10:27:22.553]  recursive: 0
[10:27:22.554]  elements: [3] ‘c’
[10:27:22.554] Future #1
[10:27:22.554]  length: 2 (resolved future 1)
[10:27:22.554] Future #2
[10:27:22.554]  length: 1 (resolved future 2)
[10:27:22.554]  length: 0 (resolved future 3)
[10:27:22.555] resolve() on environment ... DONE
[10:27:22.555] resolve() on environment ...
[10:27:22.555]  recursive: 0
[10:27:22.556]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[10:27:22.556] Future #1
[10:27:22.556] result() for ClusterFuture ...
[10:27:22.556] - result already collected: FutureResult
[10:27:22.556] result() for ClusterFuture ... done
[10:27:22.556] result() for ClusterFuture ...
[10:27:22.556] - result already collected: FutureResult
[10:27:22.556] result() for ClusterFuture ... done
[10:27:22.557]  length: 2 (resolved future 1)
[10:27:22.557] Future #2
[10:27:22.557] result() for ClusterFuture ...
[10:27:22.557] - result already collected: FutureResult
[10:27:22.557] result() for ClusterFuture ... done
[10:27:22.557] result() for ClusterFuture ...
[10:27:22.557] - result already collected: FutureResult
[10:27:22.557] result() for ClusterFuture ... done
[10:27:22.557]  length: 1 (resolved future 2)
[10:27:22.557]  length: 0 (resolved future 3)
[10:27:22.558] resolve() on environment ... DONE
[10:27:22.558] resolve() on environment ...
[10:27:22.558]  recursive: 99
[10:27:22.558]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[10:27:22.559] Future #1
[10:27:22.559] result() for ClusterFuture ...
[10:27:22.559] - result already collected: FutureResult
[10:27:22.559] result() for ClusterFuture ... done
[10:27:22.559] result() for ClusterFuture ...
[10:27:22.559] - result already collected: FutureResult
[10:27:22.559] result() for ClusterFuture ... done
[10:27:22.559] A MultisessionFuture was resolved
[10:27:22.559]  length: 2 (resolved future 1)
[10:27:22.559] Future #2
[10:27:22.560] result() for ClusterFuture ...
[10:27:22.560] - result already collected: FutureResult
[10:27:22.560] result() for ClusterFuture ... done
[10:27:22.560] result() for ClusterFuture ...
[10:27:22.560] - result already collected: FutureResult
[10:27:22.560] result() for ClusterFuture ... done
[10:27:22.560] A MultisessionFuture was resolved
[10:27:22.560]  length: 1 (resolved future 2)
[10:27:22.560]  length: 0 (resolved future 3)
[10:27:22.560] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[10:27:22.561] resolve() on list environment ...
[10:27:22.561]  recursive: 0
[10:27:22.562]  length: 2
[10:27:22.562]  elements: ‘a’, ‘b’
[10:27:22.562]  length: 1 (resolved future 1)
[10:27:22.562]  length: 0 (resolved future 2)
[10:27:22.562] resolve() on list environment ... DONE
[10:27:22.562] getGlobalsAndPackages() ...
[10:27:22.562] Searching for globals...
[10:27:22.563] 
[10:27:22.563] Searching for globals ... DONE
[10:27:22.563] - globals: [0] <none>
[10:27:22.563] getGlobalsAndPackages() ... DONE
[10:27:22.563] run() for ‘Future’ ...
[10:27:22.563] - state: ‘created’
[10:27:22.563] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:22.577] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:22.578] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:22.578]   - Field: ‘node’
[10:27:22.578]   - Field: ‘label’
[10:27:22.578]   - Field: ‘local’
[10:27:22.578]   - Field: ‘owner’
[10:27:22.578]   - Field: ‘envir’
[10:27:22.578]   - Field: ‘workers’
[10:27:22.578]   - Field: ‘packages’
[10:27:22.578]   - Field: ‘gc’
[10:27:22.579]   - Field: ‘conditions’
[10:27:22.579]   - Field: ‘persistent’
[10:27:22.579]   - Field: ‘expr’
[10:27:22.579]   - Field: ‘uuid’
[10:27:22.579]   - Field: ‘seed’
[10:27:22.579]   - Field: ‘version’
[10:27:22.579]   - Field: ‘result’
[10:27:22.579]   - Field: ‘asynchronous’
[10:27:22.579]   - Field: ‘calls’
[10:27:22.579]   - Field: ‘globals’
[10:27:22.579]   - Field: ‘stdout’
[10:27:22.580]   - Field: ‘earlySignal’
[10:27:22.580]   - Field: ‘lazy’
[10:27:22.580]   - Field: ‘state’
[10:27:22.580] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:22.580] - Launch lazy future ...
[10:27:22.580] Packages needed by the future expression (n = 0): <none>
[10:27:22.580] Packages needed by future strategies (n = 0): <none>
[10:27:22.581] {
[10:27:22.581]     {
[10:27:22.581]         {
[10:27:22.581]             ...future.startTime <- base::Sys.time()
[10:27:22.581]             {
[10:27:22.581]                 {
[10:27:22.581]                   {
[10:27:22.581]                     {
[10:27:22.581]                       base::local({
[10:27:22.581]                         has_future <- base::requireNamespace("future", 
[10:27:22.581]                           quietly = TRUE)
[10:27:22.581]                         if (has_future) {
[10:27:22.581]                           ns <- base::getNamespace("future")
[10:27:22.581]                           version <- ns[[".package"]][["version"]]
[10:27:22.581]                           if (is.null(version)) 
[10:27:22.581]                             version <- utils::packageVersion("future")
[10:27:22.581]                         }
[10:27:22.581]                         else {
[10:27:22.581]                           version <- NULL
[10:27:22.581]                         }
[10:27:22.581]                         if (!has_future || version < "1.8.0") {
[10:27:22.581]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:22.581]                             "", base::R.version$version.string), 
[10:27:22.581]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:22.581]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:22.581]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:22.581]                               "release", "version")], collapse = " "), 
[10:27:22.581]                             hostname = base::Sys.info()[["nodename"]])
[10:27:22.581]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:22.581]                             info)
[10:27:22.581]                           info <- base::paste(info, collapse = "; ")
[10:27:22.581]                           if (!has_future) {
[10:27:22.581]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:22.581]                               info)
[10:27:22.581]                           }
[10:27:22.581]                           else {
[10:27:22.581]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:22.581]                               info, version)
[10:27:22.581]                           }
[10:27:22.581]                           base::stop(msg)
[10:27:22.581]                         }
[10:27:22.581]                       })
[10:27:22.581]                     }
[10:27:22.581]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:22.581]                     base::options(mc.cores = 1L)
[10:27:22.581]                   }
[10:27:22.581]                   options(future.plan = NULL)
[10:27:22.581]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:22.581]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:22.581]                 }
[10:27:22.581]                 ...future.workdir <- getwd()
[10:27:22.581]             }
[10:27:22.581]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:22.581]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:22.581]         }
[10:27:22.581]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:22.581]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:22.581]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:22.581]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:22.581]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:22.581]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:22.581]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:22.581]             base::names(...future.oldOptions))
[10:27:22.581]     }
[10:27:22.581]     if (FALSE) {
[10:27:22.581]     }
[10:27:22.581]     else {
[10:27:22.581]         if (TRUE) {
[10:27:22.581]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:22.581]                 open = "w")
[10:27:22.581]         }
[10:27:22.581]         else {
[10:27:22.581]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:22.581]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:22.581]         }
[10:27:22.581]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:22.581]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:22.581]             base::sink(type = "output", split = FALSE)
[10:27:22.581]             base::close(...future.stdout)
[10:27:22.581]         }, add = TRUE)
[10:27:22.581]     }
[10:27:22.581]     ...future.frame <- base::sys.nframe()
[10:27:22.581]     ...future.conditions <- base::list()
[10:27:22.581]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:22.581]     if (FALSE) {
[10:27:22.581]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:22.581]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:22.581]     }
[10:27:22.581]     ...future.result <- base::tryCatch({
[10:27:22.581]         base::withCallingHandlers({
[10:27:22.581]             ...future.value <- base::withVisible(base::local({
[10:27:22.581]                 ...future.makeSendCondition <- base::local({
[10:27:22.581]                   sendCondition <- NULL
[10:27:22.581]                   function(frame = 1L) {
[10:27:22.581]                     if (is.function(sendCondition)) 
[10:27:22.581]                       return(sendCondition)
[10:27:22.581]                     ns <- getNamespace("parallel")
[10:27:22.581]                     if (exists("sendData", mode = "function", 
[10:27:22.581]                       envir = ns)) {
[10:27:22.581]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:22.581]                         envir = ns)
[10:27:22.581]                       envir <- sys.frame(frame)
[10:27:22.581]                       master <- NULL
[10:27:22.581]                       while (!identical(envir, .GlobalEnv) && 
[10:27:22.581]                         !identical(envir, emptyenv())) {
[10:27:22.581]                         if (exists("master", mode = "list", envir = envir, 
[10:27:22.581]                           inherits = FALSE)) {
[10:27:22.581]                           master <- get("master", mode = "list", 
[10:27:22.581]                             envir = envir, inherits = FALSE)
[10:27:22.581]                           if (inherits(master, c("SOCKnode", 
[10:27:22.581]                             "SOCK0node"))) {
[10:27:22.581]                             sendCondition <<- function(cond) {
[10:27:22.581]                               data <- list(type = "VALUE", value = cond, 
[10:27:22.581]                                 success = TRUE)
[10:27:22.581]                               parallel_sendData(master, data)
[10:27:22.581]                             }
[10:27:22.581]                             return(sendCondition)
[10:27:22.581]                           }
[10:27:22.581]                         }
[10:27:22.581]                         frame <- frame + 1L
[10:27:22.581]                         envir <- sys.frame(frame)
[10:27:22.581]                       }
[10:27:22.581]                     }
[10:27:22.581]                     sendCondition <<- function(cond) NULL
[10:27:22.581]                   }
[10:27:22.581]                 })
[10:27:22.581]                 withCallingHandlers({
[10:27:22.581]                   1
[10:27:22.581]                 }, immediateCondition = function(cond) {
[10:27:22.581]                   sendCondition <- ...future.makeSendCondition()
[10:27:22.581]                   sendCondition(cond)
[10:27:22.581]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.581]                   {
[10:27:22.581]                     inherits <- base::inherits
[10:27:22.581]                     invokeRestart <- base::invokeRestart
[10:27:22.581]                     is.null <- base::is.null
[10:27:22.581]                     muffled <- FALSE
[10:27:22.581]                     if (inherits(cond, "message")) {
[10:27:22.581]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:22.581]                       if (muffled) 
[10:27:22.581]                         invokeRestart("muffleMessage")
[10:27:22.581]                     }
[10:27:22.581]                     else if (inherits(cond, "warning")) {
[10:27:22.581]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:22.581]                       if (muffled) 
[10:27:22.581]                         invokeRestart("muffleWarning")
[10:27:22.581]                     }
[10:27:22.581]                     else if (inherits(cond, "condition")) {
[10:27:22.581]                       if (!is.null(pattern)) {
[10:27:22.581]                         computeRestarts <- base::computeRestarts
[10:27:22.581]                         grepl <- base::grepl
[10:27:22.581]                         restarts <- computeRestarts(cond)
[10:27:22.581]                         for (restart in restarts) {
[10:27:22.581]                           name <- restart$name
[10:27:22.581]                           if (is.null(name)) 
[10:27:22.581]                             next
[10:27:22.581]                           if (!grepl(pattern, name)) 
[10:27:22.581]                             next
[10:27:22.581]                           invokeRestart(restart)
[10:27:22.581]                           muffled <- TRUE
[10:27:22.581]                           break
[10:27:22.581]                         }
[10:27:22.581]                       }
[10:27:22.581]                     }
[10:27:22.581]                     invisible(muffled)
[10:27:22.581]                   }
[10:27:22.581]                   muffleCondition(cond)
[10:27:22.581]                 })
[10:27:22.581]             }))
[10:27:22.581]             future::FutureResult(value = ...future.value$value, 
[10:27:22.581]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:22.581]                   ...future.rng), globalenv = if (FALSE) 
[10:27:22.581]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:22.581]                     ...future.globalenv.names))
[10:27:22.581]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:22.581]         }, condition = base::local({
[10:27:22.581]             c <- base::c
[10:27:22.581]             inherits <- base::inherits
[10:27:22.581]             invokeRestart <- base::invokeRestart
[10:27:22.581]             length <- base::length
[10:27:22.581]             list <- base::list
[10:27:22.581]             seq.int <- base::seq.int
[10:27:22.581]             signalCondition <- base::signalCondition
[10:27:22.581]             sys.calls <- base::sys.calls
[10:27:22.581]             `[[` <- base::`[[`
[10:27:22.581]             `+` <- base::`+`
[10:27:22.581]             `<<-` <- base::`<<-`
[10:27:22.581]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:22.581]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:22.581]                   3L)]
[10:27:22.581]             }
[10:27:22.581]             function(cond) {
[10:27:22.581]                 is_error <- inherits(cond, "error")
[10:27:22.581]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:22.581]                   NULL)
[10:27:22.581]                 if (is_error) {
[10:27:22.581]                   sessionInformation <- function() {
[10:27:22.581]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:22.581]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:22.581]                       search = base::search(), system = base::Sys.info())
[10:27:22.581]                   }
[10:27:22.581]                   ...future.conditions[[length(...future.conditions) + 
[10:27:22.581]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:22.581]                     cond$call), session = sessionInformation(), 
[10:27:22.581]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:22.581]                   signalCondition(cond)
[10:27:22.581]                 }
[10:27:22.581]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:22.581]                 "immediateCondition"))) {
[10:27:22.581]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:22.581]                   ...future.conditions[[length(...future.conditions) + 
[10:27:22.581]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:22.581]                   if (TRUE && !signal) {
[10:27:22.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.581]                     {
[10:27:22.581]                       inherits <- base::inherits
[10:27:22.581]                       invokeRestart <- base::invokeRestart
[10:27:22.581]                       is.null <- base::is.null
[10:27:22.581]                       muffled <- FALSE
[10:27:22.581]                       if (inherits(cond, "message")) {
[10:27:22.581]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:22.581]                         if (muffled) 
[10:27:22.581]                           invokeRestart("muffleMessage")
[10:27:22.581]                       }
[10:27:22.581]                       else if (inherits(cond, "warning")) {
[10:27:22.581]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:22.581]                         if (muffled) 
[10:27:22.581]                           invokeRestart("muffleWarning")
[10:27:22.581]                       }
[10:27:22.581]                       else if (inherits(cond, "condition")) {
[10:27:22.581]                         if (!is.null(pattern)) {
[10:27:22.581]                           computeRestarts <- base::computeRestarts
[10:27:22.581]                           grepl <- base::grepl
[10:27:22.581]                           restarts <- computeRestarts(cond)
[10:27:22.581]                           for (restart in restarts) {
[10:27:22.581]                             name <- restart$name
[10:27:22.581]                             if (is.null(name)) 
[10:27:22.581]                               next
[10:27:22.581]                             if (!grepl(pattern, name)) 
[10:27:22.581]                               next
[10:27:22.581]                             invokeRestart(restart)
[10:27:22.581]                             muffled <- TRUE
[10:27:22.581]                             break
[10:27:22.581]                           }
[10:27:22.581]                         }
[10:27:22.581]                       }
[10:27:22.581]                       invisible(muffled)
[10:27:22.581]                     }
[10:27:22.581]                     muffleCondition(cond, pattern = "^muffle")
[10:27:22.581]                   }
[10:27:22.581]                 }
[10:27:22.581]                 else {
[10:27:22.581]                   if (TRUE) {
[10:27:22.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.581]                     {
[10:27:22.581]                       inherits <- base::inherits
[10:27:22.581]                       invokeRestart <- base::invokeRestart
[10:27:22.581]                       is.null <- base::is.null
[10:27:22.581]                       muffled <- FALSE
[10:27:22.581]                       if (inherits(cond, "message")) {
[10:27:22.581]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:22.581]                         if (muffled) 
[10:27:22.581]                           invokeRestart("muffleMessage")
[10:27:22.581]                       }
[10:27:22.581]                       else if (inherits(cond, "warning")) {
[10:27:22.581]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:22.581]                         if (muffled) 
[10:27:22.581]                           invokeRestart("muffleWarning")
[10:27:22.581]                       }
[10:27:22.581]                       else if (inherits(cond, "condition")) {
[10:27:22.581]                         if (!is.null(pattern)) {
[10:27:22.581]                           computeRestarts <- base::computeRestarts
[10:27:22.581]                           grepl <- base::grepl
[10:27:22.581]                           restarts <- computeRestarts(cond)
[10:27:22.581]                           for (restart in restarts) {
[10:27:22.581]                             name <- restart$name
[10:27:22.581]                             if (is.null(name)) 
[10:27:22.581]                               next
[10:27:22.581]                             if (!grepl(pattern, name)) 
[10:27:22.581]                               next
[10:27:22.581]                             invokeRestart(restart)
[10:27:22.581]                             muffled <- TRUE
[10:27:22.581]                             break
[10:27:22.581]                           }
[10:27:22.581]                         }
[10:27:22.581]                       }
[10:27:22.581]                       invisible(muffled)
[10:27:22.581]                     }
[10:27:22.581]                     muffleCondition(cond, pattern = "^muffle")
[10:27:22.581]                   }
[10:27:22.581]                 }
[10:27:22.581]             }
[10:27:22.581]         }))
[10:27:22.581]     }, error = function(ex) {
[10:27:22.581]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:22.581]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:22.581]                 ...future.rng), started = ...future.startTime, 
[10:27:22.581]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:22.581]             version = "1.8"), class = "FutureResult")
[10:27:22.581]     }, finally = {
[10:27:22.581]         if (!identical(...future.workdir, getwd())) 
[10:27:22.581]             setwd(...future.workdir)
[10:27:22.581]         {
[10:27:22.581]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:22.581]                 ...future.oldOptions$nwarnings <- NULL
[10:27:22.581]             }
[10:27:22.581]             base::options(...future.oldOptions)
[10:27:22.581]             if (.Platform$OS.type == "windows") {
[10:27:22.581]                 old_names <- names(...future.oldEnvVars)
[10:27:22.581]                 envs <- base::Sys.getenv()
[10:27:22.581]                 names <- names(envs)
[10:27:22.581]                 common <- intersect(names, old_names)
[10:27:22.581]                 added <- setdiff(names, old_names)
[10:27:22.581]                 removed <- setdiff(old_names, names)
[10:27:22.581]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:22.581]                   envs[common]]
[10:27:22.581]                 NAMES <- toupper(changed)
[10:27:22.581]                 args <- list()
[10:27:22.581]                 for (kk in seq_along(NAMES)) {
[10:27:22.581]                   name <- changed[[kk]]
[10:27:22.581]                   NAME <- NAMES[[kk]]
[10:27:22.581]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.581]                     next
[10:27:22.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:22.581]                 }
[10:27:22.581]                 NAMES <- toupper(added)
[10:27:22.581]                 for (kk in seq_along(NAMES)) {
[10:27:22.581]                   name <- added[[kk]]
[10:27:22.581]                   NAME <- NAMES[[kk]]
[10:27:22.581]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.581]                     next
[10:27:22.581]                   args[[name]] <- ""
[10:27:22.581]                 }
[10:27:22.581]                 NAMES <- toupper(removed)
[10:27:22.581]                 for (kk in seq_along(NAMES)) {
[10:27:22.581]                   name <- removed[[kk]]
[10:27:22.581]                   NAME <- NAMES[[kk]]
[10:27:22.581]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.581]                     next
[10:27:22.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:22.581]                 }
[10:27:22.581]                 if (length(args) > 0) 
[10:27:22.581]                   base::do.call(base::Sys.setenv, args = args)
[10:27:22.581]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:22.581]             }
[10:27:22.581]             else {
[10:27:22.581]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:22.581]             }
[10:27:22.581]             {
[10:27:22.581]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:22.581]                   0L) {
[10:27:22.581]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:22.581]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:22.581]                   base::options(opts)
[10:27:22.581]                 }
[10:27:22.581]                 {
[10:27:22.581]                   {
[10:27:22.581]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:22.581]                     NULL
[10:27:22.581]                   }
[10:27:22.581]                   options(future.plan = NULL)
[10:27:22.581]                   if (is.na(NA_character_)) 
[10:27:22.581]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:22.581]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:22.581]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:22.581]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:22.581]                     envir = parent.frame()) 
[10:27:22.581]                   {
[10:27:22.581]                     if (is.function(workers)) 
[10:27:22.581]                       workers <- workers()
[10:27:22.581]                     workers <- structure(as.integer(workers), 
[10:27:22.581]                       class = class(workers))
[10:27:22.581]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:22.581]                       workers >= 1)
[10:27:22.581]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:22.581]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:22.581]                     }
[10:27:22.581]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:22.581]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:22.581]                       envir = envir)
[10:27:22.581]                     if (!future$lazy) 
[10:27:22.581]                       future <- run(future)
[10:27:22.581]                     invisible(future)
[10:27:22.581]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:22.581]                 }
[10:27:22.581]             }
[10:27:22.581]         }
[10:27:22.581]     })
[10:27:22.581]     if (TRUE) {
[10:27:22.581]         base::sink(type = "output", split = FALSE)
[10:27:22.581]         if (TRUE) {
[10:27:22.581]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:22.581]         }
[10:27:22.581]         else {
[10:27:22.581]             ...future.result["stdout"] <- base::list(NULL)
[10:27:22.581]         }
[10:27:22.581]         base::close(...future.stdout)
[10:27:22.581]         ...future.stdout <- NULL
[10:27:22.581]     }
[10:27:22.581]     ...future.result$conditions <- ...future.conditions
[10:27:22.581]     ...future.result$finished <- base::Sys.time()
[10:27:22.581]     ...future.result
[10:27:22.581] }
[10:27:22.584] MultisessionFuture started
[10:27:22.584] - Launch lazy future ... done
[10:27:22.584] run() for ‘MultisessionFuture’ ... done
[10:27:22.584] getGlobalsAndPackages() ...
[10:27:22.585] Searching for globals...
[10:27:22.585] 
[10:27:22.585] Searching for globals ... DONE
[10:27:22.585] - globals: [0] <none>
[10:27:22.585] getGlobalsAndPackages() ... DONE
[10:27:22.585] run() for ‘Future’ ...
[10:27:22.586] - state: ‘created’
[10:27:22.586] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:22.600] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:22.600] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:22.600]   - Field: ‘node’
[10:27:22.600]   - Field: ‘label’
[10:27:22.600]   - Field: ‘local’
[10:27:22.600]   - Field: ‘owner’
[10:27:22.600]   - Field: ‘envir’
[10:27:22.601]   - Field: ‘workers’
[10:27:22.601]   - Field: ‘packages’
[10:27:22.601]   - Field: ‘gc’
[10:27:22.601]   - Field: ‘conditions’
[10:27:22.601]   - Field: ‘persistent’
[10:27:22.601]   - Field: ‘expr’
[10:27:22.601]   - Field: ‘uuid’
[10:27:22.601]   - Field: ‘seed’
[10:27:22.601]   - Field: ‘version’
[10:27:22.602]   - Field: ‘result’
[10:27:22.602]   - Field: ‘asynchronous’
[10:27:22.602]   - Field: ‘calls’
[10:27:22.602]   - Field: ‘globals’
[10:27:22.602]   - Field: ‘stdout’
[10:27:22.602]   - Field: ‘earlySignal’
[10:27:22.602]   - Field: ‘lazy’
[10:27:22.602]   - Field: ‘state’
[10:27:22.602] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:22.603] - Launch lazy future ...
[10:27:22.603] Packages needed by the future expression (n = 0): <none>
[10:27:22.603] Packages needed by future strategies (n = 0): <none>
[10:27:22.603] {
[10:27:22.603]     {
[10:27:22.603]         {
[10:27:22.603]             ...future.startTime <- base::Sys.time()
[10:27:22.603]             {
[10:27:22.603]                 {
[10:27:22.603]                   {
[10:27:22.603]                     {
[10:27:22.603]                       base::local({
[10:27:22.603]                         has_future <- base::requireNamespace("future", 
[10:27:22.603]                           quietly = TRUE)
[10:27:22.603]                         if (has_future) {
[10:27:22.603]                           ns <- base::getNamespace("future")
[10:27:22.603]                           version <- ns[[".package"]][["version"]]
[10:27:22.603]                           if (is.null(version)) 
[10:27:22.603]                             version <- utils::packageVersion("future")
[10:27:22.603]                         }
[10:27:22.603]                         else {
[10:27:22.603]                           version <- NULL
[10:27:22.603]                         }
[10:27:22.603]                         if (!has_future || version < "1.8.0") {
[10:27:22.603]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:22.603]                             "", base::R.version$version.string), 
[10:27:22.603]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:22.603]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:22.603]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:22.603]                               "release", "version")], collapse = " "), 
[10:27:22.603]                             hostname = base::Sys.info()[["nodename"]])
[10:27:22.603]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:22.603]                             info)
[10:27:22.603]                           info <- base::paste(info, collapse = "; ")
[10:27:22.603]                           if (!has_future) {
[10:27:22.603]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:22.603]                               info)
[10:27:22.603]                           }
[10:27:22.603]                           else {
[10:27:22.603]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:22.603]                               info, version)
[10:27:22.603]                           }
[10:27:22.603]                           base::stop(msg)
[10:27:22.603]                         }
[10:27:22.603]                       })
[10:27:22.603]                     }
[10:27:22.603]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:22.603]                     base::options(mc.cores = 1L)
[10:27:22.603]                   }
[10:27:22.603]                   options(future.plan = NULL)
[10:27:22.603]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:22.603]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:22.603]                 }
[10:27:22.603]                 ...future.workdir <- getwd()
[10:27:22.603]             }
[10:27:22.603]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:22.603]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:22.603]         }
[10:27:22.603]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:22.603]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:22.603]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:22.603]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:22.603]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:22.603]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:22.603]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:22.603]             base::names(...future.oldOptions))
[10:27:22.603]     }
[10:27:22.603]     if (FALSE) {
[10:27:22.603]     }
[10:27:22.603]     else {
[10:27:22.603]         if (TRUE) {
[10:27:22.603]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:22.603]                 open = "w")
[10:27:22.603]         }
[10:27:22.603]         else {
[10:27:22.603]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:22.603]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:22.603]         }
[10:27:22.603]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:22.603]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:22.603]             base::sink(type = "output", split = FALSE)
[10:27:22.603]             base::close(...future.stdout)
[10:27:22.603]         }, add = TRUE)
[10:27:22.603]     }
[10:27:22.603]     ...future.frame <- base::sys.nframe()
[10:27:22.603]     ...future.conditions <- base::list()
[10:27:22.603]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:22.603]     if (FALSE) {
[10:27:22.603]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:22.603]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:22.603]     }
[10:27:22.603]     ...future.result <- base::tryCatch({
[10:27:22.603]         base::withCallingHandlers({
[10:27:22.603]             ...future.value <- base::withVisible(base::local({
[10:27:22.603]                 ...future.makeSendCondition <- base::local({
[10:27:22.603]                   sendCondition <- NULL
[10:27:22.603]                   function(frame = 1L) {
[10:27:22.603]                     if (is.function(sendCondition)) 
[10:27:22.603]                       return(sendCondition)
[10:27:22.603]                     ns <- getNamespace("parallel")
[10:27:22.603]                     if (exists("sendData", mode = "function", 
[10:27:22.603]                       envir = ns)) {
[10:27:22.603]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:22.603]                         envir = ns)
[10:27:22.603]                       envir <- sys.frame(frame)
[10:27:22.603]                       master <- NULL
[10:27:22.603]                       while (!identical(envir, .GlobalEnv) && 
[10:27:22.603]                         !identical(envir, emptyenv())) {
[10:27:22.603]                         if (exists("master", mode = "list", envir = envir, 
[10:27:22.603]                           inherits = FALSE)) {
[10:27:22.603]                           master <- get("master", mode = "list", 
[10:27:22.603]                             envir = envir, inherits = FALSE)
[10:27:22.603]                           if (inherits(master, c("SOCKnode", 
[10:27:22.603]                             "SOCK0node"))) {
[10:27:22.603]                             sendCondition <<- function(cond) {
[10:27:22.603]                               data <- list(type = "VALUE", value = cond, 
[10:27:22.603]                                 success = TRUE)
[10:27:22.603]                               parallel_sendData(master, data)
[10:27:22.603]                             }
[10:27:22.603]                             return(sendCondition)
[10:27:22.603]                           }
[10:27:22.603]                         }
[10:27:22.603]                         frame <- frame + 1L
[10:27:22.603]                         envir <- sys.frame(frame)
[10:27:22.603]                       }
[10:27:22.603]                     }
[10:27:22.603]                     sendCondition <<- function(cond) NULL
[10:27:22.603]                   }
[10:27:22.603]                 })
[10:27:22.603]                 withCallingHandlers({
[10:27:22.603]                   2
[10:27:22.603]                 }, immediateCondition = function(cond) {
[10:27:22.603]                   sendCondition <- ...future.makeSendCondition()
[10:27:22.603]                   sendCondition(cond)
[10:27:22.603]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.603]                   {
[10:27:22.603]                     inherits <- base::inherits
[10:27:22.603]                     invokeRestart <- base::invokeRestart
[10:27:22.603]                     is.null <- base::is.null
[10:27:22.603]                     muffled <- FALSE
[10:27:22.603]                     if (inherits(cond, "message")) {
[10:27:22.603]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:22.603]                       if (muffled) 
[10:27:22.603]                         invokeRestart("muffleMessage")
[10:27:22.603]                     }
[10:27:22.603]                     else if (inherits(cond, "warning")) {
[10:27:22.603]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:22.603]                       if (muffled) 
[10:27:22.603]                         invokeRestart("muffleWarning")
[10:27:22.603]                     }
[10:27:22.603]                     else if (inherits(cond, "condition")) {
[10:27:22.603]                       if (!is.null(pattern)) {
[10:27:22.603]                         computeRestarts <- base::computeRestarts
[10:27:22.603]                         grepl <- base::grepl
[10:27:22.603]                         restarts <- computeRestarts(cond)
[10:27:22.603]                         for (restart in restarts) {
[10:27:22.603]                           name <- restart$name
[10:27:22.603]                           if (is.null(name)) 
[10:27:22.603]                             next
[10:27:22.603]                           if (!grepl(pattern, name)) 
[10:27:22.603]                             next
[10:27:22.603]                           invokeRestart(restart)
[10:27:22.603]                           muffled <- TRUE
[10:27:22.603]                           break
[10:27:22.603]                         }
[10:27:22.603]                       }
[10:27:22.603]                     }
[10:27:22.603]                     invisible(muffled)
[10:27:22.603]                   }
[10:27:22.603]                   muffleCondition(cond)
[10:27:22.603]                 })
[10:27:22.603]             }))
[10:27:22.603]             future::FutureResult(value = ...future.value$value, 
[10:27:22.603]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:22.603]                   ...future.rng), globalenv = if (FALSE) 
[10:27:22.603]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:22.603]                     ...future.globalenv.names))
[10:27:22.603]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:22.603]         }, condition = base::local({
[10:27:22.603]             c <- base::c
[10:27:22.603]             inherits <- base::inherits
[10:27:22.603]             invokeRestart <- base::invokeRestart
[10:27:22.603]             length <- base::length
[10:27:22.603]             list <- base::list
[10:27:22.603]             seq.int <- base::seq.int
[10:27:22.603]             signalCondition <- base::signalCondition
[10:27:22.603]             sys.calls <- base::sys.calls
[10:27:22.603]             `[[` <- base::`[[`
[10:27:22.603]             `+` <- base::`+`
[10:27:22.603]             `<<-` <- base::`<<-`
[10:27:22.603]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:22.603]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:22.603]                   3L)]
[10:27:22.603]             }
[10:27:22.603]             function(cond) {
[10:27:22.603]                 is_error <- inherits(cond, "error")
[10:27:22.603]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:22.603]                   NULL)
[10:27:22.603]                 if (is_error) {
[10:27:22.603]                   sessionInformation <- function() {
[10:27:22.603]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:22.603]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:22.603]                       search = base::search(), system = base::Sys.info())
[10:27:22.603]                   }
[10:27:22.603]                   ...future.conditions[[length(...future.conditions) + 
[10:27:22.603]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:22.603]                     cond$call), session = sessionInformation(), 
[10:27:22.603]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:22.603]                   signalCondition(cond)
[10:27:22.603]                 }
[10:27:22.603]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:22.603]                 "immediateCondition"))) {
[10:27:22.603]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:22.603]                   ...future.conditions[[length(...future.conditions) + 
[10:27:22.603]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:22.603]                   if (TRUE && !signal) {
[10:27:22.603]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.603]                     {
[10:27:22.603]                       inherits <- base::inherits
[10:27:22.603]                       invokeRestart <- base::invokeRestart
[10:27:22.603]                       is.null <- base::is.null
[10:27:22.603]                       muffled <- FALSE
[10:27:22.603]                       if (inherits(cond, "message")) {
[10:27:22.603]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:22.603]                         if (muffled) 
[10:27:22.603]                           invokeRestart("muffleMessage")
[10:27:22.603]                       }
[10:27:22.603]                       else if (inherits(cond, "warning")) {
[10:27:22.603]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:22.603]                         if (muffled) 
[10:27:22.603]                           invokeRestart("muffleWarning")
[10:27:22.603]                       }
[10:27:22.603]                       else if (inherits(cond, "condition")) {
[10:27:22.603]                         if (!is.null(pattern)) {
[10:27:22.603]                           computeRestarts <- base::computeRestarts
[10:27:22.603]                           grepl <- base::grepl
[10:27:22.603]                           restarts <- computeRestarts(cond)
[10:27:22.603]                           for (restart in restarts) {
[10:27:22.603]                             name <- restart$name
[10:27:22.603]                             if (is.null(name)) 
[10:27:22.603]                               next
[10:27:22.603]                             if (!grepl(pattern, name)) 
[10:27:22.603]                               next
[10:27:22.603]                             invokeRestart(restart)
[10:27:22.603]                             muffled <- TRUE
[10:27:22.603]                             break
[10:27:22.603]                           }
[10:27:22.603]                         }
[10:27:22.603]                       }
[10:27:22.603]                       invisible(muffled)
[10:27:22.603]                     }
[10:27:22.603]                     muffleCondition(cond, pattern = "^muffle")
[10:27:22.603]                   }
[10:27:22.603]                 }
[10:27:22.603]                 else {
[10:27:22.603]                   if (TRUE) {
[10:27:22.603]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.603]                     {
[10:27:22.603]                       inherits <- base::inherits
[10:27:22.603]                       invokeRestart <- base::invokeRestart
[10:27:22.603]                       is.null <- base::is.null
[10:27:22.603]                       muffled <- FALSE
[10:27:22.603]                       if (inherits(cond, "message")) {
[10:27:22.603]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:22.603]                         if (muffled) 
[10:27:22.603]                           invokeRestart("muffleMessage")
[10:27:22.603]                       }
[10:27:22.603]                       else if (inherits(cond, "warning")) {
[10:27:22.603]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:22.603]                         if (muffled) 
[10:27:22.603]                           invokeRestart("muffleWarning")
[10:27:22.603]                       }
[10:27:22.603]                       else if (inherits(cond, "condition")) {
[10:27:22.603]                         if (!is.null(pattern)) {
[10:27:22.603]                           computeRestarts <- base::computeRestarts
[10:27:22.603]                           grepl <- base::grepl
[10:27:22.603]                           restarts <- computeRestarts(cond)
[10:27:22.603]                           for (restart in restarts) {
[10:27:22.603]                             name <- restart$name
[10:27:22.603]                             if (is.null(name)) 
[10:27:22.603]                               next
[10:27:22.603]                             if (!grepl(pattern, name)) 
[10:27:22.603]                               next
[10:27:22.603]                             invokeRestart(restart)
[10:27:22.603]                             muffled <- TRUE
[10:27:22.603]                             break
[10:27:22.603]                           }
[10:27:22.603]                         }
[10:27:22.603]                       }
[10:27:22.603]                       invisible(muffled)
[10:27:22.603]                     }
[10:27:22.603]                     muffleCondition(cond, pattern = "^muffle")
[10:27:22.603]                   }
[10:27:22.603]                 }
[10:27:22.603]             }
[10:27:22.603]         }))
[10:27:22.603]     }, error = function(ex) {
[10:27:22.603]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:22.603]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:22.603]                 ...future.rng), started = ...future.startTime, 
[10:27:22.603]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:22.603]             version = "1.8"), class = "FutureResult")
[10:27:22.603]     }, finally = {
[10:27:22.603]         if (!identical(...future.workdir, getwd())) 
[10:27:22.603]             setwd(...future.workdir)
[10:27:22.603]         {
[10:27:22.603]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:22.603]                 ...future.oldOptions$nwarnings <- NULL
[10:27:22.603]             }
[10:27:22.603]             base::options(...future.oldOptions)
[10:27:22.603]             if (.Platform$OS.type == "windows") {
[10:27:22.603]                 old_names <- names(...future.oldEnvVars)
[10:27:22.603]                 envs <- base::Sys.getenv()
[10:27:22.603]                 names <- names(envs)
[10:27:22.603]                 common <- intersect(names, old_names)
[10:27:22.603]                 added <- setdiff(names, old_names)
[10:27:22.603]                 removed <- setdiff(old_names, names)
[10:27:22.603]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:22.603]                   envs[common]]
[10:27:22.603]                 NAMES <- toupper(changed)
[10:27:22.603]                 args <- list()
[10:27:22.603]                 for (kk in seq_along(NAMES)) {
[10:27:22.603]                   name <- changed[[kk]]
[10:27:22.603]                   NAME <- NAMES[[kk]]
[10:27:22.603]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.603]                     next
[10:27:22.603]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:22.603]                 }
[10:27:22.603]                 NAMES <- toupper(added)
[10:27:22.603]                 for (kk in seq_along(NAMES)) {
[10:27:22.603]                   name <- added[[kk]]
[10:27:22.603]                   NAME <- NAMES[[kk]]
[10:27:22.603]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.603]                     next
[10:27:22.603]                   args[[name]] <- ""
[10:27:22.603]                 }
[10:27:22.603]                 NAMES <- toupper(removed)
[10:27:22.603]                 for (kk in seq_along(NAMES)) {
[10:27:22.603]                   name <- removed[[kk]]
[10:27:22.603]                   NAME <- NAMES[[kk]]
[10:27:22.603]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.603]                     next
[10:27:22.603]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:22.603]                 }
[10:27:22.603]                 if (length(args) > 0) 
[10:27:22.603]                   base::do.call(base::Sys.setenv, args = args)
[10:27:22.603]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:22.603]             }
[10:27:22.603]             else {
[10:27:22.603]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:22.603]             }
[10:27:22.603]             {
[10:27:22.603]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:22.603]                   0L) {
[10:27:22.603]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:22.603]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:22.603]                   base::options(opts)
[10:27:22.603]                 }
[10:27:22.603]                 {
[10:27:22.603]                   {
[10:27:22.603]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:22.603]                     NULL
[10:27:22.603]                   }
[10:27:22.603]                   options(future.plan = NULL)
[10:27:22.603]                   if (is.na(NA_character_)) 
[10:27:22.603]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:22.603]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:22.603]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:22.603]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:22.603]                     envir = parent.frame()) 
[10:27:22.603]                   {
[10:27:22.603]                     if (is.function(workers)) 
[10:27:22.603]                       workers <- workers()
[10:27:22.603]                     workers <- structure(as.integer(workers), 
[10:27:22.603]                       class = class(workers))
[10:27:22.603]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:22.603]                       workers >= 1)
[10:27:22.603]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:22.603]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:22.603]                     }
[10:27:22.603]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:22.603]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:22.603]                       envir = envir)
[10:27:22.603]                     if (!future$lazy) 
[10:27:22.603]                       future <- run(future)
[10:27:22.603]                     invisible(future)
[10:27:22.603]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:22.603]                 }
[10:27:22.603]             }
[10:27:22.603]         }
[10:27:22.603]     })
[10:27:22.603]     if (TRUE) {
[10:27:22.603]         base::sink(type = "output", split = FALSE)
[10:27:22.603]         if (TRUE) {
[10:27:22.603]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:22.603]         }
[10:27:22.603]         else {
[10:27:22.603]             ...future.result["stdout"] <- base::list(NULL)
[10:27:22.603]         }
[10:27:22.603]         base::close(...future.stdout)
[10:27:22.603]         ...future.stdout <- NULL
[10:27:22.603]     }
[10:27:22.603]     ...future.result$conditions <- ...future.conditions
[10:27:22.603]     ...future.result$finished <- base::Sys.time()
[10:27:22.603]     ...future.result
[10:27:22.603] }
[10:27:22.607] MultisessionFuture started
[10:27:22.607] - Launch lazy future ... done
[10:27:22.607] run() for ‘MultisessionFuture’ ... done
[10:27:22.608] resolve() on list environment ...
[10:27:22.608]  recursive: 0
[10:27:22.608]  length: 3
[10:27:22.608]  elements: ‘a’, ‘b’, ‘c’
[10:27:22.630]  length: 2 (resolved future 3)
[10:27:22.640] receiveMessageFromWorker() for ClusterFuture ...
[10:27:22.641] - Validating connection of MultisessionFuture
[10:27:22.641] - received message: FutureResult
[10:27:22.641] - Received FutureResult
[10:27:22.641] - Erased future from FutureRegistry
[10:27:22.641] result() for ClusterFuture ...
[10:27:22.641] - result already collected: FutureResult
[10:27:22.641] result() for ClusterFuture ... done
[10:27:22.641] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:22.642] Future #1
[10:27:22.642]  length: 1 (resolved future 1)
[10:27:22.663] receiveMessageFromWorker() for ClusterFuture ...
[10:27:22.663] - Validating connection of MultisessionFuture
[10:27:22.663] - received message: FutureResult
[10:27:22.663] - Received FutureResult
[10:27:22.663] - Erased future from FutureRegistry
[10:27:22.663] result() for ClusterFuture ...
[10:27:22.663] - result already collected: FutureResult
[10:27:22.664] result() for ClusterFuture ... done
[10:27:22.664] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:22.664] Future #2
[10:27:22.664]  length: 0 (resolved future 2)
[10:27:22.664] resolve() on list environment ... DONE
[10:27:22.665] getGlobalsAndPackages() ...
[10:27:22.665] Searching for globals...
[10:27:22.665] - globals found: [1] ‘{’
[10:27:22.666] Searching for globals ... DONE
[10:27:22.666] Resolving globals: FALSE
[10:27:22.666] 
[10:27:22.666] 
[10:27:22.666] getGlobalsAndPackages() ... DONE
[10:27:22.666] run() for ‘Future’ ...
[10:27:22.667] - state: ‘created’
[10:27:22.667] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:22.681] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:22.681] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:22.681]   - Field: ‘node’
[10:27:22.681]   - Field: ‘label’
[10:27:22.681]   - Field: ‘local’
[10:27:22.682]   - Field: ‘owner’
[10:27:22.682]   - Field: ‘envir’
[10:27:22.682]   - Field: ‘workers’
[10:27:22.682]   - Field: ‘packages’
[10:27:22.682]   - Field: ‘gc’
[10:27:22.682]   - Field: ‘conditions’
[10:27:22.682]   - Field: ‘persistent’
[10:27:22.682]   - Field: ‘expr’
[10:27:22.682]   - Field: ‘uuid’
[10:27:22.682]   - Field: ‘seed’
[10:27:22.683]   - Field: ‘version’
[10:27:22.683]   - Field: ‘result’
[10:27:22.683]   - Field: ‘asynchronous’
[10:27:22.683]   - Field: ‘calls’
[10:27:22.683]   - Field: ‘globals’
[10:27:22.683]   - Field: ‘stdout’
[10:27:22.683]   - Field: ‘earlySignal’
[10:27:22.683]   - Field: ‘lazy’
[10:27:22.683]   - Field: ‘state’
[10:27:22.683] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:22.683] - Launch lazy future ...
[10:27:22.684] Packages needed by the future expression (n = 0): <none>
[10:27:22.684] Packages needed by future strategies (n = 0): <none>
[10:27:22.684] {
[10:27:22.684]     {
[10:27:22.684]         {
[10:27:22.684]             ...future.startTime <- base::Sys.time()
[10:27:22.684]             {
[10:27:22.684]                 {
[10:27:22.684]                   {
[10:27:22.684]                     {
[10:27:22.684]                       base::local({
[10:27:22.684]                         has_future <- base::requireNamespace("future", 
[10:27:22.684]                           quietly = TRUE)
[10:27:22.684]                         if (has_future) {
[10:27:22.684]                           ns <- base::getNamespace("future")
[10:27:22.684]                           version <- ns[[".package"]][["version"]]
[10:27:22.684]                           if (is.null(version)) 
[10:27:22.684]                             version <- utils::packageVersion("future")
[10:27:22.684]                         }
[10:27:22.684]                         else {
[10:27:22.684]                           version <- NULL
[10:27:22.684]                         }
[10:27:22.684]                         if (!has_future || version < "1.8.0") {
[10:27:22.684]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:22.684]                             "", base::R.version$version.string), 
[10:27:22.684]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:22.684]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:22.684]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:22.684]                               "release", "version")], collapse = " "), 
[10:27:22.684]                             hostname = base::Sys.info()[["nodename"]])
[10:27:22.684]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:22.684]                             info)
[10:27:22.684]                           info <- base::paste(info, collapse = "; ")
[10:27:22.684]                           if (!has_future) {
[10:27:22.684]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:22.684]                               info)
[10:27:22.684]                           }
[10:27:22.684]                           else {
[10:27:22.684]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:22.684]                               info, version)
[10:27:22.684]                           }
[10:27:22.684]                           base::stop(msg)
[10:27:22.684]                         }
[10:27:22.684]                       })
[10:27:22.684]                     }
[10:27:22.684]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:22.684]                     base::options(mc.cores = 1L)
[10:27:22.684]                   }
[10:27:22.684]                   options(future.plan = NULL)
[10:27:22.684]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:22.684]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:22.684]                 }
[10:27:22.684]                 ...future.workdir <- getwd()
[10:27:22.684]             }
[10:27:22.684]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:22.684]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:22.684]         }
[10:27:22.684]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:22.684]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:22.684]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:22.684]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:22.684]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:22.684]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:22.684]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:22.684]             base::names(...future.oldOptions))
[10:27:22.684]     }
[10:27:22.684]     if (FALSE) {
[10:27:22.684]     }
[10:27:22.684]     else {
[10:27:22.684]         if (TRUE) {
[10:27:22.684]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:22.684]                 open = "w")
[10:27:22.684]         }
[10:27:22.684]         else {
[10:27:22.684]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:22.684]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:22.684]         }
[10:27:22.684]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:22.684]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:22.684]             base::sink(type = "output", split = FALSE)
[10:27:22.684]             base::close(...future.stdout)
[10:27:22.684]         }, add = TRUE)
[10:27:22.684]     }
[10:27:22.684]     ...future.frame <- base::sys.nframe()
[10:27:22.684]     ...future.conditions <- base::list()
[10:27:22.684]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:22.684]     if (FALSE) {
[10:27:22.684]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:22.684]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:22.684]     }
[10:27:22.684]     ...future.result <- base::tryCatch({
[10:27:22.684]         base::withCallingHandlers({
[10:27:22.684]             ...future.value <- base::withVisible(base::local({
[10:27:22.684]                 ...future.makeSendCondition <- base::local({
[10:27:22.684]                   sendCondition <- NULL
[10:27:22.684]                   function(frame = 1L) {
[10:27:22.684]                     if (is.function(sendCondition)) 
[10:27:22.684]                       return(sendCondition)
[10:27:22.684]                     ns <- getNamespace("parallel")
[10:27:22.684]                     if (exists("sendData", mode = "function", 
[10:27:22.684]                       envir = ns)) {
[10:27:22.684]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:22.684]                         envir = ns)
[10:27:22.684]                       envir <- sys.frame(frame)
[10:27:22.684]                       master <- NULL
[10:27:22.684]                       while (!identical(envir, .GlobalEnv) && 
[10:27:22.684]                         !identical(envir, emptyenv())) {
[10:27:22.684]                         if (exists("master", mode = "list", envir = envir, 
[10:27:22.684]                           inherits = FALSE)) {
[10:27:22.684]                           master <- get("master", mode = "list", 
[10:27:22.684]                             envir = envir, inherits = FALSE)
[10:27:22.684]                           if (inherits(master, c("SOCKnode", 
[10:27:22.684]                             "SOCK0node"))) {
[10:27:22.684]                             sendCondition <<- function(cond) {
[10:27:22.684]                               data <- list(type = "VALUE", value = cond, 
[10:27:22.684]                                 success = TRUE)
[10:27:22.684]                               parallel_sendData(master, data)
[10:27:22.684]                             }
[10:27:22.684]                             return(sendCondition)
[10:27:22.684]                           }
[10:27:22.684]                         }
[10:27:22.684]                         frame <- frame + 1L
[10:27:22.684]                         envir <- sys.frame(frame)
[10:27:22.684]                       }
[10:27:22.684]                     }
[10:27:22.684]                     sendCondition <<- function(cond) NULL
[10:27:22.684]                   }
[10:27:22.684]                 })
[10:27:22.684]                 withCallingHandlers({
[10:27:22.684]                   {
[10:27:22.684]                     1
[10:27:22.684]                   }
[10:27:22.684]                 }, immediateCondition = function(cond) {
[10:27:22.684]                   sendCondition <- ...future.makeSendCondition()
[10:27:22.684]                   sendCondition(cond)
[10:27:22.684]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.684]                   {
[10:27:22.684]                     inherits <- base::inherits
[10:27:22.684]                     invokeRestart <- base::invokeRestart
[10:27:22.684]                     is.null <- base::is.null
[10:27:22.684]                     muffled <- FALSE
[10:27:22.684]                     if (inherits(cond, "message")) {
[10:27:22.684]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:22.684]                       if (muffled) 
[10:27:22.684]                         invokeRestart("muffleMessage")
[10:27:22.684]                     }
[10:27:22.684]                     else if (inherits(cond, "warning")) {
[10:27:22.684]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:22.684]                       if (muffled) 
[10:27:22.684]                         invokeRestart("muffleWarning")
[10:27:22.684]                     }
[10:27:22.684]                     else if (inherits(cond, "condition")) {
[10:27:22.684]                       if (!is.null(pattern)) {
[10:27:22.684]                         computeRestarts <- base::computeRestarts
[10:27:22.684]                         grepl <- base::grepl
[10:27:22.684]                         restarts <- computeRestarts(cond)
[10:27:22.684]                         for (restart in restarts) {
[10:27:22.684]                           name <- restart$name
[10:27:22.684]                           if (is.null(name)) 
[10:27:22.684]                             next
[10:27:22.684]                           if (!grepl(pattern, name)) 
[10:27:22.684]                             next
[10:27:22.684]                           invokeRestart(restart)
[10:27:22.684]                           muffled <- TRUE
[10:27:22.684]                           break
[10:27:22.684]                         }
[10:27:22.684]                       }
[10:27:22.684]                     }
[10:27:22.684]                     invisible(muffled)
[10:27:22.684]                   }
[10:27:22.684]                   muffleCondition(cond)
[10:27:22.684]                 })
[10:27:22.684]             }))
[10:27:22.684]             future::FutureResult(value = ...future.value$value, 
[10:27:22.684]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:22.684]                   ...future.rng), globalenv = if (FALSE) 
[10:27:22.684]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:22.684]                     ...future.globalenv.names))
[10:27:22.684]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:22.684]         }, condition = base::local({
[10:27:22.684]             c <- base::c
[10:27:22.684]             inherits <- base::inherits
[10:27:22.684]             invokeRestart <- base::invokeRestart
[10:27:22.684]             length <- base::length
[10:27:22.684]             list <- base::list
[10:27:22.684]             seq.int <- base::seq.int
[10:27:22.684]             signalCondition <- base::signalCondition
[10:27:22.684]             sys.calls <- base::sys.calls
[10:27:22.684]             `[[` <- base::`[[`
[10:27:22.684]             `+` <- base::`+`
[10:27:22.684]             `<<-` <- base::`<<-`
[10:27:22.684]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:22.684]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:22.684]                   3L)]
[10:27:22.684]             }
[10:27:22.684]             function(cond) {
[10:27:22.684]                 is_error <- inherits(cond, "error")
[10:27:22.684]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:22.684]                   NULL)
[10:27:22.684]                 if (is_error) {
[10:27:22.684]                   sessionInformation <- function() {
[10:27:22.684]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:22.684]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:22.684]                       search = base::search(), system = base::Sys.info())
[10:27:22.684]                   }
[10:27:22.684]                   ...future.conditions[[length(...future.conditions) + 
[10:27:22.684]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:22.684]                     cond$call), session = sessionInformation(), 
[10:27:22.684]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:22.684]                   signalCondition(cond)
[10:27:22.684]                 }
[10:27:22.684]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:22.684]                 "immediateCondition"))) {
[10:27:22.684]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:22.684]                   ...future.conditions[[length(...future.conditions) + 
[10:27:22.684]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:22.684]                   if (TRUE && !signal) {
[10:27:22.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.684]                     {
[10:27:22.684]                       inherits <- base::inherits
[10:27:22.684]                       invokeRestart <- base::invokeRestart
[10:27:22.684]                       is.null <- base::is.null
[10:27:22.684]                       muffled <- FALSE
[10:27:22.684]                       if (inherits(cond, "message")) {
[10:27:22.684]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:22.684]                         if (muffled) 
[10:27:22.684]                           invokeRestart("muffleMessage")
[10:27:22.684]                       }
[10:27:22.684]                       else if (inherits(cond, "warning")) {
[10:27:22.684]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:22.684]                         if (muffled) 
[10:27:22.684]                           invokeRestart("muffleWarning")
[10:27:22.684]                       }
[10:27:22.684]                       else if (inherits(cond, "condition")) {
[10:27:22.684]                         if (!is.null(pattern)) {
[10:27:22.684]                           computeRestarts <- base::computeRestarts
[10:27:22.684]                           grepl <- base::grepl
[10:27:22.684]                           restarts <- computeRestarts(cond)
[10:27:22.684]                           for (restart in restarts) {
[10:27:22.684]                             name <- restart$name
[10:27:22.684]                             if (is.null(name)) 
[10:27:22.684]                               next
[10:27:22.684]                             if (!grepl(pattern, name)) 
[10:27:22.684]                               next
[10:27:22.684]                             invokeRestart(restart)
[10:27:22.684]                             muffled <- TRUE
[10:27:22.684]                             break
[10:27:22.684]                           }
[10:27:22.684]                         }
[10:27:22.684]                       }
[10:27:22.684]                       invisible(muffled)
[10:27:22.684]                     }
[10:27:22.684]                     muffleCondition(cond, pattern = "^muffle")
[10:27:22.684]                   }
[10:27:22.684]                 }
[10:27:22.684]                 else {
[10:27:22.684]                   if (TRUE) {
[10:27:22.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.684]                     {
[10:27:22.684]                       inherits <- base::inherits
[10:27:22.684]                       invokeRestart <- base::invokeRestart
[10:27:22.684]                       is.null <- base::is.null
[10:27:22.684]                       muffled <- FALSE
[10:27:22.684]                       if (inherits(cond, "message")) {
[10:27:22.684]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:22.684]                         if (muffled) 
[10:27:22.684]                           invokeRestart("muffleMessage")
[10:27:22.684]                       }
[10:27:22.684]                       else if (inherits(cond, "warning")) {
[10:27:22.684]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:22.684]                         if (muffled) 
[10:27:22.684]                           invokeRestart("muffleWarning")
[10:27:22.684]                       }
[10:27:22.684]                       else if (inherits(cond, "condition")) {
[10:27:22.684]                         if (!is.null(pattern)) {
[10:27:22.684]                           computeRestarts <- base::computeRestarts
[10:27:22.684]                           grepl <- base::grepl
[10:27:22.684]                           restarts <- computeRestarts(cond)
[10:27:22.684]                           for (restart in restarts) {
[10:27:22.684]                             name <- restart$name
[10:27:22.684]                             if (is.null(name)) 
[10:27:22.684]                               next
[10:27:22.684]                             if (!grepl(pattern, name)) 
[10:27:22.684]                               next
[10:27:22.684]                             invokeRestart(restart)
[10:27:22.684]                             muffled <- TRUE
[10:27:22.684]                             break
[10:27:22.684]                           }
[10:27:22.684]                         }
[10:27:22.684]                       }
[10:27:22.684]                       invisible(muffled)
[10:27:22.684]                     }
[10:27:22.684]                     muffleCondition(cond, pattern = "^muffle")
[10:27:22.684]                   }
[10:27:22.684]                 }
[10:27:22.684]             }
[10:27:22.684]         }))
[10:27:22.684]     }, error = function(ex) {
[10:27:22.684]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:22.684]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:22.684]                 ...future.rng), started = ...future.startTime, 
[10:27:22.684]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:22.684]             version = "1.8"), class = "FutureResult")
[10:27:22.684]     }, finally = {
[10:27:22.684]         if (!identical(...future.workdir, getwd())) 
[10:27:22.684]             setwd(...future.workdir)
[10:27:22.684]         {
[10:27:22.684]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:22.684]                 ...future.oldOptions$nwarnings <- NULL
[10:27:22.684]             }
[10:27:22.684]             base::options(...future.oldOptions)
[10:27:22.684]             if (.Platform$OS.type == "windows") {
[10:27:22.684]                 old_names <- names(...future.oldEnvVars)
[10:27:22.684]                 envs <- base::Sys.getenv()
[10:27:22.684]                 names <- names(envs)
[10:27:22.684]                 common <- intersect(names, old_names)
[10:27:22.684]                 added <- setdiff(names, old_names)
[10:27:22.684]                 removed <- setdiff(old_names, names)
[10:27:22.684]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:22.684]                   envs[common]]
[10:27:22.684]                 NAMES <- toupper(changed)
[10:27:22.684]                 args <- list()
[10:27:22.684]                 for (kk in seq_along(NAMES)) {
[10:27:22.684]                   name <- changed[[kk]]
[10:27:22.684]                   NAME <- NAMES[[kk]]
[10:27:22.684]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.684]                     next
[10:27:22.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:22.684]                 }
[10:27:22.684]                 NAMES <- toupper(added)
[10:27:22.684]                 for (kk in seq_along(NAMES)) {
[10:27:22.684]                   name <- added[[kk]]
[10:27:22.684]                   NAME <- NAMES[[kk]]
[10:27:22.684]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.684]                     next
[10:27:22.684]                   args[[name]] <- ""
[10:27:22.684]                 }
[10:27:22.684]                 NAMES <- toupper(removed)
[10:27:22.684]                 for (kk in seq_along(NAMES)) {
[10:27:22.684]                   name <- removed[[kk]]
[10:27:22.684]                   NAME <- NAMES[[kk]]
[10:27:22.684]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.684]                     next
[10:27:22.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:22.684]                 }
[10:27:22.684]                 if (length(args) > 0) 
[10:27:22.684]                   base::do.call(base::Sys.setenv, args = args)
[10:27:22.684]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:22.684]             }
[10:27:22.684]             else {
[10:27:22.684]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:22.684]             }
[10:27:22.684]             {
[10:27:22.684]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:22.684]                   0L) {
[10:27:22.684]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:22.684]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:22.684]                   base::options(opts)
[10:27:22.684]                 }
[10:27:22.684]                 {
[10:27:22.684]                   {
[10:27:22.684]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:22.684]                     NULL
[10:27:22.684]                   }
[10:27:22.684]                   options(future.plan = NULL)
[10:27:22.684]                   if (is.na(NA_character_)) 
[10:27:22.684]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:22.684]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:22.684]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:22.684]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:22.684]                     envir = parent.frame()) 
[10:27:22.684]                   {
[10:27:22.684]                     if (is.function(workers)) 
[10:27:22.684]                       workers <- workers()
[10:27:22.684]                     workers <- structure(as.integer(workers), 
[10:27:22.684]                       class = class(workers))
[10:27:22.684]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:22.684]                       workers >= 1)
[10:27:22.684]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:22.684]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:22.684]                     }
[10:27:22.684]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:22.684]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:22.684]                       envir = envir)
[10:27:22.684]                     if (!future$lazy) 
[10:27:22.684]                       future <- run(future)
[10:27:22.684]                     invisible(future)
[10:27:22.684]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:22.684]                 }
[10:27:22.684]             }
[10:27:22.684]         }
[10:27:22.684]     })
[10:27:22.684]     if (TRUE) {
[10:27:22.684]         base::sink(type = "output", split = FALSE)
[10:27:22.684]         if (TRUE) {
[10:27:22.684]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:22.684]         }
[10:27:22.684]         else {
[10:27:22.684]             ...future.result["stdout"] <- base::list(NULL)
[10:27:22.684]         }
[10:27:22.684]         base::close(...future.stdout)
[10:27:22.684]         ...future.stdout <- NULL
[10:27:22.684]     }
[10:27:22.684]     ...future.result$conditions <- ...future.conditions
[10:27:22.684]     ...future.result$finished <- base::Sys.time()
[10:27:22.684]     ...future.result
[10:27:22.684] }
[10:27:22.688] MultisessionFuture started
[10:27:22.688] - Launch lazy future ... done
[10:27:22.688] run() for ‘MultisessionFuture’ ... done
[10:27:22.688] getGlobalsAndPackages() ...
[10:27:22.688] Searching for globals...
[10:27:22.689] - globals found: [1] ‘{’
[10:27:22.689] Searching for globals ... DONE
[10:27:22.689] Resolving globals: FALSE
[10:27:22.690] 
[10:27:22.690] 
[10:27:22.690] getGlobalsAndPackages() ... DONE
[10:27:22.690] run() for ‘Future’ ...
[10:27:22.690] - state: ‘created’
[10:27:22.690] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:22.705] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:22.705] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:22.705]   - Field: ‘node’
[10:27:22.705]   - Field: ‘label’
[10:27:22.705]   - Field: ‘local’
[10:27:22.705]   - Field: ‘owner’
[10:27:22.705]   - Field: ‘envir’
[10:27:22.705]   - Field: ‘workers’
[10:27:22.706]   - Field: ‘packages’
[10:27:22.706]   - Field: ‘gc’
[10:27:22.706]   - Field: ‘conditions’
[10:27:22.706]   - Field: ‘persistent’
[10:27:22.706]   - Field: ‘expr’
[10:27:22.706]   - Field: ‘uuid’
[10:27:22.706]   - Field: ‘seed’
[10:27:22.706]   - Field: ‘version’
[10:27:22.706]   - Field: ‘result’
[10:27:22.706]   - Field: ‘asynchronous’
[10:27:22.707]   - Field: ‘calls’
[10:27:22.707]   - Field: ‘globals’
[10:27:22.707]   - Field: ‘stdout’
[10:27:22.707]   - Field: ‘earlySignal’
[10:27:22.707]   - Field: ‘lazy’
[10:27:22.707]   - Field: ‘state’
[10:27:22.707] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:22.707] - Launch lazy future ...
[10:27:22.707] Packages needed by the future expression (n = 0): <none>
[10:27:22.708] Packages needed by future strategies (n = 0): <none>
[10:27:22.708] {
[10:27:22.708]     {
[10:27:22.708]         {
[10:27:22.708]             ...future.startTime <- base::Sys.time()
[10:27:22.708]             {
[10:27:22.708]                 {
[10:27:22.708]                   {
[10:27:22.708]                     {
[10:27:22.708]                       base::local({
[10:27:22.708]                         has_future <- base::requireNamespace("future", 
[10:27:22.708]                           quietly = TRUE)
[10:27:22.708]                         if (has_future) {
[10:27:22.708]                           ns <- base::getNamespace("future")
[10:27:22.708]                           version <- ns[[".package"]][["version"]]
[10:27:22.708]                           if (is.null(version)) 
[10:27:22.708]                             version <- utils::packageVersion("future")
[10:27:22.708]                         }
[10:27:22.708]                         else {
[10:27:22.708]                           version <- NULL
[10:27:22.708]                         }
[10:27:22.708]                         if (!has_future || version < "1.8.0") {
[10:27:22.708]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:22.708]                             "", base::R.version$version.string), 
[10:27:22.708]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:22.708]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:22.708]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:22.708]                               "release", "version")], collapse = " "), 
[10:27:22.708]                             hostname = base::Sys.info()[["nodename"]])
[10:27:22.708]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:22.708]                             info)
[10:27:22.708]                           info <- base::paste(info, collapse = "; ")
[10:27:22.708]                           if (!has_future) {
[10:27:22.708]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:22.708]                               info)
[10:27:22.708]                           }
[10:27:22.708]                           else {
[10:27:22.708]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:22.708]                               info, version)
[10:27:22.708]                           }
[10:27:22.708]                           base::stop(msg)
[10:27:22.708]                         }
[10:27:22.708]                       })
[10:27:22.708]                     }
[10:27:22.708]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:22.708]                     base::options(mc.cores = 1L)
[10:27:22.708]                   }
[10:27:22.708]                   options(future.plan = NULL)
[10:27:22.708]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:22.708]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:22.708]                 }
[10:27:22.708]                 ...future.workdir <- getwd()
[10:27:22.708]             }
[10:27:22.708]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:22.708]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:22.708]         }
[10:27:22.708]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:22.708]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:22.708]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:22.708]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:22.708]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:22.708]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:22.708]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:22.708]             base::names(...future.oldOptions))
[10:27:22.708]     }
[10:27:22.708]     if (FALSE) {
[10:27:22.708]     }
[10:27:22.708]     else {
[10:27:22.708]         if (TRUE) {
[10:27:22.708]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:22.708]                 open = "w")
[10:27:22.708]         }
[10:27:22.708]         else {
[10:27:22.708]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:22.708]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:22.708]         }
[10:27:22.708]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:22.708]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:22.708]             base::sink(type = "output", split = FALSE)
[10:27:22.708]             base::close(...future.stdout)
[10:27:22.708]         }, add = TRUE)
[10:27:22.708]     }
[10:27:22.708]     ...future.frame <- base::sys.nframe()
[10:27:22.708]     ...future.conditions <- base::list()
[10:27:22.708]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:22.708]     if (FALSE) {
[10:27:22.708]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:22.708]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:22.708]     }
[10:27:22.708]     ...future.result <- base::tryCatch({
[10:27:22.708]         base::withCallingHandlers({
[10:27:22.708]             ...future.value <- base::withVisible(base::local({
[10:27:22.708]                 ...future.makeSendCondition <- base::local({
[10:27:22.708]                   sendCondition <- NULL
[10:27:22.708]                   function(frame = 1L) {
[10:27:22.708]                     if (is.function(sendCondition)) 
[10:27:22.708]                       return(sendCondition)
[10:27:22.708]                     ns <- getNamespace("parallel")
[10:27:22.708]                     if (exists("sendData", mode = "function", 
[10:27:22.708]                       envir = ns)) {
[10:27:22.708]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:22.708]                         envir = ns)
[10:27:22.708]                       envir <- sys.frame(frame)
[10:27:22.708]                       master <- NULL
[10:27:22.708]                       while (!identical(envir, .GlobalEnv) && 
[10:27:22.708]                         !identical(envir, emptyenv())) {
[10:27:22.708]                         if (exists("master", mode = "list", envir = envir, 
[10:27:22.708]                           inherits = FALSE)) {
[10:27:22.708]                           master <- get("master", mode = "list", 
[10:27:22.708]                             envir = envir, inherits = FALSE)
[10:27:22.708]                           if (inherits(master, c("SOCKnode", 
[10:27:22.708]                             "SOCK0node"))) {
[10:27:22.708]                             sendCondition <<- function(cond) {
[10:27:22.708]                               data <- list(type = "VALUE", value = cond, 
[10:27:22.708]                                 success = TRUE)
[10:27:22.708]                               parallel_sendData(master, data)
[10:27:22.708]                             }
[10:27:22.708]                             return(sendCondition)
[10:27:22.708]                           }
[10:27:22.708]                         }
[10:27:22.708]                         frame <- frame + 1L
[10:27:22.708]                         envir <- sys.frame(frame)
[10:27:22.708]                       }
[10:27:22.708]                     }
[10:27:22.708]                     sendCondition <<- function(cond) NULL
[10:27:22.708]                   }
[10:27:22.708]                 })
[10:27:22.708]                 withCallingHandlers({
[10:27:22.708]                   {
[10:27:22.708]                     2
[10:27:22.708]                   }
[10:27:22.708]                 }, immediateCondition = function(cond) {
[10:27:22.708]                   sendCondition <- ...future.makeSendCondition()
[10:27:22.708]                   sendCondition(cond)
[10:27:22.708]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.708]                   {
[10:27:22.708]                     inherits <- base::inherits
[10:27:22.708]                     invokeRestart <- base::invokeRestart
[10:27:22.708]                     is.null <- base::is.null
[10:27:22.708]                     muffled <- FALSE
[10:27:22.708]                     if (inherits(cond, "message")) {
[10:27:22.708]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:22.708]                       if (muffled) 
[10:27:22.708]                         invokeRestart("muffleMessage")
[10:27:22.708]                     }
[10:27:22.708]                     else if (inherits(cond, "warning")) {
[10:27:22.708]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:22.708]                       if (muffled) 
[10:27:22.708]                         invokeRestart("muffleWarning")
[10:27:22.708]                     }
[10:27:22.708]                     else if (inherits(cond, "condition")) {
[10:27:22.708]                       if (!is.null(pattern)) {
[10:27:22.708]                         computeRestarts <- base::computeRestarts
[10:27:22.708]                         grepl <- base::grepl
[10:27:22.708]                         restarts <- computeRestarts(cond)
[10:27:22.708]                         for (restart in restarts) {
[10:27:22.708]                           name <- restart$name
[10:27:22.708]                           if (is.null(name)) 
[10:27:22.708]                             next
[10:27:22.708]                           if (!grepl(pattern, name)) 
[10:27:22.708]                             next
[10:27:22.708]                           invokeRestart(restart)
[10:27:22.708]                           muffled <- TRUE
[10:27:22.708]                           break
[10:27:22.708]                         }
[10:27:22.708]                       }
[10:27:22.708]                     }
[10:27:22.708]                     invisible(muffled)
[10:27:22.708]                   }
[10:27:22.708]                   muffleCondition(cond)
[10:27:22.708]                 })
[10:27:22.708]             }))
[10:27:22.708]             future::FutureResult(value = ...future.value$value, 
[10:27:22.708]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:22.708]                   ...future.rng), globalenv = if (FALSE) 
[10:27:22.708]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:22.708]                     ...future.globalenv.names))
[10:27:22.708]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:22.708]         }, condition = base::local({
[10:27:22.708]             c <- base::c
[10:27:22.708]             inherits <- base::inherits
[10:27:22.708]             invokeRestart <- base::invokeRestart
[10:27:22.708]             length <- base::length
[10:27:22.708]             list <- base::list
[10:27:22.708]             seq.int <- base::seq.int
[10:27:22.708]             signalCondition <- base::signalCondition
[10:27:22.708]             sys.calls <- base::sys.calls
[10:27:22.708]             `[[` <- base::`[[`
[10:27:22.708]             `+` <- base::`+`
[10:27:22.708]             `<<-` <- base::`<<-`
[10:27:22.708]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:22.708]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:22.708]                   3L)]
[10:27:22.708]             }
[10:27:22.708]             function(cond) {
[10:27:22.708]                 is_error <- inherits(cond, "error")
[10:27:22.708]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:22.708]                   NULL)
[10:27:22.708]                 if (is_error) {
[10:27:22.708]                   sessionInformation <- function() {
[10:27:22.708]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:22.708]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:22.708]                       search = base::search(), system = base::Sys.info())
[10:27:22.708]                   }
[10:27:22.708]                   ...future.conditions[[length(...future.conditions) + 
[10:27:22.708]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:22.708]                     cond$call), session = sessionInformation(), 
[10:27:22.708]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:22.708]                   signalCondition(cond)
[10:27:22.708]                 }
[10:27:22.708]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:22.708]                 "immediateCondition"))) {
[10:27:22.708]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:22.708]                   ...future.conditions[[length(...future.conditions) + 
[10:27:22.708]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:22.708]                   if (TRUE && !signal) {
[10:27:22.708]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.708]                     {
[10:27:22.708]                       inherits <- base::inherits
[10:27:22.708]                       invokeRestart <- base::invokeRestart
[10:27:22.708]                       is.null <- base::is.null
[10:27:22.708]                       muffled <- FALSE
[10:27:22.708]                       if (inherits(cond, "message")) {
[10:27:22.708]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:22.708]                         if (muffled) 
[10:27:22.708]                           invokeRestart("muffleMessage")
[10:27:22.708]                       }
[10:27:22.708]                       else if (inherits(cond, "warning")) {
[10:27:22.708]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:22.708]                         if (muffled) 
[10:27:22.708]                           invokeRestart("muffleWarning")
[10:27:22.708]                       }
[10:27:22.708]                       else if (inherits(cond, "condition")) {
[10:27:22.708]                         if (!is.null(pattern)) {
[10:27:22.708]                           computeRestarts <- base::computeRestarts
[10:27:22.708]                           grepl <- base::grepl
[10:27:22.708]                           restarts <- computeRestarts(cond)
[10:27:22.708]                           for (restart in restarts) {
[10:27:22.708]                             name <- restart$name
[10:27:22.708]                             if (is.null(name)) 
[10:27:22.708]                               next
[10:27:22.708]                             if (!grepl(pattern, name)) 
[10:27:22.708]                               next
[10:27:22.708]                             invokeRestart(restart)
[10:27:22.708]                             muffled <- TRUE
[10:27:22.708]                             break
[10:27:22.708]                           }
[10:27:22.708]                         }
[10:27:22.708]                       }
[10:27:22.708]                       invisible(muffled)
[10:27:22.708]                     }
[10:27:22.708]                     muffleCondition(cond, pattern = "^muffle")
[10:27:22.708]                   }
[10:27:22.708]                 }
[10:27:22.708]                 else {
[10:27:22.708]                   if (TRUE) {
[10:27:22.708]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.708]                     {
[10:27:22.708]                       inherits <- base::inherits
[10:27:22.708]                       invokeRestart <- base::invokeRestart
[10:27:22.708]                       is.null <- base::is.null
[10:27:22.708]                       muffled <- FALSE
[10:27:22.708]                       if (inherits(cond, "message")) {
[10:27:22.708]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:22.708]                         if (muffled) 
[10:27:22.708]                           invokeRestart("muffleMessage")
[10:27:22.708]                       }
[10:27:22.708]                       else if (inherits(cond, "warning")) {
[10:27:22.708]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:22.708]                         if (muffled) 
[10:27:22.708]                           invokeRestart("muffleWarning")
[10:27:22.708]                       }
[10:27:22.708]                       else if (inherits(cond, "condition")) {
[10:27:22.708]                         if (!is.null(pattern)) {
[10:27:22.708]                           computeRestarts <- base::computeRestarts
[10:27:22.708]                           grepl <- base::grepl
[10:27:22.708]                           restarts <- computeRestarts(cond)
[10:27:22.708]                           for (restart in restarts) {
[10:27:22.708]                             name <- restart$name
[10:27:22.708]                             if (is.null(name)) 
[10:27:22.708]                               next
[10:27:22.708]                             if (!grepl(pattern, name)) 
[10:27:22.708]                               next
[10:27:22.708]                             invokeRestart(restart)
[10:27:22.708]                             muffled <- TRUE
[10:27:22.708]                             break
[10:27:22.708]                           }
[10:27:22.708]                         }
[10:27:22.708]                       }
[10:27:22.708]                       invisible(muffled)
[10:27:22.708]                     }
[10:27:22.708]                     muffleCondition(cond, pattern = "^muffle")
[10:27:22.708]                   }
[10:27:22.708]                 }
[10:27:22.708]             }
[10:27:22.708]         }))
[10:27:22.708]     }, error = function(ex) {
[10:27:22.708]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:22.708]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:22.708]                 ...future.rng), started = ...future.startTime, 
[10:27:22.708]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:22.708]             version = "1.8"), class = "FutureResult")
[10:27:22.708]     }, finally = {
[10:27:22.708]         if (!identical(...future.workdir, getwd())) 
[10:27:22.708]             setwd(...future.workdir)
[10:27:22.708]         {
[10:27:22.708]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:22.708]                 ...future.oldOptions$nwarnings <- NULL
[10:27:22.708]             }
[10:27:22.708]             base::options(...future.oldOptions)
[10:27:22.708]             if (.Platform$OS.type == "windows") {
[10:27:22.708]                 old_names <- names(...future.oldEnvVars)
[10:27:22.708]                 envs <- base::Sys.getenv()
[10:27:22.708]                 names <- names(envs)
[10:27:22.708]                 common <- intersect(names, old_names)
[10:27:22.708]                 added <- setdiff(names, old_names)
[10:27:22.708]                 removed <- setdiff(old_names, names)
[10:27:22.708]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:22.708]                   envs[common]]
[10:27:22.708]                 NAMES <- toupper(changed)
[10:27:22.708]                 args <- list()
[10:27:22.708]                 for (kk in seq_along(NAMES)) {
[10:27:22.708]                   name <- changed[[kk]]
[10:27:22.708]                   NAME <- NAMES[[kk]]
[10:27:22.708]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.708]                     next
[10:27:22.708]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:22.708]                 }
[10:27:22.708]                 NAMES <- toupper(added)
[10:27:22.708]                 for (kk in seq_along(NAMES)) {
[10:27:22.708]                   name <- added[[kk]]
[10:27:22.708]                   NAME <- NAMES[[kk]]
[10:27:22.708]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.708]                     next
[10:27:22.708]                   args[[name]] <- ""
[10:27:22.708]                 }
[10:27:22.708]                 NAMES <- toupper(removed)
[10:27:22.708]                 for (kk in seq_along(NAMES)) {
[10:27:22.708]                   name <- removed[[kk]]
[10:27:22.708]                   NAME <- NAMES[[kk]]
[10:27:22.708]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.708]                     next
[10:27:22.708]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:22.708]                 }
[10:27:22.708]                 if (length(args) > 0) 
[10:27:22.708]                   base::do.call(base::Sys.setenv, args = args)
[10:27:22.708]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:22.708]             }
[10:27:22.708]             else {
[10:27:22.708]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:22.708]             }
[10:27:22.708]             {
[10:27:22.708]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:22.708]                   0L) {
[10:27:22.708]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:22.708]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:22.708]                   base::options(opts)
[10:27:22.708]                 }
[10:27:22.708]                 {
[10:27:22.708]                   {
[10:27:22.708]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:22.708]                     NULL
[10:27:22.708]                   }
[10:27:22.708]                   options(future.plan = NULL)
[10:27:22.708]                   if (is.na(NA_character_)) 
[10:27:22.708]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:22.708]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:22.708]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:22.708]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:22.708]                     envir = parent.frame()) 
[10:27:22.708]                   {
[10:27:22.708]                     if (is.function(workers)) 
[10:27:22.708]                       workers <- workers()
[10:27:22.708]                     workers <- structure(as.integer(workers), 
[10:27:22.708]                       class = class(workers))
[10:27:22.708]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:22.708]                       workers >= 1)
[10:27:22.708]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:22.708]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:22.708]                     }
[10:27:22.708]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:22.708]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:22.708]                       envir = envir)
[10:27:22.708]                     if (!future$lazy) 
[10:27:22.708]                       future <- run(future)
[10:27:22.708]                     invisible(future)
[10:27:22.708]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:22.708]                 }
[10:27:22.708]             }
[10:27:22.708]         }
[10:27:22.708]     })
[10:27:22.708]     if (TRUE) {
[10:27:22.708]         base::sink(type = "output", split = FALSE)
[10:27:22.708]         if (TRUE) {
[10:27:22.708]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:22.708]         }
[10:27:22.708]         else {
[10:27:22.708]             ...future.result["stdout"] <- base::list(NULL)
[10:27:22.708]         }
[10:27:22.708]         base::close(...future.stdout)
[10:27:22.708]         ...future.stdout <- NULL
[10:27:22.708]     }
[10:27:22.708]     ...future.result$conditions <- ...future.conditions
[10:27:22.708]     ...future.result$finished <- base::Sys.time()
[10:27:22.708]     ...future.result
[10:27:22.708] }
[10:27:22.711] MultisessionFuture started
[10:27:22.712] - Launch lazy future ... done
[10:27:22.712] run() for ‘MultisessionFuture’ ... done
[10:27:22.712] resolve() on list environment ...
[10:27:22.712]  recursive: 0
[10:27:22.713]  length: 3
[10:27:22.713]  elements: ‘a’, ‘b’, ‘c’
[10:27:22.734]  length: 2 (resolved future 3)
[10:27:22.745] receiveMessageFromWorker() for ClusterFuture ...
[10:27:22.745] - Validating connection of MultisessionFuture
[10:27:22.746] - received message: FutureResult
[10:27:22.746] - Received FutureResult
[10:27:22.746] - Erased future from FutureRegistry
[10:27:22.746] result() for ClusterFuture ...
[10:27:22.746] - result already collected: FutureResult
[10:27:22.746] result() for ClusterFuture ... done
[10:27:22.746] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:22.746] Future #1
[10:27:22.747]  length: 1 (resolved future 1)
[10:27:22.768] receiveMessageFromWorker() for ClusterFuture ...
[10:27:22.768] - Validating connection of MultisessionFuture
[10:27:22.768] - received message: FutureResult
[10:27:22.768] - Received FutureResult
[10:27:22.768] - Erased future from FutureRegistry
[10:27:22.769] result() for ClusterFuture ...
[10:27:22.769] - result already collected: FutureResult
[10:27:22.769] result() for ClusterFuture ... done
[10:27:22.769] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:22.769] Future #2
[10:27:22.769]  length: 0 (resolved future 2)
[10:27:22.769] resolve() on list environment ... DONE
[10:27:22.770] getGlobalsAndPackages() ...
[10:27:22.770] Searching for globals...
[10:27:22.771] - globals found: [1] ‘{’
[10:27:22.771] Searching for globals ... DONE
[10:27:22.771] Resolving globals: FALSE
[10:27:22.771] 
[10:27:22.771] 
[10:27:22.771] getGlobalsAndPackages() ... DONE
[10:27:22.772] run() for ‘Future’ ...
[10:27:22.772] - state: ‘created’
[10:27:22.772] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:22.786] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:22.787] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:22.787]   - Field: ‘node’
[10:27:22.787]   - Field: ‘label’
[10:27:22.787]   - Field: ‘local’
[10:27:22.787]   - Field: ‘owner’
[10:27:22.787]   - Field: ‘envir’
[10:27:22.787]   - Field: ‘workers’
[10:27:22.787]   - Field: ‘packages’
[10:27:22.787]   - Field: ‘gc’
[10:27:22.787]   - Field: ‘conditions’
[10:27:22.788]   - Field: ‘persistent’
[10:27:22.788]   - Field: ‘expr’
[10:27:22.788]   - Field: ‘uuid’
[10:27:22.788]   - Field: ‘seed’
[10:27:22.788]   - Field: ‘version’
[10:27:22.788]   - Field: ‘result’
[10:27:22.788]   - Field: ‘asynchronous’
[10:27:22.788]   - Field: ‘calls’
[10:27:22.788]   - Field: ‘globals’
[10:27:22.788]   - Field: ‘stdout’
[10:27:22.789]   - Field: ‘earlySignal’
[10:27:22.789]   - Field: ‘lazy’
[10:27:22.789]   - Field: ‘state’
[10:27:22.789] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:22.789] - Launch lazy future ...
[10:27:22.789] Packages needed by the future expression (n = 0): <none>
[10:27:22.789] Packages needed by future strategies (n = 0): <none>
[10:27:22.790] {
[10:27:22.790]     {
[10:27:22.790]         {
[10:27:22.790]             ...future.startTime <- base::Sys.time()
[10:27:22.790]             {
[10:27:22.790]                 {
[10:27:22.790]                   {
[10:27:22.790]                     {
[10:27:22.790]                       base::local({
[10:27:22.790]                         has_future <- base::requireNamespace("future", 
[10:27:22.790]                           quietly = TRUE)
[10:27:22.790]                         if (has_future) {
[10:27:22.790]                           ns <- base::getNamespace("future")
[10:27:22.790]                           version <- ns[[".package"]][["version"]]
[10:27:22.790]                           if (is.null(version)) 
[10:27:22.790]                             version <- utils::packageVersion("future")
[10:27:22.790]                         }
[10:27:22.790]                         else {
[10:27:22.790]                           version <- NULL
[10:27:22.790]                         }
[10:27:22.790]                         if (!has_future || version < "1.8.0") {
[10:27:22.790]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:22.790]                             "", base::R.version$version.string), 
[10:27:22.790]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:22.790]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:22.790]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:22.790]                               "release", "version")], collapse = " "), 
[10:27:22.790]                             hostname = base::Sys.info()[["nodename"]])
[10:27:22.790]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:22.790]                             info)
[10:27:22.790]                           info <- base::paste(info, collapse = "; ")
[10:27:22.790]                           if (!has_future) {
[10:27:22.790]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:22.790]                               info)
[10:27:22.790]                           }
[10:27:22.790]                           else {
[10:27:22.790]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:22.790]                               info, version)
[10:27:22.790]                           }
[10:27:22.790]                           base::stop(msg)
[10:27:22.790]                         }
[10:27:22.790]                       })
[10:27:22.790]                     }
[10:27:22.790]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:22.790]                     base::options(mc.cores = 1L)
[10:27:22.790]                   }
[10:27:22.790]                   options(future.plan = NULL)
[10:27:22.790]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:22.790]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:22.790]                 }
[10:27:22.790]                 ...future.workdir <- getwd()
[10:27:22.790]             }
[10:27:22.790]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:22.790]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:22.790]         }
[10:27:22.790]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:22.790]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:22.790]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:22.790]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:22.790]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:22.790]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:22.790]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:22.790]             base::names(...future.oldOptions))
[10:27:22.790]     }
[10:27:22.790]     if (FALSE) {
[10:27:22.790]     }
[10:27:22.790]     else {
[10:27:22.790]         if (TRUE) {
[10:27:22.790]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:22.790]                 open = "w")
[10:27:22.790]         }
[10:27:22.790]         else {
[10:27:22.790]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:22.790]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:22.790]         }
[10:27:22.790]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:22.790]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:22.790]             base::sink(type = "output", split = FALSE)
[10:27:22.790]             base::close(...future.stdout)
[10:27:22.790]         }, add = TRUE)
[10:27:22.790]     }
[10:27:22.790]     ...future.frame <- base::sys.nframe()
[10:27:22.790]     ...future.conditions <- base::list()
[10:27:22.790]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:22.790]     if (FALSE) {
[10:27:22.790]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:22.790]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:22.790]     }
[10:27:22.790]     ...future.result <- base::tryCatch({
[10:27:22.790]         base::withCallingHandlers({
[10:27:22.790]             ...future.value <- base::withVisible(base::local({
[10:27:22.790]                 ...future.makeSendCondition <- base::local({
[10:27:22.790]                   sendCondition <- NULL
[10:27:22.790]                   function(frame = 1L) {
[10:27:22.790]                     if (is.function(sendCondition)) 
[10:27:22.790]                       return(sendCondition)
[10:27:22.790]                     ns <- getNamespace("parallel")
[10:27:22.790]                     if (exists("sendData", mode = "function", 
[10:27:22.790]                       envir = ns)) {
[10:27:22.790]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:22.790]                         envir = ns)
[10:27:22.790]                       envir <- sys.frame(frame)
[10:27:22.790]                       master <- NULL
[10:27:22.790]                       while (!identical(envir, .GlobalEnv) && 
[10:27:22.790]                         !identical(envir, emptyenv())) {
[10:27:22.790]                         if (exists("master", mode = "list", envir = envir, 
[10:27:22.790]                           inherits = FALSE)) {
[10:27:22.790]                           master <- get("master", mode = "list", 
[10:27:22.790]                             envir = envir, inherits = FALSE)
[10:27:22.790]                           if (inherits(master, c("SOCKnode", 
[10:27:22.790]                             "SOCK0node"))) {
[10:27:22.790]                             sendCondition <<- function(cond) {
[10:27:22.790]                               data <- list(type = "VALUE", value = cond, 
[10:27:22.790]                                 success = TRUE)
[10:27:22.790]                               parallel_sendData(master, data)
[10:27:22.790]                             }
[10:27:22.790]                             return(sendCondition)
[10:27:22.790]                           }
[10:27:22.790]                         }
[10:27:22.790]                         frame <- frame + 1L
[10:27:22.790]                         envir <- sys.frame(frame)
[10:27:22.790]                       }
[10:27:22.790]                     }
[10:27:22.790]                     sendCondition <<- function(cond) NULL
[10:27:22.790]                   }
[10:27:22.790]                 })
[10:27:22.790]                 withCallingHandlers({
[10:27:22.790]                   {
[10:27:22.790]                     1
[10:27:22.790]                   }
[10:27:22.790]                 }, immediateCondition = function(cond) {
[10:27:22.790]                   sendCondition <- ...future.makeSendCondition()
[10:27:22.790]                   sendCondition(cond)
[10:27:22.790]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.790]                   {
[10:27:22.790]                     inherits <- base::inherits
[10:27:22.790]                     invokeRestart <- base::invokeRestart
[10:27:22.790]                     is.null <- base::is.null
[10:27:22.790]                     muffled <- FALSE
[10:27:22.790]                     if (inherits(cond, "message")) {
[10:27:22.790]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:22.790]                       if (muffled) 
[10:27:22.790]                         invokeRestart("muffleMessage")
[10:27:22.790]                     }
[10:27:22.790]                     else if (inherits(cond, "warning")) {
[10:27:22.790]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:22.790]                       if (muffled) 
[10:27:22.790]                         invokeRestart("muffleWarning")
[10:27:22.790]                     }
[10:27:22.790]                     else if (inherits(cond, "condition")) {
[10:27:22.790]                       if (!is.null(pattern)) {
[10:27:22.790]                         computeRestarts <- base::computeRestarts
[10:27:22.790]                         grepl <- base::grepl
[10:27:22.790]                         restarts <- computeRestarts(cond)
[10:27:22.790]                         for (restart in restarts) {
[10:27:22.790]                           name <- restart$name
[10:27:22.790]                           if (is.null(name)) 
[10:27:22.790]                             next
[10:27:22.790]                           if (!grepl(pattern, name)) 
[10:27:22.790]                             next
[10:27:22.790]                           invokeRestart(restart)
[10:27:22.790]                           muffled <- TRUE
[10:27:22.790]                           break
[10:27:22.790]                         }
[10:27:22.790]                       }
[10:27:22.790]                     }
[10:27:22.790]                     invisible(muffled)
[10:27:22.790]                   }
[10:27:22.790]                   muffleCondition(cond)
[10:27:22.790]                 })
[10:27:22.790]             }))
[10:27:22.790]             future::FutureResult(value = ...future.value$value, 
[10:27:22.790]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:22.790]                   ...future.rng), globalenv = if (FALSE) 
[10:27:22.790]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:22.790]                     ...future.globalenv.names))
[10:27:22.790]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:22.790]         }, condition = base::local({
[10:27:22.790]             c <- base::c
[10:27:22.790]             inherits <- base::inherits
[10:27:22.790]             invokeRestart <- base::invokeRestart
[10:27:22.790]             length <- base::length
[10:27:22.790]             list <- base::list
[10:27:22.790]             seq.int <- base::seq.int
[10:27:22.790]             signalCondition <- base::signalCondition
[10:27:22.790]             sys.calls <- base::sys.calls
[10:27:22.790]             `[[` <- base::`[[`
[10:27:22.790]             `+` <- base::`+`
[10:27:22.790]             `<<-` <- base::`<<-`
[10:27:22.790]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:22.790]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:22.790]                   3L)]
[10:27:22.790]             }
[10:27:22.790]             function(cond) {
[10:27:22.790]                 is_error <- inherits(cond, "error")
[10:27:22.790]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:22.790]                   NULL)
[10:27:22.790]                 if (is_error) {
[10:27:22.790]                   sessionInformation <- function() {
[10:27:22.790]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:22.790]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:22.790]                       search = base::search(), system = base::Sys.info())
[10:27:22.790]                   }
[10:27:22.790]                   ...future.conditions[[length(...future.conditions) + 
[10:27:22.790]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:22.790]                     cond$call), session = sessionInformation(), 
[10:27:22.790]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:22.790]                   signalCondition(cond)
[10:27:22.790]                 }
[10:27:22.790]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:22.790]                 "immediateCondition"))) {
[10:27:22.790]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:22.790]                   ...future.conditions[[length(...future.conditions) + 
[10:27:22.790]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:22.790]                   if (TRUE && !signal) {
[10:27:22.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.790]                     {
[10:27:22.790]                       inherits <- base::inherits
[10:27:22.790]                       invokeRestart <- base::invokeRestart
[10:27:22.790]                       is.null <- base::is.null
[10:27:22.790]                       muffled <- FALSE
[10:27:22.790]                       if (inherits(cond, "message")) {
[10:27:22.790]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:22.790]                         if (muffled) 
[10:27:22.790]                           invokeRestart("muffleMessage")
[10:27:22.790]                       }
[10:27:22.790]                       else if (inherits(cond, "warning")) {
[10:27:22.790]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:22.790]                         if (muffled) 
[10:27:22.790]                           invokeRestart("muffleWarning")
[10:27:22.790]                       }
[10:27:22.790]                       else if (inherits(cond, "condition")) {
[10:27:22.790]                         if (!is.null(pattern)) {
[10:27:22.790]                           computeRestarts <- base::computeRestarts
[10:27:22.790]                           grepl <- base::grepl
[10:27:22.790]                           restarts <- computeRestarts(cond)
[10:27:22.790]                           for (restart in restarts) {
[10:27:22.790]                             name <- restart$name
[10:27:22.790]                             if (is.null(name)) 
[10:27:22.790]                               next
[10:27:22.790]                             if (!grepl(pattern, name)) 
[10:27:22.790]                               next
[10:27:22.790]                             invokeRestart(restart)
[10:27:22.790]                             muffled <- TRUE
[10:27:22.790]                             break
[10:27:22.790]                           }
[10:27:22.790]                         }
[10:27:22.790]                       }
[10:27:22.790]                       invisible(muffled)
[10:27:22.790]                     }
[10:27:22.790]                     muffleCondition(cond, pattern = "^muffle")
[10:27:22.790]                   }
[10:27:22.790]                 }
[10:27:22.790]                 else {
[10:27:22.790]                   if (TRUE) {
[10:27:22.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.790]                     {
[10:27:22.790]                       inherits <- base::inherits
[10:27:22.790]                       invokeRestart <- base::invokeRestart
[10:27:22.790]                       is.null <- base::is.null
[10:27:22.790]                       muffled <- FALSE
[10:27:22.790]                       if (inherits(cond, "message")) {
[10:27:22.790]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:22.790]                         if (muffled) 
[10:27:22.790]                           invokeRestart("muffleMessage")
[10:27:22.790]                       }
[10:27:22.790]                       else if (inherits(cond, "warning")) {
[10:27:22.790]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:22.790]                         if (muffled) 
[10:27:22.790]                           invokeRestart("muffleWarning")
[10:27:22.790]                       }
[10:27:22.790]                       else if (inherits(cond, "condition")) {
[10:27:22.790]                         if (!is.null(pattern)) {
[10:27:22.790]                           computeRestarts <- base::computeRestarts
[10:27:22.790]                           grepl <- base::grepl
[10:27:22.790]                           restarts <- computeRestarts(cond)
[10:27:22.790]                           for (restart in restarts) {
[10:27:22.790]                             name <- restart$name
[10:27:22.790]                             if (is.null(name)) 
[10:27:22.790]                               next
[10:27:22.790]                             if (!grepl(pattern, name)) 
[10:27:22.790]                               next
[10:27:22.790]                             invokeRestart(restart)
[10:27:22.790]                             muffled <- TRUE
[10:27:22.790]                             break
[10:27:22.790]                           }
[10:27:22.790]                         }
[10:27:22.790]                       }
[10:27:22.790]                       invisible(muffled)
[10:27:22.790]                     }
[10:27:22.790]                     muffleCondition(cond, pattern = "^muffle")
[10:27:22.790]                   }
[10:27:22.790]                 }
[10:27:22.790]             }
[10:27:22.790]         }))
[10:27:22.790]     }, error = function(ex) {
[10:27:22.790]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:22.790]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:22.790]                 ...future.rng), started = ...future.startTime, 
[10:27:22.790]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:22.790]             version = "1.8"), class = "FutureResult")
[10:27:22.790]     }, finally = {
[10:27:22.790]         if (!identical(...future.workdir, getwd())) 
[10:27:22.790]             setwd(...future.workdir)
[10:27:22.790]         {
[10:27:22.790]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:22.790]                 ...future.oldOptions$nwarnings <- NULL
[10:27:22.790]             }
[10:27:22.790]             base::options(...future.oldOptions)
[10:27:22.790]             if (.Platform$OS.type == "windows") {
[10:27:22.790]                 old_names <- names(...future.oldEnvVars)
[10:27:22.790]                 envs <- base::Sys.getenv()
[10:27:22.790]                 names <- names(envs)
[10:27:22.790]                 common <- intersect(names, old_names)
[10:27:22.790]                 added <- setdiff(names, old_names)
[10:27:22.790]                 removed <- setdiff(old_names, names)
[10:27:22.790]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:22.790]                   envs[common]]
[10:27:22.790]                 NAMES <- toupper(changed)
[10:27:22.790]                 args <- list()
[10:27:22.790]                 for (kk in seq_along(NAMES)) {
[10:27:22.790]                   name <- changed[[kk]]
[10:27:22.790]                   NAME <- NAMES[[kk]]
[10:27:22.790]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.790]                     next
[10:27:22.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:22.790]                 }
[10:27:22.790]                 NAMES <- toupper(added)
[10:27:22.790]                 for (kk in seq_along(NAMES)) {
[10:27:22.790]                   name <- added[[kk]]
[10:27:22.790]                   NAME <- NAMES[[kk]]
[10:27:22.790]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.790]                     next
[10:27:22.790]                   args[[name]] <- ""
[10:27:22.790]                 }
[10:27:22.790]                 NAMES <- toupper(removed)
[10:27:22.790]                 for (kk in seq_along(NAMES)) {
[10:27:22.790]                   name <- removed[[kk]]
[10:27:22.790]                   NAME <- NAMES[[kk]]
[10:27:22.790]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.790]                     next
[10:27:22.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:22.790]                 }
[10:27:22.790]                 if (length(args) > 0) 
[10:27:22.790]                   base::do.call(base::Sys.setenv, args = args)
[10:27:22.790]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:22.790]             }
[10:27:22.790]             else {
[10:27:22.790]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:22.790]             }
[10:27:22.790]             {
[10:27:22.790]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:22.790]                   0L) {
[10:27:22.790]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:22.790]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:22.790]                   base::options(opts)
[10:27:22.790]                 }
[10:27:22.790]                 {
[10:27:22.790]                   {
[10:27:22.790]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:22.790]                     NULL
[10:27:22.790]                   }
[10:27:22.790]                   options(future.plan = NULL)
[10:27:22.790]                   if (is.na(NA_character_)) 
[10:27:22.790]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:22.790]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:22.790]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:22.790]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:22.790]                     envir = parent.frame()) 
[10:27:22.790]                   {
[10:27:22.790]                     if (is.function(workers)) 
[10:27:22.790]                       workers <- workers()
[10:27:22.790]                     workers <- structure(as.integer(workers), 
[10:27:22.790]                       class = class(workers))
[10:27:22.790]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:22.790]                       workers >= 1)
[10:27:22.790]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:22.790]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:22.790]                     }
[10:27:22.790]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:22.790]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:22.790]                       envir = envir)
[10:27:22.790]                     if (!future$lazy) 
[10:27:22.790]                       future <- run(future)
[10:27:22.790]                     invisible(future)
[10:27:22.790]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:22.790]                 }
[10:27:22.790]             }
[10:27:22.790]         }
[10:27:22.790]     })
[10:27:22.790]     if (TRUE) {
[10:27:22.790]         base::sink(type = "output", split = FALSE)
[10:27:22.790]         if (TRUE) {
[10:27:22.790]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:22.790]         }
[10:27:22.790]         else {
[10:27:22.790]             ...future.result["stdout"] <- base::list(NULL)
[10:27:22.790]         }
[10:27:22.790]         base::close(...future.stdout)
[10:27:22.790]         ...future.stdout <- NULL
[10:27:22.790]     }
[10:27:22.790]     ...future.result$conditions <- ...future.conditions
[10:27:22.790]     ...future.result$finished <- base::Sys.time()
[10:27:22.790]     ...future.result
[10:27:22.790] }
[10:27:22.793] MultisessionFuture started
[10:27:22.793] - Launch lazy future ... done
[10:27:22.793] run() for ‘MultisessionFuture’ ... done
[10:27:22.794] getGlobalsAndPackages() ...
[10:27:22.794] Searching for globals...
[10:27:22.795] - globals found: [2] ‘{’, ‘Sys.sleep’
[10:27:22.795] Searching for globals ... DONE
[10:27:22.795] Resolving globals: FALSE
[10:27:22.796] 
[10:27:22.799] 
[10:27:22.799] getGlobalsAndPackages() ... DONE
[10:27:22.800] run() for ‘Future’ ...
[10:27:22.800] - state: ‘created’
[10:27:22.800] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:22.817] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:22.817] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:22.818]   - Field: ‘node’
[10:27:22.818]   - Field: ‘label’
[10:27:22.818]   - Field: ‘local’
[10:27:22.818]   - Field: ‘owner’
[10:27:22.818]   - Field: ‘envir’
[10:27:22.818]   - Field: ‘workers’
[10:27:22.818]   - Field: ‘packages’
[10:27:22.818]   - Field: ‘gc’
[10:27:22.819]   - Field: ‘conditions’
[10:27:22.819]   - Field: ‘persistent’
[10:27:22.819]   - Field: ‘expr’
[10:27:22.819]   - Field: ‘uuid’
[10:27:22.819]   - Field: ‘seed’
[10:27:22.819]   - Field: ‘version’
[10:27:22.819]   - Field: ‘result’
[10:27:22.819]   - Field: ‘asynchronous’
[10:27:22.819]   - Field: ‘calls’
[10:27:22.820]   - Field: ‘globals’
[10:27:22.820]   - Field: ‘stdout’
[10:27:22.820]   - Field: ‘earlySignal’
[10:27:22.820]   - Field: ‘lazy’
[10:27:22.820]   - Field: ‘state’
[10:27:22.820] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:22.820] - Launch lazy future ...
[10:27:22.821] Packages needed by the future expression (n = 0): <none>
[10:27:22.821] Packages needed by future strategies (n = 0): <none>
[10:27:22.821] {
[10:27:22.821]     {
[10:27:22.821]         {
[10:27:22.821]             ...future.startTime <- base::Sys.time()
[10:27:22.821]             {
[10:27:22.821]                 {
[10:27:22.821]                   {
[10:27:22.821]                     {
[10:27:22.821]                       base::local({
[10:27:22.821]                         has_future <- base::requireNamespace("future", 
[10:27:22.821]                           quietly = TRUE)
[10:27:22.821]                         if (has_future) {
[10:27:22.821]                           ns <- base::getNamespace("future")
[10:27:22.821]                           version <- ns[[".package"]][["version"]]
[10:27:22.821]                           if (is.null(version)) 
[10:27:22.821]                             version <- utils::packageVersion("future")
[10:27:22.821]                         }
[10:27:22.821]                         else {
[10:27:22.821]                           version <- NULL
[10:27:22.821]                         }
[10:27:22.821]                         if (!has_future || version < "1.8.0") {
[10:27:22.821]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:22.821]                             "", base::R.version$version.string), 
[10:27:22.821]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:22.821]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:22.821]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:22.821]                               "release", "version")], collapse = " "), 
[10:27:22.821]                             hostname = base::Sys.info()[["nodename"]])
[10:27:22.821]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:22.821]                             info)
[10:27:22.821]                           info <- base::paste(info, collapse = "; ")
[10:27:22.821]                           if (!has_future) {
[10:27:22.821]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:22.821]                               info)
[10:27:22.821]                           }
[10:27:22.821]                           else {
[10:27:22.821]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:22.821]                               info, version)
[10:27:22.821]                           }
[10:27:22.821]                           base::stop(msg)
[10:27:22.821]                         }
[10:27:22.821]                       })
[10:27:22.821]                     }
[10:27:22.821]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:22.821]                     base::options(mc.cores = 1L)
[10:27:22.821]                   }
[10:27:22.821]                   options(future.plan = NULL)
[10:27:22.821]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:22.821]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:22.821]                 }
[10:27:22.821]                 ...future.workdir <- getwd()
[10:27:22.821]             }
[10:27:22.821]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:22.821]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:22.821]         }
[10:27:22.821]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:22.821]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:22.821]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:22.821]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:22.821]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:22.821]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:22.821]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:22.821]             base::names(...future.oldOptions))
[10:27:22.821]     }
[10:27:22.821]     if (FALSE) {
[10:27:22.821]     }
[10:27:22.821]     else {
[10:27:22.821]         if (TRUE) {
[10:27:22.821]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:22.821]                 open = "w")
[10:27:22.821]         }
[10:27:22.821]         else {
[10:27:22.821]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:22.821]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:22.821]         }
[10:27:22.821]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:22.821]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:22.821]             base::sink(type = "output", split = FALSE)
[10:27:22.821]             base::close(...future.stdout)
[10:27:22.821]         }, add = TRUE)
[10:27:22.821]     }
[10:27:22.821]     ...future.frame <- base::sys.nframe()
[10:27:22.821]     ...future.conditions <- base::list()
[10:27:22.821]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:22.821]     if (FALSE) {
[10:27:22.821]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:22.821]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:22.821]     }
[10:27:22.821]     ...future.result <- base::tryCatch({
[10:27:22.821]         base::withCallingHandlers({
[10:27:22.821]             ...future.value <- base::withVisible(base::local({
[10:27:22.821]                 ...future.makeSendCondition <- base::local({
[10:27:22.821]                   sendCondition <- NULL
[10:27:22.821]                   function(frame = 1L) {
[10:27:22.821]                     if (is.function(sendCondition)) 
[10:27:22.821]                       return(sendCondition)
[10:27:22.821]                     ns <- getNamespace("parallel")
[10:27:22.821]                     if (exists("sendData", mode = "function", 
[10:27:22.821]                       envir = ns)) {
[10:27:22.821]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:22.821]                         envir = ns)
[10:27:22.821]                       envir <- sys.frame(frame)
[10:27:22.821]                       master <- NULL
[10:27:22.821]                       while (!identical(envir, .GlobalEnv) && 
[10:27:22.821]                         !identical(envir, emptyenv())) {
[10:27:22.821]                         if (exists("master", mode = "list", envir = envir, 
[10:27:22.821]                           inherits = FALSE)) {
[10:27:22.821]                           master <- get("master", mode = "list", 
[10:27:22.821]                             envir = envir, inherits = FALSE)
[10:27:22.821]                           if (inherits(master, c("SOCKnode", 
[10:27:22.821]                             "SOCK0node"))) {
[10:27:22.821]                             sendCondition <<- function(cond) {
[10:27:22.821]                               data <- list(type = "VALUE", value = cond, 
[10:27:22.821]                                 success = TRUE)
[10:27:22.821]                               parallel_sendData(master, data)
[10:27:22.821]                             }
[10:27:22.821]                             return(sendCondition)
[10:27:22.821]                           }
[10:27:22.821]                         }
[10:27:22.821]                         frame <- frame + 1L
[10:27:22.821]                         envir <- sys.frame(frame)
[10:27:22.821]                       }
[10:27:22.821]                     }
[10:27:22.821]                     sendCondition <<- function(cond) NULL
[10:27:22.821]                   }
[10:27:22.821]                 })
[10:27:22.821]                 withCallingHandlers({
[10:27:22.821]                   {
[10:27:22.821]                     Sys.sleep(0.5)
[10:27:22.821]                     2
[10:27:22.821]                   }
[10:27:22.821]                 }, immediateCondition = function(cond) {
[10:27:22.821]                   sendCondition <- ...future.makeSendCondition()
[10:27:22.821]                   sendCondition(cond)
[10:27:22.821]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.821]                   {
[10:27:22.821]                     inherits <- base::inherits
[10:27:22.821]                     invokeRestart <- base::invokeRestart
[10:27:22.821]                     is.null <- base::is.null
[10:27:22.821]                     muffled <- FALSE
[10:27:22.821]                     if (inherits(cond, "message")) {
[10:27:22.821]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:22.821]                       if (muffled) 
[10:27:22.821]                         invokeRestart("muffleMessage")
[10:27:22.821]                     }
[10:27:22.821]                     else if (inherits(cond, "warning")) {
[10:27:22.821]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:22.821]                       if (muffled) 
[10:27:22.821]                         invokeRestart("muffleWarning")
[10:27:22.821]                     }
[10:27:22.821]                     else if (inherits(cond, "condition")) {
[10:27:22.821]                       if (!is.null(pattern)) {
[10:27:22.821]                         computeRestarts <- base::computeRestarts
[10:27:22.821]                         grepl <- base::grepl
[10:27:22.821]                         restarts <- computeRestarts(cond)
[10:27:22.821]                         for (restart in restarts) {
[10:27:22.821]                           name <- restart$name
[10:27:22.821]                           if (is.null(name)) 
[10:27:22.821]                             next
[10:27:22.821]                           if (!grepl(pattern, name)) 
[10:27:22.821]                             next
[10:27:22.821]                           invokeRestart(restart)
[10:27:22.821]                           muffled <- TRUE
[10:27:22.821]                           break
[10:27:22.821]                         }
[10:27:22.821]                       }
[10:27:22.821]                     }
[10:27:22.821]                     invisible(muffled)
[10:27:22.821]                   }
[10:27:22.821]                   muffleCondition(cond)
[10:27:22.821]                 })
[10:27:22.821]             }))
[10:27:22.821]             future::FutureResult(value = ...future.value$value, 
[10:27:22.821]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:22.821]                   ...future.rng), globalenv = if (FALSE) 
[10:27:22.821]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:22.821]                     ...future.globalenv.names))
[10:27:22.821]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:22.821]         }, condition = base::local({
[10:27:22.821]             c <- base::c
[10:27:22.821]             inherits <- base::inherits
[10:27:22.821]             invokeRestart <- base::invokeRestart
[10:27:22.821]             length <- base::length
[10:27:22.821]             list <- base::list
[10:27:22.821]             seq.int <- base::seq.int
[10:27:22.821]             signalCondition <- base::signalCondition
[10:27:22.821]             sys.calls <- base::sys.calls
[10:27:22.821]             `[[` <- base::`[[`
[10:27:22.821]             `+` <- base::`+`
[10:27:22.821]             `<<-` <- base::`<<-`
[10:27:22.821]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:22.821]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:22.821]                   3L)]
[10:27:22.821]             }
[10:27:22.821]             function(cond) {
[10:27:22.821]                 is_error <- inherits(cond, "error")
[10:27:22.821]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:22.821]                   NULL)
[10:27:22.821]                 if (is_error) {
[10:27:22.821]                   sessionInformation <- function() {
[10:27:22.821]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:22.821]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:22.821]                       search = base::search(), system = base::Sys.info())
[10:27:22.821]                   }
[10:27:22.821]                   ...future.conditions[[length(...future.conditions) + 
[10:27:22.821]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:22.821]                     cond$call), session = sessionInformation(), 
[10:27:22.821]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:22.821]                   signalCondition(cond)
[10:27:22.821]                 }
[10:27:22.821]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:22.821]                 "immediateCondition"))) {
[10:27:22.821]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:22.821]                   ...future.conditions[[length(...future.conditions) + 
[10:27:22.821]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:22.821]                   if (TRUE && !signal) {
[10:27:22.821]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.821]                     {
[10:27:22.821]                       inherits <- base::inherits
[10:27:22.821]                       invokeRestart <- base::invokeRestart
[10:27:22.821]                       is.null <- base::is.null
[10:27:22.821]                       muffled <- FALSE
[10:27:22.821]                       if (inherits(cond, "message")) {
[10:27:22.821]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:22.821]                         if (muffled) 
[10:27:22.821]                           invokeRestart("muffleMessage")
[10:27:22.821]                       }
[10:27:22.821]                       else if (inherits(cond, "warning")) {
[10:27:22.821]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:22.821]                         if (muffled) 
[10:27:22.821]                           invokeRestart("muffleWarning")
[10:27:22.821]                       }
[10:27:22.821]                       else if (inherits(cond, "condition")) {
[10:27:22.821]                         if (!is.null(pattern)) {
[10:27:22.821]                           computeRestarts <- base::computeRestarts
[10:27:22.821]                           grepl <- base::grepl
[10:27:22.821]                           restarts <- computeRestarts(cond)
[10:27:22.821]                           for (restart in restarts) {
[10:27:22.821]                             name <- restart$name
[10:27:22.821]                             if (is.null(name)) 
[10:27:22.821]                               next
[10:27:22.821]                             if (!grepl(pattern, name)) 
[10:27:22.821]                               next
[10:27:22.821]                             invokeRestart(restart)
[10:27:22.821]                             muffled <- TRUE
[10:27:22.821]                             break
[10:27:22.821]                           }
[10:27:22.821]                         }
[10:27:22.821]                       }
[10:27:22.821]                       invisible(muffled)
[10:27:22.821]                     }
[10:27:22.821]                     muffleCondition(cond, pattern = "^muffle")
[10:27:22.821]                   }
[10:27:22.821]                 }
[10:27:22.821]                 else {
[10:27:22.821]                   if (TRUE) {
[10:27:22.821]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.821]                     {
[10:27:22.821]                       inherits <- base::inherits
[10:27:22.821]                       invokeRestart <- base::invokeRestart
[10:27:22.821]                       is.null <- base::is.null
[10:27:22.821]                       muffled <- FALSE
[10:27:22.821]                       if (inherits(cond, "message")) {
[10:27:22.821]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:22.821]                         if (muffled) 
[10:27:22.821]                           invokeRestart("muffleMessage")
[10:27:22.821]                       }
[10:27:22.821]                       else if (inherits(cond, "warning")) {
[10:27:22.821]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:22.821]                         if (muffled) 
[10:27:22.821]                           invokeRestart("muffleWarning")
[10:27:22.821]                       }
[10:27:22.821]                       else if (inherits(cond, "condition")) {
[10:27:22.821]                         if (!is.null(pattern)) {
[10:27:22.821]                           computeRestarts <- base::computeRestarts
[10:27:22.821]                           grepl <- base::grepl
[10:27:22.821]                           restarts <- computeRestarts(cond)
[10:27:22.821]                           for (restart in restarts) {
[10:27:22.821]                             name <- restart$name
[10:27:22.821]                             if (is.null(name)) 
[10:27:22.821]                               next
[10:27:22.821]                             if (!grepl(pattern, name)) 
[10:27:22.821]                               next
[10:27:22.821]                             invokeRestart(restart)
[10:27:22.821]                             muffled <- TRUE
[10:27:22.821]                             break
[10:27:22.821]                           }
[10:27:22.821]                         }
[10:27:22.821]                       }
[10:27:22.821]                       invisible(muffled)
[10:27:22.821]                     }
[10:27:22.821]                     muffleCondition(cond, pattern = "^muffle")
[10:27:22.821]                   }
[10:27:22.821]                 }
[10:27:22.821]             }
[10:27:22.821]         }))
[10:27:22.821]     }, error = function(ex) {
[10:27:22.821]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:22.821]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:22.821]                 ...future.rng), started = ...future.startTime, 
[10:27:22.821]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:22.821]             version = "1.8"), class = "FutureResult")
[10:27:22.821]     }, finally = {
[10:27:22.821]         if (!identical(...future.workdir, getwd())) 
[10:27:22.821]             setwd(...future.workdir)
[10:27:22.821]         {
[10:27:22.821]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:22.821]                 ...future.oldOptions$nwarnings <- NULL
[10:27:22.821]             }
[10:27:22.821]             base::options(...future.oldOptions)
[10:27:22.821]             if (.Platform$OS.type == "windows") {
[10:27:22.821]                 old_names <- names(...future.oldEnvVars)
[10:27:22.821]                 envs <- base::Sys.getenv()
[10:27:22.821]                 names <- names(envs)
[10:27:22.821]                 common <- intersect(names, old_names)
[10:27:22.821]                 added <- setdiff(names, old_names)
[10:27:22.821]                 removed <- setdiff(old_names, names)
[10:27:22.821]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:22.821]                   envs[common]]
[10:27:22.821]                 NAMES <- toupper(changed)
[10:27:22.821]                 args <- list()
[10:27:22.821]                 for (kk in seq_along(NAMES)) {
[10:27:22.821]                   name <- changed[[kk]]
[10:27:22.821]                   NAME <- NAMES[[kk]]
[10:27:22.821]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.821]                     next
[10:27:22.821]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:22.821]                 }
[10:27:22.821]                 NAMES <- toupper(added)
[10:27:22.821]                 for (kk in seq_along(NAMES)) {
[10:27:22.821]                   name <- added[[kk]]
[10:27:22.821]                   NAME <- NAMES[[kk]]
[10:27:22.821]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.821]                     next
[10:27:22.821]                   args[[name]] <- ""
[10:27:22.821]                 }
[10:27:22.821]                 NAMES <- toupper(removed)
[10:27:22.821]                 for (kk in seq_along(NAMES)) {
[10:27:22.821]                   name <- removed[[kk]]
[10:27:22.821]                   NAME <- NAMES[[kk]]
[10:27:22.821]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.821]                     next
[10:27:22.821]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:22.821]                 }
[10:27:22.821]                 if (length(args) > 0) 
[10:27:22.821]                   base::do.call(base::Sys.setenv, args = args)
[10:27:22.821]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:22.821]             }
[10:27:22.821]             else {
[10:27:22.821]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:22.821]             }
[10:27:22.821]             {
[10:27:22.821]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:22.821]                   0L) {
[10:27:22.821]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:22.821]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:22.821]                   base::options(opts)
[10:27:22.821]                 }
[10:27:22.821]                 {
[10:27:22.821]                   {
[10:27:22.821]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:22.821]                     NULL
[10:27:22.821]                   }
[10:27:22.821]                   options(future.plan = NULL)
[10:27:22.821]                   if (is.na(NA_character_)) 
[10:27:22.821]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:22.821]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:22.821]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:22.821]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:22.821]                     envir = parent.frame()) 
[10:27:22.821]                   {
[10:27:22.821]                     if (is.function(workers)) 
[10:27:22.821]                       workers <- workers()
[10:27:22.821]                     workers <- structure(as.integer(workers), 
[10:27:22.821]                       class = class(workers))
[10:27:22.821]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:22.821]                       workers >= 1)
[10:27:22.821]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:22.821]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:22.821]                     }
[10:27:22.821]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:22.821]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:22.821]                       envir = envir)
[10:27:22.821]                     if (!future$lazy) 
[10:27:22.821]                       future <- run(future)
[10:27:22.821]                     invisible(future)
[10:27:22.821]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:22.821]                 }
[10:27:22.821]             }
[10:27:22.821]         }
[10:27:22.821]     })
[10:27:22.821]     if (TRUE) {
[10:27:22.821]         base::sink(type = "output", split = FALSE)
[10:27:22.821]         if (TRUE) {
[10:27:22.821]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:22.821]         }
[10:27:22.821]         else {
[10:27:22.821]             ...future.result["stdout"] <- base::list(NULL)
[10:27:22.821]         }
[10:27:22.821]         base::close(...future.stdout)
[10:27:22.821]         ...future.stdout <- NULL
[10:27:22.821]     }
[10:27:22.821]     ...future.result$conditions <- ...future.conditions
[10:27:22.821]     ...future.result$finished <- base::Sys.time()
[10:27:22.821]     ...future.result
[10:27:22.821] }
[10:27:22.825] MultisessionFuture started
[10:27:22.825] - Launch lazy future ... done
[10:27:22.825] run() for ‘MultisessionFuture’ ... done
[10:27:22.826] getGlobalsAndPackages() ...
[10:27:22.826] Searching for globals...
[10:27:22.827] - globals found: [1] ‘{’
[10:27:22.827] Searching for globals ... DONE
[10:27:22.827] Resolving globals: FALSE
[10:27:22.827] 
[10:27:22.827] 
[10:27:22.828] getGlobalsAndPackages() ... DONE
[10:27:22.828] run() for ‘Future’ ...
[10:27:22.828] - state: ‘created’
[10:27:22.828] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:27:22.843] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:27:22.843] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:27:22.843]   - Field: ‘node’
[10:27:22.844]   - Field: ‘label’
[10:27:22.844]   - Field: ‘local’
[10:27:22.844]   - Field: ‘owner’
[10:27:22.844]   - Field: ‘envir’
[10:27:22.844]   - Field: ‘workers’
[10:27:22.844]   - Field: ‘packages’
[10:27:22.844]   - Field: ‘gc’
[10:27:22.844]   - Field: ‘conditions’
[10:27:22.844]   - Field: ‘persistent’
[10:27:22.845]   - Field: ‘expr’
[10:27:22.845]   - Field: ‘uuid’
[10:27:22.845]   - Field: ‘seed’
[10:27:22.845]   - Field: ‘version’
[10:27:22.845]   - Field: ‘result’
[10:27:22.845]   - Field: ‘asynchronous’
[10:27:22.845]   - Field: ‘calls’
[10:27:22.845]   - Field: ‘globals’
[10:27:22.845]   - Field: ‘stdout’
[10:27:22.845]   - Field: ‘earlySignal’
[10:27:22.846]   - Field: ‘lazy’
[10:27:22.846]   - Field: ‘state’
[10:27:22.846] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:27:22.846] - Launch lazy future ...
[10:27:22.846] Packages needed by the future expression (n = 0): <none>
[10:27:22.846] Packages needed by future strategies (n = 0): <none>
[10:27:22.847] {
[10:27:22.847]     {
[10:27:22.847]         {
[10:27:22.847]             ...future.startTime <- base::Sys.time()
[10:27:22.847]             {
[10:27:22.847]                 {
[10:27:22.847]                   {
[10:27:22.847]                     {
[10:27:22.847]                       base::local({
[10:27:22.847]                         has_future <- base::requireNamespace("future", 
[10:27:22.847]                           quietly = TRUE)
[10:27:22.847]                         if (has_future) {
[10:27:22.847]                           ns <- base::getNamespace("future")
[10:27:22.847]                           version <- ns[[".package"]][["version"]]
[10:27:22.847]                           if (is.null(version)) 
[10:27:22.847]                             version <- utils::packageVersion("future")
[10:27:22.847]                         }
[10:27:22.847]                         else {
[10:27:22.847]                           version <- NULL
[10:27:22.847]                         }
[10:27:22.847]                         if (!has_future || version < "1.8.0") {
[10:27:22.847]                           info <- base::c(r_version = base::gsub("R version ", 
[10:27:22.847]                             "", base::R.version$version.string), 
[10:27:22.847]                             platform = base::sprintf("%s (%s-bit)", 
[10:27:22.847]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:27:22.847]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:27:22.847]                               "release", "version")], collapse = " "), 
[10:27:22.847]                             hostname = base::Sys.info()[["nodename"]])
[10:27:22.847]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:27:22.847]                             info)
[10:27:22.847]                           info <- base::paste(info, collapse = "; ")
[10:27:22.847]                           if (!has_future) {
[10:27:22.847]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:27:22.847]                               info)
[10:27:22.847]                           }
[10:27:22.847]                           else {
[10:27:22.847]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:27:22.847]                               info, version)
[10:27:22.847]                           }
[10:27:22.847]                           base::stop(msg)
[10:27:22.847]                         }
[10:27:22.847]                       })
[10:27:22.847]                     }
[10:27:22.847]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:27:22.847]                     base::options(mc.cores = 1L)
[10:27:22.847]                   }
[10:27:22.847]                   options(future.plan = NULL)
[10:27:22.847]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:27:22.847]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:27:22.847]                 }
[10:27:22.847]                 ...future.workdir <- getwd()
[10:27:22.847]             }
[10:27:22.847]             ...future.oldOptions <- base::as.list(base::.Options)
[10:27:22.847]             ...future.oldEnvVars <- base::Sys.getenv()
[10:27:22.847]         }
[10:27:22.847]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:27:22.847]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:27:22.847]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:27:22.847]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:27:22.847]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:27:22.847]             future.stdout.windows.reencode = NULL, width = 80L)
[10:27:22.847]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:27:22.847]             base::names(...future.oldOptions))
[10:27:22.847]     }
[10:27:22.847]     if (FALSE) {
[10:27:22.847]     }
[10:27:22.847]     else {
[10:27:22.847]         if (TRUE) {
[10:27:22.847]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:27:22.847]                 open = "w")
[10:27:22.847]         }
[10:27:22.847]         else {
[10:27:22.847]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:27:22.847]                 windows = "NUL", "/dev/null"), open = "w")
[10:27:22.847]         }
[10:27:22.847]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:27:22.847]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:27:22.847]             base::sink(type = "output", split = FALSE)
[10:27:22.847]             base::close(...future.stdout)
[10:27:22.847]         }, add = TRUE)
[10:27:22.847]     }
[10:27:22.847]     ...future.frame <- base::sys.nframe()
[10:27:22.847]     ...future.conditions <- base::list()
[10:27:22.847]     ...future.rng <- base::globalenv()$.Random.seed
[10:27:22.847]     if (FALSE) {
[10:27:22.847]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:27:22.847]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:27:22.847]     }
[10:27:22.847]     ...future.result <- base::tryCatch({
[10:27:22.847]         base::withCallingHandlers({
[10:27:22.847]             ...future.value <- base::withVisible(base::local({
[10:27:22.847]                 ...future.makeSendCondition <- base::local({
[10:27:22.847]                   sendCondition <- NULL
[10:27:22.847]                   function(frame = 1L) {
[10:27:22.847]                     if (is.function(sendCondition)) 
[10:27:22.847]                       return(sendCondition)
[10:27:22.847]                     ns <- getNamespace("parallel")
[10:27:22.847]                     if (exists("sendData", mode = "function", 
[10:27:22.847]                       envir = ns)) {
[10:27:22.847]                       parallel_sendData <- get("sendData", mode = "function", 
[10:27:22.847]                         envir = ns)
[10:27:22.847]                       envir <- sys.frame(frame)
[10:27:22.847]                       master <- NULL
[10:27:22.847]                       while (!identical(envir, .GlobalEnv) && 
[10:27:22.847]                         !identical(envir, emptyenv())) {
[10:27:22.847]                         if (exists("master", mode = "list", envir = envir, 
[10:27:22.847]                           inherits = FALSE)) {
[10:27:22.847]                           master <- get("master", mode = "list", 
[10:27:22.847]                             envir = envir, inherits = FALSE)
[10:27:22.847]                           if (inherits(master, c("SOCKnode", 
[10:27:22.847]                             "SOCK0node"))) {
[10:27:22.847]                             sendCondition <<- function(cond) {
[10:27:22.847]                               data <- list(type = "VALUE", value = cond, 
[10:27:22.847]                                 success = TRUE)
[10:27:22.847]                               parallel_sendData(master, data)
[10:27:22.847]                             }
[10:27:22.847]                             return(sendCondition)
[10:27:22.847]                           }
[10:27:22.847]                         }
[10:27:22.847]                         frame <- frame + 1L
[10:27:22.847]                         envir <- sys.frame(frame)
[10:27:22.847]                       }
[10:27:22.847]                     }
[10:27:22.847]                     sendCondition <<- function(cond) NULL
[10:27:22.847]                   }
[10:27:22.847]                 })
[10:27:22.847]                 withCallingHandlers({
[10:27:22.847]                   {
[10:27:22.847]                     3
[10:27:22.847]                   }
[10:27:22.847]                 }, immediateCondition = function(cond) {
[10:27:22.847]                   sendCondition <- ...future.makeSendCondition()
[10:27:22.847]                   sendCondition(cond)
[10:27:22.847]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.847]                   {
[10:27:22.847]                     inherits <- base::inherits
[10:27:22.847]                     invokeRestart <- base::invokeRestart
[10:27:22.847]                     is.null <- base::is.null
[10:27:22.847]                     muffled <- FALSE
[10:27:22.847]                     if (inherits(cond, "message")) {
[10:27:22.847]                       muffled <- grepl(pattern, "muffleMessage")
[10:27:22.847]                       if (muffled) 
[10:27:22.847]                         invokeRestart("muffleMessage")
[10:27:22.847]                     }
[10:27:22.847]                     else if (inherits(cond, "warning")) {
[10:27:22.847]                       muffled <- grepl(pattern, "muffleWarning")
[10:27:22.847]                       if (muffled) 
[10:27:22.847]                         invokeRestart("muffleWarning")
[10:27:22.847]                     }
[10:27:22.847]                     else if (inherits(cond, "condition")) {
[10:27:22.847]                       if (!is.null(pattern)) {
[10:27:22.847]                         computeRestarts <- base::computeRestarts
[10:27:22.847]                         grepl <- base::grepl
[10:27:22.847]                         restarts <- computeRestarts(cond)
[10:27:22.847]                         for (restart in restarts) {
[10:27:22.847]                           name <- restart$name
[10:27:22.847]                           if (is.null(name)) 
[10:27:22.847]                             next
[10:27:22.847]                           if (!grepl(pattern, name)) 
[10:27:22.847]                             next
[10:27:22.847]                           invokeRestart(restart)
[10:27:22.847]                           muffled <- TRUE
[10:27:22.847]                           break
[10:27:22.847]                         }
[10:27:22.847]                       }
[10:27:22.847]                     }
[10:27:22.847]                     invisible(muffled)
[10:27:22.847]                   }
[10:27:22.847]                   muffleCondition(cond)
[10:27:22.847]                 })
[10:27:22.847]             }))
[10:27:22.847]             future::FutureResult(value = ...future.value$value, 
[10:27:22.847]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:22.847]                   ...future.rng), globalenv = if (FALSE) 
[10:27:22.847]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:27:22.847]                     ...future.globalenv.names))
[10:27:22.847]                 else NULL, started = ...future.startTime, version = "1.8")
[10:27:22.847]         }, condition = base::local({
[10:27:22.847]             c <- base::c
[10:27:22.847]             inherits <- base::inherits
[10:27:22.847]             invokeRestart <- base::invokeRestart
[10:27:22.847]             length <- base::length
[10:27:22.847]             list <- base::list
[10:27:22.847]             seq.int <- base::seq.int
[10:27:22.847]             signalCondition <- base::signalCondition
[10:27:22.847]             sys.calls <- base::sys.calls
[10:27:22.847]             `[[` <- base::`[[`
[10:27:22.847]             `+` <- base::`+`
[10:27:22.847]             `<<-` <- base::`<<-`
[10:27:22.847]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:27:22.847]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:27:22.847]                   3L)]
[10:27:22.847]             }
[10:27:22.847]             function(cond) {
[10:27:22.847]                 is_error <- inherits(cond, "error")
[10:27:22.847]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:27:22.847]                   NULL)
[10:27:22.847]                 if (is_error) {
[10:27:22.847]                   sessionInformation <- function() {
[10:27:22.847]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:27:22.847]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:27:22.847]                       search = base::search(), system = base::Sys.info())
[10:27:22.847]                   }
[10:27:22.847]                   ...future.conditions[[length(...future.conditions) + 
[10:27:22.847]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:27:22.847]                     cond$call), session = sessionInformation(), 
[10:27:22.847]                     timestamp = base::Sys.time(), signaled = 0L)
[10:27:22.847]                   signalCondition(cond)
[10:27:22.847]                 }
[10:27:22.847]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:27:22.847]                 "immediateCondition"))) {
[10:27:22.847]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:27:22.847]                   ...future.conditions[[length(...future.conditions) + 
[10:27:22.847]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:27:22.847]                   if (TRUE && !signal) {
[10:27:22.847]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.847]                     {
[10:27:22.847]                       inherits <- base::inherits
[10:27:22.847]                       invokeRestart <- base::invokeRestart
[10:27:22.847]                       is.null <- base::is.null
[10:27:22.847]                       muffled <- FALSE
[10:27:22.847]                       if (inherits(cond, "message")) {
[10:27:22.847]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:22.847]                         if (muffled) 
[10:27:22.847]                           invokeRestart("muffleMessage")
[10:27:22.847]                       }
[10:27:22.847]                       else if (inherits(cond, "warning")) {
[10:27:22.847]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:22.847]                         if (muffled) 
[10:27:22.847]                           invokeRestart("muffleWarning")
[10:27:22.847]                       }
[10:27:22.847]                       else if (inherits(cond, "condition")) {
[10:27:22.847]                         if (!is.null(pattern)) {
[10:27:22.847]                           computeRestarts <- base::computeRestarts
[10:27:22.847]                           grepl <- base::grepl
[10:27:22.847]                           restarts <- computeRestarts(cond)
[10:27:22.847]                           for (restart in restarts) {
[10:27:22.847]                             name <- restart$name
[10:27:22.847]                             if (is.null(name)) 
[10:27:22.847]                               next
[10:27:22.847]                             if (!grepl(pattern, name)) 
[10:27:22.847]                               next
[10:27:22.847]                             invokeRestart(restart)
[10:27:22.847]                             muffled <- TRUE
[10:27:22.847]                             break
[10:27:22.847]                           }
[10:27:22.847]                         }
[10:27:22.847]                       }
[10:27:22.847]                       invisible(muffled)
[10:27:22.847]                     }
[10:27:22.847]                     muffleCondition(cond, pattern = "^muffle")
[10:27:22.847]                   }
[10:27:22.847]                 }
[10:27:22.847]                 else {
[10:27:22.847]                   if (TRUE) {
[10:27:22.847]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:27:22.847]                     {
[10:27:22.847]                       inherits <- base::inherits
[10:27:22.847]                       invokeRestart <- base::invokeRestart
[10:27:22.847]                       is.null <- base::is.null
[10:27:22.847]                       muffled <- FALSE
[10:27:22.847]                       if (inherits(cond, "message")) {
[10:27:22.847]                         muffled <- grepl(pattern, "muffleMessage")
[10:27:22.847]                         if (muffled) 
[10:27:22.847]                           invokeRestart("muffleMessage")
[10:27:22.847]                       }
[10:27:22.847]                       else if (inherits(cond, "warning")) {
[10:27:22.847]                         muffled <- grepl(pattern, "muffleWarning")
[10:27:22.847]                         if (muffled) 
[10:27:22.847]                           invokeRestart("muffleWarning")
[10:27:22.847]                       }
[10:27:22.847]                       else if (inherits(cond, "condition")) {
[10:27:22.847]                         if (!is.null(pattern)) {
[10:27:22.847]                           computeRestarts <- base::computeRestarts
[10:27:22.847]                           grepl <- base::grepl
[10:27:22.847]                           restarts <- computeRestarts(cond)
[10:27:22.847]                           for (restart in restarts) {
[10:27:22.847]                             name <- restart$name
[10:27:22.847]                             if (is.null(name)) 
[10:27:22.847]                               next
[10:27:22.847]                             if (!grepl(pattern, name)) 
[10:27:22.847]                               next
[10:27:22.847]                             invokeRestart(restart)
[10:27:22.847]                             muffled <- TRUE
[10:27:22.847]                             break
[10:27:22.847]                           }
[10:27:22.847]                         }
[10:27:22.847]                       }
[10:27:22.847]                       invisible(muffled)
[10:27:22.847]                     }
[10:27:22.847]                     muffleCondition(cond, pattern = "^muffle")
[10:27:22.847]                   }
[10:27:22.847]                 }
[10:27:22.847]             }
[10:27:22.847]         }))
[10:27:22.847]     }, error = function(ex) {
[10:27:22.847]         base::structure(base::list(value = NULL, visible = NULL, 
[10:27:22.847]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:27:22.847]                 ...future.rng), started = ...future.startTime, 
[10:27:22.847]             finished = Sys.time(), session_uuid = NA_character_, 
[10:27:22.847]             version = "1.8"), class = "FutureResult")
[10:27:22.847]     }, finally = {
[10:27:22.847]         if (!identical(...future.workdir, getwd())) 
[10:27:22.847]             setwd(...future.workdir)
[10:27:22.847]         {
[10:27:22.847]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:27:22.847]                 ...future.oldOptions$nwarnings <- NULL
[10:27:22.847]             }
[10:27:22.847]             base::options(...future.oldOptions)
[10:27:22.847]             if (.Platform$OS.type == "windows") {
[10:27:22.847]                 old_names <- names(...future.oldEnvVars)
[10:27:22.847]                 envs <- base::Sys.getenv()
[10:27:22.847]                 names <- names(envs)
[10:27:22.847]                 common <- intersect(names, old_names)
[10:27:22.847]                 added <- setdiff(names, old_names)
[10:27:22.847]                 removed <- setdiff(old_names, names)
[10:27:22.847]                 changed <- common[...future.oldEnvVars[common] != 
[10:27:22.847]                   envs[common]]
[10:27:22.847]                 NAMES <- toupper(changed)
[10:27:22.847]                 args <- list()
[10:27:22.847]                 for (kk in seq_along(NAMES)) {
[10:27:22.847]                   name <- changed[[kk]]
[10:27:22.847]                   NAME <- NAMES[[kk]]
[10:27:22.847]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.847]                     next
[10:27:22.847]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:22.847]                 }
[10:27:22.847]                 NAMES <- toupper(added)
[10:27:22.847]                 for (kk in seq_along(NAMES)) {
[10:27:22.847]                   name <- added[[kk]]
[10:27:22.847]                   NAME <- NAMES[[kk]]
[10:27:22.847]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.847]                     next
[10:27:22.847]                   args[[name]] <- ""
[10:27:22.847]                 }
[10:27:22.847]                 NAMES <- toupper(removed)
[10:27:22.847]                 for (kk in seq_along(NAMES)) {
[10:27:22.847]                   name <- removed[[kk]]
[10:27:22.847]                   NAME <- NAMES[[kk]]
[10:27:22.847]                   if (name != NAME && is.element(NAME, old_names)) 
[10:27:22.847]                     next
[10:27:22.847]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:27:22.847]                 }
[10:27:22.847]                 if (length(args) > 0) 
[10:27:22.847]                   base::do.call(base::Sys.setenv, args = args)
[10:27:22.847]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:27:22.847]             }
[10:27:22.847]             else {
[10:27:22.847]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:27:22.847]             }
[10:27:22.847]             {
[10:27:22.847]                 if (base::length(...future.futureOptionsAdded) > 
[10:27:22.847]                   0L) {
[10:27:22.847]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:27:22.847]                   base::names(opts) <- ...future.futureOptionsAdded
[10:27:22.847]                   base::options(opts)
[10:27:22.847]                 }
[10:27:22.847]                 {
[10:27:22.847]                   {
[10:27:22.847]                     base::options(mc.cores = ...future.mc.cores.old)
[10:27:22.847]                     NULL
[10:27:22.847]                   }
[10:27:22.847]                   options(future.plan = NULL)
[10:27:22.847]                   if (is.na(NA_character_)) 
[10:27:22.847]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:27:22.847]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:27:22.847]                   future::plan(list(function (..., workers = availableCores(), 
[10:27:22.847]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:27:22.847]                     envir = parent.frame()) 
[10:27:22.847]                   {
[10:27:22.847]                     if (is.function(workers)) 
[10:27:22.847]                       workers <- workers()
[10:27:22.847]                     workers <- structure(as.integer(workers), 
[10:27:22.847]                       class = class(workers))
[10:27:22.847]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:27:22.847]                       workers >= 1)
[10:27:22.847]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:27:22.847]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:27:22.847]                     }
[10:27:22.847]                     future <- MultisessionFuture(..., workers = workers, 
[10:27:22.847]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:27:22.847]                       envir = envir)
[10:27:22.847]                     if (!future$lazy) 
[10:27:22.847]                       future <- run(future)
[10:27:22.847]                     invisible(future)
[10:27:22.847]                   }), .cleanup = FALSE, .init = FALSE)
[10:27:22.847]                 }
[10:27:22.847]             }
[10:27:22.847]         }
[10:27:22.847]     })
[10:27:22.847]     if (TRUE) {
[10:27:22.847]         base::sink(type = "output", split = FALSE)
[10:27:22.847]         if (TRUE) {
[10:27:22.847]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:27:22.847]         }
[10:27:22.847]         else {
[10:27:22.847]             ...future.result["stdout"] <- base::list(NULL)
[10:27:22.847]         }
[10:27:22.847]         base::close(...future.stdout)
[10:27:22.847]         ...future.stdout <- NULL
[10:27:22.847]     }
[10:27:22.847]     ...future.result$conditions <- ...future.conditions
[10:27:22.847]     ...future.result$finished <- base::Sys.time()
[10:27:22.847]     ...future.result
[10:27:22.847] }
[10:27:22.849] Poll #1 (0): usedNodes() = 2, workers = 2
[10:27:22.860] receiveMessageFromWorker() for ClusterFuture ...
[10:27:22.860] - Validating connection of MultisessionFuture
[10:27:22.860] - received message: FutureResult
[10:27:22.860] - Received FutureResult
[10:27:22.860] - Erased future from FutureRegistry
[10:27:22.861] result() for ClusterFuture ...
[10:27:22.861] - result already collected: FutureResult
[10:27:22.861] result() for ClusterFuture ... done
[10:27:22.861] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:22.861] result() for ClusterFuture ...
[10:27:22.861] - result already collected: FutureResult
[10:27:22.861] result() for ClusterFuture ... done
[10:27:22.861] result() for ClusterFuture ...
[10:27:22.861] - result already collected: FutureResult
[10:27:22.861] result() for ClusterFuture ... done
[10:27:22.863] MultisessionFuture started
[10:27:22.863] - Launch lazy future ... done
[10:27:22.863] run() for ‘MultisessionFuture’ ... done
[10:27:22.864] resolve() on list environment ...
[10:27:22.864]  recursive: 0
[10:27:22.865]  length: 4
[10:27:22.865]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:27:22.865] Future #1
[10:27:22.865]  length: 3 (resolved future 1)
[10:27:22.887]  length: 2 (resolved future 4)
[10:27:22.911] receiveMessageFromWorker() for ClusterFuture ...
[10:27:22.911] - Validating connection of MultisessionFuture
[10:27:22.911] - received message: FutureResult
[10:27:22.911] - Received FutureResult
[10:27:22.911] - Erased future from FutureRegistry
[10:27:22.912] result() for ClusterFuture ...
[10:27:22.912] - result already collected: FutureResult
[10:27:22.912] result() for ClusterFuture ... done
[10:27:22.912] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:22.912] Future #3
[10:27:22.912]  length: 1 (resolved future 3)
[10:27:23.380] receiveMessageFromWorker() for ClusterFuture ...
[10:27:23.380] - Validating connection of MultisessionFuture
[10:27:23.380] - received message: FutureResult
[10:27:23.380] - Received FutureResult
[10:27:23.381] - Erased future from FutureRegistry
[10:27:23.381] result() for ClusterFuture ...
[10:27:23.381] - result already collected: FutureResult
[10:27:23.381] result() for ClusterFuture ... done
[10:27:23.381] receiveMessageFromWorker() for ClusterFuture ... done
[10:27:23.381] Future #2
[10:27:23.381]  length: 0 (resolved future 2)
[10:27:23.381] resolve() on list environment ... DONE
[10:27:23.382] resolve() on list environment ...
[10:27:23.382]  recursive: 0
[10:27:23.382]  length: 4
[10:27:23.383]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:27:23.383] Future #1
[10:27:23.383]  length: 3 (resolved future 1)
[10:27:23.383] Future #2
[10:27:23.383]  length: 2 (resolved future 2)
[10:27:23.383] Future #3
[10:27:23.383]  length: 1 (resolved future 3)
[10:27:23.383]  length: 0 (resolved future 4)
[10:27:23.383] resolve() on list environment ... DONE
[10:27:23.384] resolve() on list environment ...
[10:27:23.384]  recursive: 0
[10:27:23.385]  length: 4
[10:27:23.385]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:27:23.385] Future #1
[10:27:23.385]  length: 3 (resolved future 1)
[10:27:23.385] Future #2
[10:27:23.385]  length: 2 (resolved future 2)
[10:27:23.385] Future #3
[10:27:23.385]  length: 1 (resolved future 3)
[10:27:23.386]  length: 0 (resolved future 4)
[10:27:23.386] resolve() on list environment ... DONE
[10:27:23.386] resolve() on list environment ...
[10:27:23.386]  recursive: 0
[10:27:23.387]  length: 4
[10:27:23.387]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:27:23.387] Future #1
[10:27:23.387]  length: 3 (resolved future 1)
[10:27:23.387] Future #2
[10:27:23.387]  length: 2 (resolved future 2)
[10:27:23.388] Future #3
[10:27:23.388]  length: 1 (resolved future 3)
[10:27:23.388]  length: 0 (resolved future 4)
[10:27:23.388] resolve() on list environment ... DONE
[10:27:23.388] resolve() on list environment ...
[10:27:23.388]  recursive: 0
[10:27:23.389]  length: 4
[10:27:23.389]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:27:23.389] Future #1
[10:27:23.389] result() for ClusterFuture ...
[10:27:23.389] - result already collected: FutureResult
[10:27:23.390] result() for ClusterFuture ... done
[10:27:23.390] result() for ClusterFuture ...
[10:27:23.390] - result already collected: FutureResult
[10:27:23.390] result() for ClusterFuture ... done
[10:27:23.390]  length: 3 (resolved future 1)
[10:27:23.390] Future #2
[10:27:23.390] result() for ClusterFuture ...
[10:27:23.390] - result already collected: FutureResult
[10:27:23.390] result() for ClusterFuture ... done
[10:27:23.390] result() for ClusterFuture ...
[10:27:23.391] - result already collected: FutureResult
[10:27:23.391] result() for ClusterFuture ... done
[10:27:23.391]  length: 2 (resolved future 2)
[10:27:23.391] Future #3
[10:27:23.391] result() for ClusterFuture ...
[10:27:23.391] - result already collected: FutureResult
[10:27:23.391] result() for ClusterFuture ... done
[10:27:23.391] result() for ClusterFuture ...
[10:27:23.391] - result already collected: FutureResult
[10:27:23.391] result() for ClusterFuture ... done
[10:27:23.392]  length: 1 (resolved future 3)
[10:27:23.392]  length: 0 (resolved future 4)
[10:27:23.392] resolve() on list environment ... DONE
[10:27:23.392] resolve() on list environment ...
[10:27:23.392]  recursive: 99
[10:27:23.393]  length: 4
[10:27:23.393]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:27:23.393] Future #1
[10:27:23.393] result() for ClusterFuture ...
[10:27:23.393] - result already collected: FutureResult
[10:27:23.393] result() for ClusterFuture ... done
[10:27:23.394] result() for ClusterFuture ...
[10:27:23.394] - result already collected: FutureResult
[10:27:23.394] result() for ClusterFuture ... done
[10:27:23.394] A MultisessionFuture was resolved
[10:27:23.394]  length: 3 (resolved future 1)
[10:27:23.394] Future #2
[10:27:23.394] result() for ClusterFuture ...
[10:27:23.394] - result already collected: FutureResult
[10:27:23.394] result() for ClusterFuture ... done
[10:27:23.394] result() for ClusterFuture ...
[10:27:23.395] - result already collected: FutureResult
[10:27:23.395] result() for ClusterFuture ... done
[10:27:23.395] A MultisessionFuture was resolved
[10:27:23.395]  length: 2 (resolved future 2)
[10:27:23.395] Future #3
[10:27:23.395] result() for ClusterFuture ...
[10:27:23.395] - result already collected: FutureResult
[10:27:23.395] result() for ClusterFuture ... done
[10:27:23.395] result() for ClusterFuture ...
[10:27:23.395] - result already collected: FutureResult
[10:27:23.396] result() for ClusterFuture ... done
[10:27:23.396] A MultisessionFuture was resolved
[10:27:23.396]  length: 1 (resolved future 3)
[10:27:23.396]  length: 0 (resolved future 4)
[10:27:23.396] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('multisession') ...
> 
> 
> message("*** resolve() - globals with non-trustful length() ...")
*** resolve() - globals with non-trustful length() ...
> 
> length.CantTrustLength <- function(x) length(unclass(x)) + 1L
> 
> .length <- future:::.length
> 
> x <- structure(as.list(1:3), class = c("CantTrustLength", "list"))
> str(list(n = length(x), n_true = .length(x)))
List of 2
 $ n     : int 4
 $ n_true: int 3
> stopifnot(length(x) > .length(x))
> x <- resolve(x)
[10:27:23.399] resolve() on list ...
[10:27:23.399]  recursive: 0
[10:27:23.399]  length: 3
[10:27:23.399] 
[10:27:23.399]  length: 2 (resolved future 1)
[10:27:23.399]  length: 1 (resolved future 2)
[10:27:23.400]  length: 0 (resolved future 3)
[10:27:23.400] resolve() on list ... DONE
> 
> message("*** resolve() - globals with non-trustful length() ... DONE")
*** resolve() - globals with non-trustful length() ... DONE
> 
> 
> message("*** resolved() - default ...")
*** resolved() - default ...
> 
> res <- resolved(42L)
> stopifnot(isTRUE(res))
> 
> message("*** resolved() - default ... DONE")
*** resolved() - default ... DONE
> 
> 
> message("*** resolve() ... DONE")
*** resolve() ... DONE
> 
> source("incl/end.R")
[10:27:23.401] plan(): Setting new future strategy stack:
[10:27:23.401] List of future strategies:
[10:27:23.401] 1. FutureStrategy:
[10:27:23.401]    - args: function (..., envir = parent.frame())
[10:27:23.401]    - tweaked: FALSE
[10:27:23.401]    - call: future::plan(oplan)
[10:27:23.401] plan(): nbrOfWorkers() = 1
> 
