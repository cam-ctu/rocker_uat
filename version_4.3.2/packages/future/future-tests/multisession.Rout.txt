
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[10:26:25.172] plan(): Setting new future strategy stack:
[10:26:25.173] List of future strategies:
[10:26:25.173] 1. sequential:
[10:26:25.173]    - args: function (..., envir = parent.frame())
[10:26:25.173]    - tweaked: FALSE
[10:26:25.173]    - call: future::plan("sequential")
[10:26:25.187] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> message("*** multisession() ...")
*** multisession() ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   ## No global variables
+   f <- multisession({
+     42L
+   })
+   print(f)
+   stopifnot(inherits(f, "ClusterFuture") || (inherits(f, "SequentialFuture") && f$lazy))
+ 
+   print(resolved(f))
+   y <- value(f)
+   print(y)
+   stopifnot(y == 42L)
+ 
+ 
+   ## A global variable
+   a <- 0
+   f <- multisession({
+     b <- 3
+     c <- 2
+     a * b * c
+   }, globals = TRUE)
+   print(f)
+ 
+ 
+   ## A multisession future is evaluated in a separate
+   ## R session process.  Changing the value of a global
+   ## variable should not affect the result of the
+   ## future.
+   a <- 7  ## Make sure globals are frozen
+   v <- value(f)
+   print(v)
+   stopifnot(v == 0)
+ 
+ 
+   message("*** multisession() with globals and blocking")
+   x <- listenv()
+   for (ii in 2:1) {
+     message(sprintf(" - Creating multisession future #%d ...", ii))
+     x[[ii]] <- multisession({ ii }, globals = TRUE)
+   }
+   message(sprintf(" - Resolving %d multisession futures", length(x)))
+   v <- sapply(x, FUN = value)
+   stopifnot(all(v == 1:2))
+ 
+ 
+   message("*** multisession() - workers inherit .libPaths()")
+ 
+   libs <- value(future(.libPaths()))
+   str(list(
+     main = .libPaths(),
+     workers = libs
+   ))
+   stopifnot(identical(libs, .libPaths()))
+ 
+   message("*** multisession() and errors")
+   f <- multisession({
+     stop("Whoops!")
+     1
+   })
+   print(f)
+   v <- value(f, signal = FALSE)
+   print(v)
+   stopifnot(inherits(v, "simpleError"))
+ 
+   res <- try(value(f), silent = TRUE)
+   print(res)
+   stopifnot(inherits(res, "try-error"))
+ 
+   ## Error is repeated
+   res <- try(value(f), silent = TRUE)
+   print(res)
+   stopifnot(inherits(res, "try-error"))
+ 
+   ## Custom error class
+   f <- multisession({
+     stop(structure(list(message = "boom"),
+                    class = c("MyError", "error", "condition")))
+   })
+   print(f)
+   v <- value(f, signal = FALSE)
+   print(v)
+   stopifnot(inherits(v, "error"), inherits(v, "MyError"))
+ 
+   ## Make sure error is signaled
+   res <- tryCatch(value(f), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   ## Issue #200: Custom condition class attributes are lost
+   ## https://github.com/HenrikBengtsson/Wishlist-for-R/issues/57
+   ## stopifnot(inherits(res, "MyError"))    
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
[10:26:25.237] getGlobalsAndPackages() ...
[10:26:25.238] Searching for globals...
[10:26:25.241] - globals found: [1] ‘{’
[10:26:25.241] Searching for globals ... DONE
[10:26:25.241] Resolving globals: FALSE
[10:26:25.241] 
[10:26:25.241] 
[10:26:25.242] getGlobalsAndPackages() ... DONE
SequentialFuture:
Label: ‘<none>’
Expression:
{
    42L
}
Lazy evaluation: TRUE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: b237ea00-048b-53bc-62d3-d50d6929ba00
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:25.243] Packages needed by the future expression (n = 0): <none>
[10:26:25.244] Packages needed by future strategies (n = 0): <none>
[10:26:25.244] {
[10:26:25.244]     {
[10:26:25.244]         {
[10:26:25.244]             ...future.startTime <- base::Sys.time()
[10:26:25.244]             {
[10:26:25.244]                 {
[10:26:25.244]                   {
[10:26:25.244]                     base::local({
[10:26:25.244]                       has_future <- base::requireNamespace("future", 
[10:26:25.244]                         quietly = TRUE)
[10:26:25.244]                       if (has_future) {
[10:26:25.244]                         ns <- base::getNamespace("future")
[10:26:25.244]                         version <- ns[[".package"]][["version"]]
[10:26:25.244]                         if (is.null(version)) 
[10:26:25.244]                           version <- utils::packageVersion("future")
[10:26:25.244]                       }
[10:26:25.244]                       else {
[10:26:25.244]                         version <- NULL
[10:26:25.244]                       }
[10:26:25.244]                       if (!has_future || version < "1.8.0") {
[10:26:25.244]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:25.244]                           "", base::R.version$version.string), 
[10:26:25.244]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:25.244]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:25.244]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:25.244]                             "release", "version")], collapse = " "), 
[10:26:25.244]                           hostname = base::Sys.info()[["nodename"]])
[10:26:25.244]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:25.244]                           info)
[10:26:25.244]                         info <- base::paste(info, collapse = "; ")
[10:26:25.244]                         if (!has_future) {
[10:26:25.244]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:25.244]                             info)
[10:26:25.244]                         }
[10:26:25.244]                         else {
[10:26:25.244]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:25.244]                             info, version)
[10:26:25.244]                         }
[10:26:25.244]                         base::stop(msg)
[10:26:25.244]                       }
[10:26:25.244]                     })
[10:26:25.244]                   }
[10:26:25.244]                   options(future.plan = NULL)
[10:26:25.244]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:25.244]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:25.244]                 }
[10:26:25.244]                 ...future.workdir <- getwd()
[10:26:25.244]             }
[10:26:25.244]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:25.244]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:25.244]         }
[10:26:25.244]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:25.244]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:25.244]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:25.244]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:25.244]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:25.244]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:25.244]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:25.244]             base::names(...future.oldOptions))
[10:26:25.244]     }
[10:26:25.244]     if (FALSE) {
[10:26:25.244]     }
[10:26:25.244]     else {
[10:26:25.244]         if (TRUE) {
[10:26:25.244]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:25.244]                 open = "w")
[10:26:25.244]         }
[10:26:25.244]         else {
[10:26:25.244]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:25.244]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:25.244]         }
[10:26:25.244]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:25.244]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:25.244]             base::sink(type = "output", split = FALSE)
[10:26:25.244]             base::close(...future.stdout)
[10:26:25.244]         }, add = TRUE)
[10:26:25.244]     }
[10:26:25.244]     ...future.frame <- base::sys.nframe()
[10:26:25.244]     ...future.conditions <- base::list()
[10:26:25.244]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:25.244]     if (FALSE) {
[10:26:25.244]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:25.244]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:25.244]     }
[10:26:25.244]     ...future.result <- base::tryCatch({
[10:26:25.244]         base::withCallingHandlers({
[10:26:25.244]             ...future.value <- base::withVisible(base::local({
[10:26:25.244]                 42L
[10:26:25.244]             }))
[10:26:25.244]             future::FutureResult(value = ...future.value$value, 
[10:26:25.244]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:25.244]                   ...future.rng), globalenv = if (FALSE) 
[10:26:25.244]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:25.244]                     ...future.globalenv.names))
[10:26:25.244]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:25.244]         }, condition = base::local({
[10:26:25.244]             c <- base::c
[10:26:25.244]             inherits <- base::inherits
[10:26:25.244]             invokeRestart <- base::invokeRestart
[10:26:25.244]             length <- base::length
[10:26:25.244]             list <- base::list
[10:26:25.244]             seq.int <- base::seq.int
[10:26:25.244]             signalCondition <- base::signalCondition
[10:26:25.244]             sys.calls <- base::sys.calls
[10:26:25.244]             `[[` <- base::`[[`
[10:26:25.244]             `+` <- base::`+`
[10:26:25.244]             `<<-` <- base::`<<-`
[10:26:25.244]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:25.244]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:25.244]                   3L)]
[10:26:25.244]             }
[10:26:25.244]             function(cond) {
[10:26:25.244]                 is_error <- inherits(cond, "error")
[10:26:25.244]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:25.244]                   NULL)
[10:26:25.244]                 if (is_error) {
[10:26:25.244]                   sessionInformation <- function() {
[10:26:25.244]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:25.244]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:25.244]                       search = base::search(), system = base::Sys.info())
[10:26:25.244]                   }
[10:26:25.244]                   ...future.conditions[[length(...future.conditions) + 
[10:26:25.244]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:25.244]                     cond$call), session = sessionInformation(), 
[10:26:25.244]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:25.244]                   signalCondition(cond)
[10:26:25.244]                 }
[10:26:25.244]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:25.244]                 "immediateCondition"))) {
[10:26:25.244]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:25.244]                   ...future.conditions[[length(...future.conditions) + 
[10:26:25.244]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:25.244]                   if (TRUE && !signal) {
[10:26:25.244]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:25.244]                     {
[10:26:25.244]                       inherits <- base::inherits
[10:26:25.244]                       invokeRestart <- base::invokeRestart
[10:26:25.244]                       is.null <- base::is.null
[10:26:25.244]                       muffled <- FALSE
[10:26:25.244]                       if (inherits(cond, "message")) {
[10:26:25.244]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:25.244]                         if (muffled) 
[10:26:25.244]                           invokeRestart("muffleMessage")
[10:26:25.244]                       }
[10:26:25.244]                       else if (inherits(cond, "warning")) {
[10:26:25.244]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:25.244]                         if (muffled) 
[10:26:25.244]                           invokeRestart("muffleWarning")
[10:26:25.244]                       }
[10:26:25.244]                       else if (inherits(cond, "condition")) {
[10:26:25.244]                         if (!is.null(pattern)) {
[10:26:25.244]                           computeRestarts <- base::computeRestarts
[10:26:25.244]                           grepl <- base::grepl
[10:26:25.244]                           restarts <- computeRestarts(cond)
[10:26:25.244]                           for (restart in restarts) {
[10:26:25.244]                             name <- restart$name
[10:26:25.244]                             if (is.null(name)) 
[10:26:25.244]                               next
[10:26:25.244]                             if (!grepl(pattern, name)) 
[10:26:25.244]                               next
[10:26:25.244]                             invokeRestart(restart)
[10:26:25.244]                             muffled <- TRUE
[10:26:25.244]                             break
[10:26:25.244]                           }
[10:26:25.244]                         }
[10:26:25.244]                       }
[10:26:25.244]                       invisible(muffled)
[10:26:25.244]                     }
[10:26:25.244]                     muffleCondition(cond, pattern = "^muffle")
[10:26:25.244]                   }
[10:26:25.244]                 }
[10:26:25.244]                 else {
[10:26:25.244]                   if (TRUE) {
[10:26:25.244]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:25.244]                     {
[10:26:25.244]                       inherits <- base::inherits
[10:26:25.244]                       invokeRestart <- base::invokeRestart
[10:26:25.244]                       is.null <- base::is.null
[10:26:25.244]                       muffled <- FALSE
[10:26:25.244]                       if (inherits(cond, "message")) {
[10:26:25.244]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:25.244]                         if (muffled) 
[10:26:25.244]                           invokeRestart("muffleMessage")
[10:26:25.244]                       }
[10:26:25.244]                       else if (inherits(cond, "warning")) {
[10:26:25.244]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:25.244]                         if (muffled) 
[10:26:25.244]                           invokeRestart("muffleWarning")
[10:26:25.244]                       }
[10:26:25.244]                       else if (inherits(cond, "condition")) {
[10:26:25.244]                         if (!is.null(pattern)) {
[10:26:25.244]                           computeRestarts <- base::computeRestarts
[10:26:25.244]                           grepl <- base::grepl
[10:26:25.244]                           restarts <- computeRestarts(cond)
[10:26:25.244]                           for (restart in restarts) {
[10:26:25.244]                             name <- restart$name
[10:26:25.244]                             if (is.null(name)) 
[10:26:25.244]                               next
[10:26:25.244]                             if (!grepl(pattern, name)) 
[10:26:25.244]                               next
[10:26:25.244]                             invokeRestart(restart)
[10:26:25.244]                             muffled <- TRUE
[10:26:25.244]                             break
[10:26:25.244]                           }
[10:26:25.244]                         }
[10:26:25.244]                       }
[10:26:25.244]                       invisible(muffled)
[10:26:25.244]                     }
[10:26:25.244]                     muffleCondition(cond, pattern = "^muffle")
[10:26:25.244]                   }
[10:26:25.244]                 }
[10:26:25.244]             }
[10:26:25.244]         }))
[10:26:25.244]     }, error = function(ex) {
[10:26:25.244]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:25.244]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:25.244]                 ...future.rng), started = ...future.startTime, 
[10:26:25.244]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:25.244]             version = "1.8"), class = "FutureResult")
[10:26:25.244]     }, finally = {
[10:26:25.244]         if (!identical(...future.workdir, getwd())) 
[10:26:25.244]             setwd(...future.workdir)
[10:26:25.244]         {
[10:26:25.244]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:25.244]                 ...future.oldOptions$nwarnings <- NULL
[10:26:25.244]             }
[10:26:25.244]             base::options(...future.oldOptions)
[10:26:25.244]             if (.Platform$OS.type == "windows") {
[10:26:25.244]                 old_names <- names(...future.oldEnvVars)
[10:26:25.244]                 envs <- base::Sys.getenv()
[10:26:25.244]                 names <- names(envs)
[10:26:25.244]                 common <- intersect(names, old_names)
[10:26:25.244]                 added <- setdiff(names, old_names)
[10:26:25.244]                 removed <- setdiff(old_names, names)
[10:26:25.244]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:25.244]                   envs[common]]
[10:26:25.244]                 NAMES <- toupper(changed)
[10:26:25.244]                 args <- list()
[10:26:25.244]                 for (kk in seq_along(NAMES)) {
[10:26:25.244]                   name <- changed[[kk]]
[10:26:25.244]                   NAME <- NAMES[[kk]]
[10:26:25.244]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:25.244]                     next
[10:26:25.244]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:25.244]                 }
[10:26:25.244]                 NAMES <- toupper(added)
[10:26:25.244]                 for (kk in seq_along(NAMES)) {
[10:26:25.244]                   name <- added[[kk]]
[10:26:25.244]                   NAME <- NAMES[[kk]]
[10:26:25.244]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:25.244]                     next
[10:26:25.244]                   args[[name]] <- ""
[10:26:25.244]                 }
[10:26:25.244]                 NAMES <- toupper(removed)
[10:26:25.244]                 for (kk in seq_along(NAMES)) {
[10:26:25.244]                   name <- removed[[kk]]
[10:26:25.244]                   NAME <- NAMES[[kk]]
[10:26:25.244]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:25.244]                     next
[10:26:25.244]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:25.244]                 }
[10:26:25.244]                 if (length(args) > 0) 
[10:26:25.244]                   base::do.call(base::Sys.setenv, args = args)
[10:26:25.244]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:25.244]             }
[10:26:25.244]             else {
[10:26:25.244]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:25.244]             }
[10:26:25.244]             {
[10:26:25.244]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:25.244]                   0L) {
[10:26:25.244]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:25.244]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:25.244]                   base::options(opts)
[10:26:25.244]                 }
[10:26:25.244]                 {
[10:26:25.244]                   {
[10:26:25.244]                     NULL
[10:26:25.244]                     RNGkind("Mersenne-Twister")
[10:26:25.244]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:25.244]                       inherits = FALSE)
[10:26:25.244]                   }
[10:26:25.244]                   options(future.plan = NULL)
[10:26:25.244]                   if (is.na(NA_character_)) 
[10:26:25.244]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:25.244]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:25.244]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:25.244]                   {
[10:26:25.244]                     future <- SequentialFuture(..., envir = envir)
[10:26:25.244]                     if (!future$lazy) 
[10:26:25.244]                       future <- run(future)
[10:26:25.244]                     invisible(future)
[10:26:25.244]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:25.244]                 }
[10:26:25.244]             }
[10:26:25.244]         }
[10:26:25.244]     })
[10:26:25.244]     if (TRUE) {
[10:26:25.244]         base::sink(type = "output", split = FALSE)
[10:26:25.244]         if (TRUE) {
[10:26:25.244]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:25.244]         }
[10:26:25.244]         else {
[10:26:25.244]             ...future.result["stdout"] <- base::list(NULL)
[10:26:25.244]         }
[10:26:25.244]         base::close(...future.stdout)
[10:26:25.244]         ...future.stdout <- NULL
[10:26:25.244]     }
[10:26:25.244]     ...future.result$conditions <- ...future.conditions
[10:26:25.244]     ...future.result$finished <- base::Sys.time()
[10:26:25.244]     ...future.result
[10:26:25.244] }
[10:26:25.246] plan(): Setting new future strategy stack:
[10:26:25.246] List of future strategies:
[10:26:25.246] 1. sequential:
[10:26:25.246]    - args: function (..., envir = parent.frame())
[10:26:25.246]    - tweaked: FALSE
[10:26:25.246]    - call: NULL
[10:26:25.247] plan(): nbrOfWorkers() = 1
[10:26:25.248] plan(): Setting new future strategy stack:
[10:26:25.248] List of future strategies:
[10:26:25.248] 1. sequential:
[10:26:25.248]    - args: function (..., envir = parent.frame())
[10:26:25.248]    - tweaked: FALSE
[10:26:25.248]    - call: future::plan("sequential")
[10:26:25.248] plan(): nbrOfWorkers() = 1
[10:26:25.248] SequentialFuture started (and completed)
[10:26:25.249] resolved() for ‘SequentialFuture’ ...
[10:26:25.249] - state: ‘finished’
[10:26:25.249] - run: TRUE
[10:26:25.249] - result: ‘FutureResult’
[10:26:25.249] resolved() for ‘SequentialFuture’ ... done
[1] TRUE
[1] 42
[10:26:25.253] getGlobalsAndPackages() ...
[10:26:25.253] Searching for globals...
[10:26:25.257] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘a’
[10:26:25.258] Searching for globals ... DONE
[10:26:25.258] Resolving globals: FALSE
[10:26:25.258] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:25.260] The total size of the 1 globals exported for future expression (‘{; b <- 3; c <- 2; a * b * c; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[10:26:25.261] - globals: [1] ‘a’
[10:26:25.261] 
[10:26:25.261] getGlobalsAndPackages() ... DONE
SequentialFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: TRUE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: 1 objects totaling 56 bytes (numeric ‘a’ of 56 bytes)
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: b237ea00-048b-53bc-62d3-d50d6929ba00
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:25.262] Packages needed by the future expression (n = 0): <none>
[10:26:25.262] Packages needed by future strategies (n = 0): <none>
[10:26:25.262] {
[10:26:25.262]     {
[10:26:25.262]         {
[10:26:25.262]             ...future.startTime <- base::Sys.time()
[10:26:25.262]             {
[10:26:25.262]                 {
[10:26:25.262]                   {
[10:26:25.262]                     base::local({
[10:26:25.262]                       has_future <- base::requireNamespace("future", 
[10:26:25.262]                         quietly = TRUE)
[10:26:25.262]                       if (has_future) {
[10:26:25.262]                         ns <- base::getNamespace("future")
[10:26:25.262]                         version <- ns[[".package"]][["version"]]
[10:26:25.262]                         if (is.null(version)) 
[10:26:25.262]                           version <- utils::packageVersion("future")
[10:26:25.262]                       }
[10:26:25.262]                       else {
[10:26:25.262]                         version <- NULL
[10:26:25.262]                       }
[10:26:25.262]                       if (!has_future || version < "1.8.0") {
[10:26:25.262]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:25.262]                           "", base::R.version$version.string), 
[10:26:25.262]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:25.262]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:25.262]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:25.262]                             "release", "version")], collapse = " "), 
[10:26:25.262]                           hostname = base::Sys.info()[["nodename"]])
[10:26:25.262]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:25.262]                           info)
[10:26:25.262]                         info <- base::paste(info, collapse = "; ")
[10:26:25.262]                         if (!has_future) {
[10:26:25.262]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:25.262]                             info)
[10:26:25.262]                         }
[10:26:25.262]                         else {
[10:26:25.262]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:25.262]                             info, version)
[10:26:25.262]                         }
[10:26:25.262]                         base::stop(msg)
[10:26:25.262]                       }
[10:26:25.262]                     })
[10:26:25.262]                   }
[10:26:25.262]                   options(future.plan = NULL)
[10:26:25.262]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:25.262]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:25.262]                 }
[10:26:25.262]                 ...future.workdir <- getwd()
[10:26:25.262]             }
[10:26:25.262]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:25.262]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:25.262]         }
[10:26:25.262]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:25.262]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:25.262]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:25.262]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:25.262]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:25.262]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:25.262]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:25.262]             base::names(...future.oldOptions))
[10:26:25.262]     }
[10:26:25.262]     if (FALSE) {
[10:26:25.262]     }
[10:26:25.262]     else {
[10:26:25.262]         if (TRUE) {
[10:26:25.262]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:25.262]                 open = "w")
[10:26:25.262]         }
[10:26:25.262]         else {
[10:26:25.262]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:25.262]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:25.262]         }
[10:26:25.262]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:25.262]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:25.262]             base::sink(type = "output", split = FALSE)
[10:26:25.262]             base::close(...future.stdout)
[10:26:25.262]         }, add = TRUE)
[10:26:25.262]     }
[10:26:25.262]     ...future.frame <- base::sys.nframe()
[10:26:25.262]     ...future.conditions <- base::list()
[10:26:25.262]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:25.262]     if (FALSE) {
[10:26:25.262]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:25.262]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:25.262]     }
[10:26:25.262]     ...future.result <- base::tryCatch({
[10:26:25.262]         base::withCallingHandlers({
[10:26:25.262]             ...future.value <- base::withVisible(base::local({
[10:26:25.262]                 b <- 3
[10:26:25.262]                 c <- 2
[10:26:25.262]                 a * b * c
[10:26:25.262]             }))
[10:26:25.262]             future::FutureResult(value = ...future.value$value, 
[10:26:25.262]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:25.262]                   ...future.rng), globalenv = if (FALSE) 
[10:26:25.262]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:25.262]                     ...future.globalenv.names))
[10:26:25.262]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:25.262]         }, condition = base::local({
[10:26:25.262]             c <- base::c
[10:26:25.262]             inherits <- base::inherits
[10:26:25.262]             invokeRestart <- base::invokeRestart
[10:26:25.262]             length <- base::length
[10:26:25.262]             list <- base::list
[10:26:25.262]             seq.int <- base::seq.int
[10:26:25.262]             signalCondition <- base::signalCondition
[10:26:25.262]             sys.calls <- base::sys.calls
[10:26:25.262]             `[[` <- base::`[[`
[10:26:25.262]             `+` <- base::`+`
[10:26:25.262]             `<<-` <- base::`<<-`
[10:26:25.262]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:25.262]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:25.262]                   3L)]
[10:26:25.262]             }
[10:26:25.262]             function(cond) {
[10:26:25.262]                 is_error <- inherits(cond, "error")
[10:26:25.262]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:25.262]                   NULL)
[10:26:25.262]                 if (is_error) {
[10:26:25.262]                   sessionInformation <- function() {
[10:26:25.262]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:25.262]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:25.262]                       search = base::search(), system = base::Sys.info())
[10:26:25.262]                   }
[10:26:25.262]                   ...future.conditions[[length(...future.conditions) + 
[10:26:25.262]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:25.262]                     cond$call), session = sessionInformation(), 
[10:26:25.262]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:25.262]                   signalCondition(cond)
[10:26:25.262]                 }
[10:26:25.262]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:25.262]                 "immediateCondition"))) {
[10:26:25.262]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:25.262]                   ...future.conditions[[length(...future.conditions) + 
[10:26:25.262]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:25.262]                   if (TRUE && !signal) {
[10:26:25.262]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:25.262]                     {
[10:26:25.262]                       inherits <- base::inherits
[10:26:25.262]                       invokeRestart <- base::invokeRestart
[10:26:25.262]                       is.null <- base::is.null
[10:26:25.262]                       muffled <- FALSE
[10:26:25.262]                       if (inherits(cond, "message")) {
[10:26:25.262]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:25.262]                         if (muffled) 
[10:26:25.262]                           invokeRestart("muffleMessage")
[10:26:25.262]                       }
[10:26:25.262]                       else if (inherits(cond, "warning")) {
[10:26:25.262]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:25.262]                         if (muffled) 
[10:26:25.262]                           invokeRestart("muffleWarning")
[10:26:25.262]                       }
[10:26:25.262]                       else if (inherits(cond, "condition")) {
[10:26:25.262]                         if (!is.null(pattern)) {
[10:26:25.262]                           computeRestarts <- base::computeRestarts
[10:26:25.262]                           grepl <- base::grepl
[10:26:25.262]                           restarts <- computeRestarts(cond)
[10:26:25.262]                           for (restart in restarts) {
[10:26:25.262]                             name <- restart$name
[10:26:25.262]                             if (is.null(name)) 
[10:26:25.262]                               next
[10:26:25.262]                             if (!grepl(pattern, name)) 
[10:26:25.262]                               next
[10:26:25.262]                             invokeRestart(restart)
[10:26:25.262]                             muffled <- TRUE
[10:26:25.262]                             break
[10:26:25.262]                           }
[10:26:25.262]                         }
[10:26:25.262]                       }
[10:26:25.262]                       invisible(muffled)
[10:26:25.262]                     }
[10:26:25.262]                     muffleCondition(cond, pattern = "^muffle")
[10:26:25.262]                   }
[10:26:25.262]                 }
[10:26:25.262]                 else {
[10:26:25.262]                   if (TRUE) {
[10:26:25.262]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:25.262]                     {
[10:26:25.262]                       inherits <- base::inherits
[10:26:25.262]                       invokeRestart <- base::invokeRestart
[10:26:25.262]                       is.null <- base::is.null
[10:26:25.262]                       muffled <- FALSE
[10:26:25.262]                       if (inherits(cond, "message")) {
[10:26:25.262]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:25.262]                         if (muffled) 
[10:26:25.262]                           invokeRestart("muffleMessage")
[10:26:25.262]                       }
[10:26:25.262]                       else if (inherits(cond, "warning")) {
[10:26:25.262]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:25.262]                         if (muffled) 
[10:26:25.262]                           invokeRestart("muffleWarning")
[10:26:25.262]                       }
[10:26:25.262]                       else if (inherits(cond, "condition")) {
[10:26:25.262]                         if (!is.null(pattern)) {
[10:26:25.262]                           computeRestarts <- base::computeRestarts
[10:26:25.262]                           grepl <- base::grepl
[10:26:25.262]                           restarts <- computeRestarts(cond)
[10:26:25.262]                           for (restart in restarts) {
[10:26:25.262]                             name <- restart$name
[10:26:25.262]                             if (is.null(name)) 
[10:26:25.262]                               next
[10:26:25.262]                             if (!grepl(pattern, name)) 
[10:26:25.262]                               next
[10:26:25.262]                             invokeRestart(restart)
[10:26:25.262]                             muffled <- TRUE
[10:26:25.262]                             break
[10:26:25.262]                           }
[10:26:25.262]                         }
[10:26:25.262]                       }
[10:26:25.262]                       invisible(muffled)
[10:26:25.262]                     }
[10:26:25.262]                     muffleCondition(cond, pattern = "^muffle")
[10:26:25.262]                   }
[10:26:25.262]                 }
[10:26:25.262]             }
[10:26:25.262]         }))
[10:26:25.262]     }, error = function(ex) {
[10:26:25.262]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:25.262]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:25.262]                 ...future.rng), started = ...future.startTime, 
[10:26:25.262]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:25.262]             version = "1.8"), class = "FutureResult")
[10:26:25.262]     }, finally = {
[10:26:25.262]         if (!identical(...future.workdir, getwd())) 
[10:26:25.262]             setwd(...future.workdir)
[10:26:25.262]         {
[10:26:25.262]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:25.262]                 ...future.oldOptions$nwarnings <- NULL
[10:26:25.262]             }
[10:26:25.262]             base::options(...future.oldOptions)
[10:26:25.262]             if (.Platform$OS.type == "windows") {
[10:26:25.262]                 old_names <- names(...future.oldEnvVars)
[10:26:25.262]                 envs <- base::Sys.getenv()
[10:26:25.262]                 names <- names(envs)
[10:26:25.262]                 common <- intersect(names, old_names)
[10:26:25.262]                 added <- setdiff(names, old_names)
[10:26:25.262]                 removed <- setdiff(old_names, names)
[10:26:25.262]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:25.262]                   envs[common]]
[10:26:25.262]                 NAMES <- toupper(changed)
[10:26:25.262]                 args <- list()
[10:26:25.262]                 for (kk in seq_along(NAMES)) {
[10:26:25.262]                   name <- changed[[kk]]
[10:26:25.262]                   NAME <- NAMES[[kk]]
[10:26:25.262]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:25.262]                     next
[10:26:25.262]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:25.262]                 }
[10:26:25.262]                 NAMES <- toupper(added)
[10:26:25.262]                 for (kk in seq_along(NAMES)) {
[10:26:25.262]                   name <- added[[kk]]
[10:26:25.262]                   NAME <- NAMES[[kk]]
[10:26:25.262]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:25.262]                     next
[10:26:25.262]                   args[[name]] <- ""
[10:26:25.262]                 }
[10:26:25.262]                 NAMES <- toupper(removed)
[10:26:25.262]                 for (kk in seq_along(NAMES)) {
[10:26:25.262]                   name <- removed[[kk]]
[10:26:25.262]                   NAME <- NAMES[[kk]]
[10:26:25.262]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:25.262]                     next
[10:26:25.262]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:25.262]                 }
[10:26:25.262]                 if (length(args) > 0) 
[10:26:25.262]                   base::do.call(base::Sys.setenv, args = args)
[10:26:25.262]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:25.262]             }
[10:26:25.262]             else {
[10:26:25.262]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:25.262]             }
[10:26:25.262]             {
[10:26:25.262]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:25.262]                   0L) {
[10:26:25.262]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:25.262]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:25.262]                   base::options(opts)
[10:26:25.262]                 }
[10:26:25.262]                 {
[10:26:25.262]                   {
[10:26:25.262]                     NULL
[10:26:25.262]                     RNGkind("Mersenne-Twister")
[10:26:25.262]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:25.262]                       inherits = FALSE)
[10:26:25.262]                   }
[10:26:25.262]                   options(future.plan = NULL)
[10:26:25.262]                   if (is.na(NA_character_)) 
[10:26:25.262]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:25.262]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:25.262]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:25.262]                   {
[10:26:25.262]                     future <- SequentialFuture(..., envir = envir)
[10:26:25.262]                     if (!future$lazy) 
[10:26:25.262]                       future <- run(future)
[10:26:25.262]                     invisible(future)
[10:26:25.262]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:25.262]                 }
[10:26:25.262]             }
[10:26:25.262]         }
[10:26:25.262]     })
[10:26:25.262]     if (TRUE) {
[10:26:25.262]         base::sink(type = "output", split = FALSE)
[10:26:25.262]         if (TRUE) {
[10:26:25.262]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:25.262]         }
[10:26:25.262]         else {
[10:26:25.262]             ...future.result["stdout"] <- base::list(NULL)
[10:26:25.262]         }
[10:26:25.262]         base::close(...future.stdout)
[10:26:25.262]         ...future.stdout <- NULL
[10:26:25.262]     }
[10:26:25.262]     ...future.result$conditions <- ...future.conditions
[10:26:25.262]     ...future.result$finished <- base::Sys.time()
[10:26:25.262]     ...future.result
[10:26:25.262] }
[10:26:25.264] assign_globals() ...
[10:26:25.264] List of 1
[10:26:25.264]  $ a: num 0
[10:26:25.264]  - attr(*, "where")=List of 1
[10:26:25.264]   ..$ a:<environment: R_EmptyEnv> 
[10:26:25.264]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:25.264]  - attr(*, "resolved")= logi FALSE
[10:26:25.264]  - attr(*, "total_size")= num 56
[10:26:25.268] - copied ‘a’ to environment
[10:26:25.269] assign_globals() ... done
[10:26:25.269] plan(): Setting new future strategy stack:
[10:26:25.269] List of future strategies:
[10:26:25.269] 1. sequential:
[10:26:25.269]    - args: function (..., envir = parent.frame())
[10:26:25.269]    - tweaked: FALSE
[10:26:25.269]    - call: NULL
[10:26:25.269] plan(): nbrOfWorkers() = 1
[10:26:25.270] plan(): Setting new future strategy stack:
[10:26:25.270] List of future strategies:
[10:26:25.270] 1. sequential:
[10:26:25.270]    - args: function (..., envir = parent.frame())
[10:26:25.270]    - tweaked: FALSE
[10:26:25.270]    - call: future::plan("sequential")
[10:26:25.270] plan(): nbrOfWorkers() = 1
[10:26:25.270] SequentialFuture started (and completed)
[1] 0
*** multisession() with globals and blocking
 - Creating multisession future #2 ...
[10:26:25.274] getGlobalsAndPackages() ...
[10:26:25.274] Searching for globals...
[10:26:25.275] - globals found: [2] ‘{’, ‘ii’
[10:26:25.275] Searching for globals ... DONE
[10:26:25.275] Resolving globals: FALSE
[10:26:25.275] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:25.276] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:26:25.276] - globals: [1] ‘ii’
[10:26:25.276] 
[10:26:25.276] getGlobalsAndPackages() ... DONE
 - Creating multisession future #1 ...
[10:26:25.279] getGlobalsAndPackages() ...
[10:26:25.280] Searching for globals...
[10:26:25.280] - globals found: [2] ‘{’, ‘ii’
[10:26:25.280] Searching for globals ... DONE
[10:26:25.280] Resolving globals: FALSE
[10:26:25.281] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:25.281] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:26:25.281] - globals: [1] ‘ii’
[10:26:25.281] 
[10:26:25.281] getGlobalsAndPackages() ... DONE
 - Resolving 2 multisession futures
[10:26:25.282] Packages needed by the future expression (n = 0): <none>
[10:26:25.282] Packages needed by future strategies (n = 0): <none>
[10:26:25.282] {
[10:26:25.282]     {
[10:26:25.282]         {
[10:26:25.282]             ...future.startTime <- base::Sys.time()
[10:26:25.282]             {
[10:26:25.282]                 {
[10:26:25.282]                   {
[10:26:25.282]                     base::local({
[10:26:25.282]                       has_future <- base::requireNamespace("future", 
[10:26:25.282]                         quietly = TRUE)
[10:26:25.282]                       if (has_future) {
[10:26:25.282]                         ns <- base::getNamespace("future")
[10:26:25.282]                         version <- ns[[".package"]][["version"]]
[10:26:25.282]                         if (is.null(version)) 
[10:26:25.282]                           version <- utils::packageVersion("future")
[10:26:25.282]                       }
[10:26:25.282]                       else {
[10:26:25.282]                         version <- NULL
[10:26:25.282]                       }
[10:26:25.282]                       if (!has_future || version < "1.8.0") {
[10:26:25.282]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:25.282]                           "", base::R.version$version.string), 
[10:26:25.282]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:25.282]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:25.282]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:25.282]                             "release", "version")], collapse = " "), 
[10:26:25.282]                           hostname = base::Sys.info()[["nodename"]])
[10:26:25.282]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:25.282]                           info)
[10:26:25.282]                         info <- base::paste(info, collapse = "; ")
[10:26:25.282]                         if (!has_future) {
[10:26:25.282]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:25.282]                             info)
[10:26:25.282]                         }
[10:26:25.282]                         else {
[10:26:25.282]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:25.282]                             info, version)
[10:26:25.282]                         }
[10:26:25.282]                         base::stop(msg)
[10:26:25.282]                       }
[10:26:25.282]                     })
[10:26:25.282]                   }
[10:26:25.282]                   options(future.plan = NULL)
[10:26:25.282]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:25.282]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:25.282]                 }
[10:26:25.282]                 ...future.workdir <- getwd()
[10:26:25.282]             }
[10:26:25.282]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:25.282]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:25.282]         }
[10:26:25.282]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:25.282]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:25.282]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:25.282]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:25.282]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:25.282]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:25.282]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:25.282]             base::names(...future.oldOptions))
[10:26:25.282]     }
[10:26:25.282]     if (FALSE) {
[10:26:25.282]     }
[10:26:25.282]     else {
[10:26:25.282]         if (TRUE) {
[10:26:25.282]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:25.282]                 open = "w")
[10:26:25.282]         }
[10:26:25.282]         else {
[10:26:25.282]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:25.282]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:25.282]         }
[10:26:25.282]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:25.282]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:25.282]             base::sink(type = "output", split = FALSE)
[10:26:25.282]             base::close(...future.stdout)
[10:26:25.282]         }, add = TRUE)
[10:26:25.282]     }
[10:26:25.282]     ...future.frame <- base::sys.nframe()
[10:26:25.282]     ...future.conditions <- base::list()
[10:26:25.282]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:25.282]     if (FALSE) {
[10:26:25.282]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:25.282]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:25.282]     }
[10:26:25.282]     ...future.result <- base::tryCatch({
[10:26:25.282]         base::withCallingHandlers({
[10:26:25.282]             ...future.value <- base::withVisible(base::local({
[10:26:25.282]                 ii
[10:26:25.282]             }))
[10:26:25.282]             future::FutureResult(value = ...future.value$value, 
[10:26:25.282]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:25.282]                   ...future.rng), globalenv = if (FALSE) 
[10:26:25.282]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:25.282]                     ...future.globalenv.names))
[10:26:25.282]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:25.282]         }, condition = base::local({
[10:26:25.282]             c <- base::c
[10:26:25.282]             inherits <- base::inherits
[10:26:25.282]             invokeRestart <- base::invokeRestart
[10:26:25.282]             length <- base::length
[10:26:25.282]             list <- base::list
[10:26:25.282]             seq.int <- base::seq.int
[10:26:25.282]             signalCondition <- base::signalCondition
[10:26:25.282]             sys.calls <- base::sys.calls
[10:26:25.282]             `[[` <- base::`[[`
[10:26:25.282]             `+` <- base::`+`
[10:26:25.282]             `<<-` <- base::`<<-`
[10:26:25.282]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:25.282]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:25.282]                   3L)]
[10:26:25.282]             }
[10:26:25.282]             function(cond) {
[10:26:25.282]                 is_error <- inherits(cond, "error")
[10:26:25.282]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:25.282]                   NULL)
[10:26:25.282]                 if (is_error) {
[10:26:25.282]                   sessionInformation <- function() {
[10:26:25.282]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:25.282]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:25.282]                       search = base::search(), system = base::Sys.info())
[10:26:25.282]                   }
[10:26:25.282]                   ...future.conditions[[length(...future.conditions) + 
[10:26:25.282]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:25.282]                     cond$call), session = sessionInformation(), 
[10:26:25.282]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:25.282]                   signalCondition(cond)
[10:26:25.282]                 }
[10:26:25.282]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:25.282]                 "immediateCondition"))) {
[10:26:25.282]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:25.282]                   ...future.conditions[[length(...future.conditions) + 
[10:26:25.282]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:25.282]                   if (TRUE && !signal) {
[10:26:25.282]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:25.282]                     {
[10:26:25.282]                       inherits <- base::inherits
[10:26:25.282]                       invokeRestart <- base::invokeRestart
[10:26:25.282]                       is.null <- base::is.null
[10:26:25.282]                       muffled <- FALSE
[10:26:25.282]                       if (inherits(cond, "message")) {
[10:26:25.282]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:25.282]                         if (muffled) 
[10:26:25.282]                           invokeRestart("muffleMessage")
[10:26:25.282]                       }
[10:26:25.282]                       else if (inherits(cond, "warning")) {
[10:26:25.282]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:25.282]                         if (muffled) 
[10:26:25.282]                           invokeRestart("muffleWarning")
[10:26:25.282]                       }
[10:26:25.282]                       else if (inherits(cond, "condition")) {
[10:26:25.282]                         if (!is.null(pattern)) {
[10:26:25.282]                           computeRestarts <- base::computeRestarts
[10:26:25.282]                           grepl <- base::grepl
[10:26:25.282]                           restarts <- computeRestarts(cond)
[10:26:25.282]                           for (restart in restarts) {
[10:26:25.282]                             name <- restart$name
[10:26:25.282]                             if (is.null(name)) 
[10:26:25.282]                               next
[10:26:25.282]                             if (!grepl(pattern, name)) 
[10:26:25.282]                               next
[10:26:25.282]                             invokeRestart(restart)
[10:26:25.282]                             muffled <- TRUE
[10:26:25.282]                             break
[10:26:25.282]                           }
[10:26:25.282]                         }
[10:26:25.282]                       }
[10:26:25.282]                       invisible(muffled)
[10:26:25.282]                     }
[10:26:25.282]                     muffleCondition(cond, pattern = "^muffle")
[10:26:25.282]                   }
[10:26:25.282]                 }
[10:26:25.282]                 else {
[10:26:25.282]                   if (TRUE) {
[10:26:25.282]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:25.282]                     {
[10:26:25.282]                       inherits <- base::inherits
[10:26:25.282]                       invokeRestart <- base::invokeRestart
[10:26:25.282]                       is.null <- base::is.null
[10:26:25.282]                       muffled <- FALSE
[10:26:25.282]                       if (inherits(cond, "message")) {
[10:26:25.282]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:25.282]                         if (muffled) 
[10:26:25.282]                           invokeRestart("muffleMessage")
[10:26:25.282]                       }
[10:26:25.282]                       else if (inherits(cond, "warning")) {
[10:26:25.282]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:25.282]                         if (muffled) 
[10:26:25.282]                           invokeRestart("muffleWarning")
[10:26:25.282]                       }
[10:26:25.282]                       else if (inherits(cond, "condition")) {
[10:26:25.282]                         if (!is.null(pattern)) {
[10:26:25.282]                           computeRestarts <- base::computeRestarts
[10:26:25.282]                           grepl <- base::grepl
[10:26:25.282]                           restarts <- computeRestarts(cond)
[10:26:25.282]                           for (restart in restarts) {
[10:26:25.282]                             name <- restart$name
[10:26:25.282]                             if (is.null(name)) 
[10:26:25.282]                               next
[10:26:25.282]                             if (!grepl(pattern, name)) 
[10:26:25.282]                               next
[10:26:25.282]                             invokeRestart(restart)
[10:26:25.282]                             muffled <- TRUE
[10:26:25.282]                             break
[10:26:25.282]                           }
[10:26:25.282]                         }
[10:26:25.282]                       }
[10:26:25.282]                       invisible(muffled)
[10:26:25.282]                     }
[10:26:25.282]                     muffleCondition(cond, pattern = "^muffle")
[10:26:25.282]                   }
[10:26:25.282]                 }
[10:26:25.282]             }
[10:26:25.282]         }))
[10:26:25.282]     }, error = function(ex) {
[10:26:25.282]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:25.282]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:25.282]                 ...future.rng), started = ...future.startTime, 
[10:26:25.282]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:25.282]             version = "1.8"), class = "FutureResult")
[10:26:25.282]     }, finally = {
[10:26:25.282]         if (!identical(...future.workdir, getwd())) 
[10:26:25.282]             setwd(...future.workdir)
[10:26:25.282]         {
[10:26:25.282]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:25.282]                 ...future.oldOptions$nwarnings <- NULL
[10:26:25.282]             }
[10:26:25.282]             base::options(...future.oldOptions)
[10:26:25.282]             if (.Platform$OS.type == "windows") {
[10:26:25.282]                 old_names <- names(...future.oldEnvVars)
[10:26:25.282]                 envs <- base::Sys.getenv()
[10:26:25.282]                 names <- names(envs)
[10:26:25.282]                 common <- intersect(names, old_names)
[10:26:25.282]                 added <- setdiff(names, old_names)
[10:26:25.282]                 removed <- setdiff(old_names, names)
[10:26:25.282]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:25.282]                   envs[common]]
[10:26:25.282]                 NAMES <- toupper(changed)
[10:26:25.282]                 args <- list()
[10:26:25.282]                 for (kk in seq_along(NAMES)) {
[10:26:25.282]                   name <- changed[[kk]]
[10:26:25.282]                   NAME <- NAMES[[kk]]
[10:26:25.282]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:25.282]                     next
[10:26:25.282]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:25.282]                 }
[10:26:25.282]                 NAMES <- toupper(added)
[10:26:25.282]                 for (kk in seq_along(NAMES)) {
[10:26:25.282]                   name <- added[[kk]]
[10:26:25.282]                   NAME <- NAMES[[kk]]
[10:26:25.282]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:25.282]                     next
[10:26:25.282]                   args[[name]] <- ""
[10:26:25.282]                 }
[10:26:25.282]                 NAMES <- toupper(removed)
[10:26:25.282]                 for (kk in seq_along(NAMES)) {
[10:26:25.282]                   name <- removed[[kk]]
[10:26:25.282]                   NAME <- NAMES[[kk]]
[10:26:25.282]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:25.282]                     next
[10:26:25.282]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:25.282]                 }
[10:26:25.282]                 if (length(args) > 0) 
[10:26:25.282]                   base::do.call(base::Sys.setenv, args = args)
[10:26:25.282]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:25.282]             }
[10:26:25.282]             else {
[10:26:25.282]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:25.282]             }
[10:26:25.282]             {
[10:26:25.282]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:25.282]                   0L) {
[10:26:25.282]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:25.282]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:25.282]                   base::options(opts)
[10:26:25.282]                 }
[10:26:25.282]                 {
[10:26:25.282]                   {
[10:26:25.282]                     NULL
[10:26:25.282]                     RNGkind("Mersenne-Twister")
[10:26:25.282]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:25.282]                       inherits = FALSE)
[10:26:25.282]                   }
[10:26:25.282]                   options(future.plan = NULL)
[10:26:25.282]                   if (is.na(NA_character_)) 
[10:26:25.282]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:25.282]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:25.282]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:25.282]                   {
[10:26:25.282]                     future <- SequentialFuture(..., envir = envir)
[10:26:25.282]                     if (!future$lazy) 
[10:26:25.282]                       future <- run(future)
[10:26:25.282]                     invisible(future)
[10:26:25.282]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:25.282]                 }
[10:26:25.282]             }
[10:26:25.282]         }
[10:26:25.282]     })
[10:26:25.282]     if (TRUE) {
[10:26:25.282]         base::sink(type = "output", split = FALSE)
[10:26:25.282]         if (TRUE) {
[10:26:25.282]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:25.282]         }
[10:26:25.282]         else {
[10:26:25.282]             ...future.result["stdout"] <- base::list(NULL)
[10:26:25.282]         }
[10:26:25.282]         base::close(...future.stdout)
[10:26:25.282]         ...future.stdout <- NULL
[10:26:25.282]     }
[10:26:25.282]     ...future.result$conditions <- ...future.conditions
[10:26:25.282]     ...future.result$finished <- base::Sys.time()
[10:26:25.282]     ...future.result
[10:26:25.282] }
[10:26:25.284] assign_globals() ...
[10:26:25.284] List of 1
[10:26:25.284]  $ ii: int 1
[10:26:25.284]  - attr(*, "where")=List of 1
[10:26:25.284]   ..$ ii:<environment: R_EmptyEnv> 
[10:26:25.284]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:25.284]  - attr(*, "resolved")= logi FALSE
[10:26:25.284]  - attr(*, "total_size")= num 56
[10:26:25.286] - copied ‘ii’ to environment
[10:26:25.286] assign_globals() ... done
[10:26:25.287] plan(): Setting new future strategy stack:
[10:26:25.287] List of future strategies:
[10:26:25.287] 1. sequential:
[10:26:25.287]    - args: function (..., envir = parent.frame())
[10:26:25.287]    - tweaked: FALSE
[10:26:25.287]    - call: NULL
[10:26:25.287] plan(): nbrOfWorkers() = 1
[10:26:25.288] plan(): Setting new future strategy stack:
[10:26:25.288] List of future strategies:
[10:26:25.288] 1. sequential:
[10:26:25.288]    - args: function (..., envir = parent.frame())
[10:26:25.288]    - tweaked: FALSE
[10:26:25.288]    - call: future::plan("sequential")
[10:26:25.288] plan(): nbrOfWorkers() = 1
[10:26:25.288] SequentialFuture started (and completed)
[10:26:25.289] Packages needed by the future expression (n = 0): <none>
[10:26:25.289] Packages needed by future strategies (n = 0): <none>
[10:26:25.289] {
[10:26:25.289]     {
[10:26:25.289]         {
[10:26:25.289]             ...future.startTime <- base::Sys.time()
[10:26:25.289]             {
[10:26:25.289]                 {
[10:26:25.289]                   {
[10:26:25.289]                     base::local({
[10:26:25.289]                       has_future <- base::requireNamespace("future", 
[10:26:25.289]                         quietly = TRUE)
[10:26:25.289]                       if (has_future) {
[10:26:25.289]                         ns <- base::getNamespace("future")
[10:26:25.289]                         version <- ns[[".package"]][["version"]]
[10:26:25.289]                         if (is.null(version)) 
[10:26:25.289]                           version <- utils::packageVersion("future")
[10:26:25.289]                       }
[10:26:25.289]                       else {
[10:26:25.289]                         version <- NULL
[10:26:25.289]                       }
[10:26:25.289]                       if (!has_future || version < "1.8.0") {
[10:26:25.289]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:25.289]                           "", base::R.version$version.string), 
[10:26:25.289]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:25.289]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:25.289]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:25.289]                             "release", "version")], collapse = " "), 
[10:26:25.289]                           hostname = base::Sys.info()[["nodename"]])
[10:26:25.289]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:25.289]                           info)
[10:26:25.289]                         info <- base::paste(info, collapse = "; ")
[10:26:25.289]                         if (!has_future) {
[10:26:25.289]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:25.289]                             info)
[10:26:25.289]                         }
[10:26:25.289]                         else {
[10:26:25.289]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:25.289]                             info, version)
[10:26:25.289]                         }
[10:26:25.289]                         base::stop(msg)
[10:26:25.289]                       }
[10:26:25.289]                     })
[10:26:25.289]                   }
[10:26:25.289]                   options(future.plan = NULL)
[10:26:25.289]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:25.289]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:25.289]                 }
[10:26:25.289]                 ...future.workdir <- getwd()
[10:26:25.289]             }
[10:26:25.289]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:25.289]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:25.289]         }
[10:26:25.289]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:25.289]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:25.289]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:25.289]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:25.289]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:25.289]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:25.289]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:25.289]             base::names(...future.oldOptions))
[10:26:25.289]     }
[10:26:25.289]     if (FALSE) {
[10:26:25.289]     }
[10:26:25.289]     else {
[10:26:25.289]         if (TRUE) {
[10:26:25.289]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:25.289]                 open = "w")
[10:26:25.289]         }
[10:26:25.289]         else {
[10:26:25.289]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:25.289]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:25.289]         }
[10:26:25.289]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:25.289]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:25.289]             base::sink(type = "output", split = FALSE)
[10:26:25.289]             base::close(...future.stdout)
[10:26:25.289]         }, add = TRUE)
[10:26:25.289]     }
[10:26:25.289]     ...future.frame <- base::sys.nframe()
[10:26:25.289]     ...future.conditions <- base::list()
[10:26:25.289]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:25.289]     if (FALSE) {
[10:26:25.289]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:25.289]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:25.289]     }
[10:26:25.289]     ...future.result <- base::tryCatch({
[10:26:25.289]         base::withCallingHandlers({
[10:26:25.289]             ...future.value <- base::withVisible(base::local({
[10:26:25.289]                 ii
[10:26:25.289]             }))
[10:26:25.289]             future::FutureResult(value = ...future.value$value, 
[10:26:25.289]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:25.289]                   ...future.rng), globalenv = if (FALSE) 
[10:26:25.289]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:25.289]                     ...future.globalenv.names))
[10:26:25.289]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:25.289]         }, condition = base::local({
[10:26:25.289]             c <- base::c
[10:26:25.289]             inherits <- base::inherits
[10:26:25.289]             invokeRestart <- base::invokeRestart
[10:26:25.289]             length <- base::length
[10:26:25.289]             list <- base::list
[10:26:25.289]             seq.int <- base::seq.int
[10:26:25.289]             signalCondition <- base::signalCondition
[10:26:25.289]             sys.calls <- base::sys.calls
[10:26:25.289]             `[[` <- base::`[[`
[10:26:25.289]             `+` <- base::`+`
[10:26:25.289]             `<<-` <- base::`<<-`
[10:26:25.289]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:25.289]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:25.289]                   3L)]
[10:26:25.289]             }
[10:26:25.289]             function(cond) {
[10:26:25.289]                 is_error <- inherits(cond, "error")
[10:26:25.289]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:25.289]                   NULL)
[10:26:25.289]                 if (is_error) {
[10:26:25.289]                   sessionInformation <- function() {
[10:26:25.289]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:25.289]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:25.289]                       search = base::search(), system = base::Sys.info())
[10:26:25.289]                   }
[10:26:25.289]                   ...future.conditions[[length(...future.conditions) + 
[10:26:25.289]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:25.289]                     cond$call), session = sessionInformation(), 
[10:26:25.289]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:25.289]                   signalCondition(cond)
[10:26:25.289]                 }
[10:26:25.289]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:25.289]                 "immediateCondition"))) {
[10:26:25.289]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:25.289]                   ...future.conditions[[length(...future.conditions) + 
[10:26:25.289]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:25.289]                   if (TRUE && !signal) {
[10:26:25.289]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:25.289]                     {
[10:26:25.289]                       inherits <- base::inherits
[10:26:25.289]                       invokeRestart <- base::invokeRestart
[10:26:25.289]                       is.null <- base::is.null
[10:26:25.289]                       muffled <- FALSE
[10:26:25.289]                       if (inherits(cond, "message")) {
[10:26:25.289]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:25.289]                         if (muffled) 
[10:26:25.289]                           invokeRestart("muffleMessage")
[10:26:25.289]                       }
[10:26:25.289]                       else if (inherits(cond, "warning")) {
[10:26:25.289]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:25.289]                         if (muffled) 
[10:26:25.289]                           invokeRestart("muffleWarning")
[10:26:25.289]                       }
[10:26:25.289]                       else if (inherits(cond, "condition")) {
[10:26:25.289]                         if (!is.null(pattern)) {
[10:26:25.289]                           computeRestarts <- base::computeRestarts
[10:26:25.289]                           grepl <- base::grepl
[10:26:25.289]                           restarts <- computeRestarts(cond)
[10:26:25.289]                           for (restart in restarts) {
[10:26:25.289]                             name <- restart$name
[10:26:25.289]                             if (is.null(name)) 
[10:26:25.289]                               next
[10:26:25.289]                             if (!grepl(pattern, name)) 
[10:26:25.289]                               next
[10:26:25.289]                             invokeRestart(restart)
[10:26:25.289]                             muffled <- TRUE
[10:26:25.289]                             break
[10:26:25.289]                           }
[10:26:25.289]                         }
[10:26:25.289]                       }
[10:26:25.289]                       invisible(muffled)
[10:26:25.289]                     }
[10:26:25.289]                     muffleCondition(cond, pattern = "^muffle")
[10:26:25.289]                   }
[10:26:25.289]                 }
[10:26:25.289]                 else {
[10:26:25.289]                   if (TRUE) {
[10:26:25.289]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:25.289]                     {
[10:26:25.289]                       inherits <- base::inherits
[10:26:25.289]                       invokeRestart <- base::invokeRestart
[10:26:25.289]                       is.null <- base::is.null
[10:26:25.289]                       muffled <- FALSE
[10:26:25.289]                       if (inherits(cond, "message")) {
[10:26:25.289]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:25.289]                         if (muffled) 
[10:26:25.289]                           invokeRestart("muffleMessage")
[10:26:25.289]                       }
[10:26:25.289]                       else if (inherits(cond, "warning")) {
[10:26:25.289]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:25.289]                         if (muffled) 
[10:26:25.289]                           invokeRestart("muffleWarning")
[10:26:25.289]                       }
[10:26:25.289]                       else if (inherits(cond, "condition")) {
[10:26:25.289]                         if (!is.null(pattern)) {
[10:26:25.289]                           computeRestarts <- base::computeRestarts
[10:26:25.289]                           grepl <- base::grepl
[10:26:25.289]                           restarts <- computeRestarts(cond)
[10:26:25.289]                           for (restart in restarts) {
[10:26:25.289]                             name <- restart$name
[10:26:25.289]                             if (is.null(name)) 
[10:26:25.289]                               next
[10:26:25.289]                             if (!grepl(pattern, name)) 
[10:26:25.289]                               next
[10:26:25.289]                             invokeRestart(restart)
[10:26:25.289]                             muffled <- TRUE
[10:26:25.289]                             break
[10:26:25.289]                           }
[10:26:25.289]                         }
[10:26:25.289]                       }
[10:26:25.289]                       invisible(muffled)
[10:26:25.289]                     }
[10:26:25.289]                     muffleCondition(cond, pattern = "^muffle")
[10:26:25.289]                   }
[10:26:25.289]                 }
[10:26:25.289]             }
[10:26:25.289]         }))
[10:26:25.289]     }, error = function(ex) {
[10:26:25.289]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:25.289]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:25.289]                 ...future.rng), started = ...future.startTime, 
[10:26:25.289]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:25.289]             version = "1.8"), class = "FutureResult")
[10:26:25.289]     }, finally = {
[10:26:25.289]         if (!identical(...future.workdir, getwd())) 
[10:26:25.289]             setwd(...future.workdir)
[10:26:25.289]         {
[10:26:25.289]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:25.289]                 ...future.oldOptions$nwarnings <- NULL
[10:26:25.289]             }
[10:26:25.289]             base::options(...future.oldOptions)
[10:26:25.289]             if (.Platform$OS.type == "windows") {
[10:26:25.289]                 old_names <- names(...future.oldEnvVars)
[10:26:25.289]                 envs <- base::Sys.getenv()
[10:26:25.289]                 names <- names(envs)
[10:26:25.289]                 common <- intersect(names, old_names)
[10:26:25.289]                 added <- setdiff(names, old_names)
[10:26:25.289]                 removed <- setdiff(old_names, names)
[10:26:25.289]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:25.289]                   envs[common]]
[10:26:25.289]                 NAMES <- toupper(changed)
[10:26:25.289]                 args <- list()
[10:26:25.289]                 for (kk in seq_along(NAMES)) {
[10:26:25.289]                   name <- changed[[kk]]
[10:26:25.289]                   NAME <- NAMES[[kk]]
[10:26:25.289]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:25.289]                     next
[10:26:25.289]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:25.289]                 }
[10:26:25.289]                 NAMES <- toupper(added)
[10:26:25.289]                 for (kk in seq_along(NAMES)) {
[10:26:25.289]                   name <- added[[kk]]
[10:26:25.289]                   NAME <- NAMES[[kk]]
[10:26:25.289]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:25.289]                     next
[10:26:25.289]                   args[[name]] <- ""
[10:26:25.289]                 }
[10:26:25.289]                 NAMES <- toupper(removed)
[10:26:25.289]                 for (kk in seq_along(NAMES)) {
[10:26:25.289]                   name <- removed[[kk]]
[10:26:25.289]                   NAME <- NAMES[[kk]]
[10:26:25.289]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:25.289]                     next
[10:26:25.289]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:25.289]                 }
[10:26:25.289]                 if (length(args) > 0) 
[10:26:25.289]                   base::do.call(base::Sys.setenv, args = args)
[10:26:25.289]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:25.289]             }
[10:26:25.289]             else {
[10:26:25.289]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:25.289]             }
[10:26:25.289]             {
[10:26:25.289]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:25.289]                   0L) {
[10:26:25.289]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:25.289]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:25.289]                   base::options(opts)
[10:26:25.289]                 }
[10:26:25.289]                 {
[10:26:25.289]                   {
[10:26:25.289]                     NULL
[10:26:25.289]                     RNGkind("Mersenne-Twister")
[10:26:25.289]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:25.289]                       inherits = FALSE)
[10:26:25.289]                   }
[10:26:25.289]                   options(future.plan = NULL)
[10:26:25.289]                   if (is.na(NA_character_)) 
[10:26:25.289]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:25.289]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:25.289]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:25.289]                   {
[10:26:25.289]                     future <- SequentialFuture(..., envir = envir)
[10:26:25.289]                     if (!future$lazy) 
[10:26:25.289]                       future <- run(future)
[10:26:25.289]                     invisible(future)
[10:26:25.289]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:25.289]                 }
[10:26:25.289]             }
[10:26:25.289]         }
[10:26:25.289]     })
[10:26:25.289]     if (TRUE) {
[10:26:25.289]         base::sink(type = "output", split = FALSE)
[10:26:25.289]         if (TRUE) {
[10:26:25.289]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:25.289]         }
[10:26:25.289]         else {
[10:26:25.289]             ...future.result["stdout"] <- base::list(NULL)
[10:26:25.289]         }
[10:26:25.289]         base::close(...future.stdout)
[10:26:25.289]         ...future.stdout <- NULL
[10:26:25.289]     }
[10:26:25.289]     ...future.result$conditions <- ...future.conditions
[10:26:25.289]     ...future.result$finished <- base::Sys.time()
[10:26:25.289]     ...future.result
[10:26:25.289] }
[10:26:25.291] assign_globals() ...
[10:26:25.291] List of 1
[10:26:25.291]  $ ii: int 2
[10:26:25.291]  - attr(*, "where")=List of 1
[10:26:25.291]   ..$ ii:<environment: R_EmptyEnv> 
[10:26:25.291]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:25.291]  - attr(*, "resolved")= logi FALSE
[10:26:25.291]  - attr(*, "total_size")= num 56
[10:26:25.293] - copied ‘ii’ to environment
[10:26:25.293] assign_globals() ... done
[10:26:25.293] plan(): Setting new future strategy stack:
[10:26:25.293] List of future strategies:
[10:26:25.293] 1. sequential:
[10:26:25.293]    - args: function (..., envir = parent.frame())
[10:26:25.293]    - tweaked: FALSE
[10:26:25.293]    - call: NULL
[10:26:25.294] plan(): nbrOfWorkers() = 1
[10:26:25.294] plan(): Setting new future strategy stack:
[10:26:25.294] List of future strategies:
[10:26:25.294] 1. sequential:
[10:26:25.294]    - args: function (..., envir = parent.frame())
[10:26:25.294]    - tweaked: FALSE
[10:26:25.294]    - call: future::plan("sequential")
[10:26:25.295] plan(): nbrOfWorkers() = 1
[10:26:25.295] SequentialFuture started (and completed)
*** multisession() - workers inherit .libPaths()
[10:26:25.295] getGlobalsAndPackages() ...
[10:26:25.295] Searching for globals...
[10:26:25.296] - globals found: [1] ‘.libPaths’
[10:26:25.296] Searching for globals ... DONE
[10:26:25.296] Resolving globals: FALSE
[10:26:25.296] 
[10:26:25.296] 
[10:26:25.296] getGlobalsAndPackages() ... DONE
[10:26:25.297] run() for ‘Future’ ...
[10:26:25.297] - state: ‘created’
[10:26:25.297] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:25.297] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:25.297] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:25.297]   - Field: ‘label’
[10:26:25.299]   - Field: ‘local’
[10:26:25.299]   - Field: ‘owner’
[10:26:25.299]   - Field: ‘envir’
[10:26:25.299]   - Field: ‘packages’
[10:26:25.300]   - Field: ‘gc’
[10:26:25.300]   - Field: ‘conditions’
[10:26:25.300]   - Field: ‘expr’
[10:26:25.300]   - Field: ‘uuid’
[10:26:25.300]   - Field: ‘seed’
[10:26:25.300]   - Field: ‘version’
[10:26:25.300]   - Field: ‘result’
[10:26:25.300]   - Field: ‘asynchronous’
[10:26:25.300]   - Field: ‘calls’
[10:26:25.300]   - Field: ‘globals’
[10:26:25.300]   - Field: ‘stdout’
[10:26:25.301]   - Field: ‘earlySignal’
[10:26:25.301]   - Field: ‘lazy’
[10:26:25.301]   - Field: ‘state’
[10:26:25.301] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:25.301] - Launch lazy future ...
[10:26:25.301] Packages needed by the future expression (n = 0): <none>
[10:26:25.301] Packages needed by future strategies (n = 0): <none>
[10:26:25.302] {
[10:26:25.302]     {
[10:26:25.302]         {
[10:26:25.302]             ...future.startTime <- base::Sys.time()
[10:26:25.302]             {
[10:26:25.302]                 {
[10:26:25.302]                   {
[10:26:25.302]                     base::local({
[10:26:25.302]                       has_future <- base::requireNamespace("future", 
[10:26:25.302]                         quietly = TRUE)
[10:26:25.302]                       if (has_future) {
[10:26:25.302]                         ns <- base::getNamespace("future")
[10:26:25.302]                         version <- ns[[".package"]][["version"]]
[10:26:25.302]                         if (is.null(version)) 
[10:26:25.302]                           version <- utils::packageVersion("future")
[10:26:25.302]                       }
[10:26:25.302]                       else {
[10:26:25.302]                         version <- NULL
[10:26:25.302]                       }
[10:26:25.302]                       if (!has_future || version < "1.8.0") {
[10:26:25.302]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:25.302]                           "", base::R.version$version.string), 
[10:26:25.302]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:25.302]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:25.302]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:25.302]                             "release", "version")], collapse = " "), 
[10:26:25.302]                           hostname = base::Sys.info()[["nodename"]])
[10:26:25.302]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:25.302]                           info)
[10:26:25.302]                         info <- base::paste(info, collapse = "; ")
[10:26:25.302]                         if (!has_future) {
[10:26:25.302]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:25.302]                             info)
[10:26:25.302]                         }
[10:26:25.302]                         else {
[10:26:25.302]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:25.302]                             info, version)
[10:26:25.302]                         }
[10:26:25.302]                         base::stop(msg)
[10:26:25.302]                       }
[10:26:25.302]                     })
[10:26:25.302]                   }
[10:26:25.302]                   options(future.plan = NULL)
[10:26:25.302]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:25.302]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:25.302]                 }
[10:26:25.302]                 ...future.workdir <- getwd()
[10:26:25.302]             }
[10:26:25.302]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:25.302]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:25.302]         }
[10:26:25.302]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:25.302]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:25.302]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:25.302]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:25.302]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:25.302]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:25.302]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:25.302]             base::names(...future.oldOptions))
[10:26:25.302]     }
[10:26:25.302]     if (FALSE) {
[10:26:25.302]     }
[10:26:25.302]     else {
[10:26:25.302]         if (TRUE) {
[10:26:25.302]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:25.302]                 open = "w")
[10:26:25.302]         }
[10:26:25.302]         else {
[10:26:25.302]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:25.302]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:25.302]         }
[10:26:25.302]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:25.302]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:25.302]             base::sink(type = "output", split = FALSE)
[10:26:25.302]             base::close(...future.stdout)
[10:26:25.302]         }, add = TRUE)
[10:26:25.302]     }
[10:26:25.302]     ...future.frame <- base::sys.nframe()
[10:26:25.302]     ...future.conditions <- base::list()
[10:26:25.302]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:25.302]     if (FALSE) {
[10:26:25.302]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:25.302]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:25.302]     }
[10:26:25.302]     ...future.result <- base::tryCatch({
[10:26:25.302]         base::withCallingHandlers({
[10:26:25.302]             ...future.value <- base::withVisible(base::local(.libPaths()))
[10:26:25.302]             future::FutureResult(value = ...future.value$value, 
[10:26:25.302]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:25.302]                   ...future.rng), globalenv = if (FALSE) 
[10:26:25.302]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:25.302]                     ...future.globalenv.names))
[10:26:25.302]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:25.302]         }, condition = base::local({
[10:26:25.302]             c <- base::c
[10:26:25.302]             inherits <- base::inherits
[10:26:25.302]             invokeRestart <- base::invokeRestart
[10:26:25.302]             length <- base::length
[10:26:25.302]             list <- base::list
[10:26:25.302]             seq.int <- base::seq.int
[10:26:25.302]             signalCondition <- base::signalCondition
[10:26:25.302]             sys.calls <- base::sys.calls
[10:26:25.302]             `[[` <- base::`[[`
[10:26:25.302]             `+` <- base::`+`
[10:26:25.302]             `<<-` <- base::`<<-`
[10:26:25.302]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:25.302]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:25.302]                   3L)]
[10:26:25.302]             }
[10:26:25.302]             function(cond) {
[10:26:25.302]                 is_error <- inherits(cond, "error")
[10:26:25.302]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:25.302]                   NULL)
[10:26:25.302]                 if (is_error) {
[10:26:25.302]                   sessionInformation <- function() {
[10:26:25.302]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:25.302]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:25.302]                       search = base::search(), system = base::Sys.info())
[10:26:25.302]                   }
[10:26:25.302]                   ...future.conditions[[length(...future.conditions) + 
[10:26:25.302]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:25.302]                     cond$call), session = sessionInformation(), 
[10:26:25.302]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:25.302]                   signalCondition(cond)
[10:26:25.302]                 }
[10:26:25.302]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:25.302]                 "immediateCondition"))) {
[10:26:25.302]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:25.302]                   ...future.conditions[[length(...future.conditions) + 
[10:26:25.302]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:25.302]                   if (TRUE && !signal) {
[10:26:25.302]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:25.302]                     {
[10:26:25.302]                       inherits <- base::inherits
[10:26:25.302]                       invokeRestart <- base::invokeRestart
[10:26:25.302]                       is.null <- base::is.null
[10:26:25.302]                       muffled <- FALSE
[10:26:25.302]                       if (inherits(cond, "message")) {
[10:26:25.302]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:25.302]                         if (muffled) 
[10:26:25.302]                           invokeRestart("muffleMessage")
[10:26:25.302]                       }
[10:26:25.302]                       else if (inherits(cond, "warning")) {
[10:26:25.302]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:25.302]                         if (muffled) 
[10:26:25.302]                           invokeRestart("muffleWarning")
[10:26:25.302]                       }
[10:26:25.302]                       else if (inherits(cond, "condition")) {
[10:26:25.302]                         if (!is.null(pattern)) {
[10:26:25.302]                           computeRestarts <- base::computeRestarts
[10:26:25.302]                           grepl <- base::grepl
[10:26:25.302]                           restarts <- computeRestarts(cond)
[10:26:25.302]                           for (restart in restarts) {
[10:26:25.302]                             name <- restart$name
[10:26:25.302]                             if (is.null(name)) 
[10:26:25.302]                               next
[10:26:25.302]                             if (!grepl(pattern, name)) 
[10:26:25.302]                               next
[10:26:25.302]                             invokeRestart(restart)
[10:26:25.302]                             muffled <- TRUE
[10:26:25.302]                             break
[10:26:25.302]                           }
[10:26:25.302]                         }
[10:26:25.302]                       }
[10:26:25.302]                       invisible(muffled)
[10:26:25.302]                     }
[10:26:25.302]                     muffleCondition(cond, pattern = "^muffle")
[10:26:25.302]                   }
[10:26:25.302]                 }
[10:26:25.302]                 else {
[10:26:25.302]                   if (TRUE) {
[10:26:25.302]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:25.302]                     {
[10:26:25.302]                       inherits <- base::inherits
[10:26:25.302]                       invokeRestart <- base::invokeRestart
[10:26:25.302]                       is.null <- base::is.null
[10:26:25.302]                       muffled <- FALSE
[10:26:25.302]                       if (inherits(cond, "message")) {
[10:26:25.302]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:25.302]                         if (muffled) 
[10:26:25.302]                           invokeRestart("muffleMessage")
[10:26:25.302]                       }
[10:26:25.302]                       else if (inherits(cond, "warning")) {
[10:26:25.302]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:25.302]                         if (muffled) 
[10:26:25.302]                           invokeRestart("muffleWarning")
[10:26:25.302]                       }
[10:26:25.302]                       else if (inherits(cond, "condition")) {
[10:26:25.302]                         if (!is.null(pattern)) {
[10:26:25.302]                           computeRestarts <- base::computeRestarts
[10:26:25.302]                           grepl <- base::grepl
[10:26:25.302]                           restarts <- computeRestarts(cond)
[10:26:25.302]                           for (restart in restarts) {
[10:26:25.302]                             name <- restart$name
[10:26:25.302]                             if (is.null(name)) 
[10:26:25.302]                               next
[10:26:25.302]                             if (!grepl(pattern, name)) 
[10:26:25.302]                               next
[10:26:25.302]                             invokeRestart(restart)
[10:26:25.302]                             muffled <- TRUE
[10:26:25.302]                             break
[10:26:25.302]                           }
[10:26:25.302]                         }
[10:26:25.302]                       }
[10:26:25.302]                       invisible(muffled)
[10:26:25.302]                     }
[10:26:25.302]                     muffleCondition(cond, pattern = "^muffle")
[10:26:25.302]                   }
[10:26:25.302]                 }
[10:26:25.302]             }
[10:26:25.302]         }))
[10:26:25.302]     }, error = function(ex) {
[10:26:25.302]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:25.302]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:25.302]                 ...future.rng), started = ...future.startTime, 
[10:26:25.302]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:25.302]             version = "1.8"), class = "FutureResult")
[10:26:25.302]     }, finally = {
[10:26:25.302]         if (!identical(...future.workdir, getwd())) 
[10:26:25.302]             setwd(...future.workdir)
[10:26:25.302]         {
[10:26:25.302]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:25.302]                 ...future.oldOptions$nwarnings <- NULL
[10:26:25.302]             }
[10:26:25.302]             base::options(...future.oldOptions)
[10:26:25.302]             if (.Platform$OS.type == "windows") {
[10:26:25.302]                 old_names <- names(...future.oldEnvVars)
[10:26:25.302]                 envs <- base::Sys.getenv()
[10:26:25.302]                 names <- names(envs)
[10:26:25.302]                 common <- intersect(names, old_names)
[10:26:25.302]                 added <- setdiff(names, old_names)
[10:26:25.302]                 removed <- setdiff(old_names, names)
[10:26:25.302]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:25.302]                   envs[common]]
[10:26:25.302]                 NAMES <- toupper(changed)
[10:26:25.302]                 args <- list()
[10:26:25.302]                 for (kk in seq_along(NAMES)) {
[10:26:25.302]                   name <- changed[[kk]]
[10:26:25.302]                   NAME <- NAMES[[kk]]
[10:26:25.302]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:25.302]                     next
[10:26:25.302]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:25.302]                 }
[10:26:25.302]                 NAMES <- toupper(added)
[10:26:25.302]                 for (kk in seq_along(NAMES)) {
[10:26:25.302]                   name <- added[[kk]]
[10:26:25.302]                   NAME <- NAMES[[kk]]
[10:26:25.302]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:25.302]                     next
[10:26:25.302]                   args[[name]] <- ""
[10:26:25.302]                 }
[10:26:25.302]                 NAMES <- toupper(removed)
[10:26:25.302]                 for (kk in seq_along(NAMES)) {
[10:26:25.302]                   name <- removed[[kk]]
[10:26:25.302]                   NAME <- NAMES[[kk]]
[10:26:25.302]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:25.302]                     next
[10:26:25.302]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:25.302]                 }
[10:26:25.302]                 if (length(args) > 0) 
[10:26:25.302]                   base::do.call(base::Sys.setenv, args = args)
[10:26:25.302]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:25.302]             }
[10:26:25.302]             else {
[10:26:25.302]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:25.302]             }
[10:26:25.302]             {
[10:26:25.302]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:25.302]                   0L) {
[10:26:25.302]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:25.302]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:25.302]                   base::options(opts)
[10:26:25.302]                 }
[10:26:25.302]                 {
[10:26:25.302]                   {
[10:26:25.302]                     NULL
[10:26:25.302]                     RNGkind("Mersenne-Twister")
[10:26:25.302]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:25.302]                       inherits = FALSE)
[10:26:25.302]                   }
[10:26:25.302]                   options(future.plan = NULL)
[10:26:25.302]                   if (is.na(NA_character_)) 
[10:26:25.302]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:25.302]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:25.302]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:25.302]                   {
[10:26:25.302]                     future <- SequentialFuture(..., envir = envir)
[10:26:25.302]                     if (!future$lazy) 
[10:26:25.302]                       future <- run(future)
[10:26:25.302]                     invisible(future)
[10:26:25.302]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:25.302]                 }
[10:26:25.302]             }
[10:26:25.302]         }
[10:26:25.302]     })
[10:26:25.302]     if (TRUE) {
[10:26:25.302]         base::sink(type = "output", split = FALSE)
[10:26:25.302]         if (TRUE) {
[10:26:25.302]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:25.302]         }
[10:26:25.302]         else {
[10:26:25.302]             ...future.result["stdout"] <- base::list(NULL)
[10:26:25.302]         }
[10:26:25.302]         base::close(...future.stdout)
[10:26:25.302]         ...future.stdout <- NULL
[10:26:25.302]     }
[10:26:25.302]     ...future.result$conditions <- ...future.conditions
[10:26:25.302]     ...future.result$finished <- base::Sys.time()
[10:26:25.302]     ...future.result
[10:26:25.302] }
[10:26:25.303] plan(): Setting new future strategy stack:
[10:26:25.303] List of future strategies:
[10:26:25.303] 1. sequential:
[10:26:25.303]    - args: function (..., envir = parent.frame())
[10:26:25.303]    - tweaked: FALSE
[10:26:25.303]    - call: NULL
[10:26:25.304] plan(): nbrOfWorkers() = 1
[10:26:25.304] plan(): Setting new future strategy stack:
[10:26:25.305] List of future strategies:
[10:26:25.305] 1. sequential:
[10:26:25.305]    - args: function (..., envir = parent.frame())
[10:26:25.305]    - tweaked: FALSE
[10:26:25.305]    - call: future::plan("sequential")
[10:26:25.305] plan(): nbrOfWorkers() = 1
[10:26:25.305] SequentialFuture started (and completed)
[10:26:25.305] - Launch lazy future ... done
[10:26:25.305] run() for ‘SequentialFuture’ ... done
List of 2
 $ main   : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
 $ workers: chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
*** multisession() and errors
[10:26:25.310] getGlobalsAndPackages() ...
[10:26:25.310] Searching for globals...
[10:26:25.311] - globals found: [2] ‘{’, ‘stop’
[10:26:25.311] Searching for globals ... DONE
[10:26:25.311] Resolving globals: FALSE
[10:26:25.311] 
[10:26:25.311] 
[10:26:25.311] getGlobalsAndPackages() ... DONE
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: TRUE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: b237ea00-048b-53bc-62d3-d50d6929ba00
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:25.312] Packages needed by the future expression (n = 0): <none>
[10:26:25.312] Packages needed by future strategies (n = 0): <none>
[10:26:25.312] {
[10:26:25.312]     {
[10:26:25.312]         {
[10:26:25.312]             ...future.startTime <- base::Sys.time()
[10:26:25.312]             {
[10:26:25.312]                 {
[10:26:25.312]                   {
[10:26:25.312]                     base::local({
[10:26:25.312]                       has_future <- base::requireNamespace("future", 
[10:26:25.312]                         quietly = TRUE)
[10:26:25.312]                       if (has_future) {
[10:26:25.312]                         ns <- base::getNamespace("future")
[10:26:25.312]                         version <- ns[[".package"]][["version"]]
[10:26:25.312]                         if (is.null(version)) 
[10:26:25.312]                           version <- utils::packageVersion("future")
[10:26:25.312]                       }
[10:26:25.312]                       else {
[10:26:25.312]                         version <- NULL
[10:26:25.312]                       }
[10:26:25.312]                       if (!has_future || version < "1.8.0") {
[10:26:25.312]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:25.312]                           "", base::R.version$version.string), 
[10:26:25.312]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:25.312]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:25.312]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:25.312]                             "release", "version")], collapse = " "), 
[10:26:25.312]                           hostname = base::Sys.info()[["nodename"]])
[10:26:25.312]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:25.312]                           info)
[10:26:25.312]                         info <- base::paste(info, collapse = "; ")
[10:26:25.312]                         if (!has_future) {
[10:26:25.312]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:25.312]                             info)
[10:26:25.312]                         }
[10:26:25.312]                         else {
[10:26:25.312]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:25.312]                             info, version)
[10:26:25.312]                         }
[10:26:25.312]                         base::stop(msg)
[10:26:25.312]                       }
[10:26:25.312]                     })
[10:26:25.312]                   }
[10:26:25.312]                   options(future.plan = NULL)
[10:26:25.312]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:25.312]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:25.312]                 }
[10:26:25.312]                 ...future.workdir <- getwd()
[10:26:25.312]             }
[10:26:25.312]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:25.312]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:25.312]         }
[10:26:25.312]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:25.312]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:25.312]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:25.312]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:25.312]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:25.312]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:25.312]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:25.312]             base::names(...future.oldOptions))
[10:26:25.312]     }
[10:26:25.312]     if (FALSE) {
[10:26:25.312]     }
[10:26:25.312]     else {
[10:26:25.312]         if (TRUE) {
[10:26:25.312]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:25.312]                 open = "w")
[10:26:25.312]         }
[10:26:25.312]         else {
[10:26:25.312]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:25.312]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:25.312]         }
[10:26:25.312]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:25.312]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:25.312]             base::sink(type = "output", split = FALSE)
[10:26:25.312]             base::close(...future.stdout)
[10:26:25.312]         }, add = TRUE)
[10:26:25.312]     }
[10:26:25.312]     ...future.frame <- base::sys.nframe()
[10:26:25.312]     ...future.conditions <- base::list()
[10:26:25.312]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:25.312]     if (FALSE) {
[10:26:25.312]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:25.312]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:25.312]     }
[10:26:25.312]     ...future.result <- base::tryCatch({
[10:26:25.312]         base::withCallingHandlers({
[10:26:25.312]             ...future.value <- base::withVisible(base::local({
[10:26:25.312]                 stop("Whoops!")
[10:26:25.312]                 1
[10:26:25.312]             }))
[10:26:25.312]             future::FutureResult(value = ...future.value$value, 
[10:26:25.312]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:25.312]                   ...future.rng), globalenv = if (FALSE) 
[10:26:25.312]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:25.312]                     ...future.globalenv.names))
[10:26:25.312]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:25.312]         }, condition = base::local({
[10:26:25.312]             c <- base::c
[10:26:25.312]             inherits <- base::inherits
[10:26:25.312]             invokeRestart <- base::invokeRestart
[10:26:25.312]             length <- base::length
[10:26:25.312]             list <- base::list
[10:26:25.312]             seq.int <- base::seq.int
[10:26:25.312]             signalCondition <- base::signalCondition
[10:26:25.312]             sys.calls <- base::sys.calls
[10:26:25.312]             `[[` <- base::`[[`
[10:26:25.312]             `+` <- base::`+`
[10:26:25.312]             `<<-` <- base::`<<-`
[10:26:25.312]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:25.312]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:25.312]                   3L)]
[10:26:25.312]             }
[10:26:25.312]             function(cond) {
[10:26:25.312]                 is_error <- inherits(cond, "error")
[10:26:25.312]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:25.312]                   NULL)
[10:26:25.312]                 if (is_error) {
[10:26:25.312]                   sessionInformation <- function() {
[10:26:25.312]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:25.312]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:25.312]                       search = base::search(), system = base::Sys.info())
[10:26:25.312]                   }
[10:26:25.312]                   ...future.conditions[[length(...future.conditions) + 
[10:26:25.312]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:25.312]                     cond$call), session = sessionInformation(), 
[10:26:25.312]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:25.312]                   signalCondition(cond)
[10:26:25.312]                 }
[10:26:25.312]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:25.312]                 "immediateCondition"))) {
[10:26:25.312]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:25.312]                   ...future.conditions[[length(...future.conditions) + 
[10:26:25.312]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:25.312]                   if (TRUE && !signal) {
[10:26:25.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:25.312]                     {
[10:26:25.312]                       inherits <- base::inherits
[10:26:25.312]                       invokeRestart <- base::invokeRestart
[10:26:25.312]                       is.null <- base::is.null
[10:26:25.312]                       muffled <- FALSE
[10:26:25.312]                       if (inherits(cond, "message")) {
[10:26:25.312]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:25.312]                         if (muffled) 
[10:26:25.312]                           invokeRestart("muffleMessage")
[10:26:25.312]                       }
[10:26:25.312]                       else if (inherits(cond, "warning")) {
[10:26:25.312]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:25.312]                         if (muffled) 
[10:26:25.312]                           invokeRestart("muffleWarning")
[10:26:25.312]                       }
[10:26:25.312]                       else if (inherits(cond, "condition")) {
[10:26:25.312]                         if (!is.null(pattern)) {
[10:26:25.312]                           computeRestarts <- base::computeRestarts
[10:26:25.312]                           grepl <- base::grepl
[10:26:25.312]                           restarts <- computeRestarts(cond)
[10:26:25.312]                           for (restart in restarts) {
[10:26:25.312]                             name <- restart$name
[10:26:25.312]                             if (is.null(name)) 
[10:26:25.312]                               next
[10:26:25.312]                             if (!grepl(pattern, name)) 
[10:26:25.312]                               next
[10:26:25.312]                             invokeRestart(restart)
[10:26:25.312]                             muffled <- TRUE
[10:26:25.312]                             break
[10:26:25.312]                           }
[10:26:25.312]                         }
[10:26:25.312]                       }
[10:26:25.312]                       invisible(muffled)
[10:26:25.312]                     }
[10:26:25.312]                     muffleCondition(cond, pattern = "^muffle")
[10:26:25.312]                   }
[10:26:25.312]                 }
[10:26:25.312]                 else {
[10:26:25.312]                   if (TRUE) {
[10:26:25.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:25.312]                     {
[10:26:25.312]                       inherits <- base::inherits
[10:26:25.312]                       invokeRestart <- base::invokeRestart
[10:26:25.312]                       is.null <- base::is.null
[10:26:25.312]                       muffled <- FALSE
[10:26:25.312]                       if (inherits(cond, "message")) {
[10:26:25.312]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:25.312]                         if (muffled) 
[10:26:25.312]                           invokeRestart("muffleMessage")
[10:26:25.312]                       }
[10:26:25.312]                       else if (inherits(cond, "warning")) {
[10:26:25.312]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:25.312]                         if (muffled) 
[10:26:25.312]                           invokeRestart("muffleWarning")
[10:26:25.312]                       }
[10:26:25.312]                       else if (inherits(cond, "condition")) {
[10:26:25.312]                         if (!is.null(pattern)) {
[10:26:25.312]                           computeRestarts <- base::computeRestarts
[10:26:25.312]                           grepl <- base::grepl
[10:26:25.312]                           restarts <- computeRestarts(cond)
[10:26:25.312]                           for (restart in restarts) {
[10:26:25.312]                             name <- restart$name
[10:26:25.312]                             if (is.null(name)) 
[10:26:25.312]                               next
[10:26:25.312]                             if (!grepl(pattern, name)) 
[10:26:25.312]                               next
[10:26:25.312]                             invokeRestart(restart)
[10:26:25.312]                             muffled <- TRUE
[10:26:25.312]                             break
[10:26:25.312]                           }
[10:26:25.312]                         }
[10:26:25.312]                       }
[10:26:25.312]                       invisible(muffled)
[10:26:25.312]                     }
[10:26:25.312]                     muffleCondition(cond, pattern = "^muffle")
[10:26:25.312]                   }
[10:26:25.312]                 }
[10:26:25.312]             }
[10:26:25.312]         }))
[10:26:25.312]     }, error = function(ex) {
[10:26:25.312]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:25.312]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:25.312]                 ...future.rng), started = ...future.startTime, 
[10:26:25.312]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:25.312]             version = "1.8"), class = "FutureResult")
[10:26:25.312]     }, finally = {
[10:26:25.312]         if (!identical(...future.workdir, getwd())) 
[10:26:25.312]             setwd(...future.workdir)
[10:26:25.312]         {
[10:26:25.312]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:25.312]                 ...future.oldOptions$nwarnings <- NULL
[10:26:25.312]             }
[10:26:25.312]             base::options(...future.oldOptions)
[10:26:25.312]             if (.Platform$OS.type == "windows") {
[10:26:25.312]                 old_names <- names(...future.oldEnvVars)
[10:26:25.312]                 envs <- base::Sys.getenv()
[10:26:25.312]                 names <- names(envs)
[10:26:25.312]                 common <- intersect(names, old_names)
[10:26:25.312]                 added <- setdiff(names, old_names)
[10:26:25.312]                 removed <- setdiff(old_names, names)
[10:26:25.312]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:25.312]                   envs[common]]
[10:26:25.312]                 NAMES <- toupper(changed)
[10:26:25.312]                 args <- list()
[10:26:25.312]                 for (kk in seq_along(NAMES)) {
[10:26:25.312]                   name <- changed[[kk]]
[10:26:25.312]                   NAME <- NAMES[[kk]]
[10:26:25.312]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:25.312]                     next
[10:26:25.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:25.312]                 }
[10:26:25.312]                 NAMES <- toupper(added)
[10:26:25.312]                 for (kk in seq_along(NAMES)) {
[10:26:25.312]                   name <- added[[kk]]
[10:26:25.312]                   NAME <- NAMES[[kk]]
[10:26:25.312]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:25.312]                     next
[10:26:25.312]                   args[[name]] <- ""
[10:26:25.312]                 }
[10:26:25.312]                 NAMES <- toupper(removed)
[10:26:25.312]                 for (kk in seq_along(NAMES)) {
[10:26:25.312]                   name <- removed[[kk]]
[10:26:25.312]                   NAME <- NAMES[[kk]]
[10:26:25.312]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:25.312]                     next
[10:26:25.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:25.312]                 }
[10:26:25.312]                 if (length(args) > 0) 
[10:26:25.312]                   base::do.call(base::Sys.setenv, args = args)
[10:26:25.312]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:25.312]             }
[10:26:25.312]             else {
[10:26:25.312]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:25.312]             }
[10:26:25.312]             {
[10:26:25.312]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:25.312]                   0L) {
[10:26:25.312]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:25.312]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:25.312]                   base::options(opts)
[10:26:25.312]                 }
[10:26:25.312]                 {
[10:26:25.312]                   {
[10:26:25.312]                     NULL
[10:26:25.312]                     RNGkind("Mersenne-Twister")
[10:26:25.312]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:25.312]                       inherits = FALSE)
[10:26:25.312]                   }
[10:26:25.312]                   options(future.plan = NULL)
[10:26:25.312]                   if (is.na(NA_character_)) 
[10:26:25.312]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:25.312]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:25.312]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:25.312]                   {
[10:26:25.312]                     future <- SequentialFuture(..., envir = envir)
[10:26:25.312]                     if (!future$lazy) 
[10:26:25.312]                       future <- run(future)
[10:26:25.312]                     invisible(future)
[10:26:25.312]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:25.312]                 }
[10:26:25.312]             }
[10:26:25.312]         }
[10:26:25.312]     })
[10:26:25.312]     if (TRUE) {
[10:26:25.312]         base::sink(type = "output", split = FALSE)
[10:26:25.312]         if (TRUE) {
[10:26:25.312]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:25.312]         }
[10:26:25.312]         else {
[10:26:25.312]             ...future.result["stdout"] <- base::list(NULL)
[10:26:25.312]         }
[10:26:25.312]         base::close(...future.stdout)
[10:26:25.312]         ...future.stdout <- NULL
[10:26:25.312]     }
[10:26:25.312]     ...future.result$conditions <- ...future.conditions
[10:26:25.312]     ...future.result$finished <- base::Sys.time()
[10:26:25.312]     ...future.result
[10:26:25.312] }
[10:26:25.314] plan(): Setting new future strategy stack:
[10:26:25.314] List of future strategies:
[10:26:25.314] 1. sequential:
[10:26:25.314]    - args: function (..., envir = parent.frame())
[10:26:25.314]    - tweaked: FALSE
[10:26:25.314]    - call: NULL
[10:26:25.314] plan(): nbrOfWorkers() = 1
[10:26:25.315] plan(): Setting new future strategy stack:
[10:26:25.315] List of future strategies:
[10:26:25.315] 1. sequential:
[10:26:25.315]    - args: function (..., envir = parent.frame())
[10:26:25.315]    - tweaked: FALSE
[10:26:25.315]    - call: future::plan("sequential")
[10:26:25.316] plan(): nbrOfWorkers() = 1
[10:26:25.316] SequentialFuture started (and completed)
[10:26:25.316] signalConditions() ...
[10:26:25.316]  - include = ‘immediateCondition’
[10:26:25.316]  - exclude = 
[10:26:25.316]  - resignal = FALSE
[10:26:25.316]  - Number of conditions: 1
[10:26:25.317] signalConditions() ... done
[10:26:25.317] signalConditions() ...
[10:26:25.317]  - include = ‘immediateCondition’
[10:26:25.317]  - exclude = 
[10:26:25.317]  - resignal = FALSE
[10:26:25.317]  - Number of conditions: 1
[10:26:25.317] signalConditions() ... done
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[10:26:25.317] signalConditions() ...
[10:26:25.318]  - include = ‘immediateCondition’
[10:26:25.318]  - exclude = 
[10:26:25.318]  - resignal = FALSE
[10:26:25.318]  - Number of conditions: 1
[10:26:25.318] signalConditions() ... done
[10:26:25.318] Future state: ‘finished’
[10:26:25.318] signalConditions() ...
[10:26:25.318]  - include = ‘condition’
[10:26:25.318]  - exclude = ‘immediateCondition’
[10:26:25.318]  - resignal = TRUE
[10:26:25.318]  - Number of conditions: 1
[10:26:25.319]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:26:25.319] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[10:26:25.319] signalConditions() ...
[10:26:25.319]  - include = ‘immediateCondition’
[10:26:25.319]  - exclude = 
[10:26:25.319]  - resignal = FALSE
[10:26:25.319]  - Number of conditions: 1
[10:26:25.319] signalConditions() ... done
[10:26:25.320] Future state: ‘finished’
[10:26:25.320] signalConditions() ...
[10:26:25.320]  - include = ‘condition’
[10:26:25.320]  - exclude = ‘immediateCondition’
[10:26:25.320]  - resignal = TRUE
[10:26:25.320]  - Number of conditions: 1
[10:26:25.320]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:26:25.320] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[10:26:25.324] getGlobalsAndPackages() ...
[10:26:25.324] Searching for globals...
[10:26:25.325] - globals found: [5] ‘{’, ‘stop’, ‘structure’, ‘list’, ‘c’
[10:26:25.325] Searching for globals ... DONE
[10:26:25.325] Resolving globals: FALSE
[10:26:25.325] 
[10:26:25.325] 
[10:26:25.326] getGlobalsAndPackages() ... DONE
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: TRUE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: b237ea00-048b-53bc-62d3-d50d6929ba00
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:25.326] Packages needed by the future expression (n = 0): <none>
[10:26:25.326] Packages needed by future strategies (n = 0): <none>
[10:26:25.327] {
[10:26:25.327]     {
[10:26:25.327]         {
[10:26:25.327]             ...future.startTime <- base::Sys.time()
[10:26:25.327]             {
[10:26:25.327]                 {
[10:26:25.327]                   {
[10:26:25.327]                     base::local({
[10:26:25.327]                       has_future <- base::requireNamespace("future", 
[10:26:25.327]                         quietly = TRUE)
[10:26:25.327]                       if (has_future) {
[10:26:25.327]                         ns <- base::getNamespace("future")
[10:26:25.327]                         version <- ns[[".package"]][["version"]]
[10:26:25.327]                         if (is.null(version)) 
[10:26:25.327]                           version <- utils::packageVersion("future")
[10:26:25.327]                       }
[10:26:25.327]                       else {
[10:26:25.327]                         version <- NULL
[10:26:25.327]                       }
[10:26:25.327]                       if (!has_future || version < "1.8.0") {
[10:26:25.327]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:25.327]                           "", base::R.version$version.string), 
[10:26:25.327]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:25.327]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:25.327]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:25.327]                             "release", "version")], collapse = " "), 
[10:26:25.327]                           hostname = base::Sys.info()[["nodename"]])
[10:26:25.327]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:25.327]                           info)
[10:26:25.327]                         info <- base::paste(info, collapse = "; ")
[10:26:25.327]                         if (!has_future) {
[10:26:25.327]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:25.327]                             info)
[10:26:25.327]                         }
[10:26:25.327]                         else {
[10:26:25.327]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:25.327]                             info, version)
[10:26:25.327]                         }
[10:26:25.327]                         base::stop(msg)
[10:26:25.327]                       }
[10:26:25.327]                     })
[10:26:25.327]                   }
[10:26:25.327]                   options(future.plan = NULL)
[10:26:25.327]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:25.327]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:25.327]                 }
[10:26:25.327]                 ...future.workdir <- getwd()
[10:26:25.327]             }
[10:26:25.327]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:25.327]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:25.327]         }
[10:26:25.327]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:25.327]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:25.327]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:25.327]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:25.327]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:25.327]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:25.327]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:25.327]             base::names(...future.oldOptions))
[10:26:25.327]     }
[10:26:25.327]     if (FALSE) {
[10:26:25.327]     }
[10:26:25.327]     else {
[10:26:25.327]         if (TRUE) {
[10:26:25.327]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:25.327]                 open = "w")
[10:26:25.327]         }
[10:26:25.327]         else {
[10:26:25.327]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:25.327]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:25.327]         }
[10:26:25.327]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:25.327]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:25.327]             base::sink(type = "output", split = FALSE)
[10:26:25.327]             base::close(...future.stdout)
[10:26:25.327]         }, add = TRUE)
[10:26:25.327]     }
[10:26:25.327]     ...future.frame <- base::sys.nframe()
[10:26:25.327]     ...future.conditions <- base::list()
[10:26:25.327]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:25.327]     if (FALSE) {
[10:26:25.327]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:25.327]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:25.327]     }
[10:26:25.327]     ...future.result <- base::tryCatch({
[10:26:25.327]         base::withCallingHandlers({
[10:26:25.327]             ...future.value <- base::withVisible(base::local({
[10:26:25.327]                 stop(structure(list(message = "boom"), class = c("MyError", 
[10:26:25.327]                   "error", "condition")))
[10:26:25.327]             }))
[10:26:25.327]             future::FutureResult(value = ...future.value$value, 
[10:26:25.327]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:25.327]                   ...future.rng), globalenv = if (FALSE) 
[10:26:25.327]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:25.327]                     ...future.globalenv.names))
[10:26:25.327]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:25.327]         }, condition = base::local({
[10:26:25.327]             c <- base::c
[10:26:25.327]             inherits <- base::inherits
[10:26:25.327]             invokeRestart <- base::invokeRestart
[10:26:25.327]             length <- base::length
[10:26:25.327]             list <- base::list
[10:26:25.327]             seq.int <- base::seq.int
[10:26:25.327]             signalCondition <- base::signalCondition
[10:26:25.327]             sys.calls <- base::sys.calls
[10:26:25.327]             `[[` <- base::`[[`
[10:26:25.327]             `+` <- base::`+`
[10:26:25.327]             `<<-` <- base::`<<-`
[10:26:25.327]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:25.327]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:25.327]                   3L)]
[10:26:25.327]             }
[10:26:25.327]             function(cond) {
[10:26:25.327]                 is_error <- inherits(cond, "error")
[10:26:25.327]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:25.327]                   NULL)
[10:26:25.327]                 if (is_error) {
[10:26:25.327]                   sessionInformation <- function() {
[10:26:25.327]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:25.327]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:25.327]                       search = base::search(), system = base::Sys.info())
[10:26:25.327]                   }
[10:26:25.327]                   ...future.conditions[[length(...future.conditions) + 
[10:26:25.327]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:25.327]                     cond$call), session = sessionInformation(), 
[10:26:25.327]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:25.327]                   signalCondition(cond)
[10:26:25.327]                 }
[10:26:25.327]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:25.327]                 "immediateCondition"))) {
[10:26:25.327]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:25.327]                   ...future.conditions[[length(...future.conditions) + 
[10:26:25.327]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:25.327]                   if (TRUE && !signal) {
[10:26:25.327]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:25.327]                     {
[10:26:25.327]                       inherits <- base::inherits
[10:26:25.327]                       invokeRestart <- base::invokeRestart
[10:26:25.327]                       is.null <- base::is.null
[10:26:25.327]                       muffled <- FALSE
[10:26:25.327]                       if (inherits(cond, "message")) {
[10:26:25.327]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:25.327]                         if (muffled) 
[10:26:25.327]                           invokeRestart("muffleMessage")
[10:26:25.327]                       }
[10:26:25.327]                       else if (inherits(cond, "warning")) {
[10:26:25.327]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:25.327]                         if (muffled) 
[10:26:25.327]                           invokeRestart("muffleWarning")
[10:26:25.327]                       }
[10:26:25.327]                       else if (inherits(cond, "condition")) {
[10:26:25.327]                         if (!is.null(pattern)) {
[10:26:25.327]                           computeRestarts <- base::computeRestarts
[10:26:25.327]                           grepl <- base::grepl
[10:26:25.327]                           restarts <- computeRestarts(cond)
[10:26:25.327]                           for (restart in restarts) {
[10:26:25.327]                             name <- restart$name
[10:26:25.327]                             if (is.null(name)) 
[10:26:25.327]                               next
[10:26:25.327]                             if (!grepl(pattern, name)) 
[10:26:25.327]                               next
[10:26:25.327]                             invokeRestart(restart)
[10:26:25.327]                             muffled <- TRUE
[10:26:25.327]                             break
[10:26:25.327]                           }
[10:26:25.327]                         }
[10:26:25.327]                       }
[10:26:25.327]                       invisible(muffled)
[10:26:25.327]                     }
[10:26:25.327]                     muffleCondition(cond, pattern = "^muffle")
[10:26:25.327]                   }
[10:26:25.327]                 }
[10:26:25.327]                 else {
[10:26:25.327]                   if (TRUE) {
[10:26:25.327]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:25.327]                     {
[10:26:25.327]                       inherits <- base::inherits
[10:26:25.327]                       invokeRestart <- base::invokeRestart
[10:26:25.327]                       is.null <- base::is.null
[10:26:25.327]                       muffled <- FALSE
[10:26:25.327]                       if (inherits(cond, "message")) {
[10:26:25.327]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:25.327]                         if (muffled) 
[10:26:25.327]                           invokeRestart("muffleMessage")
[10:26:25.327]                       }
[10:26:25.327]                       else if (inherits(cond, "warning")) {
[10:26:25.327]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:25.327]                         if (muffled) 
[10:26:25.327]                           invokeRestart("muffleWarning")
[10:26:25.327]                       }
[10:26:25.327]                       else if (inherits(cond, "condition")) {
[10:26:25.327]                         if (!is.null(pattern)) {
[10:26:25.327]                           computeRestarts <- base::computeRestarts
[10:26:25.327]                           grepl <- base::grepl
[10:26:25.327]                           restarts <- computeRestarts(cond)
[10:26:25.327]                           for (restart in restarts) {
[10:26:25.327]                             name <- restart$name
[10:26:25.327]                             if (is.null(name)) 
[10:26:25.327]                               next
[10:26:25.327]                             if (!grepl(pattern, name)) 
[10:26:25.327]                               next
[10:26:25.327]                             invokeRestart(restart)
[10:26:25.327]                             muffled <- TRUE
[10:26:25.327]                             break
[10:26:25.327]                           }
[10:26:25.327]                         }
[10:26:25.327]                       }
[10:26:25.327]                       invisible(muffled)
[10:26:25.327]                     }
[10:26:25.327]                     muffleCondition(cond, pattern = "^muffle")
[10:26:25.327]                   }
[10:26:25.327]                 }
[10:26:25.327]             }
[10:26:25.327]         }))
[10:26:25.327]     }, error = function(ex) {
[10:26:25.327]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:25.327]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:25.327]                 ...future.rng), started = ...future.startTime, 
[10:26:25.327]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:25.327]             version = "1.8"), class = "FutureResult")
[10:26:25.327]     }, finally = {
[10:26:25.327]         if (!identical(...future.workdir, getwd())) 
[10:26:25.327]             setwd(...future.workdir)
[10:26:25.327]         {
[10:26:25.327]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:25.327]                 ...future.oldOptions$nwarnings <- NULL
[10:26:25.327]             }
[10:26:25.327]             base::options(...future.oldOptions)
[10:26:25.327]             if (.Platform$OS.type == "windows") {
[10:26:25.327]                 old_names <- names(...future.oldEnvVars)
[10:26:25.327]                 envs <- base::Sys.getenv()
[10:26:25.327]                 names <- names(envs)
[10:26:25.327]                 common <- intersect(names, old_names)
[10:26:25.327]                 added <- setdiff(names, old_names)
[10:26:25.327]                 removed <- setdiff(old_names, names)
[10:26:25.327]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:25.327]                   envs[common]]
[10:26:25.327]                 NAMES <- toupper(changed)
[10:26:25.327]                 args <- list()
[10:26:25.327]                 for (kk in seq_along(NAMES)) {
[10:26:25.327]                   name <- changed[[kk]]
[10:26:25.327]                   NAME <- NAMES[[kk]]
[10:26:25.327]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:25.327]                     next
[10:26:25.327]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:25.327]                 }
[10:26:25.327]                 NAMES <- toupper(added)
[10:26:25.327]                 for (kk in seq_along(NAMES)) {
[10:26:25.327]                   name <- added[[kk]]
[10:26:25.327]                   NAME <- NAMES[[kk]]
[10:26:25.327]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:25.327]                     next
[10:26:25.327]                   args[[name]] <- ""
[10:26:25.327]                 }
[10:26:25.327]                 NAMES <- toupper(removed)
[10:26:25.327]                 for (kk in seq_along(NAMES)) {
[10:26:25.327]                   name <- removed[[kk]]
[10:26:25.327]                   NAME <- NAMES[[kk]]
[10:26:25.327]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:25.327]                     next
[10:26:25.327]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:25.327]                 }
[10:26:25.327]                 if (length(args) > 0) 
[10:26:25.327]                   base::do.call(base::Sys.setenv, args = args)
[10:26:25.327]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:25.327]             }
[10:26:25.327]             else {
[10:26:25.327]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:25.327]             }
[10:26:25.327]             {
[10:26:25.327]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:25.327]                   0L) {
[10:26:25.327]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:25.327]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:25.327]                   base::options(opts)
[10:26:25.327]                 }
[10:26:25.327]                 {
[10:26:25.327]                   {
[10:26:25.327]                     NULL
[10:26:25.327]                     RNGkind("Mersenne-Twister")
[10:26:25.327]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:25.327]                       inherits = FALSE)
[10:26:25.327]                   }
[10:26:25.327]                   options(future.plan = NULL)
[10:26:25.327]                   if (is.na(NA_character_)) 
[10:26:25.327]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:25.327]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:25.327]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:25.327]                   {
[10:26:25.327]                     future <- SequentialFuture(..., envir = envir)
[10:26:25.327]                     if (!future$lazy) 
[10:26:25.327]                       future <- run(future)
[10:26:25.327]                     invisible(future)
[10:26:25.327]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:25.327]                 }
[10:26:25.327]             }
[10:26:25.327]         }
[10:26:25.327]     })
[10:26:25.327]     if (TRUE) {
[10:26:25.327]         base::sink(type = "output", split = FALSE)
[10:26:25.327]         if (TRUE) {
[10:26:25.327]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:25.327]         }
[10:26:25.327]         else {
[10:26:25.327]             ...future.result["stdout"] <- base::list(NULL)
[10:26:25.327]         }
[10:26:25.327]         base::close(...future.stdout)
[10:26:25.327]         ...future.stdout <- NULL
[10:26:25.327]     }
[10:26:25.327]     ...future.result$conditions <- ...future.conditions
[10:26:25.327]     ...future.result$finished <- base::Sys.time()
[10:26:25.327]     ...future.result
[10:26:25.327] }
[10:26:25.328] plan(): Setting new future strategy stack:
[10:26:25.328] List of future strategies:
[10:26:25.328] 1. sequential:
[10:26:25.328]    - args: function (..., envir = parent.frame())
[10:26:25.328]    - tweaked: FALSE
[10:26:25.328]    - call: NULL
[10:26:25.329] plan(): nbrOfWorkers() = 1
[10:26:25.330] plan(): Setting new future strategy stack:
[10:26:25.330] List of future strategies:
[10:26:25.330] 1. sequential:
[10:26:25.330]    - args: function (..., envir = parent.frame())
[10:26:25.330]    - tweaked: FALSE
[10:26:25.330]    - call: future::plan("sequential")
[10:26:25.330] plan(): nbrOfWorkers() = 1
[10:26:25.330] SequentialFuture started (and completed)
[10:26:25.330] signalConditions() ...
[10:26:25.330]  - include = ‘immediateCondition’
[10:26:25.331]  - exclude = 
[10:26:25.331]  - resignal = FALSE
[10:26:25.331]  - Number of conditions: 1
[10:26:25.331] signalConditions() ... done
[10:26:25.331] signalConditions() ...
[10:26:25.331]  - include = ‘immediateCondition’
[10:26:25.331]  - exclude = 
[10:26:25.331]  - resignal = FALSE
[10:26:25.331]  - Number of conditions: 1
[10:26:25.331] signalConditions() ... done
<MyError: boom>
[10:26:25.332] signalConditions() ...
[10:26:25.332]  - include = ‘immediateCondition’
[10:26:25.332]  - exclude = 
[10:26:25.332]  - resignal = FALSE
[10:26:25.332]  - Number of conditions: 1
[10:26:25.332] signalConditions() ... done
[10:26:25.332] Future state: ‘finished’
[10:26:25.332] signalConditions() ...
[10:26:25.332]  - include = ‘condition’
[10:26:25.332]  - exclude = ‘immediateCondition’
[10:26:25.332]  - resignal = TRUE
[10:26:25.333]  - Number of conditions: 1
[10:26:25.333]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[10:26:25.333] signalConditions() ... done
Testing with 1 cores ... DONE
Testing with 2 cores ...
[10:26:25.339] getGlobalsAndPackages() ...
[10:26:25.339] 
[10:26:25.340] - globals: [0] <none>
[10:26:25.340] getGlobalsAndPackages() ... DONE
[10:26:25.340] [local output] makeClusterPSOCK() ...
[10:26:25.372] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:26:25.373] [local output] Base port: 11297
[10:26:25.373] [local output] Getting setup options for 2 cluster nodes ...
[10:26:25.373] [local output]  - Node 1 of 2 ...
[10:26:25.374] [local output] localMachine=TRUE => revtunnel=FALSE

[10:26:25.374] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpLA4GNs/worker.rank=1.parallelly.parent=87451.1559b632eb8fa.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpLA4GNs/worker.rank=1.parallelly.parent=87451.1559b632eb8fa.pid")'’
[10:26:25.563] - Possible to infer worker's PID: TRUE
[10:26:25.563] [local output] Rscript port: 11297

[10:26:25.564] [local output]  - Node 2 of 2 ...
[10:26:25.564] [local output] localMachine=TRUE => revtunnel=FALSE

[10:26:25.565] [local output] Rscript port: 11297

[10:26:25.565] [local output] Getting setup options for 2 cluster nodes ... done
[10:26:25.565] [local output]  - Parallel setup requested for some PSOCK nodes
[10:26:25.566] [local output] Setting up PSOCK nodes in parallel
[10:26:25.566] List of 36
[10:26:25.566]  $ worker          : chr "localhost"
[10:26:25.566]   ..- attr(*, "localhost")= logi TRUE
[10:26:25.566]  $ master          : chr "localhost"
[10:26:25.566]  $ port            : int 11297
[10:26:25.566]  $ connectTimeout  : num 120
[10:26:25.566]  $ timeout         : num 2592000
[10:26:25.566]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:26:25.566]  $ homogeneous     : logi TRUE
[10:26:25.566]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:26:25.566]  $ rscript_envs    : NULL
[10:26:25.566]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:26:25.566]  $ rscript_startup : NULL
[10:26:25.566]  $ rscript_sh      : chr "sh"
[10:26:25.566]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:26:25.566]  $ methods         : logi TRUE
[10:26:25.566]  $ socketOptions   : chr "no-delay"
[10:26:25.566]  $ useXDR          : logi FALSE
[10:26:25.566]  $ outfile         : chr "/dev/null"
[10:26:25.566]  $ renice          : int NA
[10:26:25.566]  $ rshcmd          : NULL
[10:26:25.566]  $ user            : chr(0) 
[10:26:25.566]  $ revtunnel       : logi FALSE
[10:26:25.566]  $ rshlogfile      : NULL
[10:26:25.566]  $ rshopts         : chr(0) 
[10:26:25.566]  $ rank            : int 1
[10:26:25.566]  $ manual          : logi FALSE
[10:26:25.566]  $ dryrun          : logi FALSE
[10:26:25.566]  $ quiet           : logi FALSE
[10:26:25.566]  $ setup_strategy  : chr "parallel"
[10:26:25.566]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:26:25.566]  $ pidfile         : chr "/tmp/RtmpLA4GNs/worker.rank=1.parallelly.parent=87451.1559b632eb8fa.pid"
[10:26:25.566]  $ rshcmd_label    : NULL
[10:26:25.566]  $ rsh_call        : NULL
[10:26:25.566]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:26:25.566]  $ localMachine    : logi TRUE
[10:26:25.566]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:26:25.566]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:26:25.566]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:26:25.566]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:26:25.566]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:26:25.566]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:26:25.566]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:26:25.566]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:26:25.566]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:26:25.566]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:26:25.566]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:26:25.566]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:26:25.566]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:26:25.566]  $ arguments       :List of 28
[10:26:25.566]   ..$ worker          : chr "localhost"
[10:26:25.566]   ..$ master          : NULL
[10:26:25.566]   ..$ port            : int 11297
[10:26:25.566]   ..$ connectTimeout  : num 120
[10:26:25.566]   ..$ timeout         : num 2592000
[10:26:25.566]   ..$ rscript         : NULL
[10:26:25.566]   ..$ homogeneous     : NULL
[10:26:25.566]   ..$ rscript_args    : NULL
[10:26:25.566]   ..$ rscript_envs    : NULL
[10:26:25.566]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:26:25.566]   ..$ rscript_startup : NULL
[10:26:25.566]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:26:25.566]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:26:25.566]   ..$ methods         : logi TRUE
[10:26:25.566]   ..$ socketOptions   : chr "no-delay"
[10:26:25.566]   ..$ useXDR          : logi FALSE
[10:26:25.566]   ..$ outfile         : chr "/dev/null"
[10:26:25.566]   ..$ renice          : int NA
[10:26:25.566]   ..$ rshcmd          : NULL
[10:26:25.566]   ..$ user            : NULL
[10:26:25.566]   ..$ revtunnel       : logi NA
[10:26:25.566]   ..$ rshlogfile      : NULL
[10:26:25.566]   ..$ rshopts         : NULL
[10:26:25.566]   ..$ rank            : int 1
[10:26:25.566]   ..$ manual          : logi FALSE
[10:26:25.566]   ..$ dryrun          : logi FALSE
[10:26:25.566]   ..$ quiet           : logi FALSE
[10:26:25.566]   ..$ setup_strategy  : chr "parallel"
[10:26:25.566]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:26:25.582] [local output] System call to launch all workers:
[10:26:25.583] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpLA4GNs/worker.rank=1.parallelly.parent=87451.1559b632eb8fa.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11297 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:26:25.583] [local output] Starting PSOCK main server
[10:26:25.588] [local output] Workers launched
[10:26:25.588] [local output] Waiting for workers to connect back
[10:26:25.588]  - [local output] 0 workers out of 2 ready
[10:26:25.831]  - [local output] 0 workers out of 2 ready
[10:26:25.832]  - [local output] 1 workers out of 2 ready
[10:26:25.839]  - [local output] 1 workers out of 2 ready
[10:26:25.840]  - [local output] 2 workers out of 2 ready
[10:26:25.840] [local output] Launching of workers completed
[10:26:25.840] [local output] Collecting session information from workers
[10:26:25.841] [local output]  - Worker #1 of 2
[10:26:25.841] [local output]  - Worker #2 of 2
[10:26:25.841] [local output] makeClusterPSOCK() ... done
[10:26:25.853] Packages needed by the future expression (n = 0): <none>
[10:26:25.854] Packages needed by future strategies (n = 0): <none>
[10:26:25.854] {
[10:26:25.854]     {
[10:26:25.854]         {
[10:26:25.854]             ...future.startTime <- base::Sys.time()
[10:26:25.854]             {
[10:26:25.854]                 {
[10:26:25.854]                   {
[10:26:25.854]                     {
[10:26:25.854]                       base::local({
[10:26:25.854]                         has_future <- base::requireNamespace("future", 
[10:26:25.854]                           quietly = TRUE)
[10:26:25.854]                         if (has_future) {
[10:26:25.854]                           ns <- base::getNamespace("future")
[10:26:25.854]                           version <- ns[[".package"]][["version"]]
[10:26:25.854]                           if (is.null(version)) 
[10:26:25.854]                             version <- utils::packageVersion("future")
[10:26:25.854]                         }
[10:26:25.854]                         else {
[10:26:25.854]                           version <- NULL
[10:26:25.854]                         }
[10:26:25.854]                         if (!has_future || version < "1.8.0") {
[10:26:25.854]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:25.854]                             "", base::R.version$version.string), 
[10:26:25.854]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:25.854]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:25.854]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:25.854]                               "release", "version")], collapse = " "), 
[10:26:25.854]                             hostname = base::Sys.info()[["nodename"]])
[10:26:25.854]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:25.854]                             info)
[10:26:25.854]                           info <- base::paste(info, collapse = "; ")
[10:26:25.854]                           if (!has_future) {
[10:26:25.854]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:25.854]                               info)
[10:26:25.854]                           }
[10:26:25.854]                           else {
[10:26:25.854]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:25.854]                               info, version)
[10:26:25.854]                           }
[10:26:25.854]                           base::stop(msg)
[10:26:25.854]                         }
[10:26:25.854]                       })
[10:26:25.854]                     }
[10:26:25.854]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:25.854]                     base::options(mc.cores = 1L)
[10:26:25.854]                   }
[10:26:25.854]                   options(future.plan = NULL)
[10:26:25.854]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:25.854]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:25.854]                 }
[10:26:25.854]                 ...future.workdir <- getwd()
[10:26:25.854]             }
[10:26:25.854]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:25.854]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:25.854]         }
[10:26:25.854]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:25.854]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:25.854]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:25.854]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:25.854]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:25.854]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:25.854]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:25.854]             base::names(...future.oldOptions))
[10:26:25.854]     }
[10:26:25.854]     if (FALSE) {
[10:26:25.854]     }
[10:26:25.854]     else {
[10:26:25.854]         if (TRUE) {
[10:26:25.854]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:25.854]                 open = "w")
[10:26:25.854]         }
[10:26:25.854]         else {
[10:26:25.854]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:25.854]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:25.854]         }
[10:26:25.854]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:25.854]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:25.854]             base::sink(type = "output", split = FALSE)
[10:26:25.854]             base::close(...future.stdout)
[10:26:25.854]         }, add = TRUE)
[10:26:25.854]     }
[10:26:25.854]     ...future.frame <- base::sys.nframe()
[10:26:25.854]     ...future.conditions <- base::list()
[10:26:25.854]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:25.854]     if (FALSE) {
[10:26:25.854]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:25.854]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:25.854]     }
[10:26:25.854]     ...future.result <- base::tryCatch({
[10:26:25.854]         base::withCallingHandlers({
[10:26:25.854]             ...future.value <- base::withVisible(base::local({
[10:26:25.854]                 ...future.makeSendCondition <- base::local({
[10:26:25.854]                   sendCondition <- NULL
[10:26:25.854]                   function(frame = 1L) {
[10:26:25.854]                     if (is.function(sendCondition)) 
[10:26:25.854]                       return(sendCondition)
[10:26:25.854]                     ns <- getNamespace("parallel")
[10:26:25.854]                     if (exists("sendData", mode = "function", 
[10:26:25.854]                       envir = ns)) {
[10:26:25.854]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:25.854]                         envir = ns)
[10:26:25.854]                       envir <- sys.frame(frame)
[10:26:25.854]                       master <- NULL
[10:26:25.854]                       while (!identical(envir, .GlobalEnv) && 
[10:26:25.854]                         !identical(envir, emptyenv())) {
[10:26:25.854]                         if (exists("master", mode = "list", envir = envir, 
[10:26:25.854]                           inherits = FALSE)) {
[10:26:25.854]                           master <- get("master", mode = "list", 
[10:26:25.854]                             envir = envir, inherits = FALSE)
[10:26:25.854]                           if (inherits(master, c("SOCKnode", 
[10:26:25.854]                             "SOCK0node"))) {
[10:26:25.854]                             sendCondition <<- function(cond) {
[10:26:25.854]                               data <- list(type = "VALUE", value = cond, 
[10:26:25.854]                                 success = TRUE)
[10:26:25.854]                               parallel_sendData(master, data)
[10:26:25.854]                             }
[10:26:25.854]                             return(sendCondition)
[10:26:25.854]                           }
[10:26:25.854]                         }
[10:26:25.854]                         frame <- frame + 1L
[10:26:25.854]                         envir <- sys.frame(frame)
[10:26:25.854]                       }
[10:26:25.854]                     }
[10:26:25.854]                     sendCondition <<- function(cond) NULL
[10:26:25.854]                   }
[10:26:25.854]                 })
[10:26:25.854]                 withCallingHandlers({
[10:26:25.854]                   {
[10:26:25.854]                     42L
[10:26:25.854]                   }
[10:26:25.854]                 }, immediateCondition = function(cond) {
[10:26:25.854]                   sendCondition <- ...future.makeSendCondition()
[10:26:25.854]                   sendCondition(cond)
[10:26:25.854]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:25.854]                   {
[10:26:25.854]                     inherits <- base::inherits
[10:26:25.854]                     invokeRestart <- base::invokeRestart
[10:26:25.854]                     is.null <- base::is.null
[10:26:25.854]                     muffled <- FALSE
[10:26:25.854]                     if (inherits(cond, "message")) {
[10:26:25.854]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:25.854]                       if (muffled) 
[10:26:25.854]                         invokeRestart("muffleMessage")
[10:26:25.854]                     }
[10:26:25.854]                     else if (inherits(cond, "warning")) {
[10:26:25.854]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:25.854]                       if (muffled) 
[10:26:25.854]                         invokeRestart("muffleWarning")
[10:26:25.854]                     }
[10:26:25.854]                     else if (inherits(cond, "condition")) {
[10:26:25.854]                       if (!is.null(pattern)) {
[10:26:25.854]                         computeRestarts <- base::computeRestarts
[10:26:25.854]                         grepl <- base::grepl
[10:26:25.854]                         restarts <- computeRestarts(cond)
[10:26:25.854]                         for (restart in restarts) {
[10:26:25.854]                           name <- restart$name
[10:26:25.854]                           if (is.null(name)) 
[10:26:25.854]                             next
[10:26:25.854]                           if (!grepl(pattern, name)) 
[10:26:25.854]                             next
[10:26:25.854]                           invokeRestart(restart)
[10:26:25.854]                           muffled <- TRUE
[10:26:25.854]                           break
[10:26:25.854]                         }
[10:26:25.854]                       }
[10:26:25.854]                     }
[10:26:25.854]                     invisible(muffled)
[10:26:25.854]                   }
[10:26:25.854]                   muffleCondition(cond)
[10:26:25.854]                 })
[10:26:25.854]             }))
[10:26:25.854]             future::FutureResult(value = ...future.value$value, 
[10:26:25.854]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:25.854]                   ...future.rng), globalenv = if (FALSE) 
[10:26:25.854]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:25.854]                     ...future.globalenv.names))
[10:26:25.854]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:25.854]         }, condition = base::local({
[10:26:25.854]             c <- base::c
[10:26:25.854]             inherits <- base::inherits
[10:26:25.854]             invokeRestart <- base::invokeRestart
[10:26:25.854]             length <- base::length
[10:26:25.854]             list <- base::list
[10:26:25.854]             seq.int <- base::seq.int
[10:26:25.854]             signalCondition <- base::signalCondition
[10:26:25.854]             sys.calls <- base::sys.calls
[10:26:25.854]             `[[` <- base::`[[`
[10:26:25.854]             `+` <- base::`+`
[10:26:25.854]             `<<-` <- base::`<<-`
[10:26:25.854]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:25.854]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:25.854]                   3L)]
[10:26:25.854]             }
[10:26:25.854]             function(cond) {
[10:26:25.854]                 is_error <- inherits(cond, "error")
[10:26:25.854]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:25.854]                   NULL)
[10:26:25.854]                 if (is_error) {
[10:26:25.854]                   sessionInformation <- function() {
[10:26:25.854]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:25.854]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:25.854]                       search = base::search(), system = base::Sys.info())
[10:26:25.854]                   }
[10:26:25.854]                   ...future.conditions[[length(...future.conditions) + 
[10:26:25.854]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:25.854]                     cond$call), session = sessionInformation(), 
[10:26:25.854]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:25.854]                   signalCondition(cond)
[10:26:25.854]                 }
[10:26:25.854]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:25.854]                 "immediateCondition"))) {
[10:26:25.854]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:25.854]                   ...future.conditions[[length(...future.conditions) + 
[10:26:25.854]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:25.854]                   if (TRUE && !signal) {
[10:26:25.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:25.854]                     {
[10:26:25.854]                       inherits <- base::inherits
[10:26:25.854]                       invokeRestart <- base::invokeRestart
[10:26:25.854]                       is.null <- base::is.null
[10:26:25.854]                       muffled <- FALSE
[10:26:25.854]                       if (inherits(cond, "message")) {
[10:26:25.854]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:25.854]                         if (muffled) 
[10:26:25.854]                           invokeRestart("muffleMessage")
[10:26:25.854]                       }
[10:26:25.854]                       else if (inherits(cond, "warning")) {
[10:26:25.854]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:25.854]                         if (muffled) 
[10:26:25.854]                           invokeRestart("muffleWarning")
[10:26:25.854]                       }
[10:26:25.854]                       else if (inherits(cond, "condition")) {
[10:26:25.854]                         if (!is.null(pattern)) {
[10:26:25.854]                           computeRestarts <- base::computeRestarts
[10:26:25.854]                           grepl <- base::grepl
[10:26:25.854]                           restarts <- computeRestarts(cond)
[10:26:25.854]                           for (restart in restarts) {
[10:26:25.854]                             name <- restart$name
[10:26:25.854]                             if (is.null(name)) 
[10:26:25.854]                               next
[10:26:25.854]                             if (!grepl(pattern, name)) 
[10:26:25.854]                               next
[10:26:25.854]                             invokeRestart(restart)
[10:26:25.854]                             muffled <- TRUE
[10:26:25.854]                             break
[10:26:25.854]                           }
[10:26:25.854]                         }
[10:26:25.854]                       }
[10:26:25.854]                       invisible(muffled)
[10:26:25.854]                     }
[10:26:25.854]                     muffleCondition(cond, pattern = "^muffle")
[10:26:25.854]                   }
[10:26:25.854]                 }
[10:26:25.854]                 else {
[10:26:25.854]                   if (TRUE) {
[10:26:25.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:25.854]                     {
[10:26:25.854]                       inherits <- base::inherits
[10:26:25.854]                       invokeRestart <- base::invokeRestart
[10:26:25.854]                       is.null <- base::is.null
[10:26:25.854]                       muffled <- FALSE
[10:26:25.854]                       if (inherits(cond, "message")) {
[10:26:25.854]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:25.854]                         if (muffled) 
[10:26:25.854]                           invokeRestart("muffleMessage")
[10:26:25.854]                       }
[10:26:25.854]                       else if (inherits(cond, "warning")) {
[10:26:25.854]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:25.854]                         if (muffled) 
[10:26:25.854]                           invokeRestart("muffleWarning")
[10:26:25.854]                       }
[10:26:25.854]                       else if (inherits(cond, "condition")) {
[10:26:25.854]                         if (!is.null(pattern)) {
[10:26:25.854]                           computeRestarts <- base::computeRestarts
[10:26:25.854]                           grepl <- base::grepl
[10:26:25.854]                           restarts <- computeRestarts(cond)
[10:26:25.854]                           for (restart in restarts) {
[10:26:25.854]                             name <- restart$name
[10:26:25.854]                             if (is.null(name)) 
[10:26:25.854]                               next
[10:26:25.854]                             if (!grepl(pattern, name)) 
[10:26:25.854]                               next
[10:26:25.854]                             invokeRestart(restart)
[10:26:25.854]                             muffled <- TRUE
[10:26:25.854]                             break
[10:26:25.854]                           }
[10:26:25.854]                         }
[10:26:25.854]                       }
[10:26:25.854]                       invisible(muffled)
[10:26:25.854]                     }
[10:26:25.854]                     muffleCondition(cond, pattern = "^muffle")
[10:26:25.854]                   }
[10:26:25.854]                 }
[10:26:25.854]             }
[10:26:25.854]         }))
[10:26:25.854]     }, error = function(ex) {
[10:26:25.854]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:25.854]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:25.854]                 ...future.rng), started = ...future.startTime, 
[10:26:25.854]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:25.854]             version = "1.8"), class = "FutureResult")
[10:26:25.854]     }, finally = {
[10:26:25.854]         if (!identical(...future.workdir, getwd())) 
[10:26:25.854]             setwd(...future.workdir)
[10:26:25.854]         {
[10:26:25.854]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:25.854]                 ...future.oldOptions$nwarnings <- NULL
[10:26:25.854]             }
[10:26:25.854]             base::options(...future.oldOptions)
[10:26:25.854]             if (.Platform$OS.type == "windows") {
[10:26:25.854]                 old_names <- names(...future.oldEnvVars)
[10:26:25.854]                 envs <- base::Sys.getenv()
[10:26:25.854]                 names <- names(envs)
[10:26:25.854]                 common <- intersect(names, old_names)
[10:26:25.854]                 added <- setdiff(names, old_names)
[10:26:25.854]                 removed <- setdiff(old_names, names)
[10:26:25.854]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:25.854]                   envs[common]]
[10:26:25.854]                 NAMES <- toupper(changed)
[10:26:25.854]                 args <- list()
[10:26:25.854]                 for (kk in seq_along(NAMES)) {
[10:26:25.854]                   name <- changed[[kk]]
[10:26:25.854]                   NAME <- NAMES[[kk]]
[10:26:25.854]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:25.854]                     next
[10:26:25.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:25.854]                 }
[10:26:25.854]                 NAMES <- toupper(added)
[10:26:25.854]                 for (kk in seq_along(NAMES)) {
[10:26:25.854]                   name <- added[[kk]]
[10:26:25.854]                   NAME <- NAMES[[kk]]
[10:26:25.854]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:25.854]                     next
[10:26:25.854]                   args[[name]] <- ""
[10:26:25.854]                 }
[10:26:25.854]                 NAMES <- toupper(removed)
[10:26:25.854]                 for (kk in seq_along(NAMES)) {
[10:26:25.854]                   name <- removed[[kk]]
[10:26:25.854]                   NAME <- NAMES[[kk]]
[10:26:25.854]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:25.854]                     next
[10:26:25.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:25.854]                 }
[10:26:25.854]                 if (length(args) > 0) 
[10:26:25.854]                   base::do.call(base::Sys.setenv, args = args)
[10:26:25.854]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:25.854]             }
[10:26:25.854]             else {
[10:26:25.854]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:25.854]             }
[10:26:25.854]             {
[10:26:25.854]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:25.854]                   0L) {
[10:26:25.854]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:25.854]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:25.854]                   base::options(opts)
[10:26:25.854]                 }
[10:26:25.854]                 {
[10:26:25.854]                   {
[10:26:25.854]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:25.854]                     NULL
[10:26:25.854]                   }
[10:26:25.854]                   options(future.plan = NULL)
[10:26:25.854]                   if (is.na(NA_character_)) 
[10:26:25.854]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:25.854]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:25.854]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:25.854]                   {
[10:26:25.854]                     future <- SequentialFuture(..., envir = envir)
[10:26:25.854]                     if (!future$lazy) 
[10:26:25.854]                       future <- run(future)
[10:26:25.854]                     invisible(future)
[10:26:25.854]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:25.854]                 }
[10:26:25.854]             }
[10:26:25.854]         }
[10:26:25.854]     })
[10:26:25.854]     if (TRUE) {
[10:26:25.854]         base::sink(type = "output", split = FALSE)
[10:26:25.854]         if (TRUE) {
[10:26:25.854]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:25.854]         }
[10:26:25.854]         else {
[10:26:25.854]             ...future.result["stdout"] <- base::list(NULL)
[10:26:25.854]         }
[10:26:25.854]         base::close(...future.stdout)
[10:26:25.854]         ...future.stdout <- NULL
[10:26:25.854]     }
[10:26:25.854]     ...future.result$conditions <- ...future.conditions
[10:26:25.854]     ...future.result$finished <- base::Sys.time()
[10:26:25.854]     ...future.result
[10:26:25.854] }
[10:26:25.907] MultisessionFuture started
MultisessionFuture:
Label: ‘<none>’
Expression:
{
    42L
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: b237ea00-048b-53bc-62d3-d50d6929ba00
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[1] FALSE
[10:26:25.930] result() for ClusterFuture ...
[10:26:25.931] receiveMessageFromWorker() for ClusterFuture ...
[10:26:25.931] - Validating connection of MultisessionFuture
[10:26:25.942] - received message: FutureResult
[10:26:25.943] - Received FutureResult
[10:26:25.946] - Erased future from FutureRegistry
[10:26:25.946] result() for ClusterFuture ...
[10:26:25.946] - result already collected: FutureResult
[10:26:25.946] result() for ClusterFuture ... done
[10:26:25.946] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:25.946] result() for ClusterFuture ... done
[10:26:25.946] result() for ClusterFuture ...
[10:26:25.947] - result already collected: FutureResult
[10:26:25.947] result() for ClusterFuture ... done
[1] 42
[10:26:25.951] getGlobalsAndPackages() ...
[10:26:25.951] Searching for globals...
[10:26:25.954] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘a’
[10:26:25.954] Searching for globals ... DONE
[10:26:25.954] Resolving globals: FALSE
[10:26:25.954] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:25.955] The total size of the 1 globals exported for future expression (‘{; b <- 3; c <- 2; a * b * c; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[10:26:25.955] - globals: [1] ‘a’
[10:26:25.955] 
[10:26:25.955] getGlobalsAndPackages() ... DONE
[10:26:25.966] Packages needed by the future expression (n = 0): <none>
[10:26:25.967] Packages needed by future strategies (n = 0): <none>
[10:26:25.967] {
[10:26:25.967]     {
[10:26:25.967]         {
[10:26:25.967]             ...future.startTime <- base::Sys.time()
[10:26:25.967]             {
[10:26:25.967]                 {
[10:26:25.967]                   {
[10:26:25.967]                     {
[10:26:25.967]                       base::local({
[10:26:25.967]                         has_future <- base::requireNamespace("future", 
[10:26:25.967]                           quietly = TRUE)
[10:26:25.967]                         if (has_future) {
[10:26:25.967]                           ns <- base::getNamespace("future")
[10:26:25.967]                           version <- ns[[".package"]][["version"]]
[10:26:25.967]                           if (is.null(version)) 
[10:26:25.967]                             version <- utils::packageVersion("future")
[10:26:25.967]                         }
[10:26:25.967]                         else {
[10:26:25.967]                           version <- NULL
[10:26:25.967]                         }
[10:26:25.967]                         if (!has_future || version < "1.8.0") {
[10:26:25.967]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:25.967]                             "", base::R.version$version.string), 
[10:26:25.967]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:25.967]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:25.967]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:25.967]                               "release", "version")], collapse = " "), 
[10:26:25.967]                             hostname = base::Sys.info()[["nodename"]])
[10:26:25.967]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:25.967]                             info)
[10:26:25.967]                           info <- base::paste(info, collapse = "; ")
[10:26:25.967]                           if (!has_future) {
[10:26:25.967]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:25.967]                               info)
[10:26:25.967]                           }
[10:26:25.967]                           else {
[10:26:25.967]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:25.967]                               info, version)
[10:26:25.967]                           }
[10:26:25.967]                           base::stop(msg)
[10:26:25.967]                         }
[10:26:25.967]                       })
[10:26:25.967]                     }
[10:26:25.967]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:25.967]                     base::options(mc.cores = 1L)
[10:26:25.967]                   }
[10:26:25.967]                   options(future.plan = NULL)
[10:26:25.967]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:25.967]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:25.967]                 }
[10:26:25.967]                 ...future.workdir <- getwd()
[10:26:25.967]             }
[10:26:25.967]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:25.967]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:25.967]         }
[10:26:25.967]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:25.967]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:25.967]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:25.967]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:25.967]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:25.967]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:25.967]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:25.967]             base::names(...future.oldOptions))
[10:26:25.967]     }
[10:26:25.967]     if (FALSE) {
[10:26:25.967]     }
[10:26:25.967]     else {
[10:26:25.967]         if (TRUE) {
[10:26:25.967]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:25.967]                 open = "w")
[10:26:25.967]         }
[10:26:25.967]         else {
[10:26:25.967]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:25.967]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:25.967]         }
[10:26:25.967]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:25.967]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:25.967]             base::sink(type = "output", split = FALSE)
[10:26:25.967]             base::close(...future.stdout)
[10:26:25.967]         }, add = TRUE)
[10:26:25.967]     }
[10:26:25.967]     ...future.frame <- base::sys.nframe()
[10:26:25.967]     ...future.conditions <- base::list()
[10:26:25.967]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:25.967]     if (FALSE) {
[10:26:25.967]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:25.967]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:25.967]     }
[10:26:25.967]     ...future.result <- base::tryCatch({
[10:26:25.967]         base::withCallingHandlers({
[10:26:25.967]             ...future.value <- base::withVisible(base::local({
[10:26:25.967]                 ...future.makeSendCondition <- base::local({
[10:26:25.967]                   sendCondition <- NULL
[10:26:25.967]                   function(frame = 1L) {
[10:26:25.967]                     if (is.function(sendCondition)) 
[10:26:25.967]                       return(sendCondition)
[10:26:25.967]                     ns <- getNamespace("parallel")
[10:26:25.967]                     if (exists("sendData", mode = "function", 
[10:26:25.967]                       envir = ns)) {
[10:26:25.967]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:25.967]                         envir = ns)
[10:26:25.967]                       envir <- sys.frame(frame)
[10:26:25.967]                       master <- NULL
[10:26:25.967]                       while (!identical(envir, .GlobalEnv) && 
[10:26:25.967]                         !identical(envir, emptyenv())) {
[10:26:25.967]                         if (exists("master", mode = "list", envir = envir, 
[10:26:25.967]                           inherits = FALSE)) {
[10:26:25.967]                           master <- get("master", mode = "list", 
[10:26:25.967]                             envir = envir, inherits = FALSE)
[10:26:25.967]                           if (inherits(master, c("SOCKnode", 
[10:26:25.967]                             "SOCK0node"))) {
[10:26:25.967]                             sendCondition <<- function(cond) {
[10:26:25.967]                               data <- list(type = "VALUE", value = cond, 
[10:26:25.967]                                 success = TRUE)
[10:26:25.967]                               parallel_sendData(master, data)
[10:26:25.967]                             }
[10:26:25.967]                             return(sendCondition)
[10:26:25.967]                           }
[10:26:25.967]                         }
[10:26:25.967]                         frame <- frame + 1L
[10:26:25.967]                         envir <- sys.frame(frame)
[10:26:25.967]                       }
[10:26:25.967]                     }
[10:26:25.967]                     sendCondition <<- function(cond) NULL
[10:26:25.967]                   }
[10:26:25.967]                 })
[10:26:25.967]                 withCallingHandlers({
[10:26:25.967]                   {
[10:26:25.967]                     b <- 3
[10:26:25.967]                     c <- 2
[10:26:25.967]                     a * b * c
[10:26:25.967]                   }
[10:26:25.967]                 }, immediateCondition = function(cond) {
[10:26:25.967]                   sendCondition <- ...future.makeSendCondition()
[10:26:25.967]                   sendCondition(cond)
[10:26:25.967]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:25.967]                   {
[10:26:25.967]                     inherits <- base::inherits
[10:26:25.967]                     invokeRestart <- base::invokeRestart
[10:26:25.967]                     is.null <- base::is.null
[10:26:25.967]                     muffled <- FALSE
[10:26:25.967]                     if (inherits(cond, "message")) {
[10:26:25.967]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:25.967]                       if (muffled) 
[10:26:25.967]                         invokeRestart("muffleMessage")
[10:26:25.967]                     }
[10:26:25.967]                     else if (inherits(cond, "warning")) {
[10:26:25.967]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:25.967]                       if (muffled) 
[10:26:25.967]                         invokeRestart("muffleWarning")
[10:26:25.967]                     }
[10:26:25.967]                     else if (inherits(cond, "condition")) {
[10:26:25.967]                       if (!is.null(pattern)) {
[10:26:25.967]                         computeRestarts <- base::computeRestarts
[10:26:25.967]                         grepl <- base::grepl
[10:26:25.967]                         restarts <- computeRestarts(cond)
[10:26:25.967]                         for (restart in restarts) {
[10:26:25.967]                           name <- restart$name
[10:26:25.967]                           if (is.null(name)) 
[10:26:25.967]                             next
[10:26:25.967]                           if (!grepl(pattern, name)) 
[10:26:25.967]                             next
[10:26:25.967]                           invokeRestart(restart)
[10:26:25.967]                           muffled <- TRUE
[10:26:25.967]                           break
[10:26:25.967]                         }
[10:26:25.967]                       }
[10:26:25.967]                     }
[10:26:25.967]                     invisible(muffled)
[10:26:25.967]                   }
[10:26:25.967]                   muffleCondition(cond)
[10:26:25.967]                 })
[10:26:25.967]             }))
[10:26:25.967]             future::FutureResult(value = ...future.value$value, 
[10:26:25.967]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:25.967]                   ...future.rng), globalenv = if (FALSE) 
[10:26:25.967]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:25.967]                     ...future.globalenv.names))
[10:26:25.967]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:25.967]         }, condition = base::local({
[10:26:25.967]             c <- base::c
[10:26:25.967]             inherits <- base::inherits
[10:26:25.967]             invokeRestart <- base::invokeRestart
[10:26:25.967]             length <- base::length
[10:26:25.967]             list <- base::list
[10:26:25.967]             seq.int <- base::seq.int
[10:26:25.967]             signalCondition <- base::signalCondition
[10:26:25.967]             sys.calls <- base::sys.calls
[10:26:25.967]             `[[` <- base::`[[`
[10:26:25.967]             `+` <- base::`+`
[10:26:25.967]             `<<-` <- base::`<<-`
[10:26:25.967]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:25.967]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:25.967]                   3L)]
[10:26:25.967]             }
[10:26:25.967]             function(cond) {
[10:26:25.967]                 is_error <- inherits(cond, "error")
[10:26:25.967]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:25.967]                   NULL)
[10:26:25.967]                 if (is_error) {
[10:26:25.967]                   sessionInformation <- function() {
[10:26:25.967]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:25.967]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:25.967]                       search = base::search(), system = base::Sys.info())
[10:26:25.967]                   }
[10:26:25.967]                   ...future.conditions[[length(...future.conditions) + 
[10:26:25.967]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:25.967]                     cond$call), session = sessionInformation(), 
[10:26:25.967]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:25.967]                   signalCondition(cond)
[10:26:25.967]                 }
[10:26:25.967]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:25.967]                 "immediateCondition"))) {
[10:26:25.967]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:25.967]                   ...future.conditions[[length(...future.conditions) + 
[10:26:25.967]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:25.967]                   if (TRUE && !signal) {
[10:26:25.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:25.967]                     {
[10:26:25.967]                       inherits <- base::inherits
[10:26:25.967]                       invokeRestart <- base::invokeRestart
[10:26:25.967]                       is.null <- base::is.null
[10:26:25.967]                       muffled <- FALSE
[10:26:25.967]                       if (inherits(cond, "message")) {
[10:26:25.967]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:25.967]                         if (muffled) 
[10:26:25.967]                           invokeRestart("muffleMessage")
[10:26:25.967]                       }
[10:26:25.967]                       else if (inherits(cond, "warning")) {
[10:26:25.967]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:25.967]                         if (muffled) 
[10:26:25.967]                           invokeRestart("muffleWarning")
[10:26:25.967]                       }
[10:26:25.967]                       else if (inherits(cond, "condition")) {
[10:26:25.967]                         if (!is.null(pattern)) {
[10:26:25.967]                           computeRestarts <- base::computeRestarts
[10:26:25.967]                           grepl <- base::grepl
[10:26:25.967]                           restarts <- computeRestarts(cond)
[10:26:25.967]                           for (restart in restarts) {
[10:26:25.967]                             name <- restart$name
[10:26:25.967]                             if (is.null(name)) 
[10:26:25.967]                               next
[10:26:25.967]                             if (!grepl(pattern, name)) 
[10:26:25.967]                               next
[10:26:25.967]                             invokeRestart(restart)
[10:26:25.967]                             muffled <- TRUE
[10:26:25.967]                             break
[10:26:25.967]                           }
[10:26:25.967]                         }
[10:26:25.967]                       }
[10:26:25.967]                       invisible(muffled)
[10:26:25.967]                     }
[10:26:25.967]                     muffleCondition(cond, pattern = "^muffle")
[10:26:25.967]                   }
[10:26:25.967]                 }
[10:26:25.967]                 else {
[10:26:25.967]                   if (TRUE) {
[10:26:25.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:25.967]                     {
[10:26:25.967]                       inherits <- base::inherits
[10:26:25.967]                       invokeRestart <- base::invokeRestart
[10:26:25.967]                       is.null <- base::is.null
[10:26:25.967]                       muffled <- FALSE
[10:26:25.967]                       if (inherits(cond, "message")) {
[10:26:25.967]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:25.967]                         if (muffled) 
[10:26:25.967]                           invokeRestart("muffleMessage")
[10:26:25.967]                       }
[10:26:25.967]                       else if (inherits(cond, "warning")) {
[10:26:25.967]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:25.967]                         if (muffled) 
[10:26:25.967]                           invokeRestart("muffleWarning")
[10:26:25.967]                       }
[10:26:25.967]                       else if (inherits(cond, "condition")) {
[10:26:25.967]                         if (!is.null(pattern)) {
[10:26:25.967]                           computeRestarts <- base::computeRestarts
[10:26:25.967]                           grepl <- base::grepl
[10:26:25.967]                           restarts <- computeRestarts(cond)
[10:26:25.967]                           for (restart in restarts) {
[10:26:25.967]                             name <- restart$name
[10:26:25.967]                             if (is.null(name)) 
[10:26:25.967]                               next
[10:26:25.967]                             if (!grepl(pattern, name)) 
[10:26:25.967]                               next
[10:26:25.967]                             invokeRestart(restart)
[10:26:25.967]                             muffled <- TRUE
[10:26:25.967]                             break
[10:26:25.967]                           }
[10:26:25.967]                         }
[10:26:25.967]                       }
[10:26:25.967]                       invisible(muffled)
[10:26:25.967]                     }
[10:26:25.967]                     muffleCondition(cond, pattern = "^muffle")
[10:26:25.967]                   }
[10:26:25.967]                 }
[10:26:25.967]             }
[10:26:25.967]         }))
[10:26:25.967]     }, error = function(ex) {
[10:26:25.967]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:25.967]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:25.967]                 ...future.rng), started = ...future.startTime, 
[10:26:25.967]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:25.967]             version = "1.8"), class = "FutureResult")
[10:26:25.967]     }, finally = {
[10:26:25.967]         if (!identical(...future.workdir, getwd())) 
[10:26:25.967]             setwd(...future.workdir)
[10:26:25.967]         {
[10:26:25.967]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:25.967]                 ...future.oldOptions$nwarnings <- NULL
[10:26:25.967]             }
[10:26:25.967]             base::options(...future.oldOptions)
[10:26:25.967]             if (.Platform$OS.type == "windows") {
[10:26:25.967]                 old_names <- names(...future.oldEnvVars)
[10:26:25.967]                 envs <- base::Sys.getenv()
[10:26:25.967]                 names <- names(envs)
[10:26:25.967]                 common <- intersect(names, old_names)
[10:26:25.967]                 added <- setdiff(names, old_names)
[10:26:25.967]                 removed <- setdiff(old_names, names)
[10:26:25.967]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:25.967]                   envs[common]]
[10:26:25.967]                 NAMES <- toupper(changed)
[10:26:25.967]                 args <- list()
[10:26:25.967]                 for (kk in seq_along(NAMES)) {
[10:26:25.967]                   name <- changed[[kk]]
[10:26:25.967]                   NAME <- NAMES[[kk]]
[10:26:25.967]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:25.967]                     next
[10:26:25.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:25.967]                 }
[10:26:25.967]                 NAMES <- toupper(added)
[10:26:25.967]                 for (kk in seq_along(NAMES)) {
[10:26:25.967]                   name <- added[[kk]]
[10:26:25.967]                   NAME <- NAMES[[kk]]
[10:26:25.967]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:25.967]                     next
[10:26:25.967]                   args[[name]] <- ""
[10:26:25.967]                 }
[10:26:25.967]                 NAMES <- toupper(removed)
[10:26:25.967]                 for (kk in seq_along(NAMES)) {
[10:26:25.967]                   name <- removed[[kk]]
[10:26:25.967]                   NAME <- NAMES[[kk]]
[10:26:25.967]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:25.967]                     next
[10:26:25.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:25.967]                 }
[10:26:25.967]                 if (length(args) > 0) 
[10:26:25.967]                   base::do.call(base::Sys.setenv, args = args)
[10:26:25.967]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:25.967]             }
[10:26:25.967]             else {
[10:26:25.967]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:25.967]             }
[10:26:25.967]             {
[10:26:25.967]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:25.967]                   0L) {
[10:26:25.967]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:25.967]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:25.967]                   base::options(opts)
[10:26:25.967]                 }
[10:26:25.967]                 {
[10:26:25.967]                   {
[10:26:25.967]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:25.967]                     NULL
[10:26:25.967]                   }
[10:26:25.967]                   options(future.plan = NULL)
[10:26:25.967]                   if (is.na(NA_character_)) 
[10:26:25.967]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:25.967]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:25.967]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:25.967]                   {
[10:26:25.967]                     future <- SequentialFuture(..., envir = envir)
[10:26:25.967]                     if (!future$lazy) 
[10:26:25.967]                       future <- run(future)
[10:26:25.967]                     invisible(future)
[10:26:25.967]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:25.967]                 }
[10:26:25.967]             }
[10:26:25.967]         }
[10:26:25.967]     })
[10:26:25.967]     if (TRUE) {
[10:26:25.967]         base::sink(type = "output", split = FALSE)
[10:26:25.967]         if (TRUE) {
[10:26:25.967]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:25.967]         }
[10:26:25.967]         else {
[10:26:25.967]             ...future.result["stdout"] <- base::list(NULL)
[10:26:25.967]         }
[10:26:25.967]         base::close(...future.stdout)
[10:26:25.967]         ...future.stdout <- NULL
[10:26:25.967]     }
[10:26:25.967]     ...future.result$conditions <- ...future.conditions
[10:26:25.967]     ...future.result$finished <- base::Sys.time()
[10:26:25.967]     ...future.result
[10:26:25.967] }
[10:26:25.970] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[10:26:25.970] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[10:26:25.971] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[10:26:25.971] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[10:26:25.971] MultisessionFuture started
MultisessionFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: 1 objects totaling 56 bytes (numeric ‘a’ of 56 bytes)
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: b237ea00-048b-53bc-62d3-d50d6929ba00
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:25.983] result() for ClusterFuture ...
[10:26:25.983] receiveMessageFromWorker() for ClusterFuture ...
[10:26:25.983] - Validating connection of MultisessionFuture
[10:26:26.022] - received message: FutureResult
[10:26:26.022] - Received FutureResult
[10:26:26.022] - Erased future from FutureRegistry
[10:26:26.023] result() for ClusterFuture ...
[10:26:26.023] - result already collected: FutureResult
[10:26:26.023] result() for ClusterFuture ... done
[10:26:26.023] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:26.023] result() for ClusterFuture ... done
[10:26:26.023] result() for ClusterFuture ...
[10:26:26.023] - result already collected: FutureResult
[10:26:26.023] result() for ClusterFuture ... done
[1] 0
*** multisession() with globals and blocking
 - Creating multisession future #2 ...
[10:26:26.027] getGlobalsAndPackages() ...
[10:26:26.027] Searching for globals...
[10:26:26.028] - globals found: [2] ‘{’, ‘ii’
[10:26:26.028] Searching for globals ... DONE
[10:26:26.029] Resolving globals: FALSE
[10:26:26.029] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:26.029] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:26:26.030] - globals: [1] ‘ii’
[10:26:26.030] 
[10:26:26.030] getGlobalsAndPackages() ... DONE
[10:26:26.041] Packages needed by the future expression (n = 0): <none>
[10:26:26.041] Packages needed by future strategies (n = 0): <none>
[10:26:26.041] {
[10:26:26.041]     {
[10:26:26.041]         {
[10:26:26.041]             ...future.startTime <- base::Sys.time()
[10:26:26.041]             {
[10:26:26.041]                 {
[10:26:26.041]                   {
[10:26:26.041]                     {
[10:26:26.041]                       base::local({
[10:26:26.041]                         has_future <- base::requireNamespace("future", 
[10:26:26.041]                           quietly = TRUE)
[10:26:26.041]                         if (has_future) {
[10:26:26.041]                           ns <- base::getNamespace("future")
[10:26:26.041]                           version <- ns[[".package"]][["version"]]
[10:26:26.041]                           if (is.null(version)) 
[10:26:26.041]                             version <- utils::packageVersion("future")
[10:26:26.041]                         }
[10:26:26.041]                         else {
[10:26:26.041]                           version <- NULL
[10:26:26.041]                         }
[10:26:26.041]                         if (!has_future || version < "1.8.0") {
[10:26:26.041]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:26.041]                             "", base::R.version$version.string), 
[10:26:26.041]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:26.041]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:26.041]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:26.041]                               "release", "version")], collapse = " "), 
[10:26:26.041]                             hostname = base::Sys.info()[["nodename"]])
[10:26:26.041]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:26.041]                             info)
[10:26:26.041]                           info <- base::paste(info, collapse = "; ")
[10:26:26.041]                           if (!has_future) {
[10:26:26.041]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:26.041]                               info)
[10:26:26.041]                           }
[10:26:26.041]                           else {
[10:26:26.041]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:26.041]                               info, version)
[10:26:26.041]                           }
[10:26:26.041]                           base::stop(msg)
[10:26:26.041]                         }
[10:26:26.041]                       })
[10:26:26.041]                     }
[10:26:26.041]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:26.041]                     base::options(mc.cores = 1L)
[10:26:26.041]                   }
[10:26:26.041]                   options(future.plan = NULL)
[10:26:26.041]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:26.041]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:26.041]                 }
[10:26:26.041]                 ...future.workdir <- getwd()
[10:26:26.041]             }
[10:26:26.041]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:26.041]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:26.041]         }
[10:26:26.041]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:26.041]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:26.041]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:26.041]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:26.041]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:26.041]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:26.041]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:26.041]             base::names(...future.oldOptions))
[10:26:26.041]     }
[10:26:26.041]     if (FALSE) {
[10:26:26.041]     }
[10:26:26.041]     else {
[10:26:26.041]         if (TRUE) {
[10:26:26.041]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:26.041]                 open = "w")
[10:26:26.041]         }
[10:26:26.041]         else {
[10:26:26.041]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:26.041]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:26.041]         }
[10:26:26.041]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:26.041]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:26.041]             base::sink(type = "output", split = FALSE)
[10:26:26.041]             base::close(...future.stdout)
[10:26:26.041]         }, add = TRUE)
[10:26:26.041]     }
[10:26:26.041]     ...future.frame <- base::sys.nframe()
[10:26:26.041]     ...future.conditions <- base::list()
[10:26:26.041]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:26.041]     if (FALSE) {
[10:26:26.041]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:26.041]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:26.041]     }
[10:26:26.041]     ...future.result <- base::tryCatch({
[10:26:26.041]         base::withCallingHandlers({
[10:26:26.041]             ...future.value <- base::withVisible(base::local({
[10:26:26.041]                 ...future.makeSendCondition <- base::local({
[10:26:26.041]                   sendCondition <- NULL
[10:26:26.041]                   function(frame = 1L) {
[10:26:26.041]                     if (is.function(sendCondition)) 
[10:26:26.041]                       return(sendCondition)
[10:26:26.041]                     ns <- getNamespace("parallel")
[10:26:26.041]                     if (exists("sendData", mode = "function", 
[10:26:26.041]                       envir = ns)) {
[10:26:26.041]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:26.041]                         envir = ns)
[10:26:26.041]                       envir <- sys.frame(frame)
[10:26:26.041]                       master <- NULL
[10:26:26.041]                       while (!identical(envir, .GlobalEnv) && 
[10:26:26.041]                         !identical(envir, emptyenv())) {
[10:26:26.041]                         if (exists("master", mode = "list", envir = envir, 
[10:26:26.041]                           inherits = FALSE)) {
[10:26:26.041]                           master <- get("master", mode = "list", 
[10:26:26.041]                             envir = envir, inherits = FALSE)
[10:26:26.041]                           if (inherits(master, c("SOCKnode", 
[10:26:26.041]                             "SOCK0node"))) {
[10:26:26.041]                             sendCondition <<- function(cond) {
[10:26:26.041]                               data <- list(type = "VALUE", value = cond, 
[10:26:26.041]                                 success = TRUE)
[10:26:26.041]                               parallel_sendData(master, data)
[10:26:26.041]                             }
[10:26:26.041]                             return(sendCondition)
[10:26:26.041]                           }
[10:26:26.041]                         }
[10:26:26.041]                         frame <- frame + 1L
[10:26:26.041]                         envir <- sys.frame(frame)
[10:26:26.041]                       }
[10:26:26.041]                     }
[10:26:26.041]                     sendCondition <<- function(cond) NULL
[10:26:26.041]                   }
[10:26:26.041]                 })
[10:26:26.041]                 withCallingHandlers({
[10:26:26.041]                   {
[10:26:26.041]                     ii
[10:26:26.041]                   }
[10:26:26.041]                 }, immediateCondition = function(cond) {
[10:26:26.041]                   sendCondition <- ...future.makeSendCondition()
[10:26:26.041]                   sendCondition(cond)
[10:26:26.041]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:26.041]                   {
[10:26:26.041]                     inherits <- base::inherits
[10:26:26.041]                     invokeRestart <- base::invokeRestart
[10:26:26.041]                     is.null <- base::is.null
[10:26:26.041]                     muffled <- FALSE
[10:26:26.041]                     if (inherits(cond, "message")) {
[10:26:26.041]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:26.041]                       if (muffled) 
[10:26:26.041]                         invokeRestart("muffleMessage")
[10:26:26.041]                     }
[10:26:26.041]                     else if (inherits(cond, "warning")) {
[10:26:26.041]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:26.041]                       if (muffled) 
[10:26:26.041]                         invokeRestart("muffleWarning")
[10:26:26.041]                     }
[10:26:26.041]                     else if (inherits(cond, "condition")) {
[10:26:26.041]                       if (!is.null(pattern)) {
[10:26:26.041]                         computeRestarts <- base::computeRestarts
[10:26:26.041]                         grepl <- base::grepl
[10:26:26.041]                         restarts <- computeRestarts(cond)
[10:26:26.041]                         for (restart in restarts) {
[10:26:26.041]                           name <- restart$name
[10:26:26.041]                           if (is.null(name)) 
[10:26:26.041]                             next
[10:26:26.041]                           if (!grepl(pattern, name)) 
[10:26:26.041]                             next
[10:26:26.041]                           invokeRestart(restart)
[10:26:26.041]                           muffled <- TRUE
[10:26:26.041]                           break
[10:26:26.041]                         }
[10:26:26.041]                       }
[10:26:26.041]                     }
[10:26:26.041]                     invisible(muffled)
[10:26:26.041]                   }
[10:26:26.041]                   muffleCondition(cond)
[10:26:26.041]                 })
[10:26:26.041]             }))
[10:26:26.041]             future::FutureResult(value = ...future.value$value, 
[10:26:26.041]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:26.041]                   ...future.rng), globalenv = if (FALSE) 
[10:26:26.041]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:26.041]                     ...future.globalenv.names))
[10:26:26.041]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:26.041]         }, condition = base::local({
[10:26:26.041]             c <- base::c
[10:26:26.041]             inherits <- base::inherits
[10:26:26.041]             invokeRestart <- base::invokeRestart
[10:26:26.041]             length <- base::length
[10:26:26.041]             list <- base::list
[10:26:26.041]             seq.int <- base::seq.int
[10:26:26.041]             signalCondition <- base::signalCondition
[10:26:26.041]             sys.calls <- base::sys.calls
[10:26:26.041]             `[[` <- base::`[[`
[10:26:26.041]             `+` <- base::`+`
[10:26:26.041]             `<<-` <- base::`<<-`
[10:26:26.041]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:26.041]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:26.041]                   3L)]
[10:26:26.041]             }
[10:26:26.041]             function(cond) {
[10:26:26.041]                 is_error <- inherits(cond, "error")
[10:26:26.041]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:26.041]                   NULL)
[10:26:26.041]                 if (is_error) {
[10:26:26.041]                   sessionInformation <- function() {
[10:26:26.041]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:26.041]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:26.041]                       search = base::search(), system = base::Sys.info())
[10:26:26.041]                   }
[10:26:26.041]                   ...future.conditions[[length(...future.conditions) + 
[10:26:26.041]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:26.041]                     cond$call), session = sessionInformation(), 
[10:26:26.041]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:26.041]                   signalCondition(cond)
[10:26:26.041]                 }
[10:26:26.041]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:26.041]                 "immediateCondition"))) {
[10:26:26.041]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:26.041]                   ...future.conditions[[length(...future.conditions) + 
[10:26:26.041]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:26.041]                   if (TRUE && !signal) {
[10:26:26.041]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:26.041]                     {
[10:26:26.041]                       inherits <- base::inherits
[10:26:26.041]                       invokeRestart <- base::invokeRestart
[10:26:26.041]                       is.null <- base::is.null
[10:26:26.041]                       muffled <- FALSE
[10:26:26.041]                       if (inherits(cond, "message")) {
[10:26:26.041]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:26.041]                         if (muffled) 
[10:26:26.041]                           invokeRestart("muffleMessage")
[10:26:26.041]                       }
[10:26:26.041]                       else if (inherits(cond, "warning")) {
[10:26:26.041]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:26.041]                         if (muffled) 
[10:26:26.041]                           invokeRestart("muffleWarning")
[10:26:26.041]                       }
[10:26:26.041]                       else if (inherits(cond, "condition")) {
[10:26:26.041]                         if (!is.null(pattern)) {
[10:26:26.041]                           computeRestarts <- base::computeRestarts
[10:26:26.041]                           grepl <- base::grepl
[10:26:26.041]                           restarts <- computeRestarts(cond)
[10:26:26.041]                           for (restart in restarts) {
[10:26:26.041]                             name <- restart$name
[10:26:26.041]                             if (is.null(name)) 
[10:26:26.041]                               next
[10:26:26.041]                             if (!grepl(pattern, name)) 
[10:26:26.041]                               next
[10:26:26.041]                             invokeRestart(restart)
[10:26:26.041]                             muffled <- TRUE
[10:26:26.041]                             break
[10:26:26.041]                           }
[10:26:26.041]                         }
[10:26:26.041]                       }
[10:26:26.041]                       invisible(muffled)
[10:26:26.041]                     }
[10:26:26.041]                     muffleCondition(cond, pattern = "^muffle")
[10:26:26.041]                   }
[10:26:26.041]                 }
[10:26:26.041]                 else {
[10:26:26.041]                   if (TRUE) {
[10:26:26.041]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:26.041]                     {
[10:26:26.041]                       inherits <- base::inherits
[10:26:26.041]                       invokeRestart <- base::invokeRestart
[10:26:26.041]                       is.null <- base::is.null
[10:26:26.041]                       muffled <- FALSE
[10:26:26.041]                       if (inherits(cond, "message")) {
[10:26:26.041]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:26.041]                         if (muffled) 
[10:26:26.041]                           invokeRestart("muffleMessage")
[10:26:26.041]                       }
[10:26:26.041]                       else if (inherits(cond, "warning")) {
[10:26:26.041]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:26.041]                         if (muffled) 
[10:26:26.041]                           invokeRestart("muffleWarning")
[10:26:26.041]                       }
[10:26:26.041]                       else if (inherits(cond, "condition")) {
[10:26:26.041]                         if (!is.null(pattern)) {
[10:26:26.041]                           computeRestarts <- base::computeRestarts
[10:26:26.041]                           grepl <- base::grepl
[10:26:26.041]                           restarts <- computeRestarts(cond)
[10:26:26.041]                           for (restart in restarts) {
[10:26:26.041]                             name <- restart$name
[10:26:26.041]                             if (is.null(name)) 
[10:26:26.041]                               next
[10:26:26.041]                             if (!grepl(pattern, name)) 
[10:26:26.041]                               next
[10:26:26.041]                             invokeRestart(restart)
[10:26:26.041]                             muffled <- TRUE
[10:26:26.041]                             break
[10:26:26.041]                           }
[10:26:26.041]                         }
[10:26:26.041]                       }
[10:26:26.041]                       invisible(muffled)
[10:26:26.041]                     }
[10:26:26.041]                     muffleCondition(cond, pattern = "^muffle")
[10:26:26.041]                   }
[10:26:26.041]                 }
[10:26:26.041]             }
[10:26:26.041]         }))
[10:26:26.041]     }, error = function(ex) {
[10:26:26.041]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:26.041]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:26.041]                 ...future.rng), started = ...future.startTime, 
[10:26:26.041]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:26.041]             version = "1.8"), class = "FutureResult")
[10:26:26.041]     }, finally = {
[10:26:26.041]         if (!identical(...future.workdir, getwd())) 
[10:26:26.041]             setwd(...future.workdir)
[10:26:26.041]         {
[10:26:26.041]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:26.041]                 ...future.oldOptions$nwarnings <- NULL
[10:26:26.041]             }
[10:26:26.041]             base::options(...future.oldOptions)
[10:26:26.041]             if (.Platform$OS.type == "windows") {
[10:26:26.041]                 old_names <- names(...future.oldEnvVars)
[10:26:26.041]                 envs <- base::Sys.getenv()
[10:26:26.041]                 names <- names(envs)
[10:26:26.041]                 common <- intersect(names, old_names)
[10:26:26.041]                 added <- setdiff(names, old_names)
[10:26:26.041]                 removed <- setdiff(old_names, names)
[10:26:26.041]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:26.041]                   envs[common]]
[10:26:26.041]                 NAMES <- toupper(changed)
[10:26:26.041]                 args <- list()
[10:26:26.041]                 for (kk in seq_along(NAMES)) {
[10:26:26.041]                   name <- changed[[kk]]
[10:26:26.041]                   NAME <- NAMES[[kk]]
[10:26:26.041]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:26.041]                     next
[10:26:26.041]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:26.041]                 }
[10:26:26.041]                 NAMES <- toupper(added)
[10:26:26.041]                 for (kk in seq_along(NAMES)) {
[10:26:26.041]                   name <- added[[kk]]
[10:26:26.041]                   NAME <- NAMES[[kk]]
[10:26:26.041]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:26.041]                     next
[10:26:26.041]                   args[[name]] <- ""
[10:26:26.041]                 }
[10:26:26.041]                 NAMES <- toupper(removed)
[10:26:26.041]                 for (kk in seq_along(NAMES)) {
[10:26:26.041]                   name <- removed[[kk]]
[10:26:26.041]                   NAME <- NAMES[[kk]]
[10:26:26.041]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:26.041]                     next
[10:26:26.041]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:26.041]                 }
[10:26:26.041]                 if (length(args) > 0) 
[10:26:26.041]                   base::do.call(base::Sys.setenv, args = args)
[10:26:26.041]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:26.041]             }
[10:26:26.041]             else {
[10:26:26.041]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:26.041]             }
[10:26:26.041]             {
[10:26:26.041]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:26.041]                   0L) {
[10:26:26.041]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:26.041]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:26.041]                   base::options(opts)
[10:26:26.041]                 }
[10:26:26.041]                 {
[10:26:26.041]                   {
[10:26:26.041]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:26.041]                     NULL
[10:26:26.041]                   }
[10:26:26.041]                   options(future.plan = NULL)
[10:26:26.041]                   if (is.na(NA_character_)) 
[10:26:26.041]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:26.041]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:26.041]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:26.041]                   {
[10:26:26.041]                     future <- SequentialFuture(..., envir = envir)
[10:26:26.041]                     if (!future$lazy) 
[10:26:26.041]                       future <- run(future)
[10:26:26.041]                     invisible(future)
[10:26:26.041]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:26.041]                 }
[10:26:26.041]             }
[10:26:26.041]         }
[10:26:26.041]     })
[10:26:26.041]     if (TRUE) {
[10:26:26.041]         base::sink(type = "output", split = FALSE)
[10:26:26.041]         if (TRUE) {
[10:26:26.041]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:26.041]         }
[10:26:26.041]         else {
[10:26:26.041]             ...future.result["stdout"] <- base::list(NULL)
[10:26:26.041]         }
[10:26:26.041]         base::close(...future.stdout)
[10:26:26.041]         ...future.stdout <- NULL
[10:26:26.041]     }
[10:26:26.041]     ...future.result$conditions <- ...future.conditions
[10:26:26.041]     ...future.result$finished <- base::Sys.time()
[10:26:26.041]     ...future.result
[10:26:26.041] }
[10:26:26.044] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[10:26:26.044] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[10:26:26.045] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[10:26:26.045] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[10:26:26.046] MultisessionFuture started
 - Creating multisession future #1 ...
[10:26:26.049] getGlobalsAndPackages() ...
[10:26:26.050] Searching for globals...
[10:26:26.050] - globals found: [2] ‘{’, ‘ii’
[10:26:26.050] Searching for globals ... DONE
[10:26:26.051] Resolving globals: FALSE
[10:26:26.051] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:26.051] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:26:26.052] - globals: [1] ‘ii’
[10:26:26.052] 
[10:26:26.052] getGlobalsAndPackages() ... DONE
[10:26:26.063] Packages needed by the future expression (n = 0): <none>
[10:26:26.063] Packages needed by future strategies (n = 0): <none>
[10:26:26.063] {
[10:26:26.063]     {
[10:26:26.063]         {
[10:26:26.063]             ...future.startTime <- base::Sys.time()
[10:26:26.063]             {
[10:26:26.063]                 {
[10:26:26.063]                   {
[10:26:26.063]                     {
[10:26:26.063]                       base::local({
[10:26:26.063]                         has_future <- base::requireNamespace("future", 
[10:26:26.063]                           quietly = TRUE)
[10:26:26.063]                         if (has_future) {
[10:26:26.063]                           ns <- base::getNamespace("future")
[10:26:26.063]                           version <- ns[[".package"]][["version"]]
[10:26:26.063]                           if (is.null(version)) 
[10:26:26.063]                             version <- utils::packageVersion("future")
[10:26:26.063]                         }
[10:26:26.063]                         else {
[10:26:26.063]                           version <- NULL
[10:26:26.063]                         }
[10:26:26.063]                         if (!has_future || version < "1.8.0") {
[10:26:26.063]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:26.063]                             "", base::R.version$version.string), 
[10:26:26.063]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:26.063]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:26.063]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:26.063]                               "release", "version")], collapse = " "), 
[10:26:26.063]                             hostname = base::Sys.info()[["nodename"]])
[10:26:26.063]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:26.063]                             info)
[10:26:26.063]                           info <- base::paste(info, collapse = "; ")
[10:26:26.063]                           if (!has_future) {
[10:26:26.063]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:26.063]                               info)
[10:26:26.063]                           }
[10:26:26.063]                           else {
[10:26:26.063]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:26.063]                               info, version)
[10:26:26.063]                           }
[10:26:26.063]                           base::stop(msg)
[10:26:26.063]                         }
[10:26:26.063]                       })
[10:26:26.063]                     }
[10:26:26.063]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:26.063]                     base::options(mc.cores = 1L)
[10:26:26.063]                   }
[10:26:26.063]                   options(future.plan = NULL)
[10:26:26.063]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:26.063]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:26.063]                 }
[10:26:26.063]                 ...future.workdir <- getwd()
[10:26:26.063]             }
[10:26:26.063]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:26.063]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:26.063]         }
[10:26:26.063]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:26.063]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:26.063]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:26.063]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:26.063]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:26.063]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:26.063]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:26.063]             base::names(...future.oldOptions))
[10:26:26.063]     }
[10:26:26.063]     if (FALSE) {
[10:26:26.063]     }
[10:26:26.063]     else {
[10:26:26.063]         if (TRUE) {
[10:26:26.063]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:26.063]                 open = "w")
[10:26:26.063]         }
[10:26:26.063]         else {
[10:26:26.063]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:26.063]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:26.063]         }
[10:26:26.063]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:26.063]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:26.063]             base::sink(type = "output", split = FALSE)
[10:26:26.063]             base::close(...future.stdout)
[10:26:26.063]         }, add = TRUE)
[10:26:26.063]     }
[10:26:26.063]     ...future.frame <- base::sys.nframe()
[10:26:26.063]     ...future.conditions <- base::list()
[10:26:26.063]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:26.063]     if (FALSE) {
[10:26:26.063]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:26.063]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:26.063]     }
[10:26:26.063]     ...future.result <- base::tryCatch({
[10:26:26.063]         base::withCallingHandlers({
[10:26:26.063]             ...future.value <- base::withVisible(base::local({
[10:26:26.063]                 ...future.makeSendCondition <- base::local({
[10:26:26.063]                   sendCondition <- NULL
[10:26:26.063]                   function(frame = 1L) {
[10:26:26.063]                     if (is.function(sendCondition)) 
[10:26:26.063]                       return(sendCondition)
[10:26:26.063]                     ns <- getNamespace("parallel")
[10:26:26.063]                     if (exists("sendData", mode = "function", 
[10:26:26.063]                       envir = ns)) {
[10:26:26.063]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:26.063]                         envir = ns)
[10:26:26.063]                       envir <- sys.frame(frame)
[10:26:26.063]                       master <- NULL
[10:26:26.063]                       while (!identical(envir, .GlobalEnv) && 
[10:26:26.063]                         !identical(envir, emptyenv())) {
[10:26:26.063]                         if (exists("master", mode = "list", envir = envir, 
[10:26:26.063]                           inherits = FALSE)) {
[10:26:26.063]                           master <- get("master", mode = "list", 
[10:26:26.063]                             envir = envir, inherits = FALSE)
[10:26:26.063]                           if (inherits(master, c("SOCKnode", 
[10:26:26.063]                             "SOCK0node"))) {
[10:26:26.063]                             sendCondition <<- function(cond) {
[10:26:26.063]                               data <- list(type = "VALUE", value = cond, 
[10:26:26.063]                                 success = TRUE)
[10:26:26.063]                               parallel_sendData(master, data)
[10:26:26.063]                             }
[10:26:26.063]                             return(sendCondition)
[10:26:26.063]                           }
[10:26:26.063]                         }
[10:26:26.063]                         frame <- frame + 1L
[10:26:26.063]                         envir <- sys.frame(frame)
[10:26:26.063]                       }
[10:26:26.063]                     }
[10:26:26.063]                     sendCondition <<- function(cond) NULL
[10:26:26.063]                   }
[10:26:26.063]                 })
[10:26:26.063]                 withCallingHandlers({
[10:26:26.063]                   {
[10:26:26.063]                     ii
[10:26:26.063]                   }
[10:26:26.063]                 }, immediateCondition = function(cond) {
[10:26:26.063]                   sendCondition <- ...future.makeSendCondition()
[10:26:26.063]                   sendCondition(cond)
[10:26:26.063]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:26.063]                   {
[10:26:26.063]                     inherits <- base::inherits
[10:26:26.063]                     invokeRestart <- base::invokeRestart
[10:26:26.063]                     is.null <- base::is.null
[10:26:26.063]                     muffled <- FALSE
[10:26:26.063]                     if (inherits(cond, "message")) {
[10:26:26.063]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:26.063]                       if (muffled) 
[10:26:26.063]                         invokeRestart("muffleMessage")
[10:26:26.063]                     }
[10:26:26.063]                     else if (inherits(cond, "warning")) {
[10:26:26.063]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:26.063]                       if (muffled) 
[10:26:26.063]                         invokeRestart("muffleWarning")
[10:26:26.063]                     }
[10:26:26.063]                     else if (inherits(cond, "condition")) {
[10:26:26.063]                       if (!is.null(pattern)) {
[10:26:26.063]                         computeRestarts <- base::computeRestarts
[10:26:26.063]                         grepl <- base::grepl
[10:26:26.063]                         restarts <- computeRestarts(cond)
[10:26:26.063]                         for (restart in restarts) {
[10:26:26.063]                           name <- restart$name
[10:26:26.063]                           if (is.null(name)) 
[10:26:26.063]                             next
[10:26:26.063]                           if (!grepl(pattern, name)) 
[10:26:26.063]                             next
[10:26:26.063]                           invokeRestart(restart)
[10:26:26.063]                           muffled <- TRUE
[10:26:26.063]                           break
[10:26:26.063]                         }
[10:26:26.063]                       }
[10:26:26.063]                     }
[10:26:26.063]                     invisible(muffled)
[10:26:26.063]                   }
[10:26:26.063]                   muffleCondition(cond)
[10:26:26.063]                 })
[10:26:26.063]             }))
[10:26:26.063]             future::FutureResult(value = ...future.value$value, 
[10:26:26.063]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:26.063]                   ...future.rng), globalenv = if (FALSE) 
[10:26:26.063]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:26.063]                     ...future.globalenv.names))
[10:26:26.063]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:26.063]         }, condition = base::local({
[10:26:26.063]             c <- base::c
[10:26:26.063]             inherits <- base::inherits
[10:26:26.063]             invokeRestart <- base::invokeRestart
[10:26:26.063]             length <- base::length
[10:26:26.063]             list <- base::list
[10:26:26.063]             seq.int <- base::seq.int
[10:26:26.063]             signalCondition <- base::signalCondition
[10:26:26.063]             sys.calls <- base::sys.calls
[10:26:26.063]             `[[` <- base::`[[`
[10:26:26.063]             `+` <- base::`+`
[10:26:26.063]             `<<-` <- base::`<<-`
[10:26:26.063]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:26.063]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:26.063]                   3L)]
[10:26:26.063]             }
[10:26:26.063]             function(cond) {
[10:26:26.063]                 is_error <- inherits(cond, "error")
[10:26:26.063]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:26.063]                   NULL)
[10:26:26.063]                 if (is_error) {
[10:26:26.063]                   sessionInformation <- function() {
[10:26:26.063]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:26.063]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:26.063]                       search = base::search(), system = base::Sys.info())
[10:26:26.063]                   }
[10:26:26.063]                   ...future.conditions[[length(...future.conditions) + 
[10:26:26.063]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:26.063]                     cond$call), session = sessionInformation(), 
[10:26:26.063]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:26.063]                   signalCondition(cond)
[10:26:26.063]                 }
[10:26:26.063]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:26.063]                 "immediateCondition"))) {
[10:26:26.063]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:26.063]                   ...future.conditions[[length(...future.conditions) + 
[10:26:26.063]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:26.063]                   if (TRUE && !signal) {
[10:26:26.063]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:26.063]                     {
[10:26:26.063]                       inherits <- base::inherits
[10:26:26.063]                       invokeRestart <- base::invokeRestart
[10:26:26.063]                       is.null <- base::is.null
[10:26:26.063]                       muffled <- FALSE
[10:26:26.063]                       if (inherits(cond, "message")) {
[10:26:26.063]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:26.063]                         if (muffled) 
[10:26:26.063]                           invokeRestart("muffleMessage")
[10:26:26.063]                       }
[10:26:26.063]                       else if (inherits(cond, "warning")) {
[10:26:26.063]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:26.063]                         if (muffled) 
[10:26:26.063]                           invokeRestart("muffleWarning")
[10:26:26.063]                       }
[10:26:26.063]                       else if (inherits(cond, "condition")) {
[10:26:26.063]                         if (!is.null(pattern)) {
[10:26:26.063]                           computeRestarts <- base::computeRestarts
[10:26:26.063]                           grepl <- base::grepl
[10:26:26.063]                           restarts <- computeRestarts(cond)
[10:26:26.063]                           for (restart in restarts) {
[10:26:26.063]                             name <- restart$name
[10:26:26.063]                             if (is.null(name)) 
[10:26:26.063]                               next
[10:26:26.063]                             if (!grepl(pattern, name)) 
[10:26:26.063]                               next
[10:26:26.063]                             invokeRestart(restart)
[10:26:26.063]                             muffled <- TRUE
[10:26:26.063]                             break
[10:26:26.063]                           }
[10:26:26.063]                         }
[10:26:26.063]                       }
[10:26:26.063]                       invisible(muffled)
[10:26:26.063]                     }
[10:26:26.063]                     muffleCondition(cond, pattern = "^muffle")
[10:26:26.063]                   }
[10:26:26.063]                 }
[10:26:26.063]                 else {
[10:26:26.063]                   if (TRUE) {
[10:26:26.063]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:26.063]                     {
[10:26:26.063]                       inherits <- base::inherits
[10:26:26.063]                       invokeRestart <- base::invokeRestart
[10:26:26.063]                       is.null <- base::is.null
[10:26:26.063]                       muffled <- FALSE
[10:26:26.063]                       if (inherits(cond, "message")) {
[10:26:26.063]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:26.063]                         if (muffled) 
[10:26:26.063]                           invokeRestart("muffleMessage")
[10:26:26.063]                       }
[10:26:26.063]                       else if (inherits(cond, "warning")) {
[10:26:26.063]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:26.063]                         if (muffled) 
[10:26:26.063]                           invokeRestart("muffleWarning")
[10:26:26.063]                       }
[10:26:26.063]                       else if (inherits(cond, "condition")) {
[10:26:26.063]                         if (!is.null(pattern)) {
[10:26:26.063]                           computeRestarts <- base::computeRestarts
[10:26:26.063]                           grepl <- base::grepl
[10:26:26.063]                           restarts <- computeRestarts(cond)
[10:26:26.063]                           for (restart in restarts) {
[10:26:26.063]                             name <- restart$name
[10:26:26.063]                             if (is.null(name)) 
[10:26:26.063]                               next
[10:26:26.063]                             if (!grepl(pattern, name)) 
[10:26:26.063]                               next
[10:26:26.063]                             invokeRestart(restart)
[10:26:26.063]                             muffled <- TRUE
[10:26:26.063]                             break
[10:26:26.063]                           }
[10:26:26.063]                         }
[10:26:26.063]                       }
[10:26:26.063]                       invisible(muffled)
[10:26:26.063]                     }
[10:26:26.063]                     muffleCondition(cond, pattern = "^muffle")
[10:26:26.063]                   }
[10:26:26.063]                 }
[10:26:26.063]             }
[10:26:26.063]         }))
[10:26:26.063]     }, error = function(ex) {
[10:26:26.063]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:26.063]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:26.063]                 ...future.rng), started = ...future.startTime, 
[10:26:26.063]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:26.063]             version = "1.8"), class = "FutureResult")
[10:26:26.063]     }, finally = {
[10:26:26.063]         if (!identical(...future.workdir, getwd())) 
[10:26:26.063]             setwd(...future.workdir)
[10:26:26.063]         {
[10:26:26.063]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:26.063]                 ...future.oldOptions$nwarnings <- NULL
[10:26:26.063]             }
[10:26:26.063]             base::options(...future.oldOptions)
[10:26:26.063]             if (.Platform$OS.type == "windows") {
[10:26:26.063]                 old_names <- names(...future.oldEnvVars)
[10:26:26.063]                 envs <- base::Sys.getenv()
[10:26:26.063]                 names <- names(envs)
[10:26:26.063]                 common <- intersect(names, old_names)
[10:26:26.063]                 added <- setdiff(names, old_names)
[10:26:26.063]                 removed <- setdiff(old_names, names)
[10:26:26.063]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:26.063]                   envs[common]]
[10:26:26.063]                 NAMES <- toupper(changed)
[10:26:26.063]                 args <- list()
[10:26:26.063]                 for (kk in seq_along(NAMES)) {
[10:26:26.063]                   name <- changed[[kk]]
[10:26:26.063]                   NAME <- NAMES[[kk]]
[10:26:26.063]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:26.063]                     next
[10:26:26.063]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:26.063]                 }
[10:26:26.063]                 NAMES <- toupper(added)
[10:26:26.063]                 for (kk in seq_along(NAMES)) {
[10:26:26.063]                   name <- added[[kk]]
[10:26:26.063]                   NAME <- NAMES[[kk]]
[10:26:26.063]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:26.063]                     next
[10:26:26.063]                   args[[name]] <- ""
[10:26:26.063]                 }
[10:26:26.063]                 NAMES <- toupper(removed)
[10:26:26.063]                 for (kk in seq_along(NAMES)) {
[10:26:26.063]                   name <- removed[[kk]]
[10:26:26.063]                   NAME <- NAMES[[kk]]
[10:26:26.063]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:26.063]                     next
[10:26:26.063]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:26.063]                 }
[10:26:26.063]                 if (length(args) > 0) 
[10:26:26.063]                   base::do.call(base::Sys.setenv, args = args)
[10:26:26.063]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:26.063]             }
[10:26:26.063]             else {
[10:26:26.063]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:26.063]             }
[10:26:26.063]             {
[10:26:26.063]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:26.063]                   0L) {
[10:26:26.063]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:26.063]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:26.063]                   base::options(opts)
[10:26:26.063]                 }
[10:26:26.063]                 {
[10:26:26.063]                   {
[10:26:26.063]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:26.063]                     NULL
[10:26:26.063]                   }
[10:26:26.063]                   options(future.plan = NULL)
[10:26:26.063]                   if (is.na(NA_character_)) 
[10:26:26.063]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:26.063]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:26.063]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:26.063]                   {
[10:26:26.063]                     future <- SequentialFuture(..., envir = envir)
[10:26:26.063]                     if (!future$lazy) 
[10:26:26.063]                       future <- run(future)
[10:26:26.063]                     invisible(future)
[10:26:26.063]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:26.063]                 }
[10:26:26.063]             }
[10:26:26.063]         }
[10:26:26.063]     })
[10:26:26.063]     if (TRUE) {
[10:26:26.063]         base::sink(type = "output", split = FALSE)
[10:26:26.063]         if (TRUE) {
[10:26:26.063]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:26.063]         }
[10:26:26.063]         else {
[10:26:26.063]             ...future.result["stdout"] <- base::list(NULL)
[10:26:26.063]         }
[10:26:26.063]         base::close(...future.stdout)
[10:26:26.063]         ...future.stdout <- NULL
[10:26:26.063]     }
[10:26:26.063]     ...future.result$conditions <- ...future.conditions
[10:26:26.063]     ...future.result$finished <- base::Sys.time()
[10:26:26.063]     ...future.result
[10:26:26.063] }
[10:26:26.117] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[10:26:26.118] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[10:26:26.118] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[10:26:26.118] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[10:26:26.119] MultisessionFuture started
 - Resolving 2 multisession futures
[10:26:26.119] result() for ClusterFuture ...
[10:26:26.119] receiveMessageFromWorker() for ClusterFuture ...
[10:26:26.120] - Validating connection of MultisessionFuture
[10:26:26.197] - received message: FutureResult
[10:26:26.197] - Received FutureResult
[10:26:26.197] - Erased future from FutureRegistry
[10:26:26.197] result() for ClusterFuture ...
[10:26:26.197] - result already collected: FutureResult
[10:26:26.197] result() for ClusterFuture ... done
[10:26:26.198] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:26.198] result() for ClusterFuture ... done
[10:26:26.198] result() for ClusterFuture ...
[10:26:26.198] - result already collected: FutureResult
[10:26:26.198] result() for ClusterFuture ... done
[10:26:26.198] result() for ClusterFuture ...
[10:26:26.198] receiveMessageFromWorker() for ClusterFuture ...
[10:26:26.198] - Validating connection of MultisessionFuture
[10:26:26.199] - received message: FutureResult
[10:26:26.199] - Received FutureResult
[10:26:26.199] - Erased future from FutureRegistry
[10:26:26.199] result() for ClusterFuture ...
[10:26:26.199] - result already collected: FutureResult
[10:26:26.199] result() for ClusterFuture ... done
[10:26:26.199] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:26.200] result() for ClusterFuture ... done
[10:26:26.200] result() for ClusterFuture ...
[10:26:26.200] - result already collected: FutureResult
[10:26:26.200] result() for ClusterFuture ... done
*** multisession() - workers inherit .libPaths()
[10:26:26.200] getGlobalsAndPackages() ...
[10:26:26.200] Searching for globals...
[10:26:26.201] - globals found: [1] ‘.libPaths’
[10:26:26.201] Searching for globals ... DONE
[10:26:26.201] Resolving globals: FALSE
[10:26:26.202] 
[10:26:26.202] 
[10:26:26.202] getGlobalsAndPackages() ... DONE
[10:26:26.202] run() for ‘Future’ ...
[10:26:26.202] - state: ‘created’
[10:26:26.202] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:26.203] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:26.203] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:26.203]   - Field: ‘label’
[10:26:26.203]   - Field: ‘local’
[10:26:26.203]   - Field: ‘owner’
[10:26:26.203]   - Field: ‘envir’
[10:26:26.204]   - Field: ‘packages’
[10:26:26.204]   - Field: ‘gc’
[10:26:26.204]   - Field: ‘conditions’
[10:26:26.204]   - Field: ‘expr’
[10:26:26.204]   - Field: ‘uuid’
[10:26:26.204]   - Field: ‘seed’
[10:26:26.204]   - Field: ‘version’
[10:26:26.204]   - Field: ‘result’
[10:26:26.205]   - Field: ‘asynchronous’
[10:26:26.205]   - Field: ‘calls’
[10:26:26.205]   - Field: ‘globals’
[10:26:26.205]   - Field: ‘stdout’
[10:26:26.205]   - Field: ‘earlySignal’
[10:26:26.205]   - Field: ‘lazy’
[10:26:26.205]   - Field: ‘state’
[10:26:26.205] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:26.206] - Launch lazy future ...
[10:26:26.206] Packages needed by the future expression (n = 0): <none>
[10:26:26.206] Packages needed by future strategies (n = 0): <none>
[10:26:26.206] {
[10:26:26.206]     {
[10:26:26.206]         {
[10:26:26.206]             ...future.startTime <- base::Sys.time()
[10:26:26.206]             {
[10:26:26.206]                 {
[10:26:26.206]                   {
[10:26:26.206]                     base::local({
[10:26:26.206]                       has_future <- base::requireNamespace("future", 
[10:26:26.206]                         quietly = TRUE)
[10:26:26.206]                       if (has_future) {
[10:26:26.206]                         ns <- base::getNamespace("future")
[10:26:26.206]                         version <- ns[[".package"]][["version"]]
[10:26:26.206]                         if (is.null(version)) 
[10:26:26.206]                           version <- utils::packageVersion("future")
[10:26:26.206]                       }
[10:26:26.206]                       else {
[10:26:26.206]                         version <- NULL
[10:26:26.206]                       }
[10:26:26.206]                       if (!has_future || version < "1.8.0") {
[10:26:26.206]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:26.206]                           "", base::R.version$version.string), 
[10:26:26.206]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:26.206]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:26.206]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:26.206]                             "release", "version")], collapse = " "), 
[10:26:26.206]                           hostname = base::Sys.info()[["nodename"]])
[10:26:26.206]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:26.206]                           info)
[10:26:26.206]                         info <- base::paste(info, collapse = "; ")
[10:26:26.206]                         if (!has_future) {
[10:26:26.206]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:26.206]                             info)
[10:26:26.206]                         }
[10:26:26.206]                         else {
[10:26:26.206]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:26.206]                             info, version)
[10:26:26.206]                         }
[10:26:26.206]                         base::stop(msg)
[10:26:26.206]                       }
[10:26:26.206]                     })
[10:26:26.206]                   }
[10:26:26.206]                   options(future.plan = NULL)
[10:26:26.206]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:26.206]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:26.206]                 }
[10:26:26.206]                 ...future.workdir <- getwd()
[10:26:26.206]             }
[10:26:26.206]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:26.206]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:26.206]         }
[10:26:26.206]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:26.206]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:26.206]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:26.206]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:26.206]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:26.206]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:26.206]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:26.206]             base::names(...future.oldOptions))
[10:26:26.206]     }
[10:26:26.206]     if (FALSE) {
[10:26:26.206]     }
[10:26:26.206]     else {
[10:26:26.206]         if (TRUE) {
[10:26:26.206]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:26.206]                 open = "w")
[10:26:26.206]         }
[10:26:26.206]         else {
[10:26:26.206]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:26.206]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:26.206]         }
[10:26:26.206]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:26.206]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:26.206]             base::sink(type = "output", split = FALSE)
[10:26:26.206]             base::close(...future.stdout)
[10:26:26.206]         }, add = TRUE)
[10:26:26.206]     }
[10:26:26.206]     ...future.frame <- base::sys.nframe()
[10:26:26.206]     ...future.conditions <- base::list()
[10:26:26.206]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:26.206]     if (FALSE) {
[10:26:26.206]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:26.206]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:26.206]     }
[10:26:26.206]     ...future.result <- base::tryCatch({
[10:26:26.206]         base::withCallingHandlers({
[10:26:26.206]             ...future.value <- base::withVisible(base::local(.libPaths()))
[10:26:26.206]             future::FutureResult(value = ...future.value$value, 
[10:26:26.206]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:26.206]                   ...future.rng), globalenv = if (FALSE) 
[10:26:26.206]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:26.206]                     ...future.globalenv.names))
[10:26:26.206]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:26.206]         }, condition = base::local({
[10:26:26.206]             c <- base::c
[10:26:26.206]             inherits <- base::inherits
[10:26:26.206]             invokeRestart <- base::invokeRestart
[10:26:26.206]             length <- base::length
[10:26:26.206]             list <- base::list
[10:26:26.206]             seq.int <- base::seq.int
[10:26:26.206]             signalCondition <- base::signalCondition
[10:26:26.206]             sys.calls <- base::sys.calls
[10:26:26.206]             `[[` <- base::`[[`
[10:26:26.206]             `+` <- base::`+`
[10:26:26.206]             `<<-` <- base::`<<-`
[10:26:26.206]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:26.206]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:26.206]                   3L)]
[10:26:26.206]             }
[10:26:26.206]             function(cond) {
[10:26:26.206]                 is_error <- inherits(cond, "error")
[10:26:26.206]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:26.206]                   NULL)
[10:26:26.206]                 if (is_error) {
[10:26:26.206]                   sessionInformation <- function() {
[10:26:26.206]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:26.206]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:26.206]                       search = base::search(), system = base::Sys.info())
[10:26:26.206]                   }
[10:26:26.206]                   ...future.conditions[[length(...future.conditions) + 
[10:26:26.206]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:26.206]                     cond$call), session = sessionInformation(), 
[10:26:26.206]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:26.206]                   signalCondition(cond)
[10:26:26.206]                 }
[10:26:26.206]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:26.206]                 "immediateCondition"))) {
[10:26:26.206]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:26.206]                   ...future.conditions[[length(...future.conditions) + 
[10:26:26.206]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:26.206]                   if (TRUE && !signal) {
[10:26:26.206]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:26.206]                     {
[10:26:26.206]                       inherits <- base::inherits
[10:26:26.206]                       invokeRestart <- base::invokeRestart
[10:26:26.206]                       is.null <- base::is.null
[10:26:26.206]                       muffled <- FALSE
[10:26:26.206]                       if (inherits(cond, "message")) {
[10:26:26.206]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:26.206]                         if (muffled) 
[10:26:26.206]                           invokeRestart("muffleMessage")
[10:26:26.206]                       }
[10:26:26.206]                       else if (inherits(cond, "warning")) {
[10:26:26.206]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:26.206]                         if (muffled) 
[10:26:26.206]                           invokeRestart("muffleWarning")
[10:26:26.206]                       }
[10:26:26.206]                       else if (inherits(cond, "condition")) {
[10:26:26.206]                         if (!is.null(pattern)) {
[10:26:26.206]                           computeRestarts <- base::computeRestarts
[10:26:26.206]                           grepl <- base::grepl
[10:26:26.206]                           restarts <- computeRestarts(cond)
[10:26:26.206]                           for (restart in restarts) {
[10:26:26.206]                             name <- restart$name
[10:26:26.206]                             if (is.null(name)) 
[10:26:26.206]                               next
[10:26:26.206]                             if (!grepl(pattern, name)) 
[10:26:26.206]                               next
[10:26:26.206]                             invokeRestart(restart)
[10:26:26.206]                             muffled <- TRUE
[10:26:26.206]                             break
[10:26:26.206]                           }
[10:26:26.206]                         }
[10:26:26.206]                       }
[10:26:26.206]                       invisible(muffled)
[10:26:26.206]                     }
[10:26:26.206]                     muffleCondition(cond, pattern = "^muffle")
[10:26:26.206]                   }
[10:26:26.206]                 }
[10:26:26.206]                 else {
[10:26:26.206]                   if (TRUE) {
[10:26:26.206]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:26.206]                     {
[10:26:26.206]                       inherits <- base::inherits
[10:26:26.206]                       invokeRestart <- base::invokeRestart
[10:26:26.206]                       is.null <- base::is.null
[10:26:26.206]                       muffled <- FALSE
[10:26:26.206]                       if (inherits(cond, "message")) {
[10:26:26.206]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:26.206]                         if (muffled) 
[10:26:26.206]                           invokeRestart("muffleMessage")
[10:26:26.206]                       }
[10:26:26.206]                       else if (inherits(cond, "warning")) {
[10:26:26.206]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:26.206]                         if (muffled) 
[10:26:26.206]                           invokeRestart("muffleWarning")
[10:26:26.206]                       }
[10:26:26.206]                       else if (inherits(cond, "condition")) {
[10:26:26.206]                         if (!is.null(pattern)) {
[10:26:26.206]                           computeRestarts <- base::computeRestarts
[10:26:26.206]                           grepl <- base::grepl
[10:26:26.206]                           restarts <- computeRestarts(cond)
[10:26:26.206]                           for (restart in restarts) {
[10:26:26.206]                             name <- restart$name
[10:26:26.206]                             if (is.null(name)) 
[10:26:26.206]                               next
[10:26:26.206]                             if (!grepl(pattern, name)) 
[10:26:26.206]                               next
[10:26:26.206]                             invokeRestart(restart)
[10:26:26.206]                             muffled <- TRUE
[10:26:26.206]                             break
[10:26:26.206]                           }
[10:26:26.206]                         }
[10:26:26.206]                       }
[10:26:26.206]                       invisible(muffled)
[10:26:26.206]                     }
[10:26:26.206]                     muffleCondition(cond, pattern = "^muffle")
[10:26:26.206]                   }
[10:26:26.206]                 }
[10:26:26.206]             }
[10:26:26.206]         }))
[10:26:26.206]     }, error = function(ex) {
[10:26:26.206]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:26.206]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:26.206]                 ...future.rng), started = ...future.startTime, 
[10:26:26.206]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:26.206]             version = "1.8"), class = "FutureResult")
[10:26:26.206]     }, finally = {
[10:26:26.206]         if (!identical(...future.workdir, getwd())) 
[10:26:26.206]             setwd(...future.workdir)
[10:26:26.206]         {
[10:26:26.206]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:26.206]                 ...future.oldOptions$nwarnings <- NULL
[10:26:26.206]             }
[10:26:26.206]             base::options(...future.oldOptions)
[10:26:26.206]             if (.Platform$OS.type == "windows") {
[10:26:26.206]                 old_names <- names(...future.oldEnvVars)
[10:26:26.206]                 envs <- base::Sys.getenv()
[10:26:26.206]                 names <- names(envs)
[10:26:26.206]                 common <- intersect(names, old_names)
[10:26:26.206]                 added <- setdiff(names, old_names)
[10:26:26.206]                 removed <- setdiff(old_names, names)
[10:26:26.206]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:26.206]                   envs[common]]
[10:26:26.206]                 NAMES <- toupper(changed)
[10:26:26.206]                 args <- list()
[10:26:26.206]                 for (kk in seq_along(NAMES)) {
[10:26:26.206]                   name <- changed[[kk]]
[10:26:26.206]                   NAME <- NAMES[[kk]]
[10:26:26.206]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:26.206]                     next
[10:26:26.206]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:26.206]                 }
[10:26:26.206]                 NAMES <- toupper(added)
[10:26:26.206]                 for (kk in seq_along(NAMES)) {
[10:26:26.206]                   name <- added[[kk]]
[10:26:26.206]                   NAME <- NAMES[[kk]]
[10:26:26.206]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:26.206]                     next
[10:26:26.206]                   args[[name]] <- ""
[10:26:26.206]                 }
[10:26:26.206]                 NAMES <- toupper(removed)
[10:26:26.206]                 for (kk in seq_along(NAMES)) {
[10:26:26.206]                   name <- removed[[kk]]
[10:26:26.206]                   NAME <- NAMES[[kk]]
[10:26:26.206]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:26.206]                     next
[10:26:26.206]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:26.206]                 }
[10:26:26.206]                 if (length(args) > 0) 
[10:26:26.206]                   base::do.call(base::Sys.setenv, args = args)
[10:26:26.206]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:26.206]             }
[10:26:26.206]             else {
[10:26:26.206]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:26.206]             }
[10:26:26.206]             {
[10:26:26.206]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:26.206]                   0L) {
[10:26:26.206]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:26.206]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:26.206]                   base::options(opts)
[10:26:26.206]                 }
[10:26:26.206]                 {
[10:26:26.206]                   {
[10:26:26.206]                     NULL
[10:26:26.206]                     RNGkind("Mersenne-Twister")
[10:26:26.206]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:26.206]                       inherits = FALSE)
[10:26:26.206]                   }
[10:26:26.206]                   options(future.plan = NULL)
[10:26:26.206]                   if (is.na(NA_character_)) 
[10:26:26.206]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:26.206]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:26.206]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:26.206]                   {
[10:26:26.206]                     future <- SequentialFuture(..., envir = envir)
[10:26:26.206]                     if (!future$lazy) 
[10:26:26.206]                       future <- run(future)
[10:26:26.206]                     invisible(future)
[10:26:26.206]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:26.206]                 }
[10:26:26.206]             }
[10:26:26.206]         }
[10:26:26.206]     })
[10:26:26.206]     if (TRUE) {
[10:26:26.206]         base::sink(type = "output", split = FALSE)
[10:26:26.206]         if (TRUE) {
[10:26:26.206]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:26.206]         }
[10:26:26.206]         else {
[10:26:26.206]             ...future.result["stdout"] <- base::list(NULL)
[10:26:26.206]         }
[10:26:26.206]         base::close(...future.stdout)
[10:26:26.206]         ...future.stdout <- NULL
[10:26:26.206]     }
[10:26:26.206]     ...future.result$conditions <- ...future.conditions
[10:26:26.206]     ...future.result$finished <- base::Sys.time()
[10:26:26.206]     ...future.result
[10:26:26.206] }
[10:26:26.209] plan(): Setting new future strategy stack:
[10:26:26.211] List of future strategies:
[10:26:26.211] 1. sequential:
[10:26:26.211]    - args: function (..., envir = parent.frame())
[10:26:26.211]    - tweaked: FALSE
[10:26:26.211]    - call: NULL
[10:26:26.212] plan(): nbrOfWorkers() = 1
[10:26:26.212] plan(): Setting new future strategy stack:
[10:26:26.212] List of future strategies:
[10:26:26.212] 1. sequential:
[10:26:26.212]    - args: function (..., envir = parent.frame())
[10:26:26.212]    - tweaked: FALSE
[10:26:26.212]    - call: future::plan("sequential")
[10:26:26.213] plan(): nbrOfWorkers() = 1
[10:26:26.213] SequentialFuture started (and completed)
[10:26:26.213] - Launch lazy future ... done
[10:26:26.213] run() for ‘SequentialFuture’ ... done
List of 2
 $ main   : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
 $ workers: chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
*** multisession() and errors
[10:26:26.218] getGlobalsAndPackages() ...
[10:26:26.218] 
[10:26:26.218] - globals: [0] <none>
[10:26:26.218] getGlobalsAndPackages() ... DONE
[10:26:26.229] Packages needed by the future expression (n = 0): <none>
[10:26:26.229] Packages needed by future strategies (n = 0): <none>
[10:26:26.230] {
[10:26:26.230]     {
[10:26:26.230]         {
[10:26:26.230]             ...future.startTime <- base::Sys.time()
[10:26:26.230]             {
[10:26:26.230]                 {
[10:26:26.230]                   {
[10:26:26.230]                     {
[10:26:26.230]                       base::local({
[10:26:26.230]                         has_future <- base::requireNamespace("future", 
[10:26:26.230]                           quietly = TRUE)
[10:26:26.230]                         if (has_future) {
[10:26:26.230]                           ns <- base::getNamespace("future")
[10:26:26.230]                           version <- ns[[".package"]][["version"]]
[10:26:26.230]                           if (is.null(version)) 
[10:26:26.230]                             version <- utils::packageVersion("future")
[10:26:26.230]                         }
[10:26:26.230]                         else {
[10:26:26.230]                           version <- NULL
[10:26:26.230]                         }
[10:26:26.230]                         if (!has_future || version < "1.8.0") {
[10:26:26.230]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:26.230]                             "", base::R.version$version.string), 
[10:26:26.230]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:26.230]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:26.230]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:26.230]                               "release", "version")], collapse = " "), 
[10:26:26.230]                             hostname = base::Sys.info()[["nodename"]])
[10:26:26.230]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:26.230]                             info)
[10:26:26.230]                           info <- base::paste(info, collapse = "; ")
[10:26:26.230]                           if (!has_future) {
[10:26:26.230]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:26.230]                               info)
[10:26:26.230]                           }
[10:26:26.230]                           else {
[10:26:26.230]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:26.230]                               info, version)
[10:26:26.230]                           }
[10:26:26.230]                           base::stop(msg)
[10:26:26.230]                         }
[10:26:26.230]                       })
[10:26:26.230]                     }
[10:26:26.230]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:26.230]                     base::options(mc.cores = 1L)
[10:26:26.230]                   }
[10:26:26.230]                   options(future.plan = NULL)
[10:26:26.230]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:26.230]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:26.230]                 }
[10:26:26.230]                 ...future.workdir <- getwd()
[10:26:26.230]             }
[10:26:26.230]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:26.230]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:26.230]         }
[10:26:26.230]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:26.230]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:26.230]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:26.230]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:26.230]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:26.230]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:26.230]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:26.230]             base::names(...future.oldOptions))
[10:26:26.230]     }
[10:26:26.230]     if (FALSE) {
[10:26:26.230]     }
[10:26:26.230]     else {
[10:26:26.230]         if (TRUE) {
[10:26:26.230]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:26.230]                 open = "w")
[10:26:26.230]         }
[10:26:26.230]         else {
[10:26:26.230]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:26.230]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:26.230]         }
[10:26:26.230]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:26.230]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:26.230]             base::sink(type = "output", split = FALSE)
[10:26:26.230]             base::close(...future.stdout)
[10:26:26.230]         }, add = TRUE)
[10:26:26.230]     }
[10:26:26.230]     ...future.frame <- base::sys.nframe()
[10:26:26.230]     ...future.conditions <- base::list()
[10:26:26.230]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:26.230]     if (FALSE) {
[10:26:26.230]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:26.230]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:26.230]     }
[10:26:26.230]     ...future.result <- base::tryCatch({
[10:26:26.230]         base::withCallingHandlers({
[10:26:26.230]             ...future.value <- base::withVisible(base::local({
[10:26:26.230]                 ...future.makeSendCondition <- base::local({
[10:26:26.230]                   sendCondition <- NULL
[10:26:26.230]                   function(frame = 1L) {
[10:26:26.230]                     if (is.function(sendCondition)) 
[10:26:26.230]                       return(sendCondition)
[10:26:26.230]                     ns <- getNamespace("parallel")
[10:26:26.230]                     if (exists("sendData", mode = "function", 
[10:26:26.230]                       envir = ns)) {
[10:26:26.230]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:26.230]                         envir = ns)
[10:26:26.230]                       envir <- sys.frame(frame)
[10:26:26.230]                       master <- NULL
[10:26:26.230]                       while (!identical(envir, .GlobalEnv) && 
[10:26:26.230]                         !identical(envir, emptyenv())) {
[10:26:26.230]                         if (exists("master", mode = "list", envir = envir, 
[10:26:26.230]                           inherits = FALSE)) {
[10:26:26.230]                           master <- get("master", mode = "list", 
[10:26:26.230]                             envir = envir, inherits = FALSE)
[10:26:26.230]                           if (inherits(master, c("SOCKnode", 
[10:26:26.230]                             "SOCK0node"))) {
[10:26:26.230]                             sendCondition <<- function(cond) {
[10:26:26.230]                               data <- list(type = "VALUE", value = cond, 
[10:26:26.230]                                 success = TRUE)
[10:26:26.230]                               parallel_sendData(master, data)
[10:26:26.230]                             }
[10:26:26.230]                             return(sendCondition)
[10:26:26.230]                           }
[10:26:26.230]                         }
[10:26:26.230]                         frame <- frame + 1L
[10:26:26.230]                         envir <- sys.frame(frame)
[10:26:26.230]                       }
[10:26:26.230]                     }
[10:26:26.230]                     sendCondition <<- function(cond) NULL
[10:26:26.230]                   }
[10:26:26.230]                 })
[10:26:26.230]                 withCallingHandlers({
[10:26:26.230]                   {
[10:26:26.230]                     stop("Whoops!")
[10:26:26.230]                     1
[10:26:26.230]                   }
[10:26:26.230]                 }, immediateCondition = function(cond) {
[10:26:26.230]                   sendCondition <- ...future.makeSendCondition()
[10:26:26.230]                   sendCondition(cond)
[10:26:26.230]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:26.230]                   {
[10:26:26.230]                     inherits <- base::inherits
[10:26:26.230]                     invokeRestart <- base::invokeRestart
[10:26:26.230]                     is.null <- base::is.null
[10:26:26.230]                     muffled <- FALSE
[10:26:26.230]                     if (inherits(cond, "message")) {
[10:26:26.230]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:26.230]                       if (muffled) 
[10:26:26.230]                         invokeRestart("muffleMessage")
[10:26:26.230]                     }
[10:26:26.230]                     else if (inherits(cond, "warning")) {
[10:26:26.230]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:26.230]                       if (muffled) 
[10:26:26.230]                         invokeRestart("muffleWarning")
[10:26:26.230]                     }
[10:26:26.230]                     else if (inherits(cond, "condition")) {
[10:26:26.230]                       if (!is.null(pattern)) {
[10:26:26.230]                         computeRestarts <- base::computeRestarts
[10:26:26.230]                         grepl <- base::grepl
[10:26:26.230]                         restarts <- computeRestarts(cond)
[10:26:26.230]                         for (restart in restarts) {
[10:26:26.230]                           name <- restart$name
[10:26:26.230]                           if (is.null(name)) 
[10:26:26.230]                             next
[10:26:26.230]                           if (!grepl(pattern, name)) 
[10:26:26.230]                             next
[10:26:26.230]                           invokeRestart(restart)
[10:26:26.230]                           muffled <- TRUE
[10:26:26.230]                           break
[10:26:26.230]                         }
[10:26:26.230]                       }
[10:26:26.230]                     }
[10:26:26.230]                     invisible(muffled)
[10:26:26.230]                   }
[10:26:26.230]                   muffleCondition(cond)
[10:26:26.230]                 })
[10:26:26.230]             }))
[10:26:26.230]             future::FutureResult(value = ...future.value$value, 
[10:26:26.230]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:26.230]                   ...future.rng), globalenv = if (FALSE) 
[10:26:26.230]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:26.230]                     ...future.globalenv.names))
[10:26:26.230]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:26.230]         }, condition = base::local({
[10:26:26.230]             c <- base::c
[10:26:26.230]             inherits <- base::inherits
[10:26:26.230]             invokeRestart <- base::invokeRestart
[10:26:26.230]             length <- base::length
[10:26:26.230]             list <- base::list
[10:26:26.230]             seq.int <- base::seq.int
[10:26:26.230]             signalCondition <- base::signalCondition
[10:26:26.230]             sys.calls <- base::sys.calls
[10:26:26.230]             `[[` <- base::`[[`
[10:26:26.230]             `+` <- base::`+`
[10:26:26.230]             `<<-` <- base::`<<-`
[10:26:26.230]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:26.230]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:26.230]                   3L)]
[10:26:26.230]             }
[10:26:26.230]             function(cond) {
[10:26:26.230]                 is_error <- inherits(cond, "error")
[10:26:26.230]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:26.230]                   NULL)
[10:26:26.230]                 if (is_error) {
[10:26:26.230]                   sessionInformation <- function() {
[10:26:26.230]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:26.230]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:26.230]                       search = base::search(), system = base::Sys.info())
[10:26:26.230]                   }
[10:26:26.230]                   ...future.conditions[[length(...future.conditions) + 
[10:26:26.230]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:26.230]                     cond$call), session = sessionInformation(), 
[10:26:26.230]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:26.230]                   signalCondition(cond)
[10:26:26.230]                 }
[10:26:26.230]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:26.230]                 "immediateCondition"))) {
[10:26:26.230]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:26.230]                   ...future.conditions[[length(...future.conditions) + 
[10:26:26.230]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:26.230]                   if (TRUE && !signal) {
[10:26:26.230]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:26.230]                     {
[10:26:26.230]                       inherits <- base::inherits
[10:26:26.230]                       invokeRestart <- base::invokeRestart
[10:26:26.230]                       is.null <- base::is.null
[10:26:26.230]                       muffled <- FALSE
[10:26:26.230]                       if (inherits(cond, "message")) {
[10:26:26.230]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:26.230]                         if (muffled) 
[10:26:26.230]                           invokeRestart("muffleMessage")
[10:26:26.230]                       }
[10:26:26.230]                       else if (inherits(cond, "warning")) {
[10:26:26.230]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:26.230]                         if (muffled) 
[10:26:26.230]                           invokeRestart("muffleWarning")
[10:26:26.230]                       }
[10:26:26.230]                       else if (inherits(cond, "condition")) {
[10:26:26.230]                         if (!is.null(pattern)) {
[10:26:26.230]                           computeRestarts <- base::computeRestarts
[10:26:26.230]                           grepl <- base::grepl
[10:26:26.230]                           restarts <- computeRestarts(cond)
[10:26:26.230]                           for (restart in restarts) {
[10:26:26.230]                             name <- restart$name
[10:26:26.230]                             if (is.null(name)) 
[10:26:26.230]                               next
[10:26:26.230]                             if (!grepl(pattern, name)) 
[10:26:26.230]                               next
[10:26:26.230]                             invokeRestart(restart)
[10:26:26.230]                             muffled <- TRUE
[10:26:26.230]                             break
[10:26:26.230]                           }
[10:26:26.230]                         }
[10:26:26.230]                       }
[10:26:26.230]                       invisible(muffled)
[10:26:26.230]                     }
[10:26:26.230]                     muffleCondition(cond, pattern = "^muffle")
[10:26:26.230]                   }
[10:26:26.230]                 }
[10:26:26.230]                 else {
[10:26:26.230]                   if (TRUE) {
[10:26:26.230]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:26.230]                     {
[10:26:26.230]                       inherits <- base::inherits
[10:26:26.230]                       invokeRestart <- base::invokeRestart
[10:26:26.230]                       is.null <- base::is.null
[10:26:26.230]                       muffled <- FALSE
[10:26:26.230]                       if (inherits(cond, "message")) {
[10:26:26.230]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:26.230]                         if (muffled) 
[10:26:26.230]                           invokeRestart("muffleMessage")
[10:26:26.230]                       }
[10:26:26.230]                       else if (inherits(cond, "warning")) {
[10:26:26.230]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:26.230]                         if (muffled) 
[10:26:26.230]                           invokeRestart("muffleWarning")
[10:26:26.230]                       }
[10:26:26.230]                       else if (inherits(cond, "condition")) {
[10:26:26.230]                         if (!is.null(pattern)) {
[10:26:26.230]                           computeRestarts <- base::computeRestarts
[10:26:26.230]                           grepl <- base::grepl
[10:26:26.230]                           restarts <- computeRestarts(cond)
[10:26:26.230]                           for (restart in restarts) {
[10:26:26.230]                             name <- restart$name
[10:26:26.230]                             if (is.null(name)) 
[10:26:26.230]                               next
[10:26:26.230]                             if (!grepl(pattern, name)) 
[10:26:26.230]                               next
[10:26:26.230]                             invokeRestart(restart)
[10:26:26.230]                             muffled <- TRUE
[10:26:26.230]                             break
[10:26:26.230]                           }
[10:26:26.230]                         }
[10:26:26.230]                       }
[10:26:26.230]                       invisible(muffled)
[10:26:26.230]                     }
[10:26:26.230]                     muffleCondition(cond, pattern = "^muffle")
[10:26:26.230]                   }
[10:26:26.230]                 }
[10:26:26.230]             }
[10:26:26.230]         }))
[10:26:26.230]     }, error = function(ex) {
[10:26:26.230]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:26.230]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:26.230]                 ...future.rng), started = ...future.startTime, 
[10:26:26.230]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:26.230]             version = "1.8"), class = "FutureResult")
[10:26:26.230]     }, finally = {
[10:26:26.230]         if (!identical(...future.workdir, getwd())) 
[10:26:26.230]             setwd(...future.workdir)
[10:26:26.230]         {
[10:26:26.230]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:26.230]                 ...future.oldOptions$nwarnings <- NULL
[10:26:26.230]             }
[10:26:26.230]             base::options(...future.oldOptions)
[10:26:26.230]             if (.Platform$OS.type == "windows") {
[10:26:26.230]                 old_names <- names(...future.oldEnvVars)
[10:26:26.230]                 envs <- base::Sys.getenv()
[10:26:26.230]                 names <- names(envs)
[10:26:26.230]                 common <- intersect(names, old_names)
[10:26:26.230]                 added <- setdiff(names, old_names)
[10:26:26.230]                 removed <- setdiff(old_names, names)
[10:26:26.230]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:26.230]                   envs[common]]
[10:26:26.230]                 NAMES <- toupper(changed)
[10:26:26.230]                 args <- list()
[10:26:26.230]                 for (kk in seq_along(NAMES)) {
[10:26:26.230]                   name <- changed[[kk]]
[10:26:26.230]                   NAME <- NAMES[[kk]]
[10:26:26.230]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:26.230]                     next
[10:26:26.230]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:26.230]                 }
[10:26:26.230]                 NAMES <- toupper(added)
[10:26:26.230]                 for (kk in seq_along(NAMES)) {
[10:26:26.230]                   name <- added[[kk]]
[10:26:26.230]                   NAME <- NAMES[[kk]]
[10:26:26.230]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:26.230]                     next
[10:26:26.230]                   args[[name]] <- ""
[10:26:26.230]                 }
[10:26:26.230]                 NAMES <- toupper(removed)
[10:26:26.230]                 for (kk in seq_along(NAMES)) {
[10:26:26.230]                   name <- removed[[kk]]
[10:26:26.230]                   NAME <- NAMES[[kk]]
[10:26:26.230]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:26.230]                     next
[10:26:26.230]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:26.230]                 }
[10:26:26.230]                 if (length(args) > 0) 
[10:26:26.230]                   base::do.call(base::Sys.setenv, args = args)
[10:26:26.230]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:26.230]             }
[10:26:26.230]             else {
[10:26:26.230]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:26.230]             }
[10:26:26.230]             {
[10:26:26.230]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:26.230]                   0L) {
[10:26:26.230]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:26.230]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:26.230]                   base::options(opts)
[10:26:26.230]                 }
[10:26:26.230]                 {
[10:26:26.230]                   {
[10:26:26.230]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:26.230]                     NULL
[10:26:26.230]                   }
[10:26:26.230]                   options(future.plan = NULL)
[10:26:26.230]                   if (is.na(NA_character_)) 
[10:26:26.230]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:26.230]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:26.230]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:26.230]                   {
[10:26:26.230]                     future <- SequentialFuture(..., envir = envir)
[10:26:26.230]                     if (!future$lazy) 
[10:26:26.230]                       future <- run(future)
[10:26:26.230]                     invisible(future)
[10:26:26.230]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:26.230]                 }
[10:26:26.230]             }
[10:26:26.230]         }
[10:26:26.230]     })
[10:26:26.230]     if (TRUE) {
[10:26:26.230]         base::sink(type = "output", split = FALSE)
[10:26:26.230]         if (TRUE) {
[10:26:26.230]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:26.230]         }
[10:26:26.230]         else {
[10:26:26.230]             ...future.result["stdout"] <- base::list(NULL)
[10:26:26.230]         }
[10:26:26.230]         base::close(...future.stdout)
[10:26:26.230]         ...future.stdout <- NULL
[10:26:26.230]     }
[10:26:26.230]     ...future.result$conditions <- ...future.conditions
[10:26:26.230]     ...future.result$finished <- base::Sys.time()
[10:26:26.230]     ...future.result
[10:26:26.230] }
[10:26:26.233] MultisessionFuture started
MultisessionFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: b237ea00-048b-53bc-62d3-d50d6929ba00
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:26.244] result() for ClusterFuture ...
[10:26:26.244] receiveMessageFromWorker() for ClusterFuture ...
[10:26:26.244] - Validating connection of MultisessionFuture
[10:26:26.276] - received message: FutureResult
[10:26:26.276] - Received FutureResult
[10:26:26.276] - Erased future from FutureRegistry
[10:26:26.276] result() for ClusterFuture ...
[10:26:26.276] - result already collected: FutureResult
[10:26:26.276] result() for ClusterFuture ... done
[10:26:26.276] signalConditions() ...
[10:26:26.276]  - include = ‘immediateCondition’
[10:26:26.277]  - exclude = 
[10:26:26.277]  - resignal = FALSE
[10:26:26.277]  - Number of conditions: 1
[10:26:26.277] signalConditions() ... done
[10:26:26.277] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:26.277] result() for ClusterFuture ... done
[10:26:26.277] result() for ClusterFuture ...
[10:26:26.277] - result already collected: FutureResult
[10:26:26.277] result() for ClusterFuture ... done
[10:26:26.277] signalConditions() ...
[10:26:26.277]  - include = ‘immediateCondition’
[10:26:26.278]  - exclude = 
[10:26:26.278]  - resignal = FALSE
[10:26:26.278]  - Number of conditions: 1
[10:26:26.278] signalConditions() ... done
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    sendCondition <- ...future.makeSendCondition()    sendCondition(cond)    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[10:26:26.278] result() for ClusterFuture ...
[10:26:26.278] - result already collected: FutureResult
[10:26:26.278] result() for ClusterFuture ... done
[10:26:26.279] result() for ClusterFuture ...
[10:26:26.279] - result already collected: FutureResult
[10:26:26.279] result() for ClusterFuture ... done
[10:26:26.279] signalConditions() ...
[10:26:26.279]  - include = ‘immediateCondition’
[10:26:26.279]  - exclude = 
[10:26:26.279]  - resignal = FALSE
[10:26:26.279]  - Number of conditions: 1
[10:26:26.279] signalConditions() ... done
[10:26:26.279] Future state: ‘finished’
[10:26:26.279] result() for ClusterFuture ...
[10:26:26.280] - result already collected: FutureResult
[10:26:26.280] result() for ClusterFuture ... done
[10:26:26.280] signalConditions() ...
[10:26:26.280]  - include = ‘condition’
[10:26:26.280]  - exclude = ‘immediateCondition’
[10:26:26.280]  - resignal = TRUE
[10:26:26.280]  - Number of conditions: 1
[10:26:26.280]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:26:26.280] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    sendCondition <- ...future.makeSendCondition()    sendCondition(cond)    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[10:26:26.281] result() for ClusterFuture ...
[10:26:26.281] - result already collected: FutureResult
[10:26:26.281] result() for ClusterFuture ... done
[10:26:26.281] result() for ClusterFuture ...
[10:26:26.281] - result already collected: FutureResult
[10:26:26.281] result() for ClusterFuture ... done
[10:26:26.281] signalConditions() ...
[10:26:26.281]  - include = ‘immediateCondition’
[10:26:26.281]  - exclude = 
[10:26:26.282]  - resignal = FALSE
[10:26:26.282]  - Number of conditions: 1
[10:26:26.282] signalConditions() ... done
[10:26:26.282] Future state: ‘finished’
[10:26:26.282] result() for ClusterFuture ...
[10:26:26.282] - result already collected: FutureResult
[10:26:26.282] result() for ClusterFuture ... done
[10:26:26.282] signalConditions() ...
[10:26:26.282]  - include = ‘condition’
[10:26:26.282]  - exclude = ‘immediateCondition’
[10:26:26.282]  - resignal = TRUE
[10:26:26.282]  - Number of conditions: 1
[10:26:26.283]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:26:26.283] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    sendCondition <- ...future.makeSendCondition()    sendCondition(cond)    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[10:26:26.287] getGlobalsAndPackages() ...
[10:26:26.287] 
[10:26:26.287] - globals: [0] <none>
[10:26:26.287] getGlobalsAndPackages() ... DONE
[10:26:26.298] Packages needed by the future expression (n = 0): <none>
[10:26:26.298] Packages needed by future strategies (n = 0): <none>
[10:26:26.299] {
[10:26:26.299]     {
[10:26:26.299]         {
[10:26:26.299]             ...future.startTime <- base::Sys.time()
[10:26:26.299]             {
[10:26:26.299]                 {
[10:26:26.299]                   {
[10:26:26.299]                     {
[10:26:26.299]                       base::local({
[10:26:26.299]                         has_future <- base::requireNamespace("future", 
[10:26:26.299]                           quietly = TRUE)
[10:26:26.299]                         if (has_future) {
[10:26:26.299]                           ns <- base::getNamespace("future")
[10:26:26.299]                           version <- ns[[".package"]][["version"]]
[10:26:26.299]                           if (is.null(version)) 
[10:26:26.299]                             version <- utils::packageVersion("future")
[10:26:26.299]                         }
[10:26:26.299]                         else {
[10:26:26.299]                           version <- NULL
[10:26:26.299]                         }
[10:26:26.299]                         if (!has_future || version < "1.8.0") {
[10:26:26.299]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:26.299]                             "", base::R.version$version.string), 
[10:26:26.299]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:26.299]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:26.299]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:26.299]                               "release", "version")], collapse = " "), 
[10:26:26.299]                             hostname = base::Sys.info()[["nodename"]])
[10:26:26.299]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:26.299]                             info)
[10:26:26.299]                           info <- base::paste(info, collapse = "; ")
[10:26:26.299]                           if (!has_future) {
[10:26:26.299]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:26.299]                               info)
[10:26:26.299]                           }
[10:26:26.299]                           else {
[10:26:26.299]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:26.299]                               info, version)
[10:26:26.299]                           }
[10:26:26.299]                           base::stop(msg)
[10:26:26.299]                         }
[10:26:26.299]                       })
[10:26:26.299]                     }
[10:26:26.299]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:26.299]                     base::options(mc.cores = 1L)
[10:26:26.299]                   }
[10:26:26.299]                   options(future.plan = NULL)
[10:26:26.299]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:26.299]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:26.299]                 }
[10:26:26.299]                 ...future.workdir <- getwd()
[10:26:26.299]             }
[10:26:26.299]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:26.299]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:26.299]         }
[10:26:26.299]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:26.299]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:26.299]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:26.299]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:26.299]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:26.299]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:26.299]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:26.299]             base::names(...future.oldOptions))
[10:26:26.299]     }
[10:26:26.299]     if (FALSE) {
[10:26:26.299]     }
[10:26:26.299]     else {
[10:26:26.299]         if (TRUE) {
[10:26:26.299]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:26.299]                 open = "w")
[10:26:26.299]         }
[10:26:26.299]         else {
[10:26:26.299]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:26.299]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:26.299]         }
[10:26:26.299]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:26.299]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:26.299]             base::sink(type = "output", split = FALSE)
[10:26:26.299]             base::close(...future.stdout)
[10:26:26.299]         }, add = TRUE)
[10:26:26.299]     }
[10:26:26.299]     ...future.frame <- base::sys.nframe()
[10:26:26.299]     ...future.conditions <- base::list()
[10:26:26.299]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:26.299]     if (FALSE) {
[10:26:26.299]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:26.299]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:26.299]     }
[10:26:26.299]     ...future.result <- base::tryCatch({
[10:26:26.299]         base::withCallingHandlers({
[10:26:26.299]             ...future.value <- base::withVisible(base::local({
[10:26:26.299]                 ...future.makeSendCondition <- base::local({
[10:26:26.299]                   sendCondition <- NULL
[10:26:26.299]                   function(frame = 1L) {
[10:26:26.299]                     if (is.function(sendCondition)) 
[10:26:26.299]                       return(sendCondition)
[10:26:26.299]                     ns <- getNamespace("parallel")
[10:26:26.299]                     if (exists("sendData", mode = "function", 
[10:26:26.299]                       envir = ns)) {
[10:26:26.299]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:26.299]                         envir = ns)
[10:26:26.299]                       envir <- sys.frame(frame)
[10:26:26.299]                       master <- NULL
[10:26:26.299]                       while (!identical(envir, .GlobalEnv) && 
[10:26:26.299]                         !identical(envir, emptyenv())) {
[10:26:26.299]                         if (exists("master", mode = "list", envir = envir, 
[10:26:26.299]                           inherits = FALSE)) {
[10:26:26.299]                           master <- get("master", mode = "list", 
[10:26:26.299]                             envir = envir, inherits = FALSE)
[10:26:26.299]                           if (inherits(master, c("SOCKnode", 
[10:26:26.299]                             "SOCK0node"))) {
[10:26:26.299]                             sendCondition <<- function(cond) {
[10:26:26.299]                               data <- list(type = "VALUE", value = cond, 
[10:26:26.299]                                 success = TRUE)
[10:26:26.299]                               parallel_sendData(master, data)
[10:26:26.299]                             }
[10:26:26.299]                             return(sendCondition)
[10:26:26.299]                           }
[10:26:26.299]                         }
[10:26:26.299]                         frame <- frame + 1L
[10:26:26.299]                         envir <- sys.frame(frame)
[10:26:26.299]                       }
[10:26:26.299]                     }
[10:26:26.299]                     sendCondition <<- function(cond) NULL
[10:26:26.299]                   }
[10:26:26.299]                 })
[10:26:26.299]                 withCallingHandlers({
[10:26:26.299]                   {
[10:26:26.299]                     stop(structure(list(message = "boom"), class = c("MyError", 
[10:26:26.299]                       "error", "condition")))
[10:26:26.299]                   }
[10:26:26.299]                 }, immediateCondition = function(cond) {
[10:26:26.299]                   sendCondition <- ...future.makeSendCondition()
[10:26:26.299]                   sendCondition(cond)
[10:26:26.299]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:26.299]                   {
[10:26:26.299]                     inherits <- base::inherits
[10:26:26.299]                     invokeRestart <- base::invokeRestart
[10:26:26.299]                     is.null <- base::is.null
[10:26:26.299]                     muffled <- FALSE
[10:26:26.299]                     if (inherits(cond, "message")) {
[10:26:26.299]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:26.299]                       if (muffled) 
[10:26:26.299]                         invokeRestart("muffleMessage")
[10:26:26.299]                     }
[10:26:26.299]                     else if (inherits(cond, "warning")) {
[10:26:26.299]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:26.299]                       if (muffled) 
[10:26:26.299]                         invokeRestart("muffleWarning")
[10:26:26.299]                     }
[10:26:26.299]                     else if (inherits(cond, "condition")) {
[10:26:26.299]                       if (!is.null(pattern)) {
[10:26:26.299]                         computeRestarts <- base::computeRestarts
[10:26:26.299]                         grepl <- base::grepl
[10:26:26.299]                         restarts <- computeRestarts(cond)
[10:26:26.299]                         for (restart in restarts) {
[10:26:26.299]                           name <- restart$name
[10:26:26.299]                           if (is.null(name)) 
[10:26:26.299]                             next
[10:26:26.299]                           if (!grepl(pattern, name)) 
[10:26:26.299]                             next
[10:26:26.299]                           invokeRestart(restart)
[10:26:26.299]                           muffled <- TRUE
[10:26:26.299]                           break
[10:26:26.299]                         }
[10:26:26.299]                       }
[10:26:26.299]                     }
[10:26:26.299]                     invisible(muffled)
[10:26:26.299]                   }
[10:26:26.299]                   muffleCondition(cond)
[10:26:26.299]                 })
[10:26:26.299]             }))
[10:26:26.299]             future::FutureResult(value = ...future.value$value, 
[10:26:26.299]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:26.299]                   ...future.rng), globalenv = if (FALSE) 
[10:26:26.299]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:26.299]                     ...future.globalenv.names))
[10:26:26.299]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:26.299]         }, condition = base::local({
[10:26:26.299]             c <- base::c
[10:26:26.299]             inherits <- base::inherits
[10:26:26.299]             invokeRestart <- base::invokeRestart
[10:26:26.299]             length <- base::length
[10:26:26.299]             list <- base::list
[10:26:26.299]             seq.int <- base::seq.int
[10:26:26.299]             signalCondition <- base::signalCondition
[10:26:26.299]             sys.calls <- base::sys.calls
[10:26:26.299]             `[[` <- base::`[[`
[10:26:26.299]             `+` <- base::`+`
[10:26:26.299]             `<<-` <- base::`<<-`
[10:26:26.299]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:26.299]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:26.299]                   3L)]
[10:26:26.299]             }
[10:26:26.299]             function(cond) {
[10:26:26.299]                 is_error <- inherits(cond, "error")
[10:26:26.299]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:26.299]                   NULL)
[10:26:26.299]                 if (is_error) {
[10:26:26.299]                   sessionInformation <- function() {
[10:26:26.299]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:26.299]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:26.299]                       search = base::search(), system = base::Sys.info())
[10:26:26.299]                   }
[10:26:26.299]                   ...future.conditions[[length(...future.conditions) + 
[10:26:26.299]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:26.299]                     cond$call), session = sessionInformation(), 
[10:26:26.299]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:26.299]                   signalCondition(cond)
[10:26:26.299]                 }
[10:26:26.299]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:26.299]                 "immediateCondition"))) {
[10:26:26.299]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:26.299]                   ...future.conditions[[length(...future.conditions) + 
[10:26:26.299]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:26.299]                   if (TRUE && !signal) {
[10:26:26.299]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:26.299]                     {
[10:26:26.299]                       inherits <- base::inherits
[10:26:26.299]                       invokeRestart <- base::invokeRestart
[10:26:26.299]                       is.null <- base::is.null
[10:26:26.299]                       muffled <- FALSE
[10:26:26.299]                       if (inherits(cond, "message")) {
[10:26:26.299]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:26.299]                         if (muffled) 
[10:26:26.299]                           invokeRestart("muffleMessage")
[10:26:26.299]                       }
[10:26:26.299]                       else if (inherits(cond, "warning")) {
[10:26:26.299]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:26.299]                         if (muffled) 
[10:26:26.299]                           invokeRestart("muffleWarning")
[10:26:26.299]                       }
[10:26:26.299]                       else if (inherits(cond, "condition")) {
[10:26:26.299]                         if (!is.null(pattern)) {
[10:26:26.299]                           computeRestarts <- base::computeRestarts
[10:26:26.299]                           grepl <- base::grepl
[10:26:26.299]                           restarts <- computeRestarts(cond)
[10:26:26.299]                           for (restart in restarts) {
[10:26:26.299]                             name <- restart$name
[10:26:26.299]                             if (is.null(name)) 
[10:26:26.299]                               next
[10:26:26.299]                             if (!grepl(pattern, name)) 
[10:26:26.299]                               next
[10:26:26.299]                             invokeRestart(restart)
[10:26:26.299]                             muffled <- TRUE
[10:26:26.299]                             break
[10:26:26.299]                           }
[10:26:26.299]                         }
[10:26:26.299]                       }
[10:26:26.299]                       invisible(muffled)
[10:26:26.299]                     }
[10:26:26.299]                     muffleCondition(cond, pattern = "^muffle")
[10:26:26.299]                   }
[10:26:26.299]                 }
[10:26:26.299]                 else {
[10:26:26.299]                   if (TRUE) {
[10:26:26.299]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:26.299]                     {
[10:26:26.299]                       inherits <- base::inherits
[10:26:26.299]                       invokeRestart <- base::invokeRestart
[10:26:26.299]                       is.null <- base::is.null
[10:26:26.299]                       muffled <- FALSE
[10:26:26.299]                       if (inherits(cond, "message")) {
[10:26:26.299]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:26.299]                         if (muffled) 
[10:26:26.299]                           invokeRestart("muffleMessage")
[10:26:26.299]                       }
[10:26:26.299]                       else if (inherits(cond, "warning")) {
[10:26:26.299]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:26.299]                         if (muffled) 
[10:26:26.299]                           invokeRestart("muffleWarning")
[10:26:26.299]                       }
[10:26:26.299]                       else if (inherits(cond, "condition")) {
[10:26:26.299]                         if (!is.null(pattern)) {
[10:26:26.299]                           computeRestarts <- base::computeRestarts
[10:26:26.299]                           grepl <- base::grepl
[10:26:26.299]                           restarts <- computeRestarts(cond)
[10:26:26.299]                           for (restart in restarts) {
[10:26:26.299]                             name <- restart$name
[10:26:26.299]                             if (is.null(name)) 
[10:26:26.299]                               next
[10:26:26.299]                             if (!grepl(pattern, name)) 
[10:26:26.299]                               next
[10:26:26.299]                             invokeRestart(restart)
[10:26:26.299]                             muffled <- TRUE
[10:26:26.299]                             break
[10:26:26.299]                           }
[10:26:26.299]                         }
[10:26:26.299]                       }
[10:26:26.299]                       invisible(muffled)
[10:26:26.299]                     }
[10:26:26.299]                     muffleCondition(cond, pattern = "^muffle")
[10:26:26.299]                   }
[10:26:26.299]                 }
[10:26:26.299]             }
[10:26:26.299]         }))
[10:26:26.299]     }, error = function(ex) {
[10:26:26.299]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:26.299]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:26.299]                 ...future.rng), started = ...future.startTime, 
[10:26:26.299]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:26.299]             version = "1.8"), class = "FutureResult")
[10:26:26.299]     }, finally = {
[10:26:26.299]         if (!identical(...future.workdir, getwd())) 
[10:26:26.299]             setwd(...future.workdir)
[10:26:26.299]         {
[10:26:26.299]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:26.299]                 ...future.oldOptions$nwarnings <- NULL
[10:26:26.299]             }
[10:26:26.299]             base::options(...future.oldOptions)
[10:26:26.299]             if (.Platform$OS.type == "windows") {
[10:26:26.299]                 old_names <- names(...future.oldEnvVars)
[10:26:26.299]                 envs <- base::Sys.getenv()
[10:26:26.299]                 names <- names(envs)
[10:26:26.299]                 common <- intersect(names, old_names)
[10:26:26.299]                 added <- setdiff(names, old_names)
[10:26:26.299]                 removed <- setdiff(old_names, names)
[10:26:26.299]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:26.299]                   envs[common]]
[10:26:26.299]                 NAMES <- toupper(changed)
[10:26:26.299]                 args <- list()
[10:26:26.299]                 for (kk in seq_along(NAMES)) {
[10:26:26.299]                   name <- changed[[kk]]
[10:26:26.299]                   NAME <- NAMES[[kk]]
[10:26:26.299]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:26.299]                     next
[10:26:26.299]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:26.299]                 }
[10:26:26.299]                 NAMES <- toupper(added)
[10:26:26.299]                 for (kk in seq_along(NAMES)) {
[10:26:26.299]                   name <- added[[kk]]
[10:26:26.299]                   NAME <- NAMES[[kk]]
[10:26:26.299]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:26.299]                     next
[10:26:26.299]                   args[[name]] <- ""
[10:26:26.299]                 }
[10:26:26.299]                 NAMES <- toupper(removed)
[10:26:26.299]                 for (kk in seq_along(NAMES)) {
[10:26:26.299]                   name <- removed[[kk]]
[10:26:26.299]                   NAME <- NAMES[[kk]]
[10:26:26.299]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:26.299]                     next
[10:26:26.299]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:26.299]                 }
[10:26:26.299]                 if (length(args) > 0) 
[10:26:26.299]                   base::do.call(base::Sys.setenv, args = args)
[10:26:26.299]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:26.299]             }
[10:26:26.299]             else {
[10:26:26.299]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:26.299]             }
[10:26:26.299]             {
[10:26:26.299]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:26.299]                   0L) {
[10:26:26.299]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:26.299]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:26.299]                   base::options(opts)
[10:26:26.299]                 }
[10:26:26.299]                 {
[10:26:26.299]                   {
[10:26:26.299]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:26.299]                     NULL
[10:26:26.299]                   }
[10:26:26.299]                   options(future.plan = NULL)
[10:26:26.299]                   if (is.na(NA_character_)) 
[10:26:26.299]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:26.299]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:26.299]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:26.299]                   {
[10:26:26.299]                     future <- SequentialFuture(..., envir = envir)
[10:26:26.299]                     if (!future$lazy) 
[10:26:26.299]                       future <- run(future)
[10:26:26.299]                     invisible(future)
[10:26:26.299]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:26.299]                 }
[10:26:26.299]             }
[10:26:26.299]         }
[10:26:26.299]     })
[10:26:26.299]     if (TRUE) {
[10:26:26.299]         base::sink(type = "output", split = FALSE)
[10:26:26.299]         if (TRUE) {
[10:26:26.299]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:26.299]         }
[10:26:26.299]         else {
[10:26:26.299]             ...future.result["stdout"] <- base::list(NULL)
[10:26:26.299]         }
[10:26:26.299]         base::close(...future.stdout)
[10:26:26.299]         ...future.stdout <- NULL
[10:26:26.299]     }
[10:26:26.299]     ...future.result$conditions <- ...future.conditions
[10:26:26.299]     ...future.result$finished <- base::Sys.time()
[10:26:26.299]     ...future.result
[10:26:26.299] }
[10:26:26.301] MultisessionFuture started
MultisessionFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: b237ea00-048b-53bc-62d3-d50d6929ba00
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:26.313] result() for ClusterFuture ...
[10:26:26.313] receiveMessageFromWorker() for ClusterFuture ...
[10:26:26.313] - Validating connection of MultisessionFuture
[10:26:26.347] - received message: FutureResult
[10:26:26.347] - Received FutureResult
[10:26:26.347] - Erased future from FutureRegistry
[10:26:26.347] result() for ClusterFuture ...
[10:26:26.348] - result already collected: FutureResult
[10:26:26.348] result() for ClusterFuture ... done
[10:26:26.348] signalConditions() ...
[10:26:26.348]  - include = ‘immediateCondition’
[10:26:26.348]  - exclude = 
[10:26:26.348]  - resignal = FALSE
[10:26:26.348]  - Number of conditions: 1
[10:26:26.348] signalConditions() ... done
[10:26:26.348] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:26.348] result() for ClusterFuture ... done
[10:26:26.348] result() for ClusterFuture ...
[10:26:26.349] - result already collected: FutureResult
[10:26:26.349] result() for ClusterFuture ... done
[10:26:26.349] signalConditions() ...
[10:26:26.349]  - include = ‘immediateCondition’
[10:26:26.349]  - exclude = 
[10:26:26.349]  - resignal = FALSE
[10:26:26.349]  - Number of conditions: 1
[10:26:26.349] signalConditions() ... done
<MyError: boom>
[10:26:26.349] result() for ClusterFuture ...
[10:26:26.349] - result already collected: FutureResult
[10:26:26.350] result() for ClusterFuture ... done
[10:26:26.350] result() for ClusterFuture ...
[10:26:26.350] - result already collected: FutureResult
[10:26:26.350] result() for ClusterFuture ... done
[10:26:26.350] signalConditions() ...
[10:26:26.350]  - include = ‘immediateCondition’
[10:26:26.350]  - exclude = 
[10:26:26.350]  - resignal = FALSE
[10:26:26.350]  - Number of conditions: 1
[10:26:26.350] signalConditions() ... done
[10:26:26.350] Future state: ‘finished’
[10:26:26.351] result() for ClusterFuture ...
[10:26:26.351] - result already collected: FutureResult
[10:26:26.351] result() for ClusterFuture ... done
[10:26:26.351] signalConditions() ...
[10:26:26.351]  - include = ‘condition’
[10:26:26.351]  - exclude = ‘immediateCondition’
[10:26:26.351]  - resignal = TRUE
[10:26:26.351]  - Number of conditions: 1
[10:26:26.351]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[10:26:26.351] signalConditions() ... done
Testing with 2 cores ... DONE
> 
> 
> message("*** multisession() - too large globals ...")
*** multisession() - too large globals ...
> ooptsT <- options(future.globals.maxSize = object.size(1:1014))
> 
> limit <- getOption("future.globals.maxSize")
> cat(sprintf("Max total size of globals: %g bytes\n", limit))
Max total size of globals: 4104 bytes
> 
> for (workers in unique(c(1L, availableCores()))) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message("Max number of sessions: ", workers)
+ 
+   ## A large object
+   a <- 1:1014
+   yTruth <- sum(a)
+   size <- object.size(a)
+   cat(sprintf("a: %g bytes\n", size))
+   f <- multisession({ sum(a) }, globals = TRUE, workers = workers)
+   print(f)
+   rm(list = "a")
+   v <- value(f)
+   print(v)
+   stopifnot(v == yTruth)
+ 
+ 
+   ## A too large object
+   a <- 1:1015
+   yTruth <- sum(a)
+   size <- object.size(a)
+   cat(sprintf("a: %g bytes\n", size))
+   res <- try(f <- multisession({ sum(a) }, globals = TRUE, workers = workers), silent = TRUE)
+   rm(list = "a")
+   stopifnot(inherits(res, "try-error"))
+ } ## for (workers in ...)
Max number of sessions: 1
a: 4104 bytes
[10:26:26.367] getGlobalsAndPackages() ...
[10:26:26.367] Searching for globals...
[10:26:26.368] - globals found: [3] ‘{’, ‘sum’, ‘a’
[10:26:26.368] Searching for globals ... DONE
[10:26:26.368] Resolving globals: FALSE
[10:26:26.368] The total size of the 1 globals is 4.01 KiB (4104 bytes)
[10:26:26.369] The total size of the 1 globals exported for future expression (‘{; sum(a); }’) is 4.01 KiB.. This exceeds the maximum allowed size of 4.01 KiB (option 'future.globals.maxSize'). There is one global: ‘a’ (4.01 KiB of class ‘numeric’)
[10:26:26.369] - globals: [1] ‘a’
[10:26:26.369] 
[10:26:26.369] getGlobalsAndPackages() ... DONE
SequentialFuture:
Label: ‘<none>’
Expression:
{
    sum(a)
}
Lazy evaluation: TRUE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: 1 objects totaling 4.01 KiB (integer ‘a’ of 4.01 KiB)
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: b237ea00-048b-53bc-62d3-d50d6929ba00
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:26.370] Packages needed by the future expression (n = 0): <none>
[10:26:26.370] Packages needed by future strategies (n = 0): <none>
[10:26:26.370] {
[10:26:26.370]     {
[10:26:26.370]         {
[10:26:26.370]             ...future.startTime <- base::Sys.time()
[10:26:26.370]             {
[10:26:26.370]                 {
[10:26:26.370]                   {
[10:26:26.370]                     base::local({
[10:26:26.370]                       has_future <- base::requireNamespace("future", 
[10:26:26.370]                         quietly = TRUE)
[10:26:26.370]                       if (has_future) {
[10:26:26.370]                         ns <- base::getNamespace("future")
[10:26:26.370]                         version <- ns[[".package"]][["version"]]
[10:26:26.370]                         if (is.null(version)) 
[10:26:26.370]                           version <- utils::packageVersion("future")
[10:26:26.370]                       }
[10:26:26.370]                       else {
[10:26:26.370]                         version <- NULL
[10:26:26.370]                       }
[10:26:26.370]                       if (!has_future || version < "1.8.0") {
[10:26:26.370]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:26.370]                           "", base::R.version$version.string), 
[10:26:26.370]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:26.370]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:26.370]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:26.370]                             "release", "version")], collapse = " "), 
[10:26:26.370]                           hostname = base::Sys.info()[["nodename"]])
[10:26:26.370]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:26.370]                           info)
[10:26:26.370]                         info <- base::paste(info, collapse = "; ")
[10:26:26.370]                         if (!has_future) {
[10:26:26.370]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:26.370]                             info)
[10:26:26.370]                         }
[10:26:26.370]                         else {
[10:26:26.370]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:26.370]                             info, version)
[10:26:26.370]                         }
[10:26:26.370]                         base::stop(msg)
[10:26:26.370]                       }
[10:26:26.370]                     })
[10:26:26.370]                   }
[10:26:26.370]                   options(future.plan = NULL)
[10:26:26.370]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:26.370]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:26.370]                 }
[10:26:26.370]                 ...future.workdir <- getwd()
[10:26:26.370]             }
[10:26:26.370]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:26.370]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:26.370]         }
[10:26:26.370]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:26.370]             future.globals.maxSize = 4104, future.globals.method = NULL, 
[10:26:26.370]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:26.370]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:26.370]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:26.370]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:26.370]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:26.370]             base::names(...future.oldOptions))
[10:26:26.370]     }
[10:26:26.370]     if (FALSE) {
[10:26:26.370]     }
[10:26:26.370]     else {
[10:26:26.370]         if (TRUE) {
[10:26:26.370]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:26.370]                 open = "w")
[10:26:26.370]         }
[10:26:26.370]         else {
[10:26:26.370]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:26.370]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:26.370]         }
[10:26:26.370]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:26.370]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:26.370]             base::sink(type = "output", split = FALSE)
[10:26:26.370]             base::close(...future.stdout)
[10:26:26.370]         }, add = TRUE)
[10:26:26.370]     }
[10:26:26.370]     ...future.frame <- base::sys.nframe()
[10:26:26.370]     ...future.conditions <- base::list()
[10:26:26.370]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:26.370]     if (FALSE) {
[10:26:26.370]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:26.370]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:26.370]     }
[10:26:26.370]     ...future.result <- base::tryCatch({
[10:26:26.370]         base::withCallingHandlers({
[10:26:26.370]             ...future.value <- base::withVisible(base::local({
[10:26:26.370]                 sum(a)
[10:26:26.370]             }))
[10:26:26.370]             future::FutureResult(value = ...future.value$value, 
[10:26:26.370]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:26.370]                   ...future.rng), globalenv = if (FALSE) 
[10:26:26.370]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:26.370]                     ...future.globalenv.names))
[10:26:26.370]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:26.370]         }, condition = base::local({
[10:26:26.370]             c <- base::c
[10:26:26.370]             inherits <- base::inherits
[10:26:26.370]             invokeRestart <- base::invokeRestart
[10:26:26.370]             length <- base::length
[10:26:26.370]             list <- base::list
[10:26:26.370]             seq.int <- base::seq.int
[10:26:26.370]             signalCondition <- base::signalCondition
[10:26:26.370]             sys.calls <- base::sys.calls
[10:26:26.370]             `[[` <- base::`[[`
[10:26:26.370]             `+` <- base::`+`
[10:26:26.370]             `<<-` <- base::`<<-`
[10:26:26.370]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:26.370]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:26.370]                   3L)]
[10:26:26.370]             }
[10:26:26.370]             function(cond) {
[10:26:26.370]                 is_error <- inherits(cond, "error")
[10:26:26.370]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:26.370]                   NULL)
[10:26:26.370]                 if (is_error) {
[10:26:26.370]                   sessionInformation <- function() {
[10:26:26.370]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:26.370]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:26.370]                       search = base::search(), system = base::Sys.info())
[10:26:26.370]                   }
[10:26:26.370]                   ...future.conditions[[length(...future.conditions) + 
[10:26:26.370]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:26.370]                     cond$call), session = sessionInformation(), 
[10:26:26.370]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:26.370]                   signalCondition(cond)
[10:26:26.370]                 }
[10:26:26.370]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:26.370]                 "immediateCondition"))) {
[10:26:26.370]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:26.370]                   ...future.conditions[[length(...future.conditions) + 
[10:26:26.370]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:26.370]                   if (TRUE && !signal) {
[10:26:26.370]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:26.370]                     {
[10:26:26.370]                       inherits <- base::inherits
[10:26:26.370]                       invokeRestart <- base::invokeRestart
[10:26:26.370]                       is.null <- base::is.null
[10:26:26.370]                       muffled <- FALSE
[10:26:26.370]                       if (inherits(cond, "message")) {
[10:26:26.370]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:26.370]                         if (muffled) 
[10:26:26.370]                           invokeRestart("muffleMessage")
[10:26:26.370]                       }
[10:26:26.370]                       else if (inherits(cond, "warning")) {
[10:26:26.370]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:26.370]                         if (muffled) 
[10:26:26.370]                           invokeRestart("muffleWarning")
[10:26:26.370]                       }
[10:26:26.370]                       else if (inherits(cond, "condition")) {
[10:26:26.370]                         if (!is.null(pattern)) {
[10:26:26.370]                           computeRestarts <- base::computeRestarts
[10:26:26.370]                           grepl <- base::grepl
[10:26:26.370]                           restarts <- computeRestarts(cond)
[10:26:26.370]                           for (restart in restarts) {
[10:26:26.370]                             name <- restart$name
[10:26:26.370]                             if (is.null(name)) 
[10:26:26.370]                               next
[10:26:26.370]                             if (!grepl(pattern, name)) 
[10:26:26.370]                               next
[10:26:26.370]                             invokeRestart(restart)
[10:26:26.370]                             muffled <- TRUE
[10:26:26.370]                             break
[10:26:26.370]                           }
[10:26:26.370]                         }
[10:26:26.370]                       }
[10:26:26.370]                       invisible(muffled)
[10:26:26.370]                     }
[10:26:26.370]                     muffleCondition(cond, pattern = "^muffle")
[10:26:26.370]                   }
[10:26:26.370]                 }
[10:26:26.370]                 else {
[10:26:26.370]                   if (TRUE) {
[10:26:26.370]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:26.370]                     {
[10:26:26.370]                       inherits <- base::inherits
[10:26:26.370]                       invokeRestart <- base::invokeRestart
[10:26:26.370]                       is.null <- base::is.null
[10:26:26.370]                       muffled <- FALSE
[10:26:26.370]                       if (inherits(cond, "message")) {
[10:26:26.370]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:26.370]                         if (muffled) 
[10:26:26.370]                           invokeRestart("muffleMessage")
[10:26:26.370]                       }
[10:26:26.370]                       else if (inherits(cond, "warning")) {
[10:26:26.370]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:26.370]                         if (muffled) 
[10:26:26.370]                           invokeRestart("muffleWarning")
[10:26:26.370]                       }
[10:26:26.370]                       else if (inherits(cond, "condition")) {
[10:26:26.370]                         if (!is.null(pattern)) {
[10:26:26.370]                           computeRestarts <- base::computeRestarts
[10:26:26.370]                           grepl <- base::grepl
[10:26:26.370]                           restarts <- computeRestarts(cond)
[10:26:26.370]                           for (restart in restarts) {
[10:26:26.370]                             name <- restart$name
[10:26:26.370]                             if (is.null(name)) 
[10:26:26.370]                               next
[10:26:26.370]                             if (!grepl(pattern, name)) 
[10:26:26.370]                               next
[10:26:26.370]                             invokeRestart(restart)
[10:26:26.370]                             muffled <- TRUE
[10:26:26.370]                             break
[10:26:26.370]                           }
[10:26:26.370]                         }
[10:26:26.370]                       }
[10:26:26.370]                       invisible(muffled)
[10:26:26.370]                     }
[10:26:26.370]                     muffleCondition(cond, pattern = "^muffle")
[10:26:26.370]                   }
[10:26:26.370]                 }
[10:26:26.370]             }
[10:26:26.370]         }))
[10:26:26.370]     }, error = function(ex) {
[10:26:26.370]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:26.370]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:26.370]                 ...future.rng), started = ...future.startTime, 
[10:26:26.370]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:26.370]             version = "1.8"), class = "FutureResult")
[10:26:26.370]     }, finally = {
[10:26:26.370]         if (!identical(...future.workdir, getwd())) 
[10:26:26.370]             setwd(...future.workdir)
[10:26:26.370]         {
[10:26:26.370]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:26.370]                 ...future.oldOptions$nwarnings <- NULL
[10:26:26.370]             }
[10:26:26.370]             base::options(...future.oldOptions)
[10:26:26.370]             if (.Platform$OS.type == "windows") {
[10:26:26.370]                 old_names <- names(...future.oldEnvVars)
[10:26:26.370]                 envs <- base::Sys.getenv()
[10:26:26.370]                 names <- names(envs)
[10:26:26.370]                 common <- intersect(names, old_names)
[10:26:26.370]                 added <- setdiff(names, old_names)
[10:26:26.370]                 removed <- setdiff(old_names, names)
[10:26:26.370]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:26.370]                   envs[common]]
[10:26:26.370]                 NAMES <- toupper(changed)
[10:26:26.370]                 args <- list()
[10:26:26.370]                 for (kk in seq_along(NAMES)) {
[10:26:26.370]                   name <- changed[[kk]]
[10:26:26.370]                   NAME <- NAMES[[kk]]
[10:26:26.370]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:26.370]                     next
[10:26:26.370]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:26.370]                 }
[10:26:26.370]                 NAMES <- toupper(added)
[10:26:26.370]                 for (kk in seq_along(NAMES)) {
[10:26:26.370]                   name <- added[[kk]]
[10:26:26.370]                   NAME <- NAMES[[kk]]
[10:26:26.370]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:26.370]                     next
[10:26:26.370]                   args[[name]] <- ""
[10:26:26.370]                 }
[10:26:26.370]                 NAMES <- toupper(removed)
[10:26:26.370]                 for (kk in seq_along(NAMES)) {
[10:26:26.370]                   name <- removed[[kk]]
[10:26:26.370]                   NAME <- NAMES[[kk]]
[10:26:26.370]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:26.370]                     next
[10:26:26.370]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:26.370]                 }
[10:26:26.370]                 if (length(args) > 0) 
[10:26:26.370]                   base::do.call(base::Sys.setenv, args = args)
[10:26:26.370]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:26.370]             }
[10:26:26.370]             else {
[10:26:26.370]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:26.370]             }
[10:26:26.370]             {
[10:26:26.370]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:26.370]                   0L) {
[10:26:26.370]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:26.370]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:26.370]                   base::options(opts)
[10:26:26.370]                 }
[10:26:26.370]                 {
[10:26:26.370]                   {
[10:26:26.370]                     NULL
[10:26:26.370]                     RNGkind("Mersenne-Twister")
[10:26:26.370]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:26.370]                       inherits = FALSE)
[10:26:26.370]                   }
[10:26:26.370]                   options(future.plan = NULL)
[10:26:26.370]                   if (is.na(NA_character_)) 
[10:26:26.370]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:26.370]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:26.370]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:26.370]                   {
[10:26:26.370]                     future <- SequentialFuture(..., envir = envir)
[10:26:26.370]                     if (!future$lazy) 
[10:26:26.370]                       future <- run(future)
[10:26:26.370]                     invisible(future)
[10:26:26.370]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:26.370]                 }
[10:26:26.370]             }
[10:26:26.370]         }
[10:26:26.370]     })
[10:26:26.370]     if (TRUE) {
[10:26:26.370]         base::sink(type = "output", split = FALSE)
[10:26:26.370]         if (TRUE) {
[10:26:26.370]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:26.370]         }
[10:26:26.370]         else {
[10:26:26.370]             ...future.result["stdout"] <- base::list(NULL)
[10:26:26.370]         }
[10:26:26.370]         base::close(...future.stdout)
[10:26:26.370]         ...future.stdout <- NULL
[10:26:26.370]     }
[10:26:26.370]     ...future.result$conditions <- ...future.conditions
[10:26:26.370]     ...future.result$finished <- base::Sys.time()
[10:26:26.370]     ...future.result
[10:26:26.370] }
[10:26:26.372] assign_globals() ...
[10:26:26.372] List of 1
[10:26:26.372]  $ a: int [1:1014] 1 2 3 4 5 6 7 8 9 10 ...
[10:26:26.372]  - attr(*, "where")=List of 1
[10:26:26.372]   ..$ a:<environment: R_EmptyEnv> 
[10:26:26.372]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:26.372]  - attr(*, "resolved")= logi FALSE
[10:26:26.372]  - attr(*, "total_size")= num 4104
[10:26:26.375] - copied ‘a’ to environment
[10:26:26.375] assign_globals() ... done
[10:26:26.376] plan(): Setting new future strategy stack:
[10:26:26.376] List of future strategies:
[10:26:26.376] 1. sequential:
[10:26:26.376]    - args: function (..., envir = parent.frame())
[10:26:26.376]    - tweaked: FALSE
[10:26:26.376]    - call: NULL
[10:26:26.376] plan(): nbrOfWorkers() = 1
[10:26:26.377] plan(): Setting new future strategy stack:
[10:26:26.377] List of future strategies:
[10:26:26.377] 1. sequential:
[10:26:26.377]    - args: function (..., envir = parent.frame())
[10:26:26.377]    - tweaked: FALSE
[10:26:26.377]    - call: future::plan("sequential")
[10:26:26.377] plan(): nbrOfWorkers() = 1
[10:26:26.377] SequentialFuture started (and completed)
[1] 514605
a: 4112 bytes
[10:26:26.378] getGlobalsAndPackages() ...
[10:26:26.378] Searching for globals...
[10:26:26.379] - globals found: [3] ‘{’, ‘sum’, ‘a’
[10:26:26.379] Searching for globals ... DONE
[10:26:26.379] Resolving globals: FALSE
[10:26:26.379] The total size of the 1 globals is 4.02 KiB (4112 bytes)
[10:26:26.379] The total size of the 1 globals exported for future expression (‘{; sum(a); }’) is 4.02 KiB.. This exceeds the maximum allowed size of 4.01 KiB (option 'future.globals.maxSize'). There is one global: ‘a’ (4.02 KiB of class ‘numeric’)
Max number of sessions: 2
a: 4104 bytes
[10:26:26.380] getGlobalsAndPackages() ...
[10:26:26.380] Searching for globals...
[10:26:26.381] - globals found: [3] ‘{’, ‘sum’, ‘a’
[10:26:26.381] Searching for globals ... DONE
[10:26:26.381] Resolving globals: FALSE
[10:26:26.381] The total size of the 1 globals is 4.01 KiB (4104 bytes)
[10:26:26.382] The total size of the 1 globals exported for future expression (‘{; sum(a); }’) is 4.01 KiB.. This exceeds the maximum allowed size of 4.01 KiB (option 'future.globals.maxSize'). There is one global: ‘a’ (4.01 KiB of class ‘numeric’)
[10:26:26.382] - globals: [1] ‘a’
[10:26:26.382] 
[10:26:26.382] getGlobalsAndPackages() ... DONE
[10:26:26.392] Packages needed by the future expression (n = 0): <none>
[10:26:26.392] Packages needed by future strategies (n = 0): <none>
[10:26:26.393] {
[10:26:26.393]     {
[10:26:26.393]         {
[10:26:26.393]             ...future.startTime <- base::Sys.time()
[10:26:26.393]             {
[10:26:26.393]                 {
[10:26:26.393]                   {
[10:26:26.393]                     {
[10:26:26.393]                       base::local({
[10:26:26.393]                         has_future <- base::requireNamespace("future", 
[10:26:26.393]                           quietly = TRUE)
[10:26:26.393]                         if (has_future) {
[10:26:26.393]                           ns <- base::getNamespace("future")
[10:26:26.393]                           version <- ns[[".package"]][["version"]]
[10:26:26.393]                           if (is.null(version)) 
[10:26:26.393]                             version <- utils::packageVersion("future")
[10:26:26.393]                         }
[10:26:26.393]                         else {
[10:26:26.393]                           version <- NULL
[10:26:26.393]                         }
[10:26:26.393]                         if (!has_future || version < "1.8.0") {
[10:26:26.393]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:26.393]                             "", base::R.version$version.string), 
[10:26:26.393]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:26.393]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:26.393]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:26.393]                               "release", "version")], collapse = " "), 
[10:26:26.393]                             hostname = base::Sys.info()[["nodename"]])
[10:26:26.393]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:26.393]                             info)
[10:26:26.393]                           info <- base::paste(info, collapse = "; ")
[10:26:26.393]                           if (!has_future) {
[10:26:26.393]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:26.393]                               info)
[10:26:26.393]                           }
[10:26:26.393]                           else {
[10:26:26.393]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:26.393]                               info, version)
[10:26:26.393]                           }
[10:26:26.393]                           base::stop(msg)
[10:26:26.393]                         }
[10:26:26.393]                       })
[10:26:26.393]                     }
[10:26:26.393]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:26.393]                     base::options(mc.cores = 1L)
[10:26:26.393]                   }
[10:26:26.393]                   options(future.plan = NULL)
[10:26:26.393]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:26.393]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:26.393]                 }
[10:26:26.393]                 ...future.workdir <- getwd()
[10:26:26.393]             }
[10:26:26.393]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:26.393]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:26.393]         }
[10:26:26.393]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:26.393]             future.globals.maxSize = 4104, future.globals.method = NULL, 
[10:26:26.393]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:26.393]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:26.393]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:26.393]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:26.393]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:26.393]             base::names(...future.oldOptions))
[10:26:26.393]     }
[10:26:26.393]     if (FALSE) {
[10:26:26.393]     }
[10:26:26.393]     else {
[10:26:26.393]         if (TRUE) {
[10:26:26.393]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:26.393]                 open = "w")
[10:26:26.393]         }
[10:26:26.393]         else {
[10:26:26.393]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:26.393]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:26.393]         }
[10:26:26.393]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:26.393]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:26.393]             base::sink(type = "output", split = FALSE)
[10:26:26.393]             base::close(...future.stdout)
[10:26:26.393]         }, add = TRUE)
[10:26:26.393]     }
[10:26:26.393]     ...future.frame <- base::sys.nframe()
[10:26:26.393]     ...future.conditions <- base::list()
[10:26:26.393]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:26.393]     if (FALSE) {
[10:26:26.393]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:26.393]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:26.393]     }
[10:26:26.393]     ...future.result <- base::tryCatch({
[10:26:26.393]         base::withCallingHandlers({
[10:26:26.393]             ...future.value <- base::withVisible(base::local({
[10:26:26.393]                 ...future.makeSendCondition <- base::local({
[10:26:26.393]                   sendCondition <- NULL
[10:26:26.393]                   function(frame = 1L) {
[10:26:26.393]                     if (is.function(sendCondition)) 
[10:26:26.393]                       return(sendCondition)
[10:26:26.393]                     ns <- getNamespace("parallel")
[10:26:26.393]                     if (exists("sendData", mode = "function", 
[10:26:26.393]                       envir = ns)) {
[10:26:26.393]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:26.393]                         envir = ns)
[10:26:26.393]                       envir <- sys.frame(frame)
[10:26:26.393]                       master <- NULL
[10:26:26.393]                       while (!identical(envir, .GlobalEnv) && 
[10:26:26.393]                         !identical(envir, emptyenv())) {
[10:26:26.393]                         if (exists("master", mode = "list", envir = envir, 
[10:26:26.393]                           inherits = FALSE)) {
[10:26:26.393]                           master <- get("master", mode = "list", 
[10:26:26.393]                             envir = envir, inherits = FALSE)
[10:26:26.393]                           if (inherits(master, c("SOCKnode", 
[10:26:26.393]                             "SOCK0node"))) {
[10:26:26.393]                             sendCondition <<- function(cond) {
[10:26:26.393]                               data <- list(type = "VALUE", value = cond, 
[10:26:26.393]                                 success = TRUE)
[10:26:26.393]                               parallel_sendData(master, data)
[10:26:26.393]                             }
[10:26:26.393]                             return(sendCondition)
[10:26:26.393]                           }
[10:26:26.393]                         }
[10:26:26.393]                         frame <- frame + 1L
[10:26:26.393]                         envir <- sys.frame(frame)
[10:26:26.393]                       }
[10:26:26.393]                     }
[10:26:26.393]                     sendCondition <<- function(cond) NULL
[10:26:26.393]                   }
[10:26:26.393]                 })
[10:26:26.393]                 withCallingHandlers({
[10:26:26.393]                   {
[10:26:26.393]                     sum(a)
[10:26:26.393]                   }
[10:26:26.393]                 }, immediateCondition = function(cond) {
[10:26:26.393]                   sendCondition <- ...future.makeSendCondition()
[10:26:26.393]                   sendCondition(cond)
[10:26:26.393]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:26.393]                   {
[10:26:26.393]                     inherits <- base::inherits
[10:26:26.393]                     invokeRestart <- base::invokeRestart
[10:26:26.393]                     is.null <- base::is.null
[10:26:26.393]                     muffled <- FALSE
[10:26:26.393]                     if (inherits(cond, "message")) {
[10:26:26.393]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:26.393]                       if (muffled) 
[10:26:26.393]                         invokeRestart("muffleMessage")
[10:26:26.393]                     }
[10:26:26.393]                     else if (inherits(cond, "warning")) {
[10:26:26.393]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:26.393]                       if (muffled) 
[10:26:26.393]                         invokeRestart("muffleWarning")
[10:26:26.393]                     }
[10:26:26.393]                     else if (inherits(cond, "condition")) {
[10:26:26.393]                       if (!is.null(pattern)) {
[10:26:26.393]                         computeRestarts <- base::computeRestarts
[10:26:26.393]                         grepl <- base::grepl
[10:26:26.393]                         restarts <- computeRestarts(cond)
[10:26:26.393]                         for (restart in restarts) {
[10:26:26.393]                           name <- restart$name
[10:26:26.393]                           if (is.null(name)) 
[10:26:26.393]                             next
[10:26:26.393]                           if (!grepl(pattern, name)) 
[10:26:26.393]                             next
[10:26:26.393]                           invokeRestart(restart)
[10:26:26.393]                           muffled <- TRUE
[10:26:26.393]                           break
[10:26:26.393]                         }
[10:26:26.393]                       }
[10:26:26.393]                     }
[10:26:26.393]                     invisible(muffled)
[10:26:26.393]                   }
[10:26:26.393]                   muffleCondition(cond)
[10:26:26.393]                 })
[10:26:26.393]             }))
[10:26:26.393]             future::FutureResult(value = ...future.value$value, 
[10:26:26.393]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:26.393]                   ...future.rng), globalenv = if (FALSE) 
[10:26:26.393]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:26.393]                     ...future.globalenv.names))
[10:26:26.393]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:26.393]         }, condition = base::local({
[10:26:26.393]             c <- base::c
[10:26:26.393]             inherits <- base::inherits
[10:26:26.393]             invokeRestart <- base::invokeRestart
[10:26:26.393]             length <- base::length
[10:26:26.393]             list <- base::list
[10:26:26.393]             seq.int <- base::seq.int
[10:26:26.393]             signalCondition <- base::signalCondition
[10:26:26.393]             sys.calls <- base::sys.calls
[10:26:26.393]             `[[` <- base::`[[`
[10:26:26.393]             `+` <- base::`+`
[10:26:26.393]             `<<-` <- base::`<<-`
[10:26:26.393]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:26.393]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:26.393]                   3L)]
[10:26:26.393]             }
[10:26:26.393]             function(cond) {
[10:26:26.393]                 is_error <- inherits(cond, "error")
[10:26:26.393]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:26.393]                   NULL)
[10:26:26.393]                 if (is_error) {
[10:26:26.393]                   sessionInformation <- function() {
[10:26:26.393]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:26.393]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:26.393]                       search = base::search(), system = base::Sys.info())
[10:26:26.393]                   }
[10:26:26.393]                   ...future.conditions[[length(...future.conditions) + 
[10:26:26.393]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:26.393]                     cond$call), session = sessionInformation(), 
[10:26:26.393]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:26.393]                   signalCondition(cond)
[10:26:26.393]                 }
[10:26:26.393]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:26.393]                 "immediateCondition"))) {
[10:26:26.393]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:26.393]                   ...future.conditions[[length(...future.conditions) + 
[10:26:26.393]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:26.393]                   if (TRUE && !signal) {
[10:26:26.393]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:26.393]                     {
[10:26:26.393]                       inherits <- base::inherits
[10:26:26.393]                       invokeRestart <- base::invokeRestart
[10:26:26.393]                       is.null <- base::is.null
[10:26:26.393]                       muffled <- FALSE
[10:26:26.393]                       if (inherits(cond, "message")) {
[10:26:26.393]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:26.393]                         if (muffled) 
[10:26:26.393]                           invokeRestart("muffleMessage")
[10:26:26.393]                       }
[10:26:26.393]                       else if (inherits(cond, "warning")) {
[10:26:26.393]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:26.393]                         if (muffled) 
[10:26:26.393]                           invokeRestart("muffleWarning")
[10:26:26.393]                       }
[10:26:26.393]                       else if (inherits(cond, "condition")) {
[10:26:26.393]                         if (!is.null(pattern)) {
[10:26:26.393]                           computeRestarts <- base::computeRestarts
[10:26:26.393]                           grepl <- base::grepl
[10:26:26.393]                           restarts <- computeRestarts(cond)
[10:26:26.393]                           for (restart in restarts) {
[10:26:26.393]                             name <- restart$name
[10:26:26.393]                             if (is.null(name)) 
[10:26:26.393]                               next
[10:26:26.393]                             if (!grepl(pattern, name)) 
[10:26:26.393]                               next
[10:26:26.393]                             invokeRestart(restart)
[10:26:26.393]                             muffled <- TRUE
[10:26:26.393]                             break
[10:26:26.393]                           }
[10:26:26.393]                         }
[10:26:26.393]                       }
[10:26:26.393]                       invisible(muffled)
[10:26:26.393]                     }
[10:26:26.393]                     muffleCondition(cond, pattern = "^muffle")
[10:26:26.393]                   }
[10:26:26.393]                 }
[10:26:26.393]                 else {
[10:26:26.393]                   if (TRUE) {
[10:26:26.393]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:26.393]                     {
[10:26:26.393]                       inherits <- base::inherits
[10:26:26.393]                       invokeRestart <- base::invokeRestart
[10:26:26.393]                       is.null <- base::is.null
[10:26:26.393]                       muffled <- FALSE
[10:26:26.393]                       if (inherits(cond, "message")) {
[10:26:26.393]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:26.393]                         if (muffled) 
[10:26:26.393]                           invokeRestart("muffleMessage")
[10:26:26.393]                       }
[10:26:26.393]                       else if (inherits(cond, "warning")) {
[10:26:26.393]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:26.393]                         if (muffled) 
[10:26:26.393]                           invokeRestart("muffleWarning")
[10:26:26.393]                       }
[10:26:26.393]                       else if (inherits(cond, "condition")) {
[10:26:26.393]                         if (!is.null(pattern)) {
[10:26:26.393]                           computeRestarts <- base::computeRestarts
[10:26:26.393]                           grepl <- base::grepl
[10:26:26.393]                           restarts <- computeRestarts(cond)
[10:26:26.393]                           for (restart in restarts) {
[10:26:26.393]                             name <- restart$name
[10:26:26.393]                             if (is.null(name)) 
[10:26:26.393]                               next
[10:26:26.393]                             if (!grepl(pattern, name)) 
[10:26:26.393]                               next
[10:26:26.393]                             invokeRestart(restart)
[10:26:26.393]                             muffled <- TRUE
[10:26:26.393]                             break
[10:26:26.393]                           }
[10:26:26.393]                         }
[10:26:26.393]                       }
[10:26:26.393]                       invisible(muffled)
[10:26:26.393]                     }
[10:26:26.393]                     muffleCondition(cond, pattern = "^muffle")
[10:26:26.393]                   }
[10:26:26.393]                 }
[10:26:26.393]             }
[10:26:26.393]         }))
[10:26:26.393]     }, error = function(ex) {
[10:26:26.393]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:26.393]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:26.393]                 ...future.rng), started = ...future.startTime, 
[10:26:26.393]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:26.393]             version = "1.8"), class = "FutureResult")
[10:26:26.393]     }, finally = {
[10:26:26.393]         if (!identical(...future.workdir, getwd())) 
[10:26:26.393]             setwd(...future.workdir)
[10:26:26.393]         {
[10:26:26.393]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:26.393]                 ...future.oldOptions$nwarnings <- NULL
[10:26:26.393]             }
[10:26:26.393]             base::options(...future.oldOptions)
[10:26:26.393]             if (.Platform$OS.type == "windows") {
[10:26:26.393]                 old_names <- names(...future.oldEnvVars)
[10:26:26.393]                 envs <- base::Sys.getenv()
[10:26:26.393]                 names <- names(envs)
[10:26:26.393]                 common <- intersect(names, old_names)
[10:26:26.393]                 added <- setdiff(names, old_names)
[10:26:26.393]                 removed <- setdiff(old_names, names)
[10:26:26.393]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:26.393]                   envs[common]]
[10:26:26.393]                 NAMES <- toupper(changed)
[10:26:26.393]                 args <- list()
[10:26:26.393]                 for (kk in seq_along(NAMES)) {
[10:26:26.393]                   name <- changed[[kk]]
[10:26:26.393]                   NAME <- NAMES[[kk]]
[10:26:26.393]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:26.393]                     next
[10:26:26.393]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:26.393]                 }
[10:26:26.393]                 NAMES <- toupper(added)
[10:26:26.393]                 for (kk in seq_along(NAMES)) {
[10:26:26.393]                   name <- added[[kk]]
[10:26:26.393]                   NAME <- NAMES[[kk]]
[10:26:26.393]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:26.393]                     next
[10:26:26.393]                   args[[name]] <- ""
[10:26:26.393]                 }
[10:26:26.393]                 NAMES <- toupper(removed)
[10:26:26.393]                 for (kk in seq_along(NAMES)) {
[10:26:26.393]                   name <- removed[[kk]]
[10:26:26.393]                   NAME <- NAMES[[kk]]
[10:26:26.393]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:26.393]                     next
[10:26:26.393]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:26.393]                 }
[10:26:26.393]                 if (length(args) > 0) 
[10:26:26.393]                   base::do.call(base::Sys.setenv, args = args)
[10:26:26.393]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:26.393]             }
[10:26:26.393]             else {
[10:26:26.393]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:26.393]             }
[10:26:26.393]             {
[10:26:26.393]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:26.393]                   0L) {
[10:26:26.393]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:26.393]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:26.393]                   base::options(opts)
[10:26:26.393]                 }
[10:26:26.393]                 {
[10:26:26.393]                   {
[10:26:26.393]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:26.393]                     NULL
[10:26:26.393]                   }
[10:26:26.393]                   options(future.plan = NULL)
[10:26:26.393]                   if (is.na(NA_character_)) 
[10:26:26.393]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:26.393]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:26.393]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:26.393]                   {
[10:26:26.393]                     future <- SequentialFuture(..., envir = envir)
[10:26:26.393]                     if (!future$lazy) 
[10:26:26.393]                       future <- run(future)
[10:26:26.393]                     invisible(future)
[10:26:26.393]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:26.393]                 }
[10:26:26.393]             }
[10:26:26.393]         }
[10:26:26.393]     })
[10:26:26.393]     if (TRUE) {
[10:26:26.393]         base::sink(type = "output", split = FALSE)
[10:26:26.393]         if (TRUE) {
[10:26:26.393]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:26.393]         }
[10:26:26.393]         else {
[10:26:26.393]             ...future.result["stdout"] <- base::list(NULL)
[10:26:26.393]         }
[10:26:26.393]         base::close(...future.stdout)
[10:26:26.393]         ...future.stdout <- NULL
[10:26:26.393]     }
[10:26:26.393]     ...future.result$conditions <- ...future.conditions
[10:26:26.393]     ...future.result$finished <- base::Sys.time()
[10:26:26.393]     ...future.result
[10:26:26.393] }
[10:26:26.395] Exporting 1 global objects (4.01 KiB) to cluster node #1 ...
[10:26:26.396] Exporting ‘a’ (4.01 KiB) to cluster node #1 ...
[10:26:26.396] Exporting ‘a’ (4.01 KiB) to cluster node #1 ... DONE
[10:26:26.396] Exporting 1 global objects (4.01 KiB) to cluster node #1 ... DONE
[10:26:26.397] MultisessionFuture started
MultisessionFuture:
Label: ‘<none>’
Expression:
{
    sum(a)
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: 1 objects totaling 4.01 KiB (integer ‘a’ of 4.01 KiB)
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: b237ea00-048b-53bc-62d3-d50d6929ba00
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:26.408] result() for ClusterFuture ...
[10:26:26.408] receiveMessageFromWorker() for ClusterFuture ...
[10:26:26.408] - Validating connection of MultisessionFuture
[10:26:26.439] - received message: FutureResult
[10:26:26.439] - Received FutureResult
[10:26:26.439] - Erased future from FutureRegistry
[10:26:26.439] result() for ClusterFuture ...
[10:26:26.439] - result already collected: FutureResult
[10:26:26.439] result() for ClusterFuture ... done
[10:26:26.440] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:26.440] result() for ClusterFuture ... done
[10:26:26.440] result() for ClusterFuture ...
[10:26:26.440] - result already collected: FutureResult
[10:26:26.440] result() for ClusterFuture ... done
[1] 514605
a: 4112 bytes
[10:26:26.440] getGlobalsAndPackages() ...
[10:26:26.440] Searching for globals...
[10:26:26.441] - globals found: [3] ‘{’, ‘sum’, ‘a’
[10:26:26.441] Searching for globals ... DONE
[10:26:26.441] Resolving globals: FALSE
[10:26:26.442] The total size of the 1 globals is 4.02 KiB (4112 bytes)
[10:26:26.442] The total size of the 1 globals exported for future expression (‘{; sum(a); }’) is 4.02 KiB.. This exceeds the maximum allowed size of 4.01 KiB (option 'future.globals.maxSize'). There is one global: ‘a’ (4.02 KiB of class ‘numeric’)
> 
> ## Undo options changed in this test
> options(ooptsT)
> 
> message("*** multisession() - too large globals ... DONE")
*** multisession() - too large globals ... DONE
> 
> message("*** multisession(..., workers = 1L) ...")
*** multisession(..., workers = 1L) ...
> 
> a <- 2
> b <- 3
> yTruth <- a * b
> 
> f <- multisession({ a * b }, globals = TRUE, workers = 1L)
[10:26:26.442] getGlobalsAndPackages() ...
[10:26:26.443] Searching for globals...
[10:26:26.443] - globals found: [4] ‘{’, ‘*’, ‘a’, ‘b’
[10:26:26.443] Searching for globals ... DONE
[10:26:26.444] Resolving globals: FALSE
[10:26:26.444] The total size of the 2 globals is 112 bytes (112 bytes)
[10:26:26.444] The total size of the 2 globals exported for future expression (‘{; a * b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘b’ (56 bytes of class ‘numeric’)
[10:26:26.444] - globals: [2] ‘a’, ‘b’
[10:26:26.445] 
[10:26:26.445] getGlobalsAndPackages() ... DONE
> rm(list = c("a", "b"))
> 
> v <- value(f)
[10:26:26.445] Packages needed by the future expression (n = 0): <none>
[10:26:26.445] Packages needed by future strategies (n = 0): <none>
[10:26:26.445] {
[10:26:26.445]     {
[10:26:26.445]         {
[10:26:26.445]             ...future.startTime <- base::Sys.time()
[10:26:26.445]             {
[10:26:26.445]                 {
[10:26:26.445]                   {
[10:26:26.445]                     base::local({
[10:26:26.445]                       has_future <- base::requireNamespace("future", 
[10:26:26.445]                         quietly = TRUE)
[10:26:26.445]                       if (has_future) {
[10:26:26.445]                         ns <- base::getNamespace("future")
[10:26:26.445]                         version <- ns[[".package"]][["version"]]
[10:26:26.445]                         if (is.null(version)) 
[10:26:26.445]                           version <- utils::packageVersion("future")
[10:26:26.445]                       }
[10:26:26.445]                       else {
[10:26:26.445]                         version <- NULL
[10:26:26.445]                       }
[10:26:26.445]                       if (!has_future || version < "1.8.0") {
[10:26:26.445]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:26.445]                           "", base::R.version$version.string), 
[10:26:26.445]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:26.445]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:26.445]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:26.445]                             "release", "version")], collapse = " "), 
[10:26:26.445]                           hostname = base::Sys.info()[["nodename"]])
[10:26:26.445]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:26.445]                           info)
[10:26:26.445]                         info <- base::paste(info, collapse = "; ")
[10:26:26.445]                         if (!has_future) {
[10:26:26.445]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:26.445]                             info)
[10:26:26.445]                         }
[10:26:26.445]                         else {
[10:26:26.445]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:26.445]                             info, version)
[10:26:26.445]                         }
[10:26:26.445]                         base::stop(msg)
[10:26:26.445]                       }
[10:26:26.445]                     })
[10:26:26.445]                   }
[10:26:26.445]                   options(future.plan = NULL)
[10:26:26.445]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:26.445]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:26.445]                 }
[10:26:26.445]                 ...future.workdir <- getwd()
[10:26:26.445]             }
[10:26:26.445]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:26.445]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:26.445]         }
[10:26:26.445]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:26.445]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:26.445]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:26.445]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:26.445]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:26.445]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:26.445]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:26.445]             base::names(...future.oldOptions))
[10:26:26.445]     }
[10:26:26.445]     if (FALSE) {
[10:26:26.445]     }
[10:26:26.445]     else {
[10:26:26.445]         if (TRUE) {
[10:26:26.445]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:26.445]                 open = "w")
[10:26:26.445]         }
[10:26:26.445]         else {
[10:26:26.445]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:26.445]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:26.445]         }
[10:26:26.445]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:26.445]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:26.445]             base::sink(type = "output", split = FALSE)
[10:26:26.445]             base::close(...future.stdout)
[10:26:26.445]         }, add = TRUE)
[10:26:26.445]     }
[10:26:26.445]     ...future.frame <- base::sys.nframe()
[10:26:26.445]     ...future.conditions <- base::list()
[10:26:26.445]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:26.445]     if (FALSE) {
[10:26:26.445]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:26.445]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:26.445]     }
[10:26:26.445]     ...future.result <- base::tryCatch({
[10:26:26.445]         base::withCallingHandlers({
[10:26:26.445]             ...future.value <- base::withVisible(base::local({
[10:26:26.445]                 a * b
[10:26:26.445]             }))
[10:26:26.445]             future::FutureResult(value = ...future.value$value, 
[10:26:26.445]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:26.445]                   ...future.rng), globalenv = if (FALSE) 
[10:26:26.445]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:26.445]                     ...future.globalenv.names))
[10:26:26.445]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:26.445]         }, condition = base::local({
[10:26:26.445]             c <- base::c
[10:26:26.445]             inherits <- base::inherits
[10:26:26.445]             invokeRestart <- base::invokeRestart
[10:26:26.445]             length <- base::length
[10:26:26.445]             list <- base::list
[10:26:26.445]             seq.int <- base::seq.int
[10:26:26.445]             signalCondition <- base::signalCondition
[10:26:26.445]             sys.calls <- base::sys.calls
[10:26:26.445]             `[[` <- base::`[[`
[10:26:26.445]             `+` <- base::`+`
[10:26:26.445]             `<<-` <- base::`<<-`
[10:26:26.445]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:26.445]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:26.445]                   3L)]
[10:26:26.445]             }
[10:26:26.445]             function(cond) {
[10:26:26.445]                 is_error <- inherits(cond, "error")
[10:26:26.445]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:26.445]                   NULL)
[10:26:26.445]                 if (is_error) {
[10:26:26.445]                   sessionInformation <- function() {
[10:26:26.445]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:26.445]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:26.445]                       search = base::search(), system = base::Sys.info())
[10:26:26.445]                   }
[10:26:26.445]                   ...future.conditions[[length(...future.conditions) + 
[10:26:26.445]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:26.445]                     cond$call), session = sessionInformation(), 
[10:26:26.445]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:26.445]                   signalCondition(cond)
[10:26:26.445]                 }
[10:26:26.445]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:26.445]                 "immediateCondition"))) {
[10:26:26.445]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:26.445]                   ...future.conditions[[length(...future.conditions) + 
[10:26:26.445]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:26.445]                   if (TRUE && !signal) {
[10:26:26.445]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:26.445]                     {
[10:26:26.445]                       inherits <- base::inherits
[10:26:26.445]                       invokeRestart <- base::invokeRestart
[10:26:26.445]                       is.null <- base::is.null
[10:26:26.445]                       muffled <- FALSE
[10:26:26.445]                       if (inherits(cond, "message")) {
[10:26:26.445]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:26.445]                         if (muffled) 
[10:26:26.445]                           invokeRestart("muffleMessage")
[10:26:26.445]                       }
[10:26:26.445]                       else if (inherits(cond, "warning")) {
[10:26:26.445]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:26.445]                         if (muffled) 
[10:26:26.445]                           invokeRestart("muffleWarning")
[10:26:26.445]                       }
[10:26:26.445]                       else if (inherits(cond, "condition")) {
[10:26:26.445]                         if (!is.null(pattern)) {
[10:26:26.445]                           computeRestarts <- base::computeRestarts
[10:26:26.445]                           grepl <- base::grepl
[10:26:26.445]                           restarts <- computeRestarts(cond)
[10:26:26.445]                           for (restart in restarts) {
[10:26:26.445]                             name <- restart$name
[10:26:26.445]                             if (is.null(name)) 
[10:26:26.445]                               next
[10:26:26.445]                             if (!grepl(pattern, name)) 
[10:26:26.445]                               next
[10:26:26.445]                             invokeRestart(restart)
[10:26:26.445]                             muffled <- TRUE
[10:26:26.445]                             break
[10:26:26.445]                           }
[10:26:26.445]                         }
[10:26:26.445]                       }
[10:26:26.445]                       invisible(muffled)
[10:26:26.445]                     }
[10:26:26.445]                     muffleCondition(cond, pattern = "^muffle")
[10:26:26.445]                   }
[10:26:26.445]                 }
[10:26:26.445]                 else {
[10:26:26.445]                   if (TRUE) {
[10:26:26.445]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:26.445]                     {
[10:26:26.445]                       inherits <- base::inherits
[10:26:26.445]                       invokeRestart <- base::invokeRestart
[10:26:26.445]                       is.null <- base::is.null
[10:26:26.445]                       muffled <- FALSE
[10:26:26.445]                       if (inherits(cond, "message")) {
[10:26:26.445]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:26.445]                         if (muffled) 
[10:26:26.445]                           invokeRestart("muffleMessage")
[10:26:26.445]                       }
[10:26:26.445]                       else if (inherits(cond, "warning")) {
[10:26:26.445]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:26.445]                         if (muffled) 
[10:26:26.445]                           invokeRestart("muffleWarning")
[10:26:26.445]                       }
[10:26:26.445]                       else if (inherits(cond, "condition")) {
[10:26:26.445]                         if (!is.null(pattern)) {
[10:26:26.445]                           computeRestarts <- base::computeRestarts
[10:26:26.445]                           grepl <- base::grepl
[10:26:26.445]                           restarts <- computeRestarts(cond)
[10:26:26.445]                           for (restart in restarts) {
[10:26:26.445]                             name <- restart$name
[10:26:26.445]                             if (is.null(name)) 
[10:26:26.445]                               next
[10:26:26.445]                             if (!grepl(pattern, name)) 
[10:26:26.445]                               next
[10:26:26.445]                             invokeRestart(restart)
[10:26:26.445]                             muffled <- TRUE
[10:26:26.445]                             break
[10:26:26.445]                           }
[10:26:26.445]                         }
[10:26:26.445]                       }
[10:26:26.445]                       invisible(muffled)
[10:26:26.445]                     }
[10:26:26.445]                     muffleCondition(cond, pattern = "^muffle")
[10:26:26.445]                   }
[10:26:26.445]                 }
[10:26:26.445]             }
[10:26:26.445]         }))
[10:26:26.445]     }, error = function(ex) {
[10:26:26.445]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:26.445]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:26.445]                 ...future.rng), started = ...future.startTime, 
[10:26:26.445]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:26.445]             version = "1.8"), class = "FutureResult")
[10:26:26.445]     }, finally = {
[10:26:26.445]         if (!identical(...future.workdir, getwd())) 
[10:26:26.445]             setwd(...future.workdir)
[10:26:26.445]         {
[10:26:26.445]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:26.445]                 ...future.oldOptions$nwarnings <- NULL
[10:26:26.445]             }
[10:26:26.445]             base::options(...future.oldOptions)
[10:26:26.445]             if (.Platform$OS.type == "windows") {
[10:26:26.445]                 old_names <- names(...future.oldEnvVars)
[10:26:26.445]                 envs <- base::Sys.getenv()
[10:26:26.445]                 names <- names(envs)
[10:26:26.445]                 common <- intersect(names, old_names)
[10:26:26.445]                 added <- setdiff(names, old_names)
[10:26:26.445]                 removed <- setdiff(old_names, names)
[10:26:26.445]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:26.445]                   envs[common]]
[10:26:26.445]                 NAMES <- toupper(changed)
[10:26:26.445]                 args <- list()
[10:26:26.445]                 for (kk in seq_along(NAMES)) {
[10:26:26.445]                   name <- changed[[kk]]
[10:26:26.445]                   NAME <- NAMES[[kk]]
[10:26:26.445]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:26.445]                     next
[10:26:26.445]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:26.445]                 }
[10:26:26.445]                 NAMES <- toupper(added)
[10:26:26.445]                 for (kk in seq_along(NAMES)) {
[10:26:26.445]                   name <- added[[kk]]
[10:26:26.445]                   NAME <- NAMES[[kk]]
[10:26:26.445]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:26.445]                     next
[10:26:26.445]                   args[[name]] <- ""
[10:26:26.445]                 }
[10:26:26.445]                 NAMES <- toupper(removed)
[10:26:26.445]                 for (kk in seq_along(NAMES)) {
[10:26:26.445]                   name <- removed[[kk]]
[10:26:26.445]                   NAME <- NAMES[[kk]]
[10:26:26.445]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:26.445]                     next
[10:26:26.445]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:26.445]                 }
[10:26:26.445]                 if (length(args) > 0) 
[10:26:26.445]                   base::do.call(base::Sys.setenv, args = args)
[10:26:26.445]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:26.445]             }
[10:26:26.445]             else {
[10:26:26.445]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:26.445]             }
[10:26:26.445]             {
[10:26:26.445]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:26.445]                   0L) {
[10:26:26.445]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:26.445]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:26.445]                   base::options(opts)
[10:26:26.445]                 }
[10:26:26.445]                 {
[10:26:26.445]                   {
[10:26:26.445]                     NULL
[10:26:26.445]                     RNGkind("Mersenne-Twister")
[10:26:26.445]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:26.445]                       inherits = FALSE)
[10:26:26.445]                   }
[10:26:26.445]                   options(future.plan = NULL)
[10:26:26.445]                   if (is.na(NA_character_)) 
[10:26:26.445]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:26.445]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:26.445]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:26.445]                   {
[10:26:26.445]                     future <- SequentialFuture(..., envir = envir)
[10:26:26.445]                     if (!future$lazy) 
[10:26:26.445]                       future <- run(future)
[10:26:26.445]                     invisible(future)
[10:26:26.445]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:26.445]                 }
[10:26:26.445]             }
[10:26:26.445]         }
[10:26:26.445]     })
[10:26:26.445]     if (TRUE) {
[10:26:26.445]         base::sink(type = "output", split = FALSE)
[10:26:26.445]         if (TRUE) {
[10:26:26.445]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:26.445]         }
[10:26:26.445]         else {
[10:26:26.445]             ...future.result["stdout"] <- base::list(NULL)
[10:26:26.445]         }
[10:26:26.445]         base::close(...future.stdout)
[10:26:26.445]         ...future.stdout <- NULL
[10:26:26.445]     }
[10:26:26.445]     ...future.result$conditions <- ...future.conditions
[10:26:26.445]     ...future.result$finished <- base::Sys.time()
[10:26:26.445]     ...future.result
[10:26:26.445] }
[10:26:26.447] assign_globals() ...
[10:26:26.447] List of 2
[10:26:26.447]  $ a: num 2
[10:26:26.447]  $ b: num 3
[10:26:26.447]  - attr(*, "where")=List of 2
[10:26:26.447]   ..$ a:<environment: R_EmptyEnv> 
[10:26:26.447]   ..$ b:<environment: R_EmptyEnv> 
[10:26:26.447]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:26.447]  - attr(*, "resolved")= logi FALSE
[10:26:26.447]  - attr(*, "total_size")= num 112
[10:26:26.452] - copied ‘a’ to environment
[10:26:26.452] - copied ‘b’ to environment
[10:26:26.452] assign_globals() ... done
[10:26:26.452] plan(): Setting new future strategy stack:
[10:26:26.452] List of future strategies:
[10:26:26.452] 1. sequential:
[10:26:26.452]    - args: function (..., envir = parent.frame())
[10:26:26.452]    - tweaked: FALSE
[10:26:26.452]    - call: NULL
[10:26:26.452] plan(): nbrOfWorkers() = 1
[10:26:26.453] plan(): Setting new future strategy stack:
[10:26:26.453] List of future strategies:
[10:26:26.453] 1. sequential:
[10:26:26.453]    - args: function (..., envir = parent.frame())
[10:26:26.453]    - tweaked: FALSE
[10:26:26.453]    - call: future::plan("sequential")
[10:26:26.454] plan(): nbrOfWorkers() = 1
[10:26:26.454] SequentialFuture started (and completed)
> print(v)
[1] 6
> stopifnot(v == yTruth)
> 
> message("*** multisession(..., workers = 1L) ... DONE")
*** multisession(..., workers = 1L) ... DONE
> 
> message("*** multisession(..., gc = TRUE) ...")
*** multisession(..., gc = TRUE) ...
> plan(multisession, workers = 2L)
[10:26:26.455] plan(): Setting new future strategy stack:
[10:26:26.455] List of future strategies:
[10:26:26.455] 1. multisession:
[10:26:26.455]    - args: function (..., workers = 2L, envir = parent.frame())
[10:26:26.455]    - tweaked: TRUE
[10:26:26.455]    - call: plan(multisession, workers = 2L)
[10:26:26.469] plan(): plan_init() of ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:26:26.470] multisession:
[10:26:26.470] - args: function (..., workers = 2L, envir = parent.frame())
[10:26:26.470] - tweaked: TRUE
[10:26:26.470] - call: plan(multisession, workers = 2L)
[10:26:26.470] getGlobalsAndPackages() ...
[10:26:26.470] Not searching for globals
[10:26:26.471] - globals: [0] <none>
[10:26:26.471] getGlobalsAndPackages() ... DONE
[10:26:26.471] [local output] makeClusterPSOCK() ...
[10:26:26.474] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:26:26.475] [local output] Base port: 11252
[10:26:26.475] [local output] Getting setup options for 2 cluster nodes ...
[10:26:26.475] [local output]  - Node 1 of 2 ...
[10:26:26.475] [local output] localMachine=TRUE => revtunnel=FALSE

[10:26:26.476] [local output] Rscript port: 11252

[10:26:26.476] [local output]  - Node 2 of 2 ...
[10:26:26.477] [local output] localMachine=TRUE => revtunnel=FALSE

[10:26:26.477] [local output] Rscript port: 11252

[10:26:26.477] [local output] Getting setup options for 2 cluster nodes ... done
[10:26:26.477] [local output]  - Parallel setup requested for some PSOCK nodes
[10:26:26.478] [local output] Setting up PSOCK nodes in parallel
[10:26:26.478] List of 36
[10:26:26.478]  $ worker          : chr "localhost"
[10:26:26.478]   ..- attr(*, "localhost")= logi TRUE
[10:26:26.478]  $ master          : chr "localhost"
[10:26:26.478]  $ port            : int 11252
[10:26:26.478]  $ connectTimeout  : num 120
[10:26:26.478]  $ timeout         : num 2592000
[10:26:26.478]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:26:26.478]  $ homogeneous     : logi TRUE
[10:26:26.478]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:26:26.478]  $ rscript_envs    : NULL
[10:26:26.478]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:26:26.478]  $ rscript_startup : NULL
[10:26:26.478]  $ rscript_sh      : chr "sh"
[10:26:26.478]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:26:26.478]  $ methods         : logi TRUE
[10:26:26.478]  $ socketOptions   : chr "no-delay"
[10:26:26.478]  $ useXDR          : logi FALSE
[10:26:26.478]  $ outfile         : chr "/dev/null"
[10:26:26.478]  $ renice          : int NA
[10:26:26.478]  $ rshcmd          : NULL
[10:26:26.478]  $ user            : chr(0) 
[10:26:26.478]  $ revtunnel       : logi FALSE
[10:26:26.478]  $ rshlogfile      : NULL
[10:26:26.478]  $ rshopts         : chr(0) 
[10:26:26.478]  $ rank            : int 1
[10:26:26.478]  $ manual          : logi FALSE
[10:26:26.478]  $ dryrun          : logi FALSE
[10:26:26.478]  $ quiet           : logi FALSE
[10:26:26.478]  $ setup_strategy  : chr "parallel"
[10:26:26.478]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:26:26.478]  $ pidfile         : chr "/tmp/RtmpLA4GNs/worker.rank=1.parallelly.parent=87451.1559b44057010.pid"
[10:26:26.478]  $ rshcmd_label    : NULL
[10:26:26.478]  $ rsh_call        : NULL
[10:26:26.478]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:26:26.478]  $ localMachine    : logi TRUE
[10:26:26.478]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:26:26.478]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:26:26.478]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:26:26.478]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:26:26.478]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:26:26.478]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:26:26.478]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:26:26.478]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:26:26.478]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:26:26.478]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:26:26.478]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:26:26.478]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:26:26.478]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:26:26.478]  $ arguments       :List of 28
[10:26:26.478]   ..$ worker          : chr "localhost"
[10:26:26.478]   ..$ master          : NULL
[10:26:26.478]   ..$ port            : int 11252
[10:26:26.478]   ..$ connectTimeout  : num 120
[10:26:26.478]   ..$ timeout         : num 2592000
[10:26:26.478]   ..$ rscript         : NULL
[10:26:26.478]   ..$ homogeneous     : NULL
[10:26:26.478]   ..$ rscript_args    : NULL
[10:26:26.478]   ..$ rscript_envs    : NULL
[10:26:26.478]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:26:26.478]   ..$ rscript_startup : NULL
[10:26:26.478]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:26:26.478]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:26:26.478]   ..$ methods         : logi TRUE
[10:26:26.478]   ..$ socketOptions   : chr "no-delay"
[10:26:26.478]   ..$ useXDR          : logi FALSE
[10:26:26.478]   ..$ outfile         : chr "/dev/null"
[10:26:26.478]   ..$ renice          : int NA
[10:26:26.478]   ..$ rshcmd          : NULL
[10:26:26.478]   ..$ user            : NULL
[10:26:26.478]   ..$ revtunnel       : logi NA
[10:26:26.478]   ..$ rshlogfile      : NULL
[10:26:26.478]   ..$ rshopts         : NULL
[10:26:26.478]   ..$ rank            : int 1
[10:26:26.478]   ..$ manual          : logi FALSE
[10:26:26.478]   ..$ dryrun          : logi FALSE
[10:26:26.478]   ..$ quiet           : logi FALSE
[10:26:26.478]   ..$ setup_strategy  : chr "parallel"
[10:26:26.478]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:26:26.495] [local output] System call to launch all workers:
[10:26:26.495] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpLA4GNs/worker.rank=1.parallelly.parent=87451.1559b44057010.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11252 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:26:26.495] [local output] Starting PSOCK main server
[10:26:26.496] [local output] Workers launched
[10:26:26.496] [local output] Waiting for workers to connect back
[10:26:26.497]  - [local output] 0 workers out of 2 ready
[10:26:26.716]  - [local output] 0 workers out of 2 ready
[10:26:26.717]  - [local output] 1 workers out of 2 ready
[10:26:26.747]  - [local output] 1 workers out of 2 ready
[10:26:26.747]  - [local output] 2 workers out of 2 ready
[10:26:26.747] [local output] Launching of workers completed
[10:26:26.747] [local output] Collecting session information from workers
[10:26:26.748] [local output]  - Worker #1 of 2
[10:26:26.749] [local output]  - Worker #2 of 2
[10:26:26.749] [local output] makeClusterPSOCK() ... done
[10:26:26.759] Packages needed by the future expression (n = 0): <none>
[10:26:26.759] Packages needed by future strategies (n = 0): <none>
[10:26:26.760] {
[10:26:26.760]     {
[10:26:26.760]         {
[10:26:26.760]             ...future.startTime <- base::Sys.time()
[10:26:26.760]             {
[10:26:26.760]                 {
[10:26:26.760]                   {
[10:26:26.760]                     {
[10:26:26.760]                       base::local({
[10:26:26.760]                         has_future <- base::requireNamespace("future", 
[10:26:26.760]                           quietly = TRUE)
[10:26:26.760]                         if (has_future) {
[10:26:26.760]                           ns <- base::getNamespace("future")
[10:26:26.760]                           version <- ns[[".package"]][["version"]]
[10:26:26.760]                           if (is.null(version)) 
[10:26:26.760]                             version <- utils::packageVersion("future")
[10:26:26.760]                         }
[10:26:26.760]                         else {
[10:26:26.760]                           version <- NULL
[10:26:26.760]                         }
[10:26:26.760]                         if (!has_future || version < "1.8.0") {
[10:26:26.760]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:26.760]                             "", base::R.version$version.string), 
[10:26:26.760]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:26.760]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:26.760]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:26.760]                               "release", "version")], collapse = " "), 
[10:26:26.760]                             hostname = base::Sys.info()[["nodename"]])
[10:26:26.760]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:26.760]                             info)
[10:26:26.760]                           info <- base::paste(info, collapse = "; ")
[10:26:26.760]                           if (!has_future) {
[10:26:26.760]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:26.760]                               info)
[10:26:26.760]                           }
[10:26:26.760]                           else {
[10:26:26.760]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:26.760]                               info, version)
[10:26:26.760]                           }
[10:26:26.760]                           base::stop(msg)
[10:26:26.760]                         }
[10:26:26.760]                       })
[10:26:26.760]                     }
[10:26:26.760]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:26.760]                     base::options(mc.cores = 1L)
[10:26:26.760]                   }
[10:26:26.760]                   options(future.plan = NULL)
[10:26:26.760]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:26.760]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:26.760]                 }
[10:26:26.760]                 ...future.workdir <- getwd()
[10:26:26.760]             }
[10:26:26.760]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:26.760]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:26.760]         }
[10:26:26.760]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:26.760]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:26.760]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:26.760]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:26.760]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:26.760]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:26.760]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:26.760]             base::names(...future.oldOptions))
[10:26:26.760]     }
[10:26:26.760]     if (FALSE) {
[10:26:26.760]     }
[10:26:26.760]     else {
[10:26:26.760]         if (TRUE) {
[10:26:26.760]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:26.760]                 open = "w")
[10:26:26.760]         }
[10:26:26.760]         else {
[10:26:26.760]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:26.760]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:26.760]         }
[10:26:26.760]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:26.760]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:26.760]             base::sink(type = "output", split = FALSE)
[10:26:26.760]             base::close(...future.stdout)
[10:26:26.760]         }, add = TRUE)
[10:26:26.760]     }
[10:26:26.760]     ...future.frame <- base::sys.nframe()
[10:26:26.760]     ...future.conditions <- base::list()
[10:26:26.760]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:26.760]     if (FALSE) {
[10:26:26.760]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:26.760]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:26.760]     }
[10:26:26.760]     ...future.result <- base::tryCatch({
[10:26:26.760]         base::withCallingHandlers({
[10:26:26.760]             ...future.value <- base::withVisible(base::local({
[10:26:26.760]                 ...future.makeSendCondition <- base::local({
[10:26:26.760]                   sendCondition <- NULL
[10:26:26.760]                   function(frame = 1L) {
[10:26:26.760]                     if (is.function(sendCondition)) 
[10:26:26.760]                       return(sendCondition)
[10:26:26.760]                     ns <- getNamespace("parallel")
[10:26:26.760]                     if (exists("sendData", mode = "function", 
[10:26:26.760]                       envir = ns)) {
[10:26:26.760]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:26.760]                         envir = ns)
[10:26:26.760]                       envir <- sys.frame(frame)
[10:26:26.760]                       master <- NULL
[10:26:26.760]                       while (!identical(envir, .GlobalEnv) && 
[10:26:26.760]                         !identical(envir, emptyenv())) {
[10:26:26.760]                         if (exists("master", mode = "list", envir = envir, 
[10:26:26.760]                           inherits = FALSE)) {
[10:26:26.760]                           master <- get("master", mode = "list", 
[10:26:26.760]                             envir = envir, inherits = FALSE)
[10:26:26.760]                           if (inherits(master, c("SOCKnode", 
[10:26:26.760]                             "SOCK0node"))) {
[10:26:26.760]                             sendCondition <<- function(cond) {
[10:26:26.760]                               data <- list(type = "VALUE", value = cond, 
[10:26:26.760]                                 success = TRUE)
[10:26:26.760]                               parallel_sendData(master, data)
[10:26:26.760]                             }
[10:26:26.760]                             return(sendCondition)
[10:26:26.760]                           }
[10:26:26.760]                         }
[10:26:26.760]                         frame <- frame + 1L
[10:26:26.760]                         envir <- sys.frame(frame)
[10:26:26.760]                       }
[10:26:26.760]                     }
[10:26:26.760]                     sendCondition <<- function(cond) NULL
[10:26:26.760]                   }
[10:26:26.760]                 })
[10:26:26.760]                 withCallingHandlers({
[10:26:26.760]                   NA
[10:26:26.760]                 }, immediateCondition = function(cond) {
[10:26:26.760]                   sendCondition <- ...future.makeSendCondition()
[10:26:26.760]                   sendCondition(cond)
[10:26:26.760]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:26.760]                   {
[10:26:26.760]                     inherits <- base::inherits
[10:26:26.760]                     invokeRestart <- base::invokeRestart
[10:26:26.760]                     is.null <- base::is.null
[10:26:26.760]                     muffled <- FALSE
[10:26:26.760]                     if (inherits(cond, "message")) {
[10:26:26.760]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:26.760]                       if (muffled) 
[10:26:26.760]                         invokeRestart("muffleMessage")
[10:26:26.760]                     }
[10:26:26.760]                     else if (inherits(cond, "warning")) {
[10:26:26.760]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:26.760]                       if (muffled) 
[10:26:26.760]                         invokeRestart("muffleWarning")
[10:26:26.760]                     }
[10:26:26.760]                     else if (inherits(cond, "condition")) {
[10:26:26.760]                       if (!is.null(pattern)) {
[10:26:26.760]                         computeRestarts <- base::computeRestarts
[10:26:26.760]                         grepl <- base::grepl
[10:26:26.760]                         restarts <- computeRestarts(cond)
[10:26:26.760]                         for (restart in restarts) {
[10:26:26.760]                           name <- restart$name
[10:26:26.760]                           if (is.null(name)) 
[10:26:26.760]                             next
[10:26:26.760]                           if (!grepl(pattern, name)) 
[10:26:26.760]                             next
[10:26:26.760]                           invokeRestart(restart)
[10:26:26.760]                           muffled <- TRUE
[10:26:26.760]                           break
[10:26:26.760]                         }
[10:26:26.760]                       }
[10:26:26.760]                     }
[10:26:26.760]                     invisible(muffled)
[10:26:26.760]                   }
[10:26:26.760]                   muffleCondition(cond)
[10:26:26.760]                 })
[10:26:26.760]             }))
[10:26:26.760]             future::FutureResult(value = ...future.value$value, 
[10:26:26.760]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:26.760]                   ...future.rng), globalenv = if (FALSE) 
[10:26:26.760]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:26.760]                     ...future.globalenv.names))
[10:26:26.760]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:26.760]         }, condition = base::local({
[10:26:26.760]             c <- base::c
[10:26:26.760]             inherits <- base::inherits
[10:26:26.760]             invokeRestart <- base::invokeRestart
[10:26:26.760]             length <- base::length
[10:26:26.760]             list <- base::list
[10:26:26.760]             seq.int <- base::seq.int
[10:26:26.760]             signalCondition <- base::signalCondition
[10:26:26.760]             sys.calls <- base::sys.calls
[10:26:26.760]             `[[` <- base::`[[`
[10:26:26.760]             `+` <- base::`+`
[10:26:26.760]             `<<-` <- base::`<<-`
[10:26:26.760]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:26.760]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:26.760]                   3L)]
[10:26:26.760]             }
[10:26:26.760]             function(cond) {
[10:26:26.760]                 is_error <- inherits(cond, "error")
[10:26:26.760]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:26.760]                   NULL)
[10:26:26.760]                 if (is_error) {
[10:26:26.760]                   sessionInformation <- function() {
[10:26:26.760]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:26.760]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:26.760]                       search = base::search(), system = base::Sys.info())
[10:26:26.760]                   }
[10:26:26.760]                   ...future.conditions[[length(...future.conditions) + 
[10:26:26.760]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:26.760]                     cond$call), session = sessionInformation(), 
[10:26:26.760]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:26.760]                   signalCondition(cond)
[10:26:26.760]                 }
[10:26:26.760]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:26.760]                 "immediateCondition"))) {
[10:26:26.760]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:26.760]                   ...future.conditions[[length(...future.conditions) + 
[10:26:26.760]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:26.760]                   if (TRUE && !signal) {
[10:26:26.760]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:26.760]                     {
[10:26:26.760]                       inherits <- base::inherits
[10:26:26.760]                       invokeRestart <- base::invokeRestart
[10:26:26.760]                       is.null <- base::is.null
[10:26:26.760]                       muffled <- FALSE
[10:26:26.760]                       if (inherits(cond, "message")) {
[10:26:26.760]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:26.760]                         if (muffled) 
[10:26:26.760]                           invokeRestart("muffleMessage")
[10:26:26.760]                       }
[10:26:26.760]                       else if (inherits(cond, "warning")) {
[10:26:26.760]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:26.760]                         if (muffled) 
[10:26:26.760]                           invokeRestart("muffleWarning")
[10:26:26.760]                       }
[10:26:26.760]                       else if (inherits(cond, "condition")) {
[10:26:26.760]                         if (!is.null(pattern)) {
[10:26:26.760]                           computeRestarts <- base::computeRestarts
[10:26:26.760]                           grepl <- base::grepl
[10:26:26.760]                           restarts <- computeRestarts(cond)
[10:26:26.760]                           for (restart in restarts) {
[10:26:26.760]                             name <- restart$name
[10:26:26.760]                             if (is.null(name)) 
[10:26:26.760]                               next
[10:26:26.760]                             if (!grepl(pattern, name)) 
[10:26:26.760]                               next
[10:26:26.760]                             invokeRestart(restart)
[10:26:26.760]                             muffled <- TRUE
[10:26:26.760]                             break
[10:26:26.760]                           }
[10:26:26.760]                         }
[10:26:26.760]                       }
[10:26:26.760]                       invisible(muffled)
[10:26:26.760]                     }
[10:26:26.760]                     muffleCondition(cond, pattern = "^muffle")
[10:26:26.760]                   }
[10:26:26.760]                 }
[10:26:26.760]                 else {
[10:26:26.760]                   if (TRUE) {
[10:26:26.760]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:26.760]                     {
[10:26:26.760]                       inherits <- base::inherits
[10:26:26.760]                       invokeRestart <- base::invokeRestart
[10:26:26.760]                       is.null <- base::is.null
[10:26:26.760]                       muffled <- FALSE
[10:26:26.760]                       if (inherits(cond, "message")) {
[10:26:26.760]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:26.760]                         if (muffled) 
[10:26:26.760]                           invokeRestart("muffleMessage")
[10:26:26.760]                       }
[10:26:26.760]                       else if (inherits(cond, "warning")) {
[10:26:26.760]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:26.760]                         if (muffled) 
[10:26:26.760]                           invokeRestart("muffleWarning")
[10:26:26.760]                       }
[10:26:26.760]                       else if (inherits(cond, "condition")) {
[10:26:26.760]                         if (!is.null(pattern)) {
[10:26:26.760]                           computeRestarts <- base::computeRestarts
[10:26:26.760]                           grepl <- base::grepl
[10:26:26.760]                           restarts <- computeRestarts(cond)
[10:26:26.760]                           for (restart in restarts) {
[10:26:26.760]                             name <- restart$name
[10:26:26.760]                             if (is.null(name)) 
[10:26:26.760]                               next
[10:26:26.760]                             if (!grepl(pattern, name)) 
[10:26:26.760]                               next
[10:26:26.760]                             invokeRestart(restart)
[10:26:26.760]                             muffled <- TRUE
[10:26:26.760]                             break
[10:26:26.760]                           }
[10:26:26.760]                         }
[10:26:26.760]                       }
[10:26:26.760]                       invisible(muffled)
[10:26:26.760]                     }
[10:26:26.760]                     muffleCondition(cond, pattern = "^muffle")
[10:26:26.760]                   }
[10:26:26.760]                 }
[10:26:26.760]             }
[10:26:26.760]         }))
[10:26:26.760]     }, error = function(ex) {
[10:26:26.760]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:26.760]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:26.760]                 ...future.rng), started = ...future.startTime, 
[10:26:26.760]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:26.760]             version = "1.8"), class = "FutureResult")
[10:26:26.760]     }, finally = {
[10:26:26.760]         if (!identical(...future.workdir, getwd())) 
[10:26:26.760]             setwd(...future.workdir)
[10:26:26.760]         {
[10:26:26.760]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:26.760]                 ...future.oldOptions$nwarnings <- NULL
[10:26:26.760]             }
[10:26:26.760]             base::options(...future.oldOptions)
[10:26:26.760]             if (.Platform$OS.type == "windows") {
[10:26:26.760]                 old_names <- names(...future.oldEnvVars)
[10:26:26.760]                 envs <- base::Sys.getenv()
[10:26:26.760]                 names <- names(envs)
[10:26:26.760]                 common <- intersect(names, old_names)
[10:26:26.760]                 added <- setdiff(names, old_names)
[10:26:26.760]                 removed <- setdiff(old_names, names)
[10:26:26.760]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:26.760]                   envs[common]]
[10:26:26.760]                 NAMES <- toupper(changed)
[10:26:26.760]                 args <- list()
[10:26:26.760]                 for (kk in seq_along(NAMES)) {
[10:26:26.760]                   name <- changed[[kk]]
[10:26:26.760]                   NAME <- NAMES[[kk]]
[10:26:26.760]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:26.760]                     next
[10:26:26.760]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:26.760]                 }
[10:26:26.760]                 NAMES <- toupper(added)
[10:26:26.760]                 for (kk in seq_along(NAMES)) {
[10:26:26.760]                   name <- added[[kk]]
[10:26:26.760]                   NAME <- NAMES[[kk]]
[10:26:26.760]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:26.760]                     next
[10:26:26.760]                   args[[name]] <- ""
[10:26:26.760]                 }
[10:26:26.760]                 NAMES <- toupper(removed)
[10:26:26.760]                 for (kk in seq_along(NAMES)) {
[10:26:26.760]                   name <- removed[[kk]]
[10:26:26.760]                   NAME <- NAMES[[kk]]
[10:26:26.760]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:26.760]                     next
[10:26:26.760]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:26.760]                 }
[10:26:26.760]                 if (length(args) > 0) 
[10:26:26.760]                   base::do.call(base::Sys.setenv, args = args)
[10:26:26.760]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:26.760]             }
[10:26:26.760]             else {
[10:26:26.760]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:26.760]             }
[10:26:26.760]             {
[10:26:26.760]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:26.760]                   0L) {
[10:26:26.760]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:26.760]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:26.760]                   base::options(opts)
[10:26:26.760]                 }
[10:26:26.760]                 {
[10:26:26.760]                   {
[10:26:26.760]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:26.760]                     NULL
[10:26:26.760]                   }
[10:26:26.760]                   options(future.plan = NULL)
[10:26:26.760]                   if (is.na(NA_character_)) 
[10:26:26.760]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:26.760]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:26.760]                   future::plan(list(function (..., workers = 2L, 
[10:26:26.760]                     envir = parent.frame()) 
[10:26:26.760]                   strategy(..., workers = workers, envir = envir)), 
[10:26:26.760]                     .cleanup = FALSE, .init = FALSE)
[10:26:26.760]                 }
[10:26:26.760]             }
[10:26:26.760]         }
[10:26:26.760]     })
[10:26:26.760]     if (TRUE) {
[10:26:26.760]         base::sink(type = "output", split = FALSE)
[10:26:26.760]         if (TRUE) {
[10:26:26.760]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:26.760]         }
[10:26:26.760]         else {
[10:26:26.760]             ...future.result["stdout"] <- base::list(NULL)
[10:26:26.760]         }
[10:26:26.760]         base::close(...future.stdout)
[10:26:26.760]         ...future.stdout <- NULL
[10:26:26.760]     }
[10:26:26.760]     ...future.result$conditions <- ...future.conditions
[10:26:26.760]     ...future.result$finished <- base::Sys.time()
[10:26:26.760]     ...future.result
[10:26:26.760] }
[10:26:26.815] MultisessionFuture started
[10:26:26.815] result() for ClusterFuture ...
[10:26:26.816] receiveMessageFromWorker() for ClusterFuture ...
[10:26:26.816] - Validating connection of MultisessionFuture
[10:26:26.849] - received message: FutureResult
[10:26:26.849] - Received FutureResult
[10:26:26.849] - Erased future from FutureRegistry
[10:26:26.849] result() for ClusterFuture ...
[10:26:26.849] - result already collected: FutureResult
[10:26:26.849] result() for ClusterFuture ... done
[10:26:26.850] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:26.850] result() for ClusterFuture ... done
[10:26:26.850] result() for ClusterFuture ...
[10:26:26.850] - result already collected: FutureResult
[10:26:26.850] result() for ClusterFuture ... done
[10:26:26.850] plan(): plan_init() of ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:26:26.850] plan(): nbrOfWorkers() = 2
> 
> f <- future({ gc() })
[10:26:26.850] getGlobalsAndPackages() ...
[10:26:26.851] Searching for globals...
[10:26:26.851] - globals found: [2] ‘{’, ‘gc’
[10:26:26.852] Searching for globals ... DONE
[10:26:26.852] Resolving globals: FALSE
[10:26:26.852] 
[10:26:26.852] 
[10:26:26.852] getGlobalsAndPackages() ... DONE
[10:26:26.852] run() for ‘Future’ ...
[10:26:26.852] - state: ‘created’
[10:26:26.853] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:26.863] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:26.863] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:26.863]   - Field: ‘node’
[10:26:26.863]   - Field: ‘label’
[10:26:26.863]   - Field: ‘local’
[10:26:26.863]   - Field: ‘owner’
[10:26:26.864]   - Field: ‘envir’
[10:26:26.864]   - Field: ‘workers’
[10:26:26.864]   - Field: ‘packages’
[10:26:26.864]   - Field: ‘gc’
[10:26:26.864]   - Field: ‘conditions’
[10:26:26.864]   - Field: ‘persistent’
[10:26:26.864]   - Field: ‘expr’
[10:26:26.864]   - Field: ‘uuid’
[10:26:26.864]   - Field: ‘seed’
[10:26:26.864]   - Field: ‘version’
[10:26:26.865]   - Field: ‘result’
[10:26:26.865]   - Field: ‘asynchronous’
[10:26:26.865]   - Field: ‘calls’
[10:26:26.865]   - Field: ‘globals’
[10:26:26.865]   - Field: ‘stdout’
[10:26:26.865]   - Field: ‘earlySignal’
[10:26:26.865]   - Field: ‘lazy’
[10:26:26.865]   - Field: ‘state’
[10:26:26.865] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:26.865] - Launch lazy future ...
[10:26:26.866] Packages needed by the future expression (n = 0): <none>
[10:26:26.866] Packages needed by future strategies (n = 0): <none>
[10:26:26.866] {
[10:26:26.866]     {
[10:26:26.866]         {
[10:26:26.866]             ...future.startTime <- base::Sys.time()
[10:26:26.866]             {
[10:26:26.866]                 {
[10:26:26.866]                   {
[10:26:26.866]                     {
[10:26:26.866]                       base::local({
[10:26:26.866]                         has_future <- base::requireNamespace("future", 
[10:26:26.866]                           quietly = TRUE)
[10:26:26.866]                         if (has_future) {
[10:26:26.866]                           ns <- base::getNamespace("future")
[10:26:26.866]                           version <- ns[[".package"]][["version"]]
[10:26:26.866]                           if (is.null(version)) 
[10:26:26.866]                             version <- utils::packageVersion("future")
[10:26:26.866]                         }
[10:26:26.866]                         else {
[10:26:26.866]                           version <- NULL
[10:26:26.866]                         }
[10:26:26.866]                         if (!has_future || version < "1.8.0") {
[10:26:26.866]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:26.866]                             "", base::R.version$version.string), 
[10:26:26.866]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:26.866]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:26.866]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:26.866]                               "release", "version")], collapse = " "), 
[10:26:26.866]                             hostname = base::Sys.info()[["nodename"]])
[10:26:26.866]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:26.866]                             info)
[10:26:26.866]                           info <- base::paste(info, collapse = "; ")
[10:26:26.866]                           if (!has_future) {
[10:26:26.866]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:26.866]                               info)
[10:26:26.866]                           }
[10:26:26.866]                           else {
[10:26:26.866]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:26.866]                               info, version)
[10:26:26.866]                           }
[10:26:26.866]                           base::stop(msg)
[10:26:26.866]                         }
[10:26:26.866]                       })
[10:26:26.866]                     }
[10:26:26.866]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:26.866]                     base::options(mc.cores = 1L)
[10:26:26.866]                   }
[10:26:26.866]                   options(future.plan = NULL)
[10:26:26.866]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:26.866]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:26.866]                 }
[10:26:26.866]                 ...future.workdir <- getwd()
[10:26:26.866]             }
[10:26:26.866]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:26.866]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:26.866]         }
[10:26:26.866]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:26.866]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:26.866]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:26.866]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:26.866]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:26.866]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:26.866]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:26.866]             base::names(...future.oldOptions))
[10:26:26.866]     }
[10:26:26.866]     if (FALSE) {
[10:26:26.866]     }
[10:26:26.866]     else {
[10:26:26.866]         if (TRUE) {
[10:26:26.866]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:26.866]                 open = "w")
[10:26:26.866]         }
[10:26:26.866]         else {
[10:26:26.866]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:26.866]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:26.866]         }
[10:26:26.866]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:26.866]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:26.866]             base::sink(type = "output", split = FALSE)
[10:26:26.866]             base::close(...future.stdout)
[10:26:26.866]         }, add = TRUE)
[10:26:26.866]     }
[10:26:26.866]     ...future.frame <- base::sys.nframe()
[10:26:26.866]     ...future.conditions <- base::list()
[10:26:26.866]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:26.866]     if (FALSE) {
[10:26:26.866]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:26.866]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:26.866]     }
[10:26:26.866]     ...future.result <- base::tryCatch({
[10:26:26.866]         base::withCallingHandlers({
[10:26:26.866]             ...future.value <- base::withVisible(base::local({
[10:26:26.866]                 ...future.makeSendCondition <- base::local({
[10:26:26.866]                   sendCondition <- NULL
[10:26:26.866]                   function(frame = 1L) {
[10:26:26.866]                     if (is.function(sendCondition)) 
[10:26:26.866]                       return(sendCondition)
[10:26:26.866]                     ns <- getNamespace("parallel")
[10:26:26.866]                     if (exists("sendData", mode = "function", 
[10:26:26.866]                       envir = ns)) {
[10:26:26.866]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:26.866]                         envir = ns)
[10:26:26.866]                       envir <- sys.frame(frame)
[10:26:26.866]                       master <- NULL
[10:26:26.866]                       while (!identical(envir, .GlobalEnv) && 
[10:26:26.866]                         !identical(envir, emptyenv())) {
[10:26:26.866]                         if (exists("master", mode = "list", envir = envir, 
[10:26:26.866]                           inherits = FALSE)) {
[10:26:26.866]                           master <- get("master", mode = "list", 
[10:26:26.866]                             envir = envir, inherits = FALSE)
[10:26:26.866]                           if (inherits(master, c("SOCKnode", 
[10:26:26.866]                             "SOCK0node"))) {
[10:26:26.866]                             sendCondition <<- function(cond) {
[10:26:26.866]                               data <- list(type = "VALUE", value = cond, 
[10:26:26.866]                                 success = TRUE)
[10:26:26.866]                               parallel_sendData(master, data)
[10:26:26.866]                             }
[10:26:26.866]                             return(sendCondition)
[10:26:26.866]                           }
[10:26:26.866]                         }
[10:26:26.866]                         frame <- frame + 1L
[10:26:26.866]                         envir <- sys.frame(frame)
[10:26:26.866]                       }
[10:26:26.866]                     }
[10:26:26.866]                     sendCondition <<- function(cond) NULL
[10:26:26.866]                   }
[10:26:26.866]                 })
[10:26:26.866]                 withCallingHandlers({
[10:26:26.866]                   {
[10:26:26.866]                     gc()
[10:26:26.866]                   }
[10:26:26.866]                 }, immediateCondition = function(cond) {
[10:26:26.866]                   sendCondition <- ...future.makeSendCondition()
[10:26:26.866]                   sendCondition(cond)
[10:26:26.866]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:26.866]                   {
[10:26:26.866]                     inherits <- base::inherits
[10:26:26.866]                     invokeRestart <- base::invokeRestart
[10:26:26.866]                     is.null <- base::is.null
[10:26:26.866]                     muffled <- FALSE
[10:26:26.866]                     if (inherits(cond, "message")) {
[10:26:26.866]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:26.866]                       if (muffled) 
[10:26:26.866]                         invokeRestart("muffleMessage")
[10:26:26.866]                     }
[10:26:26.866]                     else if (inherits(cond, "warning")) {
[10:26:26.866]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:26.866]                       if (muffled) 
[10:26:26.866]                         invokeRestart("muffleWarning")
[10:26:26.866]                     }
[10:26:26.866]                     else if (inherits(cond, "condition")) {
[10:26:26.866]                       if (!is.null(pattern)) {
[10:26:26.866]                         computeRestarts <- base::computeRestarts
[10:26:26.866]                         grepl <- base::grepl
[10:26:26.866]                         restarts <- computeRestarts(cond)
[10:26:26.866]                         for (restart in restarts) {
[10:26:26.866]                           name <- restart$name
[10:26:26.866]                           if (is.null(name)) 
[10:26:26.866]                             next
[10:26:26.866]                           if (!grepl(pattern, name)) 
[10:26:26.866]                             next
[10:26:26.866]                           invokeRestart(restart)
[10:26:26.866]                           muffled <- TRUE
[10:26:26.866]                           break
[10:26:26.866]                         }
[10:26:26.866]                       }
[10:26:26.866]                     }
[10:26:26.866]                     invisible(muffled)
[10:26:26.866]                   }
[10:26:26.866]                   muffleCondition(cond)
[10:26:26.866]                 })
[10:26:26.866]             }))
[10:26:26.866]             future::FutureResult(value = ...future.value$value, 
[10:26:26.866]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:26.866]                   ...future.rng), globalenv = if (FALSE) 
[10:26:26.866]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:26.866]                     ...future.globalenv.names))
[10:26:26.866]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:26.866]         }, condition = base::local({
[10:26:26.866]             c <- base::c
[10:26:26.866]             inherits <- base::inherits
[10:26:26.866]             invokeRestart <- base::invokeRestart
[10:26:26.866]             length <- base::length
[10:26:26.866]             list <- base::list
[10:26:26.866]             seq.int <- base::seq.int
[10:26:26.866]             signalCondition <- base::signalCondition
[10:26:26.866]             sys.calls <- base::sys.calls
[10:26:26.866]             `[[` <- base::`[[`
[10:26:26.866]             `+` <- base::`+`
[10:26:26.866]             `<<-` <- base::`<<-`
[10:26:26.866]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:26.866]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:26.866]                   3L)]
[10:26:26.866]             }
[10:26:26.866]             function(cond) {
[10:26:26.866]                 is_error <- inherits(cond, "error")
[10:26:26.866]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:26.866]                   NULL)
[10:26:26.866]                 if (is_error) {
[10:26:26.866]                   sessionInformation <- function() {
[10:26:26.866]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:26.866]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:26.866]                       search = base::search(), system = base::Sys.info())
[10:26:26.866]                   }
[10:26:26.866]                   ...future.conditions[[length(...future.conditions) + 
[10:26:26.866]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:26.866]                     cond$call), session = sessionInformation(), 
[10:26:26.866]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:26.866]                   signalCondition(cond)
[10:26:26.866]                 }
[10:26:26.866]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:26.866]                 "immediateCondition"))) {
[10:26:26.866]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:26.866]                   ...future.conditions[[length(...future.conditions) + 
[10:26:26.866]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:26.866]                   if (TRUE && !signal) {
[10:26:26.866]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:26.866]                     {
[10:26:26.866]                       inherits <- base::inherits
[10:26:26.866]                       invokeRestart <- base::invokeRestart
[10:26:26.866]                       is.null <- base::is.null
[10:26:26.866]                       muffled <- FALSE
[10:26:26.866]                       if (inherits(cond, "message")) {
[10:26:26.866]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:26.866]                         if (muffled) 
[10:26:26.866]                           invokeRestart("muffleMessage")
[10:26:26.866]                       }
[10:26:26.866]                       else if (inherits(cond, "warning")) {
[10:26:26.866]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:26.866]                         if (muffled) 
[10:26:26.866]                           invokeRestart("muffleWarning")
[10:26:26.866]                       }
[10:26:26.866]                       else if (inherits(cond, "condition")) {
[10:26:26.866]                         if (!is.null(pattern)) {
[10:26:26.866]                           computeRestarts <- base::computeRestarts
[10:26:26.866]                           grepl <- base::grepl
[10:26:26.866]                           restarts <- computeRestarts(cond)
[10:26:26.866]                           for (restart in restarts) {
[10:26:26.866]                             name <- restart$name
[10:26:26.866]                             if (is.null(name)) 
[10:26:26.866]                               next
[10:26:26.866]                             if (!grepl(pattern, name)) 
[10:26:26.866]                               next
[10:26:26.866]                             invokeRestart(restart)
[10:26:26.866]                             muffled <- TRUE
[10:26:26.866]                             break
[10:26:26.866]                           }
[10:26:26.866]                         }
[10:26:26.866]                       }
[10:26:26.866]                       invisible(muffled)
[10:26:26.866]                     }
[10:26:26.866]                     muffleCondition(cond, pattern = "^muffle")
[10:26:26.866]                   }
[10:26:26.866]                 }
[10:26:26.866]                 else {
[10:26:26.866]                   if (TRUE) {
[10:26:26.866]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:26.866]                     {
[10:26:26.866]                       inherits <- base::inherits
[10:26:26.866]                       invokeRestart <- base::invokeRestart
[10:26:26.866]                       is.null <- base::is.null
[10:26:26.866]                       muffled <- FALSE
[10:26:26.866]                       if (inherits(cond, "message")) {
[10:26:26.866]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:26.866]                         if (muffled) 
[10:26:26.866]                           invokeRestart("muffleMessage")
[10:26:26.866]                       }
[10:26:26.866]                       else if (inherits(cond, "warning")) {
[10:26:26.866]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:26.866]                         if (muffled) 
[10:26:26.866]                           invokeRestart("muffleWarning")
[10:26:26.866]                       }
[10:26:26.866]                       else if (inherits(cond, "condition")) {
[10:26:26.866]                         if (!is.null(pattern)) {
[10:26:26.866]                           computeRestarts <- base::computeRestarts
[10:26:26.866]                           grepl <- base::grepl
[10:26:26.866]                           restarts <- computeRestarts(cond)
[10:26:26.866]                           for (restart in restarts) {
[10:26:26.866]                             name <- restart$name
[10:26:26.866]                             if (is.null(name)) 
[10:26:26.866]                               next
[10:26:26.866]                             if (!grepl(pattern, name)) 
[10:26:26.866]                               next
[10:26:26.866]                             invokeRestart(restart)
[10:26:26.866]                             muffled <- TRUE
[10:26:26.866]                             break
[10:26:26.866]                           }
[10:26:26.866]                         }
[10:26:26.866]                       }
[10:26:26.866]                       invisible(muffled)
[10:26:26.866]                     }
[10:26:26.866]                     muffleCondition(cond, pattern = "^muffle")
[10:26:26.866]                   }
[10:26:26.866]                 }
[10:26:26.866]             }
[10:26:26.866]         }))
[10:26:26.866]     }, error = function(ex) {
[10:26:26.866]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:26.866]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:26.866]                 ...future.rng), started = ...future.startTime, 
[10:26:26.866]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:26.866]             version = "1.8"), class = "FutureResult")
[10:26:26.866]     }, finally = {
[10:26:26.866]         if (!identical(...future.workdir, getwd())) 
[10:26:26.866]             setwd(...future.workdir)
[10:26:26.866]         {
[10:26:26.866]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:26.866]                 ...future.oldOptions$nwarnings <- NULL
[10:26:26.866]             }
[10:26:26.866]             base::options(...future.oldOptions)
[10:26:26.866]             if (.Platform$OS.type == "windows") {
[10:26:26.866]                 old_names <- names(...future.oldEnvVars)
[10:26:26.866]                 envs <- base::Sys.getenv()
[10:26:26.866]                 names <- names(envs)
[10:26:26.866]                 common <- intersect(names, old_names)
[10:26:26.866]                 added <- setdiff(names, old_names)
[10:26:26.866]                 removed <- setdiff(old_names, names)
[10:26:26.866]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:26.866]                   envs[common]]
[10:26:26.866]                 NAMES <- toupper(changed)
[10:26:26.866]                 args <- list()
[10:26:26.866]                 for (kk in seq_along(NAMES)) {
[10:26:26.866]                   name <- changed[[kk]]
[10:26:26.866]                   NAME <- NAMES[[kk]]
[10:26:26.866]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:26.866]                     next
[10:26:26.866]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:26.866]                 }
[10:26:26.866]                 NAMES <- toupper(added)
[10:26:26.866]                 for (kk in seq_along(NAMES)) {
[10:26:26.866]                   name <- added[[kk]]
[10:26:26.866]                   NAME <- NAMES[[kk]]
[10:26:26.866]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:26.866]                     next
[10:26:26.866]                   args[[name]] <- ""
[10:26:26.866]                 }
[10:26:26.866]                 NAMES <- toupper(removed)
[10:26:26.866]                 for (kk in seq_along(NAMES)) {
[10:26:26.866]                   name <- removed[[kk]]
[10:26:26.866]                   NAME <- NAMES[[kk]]
[10:26:26.866]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:26.866]                     next
[10:26:26.866]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:26.866]                 }
[10:26:26.866]                 if (length(args) > 0) 
[10:26:26.866]                   base::do.call(base::Sys.setenv, args = args)
[10:26:26.866]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:26.866]             }
[10:26:26.866]             else {
[10:26:26.866]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:26.866]             }
[10:26:26.866]             {
[10:26:26.866]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:26.866]                   0L) {
[10:26:26.866]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:26.866]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:26.866]                   base::options(opts)
[10:26:26.866]                 }
[10:26:26.866]                 {
[10:26:26.866]                   {
[10:26:26.866]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:26.866]                     NULL
[10:26:26.866]                   }
[10:26:26.866]                   options(future.plan = NULL)
[10:26:26.866]                   if (is.na(NA_character_)) 
[10:26:26.866]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:26.866]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:26.866]                   future::plan(list(function (..., workers = 2L, 
[10:26:26.866]                     envir = parent.frame()) 
[10:26:26.866]                   strategy(..., workers = workers, envir = envir)), 
[10:26:26.866]                     .cleanup = FALSE, .init = FALSE)
[10:26:26.866]                 }
[10:26:26.866]             }
[10:26:26.866]         }
[10:26:26.866]     })
[10:26:26.866]     if (TRUE) {
[10:26:26.866]         base::sink(type = "output", split = FALSE)
[10:26:26.866]         if (TRUE) {
[10:26:26.866]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:26.866]         }
[10:26:26.866]         else {
[10:26:26.866]             ...future.result["stdout"] <- base::list(NULL)
[10:26:26.866]         }
[10:26:26.866]         base::close(...future.stdout)
[10:26:26.866]         ...future.stdout <- NULL
[10:26:26.866]     }
[10:26:26.866]     ...future.result$conditions <- ...future.conditions
[10:26:26.866]     ...future.result$finished <- base::Sys.time()
[10:26:26.866]     ...future.result
[10:26:26.866] }
[10:26:26.869] MultisessionFuture started
[10:26:26.869] - Launch lazy future ... done
[10:26:26.869] run() for ‘MultisessionFuture’ ... done
> v <- value(f)
[10:26:26.869] result() for ClusterFuture ...
[10:26:26.870] receiveMessageFromWorker() for ClusterFuture ...
[10:26:26.870] - Validating connection of MultisessionFuture
[10:26:26.935] - received message: FutureResult
[10:26:26.935] - Received FutureResult
[10:26:26.936] - Erased future from FutureRegistry
[10:26:26.936] result() for ClusterFuture ...
[10:26:26.936] - result already collected: FutureResult
[10:26:26.936] result() for ClusterFuture ... done
[10:26:26.936] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:26.936] result() for ClusterFuture ... done
[10:26:26.936] result() for ClusterFuture ...
[10:26:26.936] - result already collected: FutureResult
[10:26:26.936] result() for ClusterFuture ... done
> print(v)
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 395068 21.1     836944 44.7   664120 35.5
Vcells 704742  5.4    8388608 64.0  1814359 13.9
> 
> f <- future({ integer(10e6) })
[10:26:26.937] getGlobalsAndPackages() ...
[10:26:26.937] Searching for globals...
[10:26:26.938] - globals found: [2] ‘{’, ‘integer’
[10:26:26.938] Searching for globals ... DONE
[10:26:26.938] Resolving globals: FALSE
[10:26:26.938] 
[10:26:26.938] 
[10:26:26.939] getGlobalsAndPackages() ... DONE
[10:26:26.939] run() for ‘Future’ ...
[10:26:26.939] - state: ‘created’
[10:26:26.939] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:26.950] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:26.950] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:26.950]   - Field: ‘node’
[10:26:26.950]   - Field: ‘label’
[10:26:26.950]   - Field: ‘local’
[10:26:26.950]   - Field: ‘owner’
[10:26:26.950]   - Field: ‘envir’
[10:26:26.950]   - Field: ‘workers’
[10:26:26.951]   - Field: ‘packages’
[10:26:26.951]   - Field: ‘gc’
[10:26:26.951]   - Field: ‘conditions’
[10:26:26.951]   - Field: ‘persistent’
[10:26:26.951]   - Field: ‘expr’
[10:26:26.951]   - Field: ‘uuid’
[10:26:26.951]   - Field: ‘seed’
[10:26:26.953]   - Field: ‘version’
[10:26:26.953]   - Field: ‘result’
[10:26:26.953]   - Field: ‘asynchronous’
[10:26:26.953]   - Field: ‘calls’
[10:26:26.954]   - Field: ‘globals’
[10:26:26.954]   - Field: ‘stdout’
[10:26:26.954]   - Field: ‘earlySignal’
[10:26:26.954]   - Field: ‘lazy’
[10:26:26.954]   - Field: ‘state’
[10:26:26.954] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:26.954] - Launch lazy future ...
[10:26:26.954] Packages needed by the future expression (n = 0): <none>
[10:26:26.954] Packages needed by future strategies (n = 0): <none>
[10:26:26.955] {
[10:26:26.955]     {
[10:26:26.955]         {
[10:26:26.955]             ...future.startTime <- base::Sys.time()
[10:26:26.955]             {
[10:26:26.955]                 {
[10:26:26.955]                   {
[10:26:26.955]                     {
[10:26:26.955]                       base::local({
[10:26:26.955]                         has_future <- base::requireNamespace("future", 
[10:26:26.955]                           quietly = TRUE)
[10:26:26.955]                         if (has_future) {
[10:26:26.955]                           ns <- base::getNamespace("future")
[10:26:26.955]                           version <- ns[[".package"]][["version"]]
[10:26:26.955]                           if (is.null(version)) 
[10:26:26.955]                             version <- utils::packageVersion("future")
[10:26:26.955]                         }
[10:26:26.955]                         else {
[10:26:26.955]                           version <- NULL
[10:26:26.955]                         }
[10:26:26.955]                         if (!has_future || version < "1.8.0") {
[10:26:26.955]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:26.955]                             "", base::R.version$version.string), 
[10:26:26.955]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:26.955]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:26.955]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:26.955]                               "release", "version")], collapse = " "), 
[10:26:26.955]                             hostname = base::Sys.info()[["nodename"]])
[10:26:26.955]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:26.955]                             info)
[10:26:26.955]                           info <- base::paste(info, collapse = "; ")
[10:26:26.955]                           if (!has_future) {
[10:26:26.955]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:26.955]                               info)
[10:26:26.955]                           }
[10:26:26.955]                           else {
[10:26:26.955]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:26.955]                               info, version)
[10:26:26.955]                           }
[10:26:26.955]                           base::stop(msg)
[10:26:26.955]                         }
[10:26:26.955]                       })
[10:26:26.955]                     }
[10:26:26.955]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:26.955]                     base::options(mc.cores = 1L)
[10:26:26.955]                   }
[10:26:26.955]                   options(future.plan = NULL)
[10:26:26.955]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:26.955]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:26.955]                 }
[10:26:26.955]                 ...future.workdir <- getwd()
[10:26:26.955]             }
[10:26:26.955]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:26.955]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:26.955]         }
[10:26:26.955]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:26.955]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:26.955]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:26.955]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:26.955]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:26.955]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:26.955]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:26.955]             base::names(...future.oldOptions))
[10:26:26.955]     }
[10:26:26.955]     if (FALSE) {
[10:26:26.955]     }
[10:26:26.955]     else {
[10:26:26.955]         if (TRUE) {
[10:26:26.955]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:26.955]                 open = "w")
[10:26:26.955]         }
[10:26:26.955]         else {
[10:26:26.955]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:26.955]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:26.955]         }
[10:26:26.955]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:26.955]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:26.955]             base::sink(type = "output", split = FALSE)
[10:26:26.955]             base::close(...future.stdout)
[10:26:26.955]         }, add = TRUE)
[10:26:26.955]     }
[10:26:26.955]     ...future.frame <- base::sys.nframe()
[10:26:26.955]     ...future.conditions <- base::list()
[10:26:26.955]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:26.955]     if (FALSE) {
[10:26:26.955]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:26.955]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:26.955]     }
[10:26:26.955]     ...future.result <- base::tryCatch({
[10:26:26.955]         base::withCallingHandlers({
[10:26:26.955]             ...future.value <- base::withVisible(base::local({
[10:26:26.955]                 ...future.makeSendCondition <- base::local({
[10:26:26.955]                   sendCondition <- NULL
[10:26:26.955]                   function(frame = 1L) {
[10:26:26.955]                     if (is.function(sendCondition)) 
[10:26:26.955]                       return(sendCondition)
[10:26:26.955]                     ns <- getNamespace("parallel")
[10:26:26.955]                     if (exists("sendData", mode = "function", 
[10:26:26.955]                       envir = ns)) {
[10:26:26.955]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:26.955]                         envir = ns)
[10:26:26.955]                       envir <- sys.frame(frame)
[10:26:26.955]                       master <- NULL
[10:26:26.955]                       while (!identical(envir, .GlobalEnv) && 
[10:26:26.955]                         !identical(envir, emptyenv())) {
[10:26:26.955]                         if (exists("master", mode = "list", envir = envir, 
[10:26:26.955]                           inherits = FALSE)) {
[10:26:26.955]                           master <- get("master", mode = "list", 
[10:26:26.955]                             envir = envir, inherits = FALSE)
[10:26:26.955]                           if (inherits(master, c("SOCKnode", 
[10:26:26.955]                             "SOCK0node"))) {
[10:26:26.955]                             sendCondition <<- function(cond) {
[10:26:26.955]                               data <- list(type = "VALUE", value = cond, 
[10:26:26.955]                                 success = TRUE)
[10:26:26.955]                               parallel_sendData(master, data)
[10:26:26.955]                             }
[10:26:26.955]                             return(sendCondition)
[10:26:26.955]                           }
[10:26:26.955]                         }
[10:26:26.955]                         frame <- frame + 1L
[10:26:26.955]                         envir <- sys.frame(frame)
[10:26:26.955]                       }
[10:26:26.955]                     }
[10:26:26.955]                     sendCondition <<- function(cond) NULL
[10:26:26.955]                   }
[10:26:26.955]                 })
[10:26:26.955]                 withCallingHandlers({
[10:26:26.955]                   {
[10:26:26.955]                     integer(1e+07)
[10:26:26.955]                   }
[10:26:26.955]                 }, immediateCondition = function(cond) {
[10:26:26.955]                   sendCondition <- ...future.makeSendCondition()
[10:26:26.955]                   sendCondition(cond)
[10:26:26.955]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:26.955]                   {
[10:26:26.955]                     inherits <- base::inherits
[10:26:26.955]                     invokeRestart <- base::invokeRestart
[10:26:26.955]                     is.null <- base::is.null
[10:26:26.955]                     muffled <- FALSE
[10:26:26.955]                     if (inherits(cond, "message")) {
[10:26:26.955]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:26.955]                       if (muffled) 
[10:26:26.955]                         invokeRestart("muffleMessage")
[10:26:26.955]                     }
[10:26:26.955]                     else if (inherits(cond, "warning")) {
[10:26:26.955]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:26.955]                       if (muffled) 
[10:26:26.955]                         invokeRestart("muffleWarning")
[10:26:26.955]                     }
[10:26:26.955]                     else if (inherits(cond, "condition")) {
[10:26:26.955]                       if (!is.null(pattern)) {
[10:26:26.955]                         computeRestarts <- base::computeRestarts
[10:26:26.955]                         grepl <- base::grepl
[10:26:26.955]                         restarts <- computeRestarts(cond)
[10:26:26.955]                         for (restart in restarts) {
[10:26:26.955]                           name <- restart$name
[10:26:26.955]                           if (is.null(name)) 
[10:26:26.955]                             next
[10:26:26.955]                           if (!grepl(pattern, name)) 
[10:26:26.955]                             next
[10:26:26.955]                           invokeRestart(restart)
[10:26:26.955]                           muffled <- TRUE
[10:26:26.955]                           break
[10:26:26.955]                         }
[10:26:26.955]                       }
[10:26:26.955]                     }
[10:26:26.955]                     invisible(muffled)
[10:26:26.955]                   }
[10:26:26.955]                   muffleCondition(cond)
[10:26:26.955]                 })
[10:26:26.955]             }))
[10:26:26.955]             future::FutureResult(value = ...future.value$value, 
[10:26:26.955]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:26.955]                   ...future.rng), globalenv = if (FALSE) 
[10:26:26.955]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:26.955]                     ...future.globalenv.names))
[10:26:26.955]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:26.955]         }, condition = base::local({
[10:26:26.955]             c <- base::c
[10:26:26.955]             inherits <- base::inherits
[10:26:26.955]             invokeRestart <- base::invokeRestart
[10:26:26.955]             length <- base::length
[10:26:26.955]             list <- base::list
[10:26:26.955]             seq.int <- base::seq.int
[10:26:26.955]             signalCondition <- base::signalCondition
[10:26:26.955]             sys.calls <- base::sys.calls
[10:26:26.955]             `[[` <- base::`[[`
[10:26:26.955]             `+` <- base::`+`
[10:26:26.955]             `<<-` <- base::`<<-`
[10:26:26.955]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:26.955]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:26.955]                   3L)]
[10:26:26.955]             }
[10:26:26.955]             function(cond) {
[10:26:26.955]                 is_error <- inherits(cond, "error")
[10:26:26.955]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:26.955]                   NULL)
[10:26:26.955]                 if (is_error) {
[10:26:26.955]                   sessionInformation <- function() {
[10:26:26.955]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:26.955]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:26.955]                       search = base::search(), system = base::Sys.info())
[10:26:26.955]                   }
[10:26:26.955]                   ...future.conditions[[length(...future.conditions) + 
[10:26:26.955]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:26.955]                     cond$call), session = sessionInformation(), 
[10:26:26.955]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:26.955]                   signalCondition(cond)
[10:26:26.955]                 }
[10:26:26.955]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:26.955]                 "immediateCondition"))) {
[10:26:26.955]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:26.955]                   ...future.conditions[[length(...future.conditions) + 
[10:26:26.955]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:26.955]                   if (TRUE && !signal) {
[10:26:26.955]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:26.955]                     {
[10:26:26.955]                       inherits <- base::inherits
[10:26:26.955]                       invokeRestart <- base::invokeRestart
[10:26:26.955]                       is.null <- base::is.null
[10:26:26.955]                       muffled <- FALSE
[10:26:26.955]                       if (inherits(cond, "message")) {
[10:26:26.955]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:26.955]                         if (muffled) 
[10:26:26.955]                           invokeRestart("muffleMessage")
[10:26:26.955]                       }
[10:26:26.955]                       else if (inherits(cond, "warning")) {
[10:26:26.955]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:26.955]                         if (muffled) 
[10:26:26.955]                           invokeRestart("muffleWarning")
[10:26:26.955]                       }
[10:26:26.955]                       else if (inherits(cond, "condition")) {
[10:26:26.955]                         if (!is.null(pattern)) {
[10:26:26.955]                           computeRestarts <- base::computeRestarts
[10:26:26.955]                           grepl <- base::grepl
[10:26:26.955]                           restarts <- computeRestarts(cond)
[10:26:26.955]                           for (restart in restarts) {
[10:26:26.955]                             name <- restart$name
[10:26:26.955]                             if (is.null(name)) 
[10:26:26.955]                               next
[10:26:26.955]                             if (!grepl(pattern, name)) 
[10:26:26.955]                               next
[10:26:26.955]                             invokeRestart(restart)
[10:26:26.955]                             muffled <- TRUE
[10:26:26.955]                             break
[10:26:26.955]                           }
[10:26:26.955]                         }
[10:26:26.955]                       }
[10:26:26.955]                       invisible(muffled)
[10:26:26.955]                     }
[10:26:26.955]                     muffleCondition(cond, pattern = "^muffle")
[10:26:26.955]                   }
[10:26:26.955]                 }
[10:26:26.955]                 else {
[10:26:26.955]                   if (TRUE) {
[10:26:26.955]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:26.955]                     {
[10:26:26.955]                       inherits <- base::inherits
[10:26:26.955]                       invokeRestart <- base::invokeRestart
[10:26:26.955]                       is.null <- base::is.null
[10:26:26.955]                       muffled <- FALSE
[10:26:26.955]                       if (inherits(cond, "message")) {
[10:26:26.955]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:26.955]                         if (muffled) 
[10:26:26.955]                           invokeRestart("muffleMessage")
[10:26:26.955]                       }
[10:26:26.955]                       else if (inherits(cond, "warning")) {
[10:26:26.955]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:26.955]                         if (muffled) 
[10:26:26.955]                           invokeRestart("muffleWarning")
[10:26:26.955]                       }
[10:26:26.955]                       else if (inherits(cond, "condition")) {
[10:26:26.955]                         if (!is.null(pattern)) {
[10:26:26.955]                           computeRestarts <- base::computeRestarts
[10:26:26.955]                           grepl <- base::grepl
[10:26:26.955]                           restarts <- computeRestarts(cond)
[10:26:26.955]                           for (restart in restarts) {
[10:26:26.955]                             name <- restart$name
[10:26:26.955]                             if (is.null(name)) 
[10:26:26.955]                               next
[10:26:26.955]                             if (!grepl(pattern, name)) 
[10:26:26.955]                               next
[10:26:26.955]                             invokeRestart(restart)
[10:26:26.955]                             muffled <- TRUE
[10:26:26.955]                             break
[10:26:26.955]                           }
[10:26:26.955]                         }
[10:26:26.955]                       }
[10:26:26.955]                       invisible(muffled)
[10:26:26.955]                     }
[10:26:26.955]                     muffleCondition(cond, pattern = "^muffle")
[10:26:26.955]                   }
[10:26:26.955]                 }
[10:26:26.955]             }
[10:26:26.955]         }))
[10:26:26.955]     }, error = function(ex) {
[10:26:26.955]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:26.955]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:26.955]                 ...future.rng), started = ...future.startTime, 
[10:26:26.955]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:26.955]             version = "1.8"), class = "FutureResult")
[10:26:26.955]     }, finally = {
[10:26:26.955]         if (!identical(...future.workdir, getwd())) 
[10:26:26.955]             setwd(...future.workdir)
[10:26:26.955]         {
[10:26:26.955]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:26.955]                 ...future.oldOptions$nwarnings <- NULL
[10:26:26.955]             }
[10:26:26.955]             base::options(...future.oldOptions)
[10:26:26.955]             if (.Platform$OS.type == "windows") {
[10:26:26.955]                 old_names <- names(...future.oldEnvVars)
[10:26:26.955]                 envs <- base::Sys.getenv()
[10:26:26.955]                 names <- names(envs)
[10:26:26.955]                 common <- intersect(names, old_names)
[10:26:26.955]                 added <- setdiff(names, old_names)
[10:26:26.955]                 removed <- setdiff(old_names, names)
[10:26:26.955]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:26.955]                   envs[common]]
[10:26:26.955]                 NAMES <- toupper(changed)
[10:26:26.955]                 args <- list()
[10:26:26.955]                 for (kk in seq_along(NAMES)) {
[10:26:26.955]                   name <- changed[[kk]]
[10:26:26.955]                   NAME <- NAMES[[kk]]
[10:26:26.955]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:26.955]                     next
[10:26:26.955]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:26.955]                 }
[10:26:26.955]                 NAMES <- toupper(added)
[10:26:26.955]                 for (kk in seq_along(NAMES)) {
[10:26:26.955]                   name <- added[[kk]]
[10:26:26.955]                   NAME <- NAMES[[kk]]
[10:26:26.955]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:26.955]                     next
[10:26:26.955]                   args[[name]] <- ""
[10:26:26.955]                 }
[10:26:26.955]                 NAMES <- toupper(removed)
[10:26:26.955]                 for (kk in seq_along(NAMES)) {
[10:26:26.955]                   name <- removed[[kk]]
[10:26:26.955]                   NAME <- NAMES[[kk]]
[10:26:26.955]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:26.955]                     next
[10:26:26.955]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:26.955]                 }
[10:26:26.955]                 if (length(args) > 0) 
[10:26:26.955]                   base::do.call(base::Sys.setenv, args = args)
[10:26:26.955]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:26.955]             }
[10:26:26.955]             else {
[10:26:26.955]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:26.955]             }
[10:26:26.955]             {
[10:26:26.955]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:26.955]                   0L) {
[10:26:26.955]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:26.955]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:26.955]                   base::options(opts)
[10:26:26.955]                 }
[10:26:26.955]                 {
[10:26:26.955]                   {
[10:26:26.955]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:26.955]                     NULL
[10:26:26.955]                   }
[10:26:26.955]                   options(future.plan = NULL)
[10:26:26.955]                   if (is.na(NA_character_)) 
[10:26:26.955]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:26.955]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:26.955]                   future::plan(list(function (..., workers = 2L, 
[10:26:26.955]                     envir = parent.frame()) 
[10:26:26.955]                   strategy(..., workers = workers, envir = envir)), 
[10:26:26.955]                     .cleanup = FALSE, .init = FALSE)
[10:26:26.955]                 }
[10:26:26.955]             }
[10:26:26.955]         }
[10:26:26.955]     })
[10:26:26.955]     if (TRUE) {
[10:26:26.955]         base::sink(type = "output", split = FALSE)
[10:26:26.955]         if (TRUE) {
[10:26:26.955]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:26.955]         }
[10:26:26.955]         else {
[10:26:26.955]             ...future.result["stdout"] <- base::list(NULL)
[10:26:26.955]         }
[10:26:26.955]         base::close(...future.stdout)
[10:26:26.955]         ...future.stdout <- NULL
[10:26:26.955]     }
[10:26:26.955]     ...future.result$conditions <- ...future.conditions
[10:26:26.955]     ...future.result$finished <- base::Sys.time()
[10:26:26.955]     ...future.result
[10:26:26.955] }
[10:26:26.958] MultisessionFuture started
[10:26:26.958] - Launch lazy future ... done
[10:26:26.958] run() for ‘MultisessionFuture’ ... done
> v <- value(f)
[10:26:26.958] result() for ClusterFuture ...
[10:26:26.958] receiveMessageFromWorker() for ClusterFuture ...
[10:26:26.958] - Validating connection of MultisessionFuture
[10:26:27.052] - received message: FutureResult
[10:26:27.052] - Received FutureResult
[10:26:27.052] - Erased future from FutureRegistry
[10:26:27.052] result() for ClusterFuture ...
[10:26:27.052] - result already collected: FutureResult
[10:26:27.053] result() for ClusterFuture ... done
[10:26:27.053] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:27.053] result() for ClusterFuture ... done
[10:26:27.053] result() for ClusterFuture ...
[10:26:27.053] - result already collected: FutureResult
[10:26:27.053] result() for ClusterFuture ... done
> str(v)
 int [1:10000000] 0 0 0 0 0 0 0 0 0 0 ...
> 
> f <- future({ gc() })
[10:26:27.054] getGlobalsAndPackages() ...
[10:26:27.054] Searching for globals...
[10:26:27.054] - globals found: [2] ‘{’, ‘gc’
[10:26:27.055] Searching for globals ... DONE
[10:26:27.055] Resolving globals: FALSE
[10:26:27.055] 
[10:26:27.055] 
[10:26:27.055] getGlobalsAndPackages() ... DONE
[10:26:27.055] run() for ‘Future’ ...
[10:26:27.056] - state: ‘created’
[10:26:27.056] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:27.066] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:27.066] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:27.067]   - Field: ‘node’
[10:26:27.067]   - Field: ‘label’
[10:26:27.067]   - Field: ‘local’
[10:26:27.067]   - Field: ‘owner’
[10:26:27.067]   - Field: ‘envir’
[10:26:27.067]   - Field: ‘workers’
[10:26:27.067]   - Field: ‘packages’
[10:26:27.067]   - Field: ‘gc’
[10:26:27.067]   - Field: ‘conditions’
[10:26:27.067]   - Field: ‘persistent’
[10:26:27.068]   - Field: ‘expr’
[10:26:27.068]   - Field: ‘uuid’
[10:26:27.068]   - Field: ‘seed’
[10:26:27.068]   - Field: ‘version’
[10:26:27.068]   - Field: ‘result’
[10:26:27.068]   - Field: ‘asynchronous’
[10:26:27.068]   - Field: ‘calls’
[10:26:27.068]   - Field: ‘globals’
[10:26:27.068]   - Field: ‘stdout’
[10:26:27.068]   - Field: ‘earlySignal’
[10:26:27.068]   - Field: ‘lazy’
[10:26:27.068]   - Field: ‘state’
[10:26:27.069] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:27.069] - Launch lazy future ...
[10:26:27.069] Packages needed by the future expression (n = 0): <none>
[10:26:27.069] Packages needed by future strategies (n = 0): <none>
[10:26:27.070] {
[10:26:27.070]     {
[10:26:27.070]         {
[10:26:27.070]             ...future.startTime <- base::Sys.time()
[10:26:27.070]             {
[10:26:27.070]                 {
[10:26:27.070]                   {
[10:26:27.070]                     {
[10:26:27.070]                       base::local({
[10:26:27.070]                         has_future <- base::requireNamespace("future", 
[10:26:27.070]                           quietly = TRUE)
[10:26:27.070]                         if (has_future) {
[10:26:27.070]                           ns <- base::getNamespace("future")
[10:26:27.070]                           version <- ns[[".package"]][["version"]]
[10:26:27.070]                           if (is.null(version)) 
[10:26:27.070]                             version <- utils::packageVersion("future")
[10:26:27.070]                         }
[10:26:27.070]                         else {
[10:26:27.070]                           version <- NULL
[10:26:27.070]                         }
[10:26:27.070]                         if (!has_future || version < "1.8.0") {
[10:26:27.070]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:27.070]                             "", base::R.version$version.string), 
[10:26:27.070]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:27.070]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:27.070]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:27.070]                               "release", "version")], collapse = " "), 
[10:26:27.070]                             hostname = base::Sys.info()[["nodename"]])
[10:26:27.070]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:27.070]                             info)
[10:26:27.070]                           info <- base::paste(info, collapse = "; ")
[10:26:27.070]                           if (!has_future) {
[10:26:27.070]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:27.070]                               info)
[10:26:27.070]                           }
[10:26:27.070]                           else {
[10:26:27.070]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:27.070]                               info, version)
[10:26:27.070]                           }
[10:26:27.070]                           base::stop(msg)
[10:26:27.070]                         }
[10:26:27.070]                       })
[10:26:27.070]                     }
[10:26:27.070]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:27.070]                     base::options(mc.cores = 1L)
[10:26:27.070]                   }
[10:26:27.070]                   options(future.plan = NULL)
[10:26:27.070]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:27.070]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:27.070]                 }
[10:26:27.070]                 ...future.workdir <- getwd()
[10:26:27.070]             }
[10:26:27.070]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:27.070]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:27.070]         }
[10:26:27.070]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:27.070]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:27.070]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:27.070]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:27.070]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:27.070]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:27.070]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:27.070]             base::names(...future.oldOptions))
[10:26:27.070]     }
[10:26:27.070]     if (FALSE) {
[10:26:27.070]     }
[10:26:27.070]     else {
[10:26:27.070]         if (TRUE) {
[10:26:27.070]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:27.070]                 open = "w")
[10:26:27.070]         }
[10:26:27.070]         else {
[10:26:27.070]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:27.070]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:27.070]         }
[10:26:27.070]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:27.070]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:27.070]             base::sink(type = "output", split = FALSE)
[10:26:27.070]             base::close(...future.stdout)
[10:26:27.070]         }, add = TRUE)
[10:26:27.070]     }
[10:26:27.070]     ...future.frame <- base::sys.nframe()
[10:26:27.070]     ...future.conditions <- base::list()
[10:26:27.070]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:27.070]     if (FALSE) {
[10:26:27.070]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:27.070]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:27.070]     }
[10:26:27.070]     ...future.result <- base::tryCatch({
[10:26:27.070]         base::withCallingHandlers({
[10:26:27.070]             ...future.value <- base::withVisible(base::local({
[10:26:27.070]                 ...future.makeSendCondition <- base::local({
[10:26:27.070]                   sendCondition <- NULL
[10:26:27.070]                   function(frame = 1L) {
[10:26:27.070]                     if (is.function(sendCondition)) 
[10:26:27.070]                       return(sendCondition)
[10:26:27.070]                     ns <- getNamespace("parallel")
[10:26:27.070]                     if (exists("sendData", mode = "function", 
[10:26:27.070]                       envir = ns)) {
[10:26:27.070]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:27.070]                         envir = ns)
[10:26:27.070]                       envir <- sys.frame(frame)
[10:26:27.070]                       master <- NULL
[10:26:27.070]                       while (!identical(envir, .GlobalEnv) && 
[10:26:27.070]                         !identical(envir, emptyenv())) {
[10:26:27.070]                         if (exists("master", mode = "list", envir = envir, 
[10:26:27.070]                           inherits = FALSE)) {
[10:26:27.070]                           master <- get("master", mode = "list", 
[10:26:27.070]                             envir = envir, inherits = FALSE)
[10:26:27.070]                           if (inherits(master, c("SOCKnode", 
[10:26:27.070]                             "SOCK0node"))) {
[10:26:27.070]                             sendCondition <<- function(cond) {
[10:26:27.070]                               data <- list(type = "VALUE", value = cond, 
[10:26:27.070]                                 success = TRUE)
[10:26:27.070]                               parallel_sendData(master, data)
[10:26:27.070]                             }
[10:26:27.070]                             return(sendCondition)
[10:26:27.070]                           }
[10:26:27.070]                         }
[10:26:27.070]                         frame <- frame + 1L
[10:26:27.070]                         envir <- sys.frame(frame)
[10:26:27.070]                       }
[10:26:27.070]                     }
[10:26:27.070]                     sendCondition <<- function(cond) NULL
[10:26:27.070]                   }
[10:26:27.070]                 })
[10:26:27.070]                 withCallingHandlers({
[10:26:27.070]                   {
[10:26:27.070]                     gc()
[10:26:27.070]                   }
[10:26:27.070]                 }, immediateCondition = function(cond) {
[10:26:27.070]                   sendCondition <- ...future.makeSendCondition()
[10:26:27.070]                   sendCondition(cond)
[10:26:27.070]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:27.070]                   {
[10:26:27.070]                     inherits <- base::inherits
[10:26:27.070]                     invokeRestart <- base::invokeRestart
[10:26:27.070]                     is.null <- base::is.null
[10:26:27.070]                     muffled <- FALSE
[10:26:27.070]                     if (inherits(cond, "message")) {
[10:26:27.070]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:27.070]                       if (muffled) 
[10:26:27.070]                         invokeRestart("muffleMessage")
[10:26:27.070]                     }
[10:26:27.070]                     else if (inherits(cond, "warning")) {
[10:26:27.070]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:27.070]                       if (muffled) 
[10:26:27.070]                         invokeRestart("muffleWarning")
[10:26:27.070]                     }
[10:26:27.070]                     else if (inherits(cond, "condition")) {
[10:26:27.070]                       if (!is.null(pattern)) {
[10:26:27.070]                         computeRestarts <- base::computeRestarts
[10:26:27.070]                         grepl <- base::grepl
[10:26:27.070]                         restarts <- computeRestarts(cond)
[10:26:27.070]                         for (restart in restarts) {
[10:26:27.070]                           name <- restart$name
[10:26:27.070]                           if (is.null(name)) 
[10:26:27.070]                             next
[10:26:27.070]                           if (!grepl(pattern, name)) 
[10:26:27.070]                             next
[10:26:27.070]                           invokeRestart(restart)
[10:26:27.070]                           muffled <- TRUE
[10:26:27.070]                           break
[10:26:27.070]                         }
[10:26:27.070]                       }
[10:26:27.070]                     }
[10:26:27.070]                     invisible(muffled)
[10:26:27.070]                   }
[10:26:27.070]                   muffleCondition(cond)
[10:26:27.070]                 })
[10:26:27.070]             }))
[10:26:27.070]             future::FutureResult(value = ...future.value$value, 
[10:26:27.070]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:27.070]                   ...future.rng), globalenv = if (FALSE) 
[10:26:27.070]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:27.070]                     ...future.globalenv.names))
[10:26:27.070]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:27.070]         }, condition = base::local({
[10:26:27.070]             c <- base::c
[10:26:27.070]             inherits <- base::inherits
[10:26:27.070]             invokeRestart <- base::invokeRestart
[10:26:27.070]             length <- base::length
[10:26:27.070]             list <- base::list
[10:26:27.070]             seq.int <- base::seq.int
[10:26:27.070]             signalCondition <- base::signalCondition
[10:26:27.070]             sys.calls <- base::sys.calls
[10:26:27.070]             `[[` <- base::`[[`
[10:26:27.070]             `+` <- base::`+`
[10:26:27.070]             `<<-` <- base::`<<-`
[10:26:27.070]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:27.070]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:27.070]                   3L)]
[10:26:27.070]             }
[10:26:27.070]             function(cond) {
[10:26:27.070]                 is_error <- inherits(cond, "error")
[10:26:27.070]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:27.070]                   NULL)
[10:26:27.070]                 if (is_error) {
[10:26:27.070]                   sessionInformation <- function() {
[10:26:27.070]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:27.070]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:27.070]                       search = base::search(), system = base::Sys.info())
[10:26:27.070]                   }
[10:26:27.070]                   ...future.conditions[[length(...future.conditions) + 
[10:26:27.070]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:27.070]                     cond$call), session = sessionInformation(), 
[10:26:27.070]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:27.070]                   signalCondition(cond)
[10:26:27.070]                 }
[10:26:27.070]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:27.070]                 "immediateCondition"))) {
[10:26:27.070]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:27.070]                   ...future.conditions[[length(...future.conditions) + 
[10:26:27.070]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:27.070]                   if (TRUE && !signal) {
[10:26:27.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:27.070]                     {
[10:26:27.070]                       inherits <- base::inherits
[10:26:27.070]                       invokeRestart <- base::invokeRestart
[10:26:27.070]                       is.null <- base::is.null
[10:26:27.070]                       muffled <- FALSE
[10:26:27.070]                       if (inherits(cond, "message")) {
[10:26:27.070]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:27.070]                         if (muffled) 
[10:26:27.070]                           invokeRestart("muffleMessage")
[10:26:27.070]                       }
[10:26:27.070]                       else if (inherits(cond, "warning")) {
[10:26:27.070]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:27.070]                         if (muffled) 
[10:26:27.070]                           invokeRestart("muffleWarning")
[10:26:27.070]                       }
[10:26:27.070]                       else if (inherits(cond, "condition")) {
[10:26:27.070]                         if (!is.null(pattern)) {
[10:26:27.070]                           computeRestarts <- base::computeRestarts
[10:26:27.070]                           grepl <- base::grepl
[10:26:27.070]                           restarts <- computeRestarts(cond)
[10:26:27.070]                           for (restart in restarts) {
[10:26:27.070]                             name <- restart$name
[10:26:27.070]                             if (is.null(name)) 
[10:26:27.070]                               next
[10:26:27.070]                             if (!grepl(pattern, name)) 
[10:26:27.070]                               next
[10:26:27.070]                             invokeRestart(restart)
[10:26:27.070]                             muffled <- TRUE
[10:26:27.070]                             break
[10:26:27.070]                           }
[10:26:27.070]                         }
[10:26:27.070]                       }
[10:26:27.070]                       invisible(muffled)
[10:26:27.070]                     }
[10:26:27.070]                     muffleCondition(cond, pattern = "^muffle")
[10:26:27.070]                   }
[10:26:27.070]                 }
[10:26:27.070]                 else {
[10:26:27.070]                   if (TRUE) {
[10:26:27.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:27.070]                     {
[10:26:27.070]                       inherits <- base::inherits
[10:26:27.070]                       invokeRestart <- base::invokeRestart
[10:26:27.070]                       is.null <- base::is.null
[10:26:27.070]                       muffled <- FALSE
[10:26:27.070]                       if (inherits(cond, "message")) {
[10:26:27.070]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:27.070]                         if (muffled) 
[10:26:27.070]                           invokeRestart("muffleMessage")
[10:26:27.070]                       }
[10:26:27.070]                       else if (inherits(cond, "warning")) {
[10:26:27.070]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:27.070]                         if (muffled) 
[10:26:27.070]                           invokeRestart("muffleWarning")
[10:26:27.070]                       }
[10:26:27.070]                       else if (inherits(cond, "condition")) {
[10:26:27.070]                         if (!is.null(pattern)) {
[10:26:27.070]                           computeRestarts <- base::computeRestarts
[10:26:27.070]                           grepl <- base::grepl
[10:26:27.070]                           restarts <- computeRestarts(cond)
[10:26:27.070]                           for (restart in restarts) {
[10:26:27.070]                             name <- restart$name
[10:26:27.070]                             if (is.null(name)) 
[10:26:27.070]                               next
[10:26:27.070]                             if (!grepl(pattern, name)) 
[10:26:27.070]                               next
[10:26:27.070]                             invokeRestart(restart)
[10:26:27.070]                             muffled <- TRUE
[10:26:27.070]                             break
[10:26:27.070]                           }
[10:26:27.070]                         }
[10:26:27.070]                       }
[10:26:27.070]                       invisible(muffled)
[10:26:27.070]                     }
[10:26:27.070]                     muffleCondition(cond, pattern = "^muffle")
[10:26:27.070]                   }
[10:26:27.070]                 }
[10:26:27.070]             }
[10:26:27.070]         }))
[10:26:27.070]     }, error = function(ex) {
[10:26:27.070]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:27.070]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:27.070]                 ...future.rng), started = ...future.startTime, 
[10:26:27.070]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:27.070]             version = "1.8"), class = "FutureResult")
[10:26:27.070]     }, finally = {
[10:26:27.070]         if (!identical(...future.workdir, getwd())) 
[10:26:27.070]             setwd(...future.workdir)
[10:26:27.070]         {
[10:26:27.070]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:27.070]                 ...future.oldOptions$nwarnings <- NULL
[10:26:27.070]             }
[10:26:27.070]             base::options(...future.oldOptions)
[10:26:27.070]             if (.Platform$OS.type == "windows") {
[10:26:27.070]                 old_names <- names(...future.oldEnvVars)
[10:26:27.070]                 envs <- base::Sys.getenv()
[10:26:27.070]                 names <- names(envs)
[10:26:27.070]                 common <- intersect(names, old_names)
[10:26:27.070]                 added <- setdiff(names, old_names)
[10:26:27.070]                 removed <- setdiff(old_names, names)
[10:26:27.070]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:27.070]                   envs[common]]
[10:26:27.070]                 NAMES <- toupper(changed)
[10:26:27.070]                 args <- list()
[10:26:27.070]                 for (kk in seq_along(NAMES)) {
[10:26:27.070]                   name <- changed[[kk]]
[10:26:27.070]                   NAME <- NAMES[[kk]]
[10:26:27.070]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:27.070]                     next
[10:26:27.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:27.070]                 }
[10:26:27.070]                 NAMES <- toupper(added)
[10:26:27.070]                 for (kk in seq_along(NAMES)) {
[10:26:27.070]                   name <- added[[kk]]
[10:26:27.070]                   NAME <- NAMES[[kk]]
[10:26:27.070]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:27.070]                     next
[10:26:27.070]                   args[[name]] <- ""
[10:26:27.070]                 }
[10:26:27.070]                 NAMES <- toupper(removed)
[10:26:27.070]                 for (kk in seq_along(NAMES)) {
[10:26:27.070]                   name <- removed[[kk]]
[10:26:27.070]                   NAME <- NAMES[[kk]]
[10:26:27.070]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:27.070]                     next
[10:26:27.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:27.070]                 }
[10:26:27.070]                 if (length(args) > 0) 
[10:26:27.070]                   base::do.call(base::Sys.setenv, args = args)
[10:26:27.070]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:27.070]             }
[10:26:27.070]             else {
[10:26:27.070]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:27.070]             }
[10:26:27.070]             {
[10:26:27.070]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:27.070]                   0L) {
[10:26:27.070]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:27.070]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:27.070]                   base::options(opts)
[10:26:27.070]                 }
[10:26:27.070]                 {
[10:26:27.070]                   {
[10:26:27.070]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:27.070]                     NULL
[10:26:27.070]                   }
[10:26:27.070]                   options(future.plan = NULL)
[10:26:27.070]                   if (is.na(NA_character_)) 
[10:26:27.070]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:27.070]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:27.070]                   future::plan(list(function (..., workers = 2L, 
[10:26:27.070]                     envir = parent.frame()) 
[10:26:27.070]                   strategy(..., workers = workers, envir = envir)), 
[10:26:27.070]                     .cleanup = FALSE, .init = FALSE)
[10:26:27.070]                 }
[10:26:27.070]             }
[10:26:27.070]         }
[10:26:27.070]     })
[10:26:27.070]     if (TRUE) {
[10:26:27.070]         base::sink(type = "output", split = FALSE)
[10:26:27.070]         if (TRUE) {
[10:26:27.070]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:27.070]         }
[10:26:27.070]         else {
[10:26:27.070]             ...future.result["stdout"] <- base::list(NULL)
[10:26:27.070]         }
[10:26:27.070]         base::close(...future.stdout)
[10:26:27.070]         ...future.stdout <- NULL
[10:26:27.070]     }
[10:26:27.070]     ...future.result$conditions <- ...future.conditions
[10:26:27.070]     ...future.result$finished <- base::Sys.time()
[10:26:27.070]     ...future.result
[10:26:27.070] }
[10:26:27.073] MultisessionFuture started
[10:26:27.073] - Launch lazy future ... done
[10:26:27.073] run() for ‘MultisessionFuture’ ... done
> v <- value(f)
[10:26:27.073] result() for ClusterFuture ...
[10:26:27.073] receiveMessageFromWorker() for ClusterFuture ...
[10:26:27.073] - Validating connection of MultisessionFuture
[10:26:27.139] - received message: FutureResult
[10:26:27.139] - Received FutureResult
[10:26:27.139] - Erased future from FutureRegistry
[10:26:27.139] result() for ClusterFuture ...
[10:26:27.139] - result already collected: FutureResult
[10:26:27.140] result() for ClusterFuture ... done
[10:26:27.140] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:27.140] result() for ClusterFuture ... done
[10:26:27.140] result() for ClusterFuture ...
[10:26:27.140] - result already collected: FutureResult
[10:26:27.140] result() for ClusterFuture ... done
> print(v)
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 395063 21.1     836944 44.7   664120 35.5
Vcells 704732  5.4    8388608 64.0  5727919 43.8
> 
> f <- future({ integer(10e6) }, gc = TRUE)
[10:26:27.140] getGlobalsAndPackages() ...
[10:26:27.140] Searching for globals...
[10:26:27.141] - globals found: [2] ‘{’, ‘integer’
[10:26:27.141] Searching for globals ... DONE
[10:26:27.142] Resolving globals: FALSE
[10:26:27.142] 
[10:26:27.142] 
[10:26:27.142] getGlobalsAndPackages() ... DONE
[10:26:27.142] run() for ‘Future’ ...
[10:26:27.143] - state: ‘created’
[10:26:27.143] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:27.153] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:27.153] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:27.153]   - Field: ‘node’
[10:26:27.153]   - Field: ‘label’
[10:26:27.154]   - Field: ‘local’
[10:26:27.154]   - Field: ‘owner’
[10:26:27.154]   - Field: ‘envir’
[10:26:27.154]   - Field: ‘workers’
[10:26:27.154]   - Field: ‘packages’
[10:26:27.154]   - Field: ‘gc’
[10:26:27.154]   - Field: ‘conditions’
[10:26:27.154]   - Field: ‘persistent’
[10:26:27.154]   - Field: ‘expr’
[10:26:27.154]   - Field: ‘uuid’
[10:26:27.155]   - Field: ‘seed’
[10:26:27.155]   - Field: ‘version’
[10:26:27.155]   - Field: ‘result’
[10:26:27.155]   - Field: ‘asynchronous’
[10:26:27.155]   - Field: ‘calls’
[10:26:27.155]   - Field: ‘globals’
[10:26:27.155]   - Field: ‘stdout’
[10:26:27.155]   - Field: ‘earlySignal’
[10:26:27.155]   - Field: ‘lazy’
[10:26:27.155]   - Field: ‘state’
[10:26:27.155] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:27.156] - Launch lazy future ...
[10:26:27.156] Packages needed by the future expression (n = 0): <none>
[10:26:27.156] Packages needed by future strategies (n = 0): <none>
[10:26:27.156] {
[10:26:27.156]     {
[10:26:27.156]         {
[10:26:27.156]             ...future.startTime <- base::Sys.time()
[10:26:27.156]             {
[10:26:27.156]                 {
[10:26:27.156]                   {
[10:26:27.156]                     {
[10:26:27.156]                       base::local({
[10:26:27.156]                         has_future <- base::requireNamespace("future", 
[10:26:27.156]                           quietly = TRUE)
[10:26:27.156]                         if (has_future) {
[10:26:27.156]                           ns <- base::getNamespace("future")
[10:26:27.156]                           version <- ns[[".package"]][["version"]]
[10:26:27.156]                           if (is.null(version)) 
[10:26:27.156]                             version <- utils::packageVersion("future")
[10:26:27.156]                         }
[10:26:27.156]                         else {
[10:26:27.156]                           version <- NULL
[10:26:27.156]                         }
[10:26:27.156]                         if (!has_future || version < "1.8.0") {
[10:26:27.156]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:27.156]                             "", base::R.version$version.string), 
[10:26:27.156]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:27.156]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:27.156]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:27.156]                               "release", "version")], collapse = " "), 
[10:26:27.156]                             hostname = base::Sys.info()[["nodename"]])
[10:26:27.156]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:27.156]                             info)
[10:26:27.156]                           info <- base::paste(info, collapse = "; ")
[10:26:27.156]                           if (!has_future) {
[10:26:27.156]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:27.156]                               info)
[10:26:27.156]                           }
[10:26:27.156]                           else {
[10:26:27.156]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:27.156]                               info, version)
[10:26:27.156]                           }
[10:26:27.156]                           base::stop(msg)
[10:26:27.156]                         }
[10:26:27.156]                       })
[10:26:27.156]                     }
[10:26:27.156]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:27.156]                     base::options(mc.cores = 1L)
[10:26:27.156]                   }
[10:26:27.156]                   options(future.plan = NULL)
[10:26:27.156]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:27.156]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:27.156]                 }
[10:26:27.156]                 ...future.workdir <- getwd()
[10:26:27.156]             }
[10:26:27.156]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:27.156]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:27.156]         }
[10:26:27.156]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:27.156]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:27.156]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:27.156]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:27.156]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:27.156]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:27.156]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:27.156]             base::names(...future.oldOptions))
[10:26:27.156]     }
[10:26:27.156]     if (FALSE) {
[10:26:27.156]     }
[10:26:27.156]     else {
[10:26:27.156]         if (TRUE) {
[10:26:27.156]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:27.156]                 open = "w")
[10:26:27.156]         }
[10:26:27.156]         else {
[10:26:27.156]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:27.156]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:27.156]         }
[10:26:27.156]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:27.156]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:27.156]             base::sink(type = "output", split = FALSE)
[10:26:27.156]             base::close(...future.stdout)
[10:26:27.156]         }, add = TRUE)
[10:26:27.156]     }
[10:26:27.156]     ...future.frame <- base::sys.nframe()
[10:26:27.156]     ...future.conditions <- base::list()
[10:26:27.156]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:27.156]     if (FALSE) {
[10:26:27.156]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:27.156]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:27.156]     }
[10:26:27.156]     ...future.result <- base::tryCatch({
[10:26:27.156]         base::withCallingHandlers({
[10:26:27.156]             ...future.value <- base::withVisible(base::local({
[10:26:27.156]                 ...future.makeSendCondition <- base::local({
[10:26:27.156]                   sendCondition <- NULL
[10:26:27.156]                   function(frame = 1L) {
[10:26:27.156]                     if (is.function(sendCondition)) 
[10:26:27.156]                       return(sendCondition)
[10:26:27.156]                     ns <- getNamespace("parallel")
[10:26:27.156]                     if (exists("sendData", mode = "function", 
[10:26:27.156]                       envir = ns)) {
[10:26:27.156]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:27.156]                         envir = ns)
[10:26:27.156]                       envir <- sys.frame(frame)
[10:26:27.156]                       master <- NULL
[10:26:27.156]                       while (!identical(envir, .GlobalEnv) && 
[10:26:27.156]                         !identical(envir, emptyenv())) {
[10:26:27.156]                         if (exists("master", mode = "list", envir = envir, 
[10:26:27.156]                           inherits = FALSE)) {
[10:26:27.156]                           master <- get("master", mode = "list", 
[10:26:27.156]                             envir = envir, inherits = FALSE)
[10:26:27.156]                           if (inherits(master, c("SOCKnode", 
[10:26:27.156]                             "SOCK0node"))) {
[10:26:27.156]                             sendCondition <<- function(cond) {
[10:26:27.156]                               data <- list(type = "VALUE", value = cond, 
[10:26:27.156]                                 success = TRUE)
[10:26:27.156]                               parallel_sendData(master, data)
[10:26:27.156]                             }
[10:26:27.156]                             return(sendCondition)
[10:26:27.156]                           }
[10:26:27.156]                         }
[10:26:27.156]                         frame <- frame + 1L
[10:26:27.156]                         envir <- sys.frame(frame)
[10:26:27.156]                       }
[10:26:27.156]                     }
[10:26:27.156]                     sendCondition <<- function(cond) NULL
[10:26:27.156]                   }
[10:26:27.156]                 })
[10:26:27.156]                 withCallingHandlers({
[10:26:27.156]                   {
[10:26:27.156]                     integer(1e+07)
[10:26:27.156]                   }
[10:26:27.156]                 }, immediateCondition = function(cond) {
[10:26:27.156]                   sendCondition <- ...future.makeSendCondition()
[10:26:27.156]                   sendCondition(cond)
[10:26:27.156]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:27.156]                   {
[10:26:27.156]                     inherits <- base::inherits
[10:26:27.156]                     invokeRestart <- base::invokeRestart
[10:26:27.156]                     is.null <- base::is.null
[10:26:27.156]                     muffled <- FALSE
[10:26:27.156]                     if (inherits(cond, "message")) {
[10:26:27.156]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:27.156]                       if (muffled) 
[10:26:27.156]                         invokeRestart("muffleMessage")
[10:26:27.156]                     }
[10:26:27.156]                     else if (inherits(cond, "warning")) {
[10:26:27.156]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:27.156]                       if (muffled) 
[10:26:27.156]                         invokeRestart("muffleWarning")
[10:26:27.156]                     }
[10:26:27.156]                     else if (inherits(cond, "condition")) {
[10:26:27.156]                       if (!is.null(pattern)) {
[10:26:27.156]                         computeRestarts <- base::computeRestarts
[10:26:27.156]                         grepl <- base::grepl
[10:26:27.156]                         restarts <- computeRestarts(cond)
[10:26:27.156]                         for (restart in restarts) {
[10:26:27.156]                           name <- restart$name
[10:26:27.156]                           if (is.null(name)) 
[10:26:27.156]                             next
[10:26:27.156]                           if (!grepl(pattern, name)) 
[10:26:27.156]                             next
[10:26:27.156]                           invokeRestart(restart)
[10:26:27.156]                           muffled <- TRUE
[10:26:27.156]                           break
[10:26:27.156]                         }
[10:26:27.156]                       }
[10:26:27.156]                     }
[10:26:27.156]                     invisible(muffled)
[10:26:27.156]                   }
[10:26:27.156]                   muffleCondition(cond)
[10:26:27.156]                 })
[10:26:27.156]             }))
[10:26:27.156]             future::FutureResult(value = ...future.value$value, 
[10:26:27.156]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:27.156]                   ...future.rng), globalenv = if (FALSE) 
[10:26:27.156]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:27.156]                     ...future.globalenv.names))
[10:26:27.156]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:27.156]         }, condition = base::local({
[10:26:27.156]             c <- base::c
[10:26:27.156]             inherits <- base::inherits
[10:26:27.156]             invokeRestart <- base::invokeRestart
[10:26:27.156]             length <- base::length
[10:26:27.156]             list <- base::list
[10:26:27.156]             seq.int <- base::seq.int
[10:26:27.156]             signalCondition <- base::signalCondition
[10:26:27.156]             sys.calls <- base::sys.calls
[10:26:27.156]             `[[` <- base::`[[`
[10:26:27.156]             `+` <- base::`+`
[10:26:27.156]             `<<-` <- base::`<<-`
[10:26:27.156]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:27.156]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:27.156]                   3L)]
[10:26:27.156]             }
[10:26:27.156]             function(cond) {
[10:26:27.156]                 is_error <- inherits(cond, "error")
[10:26:27.156]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:27.156]                   NULL)
[10:26:27.156]                 if (is_error) {
[10:26:27.156]                   sessionInformation <- function() {
[10:26:27.156]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:27.156]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:27.156]                       search = base::search(), system = base::Sys.info())
[10:26:27.156]                   }
[10:26:27.156]                   ...future.conditions[[length(...future.conditions) + 
[10:26:27.156]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:27.156]                     cond$call), session = sessionInformation(), 
[10:26:27.156]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:27.156]                   signalCondition(cond)
[10:26:27.156]                 }
[10:26:27.156]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:27.156]                 "immediateCondition"))) {
[10:26:27.156]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:27.156]                   ...future.conditions[[length(...future.conditions) + 
[10:26:27.156]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:27.156]                   if (TRUE && !signal) {
[10:26:27.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:27.156]                     {
[10:26:27.156]                       inherits <- base::inherits
[10:26:27.156]                       invokeRestart <- base::invokeRestart
[10:26:27.156]                       is.null <- base::is.null
[10:26:27.156]                       muffled <- FALSE
[10:26:27.156]                       if (inherits(cond, "message")) {
[10:26:27.156]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:27.156]                         if (muffled) 
[10:26:27.156]                           invokeRestart("muffleMessage")
[10:26:27.156]                       }
[10:26:27.156]                       else if (inherits(cond, "warning")) {
[10:26:27.156]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:27.156]                         if (muffled) 
[10:26:27.156]                           invokeRestart("muffleWarning")
[10:26:27.156]                       }
[10:26:27.156]                       else if (inherits(cond, "condition")) {
[10:26:27.156]                         if (!is.null(pattern)) {
[10:26:27.156]                           computeRestarts <- base::computeRestarts
[10:26:27.156]                           grepl <- base::grepl
[10:26:27.156]                           restarts <- computeRestarts(cond)
[10:26:27.156]                           for (restart in restarts) {
[10:26:27.156]                             name <- restart$name
[10:26:27.156]                             if (is.null(name)) 
[10:26:27.156]                               next
[10:26:27.156]                             if (!grepl(pattern, name)) 
[10:26:27.156]                               next
[10:26:27.156]                             invokeRestart(restart)
[10:26:27.156]                             muffled <- TRUE
[10:26:27.156]                             break
[10:26:27.156]                           }
[10:26:27.156]                         }
[10:26:27.156]                       }
[10:26:27.156]                       invisible(muffled)
[10:26:27.156]                     }
[10:26:27.156]                     muffleCondition(cond, pattern = "^muffle")
[10:26:27.156]                   }
[10:26:27.156]                 }
[10:26:27.156]                 else {
[10:26:27.156]                   if (TRUE) {
[10:26:27.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:27.156]                     {
[10:26:27.156]                       inherits <- base::inherits
[10:26:27.156]                       invokeRestart <- base::invokeRestart
[10:26:27.156]                       is.null <- base::is.null
[10:26:27.156]                       muffled <- FALSE
[10:26:27.156]                       if (inherits(cond, "message")) {
[10:26:27.156]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:27.156]                         if (muffled) 
[10:26:27.156]                           invokeRestart("muffleMessage")
[10:26:27.156]                       }
[10:26:27.156]                       else if (inherits(cond, "warning")) {
[10:26:27.156]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:27.156]                         if (muffled) 
[10:26:27.156]                           invokeRestart("muffleWarning")
[10:26:27.156]                       }
[10:26:27.156]                       else if (inherits(cond, "condition")) {
[10:26:27.156]                         if (!is.null(pattern)) {
[10:26:27.156]                           computeRestarts <- base::computeRestarts
[10:26:27.156]                           grepl <- base::grepl
[10:26:27.156]                           restarts <- computeRestarts(cond)
[10:26:27.156]                           for (restart in restarts) {
[10:26:27.156]                             name <- restart$name
[10:26:27.156]                             if (is.null(name)) 
[10:26:27.156]                               next
[10:26:27.156]                             if (!grepl(pattern, name)) 
[10:26:27.156]                               next
[10:26:27.156]                             invokeRestart(restart)
[10:26:27.156]                             muffled <- TRUE
[10:26:27.156]                             break
[10:26:27.156]                           }
[10:26:27.156]                         }
[10:26:27.156]                       }
[10:26:27.156]                       invisible(muffled)
[10:26:27.156]                     }
[10:26:27.156]                     muffleCondition(cond, pattern = "^muffle")
[10:26:27.156]                   }
[10:26:27.156]                 }
[10:26:27.156]             }
[10:26:27.156]         }))
[10:26:27.156]     }, error = function(ex) {
[10:26:27.156]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:27.156]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:27.156]                 ...future.rng), started = ...future.startTime, 
[10:26:27.156]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:27.156]             version = "1.8"), class = "FutureResult")
[10:26:27.156]     }, finally = {
[10:26:27.156]         if (!identical(...future.workdir, getwd())) 
[10:26:27.156]             setwd(...future.workdir)
[10:26:27.156]         {
[10:26:27.156]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:27.156]                 ...future.oldOptions$nwarnings <- NULL
[10:26:27.156]             }
[10:26:27.156]             base::options(...future.oldOptions)
[10:26:27.156]             if (.Platform$OS.type == "windows") {
[10:26:27.156]                 old_names <- names(...future.oldEnvVars)
[10:26:27.156]                 envs <- base::Sys.getenv()
[10:26:27.156]                 names <- names(envs)
[10:26:27.156]                 common <- intersect(names, old_names)
[10:26:27.156]                 added <- setdiff(names, old_names)
[10:26:27.156]                 removed <- setdiff(old_names, names)
[10:26:27.156]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:27.156]                   envs[common]]
[10:26:27.156]                 NAMES <- toupper(changed)
[10:26:27.156]                 args <- list()
[10:26:27.156]                 for (kk in seq_along(NAMES)) {
[10:26:27.156]                   name <- changed[[kk]]
[10:26:27.156]                   NAME <- NAMES[[kk]]
[10:26:27.156]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:27.156]                     next
[10:26:27.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:27.156]                 }
[10:26:27.156]                 NAMES <- toupper(added)
[10:26:27.156]                 for (kk in seq_along(NAMES)) {
[10:26:27.156]                   name <- added[[kk]]
[10:26:27.156]                   NAME <- NAMES[[kk]]
[10:26:27.156]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:27.156]                     next
[10:26:27.156]                   args[[name]] <- ""
[10:26:27.156]                 }
[10:26:27.156]                 NAMES <- toupper(removed)
[10:26:27.156]                 for (kk in seq_along(NAMES)) {
[10:26:27.156]                   name <- removed[[kk]]
[10:26:27.156]                   NAME <- NAMES[[kk]]
[10:26:27.156]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:27.156]                     next
[10:26:27.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:27.156]                 }
[10:26:27.156]                 if (length(args) > 0) 
[10:26:27.156]                   base::do.call(base::Sys.setenv, args = args)
[10:26:27.156]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:27.156]             }
[10:26:27.156]             else {
[10:26:27.156]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:27.156]             }
[10:26:27.156]             {
[10:26:27.156]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:27.156]                   0L) {
[10:26:27.156]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:27.156]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:27.156]                   base::options(opts)
[10:26:27.156]                 }
[10:26:27.156]                 {
[10:26:27.156]                   {
[10:26:27.156]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:27.156]                     NULL
[10:26:27.156]                   }
[10:26:27.156]                   options(future.plan = NULL)
[10:26:27.156]                   if (is.na(NA_character_)) 
[10:26:27.156]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:27.156]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:27.156]                   future::plan(list(function (..., workers = 2L, 
[10:26:27.156]                     envir = parent.frame()) 
[10:26:27.156]                   strategy(..., workers = workers, envir = envir)), 
[10:26:27.156]                     .cleanup = FALSE, .init = FALSE)
[10:26:27.156]                 }
[10:26:27.156]             }
[10:26:27.156]         }
[10:26:27.156]     })
[10:26:27.156]     if (TRUE) {
[10:26:27.156]         base::sink(type = "output", split = FALSE)
[10:26:27.156]         if (TRUE) {
[10:26:27.156]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:27.156]         }
[10:26:27.156]         else {
[10:26:27.156]             ...future.result["stdout"] <- base::list(NULL)
[10:26:27.156]         }
[10:26:27.156]         base::close(...future.stdout)
[10:26:27.156]         ...future.stdout <- NULL
[10:26:27.156]     }
[10:26:27.156]     ...future.result$conditions <- ...future.conditions
[10:26:27.156]     ...future.result$finished <- base::Sys.time()
[10:26:27.156]     ...future.result
[10:26:27.156] }
[10:26:27.159] MultisessionFuture started
[10:26:27.159] - Launch lazy future ... done
[10:26:27.160] run() for ‘MultisessionFuture’ ... done
> v <- value(f)
[10:26:27.160] result() for ClusterFuture ...
[10:26:27.160] receiveMessageFromWorker() for ClusterFuture ...
[10:26:27.160] - Validating connection of MultisessionFuture
[10:26:27.258] - received message: FutureResult
[10:26:27.258] - Received FutureResult
[10:26:27.258] - Erased future from FutureRegistry
[10:26:27.258] result() for ClusterFuture ...
[10:26:27.259] - result already collected: FutureResult
[10:26:27.259] result() for ClusterFuture ... done
[10:26:27.259] - Garbage collecting worker ...
[10:26:27.486] - Garbage collecting worker ... done
[10:26:27.486] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:27.486] result() for ClusterFuture ... done
[10:26:27.487] result() for ClusterFuture ...
[10:26:27.487] - result already collected: FutureResult
[10:26:27.487] result() for ClusterFuture ... done
> str(v)
 int [1:10000000] 0 0 0 0 0 0 0 0 0 0 ...
> 
> f <- future({ gc() })
[10:26:27.487] getGlobalsAndPackages() ...
[10:26:27.488] Searching for globals...
[10:26:27.488] - globals found: [2] ‘{’, ‘gc’
[10:26:27.488] Searching for globals ... DONE
[10:26:27.489] Resolving globals: FALSE
[10:26:27.489] 
[10:26:27.489] 
[10:26:27.489] getGlobalsAndPackages() ... DONE
[10:26:27.489] run() for ‘Future’ ...
[10:26:27.490] - state: ‘created’
[10:26:27.490] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:27.500] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:27.500] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:27.501]   - Field: ‘node’
[10:26:27.501]   - Field: ‘label’
[10:26:27.501]   - Field: ‘local’
[10:26:27.501]   - Field: ‘owner’
[10:26:27.501]   - Field: ‘envir’
[10:26:27.501]   - Field: ‘workers’
[10:26:27.501]   - Field: ‘packages’
[10:26:27.501]   - Field: ‘gc’
[10:26:27.501]   - Field: ‘conditions’
[10:26:27.501]   - Field: ‘persistent’
[10:26:27.502]   - Field: ‘expr’
[10:26:27.502]   - Field: ‘uuid’
[10:26:27.502]   - Field: ‘seed’
[10:26:27.502]   - Field: ‘version’
[10:26:27.502]   - Field: ‘result’
[10:26:27.502]   - Field: ‘asynchronous’
[10:26:27.502]   - Field: ‘calls’
[10:26:27.502]   - Field: ‘globals’
[10:26:27.502]   - Field: ‘stdout’
[10:26:27.502]   - Field: ‘earlySignal’
[10:26:27.502]   - Field: ‘lazy’
[10:26:27.503]   - Field: ‘state’
[10:26:27.503] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:27.503] - Launch lazy future ...
[10:26:27.503] Packages needed by the future expression (n = 0): <none>
[10:26:27.503] Packages needed by future strategies (n = 0): <none>
[10:26:27.504] {
[10:26:27.504]     {
[10:26:27.504]         {
[10:26:27.504]             ...future.startTime <- base::Sys.time()
[10:26:27.504]             {
[10:26:27.504]                 {
[10:26:27.504]                   {
[10:26:27.504]                     {
[10:26:27.504]                       base::local({
[10:26:27.504]                         has_future <- base::requireNamespace("future", 
[10:26:27.504]                           quietly = TRUE)
[10:26:27.504]                         if (has_future) {
[10:26:27.504]                           ns <- base::getNamespace("future")
[10:26:27.504]                           version <- ns[[".package"]][["version"]]
[10:26:27.504]                           if (is.null(version)) 
[10:26:27.504]                             version <- utils::packageVersion("future")
[10:26:27.504]                         }
[10:26:27.504]                         else {
[10:26:27.504]                           version <- NULL
[10:26:27.504]                         }
[10:26:27.504]                         if (!has_future || version < "1.8.0") {
[10:26:27.504]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:27.504]                             "", base::R.version$version.string), 
[10:26:27.504]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:27.504]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:27.504]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:27.504]                               "release", "version")], collapse = " "), 
[10:26:27.504]                             hostname = base::Sys.info()[["nodename"]])
[10:26:27.504]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:27.504]                             info)
[10:26:27.504]                           info <- base::paste(info, collapse = "; ")
[10:26:27.504]                           if (!has_future) {
[10:26:27.504]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:27.504]                               info)
[10:26:27.504]                           }
[10:26:27.504]                           else {
[10:26:27.504]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:27.504]                               info, version)
[10:26:27.504]                           }
[10:26:27.504]                           base::stop(msg)
[10:26:27.504]                         }
[10:26:27.504]                       })
[10:26:27.504]                     }
[10:26:27.504]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:27.504]                     base::options(mc.cores = 1L)
[10:26:27.504]                   }
[10:26:27.504]                   options(future.plan = NULL)
[10:26:27.504]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:27.504]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:27.504]                 }
[10:26:27.504]                 ...future.workdir <- getwd()
[10:26:27.504]             }
[10:26:27.504]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:27.504]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:27.504]         }
[10:26:27.504]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:27.504]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:27.504]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:27.504]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:27.504]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:27.504]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:27.504]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:27.504]             base::names(...future.oldOptions))
[10:26:27.504]     }
[10:26:27.504]     if (FALSE) {
[10:26:27.504]     }
[10:26:27.504]     else {
[10:26:27.504]         if (TRUE) {
[10:26:27.504]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:27.504]                 open = "w")
[10:26:27.504]         }
[10:26:27.504]         else {
[10:26:27.504]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:27.504]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:27.504]         }
[10:26:27.504]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:27.504]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:27.504]             base::sink(type = "output", split = FALSE)
[10:26:27.504]             base::close(...future.stdout)
[10:26:27.504]         }, add = TRUE)
[10:26:27.504]     }
[10:26:27.504]     ...future.frame <- base::sys.nframe()
[10:26:27.504]     ...future.conditions <- base::list()
[10:26:27.504]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:27.504]     if (FALSE) {
[10:26:27.504]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:27.504]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:27.504]     }
[10:26:27.504]     ...future.result <- base::tryCatch({
[10:26:27.504]         base::withCallingHandlers({
[10:26:27.504]             ...future.value <- base::withVisible(base::local({
[10:26:27.504]                 ...future.makeSendCondition <- base::local({
[10:26:27.504]                   sendCondition <- NULL
[10:26:27.504]                   function(frame = 1L) {
[10:26:27.504]                     if (is.function(sendCondition)) 
[10:26:27.504]                       return(sendCondition)
[10:26:27.504]                     ns <- getNamespace("parallel")
[10:26:27.504]                     if (exists("sendData", mode = "function", 
[10:26:27.504]                       envir = ns)) {
[10:26:27.504]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:27.504]                         envir = ns)
[10:26:27.504]                       envir <- sys.frame(frame)
[10:26:27.504]                       master <- NULL
[10:26:27.504]                       while (!identical(envir, .GlobalEnv) && 
[10:26:27.504]                         !identical(envir, emptyenv())) {
[10:26:27.504]                         if (exists("master", mode = "list", envir = envir, 
[10:26:27.504]                           inherits = FALSE)) {
[10:26:27.504]                           master <- get("master", mode = "list", 
[10:26:27.504]                             envir = envir, inherits = FALSE)
[10:26:27.504]                           if (inherits(master, c("SOCKnode", 
[10:26:27.504]                             "SOCK0node"))) {
[10:26:27.504]                             sendCondition <<- function(cond) {
[10:26:27.504]                               data <- list(type = "VALUE", value = cond, 
[10:26:27.504]                                 success = TRUE)
[10:26:27.504]                               parallel_sendData(master, data)
[10:26:27.504]                             }
[10:26:27.504]                             return(sendCondition)
[10:26:27.504]                           }
[10:26:27.504]                         }
[10:26:27.504]                         frame <- frame + 1L
[10:26:27.504]                         envir <- sys.frame(frame)
[10:26:27.504]                       }
[10:26:27.504]                     }
[10:26:27.504]                     sendCondition <<- function(cond) NULL
[10:26:27.504]                   }
[10:26:27.504]                 })
[10:26:27.504]                 withCallingHandlers({
[10:26:27.504]                   {
[10:26:27.504]                     gc()
[10:26:27.504]                   }
[10:26:27.504]                 }, immediateCondition = function(cond) {
[10:26:27.504]                   sendCondition <- ...future.makeSendCondition()
[10:26:27.504]                   sendCondition(cond)
[10:26:27.504]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:27.504]                   {
[10:26:27.504]                     inherits <- base::inherits
[10:26:27.504]                     invokeRestart <- base::invokeRestart
[10:26:27.504]                     is.null <- base::is.null
[10:26:27.504]                     muffled <- FALSE
[10:26:27.504]                     if (inherits(cond, "message")) {
[10:26:27.504]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:27.504]                       if (muffled) 
[10:26:27.504]                         invokeRestart("muffleMessage")
[10:26:27.504]                     }
[10:26:27.504]                     else if (inherits(cond, "warning")) {
[10:26:27.504]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:27.504]                       if (muffled) 
[10:26:27.504]                         invokeRestart("muffleWarning")
[10:26:27.504]                     }
[10:26:27.504]                     else if (inherits(cond, "condition")) {
[10:26:27.504]                       if (!is.null(pattern)) {
[10:26:27.504]                         computeRestarts <- base::computeRestarts
[10:26:27.504]                         grepl <- base::grepl
[10:26:27.504]                         restarts <- computeRestarts(cond)
[10:26:27.504]                         for (restart in restarts) {
[10:26:27.504]                           name <- restart$name
[10:26:27.504]                           if (is.null(name)) 
[10:26:27.504]                             next
[10:26:27.504]                           if (!grepl(pattern, name)) 
[10:26:27.504]                             next
[10:26:27.504]                           invokeRestart(restart)
[10:26:27.504]                           muffled <- TRUE
[10:26:27.504]                           break
[10:26:27.504]                         }
[10:26:27.504]                       }
[10:26:27.504]                     }
[10:26:27.504]                     invisible(muffled)
[10:26:27.504]                   }
[10:26:27.504]                   muffleCondition(cond)
[10:26:27.504]                 })
[10:26:27.504]             }))
[10:26:27.504]             future::FutureResult(value = ...future.value$value, 
[10:26:27.504]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:27.504]                   ...future.rng), globalenv = if (FALSE) 
[10:26:27.504]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:27.504]                     ...future.globalenv.names))
[10:26:27.504]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:27.504]         }, condition = base::local({
[10:26:27.504]             c <- base::c
[10:26:27.504]             inherits <- base::inherits
[10:26:27.504]             invokeRestart <- base::invokeRestart
[10:26:27.504]             length <- base::length
[10:26:27.504]             list <- base::list
[10:26:27.504]             seq.int <- base::seq.int
[10:26:27.504]             signalCondition <- base::signalCondition
[10:26:27.504]             sys.calls <- base::sys.calls
[10:26:27.504]             `[[` <- base::`[[`
[10:26:27.504]             `+` <- base::`+`
[10:26:27.504]             `<<-` <- base::`<<-`
[10:26:27.504]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:27.504]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:27.504]                   3L)]
[10:26:27.504]             }
[10:26:27.504]             function(cond) {
[10:26:27.504]                 is_error <- inherits(cond, "error")
[10:26:27.504]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:27.504]                   NULL)
[10:26:27.504]                 if (is_error) {
[10:26:27.504]                   sessionInformation <- function() {
[10:26:27.504]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:27.504]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:27.504]                       search = base::search(), system = base::Sys.info())
[10:26:27.504]                   }
[10:26:27.504]                   ...future.conditions[[length(...future.conditions) + 
[10:26:27.504]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:27.504]                     cond$call), session = sessionInformation(), 
[10:26:27.504]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:27.504]                   signalCondition(cond)
[10:26:27.504]                 }
[10:26:27.504]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:27.504]                 "immediateCondition"))) {
[10:26:27.504]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:27.504]                   ...future.conditions[[length(...future.conditions) + 
[10:26:27.504]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:27.504]                   if (TRUE && !signal) {
[10:26:27.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:27.504]                     {
[10:26:27.504]                       inherits <- base::inherits
[10:26:27.504]                       invokeRestart <- base::invokeRestart
[10:26:27.504]                       is.null <- base::is.null
[10:26:27.504]                       muffled <- FALSE
[10:26:27.504]                       if (inherits(cond, "message")) {
[10:26:27.504]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:27.504]                         if (muffled) 
[10:26:27.504]                           invokeRestart("muffleMessage")
[10:26:27.504]                       }
[10:26:27.504]                       else if (inherits(cond, "warning")) {
[10:26:27.504]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:27.504]                         if (muffled) 
[10:26:27.504]                           invokeRestart("muffleWarning")
[10:26:27.504]                       }
[10:26:27.504]                       else if (inherits(cond, "condition")) {
[10:26:27.504]                         if (!is.null(pattern)) {
[10:26:27.504]                           computeRestarts <- base::computeRestarts
[10:26:27.504]                           grepl <- base::grepl
[10:26:27.504]                           restarts <- computeRestarts(cond)
[10:26:27.504]                           for (restart in restarts) {
[10:26:27.504]                             name <- restart$name
[10:26:27.504]                             if (is.null(name)) 
[10:26:27.504]                               next
[10:26:27.504]                             if (!grepl(pattern, name)) 
[10:26:27.504]                               next
[10:26:27.504]                             invokeRestart(restart)
[10:26:27.504]                             muffled <- TRUE
[10:26:27.504]                             break
[10:26:27.504]                           }
[10:26:27.504]                         }
[10:26:27.504]                       }
[10:26:27.504]                       invisible(muffled)
[10:26:27.504]                     }
[10:26:27.504]                     muffleCondition(cond, pattern = "^muffle")
[10:26:27.504]                   }
[10:26:27.504]                 }
[10:26:27.504]                 else {
[10:26:27.504]                   if (TRUE) {
[10:26:27.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:27.504]                     {
[10:26:27.504]                       inherits <- base::inherits
[10:26:27.504]                       invokeRestart <- base::invokeRestart
[10:26:27.504]                       is.null <- base::is.null
[10:26:27.504]                       muffled <- FALSE
[10:26:27.504]                       if (inherits(cond, "message")) {
[10:26:27.504]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:27.504]                         if (muffled) 
[10:26:27.504]                           invokeRestart("muffleMessage")
[10:26:27.504]                       }
[10:26:27.504]                       else if (inherits(cond, "warning")) {
[10:26:27.504]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:27.504]                         if (muffled) 
[10:26:27.504]                           invokeRestart("muffleWarning")
[10:26:27.504]                       }
[10:26:27.504]                       else if (inherits(cond, "condition")) {
[10:26:27.504]                         if (!is.null(pattern)) {
[10:26:27.504]                           computeRestarts <- base::computeRestarts
[10:26:27.504]                           grepl <- base::grepl
[10:26:27.504]                           restarts <- computeRestarts(cond)
[10:26:27.504]                           for (restart in restarts) {
[10:26:27.504]                             name <- restart$name
[10:26:27.504]                             if (is.null(name)) 
[10:26:27.504]                               next
[10:26:27.504]                             if (!grepl(pattern, name)) 
[10:26:27.504]                               next
[10:26:27.504]                             invokeRestart(restart)
[10:26:27.504]                             muffled <- TRUE
[10:26:27.504]                             break
[10:26:27.504]                           }
[10:26:27.504]                         }
[10:26:27.504]                       }
[10:26:27.504]                       invisible(muffled)
[10:26:27.504]                     }
[10:26:27.504]                     muffleCondition(cond, pattern = "^muffle")
[10:26:27.504]                   }
[10:26:27.504]                 }
[10:26:27.504]             }
[10:26:27.504]         }))
[10:26:27.504]     }, error = function(ex) {
[10:26:27.504]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:27.504]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:27.504]                 ...future.rng), started = ...future.startTime, 
[10:26:27.504]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:27.504]             version = "1.8"), class = "FutureResult")
[10:26:27.504]     }, finally = {
[10:26:27.504]         if (!identical(...future.workdir, getwd())) 
[10:26:27.504]             setwd(...future.workdir)
[10:26:27.504]         {
[10:26:27.504]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:27.504]                 ...future.oldOptions$nwarnings <- NULL
[10:26:27.504]             }
[10:26:27.504]             base::options(...future.oldOptions)
[10:26:27.504]             if (.Platform$OS.type == "windows") {
[10:26:27.504]                 old_names <- names(...future.oldEnvVars)
[10:26:27.504]                 envs <- base::Sys.getenv()
[10:26:27.504]                 names <- names(envs)
[10:26:27.504]                 common <- intersect(names, old_names)
[10:26:27.504]                 added <- setdiff(names, old_names)
[10:26:27.504]                 removed <- setdiff(old_names, names)
[10:26:27.504]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:27.504]                   envs[common]]
[10:26:27.504]                 NAMES <- toupper(changed)
[10:26:27.504]                 args <- list()
[10:26:27.504]                 for (kk in seq_along(NAMES)) {
[10:26:27.504]                   name <- changed[[kk]]
[10:26:27.504]                   NAME <- NAMES[[kk]]
[10:26:27.504]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:27.504]                     next
[10:26:27.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:27.504]                 }
[10:26:27.504]                 NAMES <- toupper(added)
[10:26:27.504]                 for (kk in seq_along(NAMES)) {
[10:26:27.504]                   name <- added[[kk]]
[10:26:27.504]                   NAME <- NAMES[[kk]]
[10:26:27.504]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:27.504]                     next
[10:26:27.504]                   args[[name]] <- ""
[10:26:27.504]                 }
[10:26:27.504]                 NAMES <- toupper(removed)
[10:26:27.504]                 for (kk in seq_along(NAMES)) {
[10:26:27.504]                   name <- removed[[kk]]
[10:26:27.504]                   NAME <- NAMES[[kk]]
[10:26:27.504]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:27.504]                     next
[10:26:27.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:27.504]                 }
[10:26:27.504]                 if (length(args) > 0) 
[10:26:27.504]                   base::do.call(base::Sys.setenv, args = args)
[10:26:27.504]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:27.504]             }
[10:26:27.504]             else {
[10:26:27.504]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:27.504]             }
[10:26:27.504]             {
[10:26:27.504]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:27.504]                   0L) {
[10:26:27.504]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:27.504]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:27.504]                   base::options(opts)
[10:26:27.504]                 }
[10:26:27.504]                 {
[10:26:27.504]                   {
[10:26:27.504]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:27.504]                     NULL
[10:26:27.504]                   }
[10:26:27.504]                   options(future.plan = NULL)
[10:26:27.504]                   if (is.na(NA_character_)) 
[10:26:27.504]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:27.504]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:27.504]                   future::plan(list(function (..., workers = 2L, 
[10:26:27.504]                     envir = parent.frame()) 
[10:26:27.504]                   strategy(..., workers = workers, envir = envir)), 
[10:26:27.504]                     .cleanup = FALSE, .init = FALSE)
[10:26:27.504]                 }
[10:26:27.504]             }
[10:26:27.504]         }
[10:26:27.504]     })
[10:26:27.504]     if (TRUE) {
[10:26:27.504]         base::sink(type = "output", split = FALSE)
[10:26:27.504]         if (TRUE) {
[10:26:27.504]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:27.504]         }
[10:26:27.504]         else {
[10:26:27.504]             ...future.result["stdout"] <- base::list(NULL)
[10:26:27.504]         }
[10:26:27.504]         base::close(...future.stdout)
[10:26:27.504]         ...future.stdout <- NULL
[10:26:27.504]     }
[10:26:27.504]     ...future.result$conditions <- ...future.conditions
[10:26:27.504]     ...future.result$finished <- base::Sys.time()
[10:26:27.504]     ...future.result
[10:26:27.504] }
[10:26:27.507] MultisessionFuture started
[10:26:27.507] - Launch lazy future ... done
[10:26:27.507] run() for ‘MultisessionFuture’ ... done
> v <- value(f)
[10:26:27.507] result() for ClusterFuture ...
[10:26:27.507] receiveMessageFromWorker() for ClusterFuture ...
[10:26:27.507] - Validating connection of MultisessionFuture
[10:26:27.573] - received message: FutureResult
[10:26:27.573] - Received FutureResult
[10:26:27.573] - Erased future from FutureRegistry
[10:26:27.574] result() for ClusterFuture ...
[10:26:27.574] - result already collected: FutureResult
[10:26:27.574] result() for ClusterFuture ... done
[10:26:27.574] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:27.574] result() for ClusterFuture ... done
[10:26:27.574] result() for ClusterFuture ...
[10:26:27.574] - result already collected: FutureResult
[10:26:27.574] result() for ClusterFuture ... done
> print(v)
         used (Mb) gc trigger  (Mb) max used  (Mb)
Ncells 395204 21.2     836944  44.7   664120  35.5
Vcells 704817  5.4   13457836 102.7 15781226 120.5
> 
> message("*** multisession(..., gc = TRUE) ... TRUE")
*** multisession(..., gc = TRUE) ... TRUE
> 
> 
> message("*** multisession(...) - stopping with plan() change ...")
*** multisession(...) - stopping with plan() change ...
>   
> plan(multisession, workers = 2L)
[10:26:27.575] plan(): Setting new future strategy stack:
[10:26:27.575] List of future strategies:
[10:26:27.575] 1. multisession:
[10:26:27.575]    - args: function (..., workers = 2L, envir = parent.frame())
[10:26:27.575]    - tweaked: TRUE
[10:26:27.575]    - call: plan(multisession, workers = 2L)
[10:26:27.576] plan(): plan_init() of ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:26:27.576] multisession:
[10:26:27.576] - args: function (..., workers = 2L, envir = parent.frame())
[10:26:27.576] - tweaked: TRUE
[10:26:27.576] - call: plan(multisession, workers = 2L)
[10:26:27.576] getGlobalsAndPackages() ...
[10:26:27.577] Not searching for globals
[10:26:27.577] - globals: [0] <none>
[10:26:27.577] getGlobalsAndPackages() ... DONE
[10:26:27.578] [local output] makeClusterPSOCK() ...
[10:26:27.582] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:26:27.583] [local output] Base port: 11503
[10:26:27.583] [local output] Getting setup options for 2 cluster nodes ...
[10:26:27.583] [local output]  - Node 1 of 2 ...
[10:26:27.584] [local output] localMachine=TRUE => revtunnel=FALSE

[10:26:27.585] [local output] Rscript port: 11503

[10:26:27.585] [local output]  - Node 2 of 2 ...
[10:26:27.586] [local output] localMachine=TRUE => revtunnel=FALSE

[10:26:27.587] [local output] Rscript port: 11503

[10:26:27.587] [local output] Getting setup options for 2 cluster nodes ... done
[10:26:27.588] [local output]  - Parallel setup requested for some PSOCK nodes
[10:26:27.588] [local output] Setting up PSOCK nodes in parallel
[10:26:27.588] List of 36
[10:26:27.588]  $ worker          : chr "localhost"
[10:26:27.588]   ..- attr(*, "localhost")= logi TRUE
[10:26:27.588]  $ master          : chr "localhost"
[10:26:27.588]  $ port            : int 11503
[10:26:27.588]  $ connectTimeout  : num 120
[10:26:27.588]  $ timeout         : num 2592000
[10:26:27.588]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:26:27.588]  $ homogeneous     : logi TRUE
[10:26:27.588]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:26:27.588]  $ rscript_envs    : NULL
[10:26:27.588]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:26:27.588]  $ rscript_startup : NULL
[10:26:27.588]  $ rscript_sh      : chr "sh"
[10:26:27.588]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:26:27.588]  $ methods         : logi TRUE
[10:26:27.588]  $ socketOptions   : chr "no-delay"
[10:26:27.588]  $ useXDR          : logi FALSE
[10:26:27.588]  $ outfile         : chr "/dev/null"
[10:26:27.588]  $ renice          : int NA
[10:26:27.588]  $ rshcmd          : NULL
[10:26:27.588]  $ user            : chr(0) 
[10:26:27.588]  $ revtunnel       : logi FALSE
[10:26:27.588]  $ rshlogfile      : NULL
[10:26:27.588]  $ rshopts         : chr(0) 
[10:26:27.588]  $ rank            : int 1
[10:26:27.588]  $ manual          : logi FALSE
[10:26:27.588]  $ dryrun          : logi FALSE
[10:26:27.588]  $ quiet           : logi FALSE
[10:26:27.588]  $ setup_strategy  : chr "parallel"
[10:26:27.588]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:26:27.588]  $ pidfile         : chr "/tmp/RtmpLA4GNs/worker.rank=1.parallelly.parent=87451.1559b2a66f9b5.pid"
[10:26:27.588]  $ rshcmd_label    : NULL
[10:26:27.588]  $ rsh_call        : NULL
[10:26:27.588]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:26:27.588]  $ localMachine    : logi TRUE
[10:26:27.588]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:26:27.588]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:26:27.588]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:26:27.588]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:26:27.588]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:26:27.588]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:26:27.588]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:26:27.588]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:26:27.588]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:26:27.588]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:26:27.588]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:26:27.588]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:26:27.588]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:26:27.588]  $ arguments       :List of 28
[10:26:27.588]   ..$ worker          : chr "localhost"
[10:26:27.588]   ..$ master          : NULL
[10:26:27.588]   ..$ port            : int 11503
[10:26:27.588]   ..$ connectTimeout  : num 120
[10:26:27.588]   ..$ timeout         : num 2592000
[10:26:27.588]   ..$ rscript         : NULL
[10:26:27.588]   ..$ homogeneous     : NULL
[10:26:27.588]   ..$ rscript_args    : NULL
[10:26:27.588]   ..$ rscript_envs    : NULL
[10:26:27.588]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:26:27.588]   ..$ rscript_startup : NULL
[10:26:27.588]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:26:27.588]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:26:27.588]   ..$ methods         : logi TRUE
[10:26:27.588]   ..$ socketOptions   : chr "no-delay"
[10:26:27.588]   ..$ useXDR          : logi FALSE
[10:26:27.588]   ..$ outfile         : chr "/dev/null"
[10:26:27.588]   ..$ renice          : int NA
[10:26:27.588]   ..$ rshcmd          : NULL
[10:26:27.588]   ..$ user            : NULL
[10:26:27.588]   ..$ revtunnel       : logi NA
[10:26:27.588]   ..$ rshlogfile      : NULL
[10:26:27.588]   ..$ rshopts         : NULL
[10:26:27.588]   ..$ rank            : int 1
[10:26:27.588]   ..$ manual          : logi FALSE
[10:26:27.588]   ..$ dryrun          : logi FALSE
[10:26:27.588]   ..$ quiet           : logi FALSE
[10:26:27.588]   ..$ setup_strategy  : chr "parallel"
[10:26:27.588]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:26:27.608] [local output] System call to launch all workers:
[10:26:27.608] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpLA4GNs/worker.rank=1.parallelly.parent=87451.1559b2a66f9b5.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11503 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:26:27.608] [local output] Starting PSOCK main server
[10:26:27.610] [local output] Workers launched
[10:26:27.610] [local output] Waiting for workers to connect back
[10:26:27.610]  - [local output] 0 workers out of 2 ready
[10:26:27.853]  - [local output] 0 workers out of 2 ready
[10:26:27.854]  - [local output] 1 workers out of 2 ready
[10:26:27.854]  - [local output] 2 workers out of 2 ready
[10:26:27.854] [local output] Launching of workers completed
[10:26:27.854] [local output] Collecting session information from workers
[10:26:27.855] [local output]  - Worker #1 of 2
[10:26:27.855] [local output]  - Worker #2 of 2
[10:26:27.856] [local output] makeClusterPSOCK() ... done
[10:26:27.866] Packages needed by the future expression (n = 0): <none>
[10:26:27.866] Packages needed by future strategies (n = 0): <none>
[10:26:27.867] {
[10:26:27.867]     {
[10:26:27.867]         {
[10:26:27.867]             ...future.startTime <- base::Sys.time()
[10:26:27.867]             {
[10:26:27.867]                 {
[10:26:27.867]                   {
[10:26:27.867]                     {
[10:26:27.867]                       base::local({
[10:26:27.867]                         has_future <- base::requireNamespace("future", 
[10:26:27.867]                           quietly = TRUE)
[10:26:27.867]                         if (has_future) {
[10:26:27.867]                           ns <- base::getNamespace("future")
[10:26:27.867]                           version <- ns[[".package"]][["version"]]
[10:26:27.867]                           if (is.null(version)) 
[10:26:27.867]                             version <- utils::packageVersion("future")
[10:26:27.867]                         }
[10:26:27.867]                         else {
[10:26:27.867]                           version <- NULL
[10:26:27.867]                         }
[10:26:27.867]                         if (!has_future || version < "1.8.0") {
[10:26:27.867]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:27.867]                             "", base::R.version$version.string), 
[10:26:27.867]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:27.867]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:27.867]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:27.867]                               "release", "version")], collapse = " "), 
[10:26:27.867]                             hostname = base::Sys.info()[["nodename"]])
[10:26:27.867]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:27.867]                             info)
[10:26:27.867]                           info <- base::paste(info, collapse = "; ")
[10:26:27.867]                           if (!has_future) {
[10:26:27.867]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:27.867]                               info)
[10:26:27.867]                           }
[10:26:27.867]                           else {
[10:26:27.867]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:27.867]                               info, version)
[10:26:27.867]                           }
[10:26:27.867]                           base::stop(msg)
[10:26:27.867]                         }
[10:26:27.867]                       })
[10:26:27.867]                     }
[10:26:27.867]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:27.867]                     base::options(mc.cores = 1L)
[10:26:27.867]                   }
[10:26:27.867]                   options(future.plan = NULL)
[10:26:27.867]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:27.867]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:27.867]                 }
[10:26:27.867]                 ...future.workdir <- getwd()
[10:26:27.867]             }
[10:26:27.867]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:27.867]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:27.867]         }
[10:26:27.867]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:27.867]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:27.867]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:27.867]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:27.867]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:27.867]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:27.867]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:27.867]             base::names(...future.oldOptions))
[10:26:27.867]     }
[10:26:27.867]     if (FALSE) {
[10:26:27.867]     }
[10:26:27.867]     else {
[10:26:27.867]         if (TRUE) {
[10:26:27.867]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:27.867]                 open = "w")
[10:26:27.867]         }
[10:26:27.867]         else {
[10:26:27.867]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:27.867]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:27.867]         }
[10:26:27.867]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:27.867]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:27.867]             base::sink(type = "output", split = FALSE)
[10:26:27.867]             base::close(...future.stdout)
[10:26:27.867]         }, add = TRUE)
[10:26:27.867]     }
[10:26:27.867]     ...future.frame <- base::sys.nframe()
[10:26:27.867]     ...future.conditions <- base::list()
[10:26:27.867]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:27.867]     if (FALSE) {
[10:26:27.867]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:27.867]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:27.867]     }
[10:26:27.867]     ...future.result <- base::tryCatch({
[10:26:27.867]         base::withCallingHandlers({
[10:26:27.867]             ...future.value <- base::withVisible(base::local({
[10:26:27.867]                 ...future.makeSendCondition <- base::local({
[10:26:27.867]                   sendCondition <- NULL
[10:26:27.867]                   function(frame = 1L) {
[10:26:27.867]                     if (is.function(sendCondition)) 
[10:26:27.867]                       return(sendCondition)
[10:26:27.867]                     ns <- getNamespace("parallel")
[10:26:27.867]                     if (exists("sendData", mode = "function", 
[10:26:27.867]                       envir = ns)) {
[10:26:27.867]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:27.867]                         envir = ns)
[10:26:27.867]                       envir <- sys.frame(frame)
[10:26:27.867]                       master <- NULL
[10:26:27.867]                       while (!identical(envir, .GlobalEnv) && 
[10:26:27.867]                         !identical(envir, emptyenv())) {
[10:26:27.867]                         if (exists("master", mode = "list", envir = envir, 
[10:26:27.867]                           inherits = FALSE)) {
[10:26:27.867]                           master <- get("master", mode = "list", 
[10:26:27.867]                             envir = envir, inherits = FALSE)
[10:26:27.867]                           if (inherits(master, c("SOCKnode", 
[10:26:27.867]                             "SOCK0node"))) {
[10:26:27.867]                             sendCondition <<- function(cond) {
[10:26:27.867]                               data <- list(type = "VALUE", value = cond, 
[10:26:27.867]                                 success = TRUE)
[10:26:27.867]                               parallel_sendData(master, data)
[10:26:27.867]                             }
[10:26:27.867]                             return(sendCondition)
[10:26:27.867]                           }
[10:26:27.867]                         }
[10:26:27.867]                         frame <- frame + 1L
[10:26:27.867]                         envir <- sys.frame(frame)
[10:26:27.867]                       }
[10:26:27.867]                     }
[10:26:27.867]                     sendCondition <<- function(cond) NULL
[10:26:27.867]                   }
[10:26:27.867]                 })
[10:26:27.867]                 withCallingHandlers({
[10:26:27.867]                   NA
[10:26:27.867]                 }, immediateCondition = function(cond) {
[10:26:27.867]                   sendCondition <- ...future.makeSendCondition()
[10:26:27.867]                   sendCondition(cond)
[10:26:27.867]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:27.867]                   {
[10:26:27.867]                     inherits <- base::inherits
[10:26:27.867]                     invokeRestart <- base::invokeRestart
[10:26:27.867]                     is.null <- base::is.null
[10:26:27.867]                     muffled <- FALSE
[10:26:27.867]                     if (inherits(cond, "message")) {
[10:26:27.867]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:27.867]                       if (muffled) 
[10:26:27.867]                         invokeRestart("muffleMessage")
[10:26:27.867]                     }
[10:26:27.867]                     else if (inherits(cond, "warning")) {
[10:26:27.867]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:27.867]                       if (muffled) 
[10:26:27.867]                         invokeRestart("muffleWarning")
[10:26:27.867]                     }
[10:26:27.867]                     else if (inherits(cond, "condition")) {
[10:26:27.867]                       if (!is.null(pattern)) {
[10:26:27.867]                         computeRestarts <- base::computeRestarts
[10:26:27.867]                         grepl <- base::grepl
[10:26:27.867]                         restarts <- computeRestarts(cond)
[10:26:27.867]                         for (restart in restarts) {
[10:26:27.867]                           name <- restart$name
[10:26:27.867]                           if (is.null(name)) 
[10:26:27.867]                             next
[10:26:27.867]                           if (!grepl(pattern, name)) 
[10:26:27.867]                             next
[10:26:27.867]                           invokeRestart(restart)
[10:26:27.867]                           muffled <- TRUE
[10:26:27.867]                           break
[10:26:27.867]                         }
[10:26:27.867]                       }
[10:26:27.867]                     }
[10:26:27.867]                     invisible(muffled)
[10:26:27.867]                   }
[10:26:27.867]                   muffleCondition(cond)
[10:26:27.867]                 })
[10:26:27.867]             }))
[10:26:27.867]             future::FutureResult(value = ...future.value$value, 
[10:26:27.867]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:27.867]                   ...future.rng), globalenv = if (FALSE) 
[10:26:27.867]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:27.867]                     ...future.globalenv.names))
[10:26:27.867]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:27.867]         }, condition = base::local({
[10:26:27.867]             c <- base::c
[10:26:27.867]             inherits <- base::inherits
[10:26:27.867]             invokeRestart <- base::invokeRestart
[10:26:27.867]             length <- base::length
[10:26:27.867]             list <- base::list
[10:26:27.867]             seq.int <- base::seq.int
[10:26:27.867]             signalCondition <- base::signalCondition
[10:26:27.867]             sys.calls <- base::sys.calls
[10:26:27.867]             `[[` <- base::`[[`
[10:26:27.867]             `+` <- base::`+`
[10:26:27.867]             `<<-` <- base::`<<-`
[10:26:27.867]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:27.867]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:27.867]                   3L)]
[10:26:27.867]             }
[10:26:27.867]             function(cond) {
[10:26:27.867]                 is_error <- inherits(cond, "error")
[10:26:27.867]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:27.867]                   NULL)
[10:26:27.867]                 if (is_error) {
[10:26:27.867]                   sessionInformation <- function() {
[10:26:27.867]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:27.867]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:27.867]                       search = base::search(), system = base::Sys.info())
[10:26:27.867]                   }
[10:26:27.867]                   ...future.conditions[[length(...future.conditions) + 
[10:26:27.867]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:27.867]                     cond$call), session = sessionInformation(), 
[10:26:27.867]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:27.867]                   signalCondition(cond)
[10:26:27.867]                 }
[10:26:27.867]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:27.867]                 "immediateCondition"))) {
[10:26:27.867]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:27.867]                   ...future.conditions[[length(...future.conditions) + 
[10:26:27.867]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:27.867]                   if (TRUE && !signal) {
[10:26:27.867]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:27.867]                     {
[10:26:27.867]                       inherits <- base::inherits
[10:26:27.867]                       invokeRestart <- base::invokeRestart
[10:26:27.867]                       is.null <- base::is.null
[10:26:27.867]                       muffled <- FALSE
[10:26:27.867]                       if (inherits(cond, "message")) {
[10:26:27.867]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:27.867]                         if (muffled) 
[10:26:27.867]                           invokeRestart("muffleMessage")
[10:26:27.867]                       }
[10:26:27.867]                       else if (inherits(cond, "warning")) {
[10:26:27.867]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:27.867]                         if (muffled) 
[10:26:27.867]                           invokeRestart("muffleWarning")
[10:26:27.867]                       }
[10:26:27.867]                       else if (inherits(cond, "condition")) {
[10:26:27.867]                         if (!is.null(pattern)) {
[10:26:27.867]                           computeRestarts <- base::computeRestarts
[10:26:27.867]                           grepl <- base::grepl
[10:26:27.867]                           restarts <- computeRestarts(cond)
[10:26:27.867]                           for (restart in restarts) {
[10:26:27.867]                             name <- restart$name
[10:26:27.867]                             if (is.null(name)) 
[10:26:27.867]                               next
[10:26:27.867]                             if (!grepl(pattern, name)) 
[10:26:27.867]                               next
[10:26:27.867]                             invokeRestart(restart)
[10:26:27.867]                             muffled <- TRUE
[10:26:27.867]                             break
[10:26:27.867]                           }
[10:26:27.867]                         }
[10:26:27.867]                       }
[10:26:27.867]                       invisible(muffled)
[10:26:27.867]                     }
[10:26:27.867]                     muffleCondition(cond, pattern = "^muffle")
[10:26:27.867]                   }
[10:26:27.867]                 }
[10:26:27.867]                 else {
[10:26:27.867]                   if (TRUE) {
[10:26:27.867]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:27.867]                     {
[10:26:27.867]                       inherits <- base::inherits
[10:26:27.867]                       invokeRestart <- base::invokeRestart
[10:26:27.867]                       is.null <- base::is.null
[10:26:27.867]                       muffled <- FALSE
[10:26:27.867]                       if (inherits(cond, "message")) {
[10:26:27.867]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:27.867]                         if (muffled) 
[10:26:27.867]                           invokeRestart("muffleMessage")
[10:26:27.867]                       }
[10:26:27.867]                       else if (inherits(cond, "warning")) {
[10:26:27.867]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:27.867]                         if (muffled) 
[10:26:27.867]                           invokeRestart("muffleWarning")
[10:26:27.867]                       }
[10:26:27.867]                       else if (inherits(cond, "condition")) {
[10:26:27.867]                         if (!is.null(pattern)) {
[10:26:27.867]                           computeRestarts <- base::computeRestarts
[10:26:27.867]                           grepl <- base::grepl
[10:26:27.867]                           restarts <- computeRestarts(cond)
[10:26:27.867]                           for (restart in restarts) {
[10:26:27.867]                             name <- restart$name
[10:26:27.867]                             if (is.null(name)) 
[10:26:27.867]                               next
[10:26:27.867]                             if (!grepl(pattern, name)) 
[10:26:27.867]                               next
[10:26:27.867]                             invokeRestart(restart)
[10:26:27.867]                             muffled <- TRUE
[10:26:27.867]                             break
[10:26:27.867]                           }
[10:26:27.867]                         }
[10:26:27.867]                       }
[10:26:27.867]                       invisible(muffled)
[10:26:27.867]                     }
[10:26:27.867]                     muffleCondition(cond, pattern = "^muffle")
[10:26:27.867]                   }
[10:26:27.867]                 }
[10:26:27.867]             }
[10:26:27.867]         }))
[10:26:27.867]     }, error = function(ex) {
[10:26:27.867]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:27.867]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:27.867]                 ...future.rng), started = ...future.startTime, 
[10:26:27.867]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:27.867]             version = "1.8"), class = "FutureResult")
[10:26:27.867]     }, finally = {
[10:26:27.867]         if (!identical(...future.workdir, getwd())) 
[10:26:27.867]             setwd(...future.workdir)
[10:26:27.867]         {
[10:26:27.867]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:27.867]                 ...future.oldOptions$nwarnings <- NULL
[10:26:27.867]             }
[10:26:27.867]             base::options(...future.oldOptions)
[10:26:27.867]             if (.Platform$OS.type == "windows") {
[10:26:27.867]                 old_names <- names(...future.oldEnvVars)
[10:26:27.867]                 envs <- base::Sys.getenv()
[10:26:27.867]                 names <- names(envs)
[10:26:27.867]                 common <- intersect(names, old_names)
[10:26:27.867]                 added <- setdiff(names, old_names)
[10:26:27.867]                 removed <- setdiff(old_names, names)
[10:26:27.867]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:27.867]                   envs[common]]
[10:26:27.867]                 NAMES <- toupper(changed)
[10:26:27.867]                 args <- list()
[10:26:27.867]                 for (kk in seq_along(NAMES)) {
[10:26:27.867]                   name <- changed[[kk]]
[10:26:27.867]                   NAME <- NAMES[[kk]]
[10:26:27.867]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:27.867]                     next
[10:26:27.867]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:27.867]                 }
[10:26:27.867]                 NAMES <- toupper(added)
[10:26:27.867]                 for (kk in seq_along(NAMES)) {
[10:26:27.867]                   name <- added[[kk]]
[10:26:27.867]                   NAME <- NAMES[[kk]]
[10:26:27.867]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:27.867]                     next
[10:26:27.867]                   args[[name]] <- ""
[10:26:27.867]                 }
[10:26:27.867]                 NAMES <- toupper(removed)
[10:26:27.867]                 for (kk in seq_along(NAMES)) {
[10:26:27.867]                   name <- removed[[kk]]
[10:26:27.867]                   NAME <- NAMES[[kk]]
[10:26:27.867]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:27.867]                     next
[10:26:27.867]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:27.867]                 }
[10:26:27.867]                 if (length(args) > 0) 
[10:26:27.867]                   base::do.call(base::Sys.setenv, args = args)
[10:26:27.867]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:27.867]             }
[10:26:27.867]             else {
[10:26:27.867]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:27.867]             }
[10:26:27.867]             {
[10:26:27.867]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:27.867]                   0L) {
[10:26:27.867]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:27.867]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:27.867]                   base::options(opts)
[10:26:27.867]                 }
[10:26:27.867]                 {
[10:26:27.867]                   {
[10:26:27.867]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:27.867]                     NULL
[10:26:27.867]                   }
[10:26:27.867]                   options(future.plan = NULL)
[10:26:27.867]                   if (is.na(NA_character_)) 
[10:26:27.867]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:27.867]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:27.867]                   future::plan(list(function (..., workers = 2L, 
[10:26:27.867]                     envir = parent.frame()) 
[10:26:27.867]                   strategy(..., workers = workers, envir = envir)), 
[10:26:27.867]                     .cleanup = FALSE, .init = FALSE)
[10:26:27.867]                 }
[10:26:27.867]             }
[10:26:27.867]         }
[10:26:27.867]     })
[10:26:27.867]     if (TRUE) {
[10:26:27.867]         base::sink(type = "output", split = FALSE)
[10:26:27.867]         if (TRUE) {
[10:26:27.867]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:27.867]         }
[10:26:27.867]         else {
[10:26:27.867]             ...future.result["stdout"] <- base::list(NULL)
[10:26:27.867]         }
[10:26:27.867]         base::close(...future.stdout)
[10:26:27.867]         ...future.stdout <- NULL
[10:26:27.867]     }
[10:26:27.867]     ...future.result$conditions <- ...future.conditions
[10:26:27.867]     ...future.result$finished <- base::Sys.time()
[10:26:27.867]     ...future.result
[10:26:27.867] }
[10:26:27.921] MultisessionFuture started
[10:26:27.921] result() for ClusterFuture ...
[10:26:27.921] receiveMessageFromWorker() for ClusterFuture ...
[10:26:27.921] - Validating connection of MultisessionFuture
[10:26:27.954] - received message: FutureResult
[10:26:27.954] - Received FutureResult
[10:26:27.955] - Erased future from FutureRegistry
[10:26:27.955] result() for ClusterFuture ...
[10:26:27.955] - result already collected: FutureResult
[10:26:27.955] result() for ClusterFuture ... done
[10:26:27.955] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:27.955] result() for ClusterFuture ... done
[10:26:27.955] result() for ClusterFuture ...
[10:26:27.955] - result already collected: FutureResult
[10:26:27.955] result() for ClusterFuture ... done
[10:26:27.955] plan(): plan_init() of ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:26:27.956] plan(): nbrOfWorkers() = 2
> f <- future(1L)
[10:26:27.956] getGlobalsAndPackages() ...
[10:26:27.956] Searching for globals...
[10:26:27.956] 
[10:26:27.956] Searching for globals ... DONE
[10:26:27.956] - globals: [0] <none>
[10:26:27.957] getGlobalsAndPackages() ... DONE
[10:26:27.957] run() for ‘Future’ ...
[10:26:27.957] - state: ‘created’
[10:26:27.957] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:27.968] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:27.968] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:27.968]   - Field: ‘node’
[10:26:27.968]   - Field: ‘label’
[10:26:27.968]   - Field: ‘local’
[10:26:27.968]   - Field: ‘owner’
[10:26:27.968]   - Field: ‘envir’
[10:26:27.968]   - Field: ‘workers’
[10:26:27.968]   - Field: ‘packages’
[10:26:27.969]   - Field: ‘gc’
[10:26:27.969]   - Field: ‘conditions’
[10:26:27.969]   - Field: ‘persistent’
[10:26:27.969]   - Field: ‘expr’
[10:26:27.969]   - Field: ‘uuid’
[10:26:27.969]   - Field: ‘seed’
[10:26:27.969]   - Field: ‘version’
[10:26:27.969]   - Field: ‘result’
[10:26:27.969]   - Field: ‘asynchronous’
[10:26:27.969]   - Field: ‘calls’
[10:26:27.969]   - Field: ‘globals’
[10:26:27.970]   - Field: ‘stdout’
[10:26:27.970]   - Field: ‘earlySignal’
[10:26:27.970]   - Field: ‘lazy’
[10:26:27.970]   - Field: ‘state’
[10:26:27.970] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:27.970] - Launch lazy future ...
[10:26:27.970] Packages needed by the future expression (n = 0): <none>
[10:26:27.970] Packages needed by future strategies (n = 0): <none>
[10:26:27.971] {
[10:26:27.971]     {
[10:26:27.971]         {
[10:26:27.971]             ...future.startTime <- base::Sys.time()
[10:26:27.971]             {
[10:26:27.971]                 {
[10:26:27.971]                   {
[10:26:27.971]                     {
[10:26:27.971]                       base::local({
[10:26:27.971]                         has_future <- base::requireNamespace("future", 
[10:26:27.971]                           quietly = TRUE)
[10:26:27.971]                         if (has_future) {
[10:26:27.971]                           ns <- base::getNamespace("future")
[10:26:27.971]                           version <- ns[[".package"]][["version"]]
[10:26:27.971]                           if (is.null(version)) 
[10:26:27.971]                             version <- utils::packageVersion("future")
[10:26:27.971]                         }
[10:26:27.971]                         else {
[10:26:27.971]                           version <- NULL
[10:26:27.971]                         }
[10:26:27.971]                         if (!has_future || version < "1.8.0") {
[10:26:27.971]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:27.971]                             "", base::R.version$version.string), 
[10:26:27.971]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:27.971]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:27.971]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:27.971]                               "release", "version")], collapse = " "), 
[10:26:27.971]                             hostname = base::Sys.info()[["nodename"]])
[10:26:27.971]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:27.971]                             info)
[10:26:27.971]                           info <- base::paste(info, collapse = "; ")
[10:26:27.971]                           if (!has_future) {
[10:26:27.971]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:27.971]                               info)
[10:26:27.971]                           }
[10:26:27.971]                           else {
[10:26:27.971]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:27.971]                               info, version)
[10:26:27.971]                           }
[10:26:27.971]                           base::stop(msg)
[10:26:27.971]                         }
[10:26:27.971]                       })
[10:26:27.971]                     }
[10:26:27.971]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:27.971]                     base::options(mc.cores = 1L)
[10:26:27.971]                   }
[10:26:27.971]                   options(future.plan = NULL)
[10:26:27.971]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:27.971]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:27.971]                 }
[10:26:27.971]                 ...future.workdir <- getwd()
[10:26:27.971]             }
[10:26:27.971]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:27.971]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:27.971]         }
[10:26:27.971]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:27.971]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:27.971]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:27.971]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:27.971]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:27.971]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:27.971]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:27.971]             base::names(...future.oldOptions))
[10:26:27.971]     }
[10:26:27.971]     if (FALSE) {
[10:26:27.971]     }
[10:26:27.971]     else {
[10:26:27.971]         if (TRUE) {
[10:26:27.971]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:27.971]                 open = "w")
[10:26:27.971]         }
[10:26:27.971]         else {
[10:26:27.971]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:27.971]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:27.971]         }
[10:26:27.971]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:27.971]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:27.971]             base::sink(type = "output", split = FALSE)
[10:26:27.971]             base::close(...future.stdout)
[10:26:27.971]         }, add = TRUE)
[10:26:27.971]     }
[10:26:27.971]     ...future.frame <- base::sys.nframe()
[10:26:27.971]     ...future.conditions <- base::list()
[10:26:27.971]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:27.971]     if (FALSE) {
[10:26:27.971]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:27.971]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:27.971]     }
[10:26:27.971]     ...future.result <- base::tryCatch({
[10:26:27.971]         base::withCallingHandlers({
[10:26:27.971]             ...future.value <- base::withVisible(base::local({
[10:26:27.971]                 ...future.makeSendCondition <- base::local({
[10:26:27.971]                   sendCondition <- NULL
[10:26:27.971]                   function(frame = 1L) {
[10:26:27.971]                     if (is.function(sendCondition)) 
[10:26:27.971]                       return(sendCondition)
[10:26:27.971]                     ns <- getNamespace("parallel")
[10:26:27.971]                     if (exists("sendData", mode = "function", 
[10:26:27.971]                       envir = ns)) {
[10:26:27.971]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:27.971]                         envir = ns)
[10:26:27.971]                       envir <- sys.frame(frame)
[10:26:27.971]                       master <- NULL
[10:26:27.971]                       while (!identical(envir, .GlobalEnv) && 
[10:26:27.971]                         !identical(envir, emptyenv())) {
[10:26:27.971]                         if (exists("master", mode = "list", envir = envir, 
[10:26:27.971]                           inherits = FALSE)) {
[10:26:27.971]                           master <- get("master", mode = "list", 
[10:26:27.971]                             envir = envir, inherits = FALSE)
[10:26:27.971]                           if (inherits(master, c("SOCKnode", 
[10:26:27.971]                             "SOCK0node"))) {
[10:26:27.971]                             sendCondition <<- function(cond) {
[10:26:27.971]                               data <- list(type = "VALUE", value = cond, 
[10:26:27.971]                                 success = TRUE)
[10:26:27.971]                               parallel_sendData(master, data)
[10:26:27.971]                             }
[10:26:27.971]                             return(sendCondition)
[10:26:27.971]                           }
[10:26:27.971]                         }
[10:26:27.971]                         frame <- frame + 1L
[10:26:27.971]                         envir <- sys.frame(frame)
[10:26:27.971]                       }
[10:26:27.971]                     }
[10:26:27.971]                     sendCondition <<- function(cond) NULL
[10:26:27.971]                   }
[10:26:27.971]                 })
[10:26:27.971]                 withCallingHandlers({
[10:26:27.971]                   1L
[10:26:27.971]                 }, immediateCondition = function(cond) {
[10:26:27.971]                   sendCondition <- ...future.makeSendCondition()
[10:26:27.971]                   sendCondition(cond)
[10:26:27.971]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:27.971]                   {
[10:26:27.971]                     inherits <- base::inherits
[10:26:27.971]                     invokeRestart <- base::invokeRestart
[10:26:27.971]                     is.null <- base::is.null
[10:26:27.971]                     muffled <- FALSE
[10:26:27.971]                     if (inherits(cond, "message")) {
[10:26:27.971]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:27.971]                       if (muffled) 
[10:26:27.971]                         invokeRestart("muffleMessage")
[10:26:27.971]                     }
[10:26:27.971]                     else if (inherits(cond, "warning")) {
[10:26:27.971]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:27.971]                       if (muffled) 
[10:26:27.971]                         invokeRestart("muffleWarning")
[10:26:27.971]                     }
[10:26:27.971]                     else if (inherits(cond, "condition")) {
[10:26:27.971]                       if (!is.null(pattern)) {
[10:26:27.971]                         computeRestarts <- base::computeRestarts
[10:26:27.971]                         grepl <- base::grepl
[10:26:27.971]                         restarts <- computeRestarts(cond)
[10:26:27.971]                         for (restart in restarts) {
[10:26:27.971]                           name <- restart$name
[10:26:27.971]                           if (is.null(name)) 
[10:26:27.971]                             next
[10:26:27.971]                           if (!grepl(pattern, name)) 
[10:26:27.971]                             next
[10:26:27.971]                           invokeRestart(restart)
[10:26:27.971]                           muffled <- TRUE
[10:26:27.971]                           break
[10:26:27.971]                         }
[10:26:27.971]                       }
[10:26:27.971]                     }
[10:26:27.971]                     invisible(muffled)
[10:26:27.971]                   }
[10:26:27.971]                   muffleCondition(cond)
[10:26:27.971]                 })
[10:26:27.971]             }))
[10:26:27.971]             future::FutureResult(value = ...future.value$value, 
[10:26:27.971]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:27.971]                   ...future.rng), globalenv = if (FALSE) 
[10:26:27.971]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:27.971]                     ...future.globalenv.names))
[10:26:27.971]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:27.971]         }, condition = base::local({
[10:26:27.971]             c <- base::c
[10:26:27.971]             inherits <- base::inherits
[10:26:27.971]             invokeRestart <- base::invokeRestart
[10:26:27.971]             length <- base::length
[10:26:27.971]             list <- base::list
[10:26:27.971]             seq.int <- base::seq.int
[10:26:27.971]             signalCondition <- base::signalCondition
[10:26:27.971]             sys.calls <- base::sys.calls
[10:26:27.971]             `[[` <- base::`[[`
[10:26:27.971]             `+` <- base::`+`
[10:26:27.971]             `<<-` <- base::`<<-`
[10:26:27.971]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:27.971]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:27.971]                   3L)]
[10:26:27.971]             }
[10:26:27.971]             function(cond) {
[10:26:27.971]                 is_error <- inherits(cond, "error")
[10:26:27.971]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:27.971]                   NULL)
[10:26:27.971]                 if (is_error) {
[10:26:27.971]                   sessionInformation <- function() {
[10:26:27.971]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:27.971]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:27.971]                       search = base::search(), system = base::Sys.info())
[10:26:27.971]                   }
[10:26:27.971]                   ...future.conditions[[length(...future.conditions) + 
[10:26:27.971]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:27.971]                     cond$call), session = sessionInformation(), 
[10:26:27.971]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:27.971]                   signalCondition(cond)
[10:26:27.971]                 }
[10:26:27.971]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:27.971]                 "immediateCondition"))) {
[10:26:27.971]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:27.971]                   ...future.conditions[[length(...future.conditions) + 
[10:26:27.971]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:27.971]                   if (TRUE && !signal) {
[10:26:27.971]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:27.971]                     {
[10:26:27.971]                       inherits <- base::inherits
[10:26:27.971]                       invokeRestart <- base::invokeRestart
[10:26:27.971]                       is.null <- base::is.null
[10:26:27.971]                       muffled <- FALSE
[10:26:27.971]                       if (inherits(cond, "message")) {
[10:26:27.971]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:27.971]                         if (muffled) 
[10:26:27.971]                           invokeRestart("muffleMessage")
[10:26:27.971]                       }
[10:26:27.971]                       else if (inherits(cond, "warning")) {
[10:26:27.971]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:27.971]                         if (muffled) 
[10:26:27.971]                           invokeRestart("muffleWarning")
[10:26:27.971]                       }
[10:26:27.971]                       else if (inherits(cond, "condition")) {
[10:26:27.971]                         if (!is.null(pattern)) {
[10:26:27.971]                           computeRestarts <- base::computeRestarts
[10:26:27.971]                           grepl <- base::grepl
[10:26:27.971]                           restarts <- computeRestarts(cond)
[10:26:27.971]                           for (restart in restarts) {
[10:26:27.971]                             name <- restart$name
[10:26:27.971]                             if (is.null(name)) 
[10:26:27.971]                               next
[10:26:27.971]                             if (!grepl(pattern, name)) 
[10:26:27.971]                               next
[10:26:27.971]                             invokeRestart(restart)
[10:26:27.971]                             muffled <- TRUE
[10:26:27.971]                             break
[10:26:27.971]                           }
[10:26:27.971]                         }
[10:26:27.971]                       }
[10:26:27.971]                       invisible(muffled)
[10:26:27.971]                     }
[10:26:27.971]                     muffleCondition(cond, pattern = "^muffle")
[10:26:27.971]                   }
[10:26:27.971]                 }
[10:26:27.971]                 else {
[10:26:27.971]                   if (TRUE) {
[10:26:27.971]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:27.971]                     {
[10:26:27.971]                       inherits <- base::inherits
[10:26:27.971]                       invokeRestart <- base::invokeRestart
[10:26:27.971]                       is.null <- base::is.null
[10:26:27.971]                       muffled <- FALSE
[10:26:27.971]                       if (inherits(cond, "message")) {
[10:26:27.971]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:27.971]                         if (muffled) 
[10:26:27.971]                           invokeRestart("muffleMessage")
[10:26:27.971]                       }
[10:26:27.971]                       else if (inherits(cond, "warning")) {
[10:26:27.971]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:27.971]                         if (muffled) 
[10:26:27.971]                           invokeRestart("muffleWarning")
[10:26:27.971]                       }
[10:26:27.971]                       else if (inherits(cond, "condition")) {
[10:26:27.971]                         if (!is.null(pattern)) {
[10:26:27.971]                           computeRestarts <- base::computeRestarts
[10:26:27.971]                           grepl <- base::grepl
[10:26:27.971]                           restarts <- computeRestarts(cond)
[10:26:27.971]                           for (restart in restarts) {
[10:26:27.971]                             name <- restart$name
[10:26:27.971]                             if (is.null(name)) 
[10:26:27.971]                               next
[10:26:27.971]                             if (!grepl(pattern, name)) 
[10:26:27.971]                               next
[10:26:27.971]                             invokeRestart(restart)
[10:26:27.971]                             muffled <- TRUE
[10:26:27.971]                             break
[10:26:27.971]                           }
[10:26:27.971]                         }
[10:26:27.971]                       }
[10:26:27.971]                       invisible(muffled)
[10:26:27.971]                     }
[10:26:27.971]                     muffleCondition(cond, pattern = "^muffle")
[10:26:27.971]                   }
[10:26:27.971]                 }
[10:26:27.971]             }
[10:26:27.971]         }))
[10:26:27.971]     }, error = function(ex) {
[10:26:27.971]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:27.971]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:27.971]                 ...future.rng), started = ...future.startTime, 
[10:26:27.971]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:27.971]             version = "1.8"), class = "FutureResult")
[10:26:27.971]     }, finally = {
[10:26:27.971]         if (!identical(...future.workdir, getwd())) 
[10:26:27.971]             setwd(...future.workdir)
[10:26:27.971]         {
[10:26:27.971]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:27.971]                 ...future.oldOptions$nwarnings <- NULL
[10:26:27.971]             }
[10:26:27.971]             base::options(...future.oldOptions)
[10:26:27.971]             if (.Platform$OS.type == "windows") {
[10:26:27.971]                 old_names <- names(...future.oldEnvVars)
[10:26:27.971]                 envs <- base::Sys.getenv()
[10:26:27.971]                 names <- names(envs)
[10:26:27.971]                 common <- intersect(names, old_names)
[10:26:27.971]                 added <- setdiff(names, old_names)
[10:26:27.971]                 removed <- setdiff(old_names, names)
[10:26:27.971]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:27.971]                   envs[common]]
[10:26:27.971]                 NAMES <- toupper(changed)
[10:26:27.971]                 args <- list()
[10:26:27.971]                 for (kk in seq_along(NAMES)) {
[10:26:27.971]                   name <- changed[[kk]]
[10:26:27.971]                   NAME <- NAMES[[kk]]
[10:26:27.971]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:27.971]                     next
[10:26:27.971]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:27.971]                 }
[10:26:27.971]                 NAMES <- toupper(added)
[10:26:27.971]                 for (kk in seq_along(NAMES)) {
[10:26:27.971]                   name <- added[[kk]]
[10:26:27.971]                   NAME <- NAMES[[kk]]
[10:26:27.971]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:27.971]                     next
[10:26:27.971]                   args[[name]] <- ""
[10:26:27.971]                 }
[10:26:27.971]                 NAMES <- toupper(removed)
[10:26:27.971]                 for (kk in seq_along(NAMES)) {
[10:26:27.971]                   name <- removed[[kk]]
[10:26:27.971]                   NAME <- NAMES[[kk]]
[10:26:27.971]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:27.971]                     next
[10:26:27.971]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:27.971]                 }
[10:26:27.971]                 if (length(args) > 0) 
[10:26:27.971]                   base::do.call(base::Sys.setenv, args = args)
[10:26:27.971]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:27.971]             }
[10:26:27.971]             else {
[10:26:27.971]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:27.971]             }
[10:26:27.971]             {
[10:26:27.971]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:27.971]                   0L) {
[10:26:27.971]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:27.971]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:27.971]                   base::options(opts)
[10:26:27.971]                 }
[10:26:27.971]                 {
[10:26:27.971]                   {
[10:26:27.971]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:27.971]                     NULL
[10:26:27.971]                   }
[10:26:27.971]                   options(future.plan = NULL)
[10:26:27.971]                   if (is.na(NA_character_)) 
[10:26:27.971]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:27.971]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:27.971]                   future::plan(list(function (..., workers = 2L, 
[10:26:27.971]                     envir = parent.frame()) 
[10:26:27.971]                   strategy(..., workers = workers, envir = envir)), 
[10:26:27.971]                     .cleanup = FALSE, .init = FALSE)
[10:26:27.971]                 }
[10:26:27.971]             }
[10:26:27.971]         }
[10:26:27.971]     })
[10:26:27.971]     if (TRUE) {
[10:26:27.971]         base::sink(type = "output", split = FALSE)
[10:26:27.971]         if (TRUE) {
[10:26:27.971]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:27.971]         }
[10:26:27.971]         else {
[10:26:27.971]             ...future.result["stdout"] <- base::list(NULL)
[10:26:27.971]         }
[10:26:27.971]         base::close(...future.stdout)
[10:26:27.971]         ...future.stdout <- NULL
[10:26:27.971]     }
[10:26:27.971]     ...future.result$conditions <- ...future.conditions
[10:26:27.971]     ...future.result$finished <- base::Sys.time()
[10:26:27.971]     ...future.result
[10:26:27.971] }
[10:26:27.974] MultisessionFuture started
[10:26:27.974] - Launch lazy future ... done
[10:26:27.974] run() for ‘MultisessionFuture’ ... done
> cl <- ClusterRegistry("get")
> stopifnot(inherits(cl, "cluster"), length(cl) >= 1L)
> 
> plan(sequential)
[10:26:27.975] plan(): Setting new future strategy stack:
[10:26:27.975] List of future strategies:
[10:26:27.975] 1. sequential:
[10:26:27.975]    - args: function (..., envir = parent.frame())
[10:26:27.975]    - tweaked: FALSE
[10:26:27.975]    - call: plan(sequential)
[10:26:27.975] plan(): nbrOfWorkers() = 1
> cl <- ClusterRegistry("get")
> stopifnot(is.null(cl), length(cl) == 0L)
>   
> message("*** multisession(...) - stopping with plan() change ... DONE")
*** multisession(...) - stopping with plan() change ... DONE
> 
> message("*** multisession() ... DONE")
*** multisession() ... DONE
> 
> source("incl/end.R")
[10:26:27.976] plan(): Setting new future strategy stack:
[10:26:27.976] List of future strategies:
[10:26:27.976] 1. FutureStrategy:
[10:26:27.976]    - args: function (..., envir = parent.frame())
[10:26:27.976]    - tweaked: FALSE
[10:26:27.976]    - call: future::plan(oplan)
[10:26:27.977] plan(): nbrOfWorkers() = 1
> 
