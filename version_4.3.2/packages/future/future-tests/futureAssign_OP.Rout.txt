
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[13:22:54.921] plan(): Setting new future strategy stack:
[13:22:54.921] List of future strategies:
[13:22:54.921] 1. sequential:
[13:22:54.921]    - args: function (..., envir = parent.frame())
[13:22:54.921]    - tweaked: FALSE
[13:22:54.921]    - call: future::plan("sequential")
[13:22:54.937] plan(): nbrOfWorkers() = 1
> 
> message("*** %<-% ...")
*** %<-% ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("*** %%<-%% with %s futures ...", sQuote(strategy)))
+     plan(strategy)
+ 
+     rm(list = intersect(c("x", "y"), ls()))
+ 
+     message("** Future evaluation without globals")
+     v1 %<-% { x <- 1 }
+     stopifnot(!exists("x", inherits = FALSE), identical(v1, 1))
+ 
+     message("** Future evaluation with globals")
+     a <- 2
+     v2 %<-% { x <- a }
+     stopifnot(!exists("x", inherits = FALSE), identical(v2, a))
+ 
+     message("** Future evaluation with errors")
+     v3 %<-% {
+       x <- 3
+       stop("Woops!")
+       x
+     }
+     stopifnot(!exists("x", inherits = FALSE))
+     res <- tryCatch(identical(v3, 3), error = identity)
+     stopifnot(inherits(res, "error"))
+ 
+ 
+     y <- listenv::listenv()
+     for (ii in 1:3) {
+       y[[ii]] %<-% {
+         if (ii %% 2 == 0) stop("Woops!")
+         ii
+       }
+     }
+     res <- tryCatch(as.list(y), error = identity)
+     stopifnot(inherits(res, "error"))
+     z <- y[c(1, 3)]
+     z <- unlist(z)
+     stopifnot(all(z == c(1, 3)))
+     res <- tryCatch(y[[2]], error = identity)
+     stopifnot(inherits(res, "error"))
+     res <- tryCatch(y[1:2], error = identity)
+     stopifnot(inherits(res, "error"))
+ 
+ 
+     message("** Future evaluation with a poor-man's \"progress bar\"")
+     v4 %<-% {
+       cat("Processing: ")
+       for (ii in 1:10) { cat(".") }
+       cat(" [100%]\n")
+       4
+     }
+ 
+ 
+     message("** Collecting results")
+     printf("v1 = %s\n", v1)
+     stopifnot(v1 == 1)
+ 
+     printf("v2 = %s\n", v2)
+     stopifnot(v2 == a)
+ 
+     stopifnot(tryCatch({
+       printf("v3 = %s\n", v3)
+     }, error = function(ex) {
+       printf("v3: <%s> (as expect)\n", class(ex)[1])
+       TRUE
+     }))
+ 
+     printf("v4 = %s\n", v4)
+     #stopifnot(v4 == 4)
+ 
+ 
+     message("** Left-to-right and right-to-left future assignments")
+     c %<-% 1
+     printf("c = %s\n", c)
+     1 %->% d
+     printf("d = %s\n", d)
+     stopifnot(d == c)
+ 
+ 
+ 
+     message("** Nested future assignments")
+     a %<-% {
+       b <- 1
+       c %<-% 2
+       3 -> d
+       4 %->% e
+       b + c + d + e
+     }
+     printf("a = %s\n", a)
+     stopifnot(a == 10)
+ 
+     { a + 1 } %->% b
+     printf("b = %s\n", b)
+     stopifnot(b == a + 1)
+ 
+     message(sprintf("*** %%<-%% with %s futures ... DONE", sQuote(strategy)))
+   } # for (strategy in ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
*** %<-% with ‘sequential’ futures ...
[13:22:54.994] plan(): Setting new future strategy stack:
[13:22:54.994] List of future strategies:
[13:22:54.994] 1. sequential:
[13:22:54.994]    - args: function (..., envir = parent.frame())
[13:22:54.994]    - tweaked: FALSE
[13:22:54.994]    - call: plan(strategy)
[13:22:55.007] plan(): nbrOfWorkers() = 1
** Future evaluation without globals
[13:22:55.009] getGlobalsAndPackages() ...
[13:22:55.009] Searching for globals...
[13:22:55.014] - globals found: [2] ‘{’, ‘<-’
[13:22:55.014] Searching for globals ... DONE
[13:22:55.014] Resolving globals: FALSE
[13:22:55.015] 
[13:22:55.015] 
[13:22:55.015] getGlobalsAndPackages() ... DONE
[13:22:55.016] run() for ‘Future’ ...
[13:22:55.016] - state: ‘created’
[13:22:55.016] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:22:55.016] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:22:55.016] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:22:55.017]   - Field: ‘label’
[13:22:55.017]   - Field: ‘local’
[13:22:55.017]   - Field: ‘owner’
[13:22:55.017]   - Field: ‘envir’
[13:22:55.017]   - Field: ‘packages’
[13:22:55.017]   - Field: ‘gc’
[13:22:55.017]   - Field: ‘conditions’
[13:22:55.017]   - Field: ‘expr’
[13:22:55.017]   - Field: ‘uuid’
[13:22:55.017]   - Field: ‘seed’
[13:22:55.017]   - Field: ‘version’
[13:22:55.018]   - Field: ‘result’
[13:22:55.018]   - Field: ‘asynchronous’
[13:22:55.018]   - Field: ‘calls’
[13:22:55.018]   - Field: ‘globals’
[13:22:55.018]   - Field: ‘stdout’
[13:22:55.018]   - Field: ‘earlySignal’
[13:22:55.018]   - Field: ‘lazy’
[13:22:55.018]   - Field: ‘state’
[13:22:55.018] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:22:55.018] - Launch lazy future ...
[13:22:55.019] Packages needed by the future expression (n = 0): <none>
[13:22:55.019] Packages needed by future strategies (n = 0): <none>
[13:22:55.020] {
[13:22:55.020]     {
[13:22:55.020]         {
[13:22:55.020]             ...future.startTime <- base::Sys.time()
[13:22:55.020]             {
[13:22:55.020]                 {
[13:22:55.020]                   {
[13:22:55.020]                     base::local({
[13:22:55.020]                       has_future <- base::requireNamespace("future", 
[13:22:55.020]                         quietly = TRUE)
[13:22:55.020]                       if (has_future) {
[13:22:55.020]                         ns <- base::getNamespace("future")
[13:22:55.020]                         version <- ns[[".package"]][["version"]]
[13:22:55.020]                         if (is.null(version)) 
[13:22:55.020]                           version <- utils::packageVersion("future")
[13:22:55.020]                       }
[13:22:55.020]                       else {
[13:22:55.020]                         version <- NULL
[13:22:55.020]                       }
[13:22:55.020]                       if (!has_future || version < "1.8.0") {
[13:22:55.020]                         info <- base::c(r_version = base::gsub("R version ", 
[13:22:55.020]                           "", base::R.version$version.string), 
[13:22:55.020]                           platform = base::sprintf("%s (%s-bit)", 
[13:22:55.020]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:55.020]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:55.020]                             "release", "version")], collapse = " "), 
[13:22:55.020]                           hostname = base::Sys.info()[["nodename"]])
[13:22:55.020]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:22:55.020]                           info)
[13:22:55.020]                         info <- base::paste(info, collapse = "; ")
[13:22:55.020]                         if (!has_future) {
[13:22:55.020]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:55.020]                             info)
[13:22:55.020]                         }
[13:22:55.020]                         else {
[13:22:55.020]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:55.020]                             info, version)
[13:22:55.020]                         }
[13:22:55.020]                         base::stop(msg)
[13:22:55.020]                       }
[13:22:55.020]                     })
[13:22:55.020]                   }
[13:22:55.020]                   options(future.plan = NULL)
[13:22:55.020]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.020]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:55.020]                 }
[13:22:55.020]                 ...future.workdir <- getwd()
[13:22:55.020]             }
[13:22:55.020]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:55.020]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:55.020]         }
[13:22:55.020]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:55.020]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:55.020]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:55.020]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:55.020]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:55.020]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:55.020]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:55.020]             base::names(...future.oldOptions))
[13:22:55.020]     }
[13:22:55.020]     if (FALSE) {
[13:22:55.020]     }
[13:22:55.020]     else {
[13:22:55.020]         if (TRUE) {
[13:22:55.020]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:55.020]                 open = "w")
[13:22:55.020]         }
[13:22:55.020]         else {
[13:22:55.020]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:55.020]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:55.020]         }
[13:22:55.020]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:55.020]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:55.020]             base::sink(type = "output", split = FALSE)
[13:22:55.020]             base::close(...future.stdout)
[13:22:55.020]         }, add = TRUE)
[13:22:55.020]     }
[13:22:55.020]     ...future.frame <- base::sys.nframe()
[13:22:55.020]     ...future.conditions <- base::list()
[13:22:55.020]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:55.020]     if (FALSE) {
[13:22:55.020]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:55.020]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:55.020]     }
[13:22:55.020]     ...future.result <- base::tryCatch({
[13:22:55.020]         base::withCallingHandlers({
[13:22:55.020]             ...future.value <- base::withVisible(base::local({
[13:22:55.020]                 x <- 1
[13:22:55.020]             }))
[13:22:55.020]             future::FutureResult(value = ...future.value$value, 
[13:22:55.020]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.020]                   ...future.rng), globalenv = if (FALSE) 
[13:22:55.020]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:55.020]                     ...future.globalenv.names))
[13:22:55.020]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:55.020]         }, condition = base::local({
[13:22:55.020]             c <- base::c
[13:22:55.020]             inherits <- base::inherits
[13:22:55.020]             invokeRestart <- base::invokeRestart
[13:22:55.020]             length <- base::length
[13:22:55.020]             list <- base::list
[13:22:55.020]             seq.int <- base::seq.int
[13:22:55.020]             signalCondition <- base::signalCondition
[13:22:55.020]             sys.calls <- base::sys.calls
[13:22:55.020]             `[[` <- base::`[[`
[13:22:55.020]             `+` <- base::`+`
[13:22:55.020]             `<<-` <- base::`<<-`
[13:22:55.020]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:55.020]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:55.020]                   3L)]
[13:22:55.020]             }
[13:22:55.020]             function(cond) {
[13:22:55.020]                 is_error <- inherits(cond, "error")
[13:22:55.020]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:55.020]                   NULL)
[13:22:55.020]                 if (is_error) {
[13:22:55.020]                   sessionInformation <- function() {
[13:22:55.020]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:55.020]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:55.020]                       search = base::search(), system = base::Sys.info())
[13:22:55.020]                   }
[13:22:55.020]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.020]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:55.020]                     cond$call), session = sessionInformation(), 
[13:22:55.020]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:55.020]                   signalCondition(cond)
[13:22:55.020]                 }
[13:22:55.020]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:55.020]                 "immediateCondition"))) {
[13:22:55.020]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:55.020]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.020]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:55.020]                   if (TRUE && !signal) {
[13:22:55.020]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.020]                     {
[13:22:55.020]                       inherits <- base::inherits
[13:22:55.020]                       invokeRestart <- base::invokeRestart
[13:22:55.020]                       is.null <- base::is.null
[13:22:55.020]                       muffled <- FALSE
[13:22:55.020]                       if (inherits(cond, "message")) {
[13:22:55.020]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.020]                         if (muffled) 
[13:22:55.020]                           invokeRestart("muffleMessage")
[13:22:55.020]                       }
[13:22:55.020]                       else if (inherits(cond, "warning")) {
[13:22:55.020]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.020]                         if (muffled) 
[13:22:55.020]                           invokeRestart("muffleWarning")
[13:22:55.020]                       }
[13:22:55.020]                       else if (inherits(cond, "condition")) {
[13:22:55.020]                         if (!is.null(pattern)) {
[13:22:55.020]                           computeRestarts <- base::computeRestarts
[13:22:55.020]                           grepl <- base::grepl
[13:22:55.020]                           restarts <- computeRestarts(cond)
[13:22:55.020]                           for (restart in restarts) {
[13:22:55.020]                             name <- restart$name
[13:22:55.020]                             if (is.null(name)) 
[13:22:55.020]                               next
[13:22:55.020]                             if (!grepl(pattern, name)) 
[13:22:55.020]                               next
[13:22:55.020]                             invokeRestart(restart)
[13:22:55.020]                             muffled <- TRUE
[13:22:55.020]                             break
[13:22:55.020]                           }
[13:22:55.020]                         }
[13:22:55.020]                       }
[13:22:55.020]                       invisible(muffled)
[13:22:55.020]                     }
[13:22:55.020]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.020]                   }
[13:22:55.020]                 }
[13:22:55.020]                 else {
[13:22:55.020]                   if (TRUE) {
[13:22:55.020]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.020]                     {
[13:22:55.020]                       inherits <- base::inherits
[13:22:55.020]                       invokeRestart <- base::invokeRestart
[13:22:55.020]                       is.null <- base::is.null
[13:22:55.020]                       muffled <- FALSE
[13:22:55.020]                       if (inherits(cond, "message")) {
[13:22:55.020]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.020]                         if (muffled) 
[13:22:55.020]                           invokeRestart("muffleMessage")
[13:22:55.020]                       }
[13:22:55.020]                       else if (inherits(cond, "warning")) {
[13:22:55.020]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.020]                         if (muffled) 
[13:22:55.020]                           invokeRestart("muffleWarning")
[13:22:55.020]                       }
[13:22:55.020]                       else if (inherits(cond, "condition")) {
[13:22:55.020]                         if (!is.null(pattern)) {
[13:22:55.020]                           computeRestarts <- base::computeRestarts
[13:22:55.020]                           grepl <- base::grepl
[13:22:55.020]                           restarts <- computeRestarts(cond)
[13:22:55.020]                           for (restart in restarts) {
[13:22:55.020]                             name <- restart$name
[13:22:55.020]                             if (is.null(name)) 
[13:22:55.020]                               next
[13:22:55.020]                             if (!grepl(pattern, name)) 
[13:22:55.020]                               next
[13:22:55.020]                             invokeRestart(restart)
[13:22:55.020]                             muffled <- TRUE
[13:22:55.020]                             break
[13:22:55.020]                           }
[13:22:55.020]                         }
[13:22:55.020]                       }
[13:22:55.020]                       invisible(muffled)
[13:22:55.020]                     }
[13:22:55.020]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.020]                   }
[13:22:55.020]                 }
[13:22:55.020]             }
[13:22:55.020]         }))
[13:22:55.020]     }, error = function(ex) {
[13:22:55.020]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:55.020]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.020]                 ...future.rng), started = ...future.startTime, 
[13:22:55.020]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:55.020]             version = "1.8"), class = "FutureResult")
[13:22:55.020]     }, finally = {
[13:22:55.020]         if (!identical(...future.workdir, getwd())) 
[13:22:55.020]             setwd(...future.workdir)
[13:22:55.020]         {
[13:22:55.020]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:55.020]                 ...future.oldOptions$nwarnings <- NULL
[13:22:55.020]             }
[13:22:55.020]             base::options(...future.oldOptions)
[13:22:55.020]             if (.Platform$OS.type == "windows") {
[13:22:55.020]                 old_names <- names(...future.oldEnvVars)
[13:22:55.020]                 envs <- base::Sys.getenv()
[13:22:55.020]                 names <- names(envs)
[13:22:55.020]                 common <- intersect(names, old_names)
[13:22:55.020]                 added <- setdiff(names, old_names)
[13:22:55.020]                 removed <- setdiff(old_names, names)
[13:22:55.020]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:55.020]                   envs[common]]
[13:22:55.020]                 NAMES <- toupper(changed)
[13:22:55.020]                 args <- list()
[13:22:55.020]                 for (kk in seq_along(NAMES)) {
[13:22:55.020]                   name <- changed[[kk]]
[13:22:55.020]                   NAME <- NAMES[[kk]]
[13:22:55.020]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.020]                     next
[13:22:55.020]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.020]                 }
[13:22:55.020]                 NAMES <- toupper(added)
[13:22:55.020]                 for (kk in seq_along(NAMES)) {
[13:22:55.020]                   name <- added[[kk]]
[13:22:55.020]                   NAME <- NAMES[[kk]]
[13:22:55.020]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.020]                     next
[13:22:55.020]                   args[[name]] <- ""
[13:22:55.020]                 }
[13:22:55.020]                 NAMES <- toupper(removed)
[13:22:55.020]                 for (kk in seq_along(NAMES)) {
[13:22:55.020]                   name <- removed[[kk]]
[13:22:55.020]                   NAME <- NAMES[[kk]]
[13:22:55.020]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.020]                     next
[13:22:55.020]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.020]                 }
[13:22:55.020]                 if (length(args) > 0) 
[13:22:55.020]                   base::do.call(base::Sys.setenv, args = args)
[13:22:55.020]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:55.020]             }
[13:22:55.020]             else {
[13:22:55.020]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:55.020]             }
[13:22:55.020]             {
[13:22:55.020]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:55.020]                   0L) {
[13:22:55.020]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:55.020]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:55.020]                   base::options(opts)
[13:22:55.020]                 }
[13:22:55.020]                 {
[13:22:55.020]                   {
[13:22:55.020]                     NULL
[13:22:55.020]                     RNGkind("Mersenne-Twister")
[13:22:55.020]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:22:55.020]                       inherits = FALSE)
[13:22:55.020]                   }
[13:22:55.020]                   options(future.plan = NULL)
[13:22:55.020]                   if (is.na(NA_character_)) 
[13:22:55.020]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.020]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:55.020]                   future::plan(list(function (..., envir = parent.frame()) 
[13:22:55.020]                   {
[13:22:55.020]                     future <- SequentialFuture(..., envir = envir)
[13:22:55.020]                     if (!future$lazy) 
[13:22:55.020]                       future <- run(future)
[13:22:55.020]                     invisible(future)
[13:22:55.020]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:55.020]                 }
[13:22:55.020]             }
[13:22:55.020]         }
[13:22:55.020]     })
[13:22:55.020]     if (TRUE) {
[13:22:55.020]         base::sink(type = "output", split = FALSE)
[13:22:55.020]         if (TRUE) {
[13:22:55.020]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:55.020]         }
[13:22:55.020]         else {
[13:22:55.020]             ...future.result["stdout"] <- base::list(NULL)
[13:22:55.020]         }
[13:22:55.020]         base::close(...future.stdout)
[13:22:55.020]         ...future.stdout <- NULL
[13:22:55.020]     }
[13:22:55.020]     ...future.result$conditions <- ...future.conditions
[13:22:55.020]     ...future.result$finished <- base::Sys.time()
[13:22:55.020]     ...future.result
[13:22:55.020] }
[13:22:55.022] plan(): Setting new future strategy stack:
[13:22:55.022] List of future strategies:
[13:22:55.022] 1. sequential:
[13:22:55.022]    - args: function (..., envir = parent.frame())
[13:22:55.022]    - tweaked: FALSE
[13:22:55.022]    - call: NULL
[13:22:55.023] plan(): nbrOfWorkers() = 1
[13:22:55.024] plan(): Setting new future strategy stack:
[13:22:55.024] List of future strategies:
[13:22:55.024] 1. sequential:
[13:22:55.024]    - args: function (..., envir = parent.frame())
[13:22:55.024]    - tweaked: FALSE
[13:22:55.024]    - call: plan(strategy)
[13:22:55.024] plan(): nbrOfWorkers() = 1
[13:22:55.025] SequentialFuture started (and completed)
[13:22:55.025] - Launch lazy future ... done
[13:22:55.025] run() for ‘SequentialFuture’ ... done
** Future evaluation with globals
[13:22:55.026] getGlobalsAndPackages() ...
[13:22:55.026] Searching for globals...
[13:22:55.027] - globals found: [3] ‘{’, ‘<-’, ‘a’
[13:22:55.027] Searching for globals ... DONE
[13:22:55.027] Resolving globals: FALSE
[13:22:55.028] The total size of the 1 globals is 56 bytes (56 bytes)
[13:22:55.028] The total size of the 1 globals exported for future expression (‘{; x <- a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:22:55.029] - globals: [1] ‘a’
[13:22:55.029] 
[13:22:55.029] getGlobalsAndPackages() ... DONE
[13:22:55.029] run() for ‘Future’ ...
[13:22:55.029] - state: ‘created’
[13:22:55.029] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:22:55.030] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:22:55.030] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:22:55.030]   - Field: ‘label’
[13:22:55.030]   - Field: ‘local’
[13:22:55.030]   - Field: ‘owner’
[13:22:55.030]   - Field: ‘envir’
[13:22:55.030]   - Field: ‘packages’
[13:22:55.030]   - Field: ‘gc’
[13:22:55.030]   - Field: ‘conditions’
[13:22:55.030]   - Field: ‘expr’
[13:22:55.030]   - Field: ‘uuid’
[13:22:55.031]   - Field: ‘seed’
[13:22:55.031]   - Field: ‘version’
[13:22:55.031]   - Field: ‘result’
[13:22:55.031]   - Field: ‘asynchronous’
[13:22:55.031]   - Field: ‘calls’
[13:22:55.031]   - Field: ‘globals’
[13:22:55.031]   - Field: ‘stdout’
[13:22:55.031]   - Field: ‘earlySignal’
[13:22:55.031]   - Field: ‘lazy’
[13:22:55.031]   - Field: ‘state’
[13:22:55.031] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:22:55.032] - Launch lazy future ...
[13:22:55.032] Packages needed by the future expression (n = 0): <none>
[13:22:55.032] Packages needed by future strategies (n = 0): <none>
[13:22:55.032] {
[13:22:55.032]     {
[13:22:55.032]         {
[13:22:55.032]             ...future.startTime <- base::Sys.time()
[13:22:55.032]             {
[13:22:55.032]                 {
[13:22:55.032]                   {
[13:22:55.032]                     base::local({
[13:22:55.032]                       has_future <- base::requireNamespace("future", 
[13:22:55.032]                         quietly = TRUE)
[13:22:55.032]                       if (has_future) {
[13:22:55.032]                         ns <- base::getNamespace("future")
[13:22:55.032]                         version <- ns[[".package"]][["version"]]
[13:22:55.032]                         if (is.null(version)) 
[13:22:55.032]                           version <- utils::packageVersion("future")
[13:22:55.032]                       }
[13:22:55.032]                       else {
[13:22:55.032]                         version <- NULL
[13:22:55.032]                       }
[13:22:55.032]                       if (!has_future || version < "1.8.0") {
[13:22:55.032]                         info <- base::c(r_version = base::gsub("R version ", 
[13:22:55.032]                           "", base::R.version$version.string), 
[13:22:55.032]                           platform = base::sprintf("%s (%s-bit)", 
[13:22:55.032]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:55.032]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:55.032]                             "release", "version")], collapse = " "), 
[13:22:55.032]                           hostname = base::Sys.info()[["nodename"]])
[13:22:55.032]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:22:55.032]                           info)
[13:22:55.032]                         info <- base::paste(info, collapse = "; ")
[13:22:55.032]                         if (!has_future) {
[13:22:55.032]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:55.032]                             info)
[13:22:55.032]                         }
[13:22:55.032]                         else {
[13:22:55.032]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:55.032]                             info, version)
[13:22:55.032]                         }
[13:22:55.032]                         base::stop(msg)
[13:22:55.032]                       }
[13:22:55.032]                     })
[13:22:55.032]                   }
[13:22:55.032]                   options(future.plan = NULL)
[13:22:55.032]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.032]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:55.032]                 }
[13:22:55.032]                 ...future.workdir <- getwd()
[13:22:55.032]             }
[13:22:55.032]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:55.032]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:55.032]         }
[13:22:55.032]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:55.032]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:55.032]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:55.032]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:55.032]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:55.032]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:55.032]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:55.032]             base::names(...future.oldOptions))
[13:22:55.032]     }
[13:22:55.032]     if (FALSE) {
[13:22:55.032]     }
[13:22:55.032]     else {
[13:22:55.032]         if (TRUE) {
[13:22:55.032]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:55.032]                 open = "w")
[13:22:55.032]         }
[13:22:55.032]         else {
[13:22:55.032]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:55.032]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:55.032]         }
[13:22:55.032]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:55.032]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:55.032]             base::sink(type = "output", split = FALSE)
[13:22:55.032]             base::close(...future.stdout)
[13:22:55.032]         }, add = TRUE)
[13:22:55.032]     }
[13:22:55.032]     ...future.frame <- base::sys.nframe()
[13:22:55.032]     ...future.conditions <- base::list()
[13:22:55.032]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:55.032]     if (FALSE) {
[13:22:55.032]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:55.032]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:55.032]     }
[13:22:55.032]     ...future.result <- base::tryCatch({
[13:22:55.032]         base::withCallingHandlers({
[13:22:55.032]             ...future.value <- base::withVisible(base::local({
[13:22:55.032]                 x <- a
[13:22:55.032]             }))
[13:22:55.032]             future::FutureResult(value = ...future.value$value, 
[13:22:55.032]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.032]                   ...future.rng), globalenv = if (FALSE) 
[13:22:55.032]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:55.032]                     ...future.globalenv.names))
[13:22:55.032]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:55.032]         }, condition = base::local({
[13:22:55.032]             c <- base::c
[13:22:55.032]             inherits <- base::inherits
[13:22:55.032]             invokeRestart <- base::invokeRestart
[13:22:55.032]             length <- base::length
[13:22:55.032]             list <- base::list
[13:22:55.032]             seq.int <- base::seq.int
[13:22:55.032]             signalCondition <- base::signalCondition
[13:22:55.032]             sys.calls <- base::sys.calls
[13:22:55.032]             `[[` <- base::`[[`
[13:22:55.032]             `+` <- base::`+`
[13:22:55.032]             `<<-` <- base::`<<-`
[13:22:55.032]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:55.032]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:55.032]                   3L)]
[13:22:55.032]             }
[13:22:55.032]             function(cond) {
[13:22:55.032]                 is_error <- inherits(cond, "error")
[13:22:55.032]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:55.032]                   NULL)
[13:22:55.032]                 if (is_error) {
[13:22:55.032]                   sessionInformation <- function() {
[13:22:55.032]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:55.032]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:55.032]                       search = base::search(), system = base::Sys.info())
[13:22:55.032]                   }
[13:22:55.032]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.032]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:55.032]                     cond$call), session = sessionInformation(), 
[13:22:55.032]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:55.032]                   signalCondition(cond)
[13:22:55.032]                 }
[13:22:55.032]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:55.032]                 "immediateCondition"))) {
[13:22:55.032]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:55.032]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.032]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:55.032]                   if (TRUE && !signal) {
[13:22:55.032]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.032]                     {
[13:22:55.032]                       inherits <- base::inherits
[13:22:55.032]                       invokeRestart <- base::invokeRestart
[13:22:55.032]                       is.null <- base::is.null
[13:22:55.032]                       muffled <- FALSE
[13:22:55.032]                       if (inherits(cond, "message")) {
[13:22:55.032]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.032]                         if (muffled) 
[13:22:55.032]                           invokeRestart("muffleMessage")
[13:22:55.032]                       }
[13:22:55.032]                       else if (inherits(cond, "warning")) {
[13:22:55.032]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.032]                         if (muffled) 
[13:22:55.032]                           invokeRestart("muffleWarning")
[13:22:55.032]                       }
[13:22:55.032]                       else if (inherits(cond, "condition")) {
[13:22:55.032]                         if (!is.null(pattern)) {
[13:22:55.032]                           computeRestarts <- base::computeRestarts
[13:22:55.032]                           grepl <- base::grepl
[13:22:55.032]                           restarts <- computeRestarts(cond)
[13:22:55.032]                           for (restart in restarts) {
[13:22:55.032]                             name <- restart$name
[13:22:55.032]                             if (is.null(name)) 
[13:22:55.032]                               next
[13:22:55.032]                             if (!grepl(pattern, name)) 
[13:22:55.032]                               next
[13:22:55.032]                             invokeRestart(restart)
[13:22:55.032]                             muffled <- TRUE
[13:22:55.032]                             break
[13:22:55.032]                           }
[13:22:55.032]                         }
[13:22:55.032]                       }
[13:22:55.032]                       invisible(muffled)
[13:22:55.032]                     }
[13:22:55.032]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.032]                   }
[13:22:55.032]                 }
[13:22:55.032]                 else {
[13:22:55.032]                   if (TRUE) {
[13:22:55.032]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.032]                     {
[13:22:55.032]                       inherits <- base::inherits
[13:22:55.032]                       invokeRestart <- base::invokeRestart
[13:22:55.032]                       is.null <- base::is.null
[13:22:55.032]                       muffled <- FALSE
[13:22:55.032]                       if (inherits(cond, "message")) {
[13:22:55.032]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.032]                         if (muffled) 
[13:22:55.032]                           invokeRestart("muffleMessage")
[13:22:55.032]                       }
[13:22:55.032]                       else if (inherits(cond, "warning")) {
[13:22:55.032]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.032]                         if (muffled) 
[13:22:55.032]                           invokeRestart("muffleWarning")
[13:22:55.032]                       }
[13:22:55.032]                       else if (inherits(cond, "condition")) {
[13:22:55.032]                         if (!is.null(pattern)) {
[13:22:55.032]                           computeRestarts <- base::computeRestarts
[13:22:55.032]                           grepl <- base::grepl
[13:22:55.032]                           restarts <- computeRestarts(cond)
[13:22:55.032]                           for (restart in restarts) {
[13:22:55.032]                             name <- restart$name
[13:22:55.032]                             if (is.null(name)) 
[13:22:55.032]                               next
[13:22:55.032]                             if (!grepl(pattern, name)) 
[13:22:55.032]                               next
[13:22:55.032]                             invokeRestart(restart)
[13:22:55.032]                             muffled <- TRUE
[13:22:55.032]                             break
[13:22:55.032]                           }
[13:22:55.032]                         }
[13:22:55.032]                       }
[13:22:55.032]                       invisible(muffled)
[13:22:55.032]                     }
[13:22:55.032]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.032]                   }
[13:22:55.032]                 }
[13:22:55.032]             }
[13:22:55.032]         }))
[13:22:55.032]     }, error = function(ex) {
[13:22:55.032]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:55.032]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.032]                 ...future.rng), started = ...future.startTime, 
[13:22:55.032]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:55.032]             version = "1.8"), class = "FutureResult")
[13:22:55.032]     }, finally = {
[13:22:55.032]         if (!identical(...future.workdir, getwd())) 
[13:22:55.032]             setwd(...future.workdir)
[13:22:55.032]         {
[13:22:55.032]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:55.032]                 ...future.oldOptions$nwarnings <- NULL
[13:22:55.032]             }
[13:22:55.032]             base::options(...future.oldOptions)
[13:22:55.032]             if (.Platform$OS.type == "windows") {
[13:22:55.032]                 old_names <- names(...future.oldEnvVars)
[13:22:55.032]                 envs <- base::Sys.getenv()
[13:22:55.032]                 names <- names(envs)
[13:22:55.032]                 common <- intersect(names, old_names)
[13:22:55.032]                 added <- setdiff(names, old_names)
[13:22:55.032]                 removed <- setdiff(old_names, names)
[13:22:55.032]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:55.032]                   envs[common]]
[13:22:55.032]                 NAMES <- toupper(changed)
[13:22:55.032]                 args <- list()
[13:22:55.032]                 for (kk in seq_along(NAMES)) {
[13:22:55.032]                   name <- changed[[kk]]
[13:22:55.032]                   NAME <- NAMES[[kk]]
[13:22:55.032]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.032]                     next
[13:22:55.032]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.032]                 }
[13:22:55.032]                 NAMES <- toupper(added)
[13:22:55.032]                 for (kk in seq_along(NAMES)) {
[13:22:55.032]                   name <- added[[kk]]
[13:22:55.032]                   NAME <- NAMES[[kk]]
[13:22:55.032]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.032]                     next
[13:22:55.032]                   args[[name]] <- ""
[13:22:55.032]                 }
[13:22:55.032]                 NAMES <- toupper(removed)
[13:22:55.032]                 for (kk in seq_along(NAMES)) {
[13:22:55.032]                   name <- removed[[kk]]
[13:22:55.032]                   NAME <- NAMES[[kk]]
[13:22:55.032]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.032]                     next
[13:22:55.032]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.032]                 }
[13:22:55.032]                 if (length(args) > 0) 
[13:22:55.032]                   base::do.call(base::Sys.setenv, args = args)
[13:22:55.032]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:55.032]             }
[13:22:55.032]             else {
[13:22:55.032]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:55.032]             }
[13:22:55.032]             {
[13:22:55.032]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:55.032]                   0L) {
[13:22:55.032]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:55.032]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:55.032]                   base::options(opts)
[13:22:55.032]                 }
[13:22:55.032]                 {
[13:22:55.032]                   {
[13:22:55.032]                     NULL
[13:22:55.032]                     RNGkind("Mersenne-Twister")
[13:22:55.032]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:22:55.032]                       inherits = FALSE)
[13:22:55.032]                   }
[13:22:55.032]                   options(future.plan = NULL)
[13:22:55.032]                   if (is.na(NA_character_)) 
[13:22:55.032]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.032]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:55.032]                   future::plan(list(function (..., envir = parent.frame()) 
[13:22:55.032]                   {
[13:22:55.032]                     future <- SequentialFuture(..., envir = envir)
[13:22:55.032]                     if (!future$lazy) 
[13:22:55.032]                       future <- run(future)
[13:22:55.032]                     invisible(future)
[13:22:55.032]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:55.032]                 }
[13:22:55.032]             }
[13:22:55.032]         }
[13:22:55.032]     })
[13:22:55.032]     if (TRUE) {
[13:22:55.032]         base::sink(type = "output", split = FALSE)
[13:22:55.032]         if (TRUE) {
[13:22:55.032]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:55.032]         }
[13:22:55.032]         else {
[13:22:55.032]             ...future.result["stdout"] <- base::list(NULL)
[13:22:55.032]         }
[13:22:55.032]         base::close(...future.stdout)
[13:22:55.032]         ...future.stdout <- NULL
[13:22:55.032]     }
[13:22:55.032]     ...future.result$conditions <- ...future.conditions
[13:22:55.032]     ...future.result$finished <- base::Sys.time()
[13:22:55.032]     ...future.result
[13:22:55.032] }
[13:22:55.034] assign_globals() ...
[13:22:55.034] List of 1
[13:22:55.034]  $ a: num 2
[13:22:55.034]  - attr(*, "where")=List of 1
[13:22:55.034]   ..$ a:<environment: R_EmptyEnv> 
[13:22:55.034]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:22:55.034]  - attr(*, "resolved")= logi FALSE
[13:22:55.034]  - attr(*, "total_size")= num 56
[13:22:55.034]  - attr(*, "already-done")= logi TRUE
[13:22:55.042] - copied ‘a’ to environment
[13:22:55.042] assign_globals() ... done
[13:22:55.043] plan(): Setting new future strategy stack:
[13:22:55.043] List of future strategies:
[13:22:55.043] 1. sequential:
[13:22:55.043]    - args: function (..., envir = parent.frame())
[13:22:55.043]    - tweaked: FALSE
[13:22:55.043]    - call: NULL
[13:22:55.043] plan(): nbrOfWorkers() = 1
[13:22:55.044] plan(): Setting new future strategy stack:
[13:22:55.044] List of future strategies:
[13:22:55.044] 1. sequential:
[13:22:55.044]    - args: function (..., envir = parent.frame())
[13:22:55.044]    - tweaked: FALSE
[13:22:55.044]    - call: plan(strategy)
[13:22:55.044] plan(): nbrOfWorkers() = 1
[13:22:55.045] SequentialFuture started (and completed)
[13:22:55.045] - Launch lazy future ... done
[13:22:55.045] run() for ‘SequentialFuture’ ... done
** Future evaluation with errors
[13:22:55.045] getGlobalsAndPackages() ...
[13:22:55.045] Searching for globals...
[13:22:55.049] - globals found: [3] ‘{’, ‘<-’, ‘stop’
[13:22:55.049] Searching for globals ... DONE
[13:22:55.049] Resolving globals: FALSE
[13:22:55.049] 
[13:22:55.049] 
[13:22:55.049] getGlobalsAndPackages() ... DONE
[13:22:55.050] run() for ‘Future’ ...
[13:22:55.050] - state: ‘created’
[13:22:55.050] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:22:55.050] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:22:55.050] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:22:55.050]   - Field: ‘label’
[13:22:55.050]   - Field: ‘local’
[13:22:55.051]   - Field: ‘owner’
[13:22:55.051]   - Field: ‘envir’
[13:22:55.051]   - Field: ‘packages’
[13:22:55.051]   - Field: ‘gc’
[13:22:55.051]   - Field: ‘conditions’
[13:22:55.051]   - Field: ‘expr’
[13:22:55.051]   - Field: ‘uuid’
[13:22:55.051]   - Field: ‘seed’
[13:22:55.051]   - Field: ‘version’
[13:22:55.051]   - Field: ‘result’
[13:22:55.052]   - Field: ‘asynchronous’
[13:22:55.052]   - Field: ‘calls’
[13:22:55.052]   - Field: ‘globals’
[13:22:55.052]   - Field: ‘stdout’
[13:22:55.052]   - Field: ‘earlySignal’
[13:22:55.052]   - Field: ‘lazy’
[13:22:55.052]   - Field: ‘state’
[13:22:55.052] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:22:55.052] - Launch lazy future ...
[13:22:55.052] Packages needed by the future expression (n = 0): <none>
[13:22:55.053] Packages needed by future strategies (n = 0): <none>
[13:22:55.053] {
[13:22:55.053]     {
[13:22:55.053]         {
[13:22:55.053]             ...future.startTime <- base::Sys.time()
[13:22:55.053]             {
[13:22:55.053]                 {
[13:22:55.053]                   {
[13:22:55.053]                     base::local({
[13:22:55.053]                       has_future <- base::requireNamespace("future", 
[13:22:55.053]                         quietly = TRUE)
[13:22:55.053]                       if (has_future) {
[13:22:55.053]                         ns <- base::getNamespace("future")
[13:22:55.053]                         version <- ns[[".package"]][["version"]]
[13:22:55.053]                         if (is.null(version)) 
[13:22:55.053]                           version <- utils::packageVersion("future")
[13:22:55.053]                       }
[13:22:55.053]                       else {
[13:22:55.053]                         version <- NULL
[13:22:55.053]                       }
[13:22:55.053]                       if (!has_future || version < "1.8.0") {
[13:22:55.053]                         info <- base::c(r_version = base::gsub("R version ", 
[13:22:55.053]                           "", base::R.version$version.string), 
[13:22:55.053]                           platform = base::sprintf("%s (%s-bit)", 
[13:22:55.053]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:55.053]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:55.053]                             "release", "version")], collapse = " "), 
[13:22:55.053]                           hostname = base::Sys.info()[["nodename"]])
[13:22:55.053]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:22:55.053]                           info)
[13:22:55.053]                         info <- base::paste(info, collapse = "; ")
[13:22:55.053]                         if (!has_future) {
[13:22:55.053]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:55.053]                             info)
[13:22:55.053]                         }
[13:22:55.053]                         else {
[13:22:55.053]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:55.053]                             info, version)
[13:22:55.053]                         }
[13:22:55.053]                         base::stop(msg)
[13:22:55.053]                       }
[13:22:55.053]                     })
[13:22:55.053]                   }
[13:22:55.053]                   options(future.plan = NULL)
[13:22:55.053]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.053]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:55.053]                 }
[13:22:55.053]                 ...future.workdir <- getwd()
[13:22:55.053]             }
[13:22:55.053]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:55.053]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:55.053]         }
[13:22:55.053]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:55.053]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:55.053]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:55.053]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:55.053]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:55.053]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:55.053]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:55.053]             base::names(...future.oldOptions))
[13:22:55.053]     }
[13:22:55.053]     if (FALSE) {
[13:22:55.053]     }
[13:22:55.053]     else {
[13:22:55.053]         if (TRUE) {
[13:22:55.053]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:55.053]                 open = "w")
[13:22:55.053]         }
[13:22:55.053]         else {
[13:22:55.053]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:55.053]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:55.053]         }
[13:22:55.053]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:55.053]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:55.053]             base::sink(type = "output", split = FALSE)
[13:22:55.053]             base::close(...future.stdout)
[13:22:55.053]         }, add = TRUE)
[13:22:55.053]     }
[13:22:55.053]     ...future.frame <- base::sys.nframe()
[13:22:55.053]     ...future.conditions <- base::list()
[13:22:55.053]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:55.053]     if (FALSE) {
[13:22:55.053]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:55.053]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:55.053]     }
[13:22:55.053]     ...future.result <- base::tryCatch({
[13:22:55.053]         base::withCallingHandlers({
[13:22:55.053]             ...future.value <- base::withVisible(base::local({
[13:22:55.053]                 x <- 3
[13:22:55.053]                 stop("Woops!")
[13:22:55.053]                 x
[13:22:55.053]             }))
[13:22:55.053]             future::FutureResult(value = ...future.value$value, 
[13:22:55.053]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.053]                   ...future.rng), globalenv = if (FALSE) 
[13:22:55.053]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:55.053]                     ...future.globalenv.names))
[13:22:55.053]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:55.053]         }, condition = base::local({
[13:22:55.053]             c <- base::c
[13:22:55.053]             inherits <- base::inherits
[13:22:55.053]             invokeRestart <- base::invokeRestart
[13:22:55.053]             length <- base::length
[13:22:55.053]             list <- base::list
[13:22:55.053]             seq.int <- base::seq.int
[13:22:55.053]             signalCondition <- base::signalCondition
[13:22:55.053]             sys.calls <- base::sys.calls
[13:22:55.053]             `[[` <- base::`[[`
[13:22:55.053]             `+` <- base::`+`
[13:22:55.053]             `<<-` <- base::`<<-`
[13:22:55.053]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:55.053]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:55.053]                   3L)]
[13:22:55.053]             }
[13:22:55.053]             function(cond) {
[13:22:55.053]                 is_error <- inherits(cond, "error")
[13:22:55.053]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:55.053]                   NULL)
[13:22:55.053]                 if (is_error) {
[13:22:55.053]                   sessionInformation <- function() {
[13:22:55.053]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:55.053]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:55.053]                       search = base::search(), system = base::Sys.info())
[13:22:55.053]                   }
[13:22:55.053]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.053]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:55.053]                     cond$call), session = sessionInformation(), 
[13:22:55.053]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:55.053]                   signalCondition(cond)
[13:22:55.053]                 }
[13:22:55.053]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:55.053]                 "immediateCondition"))) {
[13:22:55.053]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:55.053]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.053]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:55.053]                   if (TRUE && !signal) {
[13:22:55.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.053]                     {
[13:22:55.053]                       inherits <- base::inherits
[13:22:55.053]                       invokeRestart <- base::invokeRestart
[13:22:55.053]                       is.null <- base::is.null
[13:22:55.053]                       muffled <- FALSE
[13:22:55.053]                       if (inherits(cond, "message")) {
[13:22:55.053]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.053]                         if (muffled) 
[13:22:55.053]                           invokeRestart("muffleMessage")
[13:22:55.053]                       }
[13:22:55.053]                       else if (inherits(cond, "warning")) {
[13:22:55.053]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.053]                         if (muffled) 
[13:22:55.053]                           invokeRestart("muffleWarning")
[13:22:55.053]                       }
[13:22:55.053]                       else if (inherits(cond, "condition")) {
[13:22:55.053]                         if (!is.null(pattern)) {
[13:22:55.053]                           computeRestarts <- base::computeRestarts
[13:22:55.053]                           grepl <- base::grepl
[13:22:55.053]                           restarts <- computeRestarts(cond)
[13:22:55.053]                           for (restart in restarts) {
[13:22:55.053]                             name <- restart$name
[13:22:55.053]                             if (is.null(name)) 
[13:22:55.053]                               next
[13:22:55.053]                             if (!grepl(pattern, name)) 
[13:22:55.053]                               next
[13:22:55.053]                             invokeRestart(restart)
[13:22:55.053]                             muffled <- TRUE
[13:22:55.053]                             break
[13:22:55.053]                           }
[13:22:55.053]                         }
[13:22:55.053]                       }
[13:22:55.053]                       invisible(muffled)
[13:22:55.053]                     }
[13:22:55.053]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.053]                   }
[13:22:55.053]                 }
[13:22:55.053]                 else {
[13:22:55.053]                   if (TRUE) {
[13:22:55.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.053]                     {
[13:22:55.053]                       inherits <- base::inherits
[13:22:55.053]                       invokeRestart <- base::invokeRestart
[13:22:55.053]                       is.null <- base::is.null
[13:22:55.053]                       muffled <- FALSE
[13:22:55.053]                       if (inherits(cond, "message")) {
[13:22:55.053]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.053]                         if (muffled) 
[13:22:55.053]                           invokeRestart("muffleMessage")
[13:22:55.053]                       }
[13:22:55.053]                       else if (inherits(cond, "warning")) {
[13:22:55.053]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.053]                         if (muffled) 
[13:22:55.053]                           invokeRestart("muffleWarning")
[13:22:55.053]                       }
[13:22:55.053]                       else if (inherits(cond, "condition")) {
[13:22:55.053]                         if (!is.null(pattern)) {
[13:22:55.053]                           computeRestarts <- base::computeRestarts
[13:22:55.053]                           grepl <- base::grepl
[13:22:55.053]                           restarts <- computeRestarts(cond)
[13:22:55.053]                           for (restart in restarts) {
[13:22:55.053]                             name <- restart$name
[13:22:55.053]                             if (is.null(name)) 
[13:22:55.053]                               next
[13:22:55.053]                             if (!grepl(pattern, name)) 
[13:22:55.053]                               next
[13:22:55.053]                             invokeRestart(restart)
[13:22:55.053]                             muffled <- TRUE
[13:22:55.053]                             break
[13:22:55.053]                           }
[13:22:55.053]                         }
[13:22:55.053]                       }
[13:22:55.053]                       invisible(muffled)
[13:22:55.053]                     }
[13:22:55.053]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.053]                   }
[13:22:55.053]                 }
[13:22:55.053]             }
[13:22:55.053]         }))
[13:22:55.053]     }, error = function(ex) {
[13:22:55.053]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:55.053]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.053]                 ...future.rng), started = ...future.startTime, 
[13:22:55.053]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:55.053]             version = "1.8"), class = "FutureResult")
[13:22:55.053]     }, finally = {
[13:22:55.053]         if (!identical(...future.workdir, getwd())) 
[13:22:55.053]             setwd(...future.workdir)
[13:22:55.053]         {
[13:22:55.053]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:55.053]                 ...future.oldOptions$nwarnings <- NULL
[13:22:55.053]             }
[13:22:55.053]             base::options(...future.oldOptions)
[13:22:55.053]             if (.Platform$OS.type == "windows") {
[13:22:55.053]                 old_names <- names(...future.oldEnvVars)
[13:22:55.053]                 envs <- base::Sys.getenv()
[13:22:55.053]                 names <- names(envs)
[13:22:55.053]                 common <- intersect(names, old_names)
[13:22:55.053]                 added <- setdiff(names, old_names)
[13:22:55.053]                 removed <- setdiff(old_names, names)
[13:22:55.053]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:55.053]                   envs[common]]
[13:22:55.053]                 NAMES <- toupper(changed)
[13:22:55.053]                 args <- list()
[13:22:55.053]                 for (kk in seq_along(NAMES)) {
[13:22:55.053]                   name <- changed[[kk]]
[13:22:55.053]                   NAME <- NAMES[[kk]]
[13:22:55.053]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.053]                     next
[13:22:55.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.053]                 }
[13:22:55.053]                 NAMES <- toupper(added)
[13:22:55.053]                 for (kk in seq_along(NAMES)) {
[13:22:55.053]                   name <- added[[kk]]
[13:22:55.053]                   NAME <- NAMES[[kk]]
[13:22:55.053]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.053]                     next
[13:22:55.053]                   args[[name]] <- ""
[13:22:55.053]                 }
[13:22:55.053]                 NAMES <- toupper(removed)
[13:22:55.053]                 for (kk in seq_along(NAMES)) {
[13:22:55.053]                   name <- removed[[kk]]
[13:22:55.053]                   NAME <- NAMES[[kk]]
[13:22:55.053]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.053]                     next
[13:22:55.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.053]                 }
[13:22:55.053]                 if (length(args) > 0) 
[13:22:55.053]                   base::do.call(base::Sys.setenv, args = args)
[13:22:55.053]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:55.053]             }
[13:22:55.053]             else {
[13:22:55.053]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:55.053]             }
[13:22:55.053]             {
[13:22:55.053]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:55.053]                   0L) {
[13:22:55.053]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:55.053]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:55.053]                   base::options(opts)
[13:22:55.053]                 }
[13:22:55.053]                 {
[13:22:55.053]                   {
[13:22:55.053]                     NULL
[13:22:55.053]                     RNGkind("Mersenne-Twister")
[13:22:55.053]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:22:55.053]                       inherits = FALSE)
[13:22:55.053]                   }
[13:22:55.053]                   options(future.plan = NULL)
[13:22:55.053]                   if (is.na(NA_character_)) 
[13:22:55.053]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.053]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:55.053]                   future::plan(list(function (..., envir = parent.frame()) 
[13:22:55.053]                   {
[13:22:55.053]                     future <- SequentialFuture(..., envir = envir)
[13:22:55.053]                     if (!future$lazy) 
[13:22:55.053]                       future <- run(future)
[13:22:55.053]                     invisible(future)
[13:22:55.053]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:55.053]                 }
[13:22:55.053]             }
[13:22:55.053]         }
[13:22:55.053]     })
[13:22:55.053]     if (TRUE) {
[13:22:55.053]         base::sink(type = "output", split = FALSE)
[13:22:55.053]         if (TRUE) {
[13:22:55.053]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:55.053]         }
[13:22:55.053]         else {
[13:22:55.053]             ...future.result["stdout"] <- base::list(NULL)
[13:22:55.053]         }
[13:22:55.053]         base::close(...future.stdout)
[13:22:55.053]         ...future.stdout <- NULL
[13:22:55.053]     }
[13:22:55.053]     ...future.result$conditions <- ...future.conditions
[13:22:55.053]     ...future.result$finished <- base::Sys.time()
[13:22:55.053]     ...future.result
[13:22:55.053] }
[13:22:55.055] plan(): Setting new future strategy stack:
[13:22:55.055] List of future strategies:
[13:22:55.055] 1. sequential:
[13:22:55.055]    - args: function (..., envir = parent.frame())
[13:22:55.055]    - tweaked: FALSE
[13:22:55.055]    - call: NULL
[13:22:55.055] plan(): nbrOfWorkers() = 1
[13:22:55.056] plan(): Setting new future strategy stack:
[13:22:55.056] List of future strategies:
[13:22:55.056] 1. sequential:
[13:22:55.056]    - args: function (..., envir = parent.frame())
[13:22:55.056]    - tweaked: FALSE
[13:22:55.056]    - call: plan(strategy)
[13:22:55.057] plan(): nbrOfWorkers() = 1
[13:22:55.057] SequentialFuture started (and completed)
[13:22:55.057] signalConditions() ...
[13:22:55.057]  - include = ‘immediateCondition’
[13:22:55.057]  - exclude = 
[13:22:55.057]  - resignal = FALSE
[13:22:55.057]  - Number of conditions: 1
[13:22:55.057] signalConditions() ... done
[13:22:55.057] - Launch lazy future ... done
[13:22:55.058] run() for ‘SequentialFuture’ ... done
[13:22:55.058] signalConditions() ...
[13:22:55.058]  - include = ‘immediateCondition’
[13:22:55.058]  - exclude = 
[13:22:55.058]  - resignal = FALSE
[13:22:55.058]  - Number of conditions: 1
[13:22:55.058] signalConditions() ... done
[13:22:55.058] Future state: ‘finished’
[13:22:55.058] signalConditions() ...
[13:22:55.059]  - include = ‘condition’
[13:22:55.059]  - exclude = ‘immediateCondition’
[13:22:55.059]  - resignal = TRUE
[13:22:55.059]  - Number of conditions: 1
[13:22:55.059]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:22:55.059] signalConditions() ... done
[13:22:55.060] getGlobalsAndPackages() ...
[13:22:55.060] Searching for globals...
[13:22:55.062] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[13:22:55.062] Searching for globals ... DONE
[13:22:55.062] Resolving globals: FALSE
[13:22:55.062] The total size of the 1 globals is 56 bytes (56 bytes)
[13:22:55.063] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:22:55.063] - globals: [1] ‘ii’
[13:22:55.063] 
[13:22:55.063] getGlobalsAndPackages() ... DONE
[13:22:55.063] run() for ‘Future’ ...
[13:22:55.064] - state: ‘created’
[13:22:55.064] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:22:55.064] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:22:55.064] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:22:55.064]   - Field: ‘label’
[13:22:55.064]   - Field: ‘local’
[13:22:55.064]   - Field: ‘owner’
[13:22:55.064]   - Field: ‘envir’
[13:22:55.065]   - Field: ‘packages’
[13:22:55.065]   - Field: ‘gc’
[13:22:55.065]   - Field: ‘conditions’
[13:22:55.065]   - Field: ‘expr’
[13:22:55.065]   - Field: ‘uuid’
[13:22:55.065]   - Field: ‘seed’
[13:22:55.065]   - Field: ‘version’
[13:22:55.065]   - Field: ‘result’
[13:22:55.065]   - Field: ‘asynchronous’
[13:22:55.065]   - Field: ‘calls’
[13:22:55.065]   - Field: ‘globals’
[13:22:55.066]   - Field: ‘stdout’
[13:22:55.066]   - Field: ‘earlySignal’
[13:22:55.066]   - Field: ‘lazy’
[13:22:55.066]   - Field: ‘state’
[13:22:55.066] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:22:55.066] - Launch lazy future ...
[13:22:55.066] Packages needed by the future expression (n = 0): <none>
[13:22:55.066] Packages needed by future strategies (n = 0): <none>
[13:22:55.067] {
[13:22:55.067]     {
[13:22:55.067]         {
[13:22:55.067]             ...future.startTime <- base::Sys.time()
[13:22:55.067]             {
[13:22:55.067]                 {
[13:22:55.067]                   {
[13:22:55.067]                     base::local({
[13:22:55.067]                       has_future <- base::requireNamespace("future", 
[13:22:55.067]                         quietly = TRUE)
[13:22:55.067]                       if (has_future) {
[13:22:55.067]                         ns <- base::getNamespace("future")
[13:22:55.067]                         version <- ns[[".package"]][["version"]]
[13:22:55.067]                         if (is.null(version)) 
[13:22:55.067]                           version <- utils::packageVersion("future")
[13:22:55.067]                       }
[13:22:55.067]                       else {
[13:22:55.067]                         version <- NULL
[13:22:55.067]                       }
[13:22:55.067]                       if (!has_future || version < "1.8.0") {
[13:22:55.067]                         info <- base::c(r_version = base::gsub("R version ", 
[13:22:55.067]                           "", base::R.version$version.string), 
[13:22:55.067]                           platform = base::sprintf("%s (%s-bit)", 
[13:22:55.067]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:55.067]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:55.067]                             "release", "version")], collapse = " "), 
[13:22:55.067]                           hostname = base::Sys.info()[["nodename"]])
[13:22:55.067]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:22:55.067]                           info)
[13:22:55.067]                         info <- base::paste(info, collapse = "; ")
[13:22:55.067]                         if (!has_future) {
[13:22:55.067]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:55.067]                             info)
[13:22:55.067]                         }
[13:22:55.067]                         else {
[13:22:55.067]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:55.067]                             info, version)
[13:22:55.067]                         }
[13:22:55.067]                         base::stop(msg)
[13:22:55.067]                       }
[13:22:55.067]                     })
[13:22:55.067]                   }
[13:22:55.067]                   options(future.plan = NULL)
[13:22:55.067]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.067]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:55.067]                 }
[13:22:55.067]                 ...future.workdir <- getwd()
[13:22:55.067]             }
[13:22:55.067]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:55.067]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:55.067]         }
[13:22:55.067]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:55.067]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:55.067]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:55.067]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:55.067]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:55.067]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:55.067]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:55.067]             base::names(...future.oldOptions))
[13:22:55.067]     }
[13:22:55.067]     if (FALSE) {
[13:22:55.067]     }
[13:22:55.067]     else {
[13:22:55.067]         if (TRUE) {
[13:22:55.067]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:55.067]                 open = "w")
[13:22:55.067]         }
[13:22:55.067]         else {
[13:22:55.067]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:55.067]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:55.067]         }
[13:22:55.067]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:55.067]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:55.067]             base::sink(type = "output", split = FALSE)
[13:22:55.067]             base::close(...future.stdout)
[13:22:55.067]         }, add = TRUE)
[13:22:55.067]     }
[13:22:55.067]     ...future.frame <- base::sys.nframe()
[13:22:55.067]     ...future.conditions <- base::list()
[13:22:55.067]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:55.067]     if (FALSE) {
[13:22:55.067]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:55.067]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:55.067]     }
[13:22:55.067]     ...future.result <- base::tryCatch({
[13:22:55.067]         base::withCallingHandlers({
[13:22:55.067]             ...future.value <- base::withVisible(base::local({
[13:22:55.067]                 if (ii%%2 == 0) 
[13:22:55.067]                   stop("Woops!")
[13:22:55.067]                 ii
[13:22:55.067]             }))
[13:22:55.067]             future::FutureResult(value = ...future.value$value, 
[13:22:55.067]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.067]                   ...future.rng), globalenv = if (FALSE) 
[13:22:55.067]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:55.067]                     ...future.globalenv.names))
[13:22:55.067]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:55.067]         }, condition = base::local({
[13:22:55.067]             c <- base::c
[13:22:55.067]             inherits <- base::inherits
[13:22:55.067]             invokeRestart <- base::invokeRestart
[13:22:55.067]             length <- base::length
[13:22:55.067]             list <- base::list
[13:22:55.067]             seq.int <- base::seq.int
[13:22:55.067]             signalCondition <- base::signalCondition
[13:22:55.067]             sys.calls <- base::sys.calls
[13:22:55.067]             `[[` <- base::`[[`
[13:22:55.067]             `+` <- base::`+`
[13:22:55.067]             `<<-` <- base::`<<-`
[13:22:55.067]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:55.067]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:55.067]                   3L)]
[13:22:55.067]             }
[13:22:55.067]             function(cond) {
[13:22:55.067]                 is_error <- inherits(cond, "error")
[13:22:55.067]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:55.067]                   NULL)
[13:22:55.067]                 if (is_error) {
[13:22:55.067]                   sessionInformation <- function() {
[13:22:55.067]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:55.067]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:55.067]                       search = base::search(), system = base::Sys.info())
[13:22:55.067]                   }
[13:22:55.067]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.067]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:55.067]                     cond$call), session = sessionInformation(), 
[13:22:55.067]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:55.067]                   signalCondition(cond)
[13:22:55.067]                 }
[13:22:55.067]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:55.067]                 "immediateCondition"))) {
[13:22:55.067]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:55.067]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.067]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:55.067]                   if (TRUE && !signal) {
[13:22:55.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.067]                     {
[13:22:55.067]                       inherits <- base::inherits
[13:22:55.067]                       invokeRestart <- base::invokeRestart
[13:22:55.067]                       is.null <- base::is.null
[13:22:55.067]                       muffled <- FALSE
[13:22:55.067]                       if (inherits(cond, "message")) {
[13:22:55.067]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.067]                         if (muffled) 
[13:22:55.067]                           invokeRestart("muffleMessage")
[13:22:55.067]                       }
[13:22:55.067]                       else if (inherits(cond, "warning")) {
[13:22:55.067]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.067]                         if (muffled) 
[13:22:55.067]                           invokeRestart("muffleWarning")
[13:22:55.067]                       }
[13:22:55.067]                       else if (inherits(cond, "condition")) {
[13:22:55.067]                         if (!is.null(pattern)) {
[13:22:55.067]                           computeRestarts <- base::computeRestarts
[13:22:55.067]                           grepl <- base::grepl
[13:22:55.067]                           restarts <- computeRestarts(cond)
[13:22:55.067]                           for (restart in restarts) {
[13:22:55.067]                             name <- restart$name
[13:22:55.067]                             if (is.null(name)) 
[13:22:55.067]                               next
[13:22:55.067]                             if (!grepl(pattern, name)) 
[13:22:55.067]                               next
[13:22:55.067]                             invokeRestart(restart)
[13:22:55.067]                             muffled <- TRUE
[13:22:55.067]                             break
[13:22:55.067]                           }
[13:22:55.067]                         }
[13:22:55.067]                       }
[13:22:55.067]                       invisible(muffled)
[13:22:55.067]                     }
[13:22:55.067]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.067]                   }
[13:22:55.067]                 }
[13:22:55.067]                 else {
[13:22:55.067]                   if (TRUE) {
[13:22:55.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.067]                     {
[13:22:55.067]                       inherits <- base::inherits
[13:22:55.067]                       invokeRestart <- base::invokeRestart
[13:22:55.067]                       is.null <- base::is.null
[13:22:55.067]                       muffled <- FALSE
[13:22:55.067]                       if (inherits(cond, "message")) {
[13:22:55.067]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.067]                         if (muffled) 
[13:22:55.067]                           invokeRestart("muffleMessage")
[13:22:55.067]                       }
[13:22:55.067]                       else if (inherits(cond, "warning")) {
[13:22:55.067]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.067]                         if (muffled) 
[13:22:55.067]                           invokeRestart("muffleWarning")
[13:22:55.067]                       }
[13:22:55.067]                       else if (inherits(cond, "condition")) {
[13:22:55.067]                         if (!is.null(pattern)) {
[13:22:55.067]                           computeRestarts <- base::computeRestarts
[13:22:55.067]                           grepl <- base::grepl
[13:22:55.067]                           restarts <- computeRestarts(cond)
[13:22:55.067]                           for (restart in restarts) {
[13:22:55.067]                             name <- restart$name
[13:22:55.067]                             if (is.null(name)) 
[13:22:55.067]                               next
[13:22:55.067]                             if (!grepl(pattern, name)) 
[13:22:55.067]                               next
[13:22:55.067]                             invokeRestart(restart)
[13:22:55.067]                             muffled <- TRUE
[13:22:55.067]                             break
[13:22:55.067]                           }
[13:22:55.067]                         }
[13:22:55.067]                       }
[13:22:55.067]                       invisible(muffled)
[13:22:55.067]                     }
[13:22:55.067]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.067]                   }
[13:22:55.067]                 }
[13:22:55.067]             }
[13:22:55.067]         }))
[13:22:55.067]     }, error = function(ex) {
[13:22:55.067]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:55.067]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.067]                 ...future.rng), started = ...future.startTime, 
[13:22:55.067]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:55.067]             version = "1.8"), class = "FutureResult")
[13:22:55.067]     }, finally = {
[13:22:55.067]         if (!identical(...future.workdir, getwd())) 
[13:22:55.067]             setwd(...future.workdir)
[13:22:55.067]         {
[13:22:55.067]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:55.067]                 ...future.oldOptions$nwarnings <- NULL
[13:22:55.067]             }
[13:22:55.067]             base::options(...future.oldOptions)
[13:22:55.067]             if (.Platform$OS.type == "windows") {
[13:22:55.067]                 old_names <- names(...future.oldEnvVars)
[13:22:55.067]                 envs <- base::Sys.getenv()
[13:22:55.067]                 names <- names(envs)
[13:22:55.067]                 common <- intersect(names, old_names)
[13:22:55.067]                 added <- setdiff(names, old_names)
[13:22:55.067]                 removed <- setdiff(old_names, names)
[13:22:55.067]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:55.067]                   envs[common]]
[13:22:55.067]                 NAMES <- toupper(changed)
[13:22:55.067]                 args <- list()
[13:22:55.067]                 for (kk in seq_along(NAMES)) {
[13:22:55.067]                   name <- changed[[kk]]
[13:22:55.067]                   NAME <- NAMES[[kk]]
[13:22:55.067]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.067]                     next
[13:22:55.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.067]                 }
[13:22:55.067]                 NAMES <- toupper(added)
[13:22:55.067]                 for (kk in seq_along(NAMES)) {
[13:22:55.067]                   name <- added[[kk]]
[13:22:55.067]                   NAME <- NAMES[[kk]]
[13:22:55.067]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.067]                     next
[13:22:55.067]                   args[[name]] <- ""
[13:22:55.067]                 }
[13:22:55.067]                 NAMES <- toupper(removed)
[13:22:55.067]                 for (kk in seq_along(NAMES)) {
[13:22:55.067]                   name <- removed[[kk]]
[13:22:55.067]                   NAME <- NAMES[[kk]]
[13:22:55.067]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.067]                     next
[13:22:55.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.067]                 }
[13:22:55.067]                 if (length(args) > 0) 
[13:22:55.067]                   base::do.call(base::Sys.setenv, args = args)
[13:22:55.067]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:55.067]             }
[13:22:55.067]             else {
[13:22:55.067]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:55.067]             }
[13:22:55.067]             {
[13:22:55.067]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:55.067]                   0L) {
[13:22:55.067]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:55.067]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:55.067]                   base::options(opts)
[13:22:55.067]                 }
[13:22:55.067]                 {
[13:22:55.067]                   {
[13:22:55.067]                     NULL
[13:22:55.067]                     RNGkind("Mersenne-Twister")
[13:22:55.067]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:22:55.067]                       inherits = FALSE)
[13:22:55.067]                   }
[13:22:55.067]                   options(future.plan = NULL)
[13:22:55.067]                   if (is.na(NA_character_)) 
[13:22:55.067]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.067]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:55.067]                   future::plan(list(function (..., envir = parent.frame()) 
[13:22:55.067]                   {
[13:22:55.067]                     future <- SequentialFuture(..., envir = envir)
[13:22:55.067]                     if (!future$lazy) 
[13:22:55.067]                       future <- run(future)
[13:22:55.067]                     invisible(future)
[13:22:55.067]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:55.067]                 }
[13:22:55.067]             }
[13:22:55.067]         }
[13:22:55.067]     })
[13:22:55.067]     if (TRUE) {
[13:22:55.067]         base::sink(type = "output", split = FALSE)
[13:22:55.067]         if (TRUE) {
[13:22:55.067]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:55.067]         }
[13:22:55.067]         else {
[13:22:55.067]             ...future.result["stdout"] <- base::list(NULL)
[13:22:55.067]         }
[13:22:55.067]         base::close(...future.stdout)
[13:22:55.067]         ...future.stdout <- NULL
[13:22:55.067]     }
[13:22:55.067]     ...future.result$conditions <- ...future.conditions
[13:22:55.067]     ...future.result$finished <- base::Sys.time()
[13:22:55.067]     ...future.result
[13:22:55.067] }
[13:22:55.068] assign_globals() ...
[13:22:55.069] List of 1
[13:22:55.069]  $ ii: int 1
[13:22:55.069]  - attr(*, "where")=List of 1
[13:22:55.069]   ..$ ii:<environment: R_EmptyEnv> 
[13:22:55.069]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:22:55.069]  - attr(*, "resolved")= logi FALSE
[13:22:55.069]  - attr(*, "total_size")= num 56
[13:22:55.069]  - attr(*, "already-done")= logi TRUE
[13:22:55.073] - copied ‘ii’ to environment
[13:22:55.073] assign_globals() ... done
[13:22:55.073] plan(): Setting new future strategy stack:
[13:22:55.074] List of future strategies:
[13:22:55.074] 1. sequential:
[13:22:55.074]    - args: function (..., envir = parent.frame())
[13:22:55.074]    - tweaked: FALSE
[13:22:55.074]    - call: NULL
[13:22:55.074] plan(): nbrOfWorkers() = 1
[13:22:55.075] plan(): Setting new future strategy stack:
[13:22:55.075] List of future strategies:
[13:22:55.075] 1. sequential:
[13:22:55.075]    - args: function (..., envir = parent.frame())
[13:22:55.075]    - tweaked: FALSE
[13:22:55.075]    - call: plan(strategy)
[13:22:55.075] plan(): nbrOfWorkers() = 1
[13:22:55.075] SequentialFuture started (and completed)
[13:22:55.076] - Launch lazy future ... done
[13:22:55.076] run() for ‘SequentialFuture’ ... done
[13:22:55.076] getGlobalsAndPackages() ...
[13:22:55.076] Searching for globals...
[13:22:55.078] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[13:22:55.078] Searching for globals ... DONE
[13:22:55.078] Resolving globals: FALSE
[13:22:55.078] The total size of the 1 globals is 56 bytes (56 bytes)
[13:22:55.079] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:22:55.079] - globals: [1] ‘ii’
[13:22:55.079] 
[13:22:55.079] getGlobalsAndPackages() ... DONE
[13:22:55.079] run() for ‘Future’ ...
[13:22:55.080] - state: ‘created’
[13:22:55.080] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:22:55.080] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:22:55.080] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:22:55.080]   - Field: ‘label’
[13:22:55.080]   - Field: ‘local’
[13:22:55.080]   - Field: ‘owner’
[13:22:55.081]   - Field: ‘envir’
[13:22:55.081]   - Field: ‘packages’
[13:22:55.081]   - Field: ‘gc’
[13:22:55.081]   - Field: ‘conditions’
[13:22:55.081]   - Field: ‘expr’
[13:22:55.081]   - Field: ‘uuid’
[13:22:55.081]   - Field: ‘seed’
[13:22:55.081]   - Field: ‘version’
[13:22:55.081]   - Field: ‘result’
[13:22:55.081]   - Field: ‘asynchronous’
[13:22:55.081]   - Field: ‘calls’
[13:22:55.082]   - Field: ‘globals’
[13:22:55.082]   - Field: ‘stdout’
[13:22:55.082]   - Field: ‘earlySignal’
[13:22:55.082]   - Field: ‘lazy’
[13:22:55.082]   - Field: ‘state’
[13:22:55.082] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:22:55.082] - Launch lazy future ...
[13:22:55.082] Packages needed by the future expression (n = 0): <none>
[13:22:55.082] Packages needed by future strategies (n = 0): <none>
[13:22:55.083] {
[13:22:55.083]     {
[13:22:55.083]         {
[13:22:55.083]             ...future.startTime <- base::Sys.time()
[13:22:55.083]             {
[13:22:55.083]                 {
[13:22:55.083]                   {
[13:22:55.083]                     base::local({
[13:22:55.083]                       has_future <- base::requireNamespace("future", 
[13:22:55.083]                         quietly = TRUE)
[13:22:55.083]                       if (has_future) {
[13:22:55.083]                         ns <- base::getNamespace("future")
[13:22:55.083]                         version <- ns[[".package"]][["version"]]
[13:22:55.083]                         if (is.null(version)) 
[13:22:55.083]                           version <- utils::packageVersion("future")
[13:22:55.083]                       }
[13:22:55.083]                       else {
[13:22:55.083]                         version <- NULL
[13:22:55.083]                       }
[13:22:55.083]                       if (!has_future || version < "1.8.0") {
[13:22:55.083]                         info <- base::c(r_version = base::gsub("R version ", 
[13:22:55.083]                           "", base::R.version$version.string), 
[13:22:55.083]                           platform = base::sprintf("%s (%s-bit)", 
[13:22:55.083]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:55.083]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:55.083]                             "release", "version")], collapse = " "), 
[13:22:55.083]                           hostname = base::Sys.info()[["nodename"]])
[13:22:55.083]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:22:55.083]                           info)
[13:22:55.083]                         info <- base::paste(info, collapse = "; ")
[13:22:55.083]                         if (!has_future) {
[13:22:55.083]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:55.083]                             info)
[13:22:55.083]                         }
[13:22:55.083]                         else {
[13:22:55.083]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:55.083]                             info, version)
[13:22:55.083]                         }
[13:22:55.083]                         base::stop(msg)
[13:22:55.083]                       }
[13:22:55.083]                     })
[13:22:55.083]                   }
[13:22:55.083]                   options(future.plan = NULL)
[13:22:55.083]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.083]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:55.083]                 }
[13:22:55.083]                 ...future.workdir <- getwd()
[13:22:55.083]             }
[13:22:55.083]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:55.083]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:55.083]         }
[13:22:55.083]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:55.083]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:55.083]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:55.083]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:55.083]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:55.083]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:55.083]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:55.083]             base::names(...future.oldOptions))
[13:22:55.083]     }
[13:22:55.083]     if (FALSE) {
[13:22:55.083]     }
[13:22:55.083]     else {
[13:22:55.083]         if (TRUE) {
[13:22:55.083]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:55.083]                 open = "w")
[13:22:55.083]         }
[13:22:55.083]         else {
[13:22:55.083]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:55.083]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:55.083]         }
[13:22:55.083]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:55.083]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:55.083]             base::sink(type = "output", split = FALSE)
[13:22:55.083]             base::close(...future.stdout)
[13:22:55.083]         }, add = TRUE)
[13:22:55.083]     }
[13:22:55.083]     ...future.frame <- base::sys.nframe()
[13:22:55.083]     ...future.conditions <- base::list()
[13:22:55.083]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:55.083]     if (FALSE) {
[13:22:55.083]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:55.083]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:55.083]     }
[13:22:55.083]     ...future.result <- base::tryCatch({
[13:22:55.083]         base::withCallingHandlers({
[13:22:55.083]             ...future.value <- base::withVisible(base::local({
[13:22:55.083]                 if (ii%%2 == 0) 
[13:22:55.083]                   stop("Woops!")
[13:22:55.083]                 ii
[13:22:55.083]             }))
[13:22:55.083]             future::FutureResult(value = ...future.value$value, 
[13:22:55.083]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.083]                   ...future.rng), globalenv = if (FALSE) 
[13:22:55.083]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:55.083]                     ...future.globalenv.names))
[13:22:55.083]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:55.083]         }, condition = base::local({
[13:22:55.083]             c <- base::c
[13:22:55.083]             inherits <- base::inherits
[13:22:55.083]             invokeRestart <- base::invokeRestart
[13:22:55.083]             length <- base::length
[13:22:55.083]             list <- base::list
[13:22:55.083]             seq.int <- base::seq.int
[13:22:55.083]             signalCondition <- base::signalCondition
[13:22:55.083]             sys.calls <- base::sys.calls
[13:22:55.083]             `[[` <- base::`[[`
[13:22:55.083]             `+` <- base::`+`
[13:22:55.083]             `<<-` <- base::`<<-`
[13:22:55.083]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:55.083]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:55.083]                   3L)]
[13:22:55.083]             }
[13:22:55.083]             function(cond) {
[13:22:55.083]                 is_error <- inherits(cond, "error")
[13:22:55.083]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:55.083]                   NULL)
[13:22:55.083]                 if (is_error) {
[13:22:55.083]                   sessionInformation <- function() {
[13:22:55.083]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:55.083]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:55.083]                       search = base::search(), system = base::Sys.info())
[13:22:55.083]                   }
[13:22:55.083]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.083]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:55.083]                     cond$call), session = sessionInformation(), 
[13:22:55.083]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:55.083]                   signalCondition(cond)
[13:22:55.083]                 }
[13:22:55.083]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:55.083]                 "immediateCondition"))) {
[13:22:55.083]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:55.083]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.083]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:55.083]                   if (TRUE && !signal) {
[13:22:55.083]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.083]                     {
[13:22:55.083]                       inherits <- base::inherits
[13:22:55.083]                       invokeRestart <- base::invokeRestart
[13:22:55.083]                       is.null <- base::is.null
[13:22:55.083]                       muffled <- FALSE
[13:22:55.083]                       if (inherits(cond, "message")) {
[13:22:55.083]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.083]                         if (muffled) 
[13:22:55.083]                           invokeRestart("muffleMessage")
[13:22:55.083]                       }
[13:22:55.083]                       else if (inherits(cond, "warning")) {
[13:22:55.083]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.083]                         if (muffled) 
[13:22:55.083]                           invokeRestart("muffleWarning")
[13:22:55.083]                       }
[13:22:55.083]                       else if (inherits(cond, "condition")) {
[13:22:55.083]                         if (!is.null(pattern)) {
[13:22:55.083]                           computeRestarts <- base::computeRestarts
[13:22:55.083]                           grepl <- base::grepl
[13:22:55.083]                           restarts <- computeRestarts(cond)
[13:22:55.083]                           for (restart in restarts) {
[13:22:55.083]                             name <- restart$name
[13:22:55.083]                             if (is.null(name)) 
[13:22:55.083]                               next
[13:22:55.083]                             if (!grepl(pattern, name)) 
[13:22:55.083]                               next
[13:22:55.083]                             invokeRestart(restart)
[13:22:55.083]                             muffled <- TRUE
[13:22:55.083]                             break
[13:22:55.083]                           }
[13:22:55.083]                         }
[13:22:55.083]                       }
[13:22:55.083]                       invisible(muffled)
[13:22:55.083]                     }
[13:22:55.083]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.083]                   }
[13:22:55.083]                 }
[13:22:55.083]                 else {
[13:22:55.083]                   if (TRUE) {
[13:22:55.083]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.083]                     {
[13:22:55.083]                       inherits <- base::inherits
[13:22:55.083]                       invokeRestart <- base::invokeRestart
[13:22:55.083]                       is.null <- base::is.null
[13:22:55.083]                       muffled <- FALSE
[13:22:55.083]                       if (inherits(cond, "message")) {
[13:22:55.083]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.083]                         if (muffled) 
[13:22:55.083]                           invokeRestart("muffleMessage")
[13:22:55.083]                       }
[13:22:55.083]                       else if (inherits(cond, "warning")) {
[13:22:55.083]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.083]                         if (muffled) 
[13:22:55.083]                           invokeRestart("muffleWarning")
[13:22:55.083]                       }
[13:22:55.083]                       else if (inherits(cond, "condition")) {
[13:22:55.083]                         if (!is.null(pattern)) {
[13:22:55.083]                           computeRestarts <- base::computeRestarts
[13:22:55.083]                           grepl <- base::grepl
[13:22:55.083]                           restarts <- computeRestarts(cond)
[13:22:55.083]                           for (restart in restarts) {
[13:22:55.083]                             name <- restart$name
[13:22:55.083]                             if (is.null(name)) 
[13:22:55.083]                               next
[13:22:55.083]                             if (!grepl(pattern, name)) 
[13:22:55.083]                               next
[13:22:55.083]                             invokeRestart(restart)
[13:22:55.083]                             muffled <- TRUE
[13:22:55.083]                             break
[13:22:55.083]                           }
[13:22:55.083]                         }
[13:22:55.083]                       }
[13:22:55.083]                       invisible(muffled)
[13:22:55.083]                     }
[13:22:55.083]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.083]                   }
[13:22:55.083]                 }
[13:22:55.083]             }
[13:22:55.083]         }))
[13:22:55.083]     }, error = function(ex) {
[13:22:55.083]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:55.083]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.083]                 ...future.rng), started = ...future.startTime, 
[13:22:55.083]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:55.083]             version = "1.8"), class = "FutureResult")
[13:22:55.083]     }, finally = {
[13:22:55.083]         if (!identical(...future.workdir, getwd())) 
[13:22:55.083]             setwd(...future.workdir)
[13:22:55.083]         {
[13:22:55.083]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:55.083]                 ...future.oldOptions$nwarnings <- NULL
[13:22:55.083]             }
[13:22:55.083]             base::options(...future.oldOptions)
[13:22:55.083]             if (.Platform$OS.type == "windows") {
[13:22:55.083]                 old_names <- names(...future.oldEnvVars)
[13:22:55.083]                 envs <- base::Sys.getenv()
[13:22:55.083]                 names <- names(envs)
[13:22:55.083]                 common <- intersect(names, old_names)
[13:22:55.083]                 added <- setdiff(names, old_names)
[13:22:55.083]                 removed <- setdiff(old_names, names)
[13:22:55.083]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:55.083]                   envs[common]]
[13:22:55.083]                 NAMES <- toupper(changed)
[13:22:55.083]                 args <- list()
[13:22:55.083]                 for (kk in seq_along(NAMES)) {
[13:22:55.083]                   name <- changed[[kk]]
[13:22:55.083]                   NAME <- NAMES[[kk]]
[13:22:55.083]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.083]                     next
[13:22:55.083]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.083]                 }
[13:22:55.083]                 NAMES <- toupper(added)
[13:22:55.083]                 for (kk in seq_along(NAMES)) {
[13:22:55.083]                   name <- added[[kk]]
[13:22:55.083]                   NAME <- NAMES[[kk]]
[13:22:55.083]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.083]                     next
[13:22:55.083]                   args[[name]] <- ""
[13:22:55.083]                 }
[13:22:55.083]                 NAMES <- toupper(removed)
[13:22:55.083]                 for (kk in seq_along(NAMES)) {
[13:22:55.083]                   name <- removed[[kk]]
[13:22:55.083]                   NAME <- NAMES[[kk]]
[13:22:55.083]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.083]                     next
[13:22:55.083]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.083]                 }
[13:22:55.083]                 if (length(args) > 0) 
[13:22:55.083]                   base::do.call(base::Sys.setenv, args = args)
[13:22:55.083]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:55.083]             }
[13:22:55.083]             else {
[13:22:55.083]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:55.083]             }
[13:22:55.083]             {
[13:22:55.083]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:55.083]                   0L) {
[13:22:55.083]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:55.083]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:55.083]                   base::options(opts)
[13:22:55.083]                 }
[13:22:55.083]                 {
[13:22:55.083]                   {
[13:22:55.083]                     NULL
[13:22:55.083]                     RNGkind("Mersenne-Twister")
[13:22:55.083]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:22:55.083]                       inherits = FALSE)
[13:22:55.083]                   }
[13:22:55.083]                   options(future.plan = NULL)
[13:22:55.083]                   if (is.na(NA_character_)) 
[13:22:55.083]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.083]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:55.083]                   future::plan(list(function (..., envir = parent.frame()) 
[13:22:55.083]                   {
[13:22:55.083]                     future <- SequentialFuture(..., envir = envir)
[13:22:55.083]                     if (!future$lazy) 
[13:22:55.083]                       future <- run(future)
[13:22:55.083]                     invisible(future)
[13:22:55.083]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:55.083]                 }
[13:22:55.083]             }
[13:22:55.083]         }
[13:22:55.083]     })
[13:22:55.083]     if (TRUE) {
[13:22:55.083]         base::sink(type = "output", split = FALSE)
[13:22:55.083]         if (TRUE) {
[13:22:55.083]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:55.083]         }
[13:22:55.083]         else {
[13:22:55.083]             ...future.result["stdout"] <- base::list(NULL)
[13:22:55.083]         }
[13:22:55.083]         base::close(...future.stdout)
[13:22:55.083]         ...future.stdout <- NULL
[13:22:55.083]     }
[13:22:55.083]     ...future.result$conditions <- ...future.conditions
[13:22:55.083]     ...future.result$finished <- base::Sys.time()
[13:22:55.083]     ...future.result
[13:22:55.083] }
[13:22:55.085] assign_globals() ...
[13:22:55.085] List of 1
[13:22:55.085]  $ ii: int 2
[13:22:55.085]  - attr(*, "where")=List of 1
[13:22:55.085]   ..$ ii:<environment: R_EmptyEnv> 
[13:22:55.085]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:22:55.085]  - attr(*, "resolved")= logi FALSE
[13:22:55.085]  - attr(*, "total_size")= num 56
[13:22:55.085]  - attr(*, "already-done")= logi TRUE
[13:22:55.087] - copied ‘ii’ to environment
[13:22:55.087] assign_globals() ... done
[13:22:55.088] plan(): Setting new future strategy stack:
[13:22:55.088] List of future strategies:
[13:22:55.088] 1. sequential:
[13:22:55.088]    - args: function (..., envir = parent.frame())
[13:22:55.088]    - tweaked: FALSE
[13:22:55.088]    - call: NULL
[13:22:55.088] plan(): nbrOfWorkers() = 1
[13:22:55.089] plan(): Setting new future strategy stack:
[13:22:55.089] List of future strategies:
[13:22:55.089] 1. sequential:
[13:22:55.089]    - args: function (..., envir = parent.frame())
[13:22:55.089]    - tweaked: FALSE
[13:22:55.089]    - call: plan(strategy)
[13:22:55.090] plan(): nbrOfWorkers() = 1
[13:22:55.090] SequentialFuture started (and completed)
[13:22:55.090] signalConditions() ...
[13:22:55.090]  - include = ‘immediateCondition’
[13:22:55.090]  - exclude = 
[13:22:55.090]  - resignal = FALSE
[13:22:55.090]  - Number of conditions: 1
[13:22:55.090] signalConditions() ... done
[13:22:55.091] - Launch lazy future ... done
[13:22:55.091] run() for ‘SequentialFuture’ ... done
[13:22:55.091] getGlobalsAndPackages() ...
[13:22:55.091] Searching for globals...
[13:22:55.093] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[13:22:55.093] Searching for globals ... DONE
[13:22:55.093] Resolving globals: FALSE
[13:22:55.093] The total size of the 1 globals is 56 bytes (56 bytes)
[13:22:55.094] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:22:55.094] - globals: [1] ‘ii’
[13:22:55.094] 
[13:22:55.094] getGlobalsAndPackages() ... DONE
[13:22:55.094] run() for ‘Future’ ...
[13:22:55.095] - state: ‘created’
[13:22:55.095] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:22:55.095] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:22:55.095] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:22:55.095]   - Field: ‘label’
[13:22:55.095]   - Field: ‘local’
[13:22:55.095]   - Field: ‘owner’
[13:22:55.095]   - Field: ‘envir’
[13:22:55.096]   - Field: ‘packages’
[13:22:55.096]   - Field: ‘gc’
[13:22:55.096]   - Field: ‘conditions’
[13:22:55.096]   - Field: ‘expr’
[13:22:55.096]   - Field: ‘uuid’
[13:22:55.096]   - Field: ‘seed’
[13:22:55.096]   - Field: ‘version’
[13:22:55.096]   - Field: ‘result’
[13:22:55.096]   - Field: ‘asynchronous’
[13:22:55.096]   - Field: ‘calls’
[13:22:55.097]   - Field: ‘globals’
[13:22:55.097]   - Field: ‘stdout’
[13:22:55.097]   - Field: ‘earlySignal’
[13:22:55.097]   - Field: ‘lazy’
[13:22:55.097]   - Field: ‘state’
[13:22:55.097] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:22:55.097] - Launch lazy future ...
[13:22:55.097] Packages needed by the future expression (n = 0): <none>
[13:22:55.097] Packages needed by future strategies (n = 0): <none>
[13:22:55.098] {
[13:22:55.098]     {
[13:22:55.098]         {
[13:22:55.098]             ...future.startTime <- base::Sys.time()
[13:22:55.098]             {
[13:22:55.098]                 {
[13:22:55.098]                   {
[13:22:55.098]                     base::local({
[13:22:55.098]                       has_future <- base::requireNamespace("future", 
[13:22:55.098]                         quietly = TRUE)
[13:22:55.098]                       if (has_future) {
[13:22:55.098]                         ns <- base::getNamespace("future")
[13:22:55.098]                         version <- ns[[".package"]][["version"]]
[13:22:55.098]                         if (is.null(version)) 
[13:22:55.098]                           version <- utils::packageVersion("future")
[13:22:55.098]                       }
[13:22:55.098]                       else {
[13:22:55.098]                         version <- NULL
[13:22:55.098]                       }
[13:22:55.098]                       if (!has_future || version < "1.8.0") {
[13:22:55.098]                         info <- base::c(r_version = base::gsub("R version ", 
[13:22:55.098]                           "", base::R.version$version.string), 
[13:22:55.098]                           platform = base::sprintf("%s (%s-bit)", 
[13:22:55.098]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:55.098]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:55.098]                             "release", "version")], collapse = " "), 
[13:22:55.098]                           hostname = base::Sys.info()[["nodename"]])
[13:22:55.098]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:22:55.098]                           info)
[13:22:55.098]                         info <- base::paste(info, collapse = "; ")
[13:22:55.098]                         if (!has_future) {
[13:22:55.098]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:55.098]                             info)
[13:22:55.098]                         }
[13:22:55.098]                         else {
[13:22:55.098]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:55.098]                             info, version)
[13:22:55.098]                         }
[13:22:55.098]                         base::stop(msg)
[13:22:55.098]                       }
[13:22:55.098]                     })
[13:22:55.098]                   }
[13:22:55.098]                   options(future.plan = NULL)
[13:22:55.098]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.098]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:55.098]                 }
[13:22:55.098]                 ...future.workdir <- getwd()
[13:22:55.098]             }
[13:22:55.098]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:55.098]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:55.098]         }
[13:22:55.098]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:55.098]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:55.098]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:55.098]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:55.098]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:55.098]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:55.098]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:55.098]             base::names(...future.oldOptions))
[13:22:55.098]     }
[13:22:55.098]     if (FALSE) {
[13:22:55.098]     }
[13:22:55.098]     else {
[13:22:55.098]         if (TRUE) {
[13:22:55.098]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:55.098]                 open = "w")
[13:22:55.098]         }
[13:22:55.098]         else {
[13:22:55.098]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:55.098]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:55.098]         }
[13:22:55.098]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:55.098]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:55.098]             base::sink(type = "output", split = FALSE)
[13:22:55.098]             base::close(...future.stdout)
[13:22:55.098]         }, add = TRUE)
[13:22:55.098]     }
[13:22:55.098]     ...future.frame <- base::sys.nframe()
[13:22:55.098]     ...future.conditions <- base::list()
[13:22:55.098]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:55.098]     if (FALSE) {
[13:22:55.098]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:55.098]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:55.098]     }
[13:22:55.098]     ...future.result <- base::tryCatch({
[13:22:55.098]         base::withCallingHandlers({
[13:22:55.098]             ...future.value <- base::withVisible(base::local({
[13:22:55.098]                 if (ii%%2 == 0) 
[13:22:55.098]                   stop("Woops!")
[13:22:55.098]                 ii
[13:22:55.098]             }))
[13:22:55.098]             future::FutureResult(value = ...future.value$value, 
[13:22:55.098]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.098]                   ...future.rng), globalenv = if (FALSE) 
[13:22:55.098]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:55.098]                     ...future.globalenv.names))
[13:22:55.098]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:55.098]         }, condition = base::local({
[13:22:55.098]             c <- base::c
[13:22:55.098]             inherits <- base::inherits
[13:22:55.098]             invokeRestart <- base::invokeRestart
[13:22:55.098]             length <- base::length
[13:22:55.098]             list <- base::list
[13:22:55.098]             seq.int <- base::seq.int
[13:22:55.098]             signalCondition <- base::signalCondition
[13:22:55.098]             sys.calls <- base::sys.calls
[13:22:55.098]             `[[` <- base::`[[`
[13:22:55.098]             `+` <- base::`+`
[13:22:55.098]             `<<-` <- base::`<<-`
[13:22:55.098]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:55.098]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:55.098]                   3L)]
[13:22:55.098]             }
[13:22:55.098]             function(cond) {
[13:22:55.098]                 is_error <- inherits(cond, "error")
[13:22:55.098]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:55.098]                   NULL)
[13:22:55.098]                 if (is_error) {
[13:22:55.098]                   sessionInformation <- function() {
[13:22:55.098]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:55.098]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:55.098]                       search = base::search(), system = base::Sys.info())
[13:22:55.098]                   }
[13:22:55.098]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.098]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:55.098]                     cond$call), session = sessionInformation(), 
[13:22:55.098]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:55.098]                   signalCondition(cond)
[13:22:55.098]                 }
[13:22:55.098]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:55.098]                 "immediateCondition"))) {
[13:22:55.098]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:55.098]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.098]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:55.098]                   if (TRUE && !signal) {
[13:22:55.098]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.098]                     {
[13:22:55.098]                       inherits <- base::inherits
[13:22:55.098]                       invokeRestart <- base::invokeRestart
[13:22:55.098]                       is.null <- base::is.null
[13:22:55.098]                       muffled <- FALSE
[13:22:55.098]                       if (inherits(cond, "message")) {
[13:22:55.098]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.098]                         if (muffled) 
[13:22:55.098]                           invokeRestart("muffleMessage")
[13:22:55.098]                       }
[13:22:55.098]                       else if (inherits(cond, "warning")) {
[13:22:55.098]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.098]                         if (muffled) 
[13:22:55.098]                           invokeRestart("muffleWarning")
[13:22:55.098]                       }
[13:22:55.098]                       else if (inherits(cond, "condition")) {
[13:22:55.098]                         if (!is.null(pattern)) {
[13:22:55.098]                           computeRestarts <- base::computeRestarts
[13:22:55.098]                           grepl <- base::grepl
[13:22:55.098]                           restarts <- computeRestarts(cond)
[13:22:55.098]                           for (restart in restarts) {
[13:22:55.098]                             name <- restart$name
[13:22:55.098]                             if (is.null(name)) 
[13:22:55.098]                               next
[13:22:55.098]                             if (!grepl(pattern, name)) 
[13:22:55.098]                               next
[13:22:55.098]                             invokeRestart(restart)
[13:22:55.098]                             muffled <- TRUE
[13:22:55.098]                             break
[13:22:55.098]                           }
[13:22:55.098]                         }
[13:22:55.098]                       }
[13:22:55.098]                       invisible(muffled)
[13:22:55.098]                     }
[13:22:55.098]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.098]                   }
[13:22:55.098]                 }
[13:22:55.098]                 else {
[13:22:55.098]                   if (TRUE) {
[13:22:55.098]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.098]                     {
[13:22:55.098]                       inherits <- base::inherits
[13:22:55.098]                       invokeRestart <- base::invokeRestart
[13:22:55.098]                       is.null <- base::is.null
[13:22:55.098]                       muffled <- FALSE
[13:22:55.098]                       if (inherits(cond, "message")) {
[13:22:55.098]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.098]                         if (muffled) 
[13:22:55.098]                           invokeRestart("muffleMessage")
[13:22:55.098]                       }
[13:22:55.098]                       else if (inherits(cond, "warning")) {
[13:22:55.098]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.098]                         if (muffled) 
[13:22:55.098]                           invokeRestart("muffleWarning")
[13:22:55.098]                       }
[13:22:55.098]                       else if (inherits(cond, "condition")) {
[13:22:55.098]                         if (!is.null(pattern)) {
[13:22:55.098]                           computeRestarts <- base::computeRestarts
[13:22:55.098]                           grepl <- base::grepl
[13:22:55.098]                           restarts <- computeRestarts(cond)
[13:22:55.098]                           for (restart in restarts) {
[13:22:55.098]                             name <- restart$name
[13:22:55.098]                             if (is.null(name)) 
[13:22:55.098]                               next
[13:22:55.098]                             if (!grepl(pattern, name)) 
[13:22:55.098]                               next
[13:22:55.098]                             invokeRestart(restart)
[13:22:55.098]                             muffled <- TRUE
[13:22:55.098]                             break
[13:22:55.098]                           }
[13:22:55.098]                         }
[13:22:55.098]                       }
[13:22:55.098]                       invisible(muffled)
[13:22:55.098]                     }
[13:22:55.098]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.098]                   }
[13:22:55.098]                 }
[13:22:55.098]             }
[13:22:55.098]         }))
[13:22:55.098]     }, error = function(ex) {
[13:22:55.098]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:55.098]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.098]                 ...future.rng), started = ...future.startTime, 
[13:22:55.098]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:55.098]             version = "1.8"), class = "FutureResult")
[13:22:55.098]     }, finally = {
[13:22:55.098]         if (!identical(...future.workdir, getwd())) 
[13:22:55.098]             setwd(...future.workdir)
[13:22:55.098]         {
[13:22:55.098]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:55.098]                 ...future.oldOptions$nwarnings <- NULL
[13:22:55.098]             }
[13:22:55.098]             base::options(...future.oldOptions)
[13:22:55.098]             if (.Platform$OS.type == "windows") {
[13:22:55.098]                 old_names <- names(...future.oldEnvVars)
[13:22:55.098]                 envs <- base::Sys.getenv()
[13:22:55.098]                 names <- names(envs)
[13:22:55.098]                 common <- intersect(names, old_names)
[13:22:55.098]                 added <- setdiff(names, old_names)
[13:22:55.098]                 removed <- setdiff(old_names, names)
[13:22:55.098]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:55.098]                   envs[common]]
[13:22:55.098]                 NAMES <- toupper(changed)
[13:22:55.098]                 args <- list()
[13:22:55.098]                 for (kk in seq_along(NAMES)) {
[13:22:55.098]                   name <- changed[[kk]]
[13:22:55.098]                   NAME <- NAMES[[kk]]
[13:22:55.098]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.098]                     next
[13:22:55.098]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.098]                 }
[13:22:55.098]                 NAMES <- toupper(added)
[13:22:55.098]                 for (kk in seq_along(NAMES)) {
[13:22:55.098]                   name <- added[[kk]]
[13:22:55.098]                   NAME <- NAMES[[kk]]
[13:22:55.098]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.098]                     next
[13:22:55.098]                   args[[name]] <- ""
[13:22:55.098]                 }
[13:22:55.098]                 NAMES <- toupper(removed)
[13:22:55.098]                 for (kk in seq_along(NAMES)) {
[13:22:55.098]                   name <- removed[[kk]]
[13:22:55.098]                   NAME <- NAMES[[kk]]
[13:22:55.098]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.098]                     next
[13:22:55.098]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.098]                 }
[13:22:55.098]                 if (length(args) > 0) 
[13:22:55.098]                   base::do.call(base::Sys.setenv, args = args)
[13:22:55.098]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:55.098]             }
[13:22:55.098]             else {
[13:22:55.098]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:55.098]             }
[13:22:55.098]             {
[13:22:55.098]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:55.098]                   0L) {
[13:22:55.098]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:55.098]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:55.098]                   base::options(opts)
[13:22:55.098]                 }
[13:22:55.098]                 {
[13:22:55.098]                   {
[13:22:55.098]                     NULL
[13:22:55.098]                     RNGkind("Mersenne-Twister")
[13:22:55.098]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:22:55.098]                       inherits = FALSE)
[13:22:55.098]                   }
[13:22:55.098]                   options(future.plan = NULL)
[13:22:55.098]                   if (is.na(NA_character_)) 
[13:22:55.098]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.098]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:55.098]                   future::plan(list(function (..., envir = parent.frame()) 
[13:22:55.098]                   {
[13:22:55.098]                     future <- SequentialFuture(..., envir = envir)
[13:22:55.098]                     if (!future$lazy) 
[13:22:55.098]                       future <- run(future)
[13:22:55.098]                     invisible(future)
[13:22:55.098]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:55.098]                 }
[13:22:55.098]             }
[13:22:55.098]         }
[13:22:55.098]     })
[13:22:55.098]     if (TRUE) {
[13:22:55.098]         base::sink(type = "output", split = FALSE)
[13:22:55.098]         if (TRUE) {
[13:22:55.098]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:55.098]         }
[13:22:55.098]         else {
[13:22:55.098]             ...future.result["stdout"] <- base::list(NULL)
[13:22:55.098]         }
[13:22:55.098]         base::close(...future.stdout)
[13:22:55.098]         ...future.stdout <- NULL
[13:22:55.098]     }
[13:22:55.098]     ...future.result$conditions <- ...future.conditions
[13:22:55.098]     ...future.result$finished <- base::Sys.time()
[13:22:55.098]     ...future.result
[13:22:55.098] }
[13:22:55.100] assign_globals() ...
[13:22:55.100] List of 1
[13:22:55.100]  $ ii: int 3
[13:22:55.100]  - attr(*, "where")=List of 1
[13:22:55.100]   ..$ ii:<environment: R_EmptyEnv> 
[13:22:55.100]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:22:55.100]  - attr(*, "resolved")= logi FALSE
[13:22:55.100]  - attr(*, "total_size")= num 56
[13:22:55.100]  - attr(*, "already-done")= logi TRUE
[13:22:55.104] - copied ‘ii’ to environment
[13:22:55.104] assign_globals() ... done
[13:22:55.105] plan(): Setting new future strategy stack:
[13:22:55.105] List of future strategies:
[13:22:55.105] 1. sequential:
[13:22:55.105]    - args: function (..., envir = parent.frame())
[13:22:55.105]    - tweaked: FALSE
[13:22:55.105]    - call: NULL
[13:22:55.105] plan(): nbrOfWorkers() = 1
[13:22:55.106] plan(): Setting new future strategy stack:
[13:22:55.106] List of future strategies:
[13:22:55.106] 1. sequential:
[13:22:55.106]    - args: function (..., envir = parent.frame())
[13:22:55.106]    - tweaked: FALSE
[13:22:55.106]    - call: plan(strategy)
[13:22:55.106] plan(): nbrOfWorkers() = 1
[13:22:55.106] SequentialFuture started (and completed)
[13:22:55.107] - Launch lazy future ... done
[13:22:55.107] run() for ‘SequentialFuture’ ... done
[13:22:55.107] signalConditions() ...
[13:22:55.107]  - include = ‘immediateCondition’
[13:22:55.107]  - exclude = 
[13:22:55.107]  - resignal = FALSE
[13:22:55.107]  - Number of conditions: 1
[13:22:55.108] signalConditions() ... done
[13:22:55.108] Future state: ‘finished’
[13:22:55.108] signalConditions() ...
[13:22:55.108]  - include = ‘condition’
[13:22:55.108]  - exclude = ‘immediateCondition’
[13:22:55.108]  - resignal = TRUE
[13:22:55.108]  - Number of conditions: 1
[13:22:55.108]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:22:55.108] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[13:22:55.110] signalConditions() ...
[13:22:55.110]  - include = ‘immediateCondition’
[13:22:55.110]  - exclude = 
[13:22:55.110]  - resignal = FALSE
[13:22:55.110]  - Number of conditions: 1
[13:22:55.110] signalConditions() ... done
[13:22:55.110] Future state: ‘finished’
[13:22:55.110] signalConditions() ...
[13:22:55.110]  - include = ‘condition’
[13:22:55.110]  - exclude = ‘immediateCondition’
[13:22:55.111]  - resignal = TRUE
[13:22:55.111]  - Number of conditions: 1
[13:22:55.111]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:22:55.111] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[13:22:55.111] signalConditions() ...
[13:22:55.111]  - include = ‘immediateCondition’
[13:22:55.111]  - exclude = 
[13:22:55.111]  - resignal = FALSE
[13:22:55.112]  - Number of conditions: 1
[13:22:55.112] signalConditions() ... done
[13:22:55.112] Future state: ‘finished’
[13:22:55.112] signalConditions() ...
[13:22:55.112]  - include = ‘condition’
[13:22:55.112]  - exclude = ‘immediateCondition’
[13:22:55.112]  - resignal = TRUE
[13:22:55.112]  - Number of conditions: 1
[13:22:55.112]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:22:55.112] signalConditions() ... done
** Future evaluation with a poor-man's "progress bar"
[13:22:55.113] getGlobalsAndPackages() ...
[13:22:55.113] Searching for globals...
[13:22:55.115] - globals found: [4] ‘{’, ‘cat’, ‘for’, ‘:’
[13:22:55.115] Searching for globals ... DONE
[13:22:55.115] Resolving globals: FALSE
[13:22:55.115] 
[13:22:55.116] 
[13:22:55.116] getGlobalsAndPackages() ... DONE
[13:22:55.116] run() for ‘Future’ ...
[13:22:55.116] - state: ‘created’
[13:22:55.116] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:22:55.116] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:22:55.117] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:22:55.117]   - Field: ‘label’
[13:22:55.117]   - Field: ‘local’
[13:22:55.117]   - Field: ‘owner’
[13:22:55.117]   - Field: ‘envir’
[13:22:55.117]   - Field: ‘packages’
[13:22:55.117]   - Field: ‘gc’
[13:22:55.117]   - Field: ‘conditions’
[13:22:55.117]   - Field: ‘expr’
[13:22:55.117]   - Field: ‘uuid’
[13:22:55.117]   - Field: ‘seed’
[13:22:55.118]   - Field: ‘version’
[13:22:55.118]   - Field: ‘result’
[13:22:55.118]   - Field: ‘asynchronous’
[13:22:55.118]   - Field: ‘calls’
[13:22:55.118]   - Field: ‘globals’
[13:22:55.118]   - Field: ‘stdout’
[13:22:55.118]   - Field: ‘earlySignal’
[13:22:55.118]   - Field: ‘lazy’
[13:22:55.118]   - Field: ‘state’
[13:22:55.118] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:22:55.118] - Launch lazy future ...
[13:22:55.119] Packages needed by the future expression (n = 0): <none>
[13:22:55.119] Packages needed by future strategies (n = 0): <none>
[13:22:55.119] {
[13:22:55.119]     {
[13:22:55.119]         {
[13:22:55.119]             ...future.startTime <- base::Sys.time()
[13:22:55.119]             {
[13:22:55.119]                 {
[13:22:55.119]                   {
[13:22:55.119]                     base::local({
[13:22:55.119]                       has_future <- base::requireNamespace("future", 
[13:22:55.119]                         quietly = TRUE)
[13:22:55.119]                       if (has_future) {
[13:22:55.119]                         ns <- base::getNamespace("future")
[13:22:55.119]                         version <- ns[[".package"]][["version"]]
[13:22:55.119]                         if (is.null(version)) 
[13:22:55.119]                           version <- utils::packageVersion("future")
[13:22:55.119]                       }
[13:22:55.119]                       else {
[13:22:55.119]                         version <- NULL
[13:22:55.119]                       }
[13:22:55.119]                       if (!has_future || version < "1.8.0") {
[13:22:55.119]                         info <- base::c(r_version = base::gsub("R version ", 
[13:22:55.119]                           "", base::R.version$version.string), 
[13:22:55.119]                           platform = base::sprintf("%s (%s-bit)", 
[13:22:55.119]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:55.119]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:55.119]                             "release", "version")], collapse = " "), 
[13:22:55.119]                           hostname = base::Sys.info()[["nodename"]])
[13:22:55.119]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:22:55.119]                           info)
[13:22:55.119]                         info <- base::paste(info, collapse = "; ")
[13:22:55.119]                         if (!has_future) {
[13:22:55.119]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:55.119]                             info)
[13:22:55.119]                         }
[13:22:55.119]                         else {
[13:22:55.119]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:55.119]                             info, version)
[13:22:55.119]                         }
[13:22:55.119]                         base::stop(msg)
[13:22:55.119]                       }
[13:22:55.119]                     })
[13:22:55.119]                   }
[13:22:55.119]                   options(future.plan = NULL)
[13:22:55.119]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.119]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:55.119]                 }
[13:22:55.119]                 ...future.workdir <- getwd()
[13:22:55.119]             }
[13:22:55.119]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:55.119]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:55.119]         }
[13:22:55.119]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:55.119]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:55.119]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:55.119]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:55.119]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:55.119]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:55.119]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:55.119]             base::names(...future.oldOptions))
[13:22:55.119]     }
[13:22:55.119]     if (FALSE) {
[13:22:55.119]     }
[13:22:55.119]     else {
[13:22:55.119]         if (TRUE) {
[13:22:55.119]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:55.119]                 open = "w")
[13:22:55.119]         }
[13:22:55.119]         else {
[13:22:55.119]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:55.119]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:55.119]         }
[13:22:55.119]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:55.119]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:55.119]             base::sink(type = "output", split = FALSE)
[13:22:55.119]             base::close(...future.stdout)
[13:22:55.119]         }, add = TRUE)
[13:22:55.119]     }
[13:22:55.119]     ...future.frame <- base::sys.nframe()
[13:22:55.119]     ...future.conditions <- base::list()
[13:22:55.119]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:55.119]     if (FALSE) {
[13:22:55.119]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:55.119]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:55.119]     }
[13:22:55.119]     ...future.result <- base::tryCatch({
[13:22:55.119]         base::withCallingHandlers({
[13:22:55.119]             ...future.value <- base::withVisible(base::local({
[13:22:55.119]                 cat("Processing: ")
[13:22:55.119]                 for (ii in 1:10) {
[13:22:55.119]                   cat(".")
[13:22:55.119]                 }
[13:22:55.119]                 cat(" [100%]\n")
[13:22:55.119]                 4
[13:22:55.119]             }))
[13:22:55.119]             future::FutureResult(value = ...future.value$value, 
[13:22:55.119]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.119]                   ...future.rng), globalenv = if (FALSE) 
[13:22:55.119]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:55.119]                     ...future.globalenv.names))
[13:22:55.119]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:55.119]         }, condition = base::local({
[13:22:55.119]             c <- base::c
[13:22:55.119]             inherits <- base::inherits
[13:22:55.119]             invokeRestart <- base::invokeRestart
[13:22:55.119]             length <- base::length
[13:22:55.119]             list <- base::list
[13:22:55.119]             seq.int <- base::seq.int
[13:22:55.119]             signalCondition <- base::signalCondition
[13:22:55.119]             sys.calls <- base::sys.calls
[13:22:55.119]             `[[` <- base::`[[`
[13:22:55.119]             `+` <- base::`+`
[13:22:55.119]             `<<-` <- base::`<<-`
[13:22:55.119]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:55.119]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:55.119]                   3L)]
[13:22:55.119]             }
[13:22:55.119]             function(cond) {
[13:22:55.119]                 is_error <- inherits(cond, "error")
[13:22:55.119]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:55.119]                   NULL)
[13:22:55.119]                 if (is_error) {
[13:22:55.119]                   sessionInformation <- function() {
[13:22:55.119]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:55.119]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:55.119]                       search = base::search(), system = base::Sys.info())
[13:22:55.119]                   }
[13:22:55.119]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.119]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:55.119]                     cond$call), session = sessionInformation(), 
[13:22:55.119]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:55.119]                   signalCondition(cond)
[13:22:55.119]                 }
[13:22:55.119]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:55.119]                 "immediateCondition"))) {
[13:22:55.119]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:55.119]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.119]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:55.119]                   if (TRUE && !signal) {
[13:22:55.119]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.119]                     {
[13:22:55.119]                       inherits <- base::inherits
[13:22:55.119]                       invokeRestart <- base::invokeRestart
[13:22:55.119]                       is.null <- base::is.null
[13:22:55.119]                       muffled <- FALSE
[13:22:55.119]                       if (inherits(cond, "message")) {
[13:22:55.119]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.119]                         if (muffled) 
[13:22:55.119]                           invokeRestart("muffleMessage")
[13:22:55.119]                       }
[13:22:55.119]                       else if (inherits(cond, "warning")) {
[13:22:55.119]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.119]                         if (muffled) 
[13:22:55.119]                           invokeRestart("muffleWarning")
[13:22:55.119]                       }
[13:22:55.119]                       else if (inherits(cond, "condition")) {
[13:22:55.119]                         if (!is.null(pattern)) {
[13:22:55.119]                           computeRestarts <- base::computeRestarts
[13:22:55.119]                           grepl <- base::grepl
[13:22:55.119]                           restarts <- computeRestarts(cond)
[13:22:55.119]                           for (restart in restarts) {
[13:22:55.119]                             name <- restart$name
[13:22:55.119]                             if (is.null(name)) 
[13:22:55.119]                               next
[13:22:55.119]                             if (!grepl(pattern, name)) 
[13:22:55.119]                               next
[13:22:55.119]                             invokeRestart(restart)
[13:22:55.119]                             muffled <- TRUE
[13:22:55.119]                             break
[13:22:55.119]                           }
[13:22:55.119]                         }
[13:22:55.119]                       }
[13:22:55.119]                       invisible(muffled)
[13:22:55.119]                     }
[13:22:55.119]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.119]                   }
[13:22:55.119]                 }
[13:22:55.119]                 else {
[13:22:55.119]                   if (TRUE) {
[13:22:55.119]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.119]                     {
[13:22:55.119]                       inherits <- base::inherits
[13:22:55.119]                       invokeRestart <- base::invokeRestart
[13:22:55.119]                       is.null <- base::is.null
[13:22:55.119]                       muffled <- FALSE
[13:22:55.119]                       if (inherits(cond, "message")) {
[13:22:55.119]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.119]                         if (muffled) 
[13:22:55.119]                           invokeRestart("muffleMessage")
[13:22:55.119]                       }
[13:22:55.119]                       else if (inherits(cond, "warning")) {
[13:22:55.119]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.119]                         if (muffled) 
[13:22:55.119]                           invokeRestart("muffleWarning")
[13:22:55.119]                       }
[13:22:55.119]                       else if (inherits(cond, "condition")) {
[13:22:55.119]                         if (!is.null(pattern)) {
[13:22:55.119]                           computeRestarts <- base::computeRestarts
[13:22:55.119]                           grepl <- base::grepl
[13:22:55.119]                           restarts <- computeRestarts(cond)
[13:22:55.119]                           for (restart in restarts) {
[13:22:55.119]                             name <- restart$name
[13:22:55.119]                             if (is.null(name)) 
[13:22:55.119]                               next
[13:22:55.119]                             if (!grepl(pattern, name)) 
[13:22:55.119]                               next
[13:22:55.119]                             invokeRestart(restart)
[13:22:55.119]                             muffled <- TRUE
[13:22:55.119]                             break
[13:22:55.119]                           }
[13:22:55.119]                         }
[13:22:55.119]                       }
[13:22:55.119]                       invisible(muffled)
[13:22:55.119]                     }
[13:22:55.119]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.119]                   }
[13:22:55.119]                 }
[13:22:55.119]             }
[13:22:55.119]         }))
[13:22:55.119]     }, error = function(ex) {
[13:22:55.119]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:55.119]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.119]                 ...future.rng), started = ...future.startTime, 
[13:22:55.119]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:55.119]             version = "1.8"), class = "FutureResult")
[13:22:55.119]     }, finally = {
[13:22:55.119]         if (!identical(...future.workdir, getwd())) 
[13:22:55.119]             setwd(...future.workdir)
[13:22:55.119]         {
[13:22:55.119]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:55.119]                 ...future.oldOptions$nwarnings <- NULL
[13:22:55.119]             }
[13:22:55.119]             base::options(...future.oldOptions)
[13:22:55.119]             if (.Platform$OS.type == "windows") {
[13:22:55.119]                 old_names <- names(...future.oldEnvVars)
[13:22:55.119]                 envs <- base::Sys.getenv()
[13:22:55.119]                 names <- names(envs)
[13:22:55.119]                 common <- intersect(names, old_names)
[13:22:55.119]                 added <- setdiff(names, old_names)
[13:22:55.119]                 removed <- setdiff(old_names, names)
[13:22:55.119]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:55.119]                   envs[common]]
[13:22:55.119]                 NAMES <- toupper(changed)
[13:22:55.119]                 args <- list()
[13:22:55.119]                 for (kk in seq_along(NAMES)) {
[13:22:55.119]                   name <- changed[[kk]]
[13:22:55.119]                   NAME <- NAMES[[kk]]
[13:22:55.119]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.119]                     next
[13:22:55.119]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.119]                 }
[13:22:55.119]                 NAMES <- toupper(added)
[13:22:55.119]                 for (kk in seq_along(NAMES)) {
[13:22:55.119]                   name <- added[[kk]]
[13:22:55.119]                   NAME <- NAMES[[kk]]
[13:22:55.119]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.119]                     next
[13:22:55.119]                   args[[name]] <- ""
[13:22:55.119]                 }
[13:22:55.119]                 NAMES <- toupper(removed)
[13:22:55.119]                 for (kk in seq_along(NAMES)) {
[13:22:55.119]                   name <- removed[[kk]]
[13:22:55.119]                   NAME <- NAMES[[kk]]
[13:22:55.119]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.119]                     next
[13:22:55.119]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.119]                 }
[13:22:55.119]                 if (length(args) > 0) 
[13:22:55.119]                   base::do.call(base::Sys.setenv, args = args)
[13:22:55.119]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:55.119]             }
[13:22:55.119]             else {
[13:22:55.119]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:55.119]             }
[13:22:55.119]             {
[13:22:55.119]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:55.119]                   0L) {
[13:22:55.119]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:55.119]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:55.119]                   base::options(opts)
[13:22:55.119]                 }
[13:22:55.119]                 {
[13:22:55.119]                   {
[13:22:55.119]                     NULL
[13:22:55.119]                     RNGkind("Mersenne-Twister")
[13:22:55.119]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:22:55.119]                       inherits = FALSE)
[13:22:55.119]                   }
[13:22:55.119]                   options(future.plan = NULL)
[13:22:55.119]                   if (is.na(NA_character_)) 
[13:22:55.119]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.119]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:55.119]                   future::plan(list(function (..., envir = parent.frame()) 
[13:22:55.119]                   {
[13:22:55.119]                     future <- SequentialFuture(..., envir = envir)
[13:22:55.119]                     if (!future$lazy) 
[13:22:55.119]                       future <- run(future)
[13:22:55.119]                     invisible(future)
[13:22:55.119]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:55.119]                 }
[13:22:55.119]             }
[13:22:55.119]         }
[13:22:55.119]     })
[13:22:55.119]     if (TRUE) {
[13:22:55.119]         base::sink(type = "output", split = FALSE)
[13:22:55.119]         if (TRUE) {
[13:22:55.119]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:55.119]         }
[13:22:55.119]         else {
[13:22:55.119]             ...future.result["stdout"] <- base::list(NULL)
[13:22:55.119]         }
[13:22:55.119]         base::close(...future.stdout)
[13:22:55.119]         ...future.stdout <- NULL
[13:22:55.119]     }
[13:22:55.119]     ...future.result$conditions <- ...future.conditions
[13:22:55.119]     ...future.result$finished <- base::Sys.time()
[13:22:55.119]     ...future.result
[13:22:55.119] }
[13:22:55.121] plan(): Setting new future strategy stack:
[13:22:55.121] List of future strategies:
[13:22:55.121] 1. sequential:
[13:22:55.121]    - args: function (..., envir = parent.frame())
[13:22:55.121]    - tweaked: FALSE
[13:22:55.121]    - call: NULL
[13:22:55.122] plan(): nbrOfWorkers() = 1
[13:22:55.122] plan(): Setting new future strategy stack:
[13:22:55.122] List of future strategies:
[13:22:55.122] 1. sequential:
[13:22:55.122]    - args: function (..., envir = parent.frame())
[13:22:55.122]    - tweaked: FALSE
[13:22:55.122]    - call: plan(strategy)
[13:22:55.123] plan(): nbrOfWorkers() = 1
[13:22:55.123] SequentialFuture started (and completed)
[13:22:55.123] - Launch lazy future ... done
[13:22:55.123] run() for ‘SequentialFuture’ ... done
** Collecting results
v1 = 1
v2 = 2
Warning in sprintf(...) : restarting interrupted promise evaluation
[13:22:55.125] signalConditions() ...
[13:22:55.125]  - include = ‘immediateCondition’
[13:22:55.125]  - exclude = 
[13:22:55.125]  - resignal = FALSE
[13:22:55.125]  - Number of conditions: 1
[13:22:55.125] signalConditions() ... done
[13:22:55.125] Future state: ‘finished’
[13:22:55.125] signalConditions() ...
[13:22:55.125]  - include = ‘condition’
[13:22:55.126]  - exclude = ‘immediateCondition’
[13:22:55.126]  - resignal = TRUE
[13:22:55.126]  - Number of conditions: 1
[13:22:55.126]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:22:55.126] signalConditions() ... done
v3: <simpleError> (as expect)
Processing: .......... [100%]
v4 = 4
** Left-to-right and right-to-left future assignments
[13:22:55.126] getGlobalsAndPackages() ...
[13:22:55.126] Searching for globals...
[13:22:55.127] 
[13:22:55.127] Searching for globals ... DONE
[13:22:55.127] - globals: [0] <none>
[13:22:55.127] getGlobalsAndPackages() ... DONE
[13:22:55.127] run() for ‘Future’ ...
[13:22:55.128] - state: ‘created’
[13:22:55.128] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:22:55.128] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:22:55.128] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:22:55.128]   - Field: ‘label’
[13:22:55.128]   - Field: ‘local’
[13:22:55.128]   - Field: ‘owner’
[13:22:55.129]   - Field: ‘envir’
[13:22:55.129]   - Field: ‘packages’
[13:22:55.129]   - Field: ‘gc’
[13:22:55.131]   - Field: ‘conditions’
[13:22:55.131]   - Field: ‘expr’
[13:22:55.131]   - Field: ‘uuid’
[13:22:55.131]   - Field: ‘seed’
[13:22:55.131]   - Field: ‘version’
[13:22:55.131]   - Field: ‘result’
[13:22:55.131]   - Field: ‘asynchronous’
[13:22:55.131]   - Field: ‘calls’
[13:22:55.131]   - Field: ‘globals’
[13:22:55.132]   - Field: ‘stdout’
[13:22:55.132]   - Field: ‘earlySignal’
[13:22:55.132]   - Field: ‘lazy’
[13:22:55.132]   - Field: ‘state’
[13:22:55.132] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:22:55.132] - Launch lazy future ...
[13:22:55.132] Packages needed by the future expression (n = 0): <none>
[13:22:55.132] Packages needed by future strategies (n = 0): <none>
[13:22:55.133] {
[13:22:55.133]     {
[13:22:55.133]         {
[13:22:55.133]             ...future.startTime <- base::Sys.time()
[13:22:55.133]             {
[13:22:55.133]                 {
[13:22:55.133]                   {
[13:22:55.133]                     base::local({
[13:22:55.133]                       has_future <- base::requireNamespace("future", 
[13:22:55.133]                         quietly = TRUE)
[13:22:55.133]                       if (has_future) {
[13:22:55.133]                         ns <- base::getNamespace("future")
[13:22:55.133]                         version <- ns[[".package"]][["version"]]
[13:22:55.133]                         if (is.null(version)) 
[13:22:55.133]                           version <- utils::packageVersion("future")
[13:22:55.133]                       }
[13:22:55.133]                       else {
[13:22:55.133]                         version <- NULL
[13:22:55.133]                       }
[13:22:55.133]                       if (!has_future || version < "1.8.0") {
[13:22:55.133]                         info <- base::c(r_version = base::gsub("R version ", 
[13:22:55.133]                           "", base::R.version$version.string), 
[13:22:55.133]                           platform = base::sprintf("%s (%s-bit)", 
[13:22:55.133]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:55.133]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:55.133]                             "release", "version")], collapse = " "), 
[13:22:55.133]                           hostname = base::Sys.info()[["nodename"]])
[13:22:55.133]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:22:55.133]                           info)
[13:22:55.133]                         info <- base::paste(info, collapse = "; ")
[13:22:55.133]                         if (!has_future) {
[13:22:55.133]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:55.133]                             info)
[13:22:55.133]                         }
[13:22:55.133]                         else {
[13:22:55.133]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:55.133]                             info, version)
[13:22:55.133]                         }
[13:22:55.133]                         base::stop(msg)
[13:22:55.133]                       }
[13:22:55.133]                     })
[13:22:55.133]                   }
[13:22:55.133]                   options(future.plan = NULL)
[13:22:55.133]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.133]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:55.133]                 }
[13:22:55.133]                 ...future.workdir <- getwd()
[13:22:55.133]             }
[13:22:55.133]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:55.133]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:55.133]         }
[13:22:55.133]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:55.133]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:55.133]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:55.133]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:55.133]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:55.133]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:55.133]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:55.133]             base::names(...future.oldOptions))
[13:22:55.133]     }
[13:22:55.133]     if (FALSE) {
[13:22:55.133]     }
[13:22:55.133]     else {
[13:22:55.133]         if (TRUE) {
[13:22:55.133]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:55.133]                 open = "w")
[13:22:55.133]         }
[13:22:55.133]         else {
[13:22:55.133]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:55.133]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:55.133]         }
[13:22:55.133]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:55.133]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:55.133]             base::sink(type = "output", split = FALSE)
[13:22:55.133]             base::close(...future.stdout)
[13:22:55.133]         }, add = TRUE)
[13:22:55.133]     }
[13:22:55.133]     ...future.frame <- base::sys.nframe()
[13:22:55.133]     ...future.conditions <- base::list()
[13:22:55.133]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:55.133]     if (FALSE) {
[13:22:55.133]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:55.133]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:55.133]     }
[13:22:55.133]     ...future.result <- base::tryCatch({
[13:22:55.133]         base::withCallingHandlers({
[13:22:55.133]             ...future.value <- base::withVisible(base::local(1))
[13:22:55.133]             future::FutureResult(value = ...future.value$value, 
[13:22:55.133]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.133]                   ...future.rng), globalenv = if (FALSE) 
[13:22:55.133]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:55.133]                     ...future.globalenv.names))
[13:22:55.133]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:55.133]         }, condition = base::local({
[13:22:55.133]             c <- base::c
[13:22:55.133]             inherits <- base::inherits
[13:22:55.133]             invokeRestart <- base::invokeRestart
[13:22:55.133]             length <- base::length
[13:22:55.133]             list <- base::list
[13:22:55.133]             seq.int <- base::seq.int
[13:22:55.133]             signalCondition <- base::signalCondition
[13:22:55.133]             sys.calls <- base::sys.calls
[13:22:55.133]             `[[` <- base::`[[`
[13:22:55.133]             `+` <- base::`+`
[13:22:55.133]             `<<-` <- base::`<<-`
[13:22:55.133]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:55.133]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:55.133]                   3L)]
[13:22:55.133]             }
[13:22:55.133]             function(cond) {
[13:22:55.133]                 is_error <- inherits(cond, "error")
[13:22:55.133]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:55.133]                   NULL)
[13:22:55.133]                 if (is_error) {
[13:22:55.133]                   sessionInformation <- function() {
[13:22:55.133]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:55.133]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:55.133]                       search = base::search(), system = base::Sys.info())
[13:22:55.133]                   }
[13:22:55.133]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.133]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:55.133]                     cond$call), session = sessionInformation(), 
[13:22:55.133]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:55.133]                   signalCondition(cond)
[13:22:55.133]                 }
[13:22:55.133]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:55.133]                 "immediateCondition"))) {
[13:22:55.133]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:55.133]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.133]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:55.133]                   if (TRUE && !signal) {
[13:22:55.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.133]                     {
[13:22:55.133]                       inherits <- base::inherits
[13:22:55.133]                       invokeRestart <- base::invokeRestart
[13:22:55.133]                       is.null <- base::is.null
[13:22:55.133]                       muffled <- FALSE
[13:22:55.133]                       if (inherits(cond, "message")) {
[13:22:55.133]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.133]                         if (muffled) 
[13:22:55.133]                           invokeRestart("muffleMessage")
[13:22:55.133]                       }
[13:22:55.133]                       else if (inherits(cond, "warning")) {
[13:22:55.133]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.133]                         if (muffled) 
[13:22:55.133]                           invokeRestart("muffleWarning")
[13:22:55.133]                       }
[13:22:55.133]                       else if (inherits(cond, "condition")) {
[13:22:55.133]                         if (!is.null(pattern)) {
[13:22:55.133]                           computeRestarts <- base::computeRestarts
[13:22:55.133]                           grepl <- base::grepl
[13:22:55.133]                           restarts <- computeRestarts(cond)
[13:22:55.133]                           for (restart in restarts) {
[13:22:55.133]                             name <- restart$name
[13:22:55.133]                             if (is.null(name)) 
[13:22:55.133]                               next
[13:22:55.133]                             if (!grepl(pattern, name)) 
[13:22:55.133]                               next
[13:22:55.133]                             invokeRestart(restart)
[13:22:55.133]                             muffled <- TRUE
[13:22:55.133]                             break
[13:22:55.133]                           }
[13:22:55.133]                         }
[13:22:55.133]                       }
[13:22:55.133]                       invisible(muffled)
[13:22:55.133]                     }
[13:22:55.133]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.133]                   }
[13:22:55.133]                 }
[13:22:55.133]                 else {
[13:22:55.133]                   if (TRUE) {
[13:22:55.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.133]                     {
[13:22:55.133]                       inherits <- base::inherits
[13:22:55.133]                       invokeRestart <- base::invokeRestart
[13:22:55.133]                       is.null <- base::is.null
[13:22:55.133]                       muffled <- FALSE
[13:22:55.133]                       if (inherits(cond, "message")) {
[13:22:55.133]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.133]                         if (muffled) 
[13:22:55.133]                           invokeRestart("muffleMessage")
[13:22:55.133]                       }
[13:22:55.133]                       else if (inherits(cond, "warning")) {
[13:22:55.133]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.133]                         if (muffled) 
[13:22:55.133]                           invokeRestart("muffleWarning")
[13:22:55.133]                       }
[13:22:55.133]                       else if (inherits(cond, "condition")) {
[13:22:55.133]                         if (!is.null(pattern)) {
[13:22:55.133]                           computeRestarts <- base::computeRestarts
[13:22:55.133]                           grepl <- base::grepl
[13:22:55.133]                           restarts <- computeRestarts(cond)
[13:22:55.133]                           for (restart in restarts) {
[13:22:55.133]                             name <- restart$name
[13:22:55.133]                             if (is.null(name)) 
[13:22:55.133]                               next
[13:22:55.133]                             if (!grepl(pattern, name)) 
[13:22:55.133]                               next
[13:22:55.133]                             invokeRestart(restart)
[13:22:55.133]                             muffled <- TRUE
[13:22:55.133]                             break
[13:22:55.133]                           }
[13:22:55.133]                         }
[13:22:55.133]                       }
[13:22:55.133]                       invisible(muffled)
[13:22:55.133]                     }
[13:22:55.133]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.133]                   }
[13:22:55.133]                 }
[13:22:55.133]             }
[13:22:55.133]         }))
[13:22:55.133]     }, error = function(ex) {
[13:22:55.133]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:55.133]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.133]                 ...future.rng), started = ...future.startTime, 
[13:22:55.133]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:55.133]             version = "1.8"), class = "FutureResult")
[13:22:55.133]     }, finally = {
[13:22:55.133]         if (!identical(...future.workdir, getwd())) 
[13:22:55.133]             setwd(...future.workdir)
[13:22:55.133]         {
[13:22:55.133]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:55.133]                 ...future.oldOptions$nwarnings <- NULL
[13:22:55.133]             }
[13:22:55.133]             base::options(...future.oldOptions)
[13:22:55.133]             if (.Platform$OS.type == "windows") {
[13:22:55.133]                 old_names <- names(...future.oldEnvVars)
[13:22:55.133]                 envs <- base::Sys.getenv()
[13:22:55.133]                 names <- names(envs)
[13:22:55.133]                 common <- intersect(names, old_names)
[13:22:55.133]                 added <- setdiff(names, old_names)
[13:22:55.133]                 removed <- setdiff(old_names, names)
[13:22:55.133]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:55.133]                   envs[common]]
[13:22:55.133]                 NAMES <- toupper(changed)
[13:22:55.133]                 args <- list()
[13:22:55.133]                 for (kk in seq_along(NAMES)) {
[13:22:55.133]                   name <- changed[[kk]]
[13:22:55.133]                   NAME <- NAMES[[kk]]
[13:22:55.133]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.133]                     next
[13:22:55.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.133]                 }
[13:22:55.133]                 NAMES <- toupper(added)
[13:22:55.133]                 for (kk in seq_along(NAMES)) {
[13:22:55.133]                   name <- added[[kk]]
[13:22:55.133]                   NAME <- NAMES[[kk]]
[13:22:55.133]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.133]                     next
[13:22:55.133]                   args[[name]] <- ""
[13:22:55.133]                 }
[13:22:55.133]                 NAMES <- toupper(removed)
[13:22:55.133]                 for (kk in seq_along(NAMES)) {
[13:22:55.133]                   name <- removed[[kk]]
[13:22:55.133]                   NAME <- NAMES[[kk]]
[13:22:55.133]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.133]                     next
[13:22:55.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.133]                 }
[13:22:55.133]                 if (length(args) > 0) 
[13:22:55.133]                   base::do.call(base::Sys.setenv, args = args)
[13:22:55.133]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:55.133]             }
[13:22:55.133]             else {
[13:22:55.133]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:55.133]             }
[13:22:55.133]             {
[13:22:55.133]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:55.133]                   0L) {
[13:22:55.133]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:55.133]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:55.133]                   base::options(opts)
[13:22:55.133]                 }
[13:22:55.133]                 {
[13:22:55.133]                   {
[13:22:55.133]                     NULL
[13:22:55.133]                     RNGkind("Mersenne-Twister")
[13:22:55.133]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:22:55.133]                       inherits = FALSE)
[13:22:55.133]                   }
[13:22:55.133]                   options(future.plan = NULL)
[13:22:55.133]                   if (is.na(NA_character_)) 
[13:22:55.133]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.133]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:55.133]                   future::plan(list(function (..., envir = parent.frame()) 
[13:22:55.133]                   {
[13:22:55.133]                     future <- SequentialFuture(..., envir = envir)
[13:22:55.133]                     if (!future$lazy) 
[13:22:55.133]                       future <- run(future)
[13:22:55.133]                     invisible(future)
[13:22:55.133]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:55.133]                 }
[13:22:55.133]             }
[13:22:55.133]         }
[13:22:55.133]     })
[13:22:55.133]     if (TRUE) {
[13:22:55.133]         base::sink(type = "output", split = FALSE)
[13:22:55.133]         if (TRUE) {
[13:22:55.133]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:55.133]         }
[13:22:55.133]         else {
[13:22:55.133]             ...future.result["stdout"] <- base::list(NULL)
[13:22:55.133]         }
[13:22:55.133]         base::close(...future.stdout)
[13:22:55.133]         ...future.stdout <- NULL
[13:22:55.133]     }
[13:22:55.133]     ...future.result$conditions <- ...future.conditions
[13:22:55.133]     ...future.result$finished <- base::Sys.time()
[13:22:55.133]     ...future.result
[13:22:55.133] }
[13:22:55.135] plan(): Setting new future strategy stack:
[13:22:55.135] List of future strategies:
[13:22:55.135] 1. sequential:
[13:22:55.135]    - args: function (..., envir = parent.frame())
[13:22:55.135]    - tweaked: FALSE
[13:22:55.135]    - call: NULL
[13:22:55.135] plan(): nbrOfWorkers() = 1
[13:22:55.136] plan(): Setting new future strategy stack:
[13:22:55.136] List of future strategies:
[13:22:55.136] 1. sequential:
[13:22:55.136]    - args: function (..., envir = parent.frame())
[13:22:55.136]    - tweaked: FALSE
[13:22:55.136]    - call: plan(strategy)
[13:22:55.136] plan(): nbrOfWorkers() = 1
[13:22:55.137] SequentialFuture started (and completed)
[13:22:55.137] - Launch lazy future ... done
[13:22:55.137] run() for ‘SequentialFuture’ ... done
c = 1
[13:22:55.137] getGlobalsAndPackages() ...
[13:22:55.137] Searching for globals...
[13:22:55.138] 
[13:22:55.138] Searching for globals ... DONE
[13:22:55.138] - globals: [0] <none>
[13:22:55.138] getGlobalsAndPackages() ... DONE
[13:22:55.138] run() for ‘Future’ ...
[13:22:55.138] - state: ‘created’
[13:22:55.138] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:22:55.139] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:22:55.139] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:22:55.139]   - Field: ‘label’
[13:22:55.139]   - Field: ‘local’
[13:22:55.139]   - Field: ‘owner’
[13:22:55.139]   - Field: ‘envir’
[13:22:55.139]   - Field: ‘packages’
[13:22:55.139]   - Field: ‘gc’
[13:22:55.140]   - Field: ‘conditions’
[13:22:55.140]   - Field: ‘expr’
[13:22:55.140]   - Field: ‘uuid’
[13:22:55.140]   - Field: ‘seed’
[13:22:55.140]   - Field: ‘version’
[13:22:55.140]   - Field: ‘result’
[13:22:55.140]   - Field: ‘asynchronous’
[13:22:55.140]   - Field: ‘calls’
[13:22:55.140]   - Field: ‘globals’
[13:22:55.140]   - Field: ‘stdout’
[13:22:55.140]   - Field: ‘earlySignal’
[13:22:55.141]   - Field: ‘lazy’
[13:22:55.141]   - Field: ‘state’
[13:22:55.141] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:22:55.141] - Launch lazy future ...
[13:22:55.141] Packages needed by the future expression (n = 0): <none>
[13:22:55.141] Packages needed by future strategies (n = 0): <none>
[13:22:55.142] {
[13:22:55.142]     {
[13:22:55.142]         {
[13:22:55.142]             ...future.startTime <- base::Sys.time()
[13:22:55.142]             {
[13:22:55.142]                 {
[13:22:55.142]                   {
[13:22:55.142]                     base::local({
[13:22:55.142]                       has_future <- base::requireNamespace("future", 
[13:22:55.142]                         quietly = TRUE)
[13:22:55.142]                       if (has_future) {
[13:22:55.142]                         ns <- base::getNamespace("future")
[13:22:55.142]                         version <- ns[[".package"]][["version"]]
[13:22:55.142]                         if (is.null(version)) 
[13:22:55.142]                           version <- utils::packageVersion("future")
[13:22:55.142]                       }
[13:22:55.142]                       else {
[13:22:55.142]                         version <- NULL
[13:22:55.142]                       }
[13:22:55.142]                       if (!has_future || version < "1.8.0") {
[13:22:55.142]                         info <- base::c(r_version = base::gsub("R version ", 
[13:22:55.142]                           "", base::R.version$version.string), 
[13:22:55.142]                           platform = base::sprintf("%s (%s-bit)", 
[13:22:55.142]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:55.142]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:55.142]                             "release", "version")], collapse = " "), 
[13:22:55.142]                           hostname = base::Sys.info()[["nodename"]])
[13:22:55.142]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:22:55.142]                           info)
[13:22:55.142]                         info <- base::paste(info, collapse = "; ")
[13:22:55.142]                         if (!has_future) {
[13:22:55.142]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:55.142]                             info)
[13:22:55.142]                         }
[13:22:55.142]                         else {
[13:22:55.142]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:55.142]                             info, version)
[13:22:55.142]                         }
[13:22:55.142]                         base::stop(msg)
[13:22:55.142]                       }
[13:22:55.142]                     })
[13:22:55.142]                   }
[13:22:55.142]                   options(future.plan = NULL)
[13:22:55.142]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.142]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:55.142]                 }
[13:22:55.142]                 ...future.workdir <- getwd()
[13:22:55.142]             }
[13:22:55.142]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:55.142]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:55.142]         }
[13:22:55.142]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:55.142]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:55.142]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:55.142]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:55.142]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:55.142]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:55.142]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:55.142]             base::names(...future.oldOptions))
[13:22:55.142]     }
[13:22:55.142]     if (FALSE) {
[13:22:55.142]     }
[13:22:55.142]     else {
[13:22:55.142]         if (TRUE) {
[13:22:55.142]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:55.142]                 open = "w")
[13:22:55.142]         }
[13:22:55.142]         else {
[13:22:55.142]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:55.142]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:55.142]         }
[13:22:55.142]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:55.142]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:55.142]             base::sink(type = "output", split = FALSE)
[13:22:55.142]             base::close(...future.stdout)
[13:22:55.142]         }, add = TRUE)
[13:22:55.142]     }
[13:22:55.142]     ...future.frame <- base::sys.nframe()
[13:22:55.142]     ...future.conditions <- base::list()
[13:22:55.142]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:55.142]     if (FALSE) {
[13:22:55.142]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:55.142]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:55.142]     }
[13:22:55.142]     ...future.result <- base::tryCatch({
[13:22:55.142]         base::withCallingHandlers({
[13:22:55.142]             ...future.value <- base::withVisible(base::local(1))
[13:22:55.142]             future::FutureResult(value = ...future.value$value, 
[13:22:55.142]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.142]                   ...future.rng), globalenv = if (FALSE) 
[13:22:55.142]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:55.142]                     ...future.globalenv.names))
[13:22:55.142]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:55.142]         }, condition = base::local({
[13:22:55.142]             c <- base::c
[13:22:55.142]             inherits <- base::inherits
[13:22:55.142]             invokeRestart <- base::invokeRestart
[13:22:55.142]             length <- base::length
[13:22:55.142]             list <- base::list
[13:22:55.142]             seq.int <- base::seq.int
[13:22:55.142]             signalCondition <- base::signalCondition
[13:22:55.142]             sys.calls <- base::sys.calls
[13:22:55.142]             `[[` <- base::`[[`
[13:22:55.142]             `+` <- base::`+`
[13:22:55.142]             `<<-` <- base::`<<-`
[13:22:55.142]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:55.142]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:55.142]                   3L)]
[13:22:55.142]             }
[13:22:55.142]             function(cond) {
[13:22:55.142]                 is_error <- inherits(cond, "error")
[13:22:55.142]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:55.142]                   NULL)
[13:22:55.142]                 if (is_error) {
[13:22:55.142]                   sessionInformation <- function() {
[13:22:55.142]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:55.142]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:55.142]                       search = base::search(), system = base::Sys.info())
[13:22:55.142]                   }
[13:22:55.142]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.142]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:55.142]                     cond$call), session = sessionInformation(), 
[13:22:55.142]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:55.142]                   signalCondition(cond)
[13:22:55.142]                 }
[13:22:55.142]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:55.142]                 "immediateCondition"))) {
[13:22:55.142]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:55.142]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.142]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:55.142]                   if (TRUE && !signal) {
[13:22:55.142]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.142]                     {
[13:22:55.142]                       inherits <- base::inherits
[13:22:55.142]                       invokeRestart <- base::invokeRestart
[13:22:55.142]                       is.null <- base::is.null
[13:22:55.142]                       muffled <- FALSE
[13:22:55.142]                       if (inherits(cond, "message")) {
[13:22:55.142]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.142]                         if (muffled) 
[13:22:55.142]                           invokeRestart("muffleMessage")
[13:22:55.142]                       }
[13:22:55.142]                       else if (inherits(cond, "warning")) {
[13:22:55.142]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.142]                         if (muffled) 
[13:22:55.142]                           invokeRestart("muffleWarning")
[13:22:55.142]                       }
[13:22:55.142]                       else if (inherits(cond, "condition")) {
[13:22:55.142]                         if (!is.null(pattern)) {
[13:22:55.142]                           computeRestarts <- base::computeRestarts
[13:22:55.142]                           grepl <- base::grepl
[13:22:55.142]                           restarts <- computeRestarts(cond)
[13:22:55.142]                           for (restart in restarts) {
[13:22:55.142]                             name <- restart$name
[13:22:55.142]                             if (is.null(name)) 
[13:22:55.142]                               next
[13:22:55.142]                             if (!grepl(pattern, name)) 
[13:22:55.142]                               next
[13:22:55.142]                             invokeRestart(restart)
[13:22:55.142]                             muffled <- TRUE
[13:22:55.142]                             break
[13:22:55.142]                           }
[13:22:55.142]                         }
[13:22:55.142]                       }
[13:22:55.142]                       invisible(muffled)
[13:22:55.142]                     }
[13:22:55.142]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.142]                   }
[13:22:55.142]                 }
[13:22:55.142]                 else {
[13:22:55.142]                   if (TRUE) {
[13:22:55.142]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.142]                     {
[13:22:55.142]                       inherits <- base::inherits
[13:22:55.142]                       invokeRestart <- base::invokeRestart
[13:22:55.142]                       is.null <- base::is.null
[13:22:55.142]                       muffled <- FALSE
[13:22:55.142]                       if (inherits(cond, "message")) {
[13:22:55.142]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.142]                         if (muffled) 
[13:22:55.142]                           invokeRestart("muffleMessage")
[13:22:55.142]                       }
[13:22:55.142]                       else if (inherits(cond, "warning")) {
[13:22:55.142]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.142]                         if (muffled) 
[13:22:55.142]                           invokeRestart("muffleWarning")
[13:22:55.142]                       }
[13:22:55.142]                       else if (inherits(cond, "condition")) {
[13:22:55.142]                         if (!is.null(pattern)) {
[13:22:55.142]                           computeRestarts <- base::computeRestarts
[13:22:55.142]                           grepl <- base::grepl
[13:22:55.142]                           restarts <- computeRestarts(cond)
[13:22:55.142]                           for (restart in restarts) {
[13:22:55.142]                             name <- restart$name
[13:22:55.142]                             if (is.null(name)) 
[13:22:55.142]                               next
[13:22:55.142]                             if (!grepl(pattern, name)) 
[13:22:55.142]                               next
[13:22:55.142]                             invokeRestart(restart)
[13:22:55.142]                             muffled <- TRUE
[13:22:55.142]                             break
[13:22:55.142]                           }
[13:22:55.142]                         }
[13:22:55.142]                       }
[13:22:55.142]                       invisible(muffled)
[13:22:55.142]                     }
[13:22:55.142]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.142]                   }
[13:22:55.142]                 }
[13:22:55.142]             }
[13:22:55.142]         }))
[13:22:55.142]     }, error = function(ex) {
[13:22:55.142]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:55.142]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.142]                 ...future.rng), started = ...future.startTime, 
[13:22:55.142]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:55.142]             version = "1.8"), class = "FutureResult")
[13:22:55.142]     }, finally = {
[13:22:55.142]         if (!identical(...future.workdir, getwd())) 
[13:22:55.142]             setwd(...future.workdir)
[13:22:55.142]         {
[13:22:55.142]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:55.142]                 ...future.oldOptions$nwarnings <- NULL
[13:22:55.142]             }
[13:22:55.142]             base::options(...future.oldOptions)
[13:22:55.142]             if (.Platform$OS.type == "windows") {
[13:22:55.142]                 old_names <- names(...future.oldEnvVars)
[13:22:55.142]                 envs <- base::Sys.getenv()
[13:22:55.142]                 names <- names(envs)
[13:22:55.142]                 common <- intersect(names, old_names)
[13:22:55.142]                 added <- setdiff(names, old_names)
[13:22:55.142]                 removed <- setdiff(old_names, names)
[13:22:55.142]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:55.142]                   envs[common]]
[13:22:55.142]                 NAMES <- toupper(changed)
[13:22:55.142]                 args <- list()
[13:22:55.142]                 for (kk in seq_along(NAMES)) {
[13:22:55.142]                   name <- changed[[kk]]
[13:22:55.142]                   NAME <- NAMES[[kk]]
[13:22:55.142]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.142]                     next
[13:22:55.142]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.142]                 }
[13:22:55.142]                 NAMES <- toupper(added)
[13:22:55.142]                 for (kk in seq_along(NAMES)) {
[13:22:55.142]                   name <- added[[kk]]
[13:22:55.142]                   NAME <- NAMES[[kk]]
[13:22:55.142]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.142]                     next
[13:22:55.142]                   args[[name]] <- ""
[13:22:55.142]                 }
[13:22:55.142]                 NAMES <- toupper(removed)
[13:22:55.142]                 for (kk in seq_along(NAMES)) {
[13:22:55.142]                   name <- removed[[kk]]
[13:22:55.142]                   NAME <- NAMES[[kk]]
[13:22:55.142]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.142]                     next
[13:22:55.142]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.142]                 }
[13:22:55.142]                 if (length(args) > 0) 
[13:22:55.142]                   base::do.call(base::Sys.setenv, args = args)
[13:22:55.142]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:55.142]             }
[13:22:55.142]             else {
[13:22:55.142]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:55.142]             }
[13:22:55.142]             {
[13:22:55.142]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:55.142]                   0L) {
[13:22:55.142]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:55.142]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:55.142]                   base::options(opts)
[13:22:55.142]                 }
[13:22:55.142]                 {
[13:22:55.142]                   {
[13:22:55.142]                     NULL
[13:22:55.142]                     RNGkind("Mersenne-Twister")
[13:22:55.142]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:22:55.142]                       inherits = FALSE)
[13:22:55.142]                   }
[13:22:55.142]                   options(future.plan = NULL)
[13:22:55.142]                   if (is.na(NA_character_)) 
[13:22:55.142]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.142]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:55.142]                   future::plan(list(function (..., envir = parent.frame()) 
[13:22:55.142]                   {
[13:22:55.142]                     future <- SequentialFuture(..., envir = envir)
[13:22:55.142]                     if (!future$lazy) 
[13:22:55.142]                       future <- run(future)
[13:22:55.142]                     invisible(future)
[13:22:55.142]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:55.142]                 }
[13:22:55.142]             }
[13:22:55.142]         }
[13:22:55.142]     })
[13:22:55.142]     if (TRUE) {
[13:22:55.142]         base::sink(type = "output", split = FALSE)
[13:22:55.142]         if (TRUE) {
[13:22:55.142]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:55.142]         }
[13:22:55.142]         else {
[13:22:55.142]             ...future.result["stdout"] <- base::list(NULL)
[13:22:55.142]         }
[13:22:55.142]         base::close(...future.stdout)
[13:22:55.142]         ...future.stdout <- NULL
[13:22:55.142]     }
[13:22:55.142]     ...future.result$conditions <- ...future.conditions
[13:22:55.142]     ...future.result$finished <- base::Sys.time()
[13:22:55.142]     ...future.result
[13:22:55.142] }
[13:22:55.143] plan(): Setting new future strategy stack:
[13:22:55.143] List of future strategies:
[13:22:55.143] 1. sequential:
[13:22:55.143]    - args: function (..., envir = parent.frame())
[13:22:55.143]    - tweaked: FALSE
[13:22:55.143]    - call: NULL
[13:22:55.144] plan(): nbrOfWorkers() = 1
[13:22:55.145] plan(): Setting new future strategy stack:
[13:22:55.145] List of future strategies:
[13:22:55.145] 1. sequential:
[13:22:55.145]    - args: function (..., envir = parent.frame())
[13:22:55.145]    - tweaked: FALSE
[13:22:55.145]    - call: plan(strategy)
[13:22:55.145] plan(): nbrOfWorkers() = 1
[13:22:55.145] SequentialFuture started (and completed)
[13:22:55.145] - Launch lazy future ... done
[13:22:55.146] run() for ‘SequentialFuture’ ... done
d = 1
** Nested future assignments
[13:22:55.146] getGlobalsAndPackages() ...
[13:22:55.146] Searching for globals...
[13:22:55.150] - globals found: [5] ‘{’, ‘<-’, ‘%<-%’, ‘%->%’, ‘+’
[13:22:55.150] Searching for globals ... DONE
[13:22:55.150] Resolving globals: FALSE
[13:22:55.150] 
[13:22:55.150] - packages: [1] ‘future’
[13:22:55.151] getGlobalsAndPackages() ... DONE
[13:22:55.151] run() for ‘Future’ ...
[13:22:55.151] - state: ‘created’
[13:22:55.151] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:22:55.151] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:22:55.151] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:22:55.152]   - Field: ‘label’
[13:22:55.152]   - Field: ‘local’
[13:22:55.152]   - Field: ‘owner’
[13:22:55.152]   - Field: ‘envir’
[13:22:55.152]   - Field: ‘packages’
[13:22:55.152]   - Field: ‘gc’
[13:22:55.152]   - Field: ‘conditions’
[13:22:55.152]   - Field: ‘expr’
[13:22:55.152]   - Field: ‘uuid’
[13:22:55.152]   - Field: ‘seed’
[13:22:55.153]   - Field: ‘version’
[13:22:55.153]   - Field: ‘result’
[13:22:55.153]   - Field: ‘asynchronous’
[13:22:55.153]   - Field: ‘calls’
[13:22:55.153]   - Field: ‘globals’
[13:22:55.153]   - Field: ‘stdout’
[13:22:55.153]   - Field: ‘earlySignal’
[13:22:55.153]   - Field: ‘lazy’
[13:22:55.153]   - Field: ‘state’
[13:22:55.153] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:22:55.153] - Launch lazy future ...
[13:22:55.154] Packages needed by the future expression (n = 1): ‘future’
[13:22:55.154] Packages needed by future strategies (n = 0): <none>
[13:22:55.154] {
[13:22:55.154]     {
[13:22:55.154]         {
[13:22:55.154]             ...future.startTime <- base::Sys.time()
[13:22:55.154]             {
[13:22:55.154]                 {
[13:22:55.154]                   {
[13:22:55.154]                     {
[13:22:55.154]                       base::local({
[13:22:55.154]                         has_future <- base::requireNamespace("future", 
[13:22:55.154]                           quietly = TRUE)
[13:22:55.154]                         if (has_future) {
[13:22:55.154]                           ns <- base::getNamespace("future")
[13:22:55.154]                           version <- ns[[".package"]][["version"]]
[13:22:55.154]                           if (is.null(version)) 
[13:22:55.154]                             version <- utils::packageVersion("future")
[13:22:55.154]                         }
[13:22:55.154]                         else {
[13:22:55.154]                           version <- NULL
[13:22:55.154]                         }
[13:22:55.154]                         if (!has_future || version < "1.8.0") {
[13:22:55.154]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:55.154]                             "", base::R.version$version.string), 
[13:22:55.154]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:55.154]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:55.154]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:55.154]                               "release", "version")], collapse = " "), 
[13:22:55.154]                             hostname = base::Sys.info()[["nodename"]])
[13:22:55.154]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:55.154]                             info)
[13:22:55.154]                           info <- base::paste(info, collapse = "; ")
[13:22:55.154]                           if (!has_future) {
[13:22:55.154]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:55.154]                               info)
[13:22:55.154]                           }
[13:22:55.154]                           else {
[13:22:55.154]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:55.154]                               info, version)
[13:22:55.154]                           }
[13:22:55.154]                           base::stop(msg)
[13:22:55.154]                         }
[13:22:55.154]                       })
[13:22:55.154]                     }
[13:22:55.154]                     base::local({
[13:22:55.154]                       for (pkg in "future") {
[13:22:55.154]                         base::loadNamespace(pkg)
[13:22:55.154]                         base::library(pkg, character.only = TRUE)
[13:22:55.154]                       }
[13:22:55.154]                     })
[13:22:55.154]                   }
[13:22:55.154]                   options(future.plan = NULL)
[13:22:55.154]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.154]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:55.154]                 }
[13:22:55.154]                 ...future.workdir <- getwd()
[13:22:55.154]             }
[13:22:55.154]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:55.154]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:55.154]         }
[13:22:55.154]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:55.154]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:55.154]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:55.154]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:55.154]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:55.154]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:55.154]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:55.154]             base::names(...future.oldOptions))
[13:22:55.154]     }
[13:22:55.154]     if (FALSE) {
[13:22:55.154]     }
[13:22:55.154]     else {
[13:22:55.154]         if (TRUE) {
[13:22:55.154]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:55.154]                 open = "w")
[13:22:55.154]         }
[13:22:55.154]         else {
[13:22:55.154]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:55.154]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:55.154]         }
[13:22:55.154]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:55.154]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:55.154]             base::sink(type = "output", split = FALSE)
[13:22:55.154]             base::close(...future.stdout)
[13:22:55.154]         }, add = TRUE)
[13:22:55.154]     }
[13:22:55.154]     ...future.frame <- base::sys.nframe()
[13:22:55.154]     ...future.conditions <- base::list()
[13:22:55.154]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:55.154]     if (FALSE) {
[13:22:55.154]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:55.154]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:55.154]     }
[13:22:55.154]     ...future.result <- base::tryCatch({
[13:22:55.154]         base::withCallingHandlers({
[13:22:55.154]             ...future.value <- base::withVisible(base::local({
[13:22:55.154]                 b <- 1
[13:22:55.154]                 c %<-% 2
[13:22:55.154]                 d <- 3
[13:22:55.154]                 4 %->% e
[13:22:55.154]                 b + c + d + e
[13:22:55.154]             }))
[13:22:55.154]             future::FutureResult(value = ...future.value$value, 
[13:22:55.154]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.154]                   ...future.rng), globalenv = if (FALSE) 
[13:22:55.154]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:55.154]                     ...future.globalenv.names))
[13:22:55.154]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:55.154]         }, condition = base::local({
[13:22:55.154]             c <- base::c
[13:22:55.154]             inherits <- base::inherits
[13:22:55.154]             invokeRestart <- base::invokeRestart
[13:22:55.154]             length <- base::length
[13:22:55.154]             list <- base::list
[13:22:55.154]             seq.int <- base::seq.int
[13:22:55.154]             signalCondition <- base::signalCondition
[13:22:55.154]             sys.calls <- base::sys.calls
[13:22:55.154]             `[[` <- base::`[[`
[13:22:55.154]             `+` <- base::`+`
[13:22:55.154]             `<<-` <- base::`<<-`
[13:22:55.154]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:55.154]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:55.154]                   3L)]
[13:22:55.154]             }
[13:22:55.154]             function(cond) {
[13:22:55.154]                 is_error <- inherits(cond, "error")
[13:22:55.154]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:55.154]                   NULL)
[13:22:55.154]                 if (is_error) {
[13:22:55.154]                   sessionInformation <- function() {
[13:22:55.154]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:55.154]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:55.154]                       search = base::search(), system = base::Sys.info())
[13:22:55.154]                   }
[13:22:55.154]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.154]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:55.154]                     cond$call), session = sessionInformation(), 
[13:22:55.154]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:55.154]                   signalCondition(cond)
[13:22:55.154]                 }
[13:22:55.154]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:55.154]                 "immediateCondition"))) {
[13:22:55.154]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:55.154]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.154]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:55.154]                   if (TRUE && !signal) {
[13:22:55.154]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.154]                     {
[13:22:55.154]                       inherits <- base::inherits
[13:22:55.154]                       invokeRestart <- base::invokeRestart
[13:22:55.154]                       is.null <- base::is.null
[13:22:55.154]                       muffled <- FALSE
[13:22:55.154]                       if (inherits(cond, "message")) {
[13:22:55.154]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.154]                         if (muffled) 
[13:22:55.154]                           invokeRestart("muffleMessage")
[13:22:55.154]                       }
[13:22:55.154]                       else if (inherits(cond, "warning")) {
[13:22:55.154]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.154]                         if (muffled) 
[13:22:55.154]                           invokeRestart("muffleWarning")
[13:22:55.154]                       }
[13:22:55.154]                       else if (inherits(cond, "condition")) {
[13:22:55.154]                         if (!is.null(pattern)) {
[13:22:55.154]                           computeRestarts <- base::computeRestarts
[13:22:55.154]                           grepl <- base::grepl
[13:22:55.154]                           restarts <- computeRestarts(cond)
[13:22:55.154]                           for (restart in restarts) {
[13:22:55.154]                             name <- restart$name
[13:22:55.154]                             if (is.null(name)) 
[13:22:55.154]                               next
[13:22:55.154]                             if (!grepl(pattern, name)) 
[13:22:55.154]                               next
[13:22:55.154]                             invokeRestart(restart)
[13:22:55.154]                             muffled <- TRUE
[13:22:55.154]                             break
[13:22:55.154]                           }
[13:22:55.154]                         }
[13:22:55.154]                       }
[13:22:55.154]                       invisible(muffled)
[13:22:55.154]                     }
[13:22:55.154]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.154]                   }
[13:22:55.154]                 }
[13:22:55.154]                 else {
[13:22:55.154]                   if (TRUE) {
[13:22:55.154]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.154]                     {
[13:22:55.154]                       inherits <- base::inherits
[13:22:55.154]                       invokeRestart <- base::invokeRestart
[13:22:55.154]                       is.null <- base::is.null
[13:22:55.154]                       muffled <- FALSE
[13:22:55.154]                       if (inherits(cond, "message")) {
[13:22:55.154]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.154]                         if (muffled) 
[13:22:55.154]                           invokeRestart("muffleMessage")
[13:22:55.154]                       }
[13:22:55.154]                       else if (inherits(cond, "warning")) {
[13:22:55.154]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.154]                         if (muffled) 
[13:22:55.154]                           invokeRestart("muffleWarning")
[13:22:55.154]                       }
[13:22:55.154]                       else if (inherits(cond, "condition")) {
[13:22:55.154]                         if (!is.null(pattern)) {
[13:22:55.154]                           computeRestarts <- base::computeRestarts
[13:22:55.154]                           grepl <- base::grepl
[13:22:55.154]                           restarts <- computeRestarts(cond)
[13:22:55.154]                           for (restart in restarts) {
[13:22:55.154]                             name <- restart$name
[13:22:55.154]                             if (is.null(name)) 
[13:22:55.154]                               next
[13:22:55.154]                             if (!grepl(pattern, name)) 
[13:22:55.154]                               next
[13:22:55.154]                             invokeRestart(restart)
[13:22:55.154]                             muffled <- TRUE
[13:22:55.154]                             break
[13:22:55.154]                           }
[13:22:55.154]                         }
[13:22:55.154]                       }
[13:22:55.154]                       invisible(muffled)
[13:22:55.154]                     }
[13:22:55.154]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.154]                   }
[13:22:55.154]                 }
[13:22:55.154]             }
[13:22:55.154]         }))
[13:22:55.154]     }, error = function(ex) {
[13:22:55.154]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:55.154]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.154]                 ...future.rng), started = ...future.startTime, 
[13:22:55.154]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:55.154]             version = "1.8"), class = "FutureResult")
[13:22:55.154]     }, finally = {
[13:22:55.154]         if (!identical(...future.workdir, getwd())) 
[13:22:55.154]             setwd(...future.workdir)
[13:22:55.154]         {
[13:22:55.154]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:55.154]                 ...future.oldOptions$nwarnings <- NULL
[13:22:55.154]             }
[13:22:55.154]             base::options(...future.oldOptions)
[13:22:55.154]             if (.Platform$OS.type == "windows") {
[13:22:55.154]                 old_names <- names(...future.oldEnvVars)
[13:22:55.154]                 envs <- base::Sys.getenv()
[13:22:55.154]                 names <- names(envs)
[13:22:55.154]                 common <- intersect(names, old_names)
[13:22:55.154]                 added <- setdiff(names, old_names)
[13:22:55.154]                 removed <- setdiff(old_names, names)
[13:22:55.154]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:55.154]                   envs[common]]
[13:22:55.154]                 NAMES <- toupper(changed)
[13:22:55.154]                 args <- list()
[13:22:55.154]                 for (kk in seq_along(NAMES)) {
[13:22:55.154]                   name <- changed[[kk]]
[13:22:55.154]                   NAME <- NAMES[[kk]]
[13:22:55.154]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.154]                     next
[13:22:55.154]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.154]                 }
[13:22:55.154]                 NAMES <- toupper(added)
[13:22:55.154]                 for (kk in seq_along(NAMES)) {
[13:22:55.154]                   name <- added[[kk]]
[13:22:55.154]                   NAME <- NAMES[[kk]]
[13:22:55.154]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.154]                     next
[13:22:55.154]                   args[[name]] <- ""
[13:22:55.154]                 }
[13:22:55.154]                 NAMES <- toupper(removed)
[13:22:55.154]                 for (kk in seq_along(NAMES)) {
[13:22:55.154]                   name <- removed[[kk]]
[13:22:55.154]                   NAME <- NAMES[[kk]]
[13:22:55.154]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.154]                     next
[13:22:55.154]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.154]                 }
[13:22:55.154]                 if (length(args) > 0) 
[13:22:55.154]                   base::do.call(base::Sys.setenv, args = args)
[13:22:55.154]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:55.154]             }
[13:22:55.154]             else {
[13:22:55.154]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:55.154]             }
[13:22:55.154]             {
[13:22:55.154]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:55.154]                   0L) {
[13:22:55.154]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:55.154]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:55.154]                   base::options(opts)
[13:22:55.154]                 }
[13:22:55.154]                 {
[13:22:55.154]                   {
[13:22:55.154]                     NULL
[13:22:55.154]                     RNGkind("Mersenne-Twister")
[13:22:55.154]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:22:55.154]                       inherits = FALSE)
[13:22:55.154]                   }
[13:22:55.154]                   options(future.plan = NULL)
[13:22:55.154]                   if (is.na(NA_character_)) 
[13:22:55.154]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.154]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:55.154]                   future::plan(list(function (..., envir = parent.frame()) 
[13:22:55.154]                   {
[13:22:55.154]                     future <- SequentialFuture(..., envir = envir)
[13:22:55.154]                     if (!future$lazy) 
[13:22:55.154]                       future <- run(future)
[13:22:55.154]                     invisible(future)
[13:22:55.154]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:55.154]                 }
[13:22:55.154]             }
[13:22:55.154]         }
[13:22:55.154]     })
[13:22:55.154]     if (TRUE) {
[13:22:55.154]         base::sink(type = "output", split = FALSE)
[13:22:55.154]         if (TRUE) {
[13:22:55.154]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:55.154]         }
[13:22:55.154]         else {
[13:22:55.154]             ...future.result["stdout"] <- base::list(NULL)
[13:22:55.154]         }
[13:22:55.154]         base::close(...future.stdout)
[13:22:55.154]         ...future.stdout <- NULL
[13:22:55.154]     }
[13:22:55.154]     ...future.result$conditions <- ...future.conditions
[13:22:55.154]     ...future.result$finished <- base::Sys.time()
[13:22:55.154]     ...future.result
[13:22:55.154] }
[13:22:55.156] plan(): Setting new future strategy stack:
[13:22:55.156] List of future strategies:
[13:22:55.156] 1. sequential:
[13:22:55.156]    - args: function (..., envir = parent.frame())
[13:22:55.156]    - tweaked: FALSE
[13:22:55.156]    - call: NULL
[13:22:55.157] plan(): nbrOfWorkers() = 1
[13:22:55.194] plan(): Setting new future strategy stack:
[13:22:55.194] List of future strategies:
[13:22:55.194] 1. sequential:
[13:22:55.194]    - args: function (..., envir = parent.frame())
[13:22:55.194]    - tweaked: FALSE
[13:22:55.194]    - call: plan(strategy)
[13:22:55.194] plan(): nbrOfWorkers() = 1
[13:22:55.194] SequentialFuture started (and completed)
[13:22:55.194] signalConditions() ...
[13:22:55.194]  - include = ‘immediateCondition’
[13:22:55.195]  - exclude = 
[13:22:55.195]  - resignal = FALSE
[13:22:55.195]  - Number of conditions: 88
[13:22:55.195] signalConditions() ... done
[13:22:55.195] - Launch lazy future ... done
[13:22:55.195] run() for ‘SequentialFuture’ ... done
[13:22:55.195] signalConditions() ...
[13:22:55.195]  - include = ‘immediateCondition’
[13:22:55.195]  - exclude = 
[13:22:55.196]  - resignal = FALSE
[13:22:55.196]  - Number of conditions: 88
[13:22:55.196] signalConditions() ... done
[13:22:55.196] Future state: ‘finished’
[13:22:55.196] signalConditions() ...
[13:22:55.196]  - include = ‘condition’
[13:22:55.196]  - exclude = ‘immediateCondition’
[13:22:55.196]  - resignal = TRUE
[13:22:55.196]  - Number of conditions: 88
[13:22:55.197]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.157] getGlobalsAndPackages() ...
[13:22:55.197]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.158] Searching for globals...
[13:22:55.197]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.173] 
[13:22:55.197]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.174] Searching for globals ... DONE
[13:22:55.197]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.174] - globals: [0] <none>
[13:22:55.197]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.174] getGlobalsAndPackages() ... DONE
[13:22:55.197]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.174] run() for ‘Future’ ...
[13:22:55.197]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.174] - state: ‘created’
[13:22:55.198]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.174] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:22:55.198]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.175] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:22:55.198]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.175] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:22:55.198]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.175]   - Field: ‘label’
[13:22:55.198]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.175]   - Field: ‘local’
[13:22:55.198]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.175]   - Field: ‘owner’
[13:22:55.198]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.175]   - Field: ‘envir’
[13:22:55.199]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.175]   - Field: ‘packages’
[13:22:55.199]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.176]   - Field: ‘gc’
[13:22:55.199]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.176]   - Field: ‘conditions’
[13:22:55.199]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.176]   - Field: ‘expr’
[13:22:55.199]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.176]   - Field: ‘uuid’
[13:22:55.199]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.176]   - Field: ‘seed’
[13:22:55.199]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.176]   - Field: ‘version’
[13:22:55.199]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.176]   - Field: ‘result’
[13:22:55.200]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.176]   - Field: ‘asynchronous’
[13:22:55.200]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.176]   - Field: ‘calls’
[13:22:55.200]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.177]   - Field: ‘globals’
[13:22:55.200]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.177]   - Field: ‘stdout’
[13:22:55.200]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.177]   - Field: ‘earlySignal’
[13:22:55.200]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.177]   - Field: ‘lazy’
[13:22:55.200]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.177]   - Field: ‘state’
[13:22:55.201]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.177] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:22:55.201]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.177] - Launch lazy future ...
[13:22:55.201]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.177] Packages needed by the future expression (n = 0): <none>
[13:22:55.201]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.178] Packages needed by future strategies (n = 0): <none>
[13:22:55.201]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.178] {
[13:22:55.178]     {
[13:22:55.178]         {
[13:22:55.178]             ...future.startTime <- base::Sys.time()
[13:22:55.178]             {
[13:22:55.178]                 {
[13:22:55.178]                   {
[13:22:55.178]                     base::local({
[13:22:55.178]                       has_future <- base::requireNamespace("future", 
[13:22:55.178]                         quietly = TRUE)
[13:22:55.178]                       if (has_future) {
[13:22:55.178]                         ns <- base::getNamespace("future")
[13:22:55.178]                         version <- ns[[".package"]][["version"]]
[13:22:55.178]                         if (is.null(version)) 
[13:22:55.178]                           version <- utils::packageVersion("future")
[13:22:55.178]                       }
[13:22:55.178]                       else {
[13:22:55.178]                         version <- NULL
[13:22:55.178]                       }
[13:22:55.178]                       if (!has_future || version < "1.8.0") {
[13:22:55.178]                         info <- base::c(r_version = base::gsub("R version ", 
[13:22:55.178]                           "", base::R.version$version.string), 
[13:22:55.178]                           platform = base::sprintf("%s (%s-bit)", 
[13:22:55.178]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:55.178]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:55.178]                             "release", "version")], collapse = " "), 
[13:22:55.178]                           hostname = base::Sys.info()[["nodename"]])
[13:22:55.178]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:22:55.178]                           info)
[13:22:55.178]                         info <- base::paste(info, collapse = "; ")
[13:22:55.178]                         if (!has_future) {
[13:22:55.178]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:55.178]                             info)
[13:22:55.178]                         }
[13:22:55.178]                         else {
[13:22:55.178]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:55.178]                             info, version)
[13:22:55.178]                         }
[13:22:55.178]                         base::stop(msg)
[13:22:55.178]                       }
[13:22:55.178]                     })
[13:22:55.178]                   }
[13:22:55.178]                   options(future.plan = NULL)
[13:22:55.178]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.178]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:55.178]                 }
[13:22:55.178]                 ...future.workdir <- getwd()
[13:22:55.178]             }
[13:22:55.178]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:55.178]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:55.178]         }
[13:22:55.178]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:55.178]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:55.178]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:55.178]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:55.178]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:55.178]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:55.178]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:55.178]             base::names(...future.oldOptions))
[13:22:55.178]     }
[13:22:55.178]     if (FALSE) {
[13:22:55.178]     }
[13:22:55.178]     else {
[13:22:55.178]         if (TRUE) {
[13:22:55.178]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:55.178]                 open = "w")
[13:22:55.178]         }
[13:22:55.178]         else {
[13:22:55.178]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:55.178]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:55.178]         }
[13:22:55.178]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:55.178]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:55.178]             base::sink(type = "output", split = FALSE)
[13:22:55.178]             base::close(...future.stdout)
[13:22:55.178]         }, add = TRUE)
[13:22:55.178]     }
[13:22:55.178]     ...future.frame <- base::sys.nframe()
[13:22:55.178]     ...future.conditions <- base::list()
[13:22:55.178]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:55.178]     if (FALSE) {
[13:22:55.178]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:55.178]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:55.178]     }
[13:22:55.178]     ...future.result <- base::tryCatch({
[13:22:55.178]         base::withCallingHandlers({
[13:22:55.178]             ...future.value <- base::withVisible(base::local(2))
[13:22:55.178]             future::FutureResult(value = ...future.value$value, 
[13:22:55.178]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.178]                   ...future.rng), globalenv = if (FALSE) 
[13:22:55.178]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:55.178]                     ...future.globalenv.names))
[13:22:55.178]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:55.178]         }, condition = base::local({
[13:22:55.178]             c <- base::c
[13:22:55.178]             inherits <- base::inherits
[13:22:55.178]             invokeRestart <- base::invokeRestart
[13:22:55.178]             length <- base::length
[13:22:55.178]             list <- base::list
[13:22:55.178]             seq.int <- base::seq.int
[13:22:55.178]             signalCondition <- base::signalCondition
[13:22:55.178]             sys.calls <- base::sys.calls
[13:22:55.178]             `[[` <- base::`[[`
[13:22:55.178]             `+` <- base::`+`
[13:22:55.178]             `<<-` <- base::`<<-`
[13:22:55.178]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:55.178]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:55.178]                   3L)]
[13:22:55.178]             }
[13:22:55.178]             function(cond) {
[13:22:55.178]                 is_error <- inherits(cond, "error")
[13:22:55.178]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:55.178]                   NULL)
[13:22:55.178]                 if (is_error) {
[13:22:55.178]                   sessionInformation <- function() {
[13:22:55.178]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:55.178]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:55.178]                       search = base::search(), system = base::Sys.info())
[13:22:55.178]                   }
[13:22:55.178]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.178]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:55.178]                     cond$call), session = sessionInformation(), 
[13:22:55.178]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:55.178]                   signalCondition(cond)
[13:22:55.178]                 }
[13:22:55.178]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:55.178]                 "immediateCondition"))) {
[13:22:55.178]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:55.178]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.178]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:55.178]                   if (TRUE && !signal) {
[13:22:55.178]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.178]                     {
[13:22:55.178]                       inherits <- base::inherits
[13:22:55.178]                       invokeRestart <- base::invokeRestart
[13:22:55.178]                       is.null <- base::is.null
[13:22:55.178]                       muffled <- FALSE
[13:22:55.178]                       if (inherits(cond, "message")) {
[13:22:55.178]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.178]                         if (muffled) 
[13:22:55.178]                           invokeRestart("muffleMessage")
[13:22:55.178]                       }
[13:22:55.178]                       else if (inherits(cond, "warning")) {
[13:22:55.178]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.178]                         if (muffled) 
[13:22:55.178]                           invokeRestart("muffleWarning")
[13:22:55.178]                       }
[13:22:55.178]                       else if (inherits(cond, "condition")) {
[13:22:55.178]                         if (!is.null(pattern)) {
[13:22:55.178]                           computeRestarts <- base::computeRestarts
[13:22:55.178]                           grepl <- base::grepl
[13:22:55.178]                           restarts <- computeRestarts(cond)
[13:22:55.178]                           for (restart in restarts) {
[13:22:55.178]                             name <- restart$name
[13:22:55.178]                             if (is.null(name)) 
[13:22:55.178]                               next
[13:22:55.178]                             if (!grepl(pattern, name)) 
[13:22:55.178]                               next
[13:22:55.178]                             invokeRestart(restart)
[13:22:55.178]                             muffled <- TRUE
[13:22:55.178]                             break
[13:22:55.178]                           }
[13:22:55.178]                         }
[13:22:55.178]                       }
[13:22:55.178]                       invisible(muffled)
[13:22:55.178]                     }
[13:22:55.178]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.178]                   }
[13:22:55.178]                 }
[13:22:55.178]                 else {
[13:22:55.178]                   if (TRUE) {
[13:22:55.178]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.178]                     {
[13:22:55.178]                       inherits <- base::inherits
[13:22:55.178]                       invokeRestart <- base::invokeRestart
[13:22:55.178]                       is.null <- base::is.null
[13:22:55.178]                       muffled <- FALSE
[13:22:55.178]                       if (inherits(cond, "message")) {
[13:22:55.178]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.178]                         if (muffled) 
[13:22:55.178]                           invokeRestart("muffleMessage")
[13:22:55.178]                       }
[13:22:55.178]                       else if (inherits(cond, "warning")) {
[13:22:55.178]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.178]                         if (muffled) 
[13:22:55.178]                           invokeRestart("muffleWarning")
[13:22:55.178]                       }
[13:22:55.178]                       else if (inherits(cond, "condition")) {
[13:22:55.178]                         if (!is.null(pattern)) {
[13:22:55.178]                           computeRestarts <- base::computeRestarts
[13:22:55.178]                           grepl <- base::grepl
[13:22:55.178]                           restarts <- computeRestarts(cond)
[13:22:55.178]                           for (restart in restarts) {
[13:22:55.178]                             name <- restart$name
[13:22:55.178]                             if (is.null(name)) 
[13:22:55.178]                               next
[13:22:55.178]                             if (!grepl(pattern, name)) 
[13:22:55.178]                               next
[13:22:55.178]                             invokeRestart(restart)
[13:22:55.178]                             muffled <- TRUE
[13:22:55.178]                             break
[13:22:55.178]                           }
[13:22:55.178]                         }
[13:22:55.178]                       }
[13:22:55.178]                       invisible(muffled)
[13:22:55.178]                     }
[13:22:55.178]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.178]                   }
[13:22:55.178]                 }
[13:22:55.178]             }
[13:22:55.178]         }))
[13:22:55.178]     }, error = function(ex) {
[13:22:55.178]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:55.178]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.178]                 ...future.rng), started = ...future.startTime, 
[13:22:55.178]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:55.178]             version = "1.8"), class = "FutureResult")
[13:22:55.178]     }, finally = {
[13:22:55.178]         if (!identical(...future.workdir, getwd())) 
[13:22:55.178]             setwd(...future.workdir)
[13:22:55.178]         {
[13:22:55.178]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:55.178]                 ...future.oldOptions$nwarnings <- NULL
[13:22:55.178]             }
[13:22:55.178]             base::options(...future.oldOptions)
[13:22:55.178]             if (.Platform$OS.type == "windows") {
[13:22:55.178]                 old_names <- names(...future.oldEnvVars)
[13:22:55.178]                 envs <- base::Sys.getenv()
[13:22:55.178]                 names <- names(envs)
[13:22:55.178]                 common <- intersect(names, old_names)
[13:22:55.178]                 added <- setdiff(names, old_names)
[13:22:55.178]                 removed <- setdiff(old_names, names)
[13:22:55.178]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:55.178]                   envs[common]]
[13:22:55.178]                 NAMES <- toupper(changed)
[13:22:55.178]                 args <- list()
[13:22:55.178]                 for (kk in seq_along(NAMES)) {
[13:22:55.178]                   name <- changed[[kk]]
[13:22:55.178]                   NAME <- NAMES[[kk]]
[13:22:55.178]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.178]                     next
[13:22:55.178]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.178]                 }
[13:22:55.178]                 NAMES <- toupper(added)
[13:22:55.178]                 for (kk in seq_along(NAMES)) {
[13:22:55.178]                   name <- added[[kk]]
[13:22:55.178]                   NAME <- NAMES[[kk]]
[13:22:55.178]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.178]                     next
[13:22:55.178]                   args[[name]] <- ""
[13:22:55.178]                 }
[13:22:55.178]                 NAMES <- toupper(removed)
[13:22:55.178]                 for (kk in seq_along(NAMES)) {
[13:22:55.178]                   name <- removed[[kk]]
[13:22:55.178]                   NAME <- NAMES[[kk]]
[13:22:55.178]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.178]                     next
[13:22:55.178]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.178]                 }
[13:22:55.178]                 if (length(args) > 0) 
[13:22:55.178]                   base::do.call(base::Sys.setenv, args = args)
[13:22:55.178]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:55.178]             }
[13:22:55.178]             else {
[13:22:55.178]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:55.178]             }
[13:22:55.178]             {
[13:22:55.178]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:55.178]                   0L) {
[13:22:55.178]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:55.178]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:55.178]                   base::options(opts)
[13:22:55.178]                 }
[13:22:55.178]                 {
[13:22:55.178]                   {
[13:22:55.178]                     NULL
[13:22:55.178]                     RNGkind("Mersenne-Twister")
[13:22:55.178]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:22:55.178]                       inherits = FALSE)
[13:22:55.178]                   }
[13:22:55.178]                   options(future.plan = NULL)
[13:22:55.178]                   if (is.na(NA_character_)) 
[13:22:55.178]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.178]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:55.178]                   future::plan(list(function (..., envir = parent.frame()) 
[13:22:55.178]                   {
[13:22:55.178]                     future <- SequentialFuture(..., envir = envir)
[13:22:55.178]                     if (!future$lazy) 
[13:22:55.178]                       future <- run(future)
[13:22:55.178]                     invisible(future)
[13:22:55.178]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:55.178]                 }
[13:22:55.178]             }
[13:22:55.178]         }
[13:22:55.178]     })
[13:22:55.178]     if (TRUE) {
[13:22:55.178]         base::sink(type = "output", split = FALSE)
[13:22:55.178]         if (TRUE) {
[13:22:55.178]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:55.178]         }
[13:22:55.178]         else {
[13:22:55.178]             ...future.result["stdout"] <- base::list(NULL)
[13:22:55.178]         }
[13:22:55.178]         base::close(...future.stdout)
[13:22:55.178]         ...future.stdout <- NULL
[13:22:55.178]     }
[13:22:55.178]     ...future.result$conditions <- ...future.conditions
[13:22:55.178]     ...future.result$finished <- base::Sys.time()
[13:22:55.178]     ...future.result
[13:22:55.178] }
[13:22:55.201]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.180] plan(): Setting new future strategy stack:
[13:22:55.201]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.180] List of future strategies:
[13:22:55.180] 1. sequential:
[13:22:55.180]    - args: function (..., envir = parent.frame())
[13:22:55.180]    - tweaked: FALSE
[13:22:55.180]    - call: NULL
[13:22:55.201]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.180] plan(): nbrOfWorkers() = 1
[13:22:55.202]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.183] plan(): Setting new future strategy stack:
[13:22:55.202]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.183] List of future strategies:
[13:22:55.183] 1. sequential:
[13:22:55.183]    - args: function (..., envir = parent.frame())
[13:22:55.183]    - tweaked: FALSE
[13:22:55.183]    - call: NULL
[13:22:55.202]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.183] plan(): nbrOfWorkers() = 1
[13:22:55.202]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.184] SequentialFuture started (and completed)
[13:22:55.202]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.184] - Launch lazy future ... done
[13:22:55.202]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.184] run() for ‘SequentialFuture’ ... done
[13:22:55.202]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.184] getGlobalsAndPackages() ...
[13:22:55.203]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.184] Searching for globals...
[13:22:55.203]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.185] 
[13:22:55.203]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.185] Searching for globals ... DONE
[13:22:55.203]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.185] - globals: [0] <none>
[13:22:55.203]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.185] getGlobalsAndPackages() ... DONE
[13:22:55.203]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.185] run() for ‘Future’ ...
[13:22:55.203]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.185] - state: ‘created’
[13:22:55.203]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.186] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:22:55.204]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.186] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:22:55.204]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.186] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:22:55.204]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.186]   - Field: ‘label’
[13:22:55.204]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.186]   - Field: ‘local’
[13:22:55.204]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.186]   - Field: ‘owner’
[13:22:55.204]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.186]   - Field: ‘envir’
[13:22:55.204]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.187]   - Field: ‘packages’
[13:22:55.205]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.187]   - Field: ‘gc’
[13:22:55.205]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.187]   - Field: ‘conditions’
[13:22:55.205]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.187]   - Field: ‘expr’
[13:22:55.205]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.187]   - Field: ‘uuid’
[13:22:55.205]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.187]   - Field: ‘seed’
[13:22:55.205]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.187]   - Field: ‘version’
[13:22:55.205]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.187]   - Field: ‘result’
[13:22:55.206]  - Condition #68: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.187]   - Field: ‘asynchronous’
[13:22:55.206]  - Condition #69: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.187]   - Field: ‘calls’
[13:22:55.206]  - Condition #70: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.188]   - Field: ‘globals’
[13:22:55.206]  - Condition #71: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.188]   - Field: ‘stdout’
[13:22:55.206]  - Condition #72: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.188]   - Field: ‘earlySignal’
[13:22:55.206]  - Condition #73: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.188]   - Field: ‘lazy’
[13:22:55.208]  - Condition #74: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.188]   - Field: ‘state’
[13:22:55.209]  - Condition #75: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.188] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:22:55.209]  - Condition #76: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.188] - Launch lazy future ...
[13:22:55.209]  - Condition #77: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.188] Packages needed by the future expression (n = 0): <none>
[13:22:55.209]  - Condition #78: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.189] Packages needed by future strategies (n = 0): <none>
[13:22:55.209]  - Condition #79: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.189] {
[13:22:55.189]     {
[13:22:55.189]         {
[13:22:55.189]             ...future.startTime <- base::Sys.time()
[13:22:55.189]             {
[13:22:55.189]                 {
[13:22:55.189]                   {
[13:22:55.189]                     base::local({
[13:22:55.189]                       has_future <- base::requireNamespace("future", 
[13:22:55.189]                         quietly = TRUE)
[13:22:55.189]                       if (has_future) {
[13:22:55.189]                         ns <- base::getNamespace("future")
[13:22:55.189]                         version <- ns[[".package"]][["version"]]
[13:22:55.189]                         if (is.null(version)) 
[13:22:55.189]                           version <- utils::packageVersion("future")
[13:22:55.189]                       }
[13:22:55.189]                       else {
[13:22:55.189]                         version <- NULL
[13:22:55.189]                       }
[13:22:55.189]                       if (!has_future || version < "1.8.0") {
[13:22:55.189]                         info <- base::c(r_version = base::gsub("R version ", 
[13:22:55.189]                           "", base::R.version$version.string), 
[13:22:55.189]                           platform = base::sprintf("%s (%s-bit)", 
[13:22:55.189]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:55.189]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:55.189]                             "release", "version")], collapse = " "), 
[13:22:55.189]                           hostname = base::Sys.info()[["nodename"]])
[13:22:55.189]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:22:55.189]                           info)
[13:22:55.189]                         info <- base::paste(info, collapse = "; ")
[13:22:55.189]                         if (!has_future) {
[13:22:55.189]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:55.189]                             info)
[13:22:55.189]                         }
[13:22:55.189]                         else {
[13:22:55.189]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:55.189]                             info, version)
[13:22:55.189]                         }
[13:22:55.189]                         base::stop(msg)
[13:22:55.189]                       }
[13:22:55.189]                     })
[13:22:55.189]                   }
[13:22:55.189]                   options(future.plan = NULL)
[13:22:55.189]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.189]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:55.189]                 }
[13:22:55.189]                 ...future.workdir <- getwd()
[13:22:55.189]             }
[13:22:55.189]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:55.189]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:55.189]         }
[13:22:55.189]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:55.189]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:55.189]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:55.189]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:55.189]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:55.189]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:55.189]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:55.189]             base::names(...future.oldOptions))
[13:22:55.189]     }
[13:22:55.189]     if (FALSE) {
[13:22:55.189]     }
[13:22:55.189]     else {
[13:22:55.189]         if (TRUE) {
[13:22:55.189]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:55.189]                 open = "w")
[13:22:55.189]         }
[13:22:55.189]         else {
[13:22:55.189]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:55.189]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:55.189]         }
[13:22:55.189]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:55.189]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:55.189]             base::sink(type = "output", split = FALSE)
[13:22:55.189]             base::close(...future.stdout)
[13:22:55.189]         }, add = TRUE)
[13:22:55.189]     }
[13:22:55.189]     ...future.frame <- base::sys.nframe()
[13:22:55.189]     ...future.conditions <- base::list()
[13:22:55.189]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:55.189]     if (FALSE) {
[13:22:55.189]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:55.189]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:55.189]     }
[13:22:55.189]     ...future.result <- base::tryCatch({
[13:22:55.189]         base::withCallingHandlers({
[13:22:55.189]             ...future.value <- base::withVisible(base::local(4))
[13:22:55.189]             future::FutureResult(value = ...future.value$value, 
[13:22:55.189]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.189]                   ...future.rng), globalenv = if (FALSE) 
[13:22:55.189]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:55.189]                     ...future.globalenv.names))
[13:22:55.189]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:55.189]         }, condition = base::local({
[13:22:55.189]             c <- base::c
[13:22:55.189]             inherits <- base::inherits
[13:22:55.189]             invokeRestart <- base::invokeRestart
[13:22:55.189]             length <- base::length
[13:22:55.189]             list <- base::list
[13:22:55.189]             seq.int <- base::seq.int
[13:22:55.189]             signalCondition <- base::signalCondition
[13:22:55.189]             sys.calls <- base::sys.calls
[13:22:55.189]             `[[` <- base::`[[`
[13:22:55.189]             `+` <- base::`+`
[13:22:55.189]             `<<-` <- base::`<<-`
[13:22:55.189]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:55.189]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:55.189]                   3L)]
[13:22:55.189]             }
[13:22:55.189]             function(cond) {
[13:22:55.189]                 is_error <- inherits(cond, "error")
[13:22:55.189]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:55.189]                   NULL)
[13:22:55.189]                 if (is_error) {
[13:22:55.189]                   sessionInformation <- function() {
[13:22:55.189]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:55.189]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:55.189]                       search = base::search(), system = base::Sys.info())
[13:22:55.189]                   }
[13:22:55.189]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.189]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:55.189]                     cond$call), session = sessionInformation(), 
[13:22:55.189]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:55.189]                   signalCondition(cond)
[13:22:55.189]                 }
[13:22:55.189]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:55.189]                 "immediateCondition"))) {
[13:22:55.189]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:55.189]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.189]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:55.189]                   if (TRUE && !signal) {
[13:22:55.189]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.189]                     {
[13:22:55.189]                       inherits <- base::inherits
[13:22:55.189]                       invokeRestart <- base::invokeRestart
[13:22:55.189]                       is.null <- base::is.null
[13:22:55.189]                       muffled <- FALSE
[13:22:55.189]                       if (inherits(cond, "message")) {
[13:22:55.189]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.189]                         if (muffled) 
[13:22:55.189]                           invokeRestart("muffleMessage")
[13:22:55.189]                       }
[13:22:55.189]                       else if (inherits(cond, "warning")) {
[13:22:55.189]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.189]                         if (muffled) 
[13:22:55.189]                           invokeRestart("muffleWarning")
[13:22:55.189]                       }
[13:22:55.189]                       else if (inherits(cond, "condition")) {
[13:22:55.189]                         if (!is.null(pattern)) {
[13:22:55.189]                           computeRestarts <- base::computeRestarts
[13:22:55.189]                           grepl <- base::grepl
[13:22:55.189]                           restarts <- computeRestarts(cond)
[13:22:55.189]                           for (restart in restarts) {
[13:22:55.189]                             name <- restart$name
[13:22:55.189]                             if (is.null(name)) 
[13:22:55.189]                               next
[13:22:55.189]                             if (!grepl(pattern, name)) 
[13:22:55.189]                               next
[13:22:55.189]                             invokeRestart(restart)
[13:22:55.189]                             muffled <- TRUE
[13:22:55.189]                             break
[13:22:55.189]                           }
[13:22:55.189]                         }
[13:22:55.189]                       }
[13:22:55.189]                       invisible(muffled)
[13:22:55.189]                     }
[13:22:55.189]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.189]                   }
[13:22:55.189]                 }
[13:22:55.189]                 else {
[13:22:55.189]                   if (TRUE) {
[13:22:55.189]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.189]                     {
[13:22:55.189]                       inherits <- base::inherits
[13:22:55.189]                       invokeRestart <- base::invokeRestart
[13:22:55.189]                       is.null <- base::is.null
[13:22:55.189]                       muffled <- FALSE
[13:22:55.189]                       if (inherits(cond, "message")) {
[13:22:55.189]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.189]                         if (muffled) 
[13:22:55.189]                           invokeRestart("muffleMessage")
[13:22:55.189]                       }
[13:22:55.189]                       else if (inherits(cond, "warning")) {
[13:22:55.189]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.189]                         if (muffled) 
[13:22:55.189]                           invokeRestart("muffleWarning")
[13:22:55.189]                       }
[13:22:55.189]                       else if (inherits(cond, "condition")) {
[13:22:55.189]                         if (!is.null(pattern)) {
[13:22:55.189]                           computeRestarts <- base::computeRestarts
[13:22:55.189]                           grepl <- base::grepl
[13:22:55.189]                           restarts <- computeRestarts(cond)
[13:22:55.189]                           for (restart in restarts) {
[13:22:55.189]                             name <- restart$name
[13:22:55.189]                             if (is.null(name)) 
[13:22:55.189]                               next
[13:22:55.189]                             if (!grepl(pattern, name)) 
[13:22:55.189]                               next
[13:22:55.189]                             invokeRestart(restart)
[13:22:55.189]                             muffled <- TRUE
[13:22:55.189]                             break
[13:22:55.189]                           }
[13:22:55.189]                         }
[13:22:55.189]                       }
[13:22:55.189]                       invisible(muffled)
[13:22:55.189]                     }
[13:22:55.189]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.189]                   }
[13:22:55.189]                 }
[13:22:55.189]             }
[13:22:55.189]         }))
[13:22:55.189]     }, error = function(ex) {
[13:22:55.189]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:55.189]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.189]                 ...future.rng), started = ...future.startTime, 
[13:22:55.189]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:55.189]             version = "1.8"), class = "FutureResult")
[13:22:55.189]     }, finally = {
[13:22:55.189]         if (!identical(...future.workdir, getwd())) 
[13:22:55.189]             setwd(...future.workdir)
[13:22:55.189]         {
[13:22:55.189]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:55.189]                 ...future.oldOptions$nwarnings <- NULL
[13:22:55.189]             }
[13:22:55.189]             base::options(...future.oldOptions)
[13:22:55.189]             if (.Platform$OS.type == "windows") {
[13:22:55.189]                 old_names <- names(...future.oldEnvVars)
[13:22:55.189]                 envs <- base::Sys.getenv()
[13:22:55.189]                 names <- names(envs)
[13:22:55.189]                 common <- intersect(names, old_names)
[13:22:55.189]                 added <- setdiff(names, old_names)
[13:22:55.189]                 removed <- setdiff(old_names, names)
[13:22:55.189]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:55.189]                   envs[common]]
[13:22:55.189]                 NAMES <- toupper(changed)
[13:22:55.189]                 args <- list()
[13:22:55.189]                 for (kk in seq_along(NAMES)) {
[13:22:55.189]                   name <- changed[[kk]]
[13:22:55.189]                   NAME <- NAMES[[kk]]
[13:22:55.189]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.189]                     next
[13:22:55.189]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.189]                 }
[13:22:55.189]                 NAMES <- toupper(added)
[13:22:55.189]                 for (kk in seq_along(NAMES)) {
[13:22:55.189]                   name <- added[[kk]]
[13:22:55.189]                   NAME <- NAMES[[kk]]
[13:22:55.189]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.189]                     next
[13:22:55.189]                   args[[name]] <- ""
[13:22:55.189]                 }
[13:22:55.189]                 NAMES <- toupper(removed)
[13:22:55.189]                 for (kk in seq_along(NAMES)) {
[13:22:55.189]                   name <- removed[[kk]]
[13:22:55.189]                   NAME <- NAMES[[kk]]
[13:22:55.189]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.189]                     next
[13:22:55.189]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.189]                 }
[13:22:55.189]                 if (length(args) > 0) 
[13:22:55.189]                   base::do.call(base::Sys.setenv, args = args)
[13:22:55.189]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:55.189]             }
[13:22:55.189]             else {
[13:22:55.189]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:55.189]             }
[13:22:55.189]             {
[13:22:55.189]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:55.189]                   0L) {
[13:22:55.189]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:55.189]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:55.189]                   base::options(opts)
[13:22:55.189]                 }
[13:22:55.189]                 {
[13:22:55.189]                   {
[13:22:55.189]                     NULL
[13:22:55.189]                     RNGkind("Mersenne-Twister")
[13:22:55.189]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:22:55.189]                       inherits = FALSE)
[13:22:55.189]                   }
[13:22:55.189]                   options(future.plan = NULL)
[13:22:55.189]                   if (is.na(NA_character_)) 
[13:22:55.189]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.189]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:55.189]                   future::plan(list(function (..., envir = parent.frame()) 
[13:22:55.189]                   {
[13:22:55.189]                     future <- SequentialFuture(..., envir = envir)
[13:22:55.189]                     if (!future$lazy) 
[13:22:55.189]                       future <- run(future)
[13:22:55.189]                     invisible(future)
[13:22:55.189]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:55.189]                 }
[13:22:55.189]             }
[13:22:55.189]         }
[13:22:55.189]     })
[13:22:55.189]     if (TRUE) {
[13:22:55.189]         base::sink(type = "output", split = FALSE)
[13:22:55.189]         if (TRUE) {
[13:22:55.189]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:55.189]         }
[13:22:55.189]         else {
[13:22:55.189]             ...future.result["stdout"] <- base::list(NULL)
[13:22:55.189]         }
[13:22:55.189]         base::close(...future.stdout)
[13:22:55.189]         ...future.stdout <- NULL
[13:22:55.189]     }
[13:22:55.189]     ...future.result$conditions <- ...future.conditions
[13:22:55.189]     ...future.result$finished <- base::Sys.time()
[13:22:55.189]     ...future.result
[13:22:55.189] }
[13:22:55.209]  - Condition #80: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.191] plan(): Setting new future strategy stack:
[13:22:55.210]  - Condition #81: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.191] List of future strategies:
[13:22:55.191] 1. sequential:
[13:22:55.191]    - args: function (..., envir = parent.frame())
[13:22:55.191]    - tweaked: FALSE
[13:22:55.191]    - call: NULL
[13:22:55.210]  - Condition #82: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.191] plan(): nbrOfWorkers() = 1
[13:22:55.210]  - Condition #83: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.192] plan(): Setting new future strategy stack:
[13:22:55.210]  - Condition #84: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.192] List of future strategies:
[13:22:55.192] 1. sequential:
[13:22:55.192]    - args: function (..., envir = parent.frame())
[13:22:55.192]    - tweaked: FALSE
[13:22:55.192]    - call: NULL
[13:22:55.210]  - Condition #85: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.193] plan(): nbrOfWorkers() = 1
[13:22:55.210]  - Condition #86: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.193] SequentialFuture started (and completed)
[13:22:55.210]  - Condition #87: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.193] - Launch lazy future ... done
[13:22:55.211]  - Condition #88: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.193] run() for ‘SequentialFuture’ ... done
[13:22:55.211] signalConditions() ... done
a = 10
[13:22:55.211] getGlobalsAndPackages() ...
[13:22:55.211] Searching for globals...
[13:22:55.212] - globals found: [3] ‘{’, ‘+’, ‘a’
[13:22:55.212] Searching for globals ... DONE
[13:22:55.212] Resolving globals: FALSE
[13:22:55.213] The total size of the 1 globals is 56 bytes (56 bytes)
[13:22:55.213] The total size of the 1 globals exported for future expression (‘{; a + 1; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:22:55.213] - globals: [1] ‘a’
[13:22:55.213] 
[13:22:55.213] getGlobalsAndPackages() ... DONE
[13:22:55.214] run() for ‘Future’ ...
[13:22:55.214] - state: ‘created’
[13:22:55.214] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:22:55.214] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:22:55.214] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:22:55.214]   - Field: ‘label’
[13:22:55.214]   - Field: ‘local’
[13:22:55.215]   - Field: ‘owner’
[13:22:55.215]   - Field: ‘envir’
[13:22:55.215]   - Field: ‘packages’
[13:22:55.215]   - Field: ‘gc’
[13:22:55.215]   - Field: ‘conditions’
[13:22:55.215]   - Field: ‘expr’
[13:22:55.215]   - Field: ‘uuid’
[13:22:55.215]   - Field: ‘seed’
[13:22:55.215]   - Field: ‘version’
[13:22:55.215]   - Field: ‘result’
[13:22:55.215]   - Field: ‘asynchronous’
[13:22:55.216]   - Field: ‘calls’
[13:22:55.216]   - Field: ‘globals’
[13:22:55.216]   - Field: ‘stdout’
[13:22:55.216]   - Field: ‘earlySignal’
[13:22:55.216]   - Field: ‘lazy’
[13:22:55.216]   - Field: ‘state’
[13:22:55.216] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:22:55.216] - Launch lazy future ...
[13:22:55.216] Packages needed by the future expression (n = 0): <none>
[13:22:55.217] Packages needed by future strategies (n = 0): <none>
[13:22:55.217] {
[13:22:55.217]     {
[13:22:55.217]         {
[13:22:55.217]             ...future.startTime <- base::Sys.time()
[13:22:55.217]             {
[13:22:55.217]                 {
[13:22:55.217]                   {
[13:22:55.217]                     base::local({
[13:22:55.217]                       has_future <- base::requireNamespace("future", 
[13:22:55.217]                         quietly = TRUE)
[13:22:55.217]                       if (has_future) {
[13:22:55.217]                         ns <- base::getNamespace("future")
[13:22:55.217]                         version <- ns[[".package"]][["version"]]
[13:22:55.217]                         if (is.null(version)) 
[13:22:55.217]                           version <- utils::packageVersion("future")
[13:22:55.217]                       }
[13:22:55.217]                       else {
[13:22:55.217]                         version <- NULL
[13:22:55.217]                       }
[13:22:55.217]                       if (!has_future || version < "1.8.0") {
[13:22:55.217]                         info <- base::c(r_version = base::gsub("R version ", 
[13:22:55.217]                           "", base::R.version$version.string), 
[13:22:55.217]                           platform = base::sprintf("%s (%s-bit)", 
[13:22:55.217]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:55.217]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:55.217]                             "release", "version")], collapse = " "), 
[13:22:55.217]                           hostname = base::Sys.info()[["nodename"]])
[13:22:55.217]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:22:55.217]                           info)
[13:22:55.217]                         info <- base::paste(info, collapse = "; ")
[13:22:55.217]                         if (!has_future) {
[13:22:55.217]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:55.217]                             info)
[13:22:55.217]                         }
[13:22:55.217]                         else {
[13:22:55.217]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:55.217]                             info, version)
[13:22:55.217]                         }
[13:22:55.217]                         base::stop(msg)
[13:22:55.217]                       }
[13:22:55.217]                     })
[13:22:55.217]                   }
[13:22:55.217]                   options(future.plan = NULL)
[13:22:55.217]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.217]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:55.217]                 }
[13:22:55.217]                 ...future.workdir <- getwd()
[13:22:55.217]             }
[13:22:55.217]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:55.217]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:55.217]         }
[13:22:55.217]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:55.217]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:55.217]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:55.217]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:55.217]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:55.217]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:55.217]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:55.217]             base::names(...future.oldOptions))
[13:22:55.217]     }
[13:22:55.217]     if (FALSE) {
[13:22:55.217]     }
[13:22:55.217]     else {
[13:22:55.217]         if (TRUE) {
[13:22:55.217]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:55.217]                 open = "w")
[13:22:55.217]         }
[13:22:55.217]         else {
[13:22:55.217]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:55.217]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:55.217]         }
[13:22:55.217]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:55.217]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:55.217]             base::sink(type = "output", split = FALSE)
[13:22:55.217]             base::close(...future.stdout)
[13:22:55.217]         }, add = TRUE)
[13:22:55.217]     }
[13:22:55.217]     ...future.frame <- base::sys.nframe()
[13:22:55.217]     ...future.conditions <- base::list()
[13:22:55.217]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:55.217]     if (FALSE) {
[13:22:55.217]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:55.217]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:55.217]     }
[13:22:55.217]     ...future.result <- base::tryCatch({
[13:22:55.217]         base::withCallingHandlers({
[13:22:55.217]             ...future.value <- base::withVisible(base::local({
[13:22:55.217]                 a + 1
[13:22:55.217]             }))
[13:22:55.217]             future::FutureResult(value = ...future.value$value, 
[13:22:55.217]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.217]                   ...future.rng), globalenv = if (FALSE) 
[13:22:55.217]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:55.217]                     ...future.globalenv.names))
[13:22:55.217]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:55.217]         }, condition = base::local({
[13:22:55.217]             c <- base::c
[13:22:55.217]             inherits <- base::inherits
[13:22:55.217]             invokeRestart <- base::invokeRestart
[13:22:55.217]             length <- base::length
[13:22:55.217]             list <- base::list
[13:22:55.217]             seq.int <- base::seq.int
[13:22:55.217]             signalCondition <- base::signalCondition
[13:22:55.217]             sys.calls <- base::sys.calls
[13:22:55.217]             `[[` <- base::`[[`
[13:22:55.217]             `+` <- base::`+`
[13:22:55.217]             `<<-` <- base::`<<-`
[13:22:55.217]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:55.217]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:55.217]                   3L)]
[13:22:55.217]             }
[13:22:55.217]             function(cond) {
[13:22:55.217]                 is_error <- inherits(cond, "error")
[13:22:55.217]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:55.217]                   NULL)
[13:22:55.217]                 if (is_error) {
[13:22:55.217]                   sessionInformation <- function() {
[13:22:55.217]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:55.217]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:55.217]                       search = base::search(), system = base::Sys.info())
[13:22:55.217]                   }
[13:22:55.217]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.217]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:55.217]                     cond$call), session = sessionInformation(), 
[13:22:55.217]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:55.217]                   signalCondition(cond)
[13:22:55.217]                 }
[13:22:55.217]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:55.217]                 "immediateCondition"))) {
[13:22:55.217]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:55.217]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.217]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:55.217]                   if (TRUE && !signal) {
[13:22:55.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.217]                     {
[13:22:55.217]                       inherits <- base::inherits
[13:22:55.217]                       invokeRestart <- base::invokeRestart
[13:22:55.217]                       is.null <- base::is.null
[13:22:55.217]                       muffled <- FALSE
[13:22:55.217]                       if (inherits(cond, "message")) {
[13:22:55.217]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.217]                         if (muffled) 
[13:22:55.217]                           invokeRestart("muffleMessage")
[13:22:55.217]                       }
[13:22:55.217]                       else if (inherits(cond, "warning")) {
[13:22:55.217]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.217]                         if (muffled) 
[13:22:55.217]                           invokeRestart("muffleWarning")
[13:22:55.217]                       }
[13:22:55.217]                       else if (inherits(cond, "condition")) {
[13:22:55.217]                         if (!is.null(pattern)) {
[13:22:55.217]                           computeRestarts <- base::computeRestarts
[13:22:55.217]                           grepl <- base::grepl
[13:22:55.217]                           restarts <- computeRestarts(cond)
[13:22:55.217]                           for (restart in restarts) {
[13:22:55.217]                             name <- restart$name
[13:22:55.217]                             if (is.null(name)) 
[13:22:55.217]                               next
[13:22:55.217]                             if (!grepl(pattern, name)) 
[13:22:55.217]                               next
[13:22:55.217]                             invokeRestart(restart)
[13:22:55.217]                             muffled <- TRUE
[13:22:55.217]                             break
[13:22:55.217]                           }
[13:22:55.217]                         }
[13:22:55.217]                       }
[13:22:55.217]                       invisible(muffled)
[13:22:55.217]                     }
[13:22:55.217]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.217]                   }
[13:22:55.217]                 }
[13:22:55.217]                 else {
[13:22:55.217]                   if (TRUE) {
[13:22:55.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.217]                     {
[13:22:55.217]                       inherits <- base::inherits
[13:22:55.217]                       invokeRestart <- base::invokeRestart
[13:22:55.217]                       is.null <- base::is.null
[13:22:55.217]                       muffled <- FALSE
[13:22:55.217]                       if (inherits(cond, "message")) {
[13:22:55.217]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.217]                         if (muffled) 
[13:22:55.217]                           invokeRestart("muffleMessage")
[13:22:55.217]                       }
[13:22:55.217]                       else if (inherits(cond, "warning")) {
[13:22:55.217]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.217]                         if (muffled) 
[13:22:55.217]                           invokeRestart("muffleWarning")
[13:22:55.217]                       }
[13:22:55.217]                       else if (inherits(cond, "condition")) {
[13:22:55.217]                         if (!is.null(pattern)) {
[13:22:55.217]                           computeRestarts <- base::computeRestarts
[13:22:55.217]                           grepl <- base::grepl
[13:22:55.217]                           restarts <- computeRestarts(cond)
[13:22:55.217]                           for (restart in restarts) {
[13:22:55.217]                             name <- restart$name
[13:22:55.217]                             if (is.null(name)) 
[13:22:55.217]                               next
[13:22:55.217]                             if (!grepl(pattern, name)) 
[13:22:55.217]                               next
[13:22:55.217]                             invokeRestart(restart)
[13:22:55.217]                             muffled <- TRUE
[13:22:55.217]                             break
[13:22:55.217]                           }
[13:22:55.217]                         }
[13:22:55.217]                       }
[13:22:55.217]                       invisible(muffled)
[13:22:55.217]                     }
[13:22:55.217]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.217]                   }
[13:22:55.217]                 }
[13:22:55.217]             }
[13:22:55.217]         }))
[13:22:55.217]     }, error = function(ex) {
[13:22:55.217]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:55.217]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.217]                 ...future.rng), started = ...future.startTime, 
[13:22:55.217]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:55.217]             version = "1.8"), class = "FutureResult")
[13:22:55.217]     }, finally = {
[13:22:55.217]         if (!identical(...future.workdir, getwd())) 
[13:22:55.217]             setwd(...future.workdir)
[13:22:55.217]         {
[13:22:55.217]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:55.217]                 ...future.oldOptions$nwarnings <- NULL
[13:22:55.217]             }
[13:22:55.217]             base::options(...future.oldOptions)
[13:22:55.217]             if (.Platform$OS.type == "windows") {
[13:22:55.217]                 old_names <- names(...future.oldEnvVars)
[13:22:55.217]                 envs <- base::Sys.getenv()
[13:22:55.217]                 names <- names(envs)
[13:22:55.217]                 common <- intersect(names, old_names)
[13:22:55.217]                 added <- setdiff(names, old_names)
[13:22:55.217]                 removed <- setdiff(old_names, names)
[13:22:55.217]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:55.217]                   envs[common]]
[13:22:55.217]                 NAMES <- toupper(changed)
[13:22:55.217]                 args <- list()
[13:22:55.217]                 for (kk in seq_along(NAMES)) {
[13:22:55.217]                   name <- changed[[kk]]
[13:22:55.217]                   NAME <- NAMES[[kk]]
[13:22:55.217]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.217]                     next
[13:22:55.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.217]                 }
[13:22:55.217]                 NAMES <- toupper(added)
[13:22:55.217]                 for (kk in seq_along(NAMES)) {
[13:22:55.217]                   name <- added[[kk]]
[13:22:55.217]                   NAME <- NAMES[[kk]]
[13:22:55.217]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.217]                     next
[13:22:55.217]                   args[[name]] <- ""
[13:22:55.217]                 }
[13:22:55.217]                 NAMES <- toupper(removed)
[13:22:55.217]                 for (kk in seq_along(NAMES)) {
[13:22:55.217]                   name <- removed[[kk]]
[13:22:55.217]                   NAME <- NAMES[[kk]]
[13:22:55.217]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.217]                     next
[13:22:55.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.217]                 }
[13:22:55.217]                 if (length(args) > 0) 
[13:22:55.217]                   base::do.call(base::Sys.setenv, args = args)
[13:22:55.217]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:55.217]             }
[13:22:55.217]             else {
[13:22:55.217]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:55.217]             }
[13:22:55.217]             {
[13:22:55.217]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:55.217]                   0L) {
[13:22:55.217]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:55.217]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:55.217]                   base::options(opts)
[13:22:55.217]                 }
[13:22:55.217]                 {
[13:22:55.217]                   {
[13:22:55.217]                     NULL
[13:22:55.217]                     RNGkind("Mersenne-Twister")
[13:22:55.217]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:22:55.217]                       inherits = FALSE)
[13:22:55.217]                   }
[13:22:55.217]                   options(future.plan = NULL)
[13:22:55.217]                   if (is.na(NA_character_)) 
[13:22:55.217]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.217]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:55.217]                   future::plan(list(function (..., envir = parent.frame()) 
[13:22:55.217]                   {
[13:22:55.217]                     future <- SequentialFuture(..., envir = envir)
[13:22:55.217]                     if (!future$lazy) 
[13:22:55.217]                       future <- run(future)
[13:22:55.217]                     invisible(future)
[13:22:55.217]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:55.217]                 }
[13:22:55.217]             }
[13:22:55.217]         }
[13:22:55.217]     })
[13:22:55.217]     if (TRUE) {
[13:22:55.217]         base::sink(type = "output", split = FALSE)
[13:22:55.217]         if (TRUE) {
[13:22:55.217]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:55.217]         }
[13:22:55.217]         else {
[13:22:55.217]             ...future.result["stdout"] <- base::list(NULL)
[13:22:55.217]         }
[13:22:55.217]         base::close(...future.stdout)
[13:22:55.217]         ...future.stdout <- NULL
[13:22:55.217]     }
[13:22:55.217]     ...future.result$conditions <- ...future.conditions
[13:22:55.217]     ...future.result$finished <- base::Sys.time()
[13:22:55.217]     ...future.result
[13:22:55.217] }
[13:22:55.219] assign_globals() ...
[13:22:55.219] List of 1
[13:22:55.219]  $ a: num 10
[13:22:55.219]  - attr(*, "where")=List of 1
[13:22:55.219]   ..$ a:<environment: R_EmptyEnv> 
[13:22:55.219]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:22:55.219]  - attr(*, "resolved")= logi FALSE
[13:22:55.219]  - attr(*, "total_size")= num 56
[13:22:55.219]  - attr(*, "already-done")= logi TRUE
[13:22:55.221] - copied ‘a’ to environment
[13:22:55.221] assign_globals() ... done
[13:22:55.222] plan(): Setting new future strategy stack:
[13:22:55.222] List of future strategies:
[13:22:55.222] 1. sequential:
[13:22:55.222]    - args: function (..., envir = parent.frame())
[13:22:55.222]    - tweaked: FALSE
[13:22:55.222]    - call: NULL
[13:22:55.222] plan(): nbrOfWorkers() = 1
[13:22:55.223] plan(): Setting new future strategy stack:
[13:22:55.223] List of future strategies:
[13:22:55.223] 1. sequential:
[13:22:55.223]    - args: function (..., envir = parent.frame())
[13:22:55.223]    - tweaked: FALSE
[13:22:55.223]    - call: plan(strategy)
[13:22:55.223] plan(): nbrOfWorkers() = 1
[13:22:55.224] SequentialFuture started (and completed)
[13:22:55.224] - Launch lazy future ... done
[13:22:55.224] run() for ‘SequentialFuture’ ... done
b = 11
*** %<-% with ‘sequential’ futures ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
*** %<-% with ‘multicore’ futures ...
[13:22:55.229] plan(): Setting new future strategy stack:
[13:22:55.229] List of future strategies:
[13:22:55.229] 1. multicore:
[13:22:55.229]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:22:55.229]    - tweaked: FALSE
[13:22:55.229]    - call: plan(strategy)
[13:22:55.233] plan(): nbrOfWorkers() = 2
** Future evaluation without globals
[13:22:55.234] getGlobalsAndPackages() ...
[13:22:55.234] Searching for globals...
[13:22:55.237] - globals found: [2] ‘{’, ‘<-’
[13:22:55.237] Searching for globals ... DONE
[13:22:55.237] Resolving globals: FALSE
[13:22:55.237] 
[13:22:55.237] 
[13:22:55.238] getGlobalsAndPackages() ... DONE
[13:22:55.238] run() for ‘Future’ ...
[13:22:55.238] - state: ‘created’
[13:22:55.238] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:22:55.242] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:55.242] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:22:55.242]   - Field: ‘label’
[13:22:55.242]   - Field: ‘local’
[13:22:55.242]   - Field: ‘owner’
[13:22:55.242]   - Field: ‘envir’
[13:22:55.242]   - Field: ‘workers’
[13:22:55.243]   - Field: ‘packages’
[13:22:55.243]   - Field: ‘gc’
[13:22:55.243]   - Field: ‘job’
[13:22:55.243]   - Field: ‘conditions’
[13:22:55.243]   - Field: ‘expr’
[13:22:55.243]   - Field: ‘uuid’
[13:22:55.243]   - Field: ‘seed’
[13:22:55.243]   - Field: ‘version’
[13:22:55.243]   - Field: ‘result’
[13:22:55.243]   - Field: ‘asynchronous’
[13:22:55.243]   - Field: ‘calls’
[13:22:55.244]   - Field: ‘globals’
[13:22:55.244]   - Field: ‘stdout’
[13:22:55.244]   - Field: ‘earlySignal’
[13:22:55.244]   - Field: ‘lazy’
[13:22:55.244]   - Field: ‘state’
[13:22:55.244] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:22:55.244] - Launch lazy future ...
[13:22:55.245] Packages needed by the future expression (n = 0): <none>
[13:22:55.245] Packages needed by future strategies (n = 0): <none>
[13:22:55.246] {
[13:22:55.246]     {
[13:22:55.246]         {
[13:22:55.246]             ...future.startTime <- base::Sys.time()
[13:22:55.246]             {
[13:22:55.246]                 {
[13:22:55.246]                   {
[13:22:55.246]                     {
[13:22:55.246]                       base::local({
[13:22:55.246]                         has_future <- base::requireNamespace("future", 
[13:22:55.246]                           quietly = TRUE)
[13:22:55.246]                         if (has_future) {
[13:22:55.246]                           ns <- base::getNamespace("future")
[13:22:55.246]                           version <- ns[[".package"]][["version"]]
[13:22:55.246]                           if (is.null(version)) 
[13:22:55.246]                             version <- utils::packageVersion("future")
[13:22:55.246]                         }
[13:22:55.246]                         else {
[13:22:55.246]                           version <- NULL
[13:22:55.246]                         }
[13:22:55.246]                         if (!has_future || version < "1.8.0") {
[13:22:55.246]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:55.246]                             "", base::R.version$version.string), 
[13:22:55.246]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:55.246]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:55.246]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:55.246]                               "release", "version")], collapse = " "), 
[13:22:55.246]                             hostname = base::Sys.info()[["nodename"]])
[13:22:55.246]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:55.246]                             info)
[13:22:55.246]                           info <- base::paste(info, collapse = "; ")
[13:22:55.246]                           if (!has_future) {
[13:22:55.246]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:55.246]                               info)
[13:22:55.246]                           }
[13:22:55.246]                           else {
[13:22:55.246]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:55.246]                               info, version)
[13:22:55.246]                           }
[13:22:55.246]                           base::stop(msg)
[13:22:55.246]                         }
[13:22:55.246]                       })
[13:22:55.246]                     }
[13:22:55.246]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:55.246]                     base::options(mc.cores = 1L)
[13:22:55.246]                   }
[13:22:55.246]                   options(future.plan = NULL)
[13:22:55.246]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.246]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:55.246]                 }
[13:22:55.246]                 ...future.workdir <- getwd()
[13:22:55.246]             }
[13:22:55.246]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:55.246]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:55.246]         }
[13:22:55.246]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:55.246]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:55.246]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:55.246]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:55.246]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:55.246]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:55.246]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:55.246]             base::names(...future.oldOptions))
[13:22:55.246]     }
[13:22:55.246]     if (FALSE) {
[13:22:55.246]     }
[13:22:55.246]     else {
[13:22:55.246]         if (TRUE) {
[13:22:55.246]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:55.246]                 open = "w")
[13:22:55.246]         }
[13:22:55.246]         else {
[13:22:55.246]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:55.246]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:55.246]         }
[13:22:55.246]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:55.246]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:55.246]             base::sink(type = "output", split = FALSE)
[13:22:55.246]             base::close(...future.stdout)
[13:22:55.246]         }, add = TRUE)
[13:22:55.246]     }
[13:22:55.246]     ...future.frame <- base::sys.nframe()
[13:22:55.246]     ...future.conditions <- base::list()
[13:22:55.246]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:55.246]     if (FALSE) {
[13:22:55.246]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:55.246]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:55.246]     }
[13:22:55.246]     ...future.result <- base::tryCatch({
[13:22:55.246]         base::withCallingHandlers({
[13:22:55.246]             ...future.value <- base::withVisible(base::local({
[13:22:55.246]                 withCallingHandlers({
[13:22:55.246]                   {
[13:22:55.246]                     x <- 1
[13:22:55.246]                   }
[13:22:55.246]                 }, immediateCondition = function(cond) {
[13:22:55.246]                   save_rds <- function (object, pathname, ...) 
[13:22:55.246]                   {
[13:22:55.246]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:22:55.246]                     if (file_test("-f", pathname_tmp)) {
[13:22:55.246]                       fi_tmp <- file.info(pathname_tmp)
[13:22:55.246]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:22:55.246]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:55.246]                         fi_tmp[["mtime"]])
[13:22:55.246]                     }
[13:22:55.246]                     tryCatch({
[13:22:55.246]                       saveRDS(object, file = pathname_tmp, ...)
[13:22:55.246]                     }, error = function(ex) {
[13:22:55.246]                       msg <- conditionMessage(ex)
[13:22:55.246]                       fi_tmp <- file.info(pathname_tmp)
[13:22:55.246]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:22:55.246]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:55.246]                         fi_tmp[["mtime"]], msg)
[13:22:55.246]                       ex$message <- msg
[13:22:55.246]                       stop(ex)
[13:22:55.246]                     })
[13:22:55.246]                     stopifnot(file_test("-f", pathname_tmp))
[13:22:55.246]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:22:55.246]                     if (!res || file_test("-f", pathname_tmp)) {
[13:22:55.246]                       fi_tmp <- file.info(pathname_tmp)
[13:22:55.246]                       fi <- file.info(pathname)
[13:22:55.246]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:22:55.246]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:55.246]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:22:55.246]                         fi[["size"]], fi[["mtime"]])
[13:22:55.246]                       stop(msg)
[13:22:55.246]                     }
[13:22:55.246]                     invisible(pathname)
[13:22:55.246]                   }
[13:22:55.246]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:22:55.246]                     rootPath = tempdir()) 
[13:22:55.246]                   {
[13:22:55.246]                     obj <- list(time = Sys.time(), condition = cond)
[13:22:55.246]                     file <- tempfile(pattern = class(cond)[1], 
[13:22:55.246]                       tmpdir = path, fileext = ".rds")
[13:22:55.246]                     save_rds(obj, file)
[13:22:55.246]                   }
[13:22:55.246]                   saveImmediateCondition(cond, path = "/tmp/RtmphhERam/.future/immediateConditions")
[13:22:55.246]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.246]                   {
[13:22:55.246]                     inherits <- base::inherits
[13:22:55.246]                     invokeRestart <- base::invokeRestart
[13:22:55.246]                     is.null <- base::is.null
[13:22:55.246]                     muffled <- FALSE
[13:22:55.246]                     if (inherits(cond, "message")) {
[13:22:55.246]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:55.246]                       if (muffled) 
[13:22:55.246]                         invokeRestart("muffleMessage")
[13:22:55.246]                     }
[13:22:55.246]                     else if (inherits(cond, "warning")) {
[13:22:55.246]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:55.246]                       if (muffled) 
[13:22:55.246]                         invokeRestart("muffleWarning")
[13:22:55.246]                     }
[13:22:55.246]                     else if (inherits(cond, "condition")) {
[13:22:55.246]                       if (!is.null(pattern)) {
[13:22:55.246]                         computeRestarts <- base::computeRestarts
[13:22:55.246]                         grepl <- base::grepl
[13:22:55.246]                         restarts <- computeRestarts(cond)
[13:22:55.246]                         for (restart in restarts) {
[13:22:55.246]                           name <- restart$name
[13:22:55.246]                           if (is.null(name)) 
[13:22:55.246]                             next
[13:22:55.246]                           if (!grepl(pattern, name)) 
[13:22:55.246]                             next
[13:22:55.246]                           invokeRestart(restart)
[13:22:55.246]                           muffled <- TRUE
[13:22:55.246]                           break
[13:22:55.246]                         }
[13:22:55.246]                       }
[13:22:55.246]                     }
[13:22:55.246]                     invisible(muffled)
[13:22:55.246]                   }
[13:22:55.246]                   muffleCondition(cond)
[13:22:55.246]                 })
[13:22:55.246]             }))
[13:22:55.246]             future::FutureResult(value = ...future.value$value, 
[13:22:55.246]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.246]                   ...future.rng), globalenv = if (FALSE) 
[13:22:55.246]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:55.246]                     ...future.globalenv.names))
[13:22:55.246]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:55.246]         }, condition = base::local({
[13:22:55.246]             c <- base::c
[13:22:55.246]             inherits <- base::inherits
[13:22:55.246]             invokeRestart <- base::invokeRestart
[13:22:55.246]             length <- base::length
[13:22:55.246]             list <- base::list
[13:22:55.246]             seq.int <- base::seq.int
[13:22:55.246]             signalCondition <- base::signalCondition
[13:22:55.246]             sys.calls <- base::sys.calls
[13:22:55.246]             `[[` <- base::`[[`
[13:22:55.246]             `+` <- base::`+`
[13:22:55.246]             `<<-` <- base::`<<-`
[13:22:55.246]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:55.246]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:55.246]                   3L)]
[13:22:55.246]             }
[13:22:55.246]             function(cond) {
[13:22:55.246]                 is_error <- inherits(cond, "error")
[13:22:55.246]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:55.246]                   NULL)
[13:22:55.246]                 if (is_error) {
[13:22:55.246]                   sessionInformation <- function() {
[13:22:55.246]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:55.246]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:55.246]                       search = base::search(), system = base::Sys.info())
[13:22:55.246]                   }
[13:22:55.246]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.246]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:55.246]                     cond$call), session = sessionInformation(), 
[13:22:55.246]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:55.246]                   signalCondition(cond)
[13:22:55.246]                 }
[13:22:55.246]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:55.246]                 "immediateCondition"))) {
[13:22:55.246]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:55.246]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.246]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:55.246]                   if (TRUE && !signal) {
[13:22:55.246]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.246]                     {
[13:22:55.246]                       inherits <- base::inherits
[13:22:55.246]                       invokeRestart <- base::invokeRestart
[13:22:55.246]                       is.null <- base::is.null
[13:22:55.246]                       muffled <- FALSE
[13:22:55.246]                       if (inherits(cond, "message")) {
[13:22:55.246]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.246]                         if (muffled) 
[13:22:55.246]                           invokeRestart("muffleMessage")
[13:22:55.246]                       }
[13:22:55.246]                       else if (inherits(cond, "warning")) {
[13:22:55.246]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.246]                         if (muffled) 
[13:22:55.246]                           invokeRestart("muffleWarning")
[13:22:55.246]                       }
[13:22:55.246]                       else if (inherits(cond, "condition")) {
[13:22:55.246]                         if (!is.null(pattern)) {
[13:22:55.246]                           computeRestarts <- base::computeRestarts
[13:22:55.246]                           grepl <- base::grepl
[13:22:55.246]                           restarts <- computeRestarts(cond)
[13:22:55.246]                           for (restart in restarts) {
[13:22:55.246]                             name <- restart$name
[13:22:55.246]                             if (is.null(name)) 
[13:22:55.246]                               next
[13:22:55.246]                             if (!grepl(pattern, name)) 
[13:22:55.246]                               next
[13:22:55.246]                             invokeRestart(restart)
[13:22:55.246]                             muffled <- TRUE
[13:22:55.246]                             break
[13:22:55.246]                           }
[13:22:55.246]                         }
[13:22:55.246]                       }
[13:22:55.246]                       invisible(muffled)
[13:22:55.246]                     }
[13:22:55.246]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.246]                   }
[13:22:55.246]                 }
[13:22:55.246]                 else {
[13:22:55.246]                   if (TRUE) {
[13:22:55.246]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.246]                     {
[13:22:55.246]                       inherits <- base::inherits
[13:22:55.246]                       invokeRestart <- base::invokeRestart
[13:22:55.246]                       is.null <- base::is.null
[13:22:55.246]                       muffled <- FALSE
[13:22:55.246]                       if (inherits(cond, "message")) {
[13:22:55.246]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.246]                         if (muffled) 
[13:22:55.246]                           invokeRestart("muffleMessage")
[13:22:55.246]                       }
[13:22:55.246]                       else if (inherits(cond, "warning")) {
[13:22:55.246]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.246]                         if (muffled) 
[13:22:55.246]                           invokeRestart("muffleWarning")
[13:22:55.246]                       }
[13:22:55.246]                       else if (inherits(cond, "condition")) {
[13:22:55.246]                         if (!is.null(pattern)) {
[13:22:55.246]                           computeRestarts <- base::computeRestarts
[13:22:55.246]                           grepl <- base::grepl
[13:22:55.246]                           restarts <- computeRestarts(cond)
[13:22:55.246]                           for (restart in restarts) {
[13:22:55.246]                             name <- restart$name
[13:22:55.246]                             if (is.null(name)) 
[13:22:55.246]                               next
[13:22:55.246]                             if (!grepl(pattern, name)) 
[13:22:55.246]                               next
[13:22:55.246]                             invokeRestart(restart)
[13:22:55.246]                             muffled <- TRUE
[13:22:55.246]                             break
[13:22:55.246]                           }
[13:22:55.246]                         }
[13:22:55.246]                       }
[13:22:55.246]                       invisible(muffled)
[13:22:55.246]                     }
[13:22:55.246]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.246]                   }
[13:22:55.246]                 }
[13:22:55.246]             }
[13:22:55.246]         }))
[13:22:55.246]     }, error = function(ex) {
[13:22:55.246]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:55.246]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.246]                 ...future.rng), started = ...future.startTime, 
[13:22:55.246]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:55.246]             version = "1.8"), class = "FutureResult")
[13:22:55.246]     }, finally = {
[13:22:55.246]         if (!identical(...future.workdir, getwd())) 
[13:22:55.246]             setwd(...future.workdir)
[13:22:55.246]         {
[13:22:55.246]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:55.246]                 ...future.oldOptions$nwarnings <- NULL
[13:22:55.246]             }
[13:22:55.246]             base::options(...future.oldOptions)
[13:22:55.246]             if (.Platform$OS.type == "windows") {
[13:22:55.246]                 old_names <- names(...future.oldEnvVars)
[13:22:55.246]                 envs <- base::Sys.getenv()
[13:22:55.246]                 names <- names(envs)
[13:22:55.246]                 common <- intersect(names, old_names)
[13:22:55.246]                 added <- setdiff(names, old_names)
[13:22:55.246]                 removed <- setdiff(old_names, names)
[13:22:55.246]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:55.246]                   envs[common]]
[13:22:55.246]                 NAMES <- toupper(changed)
[13:22:55.246]                 args <- list()
[13:22:55.246]                 for (kk in seq_along(NAMES)) {
[13:22:55.246]                   name <- changed[[kk]]
[13:22:55.246]                   NAME <- NAMES[[kk]]
[13:22:55.246]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.246]                     next
[13:22:55.246]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.246]                 }
[13:22:55.246]                 NAMES <- toupper(added)
[13:22:55.246]                 for (kk in seq_along(NAMES)) {
[13:22:55.246]                   name <- added[[kk]]
[13:22:55.246]                   NAME <- NAMES[[kk]]
[13:22:55.246]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.246]                     next
[13:22:55.246]                   args[[name]] <- ""
[13:22:55.246]                 }
[13:22:55.246]                 NAMES <- toupper(removed)
[13:22:55.246]                 for (kk in seq_along(NAMES)) {
[13:22:55.246]                   name <- removed[[kk]]
[13:22:55.246]                   NAME <- NAMES[[kk]]
[13:22:55.246]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.246]                     next
[13:22:55.246]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.246]                 }
[13:22:55.246]                 if (length(args) > 0) 
[13:22:55.246]                   base::do.call(base::Sys.setenv, args = args)
[13:22:55.246]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:55.246]             }
[13:22:55.246]             else {
[13:22:55.246]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:55.246]             }
[13:22:55.246]             {
[13:22:55.246]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:55.246]                   0L) {
[13:22:55.246]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:55.246]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:55.246]                   base::options(opts)
[13:22:55.246]                 }
[13:22:55.246]                 {
[13:22:55.246]                   {
[13:22:55.246]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:55.246]                     NULL
[13:22:55.246]                   }
[13:22:55.246]                   options(future.plan = NULL)
[13:22:55.246]                   if (is.na(NA_character_)) 
[13:22:55.246]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.246]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:55.246]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:22:55.246]                     envir = parent.frame()) 
[13:22:55.246]                   {
[13:22:55.246]                     default_workers <- missing(workers)
[13:22:55.246]                     if (is.function(workers)) 
[13:22:55.246]                       workers <- workers()
[13:22:55.246]                     workers <- structure(as.integer(workers), 
[13:22:55.246]                       class = class(workers))
[13:22:55.246]                     stop_if_not(is.finite(workers), workers >= 
[13:22:55.246]                       1L)
[13:22:55.246]                     if ((workers == 1L && !inherits(workers, 
[13:22:55.246]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:22:55.246]                       if (default_workers) 
[13:22:55.246]                         supportsMulticore(warn = TRUE)
[13:22:55.246]                       return(sequential(..., envir = envir))
[13:22:55.246]                     }
[13:22:55.246]                     oopts <- options(mc.cores = workers)
[13:22:55.246]                     on.exit(options(oopts))
[13:22:55.246]                     future <- MulticoreFuture(..., workers = workers, 
[13:22:55.246]                       envir = envir)
[13:22:55.246]                     if (!future$lazy) 
[13:22:55.246]                       future <- run(future)
[13:22:55.246]                     invisible(future)
[13:22:55.246]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:55.246]                 }
[13:22:55.246]             }
[13:22:55.246]         }
[13:22:55.246]     })
[13:22:55.246]     if (TRUE) {
[13:22:55.246]         base::sink(type = "output", split = FALSE)
[13:22:55.246]         if (TRUE) {
[13:22:55.246]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:55.246]         }
[13:22:55.246]         else {
[13:22:55.246]             ...future.result["stdout"] <- base::list(NULL)
[13:22:55.246]         }
[13:22:55.246]         base::close(...future.stdout)
[13:22:55.246]         ...future.stdout <- NULL
[13:22:55.246]     }
[13:22:55.246]     ...future.result$conditions <- ...future.conditions
[13:22:55.246]     ...future.result$finished <- base::Sys.time()
[13:22:55.246]     ...future.result
[13:22:55.246] }
[13:22:55.248] requestCore(): workers = 2
[13:22:55.251] MulticoreFuture started
[13:22:55.252] - Launch lazy future ... done
[13:22:55.252] plan(): Setting new future strategy stack:
[13:22:55.252] run() for ‘MulticoreFuture’ ... done
[13:22:55.252] List of future strategies:
[13:22:55.252] 1. sequential:
[13:22:55.252]    - args: function (..., envir = parent.frame())
[13:22:55.252]    - tweaked: FALSE
[13:22:55.252]    - call: NULL
[13:22:55.253] plan(): nbrOfWorkers() = 1
[13:22:55.253] result() for MulticoreFuture ...
[13:22:55.255] plan(): Setting new future strategy stack:
[13:22:55.255] List of future strategies:
[13:22:55.255] 1. multicore:
[13:22:55.255]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:22:55.255]    - tweaked: FALSE
[13:22:55.255]    - call: plan(strategy)
[13:22:55.261] plan(): nbrOfWorkers() = 2
[13:22:55.265] result() for MulticoreFuture ...
[13:22:55.266] result() for MulticoreFuture ... done
[13:22:55.266] result() for MulticoreFuture ... done
[13:22:55.266] result() for MulticoreFuture ...
[13:22:55.266] result() for MulticoreFuture ... done
** Future evaluation with globals
[13:22:55.267] getGlobalsAndPackages() ...
[13:22:55.267] Searching for globals...
[13:22:55.268] - globals found: [3] ‘{’, ‘<-’, ‘a’
[13:22:55.268] Searching for globals ... DONE
[13:22:55.268] Resolving globals: FALSE
[13:22:55.269] The total size of the 1 globals is 56 bytes (56 bytes)
[13:22:55.269] The total size of the 1 globals exported for future expression (‘{; x <- a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:22:55.269] - globals: [1] ‘a’
[13:22:55.270] 
[13:22:55.270] getGlobalsAndPackages() ... DONE
[13:22:55.270] run() for ‘Future’ ...
[13:22:55.270] - state: ‘created’
[13:22:55.270] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:22:55.275] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:55.275] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:22:55.275]   - Field: ‘label’
[13:22:55.275]   - Field: ‘local’
[13:22:55.275]   - Field: ‘owner’
[13:22:55.275]   - Field: ‘envir’
[13:22:55.275]   - Field: ‘workers’
[13:22:55.275]   - Field: ‘packages’
[13:22:55.276]   - Field: ‘gc’
[13:22:55.276]   - Field: ‘job’
[13:22:55.276]   - Field: ‘conditions’
[13:22:55.276]   - Field: ‘expr’
[13:22:55.276]   - Field: ‘uuid’
[13:22:55.276]   - Field: ‘seed’
[13:22:55.276]   - Field: ‘version’
[13:22:55.276]   - Field: ‘result’
[13:22:55.276]   - Field: ‘asynchronous’
[13:22:55.277]   - Field: ‘calls’
[13:22:55.277]   - Field: ‘globals’
[13:22:55.277]   - Field: ‘stdout’
[13:22:55.277]   - Field: ‘earlySignal’
[13:22:55.277]   - Field: ‘lazy’
[13:22:55.277]   - Field: ‘state’
[13:22:55.277] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:22:55.277] - Launch lazy future ...
[13:22:55.278] Packages needed by the future expression (n = 0): <none>
[13:22:55.278] Packages needed by future strategies (n = 0): <none>
[13:22:55.278] {
[13:22:55.278]     {
[13:22:55.278]         {
[13:22:55.278]             ...future.startTime <- base::Sys.time()
[13:22:55.278]             {
[13:22:55.278]                 {
[13:22:55.278]                   {
[13:22:55.278]                     {
[13:22:55.278]                       base::local({
[13:22:55.278]                         has_future <- base::requireNamespace("future", 
[13:22:55.278]                           quietly = TRUE)
[13:22:55.278]                         if (has_future) {
[13:22:55.278]                           ns <- base::getNamespace("future")
[13:22:55.278]                           version <- ns[[".package"]][["version"]]
[13:22:55.278]                           if (is.null(version)) 
[13:22:55.278]                             version <- utils::packageVersion("future")
[13:22:55.278]                         }
[13:22:55.278]                         else {
[13:22:55.278]                           version <- NULL
[13:22:55.278]                         }
[13:22:55.278]                         if (!has_future || version < "1.8.0") {
[13:22:55.278]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:55.278]                             "", base::R.version$version.string), 
[13:22:55.278]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:55.278]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:55.278]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:55.278]                               "release", "version")], collapse = " "), 
[13:22:55.278]                             hostname = base::Sys.info()[["nodename"]])
[13:22:55.278]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:55.278]                             info)
[13:22:55.278]                           info <- base::paste(info, collapse = "; ")
[13:22:55.278]                           if (!has_future) {
[13:22:55.278]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:55.278]                               info)
[13:22:55.278]                           }
[13:22:55.278]                           else {
[13:22:55.278]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:55.278]                               info, version)
[13:22:55.278]                           }
[13:22:55.278]                           base::stop(msg)
[13:22:55.278]                         }
[13:22:55.278]                       })
[13:22:55.278]                     }
[13:22:55.278]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:55.278]                     base::options(mc.cores = 1L)
[13:22:55.278]                   }
[13:22:55.278]                   options(future.plan = NULL)
[13:22:55.278]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.278]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:55.278]                 }
[13:22:55.278]                 ...future.workdir <- getwd()
[13:22:55.278]             }
[13:22:55.278]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:55.278]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:55.278]         }
[13:22:55.278]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:55.278]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:55.278]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:55.278]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:55.278]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:55.278]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:55.278]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:55.278]             base::names(...future.oldOptions))
[13:22:55.278]     }
[13:22:55.278]     if (FALSE) {
[13:22:55.278]     }
[13:22:55.278]     else {
[13:22:55.278]         if (TRUE) {
[13:22:55.278]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:55.278]                 open = "w")
[13:22:55.278]         }
[13:22:55.278]         else {
[13:22:55.278]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:55.278]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:55.278]         }
[13:22:55.278]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:55.278]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:55.278]             base::sink(type = "output", split = FALSE)
[13:22:55.278]             base::close(...future.stdout)
[13:22:55.278]         }, add = TRUE)
[13:22:55.278]     }
[13:22:55.278]     ...future.frame <- base::sys.nframe()
[13:22:55.278]     ...future.conditions <- base::list()
[13:22:55.278]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:55.278]     if (FALSE) {
[13:22:55.278]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:55.278]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:55.278]     }
[13:22:55.278]     ...future.result <- base::tryCatch({
[13:22:55.278]         base::withCallingHandlers({
[13:22:55.278]             ...future.value <- base::withVisible(base::local({
[13:22:55.278]                 withCallingHandlers({
[13:22:55.278]                   {
[13:22:55.278]                     x <- a
[13:22:55.278]                   }
[13:22:55.278]                 }, immediateCondition = function(cond) {
[13:22:55.278]                   save_rds <- function (object, pathname, ...) 
[13:22:55.278]                   {
[13:22:55.278]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:22:55.278]                     if (file_test("-f", pathname_tmp)) {
[13:22:55.278]                       fi_tmp <- file.info(pathname_tmp)
[13:22:55.278]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:22:55.278]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:55.278]                         fi_tmp[["mtime"]])
[13:22:55.278]                     }
[13:22:55.278]                     tryCatch({
[13:22:55.278]                       saveRDS(object, file = pathname_tmp, ...)
[13:22:55.278]                     }, error = function(ex) {
[13:22:55.278]                       msg <- conditionMessage(ex)
[13:22:55.278]                       fi_tmp <- file.info(pathname_tmp)
[13:22:55.278]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:22:55.278]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:55.278]                         fi_tmp[["mtime"]], msg)
[13:22:55.278]                       ex$message <- msg
[13:22:55.278]                       stop(ex)
[13:22:55.278]                     })
[13:22:55.278]                     stopifnot(file_test("-f", pathname_tmp))
[13:22:55.278]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:22:55.278]                     if (!res || file_test("-f", pathname_tmp)) {
[13:22:55.278]                       fi_tmp <- file.info(pathname_tmp)
[13:22:55.278]                       fi <- file.info(pathname)
[13:22:55.278]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:22:55.278]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:55.278]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:22:55.278]                         fi[["size"]], fi[["mtime"]])
[13:22:55.278]                       stop(msg)
[13:22:55.278]                     }
[13:22:55.278]                     invisible(pathname)
[13:22:55.278]                   }
[13:22:55.278]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:22:55.278]                     rootPath = tempdir()) 
[13:22:55.278]                   {
[13:22:55.278]                     obj <- list(time = Sys.time(), condition = cond)
[13:22:55.278]                     file <- tempfile(pattern = class(cond)[1], 
[13:22:55.278]                       tmpdir = path, fileext = ".rds")
[13:22:55.278]                     save_rds(obj, file)
[13:22:55.278]                   }
[13:22:55.278]                   saveImmediateCondition(cond, path = "/tmp/RtmphhERam/.future/immediateConditions")
[13:22:55.278]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.278]                   {
[13:22:55.278]                     inherits <- base::inherits
[13:22:55.278]                     invokeRestart <- base::invokeRestart
[13:22:55.278]                     is.null <- base::is.null
[13:22:55.278]                     muffled <- FALSE
[13:22:55.278]                     if (inherits(cond, "message")) {
[13:22:55.278]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:55.278]                       if (muffled) 
[13:22:55.278]                         invokeRestart("muffleMessage")
[13:22:55.278]                     }
[13:22:55.278]                     else if (inherits(cond, "warning")) {
[13:22:55.278]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:55.278]                       if (muffled) 
[13:22:55.278]                         invokeRestart("muffleWarning")
[13:22:55.278]                     }
[13:22:55.278]                     else if (inherits(cond, "condition")) {
[13:22:55.278]                       if (!is.null(pattern)) {
[13:22:55.278]                         computeRestarts <- base::computeRestarts
[13:22:55.278]                         grepl <- base::grepl
[13:22:55.278]                         restarts <- computeRestarts(cond)
[13:22:55.278]                         for (restart in restarts) {
[13:22:55.278]                           name <- restart$name
[13:22:55.278]                           if (is.null(name)) 
[13:22:55.278]                             next
[13:22:55.278]                           if (!grepl(pattern, name)) 
[13:22:55.278]                             next
[13:22:55.278]                           invokeRestart(restart)
[13:22:55.278]                           muffled <- TRUE
[13:22:55.278]                           break
[13:22:55.278]                         }
[13:22:55.278]                       }
[13:22:55.278]                     }
[13:22:55.278]                     invisible(muffled)
[13:22:55.278]                   }
[13:22:55.278]                   muffleCondition(cond)
[13:22:55.278]                 })
[13:22:55.278]             }))
[13:22:55.278]             future::FutureResult(value = ...future.value$value, 
[13:22:55.278]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.278]                   ...future.rng), globalenv = if (FALSE) 
[13:22:55.278]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:55.278]                     ...future.globalenv.names))
[13:22:55.278]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:55.278]         }, condition = base::local({
[13:22:55.278]             c <- base::c
[13:22:55.278]             inherits <- base::inherits
[13:22:55.278]             invokeRestart <- base::invokeRestart
[13:22:55.278]             length <- base::length
[13:22:55.278]             list <- base::list
[13:22:55.278]             seq.int <- base::seq.int
[13:22:55.278]             signalCondition <- base::signalCondition
[13:22:55.278]             sys.calls <- base::sys.calls
[13:22:55.278]             `[[` <- base::`[[`
[13:22:55.278]             `+` <- base::`+`
[13:22:55.278]             `<<-` <- base::`<<-`
[13:22:55.278]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:55.278]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:55.278]                   3L)]
[13:22:55.278]             }
[13:22:55.278]             function(cond) {
[13:22:55.278]                 is_error <- inherits(cond, "error")
[13:22:55.278]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:55.278]                   NULL)
[13:22:55.278]                 if (is_error) {
[13:22:55.278]                   sessionInformation <- function() {
[13:22:55.278]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:55.278]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:55.278]                       search = base::search(), system = base::Sys.info())
[13:22:55.278]                   }
[13:22:55.278]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.278]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:55.278]                     cond$call), session = sessionInformation(), 
[13:22:55.278]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:55.278]                   signalCondition(cond)
[13:22:55.278]                 }
[13:22:55.278]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:55.278]                 "immediateCondition"))) {
[13:22:55.278]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:55.278]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.278]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:55.278]                   if (TRUE && !signal) {
[13:22:55.278]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.278]                     {
[13:22:55.278]                       inherits <- base::inherits
[13:22:55.278]                       invokeRestart <- base::invokeRestart
[13:22:55.278]                       is.null <- base::is.null
[13:22:55.278]                       muffled <- FALSE
[13:22:55.278]                       if (inherits(cond, "message")) {
[13:22:55.278]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.278]                         if (muffled) 
[13:22:55.278]                           invokeRestart("muffleMessage")
[13:22:55.278]                       }
[13:22:55.278]                       else if (inherits(cond, "warning")) {
[13:22:55.278]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.278]                         if (muffled) 
[13:22:55.278]                           invokeRestart("muffleWarning")
[13:22:55.278]                       }
[13:22:55.278]                       else if (inherits(cond, "condition")) {
[13:22:55.278]                         if (!is.null(pattern)) {
[13:22:55.278]                           computeRestarts <- base::computeRestarts
[13:22:55.278]                           grepl <- base::grepl
[13:22:55.278]                           restarts <- computeRestarts(cond)
[13:22:55.278]                           for (restart in restarts) {
[13:22:55.278]                             name <- restart$name
[13:22:55.278]                             if (is.null(name)) 
[13:22:55.278]                               next
[13:22:55.278]                             if (!grepl(pattern, name)) 
[13:22:55.278]                               next
[13:22:55.278]                             invokeRestart(restart)
[13:22:55.278]                             muffled <- TRUE
[13:22:55.278]                             break
[13:22:55.278]                           }
[13:22:55.278]                         }
[13:22:55.278]                       }
[13:22:55.278]                       invisible(muffled)
[13:22:55.278]                     }
[13:22:55.278]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.278]                   }
[13:22:55.278]                 }
[13:22:55.278]                 else {
[13:22:55.278]                   if (TRUE) {
[13:22:55.278]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.278]                     {
[13:22:55.278]                       inherits <- base::inherits
[13:22:55.278]                       invokeRestart <- base::invokeRestart
[13:22:55.278]                       is.null <- base::is.null
[13:22:55.278]                       muffled <- FALSE
[13:22:55.278]                       if (inherits(cond, "message")) {
[13:22:55.278]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.278]                         if (muffled) 
[13:22:55.278]                           invokeRestart("muffleMessage")
[13:22:55.278]                       }
[13:22:55.278]                       else if (inherits(cond, "warning")) {
[13:22:55.278]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.278]                         if (muffled) 
[13:22:55.278]                           invokeRestart("muffleWarning")
[13:22:55.278]                       }
[13:22:55.278]                       else if (inherits(cond, "condition")) {
[13:22:55.278]                         if (!is.null(pattern)) {
[13:22:55.278]                           computeRestarts <- base::computeRestarts
[13:22:55.278]                           grepl <- base::grepl
[13:22:55.278]                           restarts <- computeRestarts(cond)
[13:22:55.278]                           for (restart in restarts) {
[13:22:55.278]                             name <- restart$name
[13:22:55.278]                             if (is.null(name)) 
[13:22:55.278]                               next
[13:22:55.278]                             if (!grepl(pattern, name)) 
[13:22:55.278]                               next
[13:22:55.278]                             invokeRestart(restart)
[13:22:55.278]                             muffled <- TRUE
[13:22:55.278]                             break
[13:22:55.278]                           }
[13:22:55.278]                         }
[13:22:55.278]                       }
[13:22:55.278]                       invisible(muffled)
[13:22:55.278]                     }
[13:22:55.278]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.278]                   }
[13:22:55.278]                 }
[13:22:55.278]             }
[13:22:55.278]         }))
[13:22:55.278]     }, error = function(ex) {
[13:22:55.278]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:55.278]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.278]                 ...future.rng), started = ...future.startTime, 
[13:22:55.278]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:55.278]             version = "1.8"), class = "FutureResult")
[13:22:55.278]     }, finally = {
[13:22:55.278]         if (!identical(...future.workdir, getwd())) 
[13:22:55.278]             setwd(...future.workdir)
[13:22:55.278]         {
[13:22:55.278]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:55.278]                 ...future.oldOptions$nwarnings <- NULL
[13:22:55.278]             }
[13:22:55.278]             base::options(...future.oldOptions)
[13:22:55.278]             if (.Platform$OS.type == "windows") {
[13:22:55.278]                 old_names <- names(...future.oldEnvVars)
[13:22:55.278]                 envs <- base::Sys.getenv()
[13:22:55.278]                 names <- names(envs)
[13:22:55.278]                 common <- intersect(names, old_names)
[13:22:55.278]                 added <- setdiff(names, old_names)
[13:22:55.278]                 removed <- setdiff(old_names, names)
[13:22:55.278]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:55.278]                   envs[common]]
[13:22:55.278]                 NAMES <- toupper(changed)
[13:22:55.278]                 args <- list()
[13:22:55.278]                 for (kk in seq_along(NAMES)) {
[13:22:55.278]                   name <- changed[[kk]]
[13:22:55.278]                   NAME <- NAMES[[kk]]
[13:22:55.278]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.278]                     next
[13:22:55.278]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.278]                 }
[13:22:55.278]                 NAMES <- toupper(added)
[13:22:55.278]                 for (kk in seq_along(NAMES)) {
[13:22:55.278]                   name <- added[[kk]]
[13:22:55.278]                   NAME <- NAMES[[kk]]
[13:22:55.278]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.278]                     next
[13:22:55.278]                   args[[name]] <- ""
[13:22:55.278]                 }
[13:22:55.278]                 NAMES <- toupper(removed)
[13:22:55.278]                 for (kk in seq_along(NAMES)) {
[13:22:55.278]                   name <- removed[[kk]]
[13:22:55.278]                   NAME <- NAMES[[kk]]
[13:22:55.278]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.278]                     next
[13:22:55.278]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.278]                 }
[13:22:55.278]                 if (length(args) > 0) 
[13:22:55.278]                   base::do.call(base::Sys.setenv, args = args)
[13:22:55.278]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:55.278]             }
[13:22:55.278]             else {
[13:22:55.278]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:55.278]             }
[13:22:55.278]             {
[13:22:55.278]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:55.278]                   0L) {
[13:22:55.278]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:55.278]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:55.278]                   base::options(opts)
[13:22:55.278]                 }
[13:22:55.278]                 {
[13:22:55.278]                   {
[13:22:55.278]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:55.278]                     NULL
[13:22:55.278]                   }
[13:22:55.278]                   options(future.plan = NULL)
[13:22:55.278]                   if (is.na(NA_character_)) 
[13:22:55.278]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.278]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:55.278]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:22:55.278]                     envir = parent.frame()) 
[13:22:55.278]                   {
[13:22:55.278]                     default_workers <- missing(workers)
[13:22:55.278]                     if (is.function(workers)) 
[13:22:55.278]                       workers <- workers()
[13:22:55.278]                     workers <- structure(as.integer(workers), 
[13:22:55.278]                       class = class(workers))
[13:22:55.278]                     stop_if_not(is.finite(workers), workers >= 
[13:22:55.278]                       1L)
[13:22:55.278]                     if ((workers == 1L && !inherits(workers, 
[13:22:55.278]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:22:55.278]                       if (default_workers) 
[13:22:55.278]                         supportsMulticore(warn = TRUE)
[13:22:55.278]                       return(sequential(..., envir = envir))
[13:22:55.278]                     }
[13:22:55.278]                     oopts <- options(mc.cores = workers)
[13:22:55.278]                     on.exit(options(oopts))
[13:22:55.278]                     future <- MulticoreFuture(..., workers = workers, 
[13:22:55.278]                       envir = envir)
[13:22:55.278]                     if (!future$lazy) 
[13:22:55.278]                       future <- run(future)
[13:22:55.278]                     invisible(future)
[13:22:55.278]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:55.278]                 }
[13:22:55.278]             }
[13:22:55.278]         }
[13:22:55.278]     })
[13:22:55.278]     if (TRUE) {
[13:22:55.278]         base::sink(type = "output", split = FALSE)
[13:22:55.278]         if (TRUE) {
[13:22:55.278]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:55.278]         }
[13:22:55.278]         else {
[13:22:55.278]             ...future.result["stdout"] <- base::list(NULL)
[13:22:55.278]         }
[13:22:55.278]         base::close(...future.stdout)
[13:22:55.278]         ...future.stdout <- NULL
[13:22:55.278]     }
[13:22:55.278]     ...future.result$conditions <- ...future.conditions
[13:22:55.278]     ...future.result$finished <- base::Sys.time()
[13:22:55.278]     ...future.result
[13:22:55.278] }
[13:22:55.281] assign_globals() ...
[13:22:55.281] List of 1
[13:22:55.281]  $ a: num 2
[13:22:55.281]  - attr(*, "where")=List of 1
[13:22:55.281]   ..$ a:<environment: R_EmptyEnv> 
[13:22:55.281]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:22:55.281]  - attr(*, "resolved")= logi FALSE
[13:22:55.281]  - attr(*, "total_size")= num 56
[13:22:55.281]  - attr(*, "already-done")= logi TRUE
[13:22:55.285] - copied ‘a’ to environment
[13:22:55.285] assign_globals() ... done
[13:22:55.285] requestCore(): workers = 2
[13:22:55.287] MulticoreFuture started
[13:22:55.287] - Launch lazy future ... done
[13:22:55.288] run() for ‘MulticoreFuture’ ... done
[13:22:55.288] result() for MulticoreFuture ...
[13:22:55.288] plan(): Setting new future strategy stack:
[13:22:55.289] List of future strategies:
[13:22:55.289] 1. sequential:
[13:22:55.289]    - args: function (..., envir = parent.frame())
[13:22:55.289]    - tweaked: FALSE
[13:22:55.289]    - call: NULL
[13:22:55.289] plan(): nbrOfWorkers() = 1
[13:22:55.298] plan(): Setting new future strategy stack:
[13:22:55.298] List of future strategies:
[13:22:55.298] 1. multicore:
[13:22:55.298]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:22:55.298]    - tweaked: FALSE
[13:22:55.298]    - call: plan(strategy)
[13:22:55.304] plan(): nbrOfWorkers() = 2
[13:22:55.308] result() for MulticoreFuture ...
[13:22:55.309] result() for MulticoreFuture ... done
[13:22:55.309] result() for MulticoreFuture ... done
[13:22:55.309] result() for MulticoreFuture ...
[13:22:55.309] result() for MulticoreFuture ... done
** Future evaluation with errors
[13:22:55.310] getGlobalsAndPackages() ...
[13:22:55.310] Searching for globals...
[13:22:55.312] - globals found: [3] ‘{’, ‘<-’, ‘stop’
[13:22:55.312] Searching for globals ... DONE
[13:22:55.313] Resolving globals: FALSE
[13:22:55.313] 
[13:22:55.313] 
[13:22:55.313] getGlobalsAndPackages() ... DONE
[13:22:55.314] run() for ‘Future’ ...
[13:22:55.314] - state: ‘created’
[13:22:55.314] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:22:55.318] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:55.318] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:22:55.319]   - Field: ‘label’
[13:22:55.319]   - Field: ‘local’
[13:22:55.319]   - Field: ‘owner’
[13:22:55.319]   - Field: ‘envir’
[13:22:55.319]   - Field: ‘workers’
[13:22:55.319]   - Field: ‘packages’
[13:22:55.319]   - Field: ‘gc’
[13:22:55.319]   - Field: ‘job’
[13:22:55.320]   - Field: ‘conditions’
[13:22:55.320]   - Field: ‘expr’
[13:22:55.320]   - Field: ‘uuid’
[13:22:55.320]   - Field: ‘seed’
[13:22:55.320]   - Field: ‘version’
[13:22:55.320]   - Field: ‘result’
[13:22:55.320]   - Field: ‘asynchronous’
[13:22:55.321]   - Field: ‘calls’
[13:22:55.321]   - Field: ‘globals’
[13:22:55.321]   - Field: ‘stdout’
[13:22:55.321]   - Field: ‘earlySignal’
[13:22:55.321]   - Field: ‘lazy’
[13:22:55.321]   - Field: ‘state’
[13:22:55.321] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:22:55.321] - Launch lazy future ...
[13:22:55.322] Packages needed by the future expression (n = 0): <none>
[13:22:55.322] Packages needed by future strategies (n = 0): <none>
[13:22:55.322] {
[13:22:55.322]     {
[13:22:55.322]         {
[13:22:55.322]             ...future.startTime <- base::Sys.time()
[13:22:55.322]             {
[13:22:55.322]                 {
[13:22:55.322]                   {
[13:22:55.322]                     {
[13:22:55.322]                       base::local({
[13:22:55.322]                         has_future <- base::requireNamespace("future", 
[13:22:55.322]                           quietly = TRUE)
[13:22:55.322]                         if (has_future) {
[13:22:55.322]                           ns <- base::getNamespace("future")
[13:22:55.322]                           version <- ns[[".package"]][["version"]]
[13:22:55.322]                           if (is.null(version)) 
[13:22:55.322]                             version <- utils::packageVersion("future")
[13:22:55.322]                         }
[13:22:55.322]                         else {
[13:22:55.322]                           version <- NULL
[13:22:55.322]                         }
[13:22:55.322]                         if (!has_future || version < "1.8.0") {
[13:22:55.322]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:55.322]                             "", base::R.version$version.string), 
[13:22:55.322]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:55.322]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:55.322]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:55.322]                               "release", "version")], collapse = " "), 
[13:22:55.322]                             hostname = base::Sys.info()[["nodename"]])
[13:22:55.322]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:55.322]                             info)
[13:22:55.322]                           info <- base::paste(info, collapse = "; ")
[13:22:55.322]                           if (!has_future) {
[13:22:55.322]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:55.322]                               info)
[13:22:55.322]                           }
[13:22:55.322]                           else {
[13:22:55.322]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:55.322]                               info, version)
[13:22:55.322]                           }
[13:22:55.322]                           base::stop(msg)
[13:22:55.322]                         }
[13:22:55.322]                       })
[13:22:55.322]                     }
[13:22:55.322]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:55.322]                     base::options(mc.cores = 1L)
[13:22:55.322]                   }
[13:22:55.322]                   options(future.plan = NULL)
[13:22:55.322]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.322]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:55.322]                 }
[13:22:55.322]                 ...future.workdir <- getwd()
[13:22:55.322]             }
[13:22:55.322]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:55.322]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:55.322]         }
[13:22:55.322]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:55.322]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:55.322]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:55.322]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:55.322]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:55.322]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:55.322]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:55.322]             base::names(...future.oldOptions))
[13:22:55.322]     }
[13:22:55.322]     if (FALSE) {
[13:22:55.322]     }
[13:22:55.322]     else {
[13:22:55.322]         if (TRUE) {
[13:22:55.322]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:55.322]                 open = "w")
[13:22:55.322]         }
[13:22:55.322]         else {
[13:22:55.322]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:55.322]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:55.322]         }
[13:22:55.322]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:55.322]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:55.322]             base::sink(type = "output", split = FALSE)
[13:22:55.322]             base::close(...future.stdout)
[13:22:55.322]         }, add = TRUE)
[13:22:55.322]     }
[13:22:55.322]     ...future.frame <- base::sys.nframe()
[13:22:55.322]     ...future.conditions <- base::list()
[13:22:55.322]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:55.322]     if (FALSE) {
[13:22:55.322]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:55.322]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:55.322]     }
[13:22:55.322]     ...future.result <- base::tryCatch({
[13:22:55.322]         base::withCallingHandlers({
[13:22:55.322]             ...future.value <- base::withVisible(base::local({
[13:22:55.322]                 withCallingHandlers({
[13:22:55.322]                   {
[13:22:55.322]                     x <- 3
[13:22:55.322]                     stop("Woops!")
[13:22:55.322]                     x
[13:22:55.322]                   }
[13:22:55.322]                 }, immediateCondition = function(cond) {
[13:22:55.322]                   save_rds <- function (object, pathname, ...) 
[13:22:55.322]                   {
[13:22:55.322]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:22:55.322]                     if (file_test("-f", pathname_tmp)) {
[13:22:55.322]                       fi_tmp <- file.info(pathname_tmp)
[13:22:55.322]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:22:55.322]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:55.322]                         fi_tmp[["mtime"]])
[13:22:55.322]                     }
[13:22:55.322]                     tryCatch({
[13:22:55.322]                       saveRDS(object, file = pathname_tmp, ...)
[13:22:55.322]                     }, error = function(ex) {
[13:22:55.322]                       msg <- conditionMessage(ex)
[13:22:55.322]                       fi_tmp <- file.info(pathname_tmp)
[13:22:55.322]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:22:55.322]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:55.322]                         fi_tmp[["mtime"]], msg)
[13:22:55.322]                       ex$message <- msg
[13:22:55.322]                       stop(ex)
[13:22:55.322]                     })
[13:22:55.322]                     stopifnot(file_test("-f", pathname_tmp))
[13:22:55.322]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:22:55.322]                     if (!res || file_test("-f", pathname_tmp)) {
[13:22:55.322]                       fi_tmp <- file.info(pathname_tmp)
[13:22:55.322]                       fi <- file.info(pathname)
[13:22:55.322]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:22:55.322]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:55.322]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:22:55.322]                         fi[["size"]], fi[["mtime"]])
[13:22:55.322]                       stop(msg)
[13:22:55.322]                     }
[13:22:55.322]                     invisible(pathname)
[13:22:55.322]                   }
[13:22:55.322]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:22:55.322]                     rootPath = tempdir()) 
[13:22:55.322]                   {
[13:22:55.322]                     obj <- list(time = Sys.time(), condition = cond)
[13:22:55.322]                     file <- tempfile(pattern = class(cond)[1], 
[13:22:55.322]                       tmpdir = path, fileext = ".rds")
[13:22:55.322]                     save_rds(obj, file)
[13:22:55.322]                   }
[13:22:55.322]                   saveImmediateCondition(cond, path = "/tmp/RtmphhERam/.future/immediateConditions")
[13:22:55.322]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.322]                   {
[13:22:55.322]                     inherits <- base::inherits
[13:22:55.322]                     invokeRestart <- base::invokeRestart
[13:22:55.322]                     is.null <- base::is.null
[13:22:55.322]                     muffled <- FALSE
[13:22:55.322]                     if (inherits(cond, "message")) {
[13:22:55.322]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:55.322]                       if (muffled) 
[13:22:55.322]                         invokeRestart("muffleMessage")
[13:22:55.322]                     }
[13:22:55.322]                     else if (inherits(cond, "warning")) {
[13:22:55.322]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:55.322]                       if (muffled) 
[13:22:55.322]                         invokeRestart("muffleWarning")
[13:22:55.322]                     }
[13:22:55.322]                     else if (inherits(cond, "condition")) {
[13:22:55.322]                       if (!is.null(pattern)) {
[13:22:55.322]                         computeRestarts <- base::computeRestarts
[13:22:55.322]                         grepl <- base::grepl
[13:22:55.322]                         restarts <- computeRestarts(cond)
[13:22:55.322]                         for (restart in restarts) {
[13:22:55.322]                           name <- restart$name
[13:22:55.322]                           if (is.null(name)) 
[13:22:55.322]                             next
[13:22:55.322]                           if (!grepl(pattern, name)) 
[13:22:55.322]                             next
[13:22:55.322]                           invokeRestart(restart)
[13:22:55.322]                           muffled <- TRUE
[13:22:55.322]                           break
[13:22:55.322]                         }
[13:22:55.322]                       }
[13:22:55.322]                     }
[13:22:55.322]                     invisible(muffled)
[13:22:55.322]                   }
[13:22:55.322]                   muffleCondition(cond)
[13:22:55.322]                 })
[13:22:55.322]             }))
[13:22:55.322]             future::FutureResult(value = ...future.value$value, 
[13:22:55.322]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.322]                   ...future.rng), globalenv = if (FALSE) 
[13:22:55.322]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:55.322]                     ...future.globalenv.names))
[13:22:55.322]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:55.322]         }, condition = base::local({
[13:22:55.322]             c <- base::c
[13:22:55.322]             inherits <- base::inherits
[13:22:55.322]             invokeRestart <- base::invokeRestart
[13:22:55.322]             length <- base::length
[13:22:55.322]             list <- base::list
[13:22:55.322]             seq.int <- base::seq.int
[13:22:55.322]             signalCondition <- base::signalCondition
[13:22:55.322]             sys.calls <- base::sys.calls
[13:22:55.322]             `[[` <- base::`[[`
[13:22:55.322]             `+` <- base::`+`
[13:22:55.322]             `<<-` <- base::`<<-`
[13:22:55.322]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:55.322]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:55.322]                   3L)]
[13:22:55.322]             }
[13:22:55.322]             function(cond) {
[13:22:55.322]                 is_error <- inherits(cond, "error")
[13:22:55.322]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:55.322]                   NULL)
[13:22:55.322]                 if (is_error) {
[13:22:55.322]                   sessionInformation <- function() {
[13:22:55.322]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:55.322]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:55.322]                       search = base::search(), system = base::Sys.info())
[13:22:55.322]                   }
[13:22:55.322]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.322]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:55.322]                     cond$call), session = sessionInformation(), 
[13:22:55.322]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:55.322]                   signalCondition(cond)
[13:22:55.322]                 }
[13:22:55.322]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:55.322]                 "immediateCondition"))) {
[13:22:55.322]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:55.322]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.322]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:55.322]                   if (TRUE && !signal) {
[13:22:55.322]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.322]                     {
[13:22:55.322]                       inherits <- base::inherits
[13:22:55.322]                       invokeRestart <- base::invokeRestart
[13:22:55.322]                       is.null <- base::is.null
[13:22:55.322]                       muffled <- FALSE
[13:22:55.322]                       if (inherits(cond, "message")) {
[13:22:55.322]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.322]                         if (muffled) 
[13:22:55.322]                           invokeRestart("muffleMessage")
[13:22:55.322]                       }
[13:22:55.322]                       else if (inherits(cond, "warning")) {
[13:22:55.322]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.322]                         if (muffled) 
[13:22:55.322]                           invokeRestart("muffleWarning")
[13:22:55.322]                       }
[13:22:55.322]                       else if (inherits(cond, "condition")) {
[13:22:55.322]                         if (!is.null(pattern)) {
[13:22:55.322]                           computeRestarts <- base::computeRestarts
[13:22:55.322]                           grepl <- base::grepl
[13:22:55.322]                           restarts <- computeRestarts(cond)
[13:22:55.322]                           for (restart in restarts) {
[13:22:55.322]                             name <- restart$name
[13:22:55.322]                             if (is.null(name)) 
[13:22:55.322]                               next
[13:22:55.322]                             if (!grepl(pattern, name)) 
[13:22:55.322]                               next
[13:22:55.322]                             invokeRestart(restart)
[13:22:55.322]                             muffled <- TRUE
[13:22:55.322]                             break
[13:22:55.322]                           }
[13:22:55.322]                         }
[13:22:55.322]                       }
[13:22:55.322]                       invisible(muffled)
[13:22:55.322]                     }
[13:22:55.322]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.322]                   }
[13:22:55.322]                 }
[13:22:55.322]                 else {
[13:22:55.322]                   if (TRUE) {
[13:22:55.322]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.322]                     {
[13:22:55.322]                       inherits <- base::inherits
[13:22:55.322]                       invokeRestart <- base::invokeRestart
[13:22:55.322]                       is.null <- base::is.null
[13:22:55.322]                       muffled <- FALSE
[13:22:55.322]                       if (inherits(cond, "message")) {
[13:22:55.322]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.322]                         if (muffled) 
[13:22:55.322]                           invokeRestart("muffleMessage")
[13:22:55.322]                       }
[13:22:55.322]                       else if (inherits(cond, "warning")) {
[13:22:55.322]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.322]                         if (muffled) 
[13:22:55.322]                           invokeRestart("muffleWarning")
[13:22:55.322]                       }
[13:22:55.322]                       else if (inherits(cond, "condition")) {
[13:22:55.322]                         if (!is.null(pattern)) {
[13:22:55.322]                           computeRestarts <- base::computeRestarts
[13:22:55.322]                           grepl <- base::grepl
[13:22:55.322]                           restarts <- computeRestarts(cond)
[13:22:55.322]                           for (restart in restarts) {
[13:22:55.322]                             name <- restart$name
[13:22:55.322]                             if (is.null(name)) 
[13:22:55.322]                               next
[13:22:55.322]                             if (!grepl(pattern, name)) 
[13:22:55.322]                               next
[13:22:55.322]                             invokeRestart(restart)
[13:22:55.322]                             muffled <- TRUE
[13:22:55.322]                             break
[13:22:55.322]                           }
[13:22:55.322]                         }
[13:22:55.322]                       }
[13:22:55.322]                       invisible(muffled)
[13:22:55.322]                     }
[13:22:55.322]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.322]                   }
[13:22:55.322]                 }
[13:22:55.322]             }
[13:22:55.322]         }))
[13:22:55.322]     }, error = function(ex) {
[13:22:55.322]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:55.322]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.322]                 ...future.rng), started = ...future.startTime, 
[13:22:55.322]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:55.322]             version = "1.8"), class = "FutureResult")
[13:22:55.322]     }, finally = {
[13:22:55.322]         if (!identical(...future.workdir, getwd())) 
[13:22:55.322]             setwd(...future.workdir)
[13:22:55.322]         {
[13:22:55.322]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:55.322]                 ...future.oldOptions$nwarnings <- NULL
[13:22:55.322]             }
[13:22:55.322]             base::options(...future.oldOptions)
[13:22:55.322]             if (.Platform$OS.type == "windows") {
[13:22:55.322]                 old_names <- names(...future.oldEnvVars)
[13:22:55.322]                 envs <- base::Sys.getenv()
[13:22:55.322]                 names <- names(envs)
[13:22:55.322]                 common <- intersect(names, old_names)
[13:22:55.322]                 added <- setdiff(names, old_names)
[13:22:55.322]                 removed <- setdiff(old_names, names)
[13:22:55.322]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:55.322]                   envs[common]]
[13:22:55.322]                 NAMES <- toupper(changed)
[13:22:55.322]                 args <- list()
[13:22:55.322]                 for (kk in seq_along(NAMES)) {
[13:22:55.322]                   name <- changed[[kk]]
[13:22:55.322]                   NAME <- NAMES[[kk]]
[13:22:55.322]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.322]                     next
[13:22:55.322]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.322]                 }
[13:22:55.322]                 NAMES <- toupper(added)
[13:22:55.322]                 for (kk in seq_along(NAMES)) {
[13:22:55.322]                   name <- added[[kk]]
[13:22:55.322]                   NAME <- NAMES[[kk]]
[13:22:55.322]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.322]                     next
[13:22:55.322]                   args[[name]] <- ""
[13:22:55.322]                 }
[13:22:55.322]                 NAMES <- toupper(removed)
[13:22:55.322]                 for (kk in seq_along(NAMES)) {
[13:22:55.322]                   name <- removed[[kk]]
[13:22:55.322]                   NAME <- NAMES[[kk]]
[13:22:55.322]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.322]                     next
[13:22:55.322]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.322]                 }
[13:22:55.322]                 if (length(args) > 0) 
[13:22:55.322]                   base::do.call(base::Sys.setenv, args = args)
[13:22:55.322]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:55.322]             }
[13:22:55.322]             else {
[13:22:55.322]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:55.322]             }
[13:22:55.322]             {
[13:22:55.322]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:55.322]                   0L) {
[13:22:55.322]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:55.322]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:55.322]                   base::options(opts)
[13:22:55.322]                 }
[13:22:55.322]                 {
[13:22:55.322]                   {
[13:22:55.322]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:55.322]                     NULL
[13:22:55.322]                   }
[13:22:55.322]                   options(future.plan = NULL)
[13:22:55.322]                   if (is.na(NA_character_)) 
[13:22:55.322]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.322]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:55.322]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:22:55.322]                     envir = parent.frame()) 
[13:22:55.322]                   {
[13:22:55.322]                     default_workers <- missing(workers)
[13:22:55.322]                     if (is.function(workers)) 
[13:22:55.322]                       workers <- workers()
[13:22:55.322]                     workers <- structure(as.integer(workers), 
[13:22:55.322]                       class = class(workers))
[13:22:55.322]                     stop_if_not(is.finite(workers), workers >= 
[13:22:55.322]                       1L)
[13:22:55.322]                     if ((workers == 1L && !inherits(workers, 
[13:22:55.322]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:22:55.322]                       if (default_workers) 
[13:22:55.322]                         supportsMulticore(warn = TRUE)
[13:22:55.322]                       return(sequential(..., envir = envir))
[13:22:55.322]                     }
[13:22:55.322]                     oopts <- options(mc.cores = workers)
[13:22:55.322]                     on.exit(options(oopts))
[13:22:55.322]                     future <- MulticoreFuture(..., workers = workers, 
[13:22:55.322]                       envir = envir)
[13:22:55.322]                     if (!future$lazy) 
[13:22:55.322]                       future <- run(future)
[13:22:55.322]                     invisible(future)
[13:22:55.322]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:55.322]                 }
[13:22:55.322]             }
[13:22:55.322]         }
[13:22:55.322]     })
[13:22:55.322]     if (TRUE) {
[13:22:55.322]         base::sink(type = "output", split = FALSE)
[13:22:55.322]         if (TRUE) {
[13:22:55.322]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:55.322]         }
[13:22:55.322]         else {
[13:22:55.322]             ...future.result["stdout"] <- base::list(NULL)
[13:22:55.322]         }
[13:22:55.322]         base::close(...future.stdout)
[13:22:55.322]         ...future.stdout <- NULL
[13:22:55.322]     }
[13:22:55.322]     ...future.result$conditions <- ...future.conditions
[13:22:55.322]     ...future.result$finished <- base::Sys.time()
[13:22:55.322]     ...future.result
[13:22:55.322] }
[13:22:55.325] requestCore(): workers = 2
[13:22:55.327] MulticoreFuture started
[13:22:55.327] - Launch lazy future ... done
[13:22:55.328] run() for ‘MulticoreFuture’ ... done
[13:22:55.328] result() for MulticoreFuture ...
[13:22:55.328] plan(): Setting new future strategy stack:
[13:22:55.328] List of future strategies:
[13:22:55.328] 1. sequential:
[13:22:55.328]    - args: function (..., envir = parent.frame())
[13:22:55.328]    - tweaked: FALSE
[13:22:55.328]    - call: NULL
[13:22:55.329] plan(): nbrOfWorkers() = 1
[13:22:55.331] plan(): Setting new future strategy stack:
[13:22:55.331] List of future strategies:
[13:22:55.331] 1. multicore:
[13:22:55.331]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:22:55.331]    - tweaked: FALSE
[13:22:55.331]    - call: plan(strategy)
[13:22:55.337] plan(): nbrOfWorkers() = 2
[13:22:55.342] result() for MulticoreFuture ...
[13:22:55.342] result() for MulticoreFuture ... done
[13:22:55.342] signalConditions() ...
[13:22:55.342]  - include = ‘immediateCondition’
[13:22:55.343]  - exclude = 
[13:22:55.343]  - resignal = FALSE
[13:22:55.343]  - Number of conditions: 1
[13:22:55.343] signalConditions() ... done
[13:22:55.343] result() for MulticoreFuture ... done
[13:22:55.343] result() for MulticoreFuture ...
[13:22:55.343] result() for MulticoreFuture ... done
[13:22:55.343] signalConditions() ...
[13:22:55.344]  - include = ‘immediateCondition’
[13:22:55.344]  - exclude = 
[13:22:55.344]  - resignal = FALSE
[13:22:55.344]  - Number of conditions: 1
[13:22:55.344] signalConditions() ... done
[13:22:55.344] Future state: ‘finished’
[13:22:55.344] result() for MulticoreFuture ...
[13:22:55.344] result() for MulticoreFuture ... done
[13:22:55.345] signalConditions() ...
[13:22:55.345]  - include = ‘condition’
[13:22:55.345]  - exclude = ‘immediateCondition’
[13:22:55.345]  - resignal = TRUE
[13:22:55.345]  - Number of conditions: 1
[13:22:55.345]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:22:55.345] signalConditions() ... done
[13:22:55.346] getGlobalsAndPackages() ...
[13:22:55.346] Searching for globals...
[13:22:55.348] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[13:22:55.348] Searching for globals ... DONE
[13:22:55.349] Resolving globals: FALSE
[13:22:55.349] The total size of the 1 globals is 56 bytes (56 bytes)
[13:22:55.350] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:22:55.350] - globals: [1] ‘ii’
[13:22:55.350] 
[13:22:55.350] getGlobalsAndPackages() ... DONE
[13:22:55.350] run() for ‘Future’ ...
[13:22:55.351] - state: ‘created’
[13:22:55.351] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:22:55.355] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:55.356] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:22:55.356]   - Field: ‘label’
[13:22:55.356]   - Field: ‘local’
[13:22:55.356]   - Field: ‘owner’
[13:22:55.356]   - Field: ‘envir’
[13:22:55.356]   - Field: ‘workers’
[13:22:55.356]   - Field: ‘packages’
[13:22:55.357]   - Field: ‘gc’
[13:22:55.357]   - Field: ‘job’
[13:22:55.357]   - Field: ‘conditions’
[13:22:55.357]   - Field: ‘expr’
[13:22:55.357]   - Field: ‘uuid’
[13:22:55.357]   - Field: ‘seed’
[13:22:55.357]   - Field: ‘version’
[13:22:55.357]   - Field: ‘result’
[13:22:55.357]   - Field: ‘asynchronous’
[13:22:55.358]   - Field: ‘calls’
[13:22:55.358]   - Field: ‘globals’
[13:22:55.358]   - Field: ‘stdout’
[13:22:55.358]   - Field: ‘earlySignal’
[13:22:55.358]   - Field: ‘lazy’
[13:22:55.358]   - Field: ‘state’
[13:22:55.358] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:22:55.358] - Launch lazy future ...
[13:22:55.359] Packages needed by the future expression (n = 0): <none>
[13:22:55.359] Packages needed by future strategies (n = 0): <none>
[13:22:55.362] {
[13:22:55.362]     {
[13:22:55.362]         {
[13:22:55.362]             ...future.startTime <- base::Sys.time()
[13:22:55.362]             {
[13:22:55.362]                 {
[13:22:55.362]                   {
[13:22:55.362]                     {
[13:22:55.362]                       base::local({
[13:22:55.362]                         has_future <- base::requireNamespace("future", 
[13:22:55.362]                           quietly = TRUE)
[13:22:55.362]                         if (has_future) {
[13:22:55.362]                           ns <- base::getNamespace("future")
[13:22:55.362]                           version <- ns[[".package"]][["version"]]
[13:22:55.362]                           if (is.null(version)) 
[13:22:55.362]                             version <- utils::packageVersion("future")
[13:22:55.362]                         }
[13:22:55.362]                         else {
[13:22:55.362]                           version <- NULL
[13:22:55.362]                         }
[13:22:55.362]                         if (!has_future || version < "1.8.0") {
[13:22:55.362]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:55.362]                             "", base::R.version$version.string), 
[13:22:55.362]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:55.362]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:55.362]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:55.362]                               "release", "version")], collapse = " "), 
[13:22:55.362]                             hostname = base::Sys.info()[["nodename"]])
[13:22:55.362]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:55.362]                             info)
[13:22:55.362]                           info <- base::paste(info, collapse = "; ")
[13:22:55.362]                           if (!has_future) {
[13:22:55.362]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:55.362]                               info)
[13:22:55.362]                           }
[13:22:55.362]                           else {
[13:22:55.362]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:55.362]                               info, version)
[13:22:55.362]                           }
[13:22:55.362]                           base::stop(msg)
[13:22:55.362]                         }
[13:22:55.362]                       })
[13:22:55.362]                     }
[13:22:55.362]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:55.362]                     base::options(mc.cores = 1L)
[13:22:55.362]                   }
[13:22:55.362]                   options(future.plan = NULL)
[13:22:55.362]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.362]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:55.362]                 }
[13:22:55.362]                 ...future.workdir <- getwd()
[13:22:55.362]             }
[13:22:55.362]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:55.362]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:55.362]         }
[13:22:55.362]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:55.362]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:55.362]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:55.362]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:55.362]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:55.362]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:55.362]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:55.362]             base::names(...future.oldOptions))
[13:22:55.362]     }
[13:22:55.362]     if (FALSE) {
[13:22:55.362]     }
[13:22:55.362]     else {
[13:22:55.362]         if (TRUE) {
[13:22:55.362]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:55.362]                 open = "w")
[13:22:55.362]         }
[13:22:55.362]         else {
[13:22:55.362]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:55.362]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:55.362]         }
[13:22:55.362]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:55.362]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:55.362]             base::sink(type = "output", split = FALSE)
[13:22:55.362]             base::close(...future.stdout)
[13:22:55.362]         }, add = TRUE)
[13:22:55.362]     }
[13:22:55.362]     ...future.frame <- base::sys.nframe()
[13:22:55.362]     ...future.conditions <- base::list()
[13:22:55.362]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:55.362]     if (FALSE) {
[13:22:55.362]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:55.362]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:55.362]     }
[13:22:55.362]     ...future.result <- base::tryCatch({
[13:22:55.362]         base::withCallingHandlers({
[13:22:55.362]             ...future.value <- base::withVisible(base::local({
[13:22:55.362]                 withCallingHandlers({
[13:22:55.362]                   {
[13:22:55.362]                     if (ii%%2 == 0) 
[13:22:55.362]                       stop("Woops!")
[13:22:55.362]                     ii
[13:22:55.362]                   }
[13:22:55.362]                 }, immediateCondition = function(cond) {
[13:22:55.362]                   save_rds <- function (object, pathname, ...) 
[13:22:55.362]                   {
[13:22:55.362]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:22:55.362]                     if (file_test("-f", pathname_tmp)) {
[13:22:55.362]                       fi_tmp <- file.info(pathname_tmp)
[13:22:55.362]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:22:55.362]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:55.362]                         fi_tmp[["mtime"]])
[13:22:55.362]                     }
[13:22:55.362]                     tryCatch({
[13:22:55.362]                       saveRDS(object, file = pathname_tmp, ...)
[13:22:55.362]                     }, error = function(ex) {
[13:22:55.362]                       msg <- conditionMessage(ex)
[13:22:55.362]                       fi_tmp <- file.info(pathname_tmp)
[13:22:55.362]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:22:55.362]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:55.362]                         fi_tmp[["mtime"]], msg)
[13:22:55.362]                       ex$message <- msg
[13:22:55.362]                       stop(ex)
[13:22:55.362]                     })
[13:22:55.362]                     stopifnot(file_test("-f", pathname_tmp))
[13:22:55.362]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:22:55.362]                     if (!res || file_test("-f", pathname_tmp)) {
[13:22:55.362]                       fi_tmp <- file.info(pathname_tmp)
[13:22:55.362]                       fi <- file.info(pathname)
[13:22:55.362]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:22:55.362]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:55.362]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:22:55.362]                         fi[["size"]], fi[["mtime"]])
[13:22:55.362]                       stop(msg)
[13:22:55.362]                     }
[13:22:55.362]                     invisible(pathname)
[13:22:55.362]                   }
[13:22:55.362]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:22:55.362]                     rootPath = tempdir()) 
[13:22:55.362]                   {
[13:22:55.362]                     obj <- list(time = Sys.time(), condition = cond)
[13:22:55.362]                     file <- tempfile(pattern = class(cond)[1], 
[13:22:55.362]                       tmpdir = path, fileext = ".rds")
[13:22:55.362]                     save_rds(obj, file)
[13:22:55.362]                   }
[13:22:55.362]                   saveImmediateCondition(cond, path = "/tmp/RtmphhERam/.future/immediateConditions")
[13:22:55.362]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.362]                   {
[13:22:55.362]                     inherits <- base::inherits
[13:22:55.362]                     invokeRestart <- base::invokeRestart
[13:22:55.362]                     is.null <- base::is.null
[13:22:55.362]                     muffled <- FALSE
[13:22:55.362]                     if (inherits(cond, "message")) {
[13:22:55.362]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:55.362]                       if (muffled) 
[13:22:55.362]                         invokeRestart("muffleMessage")
[13:22:55.362]                     }
[13:22:55.362]                     else if (inherits(cond, "warning")) {
[13:22:55.362]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:55.362]                       if (muffled) 
[13:22:55.362]                         invokeRestart("muffleWarning")
[13:22:55.362]                     }
[13:22:55.362]                     else if (inherits(cond, "condition")) {
[13:22:55.362]                       if (!is.null(pattern)) {
[13:22:55.362]                         computeRestarts <- base::computeRestarts
[13:22:55.362]                         grepl <- base::grepl
[13:22:55.362]                         restarts <- computeRestarts(cond)
[13:22:55.362]                         for (restart in restarts) {
[13:22:55.362]                           name <- restart$name
[13:22:55.362]                           if (is.null(name)) 
[13:22:55.362]                             next
[13:22:55.362]                           if (!grepl(pattern, name)) 
[13:22:55.362]                             next
[13:22:55.362]                           invokeRestart(restart)
[13:22:55.362]                           muffled <- TRUE
[13:22:55.362]                           break
[13:22:55.362]                         }
[13:22:55.362]                       }
[13:22:55.362]                     }
[13:22:55.362]                     invisible(muffled)
[13:22:55.362]                   }
[13:22:55.362]                   muffleCondition(cond)
[13:22:55.362]                 })
[13:22:55.362]             }))
[13:22:55.362]             future::FutureResult(value = ...future.value$value, 
[13:22:55.362]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.362]                   ...future.rng), globalenv = if (FALSE) 
[13:22:55.362]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:55.362]                     ...future.globalenv.names))
[13:22:55.362]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:55.362]         }, condition = base::local({
[13:22:55.362]             c <- base::c
[13:22:55.362]             inherits <- base::inherits
[13:22:55.362]             invokeRestart <- base::invokeRestart
[13:22:55.362]             length <- base::length
[13:22:55.362]             list <- base::list
[13:22:55.362]             seq.int <- base::seq.int
[13:22:55.362]             signalCondition <- base::signalCondition
[13:22:55.362]             sys.calls <- base::sys.calls
[13:22:55.362]             `[[` <- base::`[[`
[13:22:55.362]             `+` <- base::`+`
[13:22:55.362]             `<<-` <- base::`<<-`
[13:22:55.362]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:55.362]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:55.362]                   3L)]
[13:22:55.362]             }
[13:22:55.362]             function(cond) {
[13:22:55.362]                 is_error <- inherits(cond, "error")
[13:22:55.362]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:55.362]                   NULL)
[13:22:55.362]                 if (is_error) {
[13:22:55.362]                   sessionInformation <- function() {
[13:22:55.362]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:55.362]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:55.362]                       search = base::search(), system = base::Sys.info())
[13:22:55.362]                   }
[13:22:55.362]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.362]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:55.362]                     cond$call), session = sessionInformation(), 
[13:22:55.362]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:55.362]                   signalCondition(cond)
[13:22:55.362]                 }
[13:22:55.362]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:55.362]                 "immediateCondition"))) {
[13:22:55.362]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:55.362]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.362]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:55.362]                   if (TRUE && !signal) {
[13:22:55.362]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.362]                     {
[13:22:55.362]                       inherits <- base::inherits
[13:22:55.362]                       invokeRestart <- base::invokeRestart
[13:22:55.362]                       is.null <- base::is.null
[13:22:55.362]                       muffled <- FALSE
[13:22:55.362]                       if (inherits(cond, "message")) {
[13:22:55.362]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.362]                         if (muffled) 
[13:22:55.362]                           invokeRestart("muffleMessage")
[13:22:55.362]                       }
[13:22:55.362]                       else if (inherits(cond, "warning")) {
[13:22:55.362]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.362]                         if (muffled) 
[13:22:55.362]                           invokeRestart("muffleWarning")
[13:22:55.362]                       }
[13:22:55.362]                       else if (inherits(cond, "condition")) {
[13:22:55.362]                         if (!is.null(pattern)) {
[13:22:55.362]                           computeRestarts <- base::computeRestarts
[13:22:55.362]                           grepl <- base::grepl
[13:22:55.362]                           restarts <- computeRestarts(cond)
[13:22:55.362]                           for (restart in restarts) {
[13:22:55.362]                             name <- restart$name
[13:22:55.362]                             if (is.null(name)) 
[13:22:55.362]                               next
[13:22:55.362]                             if (!grepl(pattern, name)) 
[13:22:55.362]                               next
[13:22:55.362]                             invokeRestart(restart)
[13:22:55.362]                             muffled <- TRUE
[13:22:55.362]                             break
[13:22:55.362]                           }
[13:22:55.362]                         }
[13:22:55.362]                       }
[13:22:55.362]                       invisible(muffled)
[13:22:55.362]                     }
[13:22:55.362]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.362]                   }
[13:22:55.362]                 }
[13:22:55.362]                 else {
[13:22:55.362]                   if (TRUE) {
[13:22:55.362]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.362]                     {
[13:22:55.362]                       inherits <- base::inherits
[13:22:55.362]                       invokeRestart <- base::invokeRestart
[13:22:55.362]                       is.null <- base::is.null
[13:22:55.362]                       muffled <- FALSE
[13:22:55.362]                       if (inherits(cond, "message")) {
[13:22:55.362]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.362]                         if (muffled) 
[13:22:55.362]                           invokeRestart("muffleMessage")
[13:22:55.362]                       }
[13:22:55.362]                       else if (inherits(cond, "warning")) {
[13:22:55.362]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.362]                         if (muffled) 
[13:22:55.362]                           invokeRestart("muffleWarning")
[13:22:55.362]                       }
[13:22:55.362]                       else if (inherits(cond, "condition")) {
[13:22:55.362]                         if (!is.null(pattern)) {
[13:22:55.362]                           computeRestarts <- base::computeRestarts
[13:22:55.362]                           grepl <- base::grepl
[13:22:55.362]                           restarts <- computeRestarts(cond)
[13:22:55.362]                           for (restart in restarts) {
[13:22:55.362]                             name <- restart$name
[13:22:55.362]                             if (is.null(name)) 
[13:22:55.362]                               next
[13:22:55.362]                             if (!grepl(pattern, name)) 
[13:22:55.362]                               next
[13:22:55.362]                             invokeRestart(restart)
[13:22:55.362]                             muffled <- TRUE
[13:22:55.362]                             break
[13:22:55.362]                           }
[13:22:55.362]                         }
[13:22:55.362]                       }
[13:22:55.362]                       invisible(muffled)
[13:22:55.362]                     }
[13:22:55.362]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.362]                   }
[13:22:55.362]                 }
[13:22:55.362]             }
[13:22:55.362]         }))
[13:22:55.362]     }, error = function(ex) {
[13:22:55.362]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:55.362]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.362]                 ...future.rng), started = ...future.startTime, 
[13:22:55.362]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:55.362]             version = "1.8"), class = "FutureResult")
[13:22:55.362]     }, finally = {
[13:22:55.362]         if (!identical(...future.workdir, getwd())) 
[13:22:55.362]             setwd(...future.workdir)
[13:22:55.362]         {
[13:22:55.362]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:55.362]                 ...future.oldOptions$nwarnings <- NULL
[13:22:55.362]             }
[13:22:55.362]             base::options(...future.oldOptions)
[13:22:55.362]             if (.Platform$OS.type == "windows") {
[13:22:55.362]                 old_names <- names(...future.oldEnvVars)
[13:22:55.362]                 envs <- base::Sys.getenv()
[13:22:55.362]                 names <- names(envs)
[13:22:55.362]                 common <- intersect(names, old_names)
[13:22:55.362]                 added <- setdiff(names, old_names)
[13:22:55.362]                 removed <- setdiff(old_names, names)
[13:22:55.362]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:55.362]                   envs[common]]
[13:22:55.362]                 NAMES <- toupper(changed)
[13:22:55.362]                 args <- list()
[13:22:55.362]                 for (kk in seq_along(NAMES)) {
[13:22:55.362]                   name <- changed[[kk]]
[13:22:55.362]                   NAME <- NAMES[[kk]]
[13:22:55.362]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.362]                     next
[13:22:55.362]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.362]                 }
[13:22:55.362]                 NAMES <- toupper(added)
[13:22:55.362]                 for (kk in seq_along(NAMES)) {
[13:22:55.362]                   name <- added[[kk]]
[13:22:55.362]                   NAME <- NAMES[[kk]]
[13:22:55.362]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.362]                     next
[13:22:55.362]                   args[[name]] <- ""
[13:22:55.362]                 }
[13:22:55.362]                 NAMES <- toupper(removed)
[13:22:55.362]                 for (kk in seq_along(NAMES)) {
[13:22:55.362]                   name <- removed[[kk]]
[13:22:55.362]                   NAME <- NAMES[[kk]]
[13:22:55.362]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.362]                     next
[13:22:55.362]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.362]                 }
[13:22:55.362]                 if (length(args) > 0) 
[13:22:55.362]                   base::do.call(base::Sys.setenv, args = args)
[13:22:55.362]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:55.362]             }
[13:22:55.362]             else {
[13:22:55.362]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:55.362]             }
[13:22:55.362]             {
[13:22:55.362]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:55.362]                   0L) {
[13:22:55.362]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:55.362]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:55.362]                   base::options(opts)
[13:22:55.362]                 }
[13:22:55.362]                 {
[13:22:55.362]                   {
[13:22:55.362]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:55.362]                     NULL
[13:22:55.362]                   }
[13:22:55.362]                   options(future.plan = NULL)
[13:22:55.362]                   if (is.na(NA_character_)) 
[13:22:55.362]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.362]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:55.362]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:22:55.362]                     envir = parent.frame()) 
[13:22:55.362]                   {
[13:22:55.362]                     default_workers <- missing(workers)
[13:22:55.362]                     if (is.function(workers)) 
[13:22:55.362]                       workers <- workers()
[13:22:55.362]                     workers <- structure(as.integer(workers), 
[13:22:55.362]                       class = class(workers))
[13:22:55.362]                     stop_if_not(is.finite(workers), workers >= 
[13:22:55.362]                       1L)
[13:22:55.362]                     if ((workers == 1L && !inherits(workers, 
[13:22:55.362]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:22:55.362]                       if (default_workers) 
[13:22:55.362]                         supportsMulticore(warn = TRUE)
[13:22:55.362]                       return(sequential(..., envir = envir))
[13:22:55.362]                     }
[13:22:55.362]                     oopts <- options(mc.cores = workers)
[13:22:55.362]                     on.exit(options(oopts))
[13:22:55.362]                     future <- MulticoreFuture(..., workers = workers, 
[13:22:55.362]                       envir = envir)
[13:22:55.362]                     if (!future$lazy) 
[13:22:55.362]                       future <- run(future)
[13:22:55.362]                     invisible(future)
[13:22:55.362]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:55.362]                 }
[13:22:55.362]             }
[13:22:55.362]         }
[13:22:55.362]     })
[13:22:55.362]     if (TRUE) {
[13:22:55.362]         base::sink(type = "output", split = FALSE)
[13:22:55.362]         if (TRUE) {
[13:22:55.362]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:55.362]         }
[13:22:55.362]         else {
[13:22:55.362]             ...future.result["stdout"] <- base::list(NULL)
[13:22:55.362]         }
[13:22:55.362]         base::close(...future.stdout)
[13:22:55.362]         ...future.stdout <- NULL
[13:22:55.362]     }
[13:22:55.362]     ...future.result$conditions <- ...future.conditions
[13:22:55.362]     ...future.result$finished <- base::Sys.time()
[13:22:55.362]     ...future.result
[13:22:55.362] }
[13:22:55.365] assign_globals() ...
[13:22:55.365] List of 1
[13:22:55.365]  $ ii: int 1
[13:22:55.365]  - attr(*, "where")=List of 1
[13:22:55.365]   ..$ ii:<environment: R_EmptyEnv> 
[13:22:55.365]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:22:55.365]  - attr(*, "resolved")= logi FALSE
[13:22:55.365]  - attr(*, "total_size")= num 56
[13:22:55.365]  - attr(*, "already-done")= logi TRUE
[13:22:55.369] - copied ‘ii’ to environment
[13:22:55.369] assign_globals() ... done
[13:22:55.369] requestCore(): workers = 2
[13:22:55.371] MulticoreFuture started
[13:22:55.372] - Launch lazy future ... done
[13:22:55.372] run() for ‘MulticoreFuture’ ... done
[13:22:55.373] plan(): Setting new future strategy stack:
[13:22:55.373] getGlobalsAndPackages() ...
[13:22:55.373] Searching for globals...
[13:22:55.373] List of future strategies:
[13:22:55.373] 1. sequential:
[13:22:55.373]    - args: function (..., envir = parent.frame())
[13:22:55.373]    - tweaked: FALSE
[13:22:55.373]    - call: NULL
[13:22:55.374] plan(): nbrOfWorkers() = 1
[13:22:55.376] plan(): Setting new future strategy stack:
[13:22:55.376] List of future strategies:
[13:22:55.376] 1. multicore:
[13:22:55.376]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:22:55.376]    - tweaked: FALSE
[13:22:55.376]    - call: plan(strategy)
[13:22:55.377] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[13:22:55.377] Searching for globals ... DONE
[13:22:55.377] Resolving globals: FALSE
[13:22:55.378] The total size of the 1 globals is 56 bytes (56 bytes)
[13:22:55.379] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:22:55.379] - globals: [1] ‘ii’
[13:22:55.379] 
[13:22:55.380] getGlobalsAndPackages() ... DONE
[13:22:55.380] run() for ‘Future’ ...
[13:22:55.380] - state: ‘created’
[13:22:55.380] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:22:55.381] plan(): nbrOfWorkers() = 2
[13:22:55.386] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:55.386] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:22:55.386]   - Field: ‘label’
[13:22:55.386]   - Field: ‘local’
[13:22:55.386]   - Field: ‘owner’
[13:22:55.387]   - Field: ‘envir’
[13:22:55.387]   - Field: ‘workers’
[13:22:55.387]   - Field: ‘packages’
[13:22:55.387]   - Field: ‘gc’
[13:22:55.387]   - Field: ‘job’
[13:22:55.387]   - Field: ‘conditions’
[13:22:55.387]   - Field: ‘expr’
[13:22:55.388]   - Field: ‘uuid’
[13:22:55.388]   - Field: ‘seed’
[13:22:55.388]   - Field: ‘version’
[13:22:55.388]   - Field: ‘result’
[13:22:55.388]   - Field: ‘asynchronous’
[13:22:55.388]   - Field: ‘calls’
[13:22:55.388]   - Field: ‘globals’
[13:22:55.389]   - Field: ‘stdout’
[13:22:55.389]   - Field: ‘earlySignal’
[13:22:55.389]   - Field: ‘lazy’
[13:22:55.389]   - Field: ‘state’
[13:22:55.389] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:22:55.389] - Launch lazy future ...
[13:22:55.390] Packages needed by the future expression (n = 0): <none>
[13:22:55.390] Packages needed by future strategies (n = 0): <none>
[13:22:55.391] {
[13:22:55.391]     {
[13:22:55.391]         {
[13:22:55.391]             ...future.startTime <- base::Sys.time()
[13:22:55.391]             {
[13:22:55.391]                 {
[13:22:55.391]                   {
[13:22:55.391]                     {
[13:22:55.391]                       base::local({
[13:22:55.391]                         has_future <- base::requireNamespace("future", 
[13:22:55.391]                           quietly = TRUE)
[13:22:55.391]                         if (has_future) {
[13:22:55.391]                           ns <- base::getNamespace("future")
[13:22:55.391]                           version <- ns[[".package"]][["version"]]
[13:22:55.391]                           if (is.null(version)) 
[13:22:55.391]                             version <- utils::packageVersion("future")
[13:22:55.391]                         }
[13:22:55.391]                         else {
[13:22:55.391]                           version <- NULL
[13:22:55.391]                         }
[13:22:55.391]                         if (!has_future || version < "1.8.0") {
[13:22:55.391]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:55.391]                             "", base::R.version$version.string), 
[13:22:55.391]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:55.391]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:55.391]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:55.391]                               "release", "version")], collapse = " "), 
[13:22:55.391]                             hostname = base::Sys.info()[["nodename"]])
[13:22:55.391]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:55.391]                             info)
[13:22:55.391]                           info <- base::paste(info, collapse = "; ")
[13:22:55.391]                           if (!has_future) {
[13:22:55.391]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:55.391]                               info)
[13:22:55.391]                           }
[13:22:55.391]                           else {
[13:22:55.391]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:55.391]                               info, version)
[13:22:55.391]                           }
[13:22:55.391]                           base::stop(msg)
[13:22:55.391]                         }
[13:22:55.391]                       })
[13:22:55.391]                     }
[13:22:55.391]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:55.391]                     base::options(mc.cores = 1L)
[13:22:55.391]                   }
[13:22:55.391]                   options(future.plan = NULL)
[13:22:55.391]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.391]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:55.391]                 }
[13:22:55.391]                 ...future.workdir <- getwd()
[13:22:55.391]             }
[13:22:55.391]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:55.391]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:55.391]         }
[13:22:55.391]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:55.391]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:55.391]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:55.391]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:55.391]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:55.391]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:55.391]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:55.391]             base::names(...future.oldOptions))
[13:22:55.391]     }
[13:22:55.391]     if (FALSE) {
[13:22:55.391]     }
[13:22:55.391]     else {
[13:22:55.391]         if (TRUE) {
[13:22:55.391]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:55.391]                 open = "w")
[13:22:55.391]         }
[13:22:55.391]         else {
[13:22:55.391]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:55.391]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:55.391]         }
[13:22:55.391]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:55.391]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:55.391]             base::sink(type = "output", split = FALSE)
[13:22:55.391]             base::close(...future.stdout)
[13:22:55.391]         }, add = TRUE)
[13:22:55.391]     }
[13:22:55.391]     ...future.frame <- base::sys.nframe()
[13:22:55.391]     ...future.conditions <- base::list()
[13:22:55.391]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:55.391]     if (FALSE) {
[13:22:55.391]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:55.391]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:55.391]     }
[13:22:55.391]     ...future.result <- base::tryCatch({
[13:22:55.391]         base::withCallingHandlers({
[13:22:55.391]             ...future.value <- base::withVisible(base::local({
[13:22:55.391]                 withCallingHandlers({
[13:22:55.391]                   {
[13:22:55.391]                     if (ii%%2 == 0) 
[13:22:55.391]                       stop("Woops!")
[13:22:55.391]                     ii
[13:22:55.391]                   }
[13:22:55.391]                 }, immediateCondition = function(cond) {
[13:22:55.391]                   save_rds <- function (object, pathname, ...) 
[13:22:55.391]                   {
[13:22:55.391]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:22:55.391]                     if (file_test("-f", pathname_tmp)) {
[13:22:55.391]                       fi_tmp <- file.info(pathname_tmp)
[13:22:55.391]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:22:55.391]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:55.391]                         fi_tmp[["mtime"]])
[13:22:55.391]                     }
[13:22:55.391]                     tryCatch({
[13:22:55.391]                       saveRDS(object, file = pathname_tmp, ...)
[13:22:55.391]                     }, error = function(ex) {
[13:22:55.391]                       msg <- conditionMessage(ex)
[13:22:55.391]                       fi_tmp <- file.info(pathname_tmp)
[13:22:55.391]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:22:55.391]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:55.391]                         fi_tmp[["mtime"]], msg)
[13:22:55.391]                       ex$message <- msg
[13:22:55.391]                       stop(ex)
[13:22:55.391]                     })
[13:22:55.391]                     stopifnot(file_test("-f", pathname_tmp))
[13:22:55.391]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:22:55.391]                     if (!res || file_test("-f", pathname_tmp)) {
[13:22:55.391]                       fi_tmp <- file.info(pathname_tmp)
[13:22:55.391]                       fi <- file.info(pathname)
[13:22:55.391]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:22:55.391]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:55.391]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:22:55.391]                         fi[["size"]], fi[["mtime"]])
[13:22:55.391]                       stop(msg)
[13:22:55.391]                     }
[13:22:55.391]                     invisible(pathname)
[13:22:55.391]                   }
[13:22:55.391]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:22:55.391]                     rootPath = tempdir()) 
[13:22:55.391]                   {
[13:22:55.391]                     obj <- list(time = Sys.time(), condition = cond)
[13:22:55.391]                     file <- tempfile(pattern = class(cond)[1], 
[13:22:55.391]                       tmpdir = path, fileext = ".rds")
[13:22:55.391]                     save_rds(obj, file)
[13:22:55.391]                   }
[13:22:55.391]                   saveImmediateCondition(cond, path = "/tmp/RtmphhERam/.future/immediateConditions")
[13:22:55.391]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.391]                   {
[13:22:55.391]                     inherits <- base::inherits
[13:22:55.391]                     invokeRestart <- base::invokeRestart
[13:22:55.391]                     is.null <- base::is.null
[13:22:55.391]                     muffled <- FALSE
[13:22:55.391]                     if (inherits(cond, "message")) {
[13:22:55.391]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:55.391]                       if (muffled) 
[13:22:55.391]                         invokeRestart("muffleMessage")
[13:22:55.391]                     }
[13:22:55.391]                     else if (inherits(cond, "warning")) {
[13:22:55.391]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:55.391]                       if (muffled) 
[13:22:55.391]                         invokeRestart("muffleWarning")
[13:22:55.391]                     }
[13:22:55.391]                     else if (inherits(cond, "condition")) {
[13:22:55.391]                       if (!is.null(pattern)) {
[13:22:55.391]                         computeRestarts <- base::computeRestarts
[13:22:55.391]                         grepl <- base::grepl
[13:22:55.391]                         restarts <- computeRestarts(cond)
[13:22:55.391]                         for (restart in restarts) {
[13:22:55.391]                           name <- restart$name
[13:22:55.391]                           if (is.null(name)) 
[13:22:55.391]                             next
[13:22:55.391]                           if (!grepl(pattern, name)) 
[13:22:55.391]                             next
[13:22:55.391]                           invokeRestart(restart)
[13:22:55.391]                           muffled <- TRUE
[13:22:55.391]                           break
[13:22:55.391]                         }
[13:22:55.391]                       }
[13:22:55.391]                     }
[13:22:55.391]                     invisible(muffled)
[13:22:55.391]                   }
[13:22:55.391]                   muffleCondition(cond)
[13:22:55.391]                 })
[13:22:55.391]             }))
[13:22:55.391]             future::FutureResult(value = ...future.value$value, 
[13:22:55.391]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.391]                   ...future.rng), globalenv = if (FALSE) 
[13:22:55.391]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:55.391]                     ...future.globalenv.names))
[13:22:55.391]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:55.391]         }, condition = base::local({
[13:22:55.391]             c <- base::c
[13:22:55.391]             inherits <- base::inherits
[13:22:55.391]             invokeRestart <- base::invokeRestart
[13:22:55.391]             length <- base::length
[13:22:55.391]             list <- base::list
[13:22:55.391]             seq.int <- base::seq.int
[13:22:55.391]             signalCondition <- base::signalCondition
[13:22:55.391]             sys.calls <- base::sys.calls
[13:22:55.391]             `[[` <- base::`[[`
[13:22:55.391]             `+` <- base::`+`
[13:22:55.391]             `<<-` <- base::`<<-`
[13:22:55.391]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:55.391]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:55.391]                   3L)]
[13:22:55.391]             }
[13:22:55.391]             function(cond) {
[13:22:55.391]                 is_error <- inherits(cond, "error")
[13:22:55.391]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:55.391]                   NULL)
[13:22:55.391]                 if (is_error) {
[13:22:55.391]                   sessionInformation <- function() {
[13:22:55.391]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:55.391]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:55.391]                       search = base::search(), system = base::Sys.info())
[13:22:55.391]                   }
[13:22:55.391]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.391]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:55.391]                     cond$call), session = sessionInformation(), 
[13:22:55.391]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:55.391]                   signalCondition(cond)
[13:22:55.391]                 }
[13:22:55.391]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:55.391]                 "immediateCondition"))) {
[13:22:55.391]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:55.391]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.391]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:55.391]                   if (TRUE && !signal) {
[13:22:55.391]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.391]                     {
[13:22:55.391]                       inherits <- base::inherits
[13:22:55.391]                       invokeRestart <- base::invokeRestart
[13:22:55.391]                       is.null <- base::is.null
[13:22:55.391]                       muffled <- FALSE
[13:22:55.391]                       if (inherits(cond, "message")) {
[13:22:55.391]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.391]                         if (muffled) 
[13:22:55.391]                           invokeRestart("muffleMessage")
[13:22:55.391]                       }
[13:22:55.391]                       else if (inherits(cond, "warning")) {
[13:22:55.391]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.391]                         if (muffled) 
[13:22:55.391]                           invokeRestart("muffleWarning")
[13:22:55.391]                       }
[13:22:55.391]                       else if (inherits(cond, "condition")) {
[13:22:55.391]                         if (!is.null(pattern)) {
[13:22:55.391]                           computeRestarts <- base::computeRestarts
[13:22:55.391]                           grepl <- base::grepl
[13:22:55.391]                           restarts <- computeRestarts(cond)
[13:22:55.391]                           for (restart in restarts) {
[13:22:55.391]                             name <- restart$name
[13:22:55.391]                             if (is.null(name)) 
[13:22:55.391]                               next
[13:22:55.391]                             if (!grepl(pattern, name)) 
[13:22:55.391]                               next
[13:22:55.391]                             invokeRestart(restart)
[13:22:55.391]                             muffled <- TRUE
[13:22:55.391]                             break
[13:22:55.391]                           }
[13:22:55.391]                         }
[13:22:55.391]                       }
[13:22:55.391]                       invisible(muffled)
[13:22:55.391]                     }
[13:22:55.391]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.391]                   }
[13:22:55.391]                 }
[13:22:55.391]                 else {
[13:22:55.391]                   if (TRUE) {
[13:22:55.391]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.391]                     {
[13:22:55.391]                       inherits <- base::inherits
[13:22:55.391]                       invokeRestart <- base::invokeRestart
[13:22:55.391]                       is.null <- base::is.null
[13:22:55.391]                       muffled <- FALSE
[13:22:55.391]                       if (inherits(cond, "message")) {
[13:22:55.391]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.391]                         if (muffled) 
[13:22:55.391]                           invokeRestart("muffleMessage")
[13:22:55.391]                       }
[13:22:55.391]                       else if (inherits(cond, "warning")) {
[13:22:55.391]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.391]                         if (muffled) 
[13:22:55.391]                           invokeRestart("muffleWarning")
[13:22:55.391]                       }
[13:22:55.391]                       else if (inherits(cond, "condition")) {
[13:22:55.391]                         if (!is.null(pattern)) {
[13:22:55.391]                           computeRestarts <- base::computeRestarts
[13:22:55.391]                           grepl <- base::grepl
[13:22:55.391]                           restarts <- computeRestarts(cond)
[13:22:55.391]                           for (restart in restarts) {
[13:22:55.391]                             name <- restart$name
[13:22:55.391]                             if (is.null(name)) 
[13:22:55.391]                               next
[13:22:55.391]                             if (!grepl(pattern, name)) 
[13:22:55.391]                               next
[13:22:55.391]                             invokeRestart(restart)
[13:22:55.391]                             muffled <- TRUE
[13:22:55.391]                             break
[13:22:55.391]                           }
[13:22:55.391]                         }
[13:22:55.391]                       }
[13:22:55.391]                       invisible(muffled)
[13:22:55.391]                     }
[13:22:55.391]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.391]                   }
[13:22:55.391]                 }
[13:22:55.391]             }
[13:22:55.391]         }))
[13:22:55.391]     }, error = function(ex) {
[13:22:55.391]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:55.391]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.391]                 ...future.rng), started = ...future.startTime, 
[13:22:55.391]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:55.391]             version = "1.8"), class = "FutureResult")
[13:22:55.391]     }, finally = {
[13:22:55.391]         if (!identical(...future.workdir, getwd())) 
[13:22:55.391]             setwd(...future.workdir)
[13:22:55.391]         {
[13:22:55.391]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:55.391]                 ...future.oldOptions$nwarnings <- NULL
[13:22:55.391]             }
[13:22:55.391]             base::options(...future.oldOptions)
[13:22:55.391]             if (.Platform$OS.type == "windows") {
[13:22:55.391]                 old_names <- names(...future.oldEnvVars)
[13:22:55.391]                 envs <- base::Sys.getenv()
[13:22:55.391]                 names <- names(envs)
[13:22:55.391]                 common <- intersect(names, old_names)
[13:22:55.391]                 added <- setdiff(names, old_names)
[13:22:55.391]                 removed <- setdiff(old_names, names)
[13:22:55.391]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:55.391]                   envs[common]]
[13:22:55.391]                 NAMES <- toupper(changed)
[13:22:55.391]                 args <- list()
[13:22:55.391]                 for (kk in seq_along(NAMES)) {
[13:22:55.391]                   name <- changed[[kk]]
[13:22:55.391]                   NAME <- NAMES[[kk]]
[13:22:55.391]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.391]                     next
[13:22:55.391]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.391]                 }
[13:22:55.391]                 NAMES <- toupper(added)
[13:22:55.391]                 for (kk in seq_along(NAMES)) {
[13:22:55.391]                   name <- added[[kk]]
[13:22:55.391]                   NAME <- NAMES[[kk]]
[13:22:55.391]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.391]                     next
[13:22:55.391]                   args[[name]] <- ""
[13:22:55.391]                 }
[13:22:55.391]                 NAMES <- toupper(removed)
[13:22:55.391]                 for (kk in seq_along(NAMES)) {
[13:22:55.391]                   name <- removed[[kk]]
[13:22:55.391]                   NAME <- NAMES[[kk]]
[13:22:55.391]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.391]                     next
[13:22:55.391]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.391]                 }
[13:22:55.391]                 if (length(args) > 0) 
[13:22:55.391]                   base::do.call(base::Sys.setenv, args = args)
[13:22:55.391]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:55.391]             }
[13:22:55.391]             else {
[13:22:55.391]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:55.391]             }
[13:22:55.391]             {
[13:22:55.391]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:55.391]                   0L) {
[13:22:55.391]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:55.391]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:55.391]                   base::options(opts)
[13:22:55.391]                 }
[13:22:55.391]                 {
[13:22:55.391]                   {
[13:22:55.391]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:55.391]                     NULL
[13:22:55.391]                   }
[13:22:55.391]                   options(future.plan = NULL)
[13:22:55.391]                   if (is.na(NA_character_)) 
[13:22:55.391]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.391]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:55.391]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:22:55.391]                     envir = parent.frame()) 
[13:22:55.391]                   {
[13:22:55.391]                     default_workers <- missing(workers)
[13:22:55.391]                     if (is.function(workers)) 
[13:22:55.391]                       workers <- workers()
[13:22:55.391]                     workers <- structure(as.integer(workers), 
[13:22:55.391]                       class = class(workers))
[13:22:55.391]                     stop_if_not(is.finite(workers), workers >= 
[13:22:55.391]                       1L)
[13:22:55.391]                     if ((workers == 1L && !inherits(workers, 
[13:22:55.391]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:22:55.391]                       if (default_workers) 
[13:22:55.391]                         supportsMulticore(warn = TRUE)
[13:22:55.391]                       return(sequential(..., envir = envir))
[13:22:55.391]                     }
[13:22:55.391]                     oopts <- options(mc.cores = workers)
[13:22:55.391]                     on.exit(options(oopts))
[13:22:55.391]                     future <- MulticoreFuture(..., workers = workers, 
[13:22:55.391]                       envir = envir)
[13:22:55.391]                     if (!future$lazy) 
[13:22:55.391]                       future <- run(future)
[13:22:55.391]                     invisible(future)
[13:22:55.391]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:55.391]                 }
[13:22:55.391]             }
[13:22:55.391]         }
[13:22:55.391]     })
[13:22:55.391]     if (TRUE) {
[13:22:55.391]         base::sink(type = "output", split = FALSE)
[13:22:55.391]         if (TRUE) {
[13:22:55.391]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:55.391]         }
[13:22:55.391]         else {
[13:22:55.391]             ...future.result["stdout"] <- base::list(NULL)
[13:22:55.391]         }
[13:22:55.391]         base::close(...future.stdout)
[13:22:55.391]         ...future.stdout <- NULL
[13:22:55.391]     }
[13:22:55.391]     ...future.result$conditions <- ...future.conditions
[13:22:55.391]     ...future.result$finished <- base::Sys.time()
[13:22:55.391]     ...future.result
[13:22:55.391] }
[13:22:55.394] assign_globals() ...
[13:22:55.394] List of 1
[13:22:55.394]  $ ii: int 2
[13:22:55.394]  - attr(*, "where")=List of 1
[13:22:55.394]   ..$ ii:<environment: R_EmptyEnv> 
[13:22:55.394]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:22:55.394]  - attr(*, "resolved")= logi FALSE
[13:22:55.394]  - attr(*, "total_size")= num 56
[13:22:55.394]  - attr(*, "already-done")= logi TRUE
[13:22:55.398] - copied ‘ii’ to environment
[13:22:55.398] assign_globals() ... done
[13:22:55.399] requestCore(): workers = 2
[13:22:55.401] MulticoreFuture started
[13:22:55.401] - Launch lazy future ... done
[13:22:55.402] run() for ‘MulticoreFuture’ ... done
[13:22:55.402] plan(): Setting new future strategy stack:
[13:22:55.403] getGlobalsAndPackages() ...
[13:22:55.403] Searching for globals...
[13:22:55.403] List of future strategies:
[13:22:55.403] 1. sequential:
[13:22:55.403]    - args: function (..., envir = parent.frame())
[13:22:55.403]    - tweaked: FALSE
[13:22:55.403]    - call: NULL
[13:22:55.403] plan(): nbrOfWorkers() = 1
[13:22:55.406] plan(): Setting new future strategy stack:
[13:22:55.406] List of future strategies:
[13:22:55.406] 1. multicore:
[13:22:55.406]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:22:55.406]    - tweaked: FALSE
[13:22:55.406]    - call: plan(strategy)
[13:22:55.406] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[13:22:55.406] Searching for globals ... DONE
[13:22:55.406] Resolving globals: FALSE
[13:22:55.407] The total size of the 1 globals is 56 bytes (56 bytes)
[13:22:55.408] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:22:55.409] - globals: [1] ‘ii’
[13:22:55.409] 
[13:22:55.409] getGlobalsAndPackages() ... DONE
[13:22:55.410] run() for ‘Future’ ...
[13:22:55.410] - state: ‘created’
[13:22:55.411] plan(): nbrOfWorkers() = 2
[13:22:55.410] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:22:55.420] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:55.420] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:22:55.420]   - Field: ‘label’
[13:22:55.420]   - Field: ‘local’
[13:22:55.420]   - Field: ‘owner’
[13:22:55.421]   - Field: ‘envir’
[13:22:55.421]   - Field: ‘workers’
[13:22:55.421]   - Field: ‘packages’
[13:22:55.421]   - Field: ‘gc’
[13:22:55.422]   - Field: ‘job’
[13:22:55.422]   - Field: ‘conditions’
[13:22:55.422]   - Field: ‘expr’
[13:22:55.422]   - Field: ‘uuid’
[13:22:55.422]   - Field: ‘seed’
[13:22:55.422]   - Field: ‘version’
[13:22:55.423]   - Field: ‘result’
[13:22:55.423]   - Field: ‘asynchronous’
[13:22:55.423]   - Field: ‘calls’
[13:22:55.423]   - Field: ‘globals’
[13:22:55.423]   - Field: ‘stdout’
[13:22:55.423]   - Field: ‘earlySignal’
[13:22:55.424]   - Field: ‘lazy’
[13:22:55.424]   - Field: ‘state’
[13:22:55.424] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:22:55.424] - Launch lazy future ...
[13:22:55.425] Packages needed by the future expression (n = 0): <none>
[13:22:55.425] Packages needed by future strategies (n = 0): <none>
[13:22:55.426] {
[13:22:55.426]     {
[13:22:55.426]         {
[13:22:55.426]             ...future.startTime <- base::Sys.time()
[13:22:55.426]             {
[13:22:55.426]                 {
[13:22:55.426]                   {
[13:22:55.426]                     {
[13:22:55.426]                       base::local({
[13:22:55.426]                         has_future <- base::requireNamespace("future", 
[13:22:55.426]                           quietly = TRUE)
[13:22:55.426]                         if (has_future) {
[13:22:55.426]                           ns <- base::getNamespace("future")
[13:22:55.426]                           version <- ns[[".package"]][["version"]]
[13:22:55.426]                           if (is.null(version)) 
[13:22:55.426]                             version <- utils::packageVersion("future")
[13:22:55.426]                         }
[13:22:55.426]                         else {
[13:22:55.426]                           version <- NULL
[13:22:55.426]                         }
[13:22:55.426]                         if (!has_future || version < "1.8.0") {
[13:22:55.426]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:55.426]                             "", base::R.version$version.string), 
[13:22:55.426]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:55.426]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:55.426]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:55.426]                               "release", "version")], collapse = " "), 
[13:22:55.426]                             hostname = base::Sys.info()[["nodename"]])
[13:22:55.426]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:55.426]                             info)
[13:22:55.426]                           info <- base::paste(info, collapse = "; ")
[13:22:55.426]                           if (!has_future) {
[13:22:55.426]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:55.426]                               info)
[13:22:55.426]                           }
[13:22:55.426]                           else {
[13:22:55.426]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:55.426]                               info, version)
[13:22:55.426]                           }
[13:22:55.426]                           base::stop(msg)
[13:22:55.426]                         }
[13:22:55.426]                       })
[13:22:55.426]                     }
[13:22:55.426]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:55.426]                     base::options(mc.cores = 1L)
[13:22:55.426]                   }
[13:22:55.426]                   options(future.plan = NULL)
[13:22:55.426]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.426]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:55.426]                 }
[13:22:55.426]                 ...future.workdir <- getwd()
[13:22:55.426]             }
[13:22:55.426]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:55.426]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:55.426]         }
[13:22:55.426]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:55.426]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:55.426]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:55.426]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:55.426]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:55.426]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:55.426]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:55.426]             base::names(...future.oldOptions))
[13:22:55.426]     }
[13:22:55.426]     if (FALSE) {
[13:22:55.426]     }
[13:22:55.426]     else {
[13:22:55.426]         if (TRUE) {
[13:22:55.426]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:55.426]                 open = "w")
[13:22:55.426]         }
[13:22:55.426]         else {
[13:22:55.426]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:55.426]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:55.426]         }
[13:22:55.426]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:55.426]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:55.426]             base::sink(type = "output", split = FALSE)
[13:22:55.426]             base::close(...future.stdout)
[13:22:55.426]         }, add = TRUE)
[13:22:55.426]     }
[13:22:55.426]     ...future.frame <- base::sys.nframe()
[13:22:55.426]     ...future.conditions <- base::list()
[13:22:55.426]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:55.426]     if (FALSE) {
[13:22:55.426]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:55.426]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:55.426]     }
[13:22:55.426]     ...future.result <- base::tryCatch({
[13:22:55.426]         base::withCallingHandlers({
[13:22:55.426]             ...future.value <- base::withVisible(base::local({
[13:22:55.426]                 withCallingHandlers({
[13:22:55.426]                   {
[13:22:55.426]                     if (ii%%2 == 0) 
[13:22:55.426]                       stop("Woops!")
[13:22:55.426]                     ii
[13:22:55.426]                   }
[13:22:55.426]                 }, immediateCondition = function(cond) {
[13:22:55.426]                   save_rds <- function (object, pathname, ...) 
[13:22:55.426]                   {
[13:22:55.426]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:22:55.426]                     if (file_test("-f", pathname_tmp)) {
[13:22:55.426]                       fi_tmp <- file.info(pathname_tmp)
[13:22:55.426]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:22:55.426]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:55.426]                         fi_tmp[["mtime"]])
[13:22:55.426]                     }
[13:22:55.426]                     tryCatch({
[13:22:55.426]                       saveRDS(object, file = pathname_tmp, ...)
[13:22:55.426]                     }, error = function(ex) {
[13:22:55.426]                       msg <- conditionMessage(ex)
[13:22:55.426]                       fi_tmp <- file.info(pathname_tmp)
[13:22:55.426]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:22:55.426]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:55.426]                         fi_tmp[["mtime"]], msg)
[13:22:55.426]                       ex$message <- msg
[13:22:55.426]                       stop(ex)
[13:22:55.426]                     })
[13:22:55.426]                     stopifnot(file_test("-f", pathname_tmp))
[13:22:55.426]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:22:55.426]                     if (!res || file_test("-f", pathname_tmp)) {
[13:22:55.426]                       fi_tmp <- file.info(pathname_tmp)
[13:22:55.426]                       fi <- file.info(pathname)
[13:22:55.426]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:22:55.426]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:55.426]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:22:55.426]                         fi[["size"]], fi[["mtime"]])
[13:22:55.426]                       stop(msg)
[13:22:55.426]                     }
[13:22:55.426]                     invisible(pathname)
[13:22:55.426]                   }
[13:22:55.426]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:22:55.426]                     rootPath = tempdir()) 
[13:22:55.426]                   {
[13:22:55.426]                     obj <- list(time = Sys.time(), condition = cond)
[13:22:55.426]                     file <- tempfile(pattern = class(cond)[1], 
[13:22:55.426]                       tmpdir = path, fileext = ".rds")
[13:22:55.426]                     save_rds(obj, file)
[13:22:55.426]                   }
[13:22:55.426]                   saveImmediateCondition(cond, path = "/tmp/RtmphhERam/.future/immediateConditions")
[13:22:55.426]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.426]                   {
[13:22:55.426]                     inherits <- base::inherits
[13:22:55.426]                     invokeRestart <- base::invokeRestart
[13:22:55.426]                     is.null <- base::is.null
[13:22:55.426]                     muffled <- FALSE
[13:22:55.426]                     if (inherits(cond, "message")) {
[13:22:55.426]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:55.426]                       if (muffled) 
[13:22:55.426]                         invokeRestart("muffleMessage")
[13:22:55.426]                     }
[13:22:55.426]                     else if (inherits(cond, "warning")) {
[13:22:55.426]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:55.426]                       if (muffled) 
[13:22:55.426]                         invokeRestart("muffleWarning")
[13:22:55.426]                     }
[13:22:55.426]                     else if (inherits(cond, "condition")) {
[13:22:55.426]                       if (!is.null(pattern)) {
[13:22:55.426]                         computeRestarts <- base::computeRestarts
[13:22:55.426]                         grepl <- base::grepl
[13:22:55.426]                         restarts <- computeRestarts(cond)
[13:22:55.426]                         for (restart in restarts) {
[13:22:55.426]                           name <- restart$name
[13:22:55.426]                           if (is.null(name)) 
[13:22:55.426]                             next
[13:22:55.426]                           if (!grepl(pattern, name)) 
[13:22:55.426]                             next
[13:22:55.426]                           invokeRestart(restart)
[13:22:55.426]                           muffled <- TRUE
[13:22:55.426]                           break
[13:22:55.426]                         }
[13:22:55.426]                       }
[13:22:55.426]                     }
[13:22:55.426]                     invisible(muffled)
[13:22:55.426]                   }
[13:22:55.426]                   muffleCondition(cond)
[13:22:55.426]                 })
[13:22:55.426]             }))
[13:22:55.426]             future::FutureResult(value = ...future.value$value, 
[13:22:55.426]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.426]                   ...future.rng), globalenv = if (FALSE) 
[13:22:55.426]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:55.426]                     ...future.globalenv.names))
[13:22:55.426]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:55.426]         }, condition = base::local({
[13:22:55.426]             c <- base::c
[13:22:55.426]             inherits <- base::inherits
[13:22:55.426]             invokeRestart <- base::invokeRestart
[13:22:55.426]             length <- base::length
[13:22:55.426]             list <- base::list
[13:22:55.426]             seq.int <- base::seq.int
[13:22:55.426]             signalCondition <- base::signalCondition
[13:22:55.426]             sys.calls <- base::sys.calls
[13:22:55.426]             `[[` <- base::`[[`
[13:22:55.426]             `+` <- base::`+`
[13:22:55.426]             `<<-` <- base::`<<-`
[13:22:55.426]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:55.426]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:55.426]                   3L)]
[13:22:55.426]             }
[13:22:55.426]             function(cond) {
[13:22:55.426]                 is_error <- inherits(cond, "error")
[13:22:55.426]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:55.426]                   NULL)
[13:22:55.426]                 if (is_error) {
[13:22:55.426]                   sessionInformation <- function() {
[13:22:55.426]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:55.426]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:55.426]                       search = base::search(), system = base::Sys.info())
[13:22:55.426]                   }
[13:22:55.426]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.426]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:55.426]                     cond$call), session = sessionInformation(), 
[13:22:55.426]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:55.426]                   signalCondition(cond)
[13:22:55.426]                 }
[13:22:55.426]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:55.426]                 "immediateCondition"))) {
[13:22:55.426]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:55.426]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.426]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:55.426]                   if (TRUE && !signal) {
[13:22:55.426]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.426]                     {
[13:22:55.426]                       inherits <- base::inherits
[13:22:55.426]                       invokeRestart <- base::invokeRestart
[13:22:55.426]                       is.null <- base::is.null
[13:22:55.426]                       muffled <- FALSE
[13:22:55.426]                       if (inherits(cond, "message")) {
[13:22:55.426]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.426]                         if (muffled) 
[13:22:55.426]                           invokeRestart("muffleMessage")
[13:22:55.426]                       }
[13:22:55.426]                       else if (inherits(cond, "warning")) {
[13:22:55.426]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.426]                         if (muffled) 
[13:22:55.426]                           invokeRestart("muffleWarning")
[13:22:55.426]                       }
[13:22:55.426]                       else if (inherits(cond, "condition")) {
[13:22:55.426]                         if (!is.null(pattern)) {
[13:22:55.426]                           computeRestarts <- base::computeRestarts
[13:22:55.426]                           grepl <- base::grepl
[13:22:55.426]                           restarts <- computeRestarts(cond)
[13:22:55.426]                           for (restart in restarts) {
[13:22:55.426]                             name <- restart$name
[13:22:55.426]                             if (is.null(name)) 
[13:22:55.426]                               next
[13:22:55.426]                             if (!grepl(pattern, name)) 
[13:22:55.426]                               next
[13:22:55.426]                             invokeRestart(restart)
[13:22:55.426]                             muffled <- TRUE
[13:22:55.426]                             break
[13:22:55.426]                           }
[13:22:55.426]                         }
[13:22:55.426]                       }
[13:22:55.426]                       invisible(muffled)
[13:22:55.426]                     }
[13:22:55.426]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.426]                   }
[13:22:55.426]                 }
[13:22:55.426]                 else {
[13:22:55.426]                   if (TRUE) {
[13:22:55.426]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.426]                     {
[13:22:55.426]                       inherits <- base::inherits
[13:22:55.426]                       invokeRestart <- base::invokeRestart
[13:22:55.426]                       is.null <- base::is.null
[13:22:55.426]                       muffled <- FALSE
[13:22:55.426]                       if (inherits(cond, "message")) {
[13:22:55.426]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.426]                         if (muffled) 
[13:22:55.426]                           invokeRestart("muffleMessage")
[13:22:55.426]                       }
[13:22:55.426]                       else if (inherits(cond, "warning")) {
[13:22:55.426]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.426]                         if (muffled) 
[13:22:55.426]                           invokeRestart("muffleWarning")
[13:22:55.426]                       }
[13:22:55.426]                       else if (inherits(cond, "condition")) {
[13:22:55.426]                         if (!is.null(pattern)) {
[13:22:55.426]                           computeRestarts <- base::computeRestarts
[13:22:55.426]                           grepl <- base::grepl
[13:22:55.426]                           restarts <- computeRestarts(cond)
[13:22:55.426]                           for (restart in restarts) {
[13:22:55.426]                             name <- restart$name
[13:22:55.426]                             if (is.null(name)) 
[13:22:55.426]                               next
[13:22:55.426]                             if (!grepl(pattern, name)) 
[13:22:55.426]                               next
[13:22:55.426]                             invokeRestart(restart)
[13:22:55.426]                             muffled <- TRUE
[13:22:55.426]                             break
[13:22:55.426]                           }
[13:22:55.426]                         }
[13:22:55.426]                       }
[13:22:55.426]                       invisible(muffled)
[13:22:55.426]                     }
[13:22:55.426]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.426]                   }
[13:22:55.426]                 }
[13:22:55.426]             }
[13:22:55.426]         }))
[13:22:55.426]     }, error = function(ex) {
[13:22:55.426]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:55.426]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.426]                 ...future.rng), started = ...future.startTime, 
[13:22:55.426]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:55.426]             version = "1.8"), class = "FutureResult")
[13:22:55.426]     }, finally = {
[13:22:55.426]         if (!identical(...future.workdir, getwd())) 
[13:22:55.426]             setwd(...future.workdir)
[13:22:55.426]         {
[13:22:55.426]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:55.426]                 ...future.oldOptions$nwarnings <- NULL
[13:22:55.426]             }
[13:22:55.426]             base::options(...future.oldOptions)
[13:22:55.426]             if (.Platform$OS.type == "windows") {
[13:22:55.426]                 old_names <- names(...future.oldEnvVars)
[13:22:55.426]                 envs <- base::Sys.getenv()
[13:22:55.426]                 names <- names(envs)
[13:22:55.426]                 common <- intersect(names, old_names)
[13:22:55.426]                 added <- setdiff(names, old_names)
[13:22:55.426]                 removed <- setdiff(old_names, names)
[13:22:55.426]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:55.426]                   envs[common]]
[13:22:55.426]                 NAMES <- toupper(changed)
[13:22:55.426]                 args <- list()
[13:22:55.426]                 for (kk in seq_along(NAMES)) {
[13:22:55.426]                   name <- changed[[kk]]
[13:22:55.426]                   NAME <- NAMES[[kk]]
[13:22:55.426]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.426]                     next
[13:22:55.426]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.426]                 }
[13:22:55.426]                 NAMES <- toupper(added)
[13:22:55.426]                 for (kk in seq_along(NAMES)) {
[13:22:55.426]                   name <- added[[kk]]
[13:22:55.426]                   NAME <- NAMES[[kk]]
[13:22:55.426]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.426]                     next
[13:22:55.426]                   args[[name]] <- ""
[13:22:55.426]                 }
[13:22:55.426]                 NAMES <- toupper(removed)
[13:22:55.426]                 for (kk in seq_along(NAMES)) {
[13:22:55.426]                   name <- removed[[kk]]
[13:22:55.426]                   NAME <- NAMES[[kk]]
[13:22:55.426]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.426]                     next
[13:22:55.426]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.426]                 }
[13:22:55.426]                 if (length(args) > 0) 
[13:22:55.426]                   base::do.call(base::Sys.setenv, args = args)
[13:22:55.426]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:55.426]             }
[13:22:55.426]             else {
[13:22:55.426]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:55.426]             }
[13:22:55.426]             {
[13:22:55.426]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:55.426]                   0L) {
[13:22:55.426]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:55.426]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:55.426]                   base::options(opts)
[13:22:55.426]                 }
[13:22:55.426]                 {
[13:22:55.426]                   {
[13:22:55.426]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:55.426]                     NULL
[13:22:55.426]                   }
[13:22:55.426]                   options(future.plan = NULL)
[13:22:55.426]                   if (is.na(NA_character_)) 
[13:22:55.426]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.426]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:55.426]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:22:55.426]                     envir = parent.frame()) 
[13:22:55.426]                   {
[13:22:55.426]                     default_workers <- missing(workers)
[13:22:55.426]                     if (is.function(workers)) 
[13:22:55.426]                       workers <- workers()
[13:22:55.426]                     workers <- structure(as.integer(workers), 
[13:22:55.426]                       class = class(workers))
[13:22:55.426]                     stop_if_not(is.finite(workers), workers >= 
[13:22:55.426]                       1L)
[13:22:55.426]                     if ((workers == 1L && !inherits(workers, 
[13:22:55.426]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:22:55.426]                       if (default_workers) 
[13:22:55.426]                         supportsMulticore(warn = TRUE)
[13:22:55.426]                       return(sequential(..., envir = envir))
[13:22:55.426]                     }
[13:22:55.426]                     oopts <- options(mc.cores = workers)
[13:22:55.426]                     on.exit(options(oopts))
[13:22:55.426]                     future <- MulticoreFuture(..., workers = workers, 
[13:22:55.426]                       envir = envir)
[13:22:55.426]                     if (!future$lazy) 
[13:22:55.426]                       future <- run(future)
[13:22:55.426]                     invisible(future)
[13:22:55.426]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:55.426]                 }
[13:22:55.426]             }
[13:22:55.426]         }
[13:22:55.426]     })
[13:22:55.426]     if (TRUE) {
[13:22:55.426]         base::sink(type = "output", split = FALSE)
[13:22:55.426]         if (TRUE) {
[13:22:55.426]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:55.426]         }
[13:22:55.426]         else {
[13:22:55.426]             ...future.result["stdout"] <- base::list(NULL)
[13:22:55.426]         }
[13:22:55.426]         base::close(...future.stdout)
[13:22:55.426]         ...future.stdout <- NULL
[13:22:55.426]     }
[13:22:55.426]     ...future.result$conditions <- ...future.conditions
[13:22:55.426]     ...future.result$finished <- base::Sys.time()
[13:22:55.426]     ...future.result
[13:22:55.426] }
[13:22:55.428] assign_globals() ...
[13:22:55.429] List of 1
[13:22:55.429]  $ ii: int 3
[13:22:55.429]  - attr(*, "where")=List of 1
[13:22:55.429]   ..$ ii:<environment: R_EmptyEnv> 
[13:22:55.429]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:22:55.429]  - attr(*, "resolved")= logi FALSE
[13:22:55.429]  - attr(*, "total_size")= num 56
[13:22:55.429]  - attr(*, "already-done")= logi TRUE
[13:22:55.433] - copied ‘ii’ to environment
[13:22:55.433] assign_globals() ... done
[13:22:55.433] requestCore(): workers = 2
[13:22:55.433] Poll #1 (0): usedCores() = 2, workers = 2
[13:22:55.445] result() for MulticoreFuture ...
[13:22:55.446] result() for MulticoreFuture ...
[13:22:55.446] result() for MulticoreFuture ... done
[13:22:55.446] result() for MulticoreFuture ... done
[13:22:55.446] result() for MulticoreFuture ...
[13:22:55.446] result() for MulticoreFuture ... done
[13:22:55.449] MulticoreFuture started
[13:22:55.450] - Launch lazy future ... done
[13:22:55.450] run() for ‘MulticoreFuture’ ... done
[13:22:55.451] result() for MulticoreFuture ...
[13:22:55.451] plan(): Setting new future strategy stack:
[13:22:55.451] result() for MulticoreFuture ... done
[13:22:55.451] result() for MulticoreFuture ...
[13:22:55.451] result() for MulticoreFuture ... done
[13:22:55.452] result() for MulticoreFuture ...
[13:22:55.451] List of future strategies:
[13:22:55.451] 1. sequential:
[13:22:55.451]    - args: function (..., envir = parent.frame())
[13:22:55.451]    - tweaked: FALSE
[13:22:55.451]    - call: NULL
[13:22:55.452] plan(): nbrOfWorkers() = 1
[13:22:55.454] plan(): Setting new future strategy stack:
[13:22:55.454] List of future strategies:
[13:22:55.454] 1. multicore:
[13:22:55.454]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:22:55.454]    - tweaked: FALSE
[13:22:55.454]    - call: plan(strategy)
[13:22:55.456] result() for MulticoreFuture ...
[13:22:55.456] result() for MulticoreFuture ... done
[13:22:55.456] signalConditions() ...
[13:22:55.456]  - include = ‘immediateCondition’
[13:22:55.456]  - exclude = 
[13:22:55.456]  - resignal = FALSE
[13:22:55.457]  - Number of conditions: 1
[13:22:55.457] signalConditions() ... done
[13:22:55.457] result() for MulticoreFuture ... done
[13:22:55.457] result() for MulticoreFuture ...
[13:22:55.457] result() for MulticoreFuture ... done
[13:22:55.458] signalConditions() ...
[13:22:55.458]  - include = ‘immediateCondition’
[13:22:55.458]  - exclude = 
[13:22:55.458]  - resignal = FALSE
[13:22:55.458]  - Number of conditions: 1
[13:22:55.458] signalConditions() ... done
[13:22:55.459] Future state: ‘finished’
[13:22:55.459] result() for MulticoreFuture ...
[13:22:55.459] result() for MulticoreFuture ... done
[13:22:55.459] signalConditions() ...
[13:22:55.459]  - include = ‘condition’
[13:22:55.460]  - exclude = ‘immediateCondition’
[13:22:55.460]  - resignal = TRUE
[13:22:55.460]  - Number of conditions: 1
[13:22:55.460]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:22:55.460] signalConditions() ... done
[13:22:55.461] plan(): nbrOfWorkers() = 2
[13:22:55.461] result() for MulticoreFuture ...
[13:22:55.462] result() for MulticoreFuture ...
[13:22:55.462] result() for MulticoreFuture ... done
[13:22:55.462] result() for MulticoreFuture ... done
[13:22:55.462] result() for MulticoreFuture ...
[13:22:55.462] result() for MulticoreFuture ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[13:22:55.463] result() for MulticoreFuture ...
[13:22:55.463] result() for MulticoreFuture ... done
[13:22:55.463] result() for MulticoreFuture ...
[13:22:55.463] result() for MulticoreFuture ... done
[13:22:55.463] signalConditions() ...
[13:22:55.463]  - include = ‘immediateCondition’
[13:22:55.464]  - exclude = 
[13:22:55.464]  - resignal = FALSE
[13:22:55.464]  - Number of conditions: 1
[13:22:55.464] signalConditions() ... done
[13:22:55.464] Future state: ‘finished’
[13:22:55.464] result() for MulticoreFuture ...
[13:22:55.464] result() for MulticoreFuture ... done
[13:22:55.464] signalConditions() ...
[13:22:55.465]  - include = ‘condition’
[13:22:55.465]  - exclude = ‘immediateCondition’
[13:22:55.465]  - resignal = TRUE
[13:22:55.465]  - Number of conditions: 1
[13:22:55.465]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:22:55.465] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[13:22:55.466] result() for MulticoreFuture ...
[13:22:55.466] result() for MulticoreFuture ... done
[13:22:55.466] result() for MulticoreFuture ...
[13:22:55.466] result() for MulticoreFuture ... done
[13:22:55.466] signalConditions() ...
[13:22:55.466]  - include = ‘immediateCondition’
[13:22:55.466]  - exclude = 
[13:22:55.466]  - resignal = FALSE
[13:22:55.467]  - Number of conditions: 1
[13:22:55.467] signalConditions() ... done
[13:22:55.467] Future state: ‘finished’
[13:22:55.467] result() for MulticoreFuture ...
[13:22:55.467] result() for MulticoreFuture ... done
[13:22:55.467] signalConditions() ...
[13:22:55.467]  - include = ‘condition’
[13:22:55.467]  - exclude = ‘immediateCondition’
[13:22:55.467]  - resignal = TRUE
[13:22:55.468]  - Number of conditions: 1
[13:22:55.468]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:22:55.468] signalConditions() ... done
** Future evaluation with a poor-man's "progress bar"
[13:22:55.471] getGlobalsAndPackages() ...
[13:22:55.472] Searching for globals...
[13:22:55.475] - globals found: [4] ‘{’, ‘cat’, ‘for’, ‘:’
[13:22:55.475] Searching for globals ... DONE
[13:22:55.475] Resolving globals: FALSE
[13:22:55.475] 
[13:22:55.476] 
[13:22:55.476] getGlobalsAndPackages() ... DONE
[13:22:55.476] run() for ‘Future’ ...
[13:22:55.476] - state: ‘created’
[13:22:55.477] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:22:55.481] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:55.481] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:22:55.481]   - Field: ‘label’
[13:22:55.481]   - Field: ‘local’
[13:22:55.481]   - Field: ‘owner’
[13:22:55.482]   - Field: ‘envir’
[13:22:55.482]   - Field: ‘workers’
[13:22:55.482]   - Field: ‘packages’
[13:22:55.482]   - Field: ‘gc’
[13:22:55.482]   - Field: ‘job’
[13:22:55.482]   - Field: ‘conditions’
[13:22:55.482]   - Field: ‘expr’
[13:22:55.482]   - Field: ‘uuid’
[13:22:55.482]   - Field: ‘seed’
[13:22:55.483]   - Field: ‘version’
[13:22:55.483]   - Field: ‘result’
[13:22:55.483]   - Field: ‘asynchronous’
[13:22:55.483]   - Field: ‘calls’
[13:22:55.483]   - Field: ‘globals’
[13:22:55.483]   - Field: ‘stdout’
[13:22:55.483]   - Field: ‘earlySignal’
[13:22:55.483]   - Field: ‘lazy’
[13:22:55.484]   - Field: ‘state’
[13:22:55.484] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:22:55.484] - Launch lazy future ...
[13:22:55.484] Packages needed by the future expression (n = 0): <none>
[13:22:55.484] Packages needed by future strategies (n = 0): <none>
[13:22:55.485] {
[13:22:55.485]     {
[13:22:55.485]         {
[13:22:55.485]             ...future.startTime <- base::Sys.time()
[13:22:55.485]             {
[13:22:55.485]                 {
[13:22:55.485]                   {
[13:22:55.485]                     {
[13:22:55.485]                       base::local({
[13:22:55.485]                         has_future <- base::requireNamespace("future", 
[13:22:55.485]                           quietly = TRUE)
[13:22:55.485]                         if (has_future) {
[13:22:55.485]                           ns <- base::getNamespace("future")
[13:22:55.485]                           version <- ns[[".package"]][["version"]]
[13:22:55.485]                           if (is.null(version)) 
[13:22:55.485]                             version <- utils::packageVersion("future")
[13:22:55.485]                         }
[13:22:55.485]                         else {
[13:22:55.485]                           version <- NULL
[13:22:55.485]                         }
[13:22:55.485]                         if (!has_future || version < "1.8.0") {
[13:22:55.485]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:55.485]                             "", base::R.version$version.string), 
[13:22:55.485]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:55.485]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:55.485]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:55.485]                               "release", "version")], collapse = " "), 
[13:22:55.485]                             hostname = base::Sys.info()[["nodename"]])
[13:22:55.485]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:55.485]                             info)
[13:22:55.485]                           info <- base::paste(info, collapse = "; ")
[13:22:55.485]                           if (!has_future) {
[13:22:55.485]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:55.485]                               info)
[13:22:55.485]                           }
[13:22:55.485]                           else {
[13:22:55.485]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:55.485]                               info, version)
[13:22:55.485]                           }
[13:22:55.485]                           base::stop(msg)
[13:22:55.485]                         }
[13:22:55.485]                       })
[13:22:55.485]                     }
[13:22:55.485]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:55.485]                     base::options(mc.cores = 1L)
[13:22:55.485]                   }
[13:22:55.485]                   options(future.plan = NULL)
[13:22:55.485]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.485]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:55.485]                 }
[13:22:55.485]                 ...future.workdir <- getwd()
[13:22:55.485]             }
[13:22:55.485]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:55.485]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:55.485]         }
[13:22:55.485]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:55.485]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:55.485]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:55.485]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:55.485]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:55.485]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:55.485]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:55.485]             base::names(...future.oldOptions))
[13:22:55.485]     }
[13:22:55.485]     if (FALSE) {
[13:22:55.485]     }
[13:22:55.485]     else {
[13:22:55.485]         if (TRUE) {
[13:22:55.485]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:55.485]                 open = "w")
[13:22:55.485]         }
[13:22:55.485]         else {
[13:22:55.485]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:55.485]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:55.485]         }
[13:22:55.485]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:55.485]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:55.485]             base::sink(type = "output", split = FALSE)
[13:22:55.485]             base::close(...future.stdout)
[13:22:55.485]         }, add = TRUE)
[13:22:55.485]     }
[13:22:55.485]     ...future.frame <- base::sys.nframe()
[13:22:55.485]     ...future.conditions <- base::list()
[13:22:55.485]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:55.485]     if (FALSE) {
[13:22:55.485]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:55.485]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:55.485]     }
[13:22:55.485]     ...future.result <- base::tryCatch({
[13:22:55.485]         base::withCallingHandlers({
[13:22:55.485]             ...future.value <- base::withVisible(base::local({
[13:22:55.485]                 withCallingHandlers({
[13:22:55.485]                   {
[13:22:55.485]                     cat("Processing: ")
[13:22:55.485]                     for (ii in 1:10) {
[13:22:55.485]                       cat(".")
[13:22:55.485]                     }
[13:22:55.485]                     cat(" [100%]\n")
[13:22:55.485]                     4
[13:22:55.485]                   }
[13:22:55.485]                 }, immediateCondition = function(cond) {
[13:22:55.485]                   save_rds <- function (object, pathname, ...) 
[13:22:55.485]                   {
[13:22:55.485]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:22:55.485]                     if (file_test("-f", pathname_tmp)) {
[13:22:55.485]                       fi_tmp <- file.info(pathname_tmp)
[13:22:55.485]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:22:55.485]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:55.485]                         fi_tmp[["mtime"]])
[13:22:55.485]                     }
[13:22:55.485]                     tryCatch({
[13:22:55.485]                       saveRDS(object, file = pathname_tmp, ...)
[13:22:55.485]                     }, error = function(ex) {
[13:22:55.485]                       msg <- conditionMessage(ex)
[13:22:55.485]                       fi_tmp <- file.info(pathname_tmp)
[13:22:55.485]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:22:55.485]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:55.485]                         fi_tmp[["mtime"]], msg)
[13:22:55.485]                       ex$message <- msg
[13:22:55.485]                       stop(ex)
[13:22:55.485]                     })
[13:22:55.485]                     stopifnot(file_test("-f", pathname_tmp))
[13:22:55.485]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:22:55.485]                     if (!res || file_test("-f", pathname_tmp)) {
[13:22:55.485]                       fi_tmp <- file.info(pathname_tmp)
[13:22:55.485]                       fi <- file.info(pathname)
[13:22:55.485]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:22:55.485]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:55.485]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:22:55.485]                         fi[["size"]], fi[["mtime"]])
[13:22:55.485]                       stop(msg)
[13:22:55.485]                     }
[13:22:55.485]                     invisible(pathname)
[13:22:55.485]                   }
[13:22:55.485]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:22:55.485]                     rootPath = tempdir()) 
[13:22:55.485]                   {
[13:22:55.485]                     obj <- list(time = Sys.time(), condition = cond)
[13:22:55.485]                     file <- tempfile(pattern = class(cond)[1], 
[13:22:55.485]                       tmpdir = path, fileext = ".rds")
[13:22:55.485]                     save_rds(obj, file)
[13:22:55.485]                   }
[13:22:55.485]                   saveImmediateCondition(cond, path = "/tmp/RtmphhERam/.future/immediateConditions")
[13:22:55.485]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.485]                   {
[13:22:55.485]                     inherits <- base::inherits
[13:22:55.485]                     invokeRestart <- base::invokeRestart
[13:22:55.485]                     is.null <- base::is.null
[13:22:55.485]                     muffled <- FALSE
[13:22:55.485]                     if (inherits(cond, "message")) {
[13:22:55.485]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:55.485]                       if (muffled) 
[13:22:55.485]                         invokeRestart("muffleMessage")
[13:22:55.485]                     }
[13:22:55.485]                     else if (inherits(cond, "warning")) {
[13:22:55.485]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:55.485]                       if (muffled) 
[13:22:55.485]                         invokeRestart("muffleWarning")
[13:22:55.485]                     }
[13:22:55.485]                     else if (inherits(cond, "condition")) {
[13:22:55.485]                       if (!is.null(pattern)) {
[13:22:55.485]                         computeRestarts <- base::computeRestarts
[13:22:55.485]                         grepl <- base::grepl
[13:22:55.485]                         restarts <- computeRestarts(cond)
[13:22:55.485]                         for (restart in restarts) {
[13:22:55.485]                           name <- restart$name
[13:22:55.485]                           if (is.null(name)) 
[13:22:55.485]                             next
[13:22:55.485]                           if (!grepl(pattern, name)) 
[13:22:55.485]                             next
[13:22:55.485]                           invokeRestart(restart)
[13:22:55.485]                           muffled <- TRUE
[13:22:55.485]                           break
[13:22:55.485]                         }
[13:22:55.485]                       }
[13:22:55.485]                     }
[13:22:55.485]                     invisible(muffled)
[13:22:55.485]                   }
[13:22:55.485]                   muffleCondition(cond)
[13:22:55.485]                 })
[13:22:55.485]             }))
[13:22:55.485]             future::FutureResult(value = ...future.value$value, 
[13:22:55.485]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.485]                   ...future.rng), globalenv = if (FALSE) 
[13:22:55.485]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:55.485]                     ...future.globalenv.names))
[13:22:55.485]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:55.485]         }, condition = base::local({
[13:22:55.485]             c <- base::c
[13:22:55.485]             inherits <- base::inherits
[13:22:55.485]             invokeRestart <- base::invokeRestart
[13:22:55.485]             length <- base::length
[13:22:55.485]             list <- base::list
[13:22:55.485]             seq.int <- base::seq.int
[13:22:55.485]             signalCondition <- base::signalCondition
[13:22:55.485]             sys.calls <- base::sys.calls
[13:22:55.485]             `[[` <- base::`[[`
[13:22:55.485]             `+` <- base::`+`
[13:22:55.485]             `<<-` <- base::`<<-`
[13:22:55.485]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:55.485]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:55.485]                   3L)]
[13:22:55.485]             }
[13:22:55.485]             function(cond) {
[13:22:55.485]                 is_error <- inherits(cond, "error")
[13:22:55.485]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:55.485]                   NULL)
[13:22:55.485]                 if (is_error) {
[13:22:55.485]                   sessionInformation <- function() {
[13:22:55.485]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:55.485]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:55.485]                       search = base::search(), system = base::Sys.info())
[13:22:55.485]                   }
[13:22:55.485]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.485]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:55.485]                     cond$call), session = sessionInformation(), 
[13:22:55.485]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:55.485]                   signalCondition(cond)
[13:22:55.485]                 }
[13:22:55.485]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:55.485]                 "immediateCondition"))) {
[13:22:55.485]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:55.485]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.485]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:55.485]                   if (TRUE && !signal) {
[13:22:55.485]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.485]                     {
[13:22:55.485]                       inherits <- base::inherits
[13:22:55.485]                       invokeRestart <- base::invokeRestart
[13:22:55.485]                       is.null <- base::is.null
[13:22:55.485]                       muffled <- FALSE
[13:22:55.485]                       if (inherits(cond, "message")) {
[13:22:55.485]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.485]                         if (muffled) 
[13:22:55.485]                           invokeRestart("muffleMessage")
[13:22:55.485]                       }
[13:22:55.485]                       else if (inherits(cond, "warning")) {
[13:22:55.485]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.485]                         if (muffled) 
[13:22:55.485]                           invokeRestart("muffleWarning")
[13:22:55.485]                       }
[13:22:55.485]                       else if (inherits(cond, "condition")) {
[13:22:55.485]                         if (!is.null(pattern)) {
[13:22:55.485]                           computeRestarts <- base::computeRestarts
[13:22:55.485]                           grepl <- base::grepl
[13:22:55.485]                           restarts <- computeRestarts(cond)
[13:22:55.485]                           for (restart in restarts) {
[13:22:55.485]                             name <- restart$name
[13:22:55.485]                             if (is.null(name)) 
[13:22:55.485]                               next
[13:22:55.485]                             if (!grepl(pattern, name)) 
[13:22:55.485]                               next
[13:22:55.485]                             invokeRestart(restart)
[13:22:55.485]                             muffled <- TRUE
[13:22:55.485]                             break
[13:22:55.485]                           }
[13:22:55.485]                         }
[13:22:55.485]                       }
[13:22:55.485]                       invisible(muffled)
[13:22:55.485]                     }
[13:22:55.485]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.485]                   }
[13:22:55.485]                 }
[13:22:55.485]                 else {
[13:22:55.485]                   if (TRUE) {
[13:22:55.485]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.485]                     {
[13:22:55.485]                       inherits <- base::inherits
[13:22:55.485]                       invokeRestart <- base::invokeRestart
[13:22:55.485]                       is.null <- base::is.null
[13:22:55.485]                       muffled <- FALSE
[13:22:55.485]                       if (inherits(cond, "message")) {
[13:22:55.485]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.485]                         if (muffled) 
[13:22:55.485]                           invokeRestart("muffleMessage")
[13:22:55.485]                       }
[13:22:55.485]                       else if (inherits(cond, "warning")) {
[13:22:55.485]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.485]                         if (muffled) 
[13:22:55.485]                           invokeRestart("muffleWarning")
[13:22:55.485]                       }
[13:22:55.485]                       else if (inherits(cond, "condition")) {
[13:22:55.485]                         if (!is.null(pattern)) {
[13:22:55.485]                           computeRestarts <- base::computeRestarts
[13:22:55.485]                           grepl <- base::grepl
[13:22:55.485]                           restarts <- computeRestarts(cond)
[13:22:55.485]                           for (restart in restarts) {
[13:22:55.485]                             name <- restart$name
[13:22:55.485]                             if (is.null(name)) 
[13:22:55.485]                               next
[13:22:55.485]                             if (!grepl(pattern, name)) 
[13:22:55.485]                               next
[13:22:55.485]                             invokeRestart(restart)
[13:22:55.485]                             muffled <- TRUE
[13:22:55.485]                             break
[13:22:55.485]                           }
[13:22:55.485]                         }
[13:22:55.485]                       }
[13:22:55.485]                       invisible(muffled)
[13:22:55.485]                     }
[13:22:55.485]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.485]                   }
[13:22:55.485]                 }
[13:22:55.485]             }
[13:22:55.485]         }))
[13:22:55.485]     }, error = function(ex) {
[13:22:55.485]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:55.485]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.485]                 ...future.rng), started = ...future.startTime, 
[13:22:55.485]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:55.485]             version = "1.8"), class = "FutureResult")
[13:22:55.485]     }, finally = {
[13:22:55.485]         if (!identical(...future.workdir, getwd())) 
[13:22:55.485]             setwd(...future.workdir)
[13:22:55.485]         {
[13:22:55.485]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:55.485]                 ...future.oldOptions$nwarnings <- NULL
[13:22:55.485]             }
[13:22:55.485]             base::options(...future.oldOptions)
[13:22:55.485]             if (.Platform$OS.type == "windows") {
[13:22:55.485]                 old_names <- names(...future.oldEnvVars)
[13:22:55.485]                 envs <- base::Sys.getenv()
[13:22:55.485]                 names <- names(envs)
[13:22:55.485]                 common <- intersect(names, old_names)
[13:22:55.485]                 added <- setdiff(names, old_names)
[13:22:55.485]                 removed <- setdiff(old_names, names)
[13:22:55.485]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:55.485]                   envs[common]]
[13:22:55.485]                 NAMES <- toupper(changed)
[13:22:55.485]                 args <- list()
[13:22:55.485]                 for (kk in seq_along(NAMES)) {
[13:22:55.485]                   name <- changed[[kk]]
[13:22:55.485]                   NAME <- NAMES[[kk]]
[13:22:55.485]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.485]                     next
[13:22:55.485]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.485]                 }
[13:22:55.485]                 NAMES <- toupper(added)
[13:22:55.485]                 for (kk in seq_along(NAMES)) {
[13:22:55.485]                   name <- added[[kk]]
[13:22:55.485]                   NAME <- NAMES[[kk]]
[13:22:55.485]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.485]                     next
[13:22:55.485]                   args[[name]] <- ""
[13:22:55.485]                 }
[13:22:55.485]                 NAMES <- toupper(removed)
[13:22:55.485]                 for (kk in seq_along(NAMES)) {
[13:22:55.485]                   name <- removed[[kk]]
[13:22:55.485]                   NAME <- NAMES[[kk]]
[13:22:55.485]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.485]                     next
[13:22:55.485]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.485]                 }
[13:22:55.485]                 if (length(args) > 0) 
[13:22:55.485]                   base::do.call(base::Sys.setenv, args = args)
[13:22:55.485]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:55.485]             }
[13:22:55.485]             else {
[13:22:55.485]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:55.485]             }
[13:22:55.485]             {
[13:22:55.485]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:55.485]                   0L) {
[13:22:55.485]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:55.485]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:55.485]                   base::options(opts)
[13:22:55.485]                 }
[13:22:55.485]                 {
[13:22:55.485]                   {
[13:22:55.485]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:55.485]                     NULL
[13:22:55.485]                   }
[13:22:55.485]                   options(future.plan = NULL)
[13:22:55.485]                   if (is.na(NA_character_)) 
[13:22:55.485]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.485]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:55.485]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:22:55.485]                     envir = parent.frame()) 
[13:22:55.485]                   {
[13:22:55.485]                     default_workers <- missing(workers)
[13:22:55.485]                     if (is.function(workers)) 
[13:22:55.485]                       workers <- workers()
[13:22:55.485]                     workers <- structure(as.integer(workers), 
[13:22:55.485]                       class = class(workers))
[13:22:55.485]                     stop_if_not(is.finite(workers), workers >= 
[13:22:55.485]                       1L)
[13:22:55.485]                     if ((workers == 1L && !inherits(workers, 
[13:22:55.485]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:22:55.485]                       if (default_workers) 
[13:22:55.485]                         supportsMulticore(warn = TRUE)
[13:22:55.485]                       return(sequential(..., envir = envir))
[13:22:55.485]                     }
[13:22:55.485]                     oopts <- options(mc.cores = workers)
[13:22:55.485]                     on.exit(options(oopts))
[13:22:55.485]                     future <- MulticoreFuture(..., workers = workers, 
[13:22:55.485]                       envir = envir)
[13:22:55.485]                     if (!future$lazy) 
[13:22:55.485]                       future <- run(future)
[13:22:55.485]                     invisible(future)
[13:22:55.485]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:55.485]                 }
[13:22:55.485]             }
[13:22:55.485]         }
[13:22:55.485]     })
[13:22:55.485]     if (TRUE) {
[13:22:55.485]         base::sink(type = "output", split = FALSE)
[13:22:55.485]         if (TRUE) {
[13:22:55.485]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:55.485]         }
[13:22:55.485]         else {
[13:22:55.485]             ...future.result["stdout"] <- base::list(NULL)
[13:22:55.485]         }
[13:22:55.485]         base::close(...future.stdout)
[13:22:55.485]         ...future.stdout <- NULL
[13:22:55.485]     }
[13:22:55.485]     ...future.result$conditions <- ...future.conditions
[13:22:55.485]     ...future.result$finished <- base::Sys.time()
[13:22:55.485]     ...future.result
[13:22:55.485] }
[13:22:55.488] requestCore(): workers = 2
[13:22:55.490] MulticoreFuture started
[13:22:55.490] - Launch lazy future ... done
[13:22:55.491] run() for ‘MulticoreFuture’ ... done
** Collecting results
[13:22:55.491] plan(): Setting new future strategy stack:
v1 = 1
v2 = 2
Warning in sprintf(...) : restarting interrupted promise evaluation
[13:22:55.492] result() for MulticoreFuture ...
[13:22:55.492] result() for MulticoreFuture ... done
[13:22:55.491] List of future strategies:
[13:22:55.491] 1. sequential:
[13:22:55.491]    - args: function (..., envir = parent.frame())
[13:22:55.491]    - tweaked: FALSE
[13:22:55.491]    - call: NULL
[13:22:55.492] result() for MulticoreFuture ...
[13:22:55.492] result() for MulticoreFuture ... done
[13:22:55.492] plan(): nbrOfWorkers() = 1
[13:22:55.493] signalConditions() ...
[13:22:55.493]  - include = ‘immediateCondition’
[13:22:55.493]  - exclude = 
[13:22:55.493]  - resignal = FALSE
[13:22:55.493]  - Number of conditions: 1
[13:22:55.493] signalConditions() ... done
[13:22:55.493] Future state: ‘finished’
[13:22:55.494] result() for MulticoreFuture ...
[13:22:55.494] result() for MulticoreFuture ... done
[13:22:55.494] signalConditions() ...
[13:22:55.494]  - include = ‘condition’
[13:22:55.494]  - exclude = ‘immediateCondition’
[13:22:55.494]  - resignal = TRUE
[13:22:55.494] plan(): Setting new future strategy stack:
[13:22:55.495]  - Number of conditions: 1
[13:22:55.495]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:22:55.495] List of future strategies:
[13:22:55.495] 1. multicore:
[13:22:55.495]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:22:55.495]    - tweaked: FALSE
[13:22:55.495]    - call: plan(strategy)
[13:22:55.495] signalConditions() ... done
v3: <simpleError> (as expect)
[13:22:55.495] result() for MulticoreFuture ...
[13:22:55.500] plan(): nbrOfWorkers() = 2
[13:22:55.501] result() for MulticoreFuture ...
[13:22:55.501] result() for MulticoreFuture ... done
[13:22:55.501] result() for MulticoreFuture ... done
[13:22:55.501] result() for MulticoreFuture ...
[13:22:55.502] result() for MulticoreFuture ... done
Processing: .......... [100%]
v4 = 4
** Left-to-right and right-to-left future assignments
[13:22:55.502] getGlobalsAndPackages() ...
[13:22:55.502] Searching for globals...
[13:22:55.503] 
[13:22:55.503] Searching for globals ... DONE
[13:22:55.503] - globals: [0] <none>
[13:22:55.503] getGlobalsAndPackages() ... DONE
[13:22:55.504] run() for ‘Future’ ...
[13:22:55.504] - state: ‘created’
[13:22:55.504] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:22:55.508] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:55.508] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:22:55.509]   - Field: ‘label’
[13:22:55.509]   - Field: ‘local’
[13:22:55.509]   - Field: ‘owner’
[13:22:55.509]   - Field: ‘envir’
[13:22:55.509]   - Field: ‘workers’
[13:22:55.509]   - Field: ‘packages’
[13:22:55.509]   - Field: ‘gc’
[13:22:55.509]   - Field: ‘job’
[13:22:55.509]   - Field: ‘conditions’
[13:22:55.510]   - Field: ‘expr’
[13:22:55.510]   - Field: ‘uuid’
[13:22:55.510]   - Field: ‘seed’
[13:22:55.510]   - Field: ‘version’
[13:22:55.510]   - Field: ‘result’
[13:22:55.510]   - Field: ‘asynchronous’
[13:22:55.510]   - Field: ‘calls’
[13:22:55.510]   - Field: ‘globals’
[13:22:55.511]   - Field: ‘stdout’
[13:22:55.511]   - Field: ‘earlySignal’
[13:22:55.511]   - Field: ‘lazy’
[13:22:55.511]   - Field: ‘state’
[13:22:55.511] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:22:55.511] - Launch lazy future ...
[13:22:55.511] Packages needed by the future expression (n = 0): <none>
[13:22:55.512] Packages needed by future strategies (n = 0): <none>
[13:22:55.512] {
[13:22:55.512]     {
[13:22:55.512]         {
[13:22:55.512]             ...future.startTime <- base::Sys.time()
[13:22:55.512]             {
[13:22:55.512]                 {
[13:22:55.512]                   {
[13:22:55.512]                     {
[13:22:55.512]                       base::local({
[13:22:55.512]                         has_future <- base::requireNamespace("future", 
[13:22:55.512]                           quietly = TRUE)
[13:22:55.512]                         if (has_future) {
[13:22:55.512]                           ns <- base::getNamespace("future")
[13:22:55.512]                           version <- ns[[".package"]][["version"]]
[13:22:55.512]                           if (is.null(version)) 
[13:22:55.512]                             version <- utils::packageVersion("future")
[13:22:55.512]                         }
[13:22:55.512]                         else {
[13:22:55.512]                           version <- NULL
[13:22:55.512]                         }
[13:22:55.512]                         if (!has_future || version < "1.8.0") {
[13:22:55.512]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:55.512]                             "", base::R.version$version.string), 
[13:22:55.512]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:55.512]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:55.512]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:55.512]                               "release", "version")], collapse = " "), 
[13:22:55.512]                             hostname = base::Sys.info()[["nodename"]])
[13:22:55.512]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:55.512]                             info)
[13:22:55.512]                           info <- base::paste(info, collapse = "; ")
[13:22:55.512]                           if (!has_future) {
[13:22:55.512]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:55.512]                               info)
[13:22:55.512]                           }
[13:22:55.512]                           else {
[13:22:55.512]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:55.512]                               info, version)
[13:22:55.512]                           }
[13:22:55.512]                           base::stop(msg)
[13:22:55.512]                         }
[13:22:55.512]                       })
[13:22:55.512]                     }
[13:22:55.512]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:55.512]                     base::options(mc.cores = 1L)
[13:22:55.512]                   }
[13:22:55.512]                   options(future.plan = NULL)
[13:22:55.512]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.512]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:55.512]                 }
[13:22:55.512]                 ...future.workdir <- getwd()
[13:22:55.512]             }
[13:22:55.512]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:55.512]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:55.512]         }
[13:22:55.512]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:55.512]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:55.512]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:55.512]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:55.512]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:55.512]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:55.512]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:55.512]             base::names(...future.oldOptions))
[13:22:55.512]     }
[13:22:55.512]     if (FALSE) {
[13:22:55.512]     }
[13:22:55.512]     else {
[13:22:55.512]         if (TRUE) {
[13:22:55.512]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:55.512]                 open = "w")
[13:22:55.512]         }
[13:22:55.512]         else {
[13:22:55.512]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:55.512]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:55.512]         }
[13:22:55.512]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:55.512]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:55.512]             base::sink(type = "output", split = FALSE)
[13:22:55.512]             base::close(...future.stdout)
[13:22:55.512]         }, add = TRUE)
[13:22:55.512]     }
[13:22:55.512]     ...future.frame <- base::sys.nframe()
[13:22:55.512]     ...future.conditions <- base::list()
[13:22:55.512]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:55.512]     if (FALSE) {
[13:22:55.512]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:55.512]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:55.512]     }
[13:22:55.512]     ...future.result <- base::tryCatch({
[13:22:55.512]         base::withCallingHandlers({
[13:22:55.512]             ...future.value <- base::withVisible(base::local({
[13:22:55.512]                 withCallingHandlers({
[13:22:55.512]                   1
[13:22:55.512]                 }, immediateCondition = function(cond) {
[13:22:55.512]                   save_rds <- function (object, pathname, ...) 
[13:22:55.512]                   {
[13:22:55.512]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:22:55.512]                     if (file_test("-f", pathname_tmp)) {
[13:22:55.512]                       fi_tmp <- file.info(pathname_tmp)
[13:22:55.512]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:22:55.512]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:55.512]                         fi_tmp[["mtime"]])
[13:22:55.512]                     }
[13:22:55.512]                     tryCatch({
[13:22:55.512]                       saveRDS(object, file = pathname_tmp, ...)
[13:22:55.512]                     }, error = function(ex) {
[13:22:55.512]                       msg <- conditionMessage(ex)
[13:22:55.512]                       fi_tmp <- file.info(pathname_tmp)
[13:22:55.512]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:22:55.512]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:55.512]                         fi_tmp[["mtime"]], msg)
[13:22:55.512]                       ex$message <- msg
[13:22:55.512]                       stop(ex)
[13:22:55.512]                     })
[13:22:55.512]                     stopifnot(file_test("-f", pathname_tmp))
[13:22:55.512]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:22:55.512]                     if (!res || file_test("-f", pathname_tmp)) {
[13:22:55.512]                       fi_tmp <- file.info(pathname_tmp)
[13:22:55.512]                       fi <- file.info(pathname)
[13:22:55.512]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:22:55.512]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:55.512]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:22:55.512]                         fi[["size"]], fi[["mtime"]])
[13:22:55.512]                       stop(msg)
[13:22:55.512]                     }
[13:22:55.512]                     invisible(pathname)
[13:22:55.512]                   }
[13:22:55.512]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:22:55.512]                     rootPath = tempdir()) 
[13:22:55.512]                   {
[13:22:55.512]                     obj <- list(time = Sys.time(), condition = cond)
[13:22:55.512]                     file <- tempfile(pattern = class(cond)[1], 
[13:22:55.512]                       tmpdir = path, fileext = ".rds")
[13:22:55.512]                     save_rds(obj, file)
[13:22:55.512]                   }
[13:22:55.512]                   saveImmediateCondition(cond, path = "/tmp/RtmphhERam/.future/immediateConditions")
[13:22:55.512]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.512]                   {
[13:22:55.512]                     inherits <- base::inherits
[13:22:55.512]                     invokeRestart <- base::invokeRestart
[13:22:55.512]                     is.null <- base::is.null
[13:22:55.512]                     muffled <- FALSE
[13:22:55.512]                     if (inherits(cond, "message")) {
[13:22:55.512]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:55.512]                       if (muffled) 
[13:22:55.512]                         invokeRestart("muffleMessage")
[13:22:55.512]                     }
[13:22:55.512]                     else if (inherits(cond, "warning")) {
[13:22:55.512]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:55.512]                       if (muffled) 
[13:22:55.512]                         invokeRestart("muffleWarning")
[13:22:55.512]                     }
[13:22:55.512]                     else if (inherits(cond, "condition")) {
[13:22:55.512]                       if (!is.null(pattern)) {
[13:22:55.512]                         computeRestarts <- base::computeRestarts
[13:22:55.512]                         grepl <- base::grepl
[13:22:55.512]                         restarts <- computeRestarts(cond)
[13:22:55.512]                         for (restart in restarts) {
[13:22:55.512]                           name <- restart$name
[13:22:55.512]                           if (is.null(name)) 
[13:22:55.512]                             next
[13:22:55.512]                           if (!grepl(pattern, name)) 
[13:22:55.512]                             next
[13:22:55.512]                           invokeRestart(restart)
[13:22:55.512]                           muffled <- TRUE
[13:22:55.512]                           break
[13:22:55.512]                         }
[13:22:55.512]                       }
[13:22:55.512]                     }
[13:22:55.512]                     invisible(muffled)
[13:22:55.512]                   }
[13:22:55.512]                   muffleCondition(cond)
[13:22:55.512]                 })
[13:22:55.512]             }))
[13:22:55.512]             future::FutureResult(value = ...future.value$value, 
[13:22:55.512]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.512]                   ...future.rng), globalenv = if (FALSE) 
[13:22:55.512]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:55.512]                     ...future.globalenv.names))
[13:22:55.512]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:55.512]         }, condition = base::local({
[13:22:55.512]             c <- base::c
[13:22:55.512]             inherits <- base::inherits
[13:22:55.512]             invokeRestart <- base::invokeRestart
[13:22:55.512]             length <- base::length
[13:22:55.512]             list <- base::list
[13:22:55.512]             seq.int <- base::seq.int
[13:22:55.512]             signalCondition <- base::signalCondition
[13:22:55.512]             sys.calls <- base::sys.calls
[13:22:55.512]             `[[` <- base::`[[`
[13:22:55.512]             `+` <- base::`+`
[13:22:55.512]             `<<-` <- base::`<<-`
[13:22:55.512]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:55.512]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:55.512]                   3L)]
[13:22:55.512]             }
[13:22:55.512]             function(cond) {
[13:22:55.512]                 is_error <- inherits(cond, "error")
[13:22:55.512]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:55.512]                   NULL)
[13:22:55.512]                 if (is_error) {
[13:22:55.512]                   sessionInformation <- function() {
[13:22:55.512]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:55.512]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:55.512]                       search = base::search(), system = base::Sys.info())
[13:22:55.512]                   }
[13:22:55.512]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.512]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:55.512]                     cond$call), session = sessionInformation(), 
[13:22:55.512]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:55.512]                   signalCondition(cond)
[13:22:55.512]                 }
[13:22:55.512]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:55.512]                 "immediateCondition"))) {
[13:22:55.512]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:55.512]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.512]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:55.512]                   if (TRUE && !signal) {
[13:22:55.512]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.512]                     {
[13:22:55.512]                       inherits <- base::inherits
[13:22:55.512]                       invokeRestart <- base::invokeRestart
[13:22:55.512]                       is.null <- base::is.null
[13:22:55.512]                       muffled <- FALSE
[13:22:55.512]                       if (inherits(cond, "message")) {
[13:22:55.512]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.512]                         if (muffled) 
[13:22:55.512]                           invokeRestart("muffleMessage")
[13:22:55.512]                       }
[13:22:55.512]                       else if (inherits(cond, "warning")) {
[13:22:55.512]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.512]                         if (muffled) 
[13:22:55.512]                           invokeRestart("muffleWarning")
[13:22:55.512]                       }
[13:22:55.512]                       else if (inherits(cond, "condition")) {
[13:22:55.512]                         if (!is.null(pattern)) {
[13:22:55.512]                           computeRestarts <- base::computeRestarts
[13:22:55.512]                           grepl <- base::grepl
[13:22:55.512]                           restarts <- computeRestarts(cond)
[13:22:55.512]                           for (restart in restarts) {
[13:22:55.512]                             name <- restart$name
[13:22:55.512]                             if (is.null(name)) 
[13:22:55.512]                               next
[13:22:55.512]                             if (!grepl(pattern, name)) 
[13:22:55.512]                               next
[13:22:55.512]                             invokeRestart(restart)
[13:22:55.512]                             muffled <- TRUE
[13:22:55.512]                             break
[13:22:55.512]                           }
[13:22:55.512]                         }
[13:22:55.512]                       }
[13:22:55.512]                       invisible(muffled)
[13:22:55.512]                     }
[13:22:55.512]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.512]                   }
[13:22:55.512]                 }
[13:22:55.512]                 else {
[13:22:55.512]                   if (TRUE) {
[13:22:55.512]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.512]                     {
[13:22:55.512]                       inherits <- base::inherits
[13:22:55.512]                       invokeRestart <- base::invokeRestart
[13:22:55.512]                       is.null <- base::is.null
[13:22:55.512]                       muffled <- FALSE
[13:22:55.512]                       if (inherits(cond, "message")) {
[13:22:55.512]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.512]                         if (muffled) 
[13:22:55.512]                           invokeRestart("muffleMessage")
[13:22:55.512]                       }
[13:22:55.512]                       else if (inherits(cond, "warning")) {
[13:22:55.512]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.512]                         if (muffled) 
[13:22:55.512]                           invokeRestart("muffleWarning")
[13:22:55.512]                       }
[13:22:55.512]                       else if (inherits(cond, "condition")) {
[13:22:55.512]                         if (!is.null(pattern)) {
[13:22:55.512]                           computeRestarts <- base::computeRestarts
[13:22:55.512]                           grepl <- base::grepl
[13:22:55.512]                           restarts <- computeRestarts(cond)
[13:22:55.512]                           for (restart in restarts) {
[13:22:55.512]                             name <- restart$name
[13:22:55.512]                             if (is.null(name)) 
[13:22:55.512]                               next
[13:22:55.512]                             if (!grepl(pattern, name)) 
[13:22:55.512]                               next
[13:22:55.512]                             invokeRestart(restart)
[13:22:55.512]                             muffled <- TRUE
[13:22:55.512]                             break
[13:22:55.512]                           }
[13:22:55.512]                         }
[13:22:55.512]                       }
[13:22:55.512]                       invisible(muffled)
[13:22:55.512]                     }
[13:22:55.512]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.512]                   }
[13:22:55.512]                 }
[13:22:55.512]             }
[13:22:55.512]         }))
[13:22:55.512]     }, error = function(ex) {
[13:22:55.512]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:55.512]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.512]                 ...future.rng), started = ...future.startTime, 
[13:22:55.512]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:55.512]             version = "1.8"), class = "FutureResult")
[13:22:55.512]     }, finally = {
[13:22:55.512]         if (!identical(...future.workdir, getwd())) 
[13:22:55.512]             setwd(...future.workdir)
[13:22:55.512]         {
[13:22:55.512]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:55.512]                 ...future.oldOptions$nwarnings <- NULL
[13:22:55.512]             }
[13:22:55.512]             base::options(...future.oldOptions)
[13:22:55.512]             if (.Platform$OS.type == "windows") {
[13:22:55.512]                 old_names <- names(...future.oldEnvVars)
[13:22:55.512]                 envs <- base::Sys.getenv()
[13:22:55.512]                 names <- names(envs)
[13:22:55.512]                 common <- intersect(names, old_names)
[13:22:55.512]                 added <- setdiff(names, old_names)
[13:22:55.512]                 removed <- setdiff(old_names, names)
[13:22:55.512]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:55.512]                   envs[common]]
[13:22:55.512]                 NAMES <- toupper(changed)
[13:22:55.512]                 args <- list()
[13:22:55.512]                 for (kk in seq_along(NAMES)) {
[13:22:55.512]                   name <- changed[[kk]]
[13:22:55.512]                   NAME <- NAMES[[kk]]
[13:22:55.512]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.512]                     next
[13:22:55.512]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.512]                 }
[13:22:55.512]                 NAMES <- toupper(added)
[13:22:55.512]                 for (kk in seq_along(NAMES)) {
[13:22:55.512]                   name <- added[[kk]]
[13:22:55.512]                   NAME <- NAMES[[kk]]
[13:22:55.512]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.512]                     next
[13:22:55.512]                   args[[name]] <- ""
[13:22:55.512]                 }
[13:22:55.512]                 NAMES <- toupper(removed)
[13:22:55.512]                 for (kk in seq_along(NAMES)) {
[13:22:55.512]                   name <- removed[[kk]]
[13:22:55.512]                   NAME <- NAMES[[kk]]
[13:22:55.512]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.512]                     next
[13:22:55.512]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.512]                 }
[13:22:55.512]                 if (length(args) > 0) 
[13:22:55.512]                   base::do.call(base::Sys.setenv, args = args)
[13:22:55.512]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:55.512]             }
[13:22:55.512]             else {
[13:22:55.512]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:55.512]             }
[13:22:55.512]             {
[13:22:55.512]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:55.512]                   0L) {
[13:22:55.512]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:55.512]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:55.512]                   base::options(opts)
[13:22:55.512]                 }
[13:22:55.512]                 {
[13:22:55.512]                   {
[13:22:55.512]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:55.512]                     NULL
[13:22:55.512]                   }
[13:22:55.512]                   options(future.plan = NULL)
[13:22:55.512]                   if (is.na(NA_character_)) 
[13:22:55.512]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.512]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:55.512]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:22:55.512]                     envir = parent.frame()) 
[13:22:55.512]                   {
[13:22:55.512]                     default_workers <- missing(workers)
[13:22:55.512]                     if (is.function(workers)) 
[13:22:55.512]                       workers <- workers()
[13:22:55.512]                     workers <- structure(as.integer(workers), 
[13:22:55.512]                       class = class(workers))
[13:22:55.512]                     stop_if_not(is.finite(workers), workers >= 
[13:22:55.512]                       1L)
[13:22:55.512]                     if ((workers == 1L && !inherits(workers, 
[13:22:55.512]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:22:55.512]                       if (default_workers) 
[13:22:55.512]                         supportsMulticore(warn = TRUE)
[13:22:55.512]                       return(sequential(..., envir = envir))
[13:22:55.512]                     }
[13:22:55.512]                     oopts <- options(mc.cores = workers)
[13:22:55.512]                     on.exit(options(oopts))
[13:22:55.512]                     future <- MulticoreFuture(..., workers = workers, 
[13:22:55.512]                       envir = envir)
[13:22:55.512]                     if (!future$lazy) 
[13:22:55.512]                       future <- run(future)
[13:22:55.512]                     invisible(future)
[13:22:55.512]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:55.512]                 }
[13:22:55.512]             }
[13:22:55.512]         }
[13:22:55.512]     })
[13:22:55.512]     if (TRUE) {
[13:22:55.512]         base::sink(type = "output", split = FALSE)
[13:22:55.512]         if (TRUE) {
[13:22:55.512]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:55.512]         }
[13:22:55.512]         else {
[13:22:55.512]             ...future.result["stdout"] <- base::list(NULL)
[13:22:55.512]         }
[13:22:55.512]         base::close(...future.stdout)
[13:22:55.512]         ...future.stdout <- NULL
[13:22:55.512]     }
[13:22:55.512]     ...future.result$conditions <- ...future.conditions
[13:22:55.512]     ...future.result$finished <- base::Sys.time()
[13:22:55.512]     ...future.result
[13:22:55.512] }
[13:22:55.515] requestCore(): workers = 2
[13:22:55.522] MulticoreFuture started
[13:22:55.522] - Launch lazy future ... done
[13:22:55.522] run() for ‘MulticoreFuture’ ... done
[13:22:55.523] plan(): Setting new future strategy stack:
[13:22:55.523] result() for MulticoreFuture ...
[13:22:55.523] List of future strategies:
[13:22:55.523] 1. sequential:
[13:22:55.523]    - args: function (..., envir = parent.frame())
[13:22:55.523]    - tweaked: FALSE
[13:22:55.523]    - call: NULL
[13:22:55.524] plan(): nbrOfWorkers() = 1
[13:22:55.526] plan(): Setting new future strategy stack:
[13:22:55.526] List of future strategies:
[13:22:55.526] 1. multicore:
[13:22:55.526]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:22:55.526]    - tweaked: FALSE
[13:22:55.526]    - call: plan(strategy)
[13:22:55.532] plan(): nbrOfWorkers() = 2
[13:22:55.533] result() for MulticoreFuture ...
[13:22:55.533] result() for MulticoreFuture ... done
[13:22:55.533] result() for MulticoreFuture ... done
[13:22:55.534] result() for MulticoreFuture ...
[13:22:55.534] result() for MulticoreFuture ... done
c = 1
[13:22:55.534] getGlobalsAndPackages() ...
[13:22:55.534] Searching for globals...
[13:22:55.535] 
[13:22:55.535] Searching for globals ... DONE
[13:22:55.535] - globals: [0] <none>
[13:22:55.535] getGlobalsAndPackages() ... DONE
[13:22:55.536] run() for ‘Future’ ...
[13:22:55.536] - state: ‘created’
[13:22:55.536] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:22:55.541] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:55.541] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:22:55.541]   - Field: ‘label’
[13:22:55.541]   - Field: ‘local’
[13:22:55.541]   - Field: ‘owner’
[13:22:55.541]   - Field: ‘envir’
[13:22:55.542]   - Field: ‘workers’
[13:22:55.542]   - Field: ‘packages’
[13:22:55.542]   - Field: ‘gc’
[13:22:55.542]   - Field: ‘job’
[13:22:55.542]   - Field: ‘conditions’
[13:22:55.542]   - Field: ‘expr’
[13:22:55.542]   - Field: ‘uuid’
[13:22:55.542]   - Field: ‘seed’
[13:22:55.542]   - Field: ‘version’
[13:22:55.543]   - Field: ‘result’
[13:22:55.543]   - Field: ‘asynchronous’
[13:22:55.543]   - Field: ‘calls’
[13:22:55.543]   - Field: ‘globals’
[13:22:55.543]   - Field: ‘stdout’
[13:22:55.543]   - Field: ‘earlySignal’
[13:22:55.543]   - Field: ‘lazy’
[13:22:55.543]   - Field: ‘state’
[13:22:55.544] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:22:55.544] - Launch lazy future ...
[13:22:55.544] Packages needed by the future expression (n = 0): <none>
[13:22:55.544] Packages needed by future strategies (n = 0): <none>
[13:22:55.545] {
[13:22:55.545]     {
[13:22:55.545]         {
[13:22:55.545]             ...future.startTime <- base::Sys.time()
[13:22:55.545]             {
[13:22:55.545]                 {
[13:22:55.545]                   {
[13:22:55.545]                     {
[13:22:55.545]                       base::local({
[13:22:55.545]                         has_future <- base::requireNamespace("future", 
[13:22:55.545]                           quietly = TRUE)
[13:22:55.545]                         if (has_future) {
[13:22:55.545]                           ns <- base::getNamespace("future")
[13:22:55.545]                           version <- ns[[".package"]][["version"]]
[13:22:55.545]                           if (is.null(version)) 
[13:22:55.545]                             version <- utils::packageVersion("future")
[13:22:55.545]                         }
[13:22:55.545]                         else {
[13:22:55.545]                           version <- NULL
[13:22:55.545]                         }
[13:22:55.545]                         if (!has_future || version < "1.8.0") {
[13:22:55.545]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:55.545]                             "", base::R.version$version.string), 
[13:22:55.545]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:55.545]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:55.545]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:55.545]                               "release", "version")], collapse = " "), 
[13:22:55.545]                             hostname = base::Sys.info()[["nodename"]])
[13:22:55.545]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:55.545]                             info)
[13:22:55.545]                           info <- base::paste(info, collapse = "; ")
[13:22:55.545]                           if (!has_future) {
[13:22:55.545]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:55.545]                               info)
[13:22:55.545]                           }
[13:22:55.545]                           else {
[13:22:55.545]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:55.545]                               info, version)
[13:22:55.545]                           }
[13:22:55.545]                           base::stop(msg)
[13:22:55.545]                         }
[13:22:55.545]                       })
[13:22:55.545]                     }
[13:22:55.545]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:55.545]                     base::options(mc.cores = 1L)
[13:22:55.545]                   }
[13:22:55.545]                   options(future.plan = NULL)
[13:22:55.545]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.545]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:55.545]                 }
[13:22:55.545]                 ...future.workdir <- getwd()
[13:22:55.545]             }
[13:22:55.545]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:55.545]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:55.545]         }
[13:22:55.545]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:55.545]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:55.545]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:55.545]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:55.545]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:55.545]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:55.545]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:55.545]             base::names(...future.oldOptions))
[13:22:55.545]     }
[13:22:55.545]     if (FALSE) {
[13:22:55.545]     }
[13:22:55.545]     else {
[13:22:55.545]         if (TRUE) {
[13:22:55.545]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:55.545]                 open = "w")
[13:22:55.545]         }
[13:22:55.545]         else {
[13:22:55.545]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:55.545]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:55.545]         }
[13:22:55.545]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:55.545]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:55.545]             base::sink(type = "output", split = FALSE)
[13:22:55.545]             base::close(...future.stdout)
[13:22:55.545]         }, add = TRUE)
[13:22:55.545]     }
[13:22:55.545]     ...future.frame <- base::sys.nframe()
[13:22:55.545]     ...future.conditions <- base::list()
[13:22:55.545]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:55.545]     if (FALSE) {
[13:22:55.545]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:55.545]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:55.545]     }
[13:22:55.545]     ...future.result <- base::tryCatch({
[13:22:55.545]         base::withCallingHandlers({
[13:22:55.545]             ...future.value <- base::withVisible(base::local({
[13:22:55.545]                 withCallingHandlers({
[13:22:55.545]                   1
[13:22:55.545]                 }, immediateCondition = function(cond) {
[13:22:55.545]                   save_rds <- function (object, pathname, ...) 
[13:22:55.545]                   {
[13:22:55.545]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:22:55.545]                     if (file_test("-f", pathname_tmp)) {
[13:22:55.545]                       fi_tmp <- file.info(pathname_tmp)
[13:22:55.545]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:22:55.545]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:55.545]                         fi_tmp[["mtime"]])
[13:22:55.545]                     }
[13:22:55.545]                     tryCatch({
[13:22:55.545]                       saveRDS(object, file = pathname_tmp, ...)
[13:22:55.545]                     }, error = function(ex) {
[13:22:55.545]                       msg <- conditionMessage(ex)
[13:22:55.545]                       fi_tmp <- file.info(pathname_tmp)
[13:22:55.545]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:22:55.545]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:55.545]                         fi_tmp[["mtime"]], msg)
[13:22:55.545]                       ex$message <- msg
[13:22:55.545]                       stop(ex)
[13:22:55.545]                     })
[13:22:55.545]                     stopifnot(file_test("-f", pathname_tmp))
[13:22:55.545]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:22:55.545]                     if (!res || file_test("-f", pathname_tmp)) {
[13:22:55.545]                       fi_tmp <- file.info(pathname_tmp)
[13:22:55.545]                       fi <- file.info(pathname)
[13:22:55.545]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:22:55.545]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:55.545]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:22:55.545]                         fi[["size"]], fi[["mtime"]])
[13:22:55.545]                       stop(msg)
[13:22:55.545]                     }
[13:22:55.545]                     invisible(pathname)
[13:22:55.545]                   }
[13:22:55.545]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:22:55.545]                     rootPath = tempdir()) 
[13:22:55.545]                   {
[13:22:55.545]                     obj <- list(time = Sys.time(), condition = cond)
[13:22:55.545]                     file <- tempfile(pattern = class(cond)[1], 
[13:22:55.545]                       tmpdir = path, fileext = ".rds")
[13:22:55.545]                     save_rds(obj, file)
[13:22:55.545]                   }
[13:22:55.545]                   saveImmediateCondition(cond, path = "/tmp/RtmphhERam/.future/immediateConditions")
[13:22:55.545]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.545]                   {
[13:22:55.545]                     inherits <- base::inherits
[13:22:55.545]                     invokeRestart <- base::invokeRestart
[13:22:55.545]                     is.null <- base::is.null
[13:22:55.545]                     muffled <- FALSE
[13:22:55.545]                     if (inherits(cond, "message")) {
[13:22:55.545]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:55.545]                       if (muffled) 
[13:22:55.545]                         invokeRestart("muffleMessage")
[13:22:55.545]                     }
[13:22:55.545]                     else if (inherits(cond, "warning")) {
[13:22:55.545]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:55.545]                       if (muffled) 
[13:22:55.545]                         invokeRestart("muffleWarning")
[13:22:55.545]                     }
[13:22:55.545]                     else if (inherits(cond, "condition")) {
[13:22:55.545]                       if (!is.null(pattern)) {
[13:22:55.545]                         computeRestarts <- base::computeRestarts
[13:22:55.545]                         grepl <- base::grepl
[13:22:55.545]                         restarts <- computeRestarts(cond)
[13:22:55.545]                         for (restart in restarts) {
[13:22:55.545]                           name <- restart$name
[13:22:55.545]                           if (is.null(name)) 
[13:22:55.545]                             next
[13:22:55.545]                           if (!grepl(pattern, name)) 
[13:22:55.545]                             next
[13:22:55.545]                           invokeRestart(restart)
[13:22:55.545]                           muffled <- TRUE
[13:22:55.545]                           break
[13:22:55.545]                         }
[13:22:55.545]                       }
[13:22:55.545]                     }
[13:22:55.545]                     invisible(muffled)
[13:22:55.545]                   }
[13:22:55.545]                   muffleCondition(cond)
[13:22:55.545]                 })
[13:22:55.545]             }))
[13:22:55.545]             future::FutureResult(value = ...future.value$value, 
[13:22:55.545]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.545]                   ...future.rng), globalenv = if (FALSE) 
[13:22:55.545]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:55.545]                     ...future.globalenv.names))
[13:22:55.545]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:55.545]         }, condition = base::local({
[13:22:55.545]             c <- base::c
[13:22:55.545]             inherits <- base::inherits
[13:22:55.545]             invokeRestart <- base::invokeRestart
[13:22:55.545]             length <- base::length
[13:22:55.545]             list <- base::list
[13:22:55.545]             seq.int <- base::seq.int
[13:22:55.545]             signalCondition <- base::signalCondition
[13:22:55.545]             sys.calls <- base::sys.calls
[13:22:55.545]             `[[` <- base::`[[`
[13:22:55.545]             `+` <- base::`+`
[13:22:55.545]             `<<-` <- base::`<<-`
[13:22:55.545]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:55.545]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:55.545]                   3L)]
[13:22:55.545]             }
[13:22:55.545]             function(cond) {
[13:22:55.545]                 is_error <- inherits(cond, "error")
[13:22:55.545]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:55.545]                   NULL)
[13:22:55.545]                 if (is_error) {
[13:22:55.545]                   sessionInformation <- function() {
[13:22:55.545]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:55.545]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:55.545]                       search = base::search(), system = base::Sys.info())
[13:22:55.545]                   }
[13:22:55.545]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.545]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:55.545]                     cond$call), session = sessionInformation(), 
[13:22:55.545]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:55.545]                   signalCondition(cond)
[13:22:55.545]                 }
[13:22:55.545]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:55.545]                 "immediateCondition"))) {
[13:22:55.545]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:55.545]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.545]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:55.545]                   if (TRUE && !signal) {
[13:22:55.545]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.545]                     {
[13:22:55.545]                       inherits <- base::inherits
[13:22:55.545]                       invokeRestart <- base::invokeRestart
[13:22:55.545]                       is.null <- base::is.null
[13:22:55.545]                       muffled <- FALSE
[13:22:55.545]                       if (inherits(cond, "message")) {
[13:22:55.545]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.545]                         if (muffled) 
[13:22:55.545]                           invokeRestart("muffleMessage")
[13:22:55.545]                       }
[13:22:55.545]                       else if (inherits(cond, "warning")) {
[13:22:55.545]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.545]                         if (muffled) 
[13:22:55.545]                           invokeRestart("muffleWarning")
[13:22:55.545]                       }
[13:22:55.545]                       else if (inherits(cond, "condition")) {
[13:22:55.545]                         if (!is.null(pattern)) {
[13:22:55.545]                           computeRestarts <- base::computeRestarts
[13:22:55.545]                           grepl <- base::grepl
[13:22:55.545]                           restarts <- computeRestarts(cond)
[13:22:55.545]                           for (restart in restarts) {
[13:22:55.545]                             name <- restart$name
[13:22:55.545]                             if (is.null(name)) 
[13:22:55.545]                               next
[13:22:55.545]                             if (!grepl(pattern, name)) 
[13:22:55.545]                               next
[13:22:55.545]                             invokeRestart(restart)
[13:22:55.545]                             muffled <- TRUE
[13:22:55.545]                             break
[13:22:55.545]                           }
[13:22:55.545]                         }
[13:22:55.545]                       }
[13:22:55.545]                       invisible(muffled)
[13:22:55.545]                     }
[13:22:55.545]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.545]                   }
[13:22:55.545]                 }
[13:22:55.545]                 else {
[13:22:55.545]                   if (TRUE) {
[13:22:55.545]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.545]                     {
[13:22:55.545]                       inherits <- base::inherits
[13:22:55.545]                       invokeRestart <- base::invokeRestart
[13:22:55.545]                       is.null <- base::is.null
[13:22:55.545]                       muffled <- FALSE
[13:22:55.545]                       if (inherits(cond, "message")) {
[13:22:55.545]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.545]                         if (muffled) 
[13:22:55.545]                           invokeRestart("muffleMessage")
[13:22:55.545]                       }
[13:22:55.545]                       else if (inherits(cond, "warning")) {
[13:22:55.545]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.545]                         if (muffled) 
[13:22:55.545]                           invokeRestart("muffleWarning")
[13:22:55.545]                       }
[13:22:55.545]                       else if (inherits(cond, "condition")) {
[13:22:55.545]                         if (!is.null(pattern)) {
[13:22:55.545]                           computeRestarts <- base::computeRestarts
[13:22:55.545]                           grepl <- base::grepl
[13:22:55.545]                           restarts <- computeRestarts(cond)
[13:22:55.545]                           for (restart in restarts) {
[13:22:55.545]                             name <- restart$name
[13:22:55.545]                             if (is.null(name)) 
[13:22:55.545]                               next
[13:22:55.545]                             if (!grepl(pattern, name)) 
[13:22:55.545]                               next
[13:22:55.545]                             invokeRestart(restart)
[13:22:55.545]                             muffled <- TRUE
[13:22:55.545]                             break
[13:22:55.545]                           }
[13:22:55.545]                         }
[13:22:55.545]                       }
[13:22:55.545]                       invisible(muffled)
[13:22:55.545]                     }
[13:22:55.545]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.545]                   }
[13:22:55.545]                 }
[13:22:55.545]             }
[13:22:55.545]         }))
[13:22:55.545]     }, error = function(ex) {
[13:22:55.545]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:55.545]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.545]                 ...future.rng), started = ...future.startTime, 
[13:22:55.545]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:55.545]             version = "1.8"), class = "FutureResult")
[13:22:55.545]     }, finally = {
[13:22:55.545]         if (!identical(...future.workdir, getwd())) 
[13:22:55.545]             setwd(...future.workdir)
[13:22:55.545]         {
[13:22:55.545]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:55.545]                 ...future.oldOptions$nwarnings <- NULL
[13:22:55.545]             }
[13:22:55.545]             base::options(...future.oldOptions)
[13:22:55.545]             if (.Platform$OS.type == "windows") {
[13:22:55.545]                 old_names <- names(...future.oldEnvVars)
[13:22:55.545]                 envs <- base::Sys.getenv()
[13:22:55.545]                 names <- names(envs)
[13:22:55.545]                 common <- intersect(names, old_names)
[13:22:55.545]                 added <- setdiff(names, old_names)
[13:22:55.545]                 removed <- setdiff(old_names, names)
[13:22:55.545]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:55.545]                   envs[common]]
[13:22:55.545]                 NAMES <- toupper(changed)
[13:22:55.545]                 args <- list()
[13:22:55.545]                 for (kk in seq_along(NAMES)) {
[13:22:55.545]                   name <- changed[[kk]]
[13:22:55.545]                   NAME <- NAMES[[kk]]
[13:22:55.545]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.545]                     next
[13:22:55.545]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.545]                 }
[13:22:55.545]                 NAMES <- toupper(added)
[13:22:55.545]                 for (kk in seq_along(NAMES)) {
[13:22:55.545]                   name <- added[[kk]]
[13:22:55.545]                   NAME <- NAMES[[kk]]
[13:22:55.545]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.545]                     next
[13:22:55.545]                   args[[name]] <- ""
[13:22:55.545]                 }
[13:22:55.545]                 NAMES <- toupper(removed)
[13:22:55.545]                 for (kk in seq_along(NAMES)) {
[13:22:55.545]                   name <- removed[[kk]]
[13:22:55.545]                   NAME <- NAMES[[kk]]
[13:22:55.545]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.545]                     next
[13:22:55.545]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.545]                 }
[13:22:55.545]                 if (length(args) > 0) 
[13:22:55.545]                   base::do.call(base::Sys.setenv, args = args)
[13:22:55.545]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:55.545]             }
[13:22:55.545]             else {
[13:22:55.545]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:55.545]             }
[13:22:55.545]             {
[13:22:55.545]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:55.545]                   0L) {
[13:22:55.545]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:55.545]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:55.545]                   base::options(opts)
[13:22:55.545]                 }
[13:22:55.545]                 {
[13:22:55.545]                   {
[13:22:55.545]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:55.545]                     NULL
[13:22:55.545]                   }
[13:22:55.545]                   options(future.plan = NULL)
[13:22:55.545]                   if (is.na(NA_character_)) 
[13:22:55.545]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.545]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:55.545]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:22:55.545]                     envir = parent.frame()) 
[13:22:55.545]                   {
[13:22:55.545]                     default_workers <- missing(workers)
[13:22:55.545]                     if (is.function(workers)) 
[13:22:55.545]                       workers <- workers()
[13:22:55.545]                     workers <- structure(as.integer(workers), 
[13:22:55.545]                       class = class(workers))
[13:22:55.545]                     stop_if_not(is.finite(workers), workers >= 
[13:22:55.545]                       1L)
[13:22:55.545]                     if ((workers == 1L && !inherits(workers, 
[13:22:55.545]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:22:55.545]                       if (default_workers) 
[13:22:55.545]                         supportsMulticore(warn = TRUE)
[13:22:55.545]                       return(sequential(..., envir = envir))
[13:22:55.545]                     }
[13:22:55.545]                     oopts <- options(mc.cores = workers)
[13:22:55.545]                     on.exit(options(oopts))
[13:22:55.545]                     future <- MulticoreFuture(..., workers = workers, 
[13:22:55.545]                       envir = envir)
[13:22:55.545]                     if (!future$lazy) 
[13:22:55.545]                       future <- run(future)
[13:22:55.545]                     invisible(future)
[13:22:55.545]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:55.545]                 }
[13:22:55.545]             }
[13:22:55.545]         }
[13:22:55.545]     })
[13:22:55.545]     if (TRUE) {
[13:22:55.545]         base::sink(type = "output", split = FALSE)
[13:22:55.545]         if (TRUE) {
[13:22:55.545]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:55.545]         }
[13:22:55.545]         else {
[13:22:55.545]             ...future.result["stdout"] <- base::list(NULL)
[13:22:55.545]         }
[13:22:55.545]         base::close(...future.stdout)
[13:22:55.545]         ...future.stdout <- NULL
[13:22:55.545]     }
[13:22:55.545]     ...future.result$conditions <- ...future.conditions
[13:22:55.545]     ...future.result$finished <- base::Sys.time()
[13:22:55.545]     ...future.result
[13:22:55.545] }
[13:22:55.547] requestCore(): workers = 2
[13:22:55.550] MulticoreFuture started
[13:22:55.550] - Launch lazy future ... done
[13:22:55.550] run() for ‘MulticoreFuture’ ... done
[13:22:55.551] result() for MulticoreFuture ...
[13:22:55.551] plan(): Setting new future strategy stack:
[13:22:55.551] List of future strategies:
[13:22:55.551] 1. sequential:
[13:22:55.551]    - args: function (..., envir = parent.frame())
[13:22:55.551]    - tweaked: FALSE
[13:22:55.551]    - call: NULL
[13:22:55.552] plan(): nbrOfWorkers() = 1
[13:22:55.554] plan(): Setting new future strategy stack:
[13:22:55.555] List of future strategies:
[13:22:55.555] 1. multicore:
[13:22:55.555]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:22:55.555]    - tweaked: FALSE
[13:22:55.555]    - call: plan(strategy)
[13:22:55.560] plan(): nbrOfWorkers() = 2
[13:22:55.561] result() for MulticoreFuture ...
[13:22:55.561] result() for MulticoreFuture ... done
[13:22:55.561] result() for MulticoreFuture ... done
[13:22:55.561] result() for MulticoreFuture ...
[13:22:55.561] result() for MulticoreFuture ... done
d = 1
** Nested future assignments
[13:22:55.562] getGlobalsAndPackages() ...
[13:22:55.562] Searching for globals...
[13:22:55.567] - globals found: [5] ‘{’, ‘<-’, ‘%<-%’, ‘%->%’, ‘+’
[13:22:55.568] Searching for globals ... DONE
[13:22:55.568] Resolving globals: FALSE
[13:22:55.568] 
[13:22:55.568] - packages: [1] ‘future’
[13:22:55.569] getGlobalsAndPackages() ... DONE
[13:22:55.569] run() for ‘Future’ ...
[13:22:55.569] - state: ‘created’
[13:22:55.569] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:22:55.574] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:55.574] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:22:55.574]   - Field: ‘label’
[13:22:55.574]   - Field: ‘local’
[13:22:55.574]   - Field: ‘owner’
[13:22:55.574]   - Field: ‘envir’
[13:22:55.575]   - Field: ‘workers’
[13:22:55.575]   - Field: ‘packages’
[13:22:55.575]   - Field: ‘gc’
[13:22:55.575]   - Field: ‘job’
[13:22:55.575]   - Field: ‘conditions’
[13:22:55.575]   - Field: ‘expr’
[13:22:55.575]   - Field: ‘uuid’
[13:22:55.575]   - Field: ‘seed’
[13:22:55.576]   - Field: ‘version’
[13:22:55.576]   - Field: ‘result’
[13:22:55.576]   - Field: ‘asynchronous’
[13:22:55.576]   - Field: ‘calls’
[13:22:55.579]   - Field: ‘globals’
[13:22:55.579]   - Field: ‘stdout’
[13:22:55.579]   - Field: ‘earlySignal’
[13:22:55.579]   - Field: ‘lazy’
[13:22:55.579]   - Field: ‘state’
[13:22:55.579] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:22:55.580] - Launch lazy future ...
[13:22:55.580] Packages needed by the future expression (n = 1): ‘future’
[13:22:55.580] Packages needed by future strategies (n = 0): <none>
[13:22:55.581] {
[13:22:55.581]     {
[13:22:55.581]         {
[13:22:55.581]             ...future.startTime <- base::Sys.time()
[13:22:55.581]             {
[13:22:55.581]                 {
[13:22:55.581]                   {
[13:22:55.581]                     {
[13:22:55.581]                       {
[13:22:55.581]                         base::local({
[13:22:55.581]                           has_future <- base::requireNamespace("future", 
[13:22:55.581]                             quietly = TRUE)
[13:22:55.581]                           if (has_future) {
[13:22:55.581]                             ns <- base::getNamespace("future")
[13:22:55.581]                             version <- ns[[".package"]][["version"]]
[13:22:55.581]                             if (is.null(version)) 
[13:22:55.581]                               version <- utils::packageVersion("future")
[13:22:55.581]                           }
[13:22:55.581]                           else {
[13:22:55.581]                             version <- NULL
[13:22:55.581]                           }
[13:22:55.581]                           if (!has_future || version < "1.8.0") {
[13:22:55.581]                             info <- base::c(r_version = base::gsub("R version ", 
[13:22:55.581]                               "", base::R.version$version.string), 
[13:22:55.581]                               platform = base::sprintf("%s (%s-bit)", 
[13:22:55.581]                                 base::R.version$platform, 8 * 
[13:22:55.581]                                   base::.Machine$sizeof.pointer), 
[13:22:55.581]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:55.581]                                 "release", "version")], collapse = " "), 
[13:22:55.581]                               hostname = base::Sys.info()[["nodename"]])
[13:22:55.581]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:22:55.581]                               info)
[13:22:55.581]                             info <- base::paste(info, collapse = "; ")
[13:22:55.581]                             if (!has_future) {
[13:22:55.581]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:55.581]                                 info)
[13:22:55.581]                             }
[13:22:55.581]                             else {
[13:22:55.581]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:55.581]                                 info, version)
[13:22:55.581]                             }
[13:22:55.581]                             base::stop(msg)
[13:22:55.581]                           }
[13:22:55.581]                         })
[13:22:55.581]                       }
[13:22:55.581]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:55.581]                       base::options(mc.cores = 1L)
[13:22:55.581]                     }
[13:22:55.581]                     base::local({
[13:22:55.581]                       for (pkg in "future") {
[13:22:55.581]                         base::loadNamespace(pkg)
[13:22:55.581]                         base::library(pkg, character.only = TRUE)
[13:22:55.581]                       }
[13:22:55.581]                     })
[13:22:55.581]                   }
[13:22:55.581]                   options(future.plan = NULL)
[13:22:55.581]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.581]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:55.581]                 }
[13:22:55.581]                 ...future.workdir <- getwd()
[13:22:55.581]             }
[13:22:55.581]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:55.581]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:55.581]         }
[13:22:55.581]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:55.581]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:55.581]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:55.581]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:55.581]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:55.581]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:55.581]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:55.581]             base::names(...future.oldOptions))
[13:22:55.581]     }
[13:22:55.581]     if (FALSE) {
[13:22:55.581]     }
[13:22:55.581]     else {
[13:22:55.581]         if (TRUE) {
[13:22:55.581]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:55.581]                 open = "w")
[13:22:55.581]         }
[13:22:55.581]         else {
[13:22:55.581]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:55.581]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:55.581]         }
[13:22:55.581]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:55.581]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:55.581]             base::sink(type = "output", split = FALSE)
[13:22:55.581]             base::close(...future.stdout)
[13:22:55.581]         }, add = TRUE)
[13:22:55.581]     }
[13:22:55.581]     ...future.frame <- base::sys.nframe()
[13:22:55.581]     ...future.conditions <- base::list()
[13:22:55.581]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:55.581]     if (FALSE) {
[13:22:55.581]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:55.581]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:55.581]     }
[13:22:55.581]     ...future.result <- base::tryCatch({
[13:22:55.581]         base::withCallingHandlers({
[13:22:55.581]             ...future.value <- base::withVisible(base::local({
[13:22:55.581]                 withCallingHandlers({
[13:22:55.581]                   {
[13:22:55.581]                     b <- 1
[13:22:55.581]                     c %<-% 2
[13:22:55.581]                     d <- 3
[13:22:55.581]                     4 %->% e
[13:22:55.581]                     b + c + d + e
[13:22:55.581]                   }
[13:22:55.581]                 }, immediateCondition = function(cond) {
[13:22:55.581]                   save_rds <- function (object, pathname, ...) 
[13:22:55.581]                   {
[13:22:55.581]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:22:55.581]                     if (file_test("-f", pathname_tmp)) {
[13:22:55.581]                       fi_tmp <- file.info(pathname_tmp)
[13:22:55.581]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:22:55.581]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:55.581]                         fi_tmp[["mtime"]])
[13:22:55.581]                     }
[13:22:55.581]                     tryCatch({
[13:22:55.581]                       saveRDS(object, file = pathname_tmp, ...)
[13:22:55.581]                     }, error = function(ex) {
[13:22:55.581]                       msg <- conditionMessage(ex)
[13:22:55.581]                       fi_tmp <- file.info(pathname_tmp)
[13:22:55.581]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:22:55.581]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:55.581]                         fi_tmp[["mtime"]], msg)
[13:22:55.581]                       ex$message <- msg
[13:22:55.581]                       stop(ex)
[13:22:55.581]                     })
[13:22:55.581]                     stopifnot(file_test("-f", pathname_tmp))
[13:22:55.581]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:22:55.581]                     if (!res || file_test("-f", pathname_tmp)) {
[13:22:55.581]                       fi_tmp <- file.info(pathname_tmp)
[13:22:55.581]                       fi <- file.info(pathname)
[13:22:55.581]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:22:55.581]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:55.581]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:22:55.581]                         fi[["size"]], fi[["mtime"]])
[13:22:55.581]                       stop(msg)
[13:22:55.581]                     }
[13:22:55.581]                     invisible(pathname)
[13:22:55.581]                   }
[13:22:55.581]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:22:55.581]                     rootPath = tempdir()) 
[13:22:55.581]                   {
[13:22:55.581]                     obj <- list(time = Sys.time(), condition = cond)
[13:22:55.581]                     file <- tempfile(pattern = class(cond)[1], 
[13:22:55.581]                       tmpdir = path, fileext = ".rds")
[13:22:55.581]                     save_rds(obj, file)
[13:22:55.581]                   }
[13:22:55.581]                   saveImmediateCondition(cond, path = "/tmp/RtmphhERam/.future/immediateConditions")
[13:22:55.581]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.581]                   {
[13:22:55.581]                     inherits <- base::inherits
[13:22:55.581]                     invokeRestart <- base::invokeRestart
[13:22:55.581]                     is.null <- base::is.null
[13:22:55.581]                     muffled <- FALSE
[13:22:55.581]                     if (inherits(cond, "message")) {
[13:22:55.581]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:55.581]                       if (muffled) 
[13:22:55.581]                         invokeRestart("muffleMessage")
[13:22:55.581]                     }
[13:22:55.581]                     else if (inherits(cond, "warning")) {
[13:22:55.581]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:55.581]                       if (muffled) 
[13:22:55.581]                         invokeRestart("muffleWarning")
[13:22:55.581]                     }
[13:22:55.581]                     else if (inherits(cond, "condition")) {
[13:22:55.581]                       if (!is.null(pattern)) {
[13:22:55.581]                         computeRestarts <- base::computeRestarts
[13:22:55.581]                         grepl <- base::grepl
[13:22:55.581]                         restarts <- computeRestarts(cond)
[13:22:55.581]                         for (restart in restarts) {
[13:22:55.581]                           name <- restart$name
[13:22:55.581]                           if (is.null(name)) 
[13:22:55.581]                             next
[13:22:55.581]                           if (!grepl(pattern, name)) 
[13:22:55.581]                             next
[13:22:55.581]                           invokeRestart(restart)
[13:22:55.581]                           muffled <- TRUE
[13:22:55.581]                           break
[13:22:55.581]                         }
[13:22:55.581]                       }
[13:22:55.581]                     }
[13:22:55.581]                     invisible(muffled)
[13:22:55.581]                   }
[13:22:55.581]                   muffleCondition(cond)
[13:22:55.581]                 })
[13:22:55.581]             }))
[13:22:55.581]             future::FutureResult(value = ...future.value$value, 
[13:22:55.581]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.581]                   ...future.rng), globalenv = if (FALSE) 
[13:22:55.581]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:55.581]                     ...future.globalenv.names))
[13:22:55.581]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:55.581]         }, condition = base::local({
[13:22:55.581]             c <- base::c
[13:22:55.581]             inherits <- base::inherits
[13:22:55.581]             invokeRestart <- base::invokeRestart
[13:22:55.581]             length <- base::length
[13:22:55.581]             list <- base::list
[13:22:55.581]             seq.int <- base::seq.int
[13:22:55.581]             signalCondition <- base::signalCondition
[13:22:55.581]             sys.calls <- base::sys.calls
[13:22:55.581]             `[[` <- base::`[[`
[13:22:55.581]             `+` <- base::`+`
[13:22:55.581]             `<<-` <- base::`<<-`
[13:22:55.581]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:55.581]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:55.581]                   3L)]
[13:22:55.581]             }
[13:22:55.581]             function(cond) {
[13:22:55.581]                 is_error <- inherits(cond, "error")
[13:22:55.581]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:55.581]                   NULL)
[13:22:55.581]                 if (is_error) {
[13:22:55.581]                   sessionInformation <- function() {
[13:22:55.581]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:55.581]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:55.581]                       search = base::search(), system = base::Sys.info())
[13:22:55.581]                   }
[13:22:55.581]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.581]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:55.581]                     cond$call), session = sessionInformation(), 
[13:22:55.581]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:55.581]                   signalCondition(cond)
[13:22:55.581]                 }
[13:22:55.581]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:55.581]                 "immediateCondition"))) {
[13:22:55.581]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:55.581]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.581]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:55.581]                   if (TRUE && !signal) {
[13:22:55.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.581]                     {
[13:22:55.581]                       inherits <- base::inherits
[13:22:55.581]                       invokeRestart <- base::invokeRestart
[13:22:55.581]                       is.null <- base::is.null
[13:22:55.581]                       muffled <- FALSE
[13:22:55.581]                       if (inherits(cond, "message")) {
[13:22:55.581]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.581]                         if (muffled) 
[13:22:55.581]                           invokeRestart("muffleMessage")
[13:22:55.581]                       }
[13:22:55.581]                       else if (inherits(cond, "warning")) {
[13:22:55.581]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.581]                         if (muffled) 
[13:22:55.581]                           invokeRestart("muffleWarning")
[13:22:55.581]                       }
[13:22:55.581]                       else if (inherits(cond, "condition")) {
[13:22:55.581]                         if (!is.null(pattern)) {
[13:22:55.581]                           computeRestarts <- base::computeRestarts
[13:22:55.581]                           grepl <- base::grepl
[13:22:55.581]                           restarts <- computeRestarts(cond)
[13:22:55.581]                           for (restart in restarts) {
[13:22:55.581]                             name <- restart$name
[13:22:55.581]                             if (is.null(name)) 
[13:22:55.581]                               next
[13:22:55.581]                             if (!grepl(pattern, name)) 
[13:22:55.581]                               next
[13:22:55.581]                             invokeRestart(restart)
[13:22:55.581]                             muffled <- TRUE
[13:22:55.581]                             break
[13:22:55.581]                           }
[13:22:55.581]                         }
[13:22:55.581]                       }
[13:22:55.581]                       invisible(muffled)
[13:22:55.581]                     }
[13:22:55.581]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.581]                   }
[13:22:55.581]                 }
[13:22:55.581]                 else {
[13:22:55.581]                   if (TRUE) {
[13:22:55.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.581]                     {
[13:22:55.581]                       inherits <- base::inherits
[13:22:55.581]                       invokeRestart <- base::invokeRestart
[13:22:55.581]                       is.null <- base::is.null
[13:22:55.581]                       muffled <- FALSE
[13:22:55.581]                       if (inherits(cond, "message")) {
[13:22:55.581]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.581]                         if (muffled) 
[13:22:55.581]                           invokeRestart("muffleMessage")
[13:22:55.581]                       }
[13:22:55.581]                       else if (inherits(cond, "warning")) {
[13:22:55.581]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.581]                         if (muffled) 
[13:22:55.581]                           invokeRestart("muffleWarning")
[13:22:55.581]                       }
[13:22:55.581]                       else if (inherits(cond, "condition")) {
[13:22:55.581]                         if (!is.null(pattern)) {
[13:22:55.581]                           computeRestarts <- base::computeRestarts
[13:22:55.581]                           grepl <- base::grepl
[13:22:55.581]                           restarts <- computeRestarts(cond)
[13:22:55.581]                           for (restart in restarts) {
[13:22:55.581]                             name <- restart$name
[13:22:55.581]                             if (is.null(name)) 
[13:22:55.581]                               next
[13:22:55.581]                             if (!grepl(pattern, name)) 
[13:22:55.581]                               next
[13:22:55.581]                             invokeRestart(restart)
[13:22:55.581]                             muffled <- TRUE
[13:22:55.581]                             break
[13:22:55.581]                           }
[13:22:55.581]                         }
[13:22:55.581]                       }
[13:22:55.581]                       invisible(muffled)
[13:22:55.581]                     }
[13:22:55.581]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.581]                   }
[13:22:55.581]                 }
[13:22:55.581]             }
[13:22:55.581]         }))
[13:22:55.581]     }, error = function(ex) {
[13:22:55.581]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:55.581]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.581]                 ...future.rng), started = ...future.startTime, 
[13:22:55.581]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:55.581]             version = "1.8"), class = "FutureResult")
[13:22:55.581]     }, finally = {
[13:22:55.581]         if (!identical(...future.workdir, getwd())) 
[13:22:55.581]             setwd(...future.workdir)
[13:22:55.581]         {
[13:22:55.581]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:55.581]                 ...future.oldOptions$nwarnings <- NULL
[13:22:55.581]             }
[13:22:55.581]             base::options(...future.oldOptions)
[13:22:55.581]             if (.Platform$OS.type == "windows") {
[13:22:55.581]                 old_names <- names(...future.oldEnvVars)
[13:22:55.581]                 envs <- base::Sys.getenv()
[13:22:55.581]                 names <- names(envs)
[13:22:55.581]                 common <- intersect(names, old_names)
[13:22:55.581]                 added <- setdiff(names, old_names)
[13:22:55.581]                 removed <- setdiff(old_names, names)
[13:22:55.581]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:55.581]                   envs[common]]
[13:22:55.581]                 NAMES <- toupper(changed)
[13:22:55.581]                 args <- list()
[13:22:55.581]                 for (kk in seq_along(NAMES)) {
[13:22:55.581]                   name <- changed[[kk]]
[13:22:55.581]                   NAME <- NAMES[[kk]]
[13:22:55.581]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.581]                     next
[13:22:55.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.581]                 }
[13:22:55.581]                 NAMES <- toupper(added)
[13:22:55.581]                 for (kk in seq_along(NAMES)) {
[13:22:55.581]                   name <- added[[kk]]
[13:22:55.581]                   NAME <- NAMES[[kk]]
[13:22:55.581]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.581]                     next
[13:22:55.581]                   args[[name]] <- ""
[13:22:55.581]                 }
[13:22:55.581]                 NAMES <- toupper(removed)
[13:22:55.581]                 for (kk in seq_along(NAMES)) {
[13:22:55.581]                   name <- removed[[kk]]
[13:22:55.581]                   NAME <- NAMES[[kk]]
[13:22:55.581]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.581]                     next
[13:22:55.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.581]                 }
[13:22:55.581]                 if (length(args) > 0) 
[13:22:55.581]                   base::do.call(base::Sys.setenv, args = args)
[13:22:55.581]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:55.581]             }
[13:22:55.581]             else {
[13:22:55.581]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:55.581]             }
[13:22:55.581]             {
[13:22:55.581]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:55.581]                   0L) {
[13:22:55.581]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:55.581]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:55.581]                   base::options(opts)
[13:22:55.581]                 }
[13:22:55.581]                 {
[13:22:55.581]                   {
[13:22:55.581]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:55.581]                     NULL
[13:22:55.581]                   }
[13:22:55.581]                   options(future.plan = NULL)
[13:22:55.581]                   if (is.na(NA_character_)) 
[13:22:55.581]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.581]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:55.581]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:22:55.581]                     envir = parent.frame()) 
[13:22:55.581]                   {
[13:22:55.581]                     default_workers <- missing(workers)
[13:22:55.581]                     if (is.function(workers)) 
[13:22:55.581]                       workers <- workers()
[13:22:55.581]                     workers <- structure(as.integer(workers), 
[13:22:55.581]                       class = class(workers))
[13:22:55.581]                     stop_if_not(is.finite(workers), workers >= 
[13:22:55.581]                       1L)
[13:22:55.581]                     if ((workers == 1L && !inherits(workers, 
[13:22:55.581]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:22:55.581]                       if (default_workers) 
[13:22:55.581]                         supportsMulticore(warn = TRUE)
[13:22:55.581]                       return(sequential(..., envir = envir))
[13:22:55.581]                     }
[13:22:55.581]                     oopts <- options(mc.cores = workers)
[13:22:55.581]                     on.exit(options(oopts))
[13:22:55.581]                     future <- MulticoreFuture(..., workers = workers, 
[13:22:55.581]                       envir = envir)
[13:22:55.581]                     if (!future$lazy) 
[13:22:55.581]                       future <- run(future)
[13:22:55.581]                     invisible(future)
[13:22:55.581]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:55.581]                 }
[13:22:55.581]             }
[13:22:55.581]         }
[13:22:55.581]     })
[13:22:55.581]     if (TRUE) {
[13:22:55.581]         base::sink(type = "output", split = FALSE)
[13:22:55.581]         if (TRUE) {
[13:22:55.581]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:55.581]         }
[13:22:55.581]         else {
[13:22:55.581]             ...future.result["stdout"] <- base::list(NULL)
[13:22:55.581]         }
[13:22:55.581]         base::close(...future.stdout)
[13:22:55.581]         ...future.stdout <- NULL
[13:22:55.581]     }
[13:22:55.581]     ...future.result$conditions <- ...future.conditions
[13:22:55.581]     ...future.result$finished <- base::Sys.time()
[13:22:55.581]     ...future.result
[13:22:55.581] }
[13:22:55.584] requestCore(): workers = 2
[13:22:55.586] MulticoreFuture started
[13:22:55.587] - Launch lazy future ... done
[13:22:55.587] run() for ‘MulticoreFuture’ ... done
[13:22:55.588] result() for MulticoreFuture ...
[13:22:55.588] plan(): Setting new future strategy stack:
[13:22:55.588] List of future strategies:
[13:22:55.588] 1. sequential:
[13:22:55.588]    - args: function (..., envir = parent.frame())
[13:22:55.588]    - tweaked: FALSE
[13:22:55.588]    - call: NULL
[13:22:55.589] plan(): nbrOfWorkers() = 1
[13:22:55.625] plan(): Setting new future strategy stack:
[13:22:55.625] List of future strategies:
[13:22:55.625] 1. multicore:
[13:22:55.625]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:22:55.625]    - tweaked: FALSE
[13:22:55.625]    - call: plan(strategy)
[13:22:55.630] plan(): nbrOfWorkers() = 2
[13:22:55.632] result() for MulticoreFuture ...
[13:22:55.632] result() for MulticoreFuture ... done
[13:22:55.632] signalConditions() ...
[13:22:55.632]  - include = ‘immediateCondition’
[13:22:55.632]  - exclude = 
[13:22:55.632]  - resignal = FALSE
[13:22:55.633]  - Number of conditions: 88
[13:22:55.633] signalConditions() ... done
[13:22:55.633] result() for MulticoreFuture ... done
[13:22:55.633] result() for MulticoreFuture ...
[13:22:55.633] result() for MulticoreFuture ... done
[13:22:55.633] signalConditions() ...
[13:22:55.633]  - include = ‘immediateCondition’
[13:22:55.634]  - exclude = 
[13:22:55.634]  - resignal = FALSE
[13:22:55.634]  - Number of conditions: 88
[13:22:55.634] signalConditions() ... done
[13:22:55.634] Future state: ‘finished’
[13:22:55.634] result() for MulticoreFuture ...
[13:22:55.635] result() for MulticoreFuture ... done
[13:22:55.635] signalConditions() ...
[13:22:55.635]  - include = ‘condition’
[13:22:55.635]  - exclude = ‘immediateCondition’
[13:22:55.635]  - resignal = TRUE
[13:22:55.635]  - Number of conditions: 88
[13:22:55.635]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.591] getGlobalsAndPackages() ...
[13:22:55.635]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.591] Searching for globals...
[13:22:55.636]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.592] 
[13:22:55.636]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.592] Searching for globals ... DONE
[13:22:55.636]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.593] - globals: [0] <none>
[13:22:55.636]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.593] getGlobalsAndPackages() ... DONE
[13:22:55.636]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.594] run() for ‘Future’ ...
[13:22:55.637]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.594] - state: ‘created’
[13:22:55.637]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.594] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:22:55.637]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.595] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:22:55.637]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.595] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:22:55.637]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.595]   - Field: ‘label’
[13:22:55.637]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.595]   - Field: ‘local’
[13:22:55.638]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.596]   - Field: ‘owner’
[13:22:55.638]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.596]   - Field: ‘envir’
[13:22:55.638]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.596]   - Field: ‘packages’
[13:22:55.638]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.596]   - Field: ‘gc’
[13:22:55.638]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.597]   - Field: ‘conditions’
[13:22:55.639]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.597]   - Field: ‘expr’
[13:22:55.639]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.597]   - Field: ‘uuid’
[13:22:55.639]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.597]   - Field: ‘seed’
[13:22:55.639]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.597]   - Field: ‘version’
[13:22:55.639]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.597]   - Field: ‘result’
[13:22:55.639]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.598]   - Field: ‘asynchronous’
[13:22:55.640]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.598]   - Field: ‘calls’
[13:22:55.640]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.598]   - Field: ‘globals’
[13:22:55.640]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.598]   - Field: ‘stdout’
[13:22:55.640]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.598]   - Field: ‘earlySignal’
[13:22:55.640]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.599]   - Field: ‘lazy’
[13:22:55.640]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.599]   - Field: ‘state’
[13:22:55.641]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.599] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:22:55.641]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.599] - Launch lazy future ...
[13:22:55.641]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.600] Packages needed by the future expression (n = 0): <none>
[13:22:55.641]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.600] Packages needed by future strategies (n = 0): <none>
[13:22:55.641]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.601] {
[13:22:55.601]     {
[13:22:55.601]         {
[13:22:55.601]             ...future.startTime <- base::Sys.time()
[13:22:55.601]             {
[13:22:55.601]                 {
[13:22:55.601]                   {
[13:22:55.601]                     base::local({
[13:22:55.601]                       has_future <- base::requireNamespace("future", 
[13:22:55.601]                         quietly = TRUE)
[13:22:55.601]                       if (has_future) {
[13:22:55.601]                         ns <- base::getNamespace("future")
[13:22:55.601]                         version <- ns[[".package"]][["version"]]
[13:22:55.601]                         if (is.null(version)) 
[13:22:55.601]                           version <- utils::packageVersion("future")
[13:22:55.601]                       }
[13:22:55.601]                       else {
[13:22:55.601]                         version <- NULL
[13:22:55.601]                       }
[13:22:55.601]                       if (!has_future || version < "1.8.0") {
[13:22:55.601]                         info <- base::c(r_version = base::gsub("R version ", 
[13:22:55.601]                           "", base::R.version$version.string), 
[13:22:55.601]                           platform = base::sprintf("%s (%s-bit)", 
[13:22:55.601]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:55.601]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:55.601]                             "release", "version")], collapse = " "), 
[13:22:55.601]                           hostname = base::Sys.info()[["nodename"]])
[13:22:55.601]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:22:55.601]                           info)
[13:22:55.601]                         info <- base::paste(info, collapse = "; ")
[13:22:55.601]                         if (!has_future) {
[13:22:55.601]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:55.601]                             info)
[13:22:55.601]                         }
[13:22:55.601]                         else {
[13:22:55.601]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:55.601]                             info, version)
[13:22:55.601]                         }
[13:22:55.601]                         base::stop(msg)
[13:22:55.601]                       }
[13:22:55.601]                     })
[13:22:55.601]                   }
[13:22:55.601]                   options(future.plan = NULL)
[13:22:55.601]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.601]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:55.601]                 }
[13:22:55.601]                 ...future.workdir <- getwd()
[13:22:55.601]             }
[13:22:55.601]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:55.601]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:55.601]         }
[13:22:55.601]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:55.601]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:55.601]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:55.601]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:55.601]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:55.601]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:55.601]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:55.601]             base::names(...future.oldOptions))
[13:22:55.601]     }
[13:22:55.601]     if (FALSE) {
[13:22:55.601]     }
[13:22:55.601]     else {
[13:22:55.601]         if (TRUE) {
[13:22:55.601]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:55.601]                 open = "w")
[13:22:55.601]         }
[13:22:55.601]         else {
[13:22:55.601]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:55.601]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:55.601]         }
[13:22:55.601]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:55.601]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:55.601]             base::sink(type = "output", split = FALSE)
[13:22:55.601]             base::close(...future.stdout)
[13:22:55.601]         }, add = TRUE)
[13:22:55.601]     }
[13:22:55.601]     ...future.frame <- base::sys.nframe()
[13:22:55.601]     ...future.conditions <- base::list()
[13:22:55.601]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:55.601]     if (FALSE) {
[13:22:55.601]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:55.601]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:55.601]     }
[13:22:55.601]     ...future.result <- base::tryCatch({
[13:22:55.601]         base::withCallingHandlers({
[13:22:55.601]             ...future.value <- base::withVisible(base::local(2))
[13:22:55.601]             future::FutureResult(value = ...future.value$value, 
[13:22:55.601]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.601]                   ...future.rng), globalenv = if (FALSE) 
[13:22:55.601]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:55.601]                     ...future.globalenv.names))
[13:22:55.601]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:55.601]         }, condition = base::local({
[13:22:55.601]             c <- base::c
[13:22:55.601]             inherits <- base::inherits
[13:22:55.601]             invokeRestart <- base::invokeRestart
[13:22:55.601]             length <- base::length
[13:22:55.601]             list <- base::list
[13:22:55.601]             seq.int <- base::seq.int
[13:22:55.601]             signalCondition <- base::signalCondition
[13:22:55.601]             sys.calls <- base::sys.calls
[13:22:55.601]             `[[` <- base::`[[`
[13:22:55.601]             `+` <- base::`+`
[13:22:55.601]             `<<-` <- base::`<<-`
[13:22:55.601]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:55.601]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:55.601]                   3L)]
[13:22:55.601]             }
[13:22:55.601]             function(cond) {
[13:22:55.601]                 is_error <- inherits(cond, "error")
[13:22:55.601]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:55.601]                   NULL)
[13:22:55.601]                 if (is_error) {
[13:22:55.601]                   sessionInformation <- function() {
[13:22:55.601]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:55.601]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:55.601]                       search = base::search(), system = base::Sys.info())
[13:22:55.601]                   }
[13:22:55.601]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.601]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:55.601]                     cond$call), session = sessionInformation(), 
[13:22:55.601]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:55.601]                   signalCondition(cond)
[13:22:55.601]                 }
[13:22:55.601]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:55.601]                 "immediateCondition"))) {
[13:22:55.601]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:55.601]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.601]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:55.601]                   if (TRUE && !signal) {
[13:22:55.601]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.601]                     {
[13:22:55.601]                       inherits <- base::inherits
[13:22:55.601]                       invokeRestart <- base::invokeRestart
[13:22:55.601]                       is.null <- base::is.null
[13:22:55.601]                       muffled <- FALSE
[13:22:55.601]                       if (inherits(cond, "message")) {
[13:22:55.601]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.601]                         if (muffled) 
[13:22:55.601]                           invokeRestart("muffleMessage")
[13:22:55.601]                       }
[13:22:55.601]                       else if (inherits(cond, "warning")) {
[13:22:55.601]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.601]                         if (muffled) 
[13:22:55.601]                           invokeRestart("muffleWarning")
[13:22:55.601]                       }
[13:22:55.601]                       else if (inherits(cond, "condition")) {
[13:22:55.601]                         if (!is.null(pattern)) {
[13:22:55.601]                           computeRestarts <- base::computeRestarts
[13:22:55.601]                           grepl <- base::grepl
[13:22:55.601]                           restarts <- computeRestarts(cond)
[13:22:55.601]                           for (restart in restarts) {
[13:22:55.601]                             name <- restart$name
[13:22:55.601]                             if (is.null(name)) 
[13:22:55.601]                               next
[13:22:55.601]                             if (!grepl(pattern, name)) 
[13:22:55.601]                               next
[13:22:55.601]                             invokeRestart(restart)
[13:22:55.601]                             muffled <- TRUE
[13:22:55.601]                             break
[13:22:55.601]                           }
[13:22:55.601]                         }
[13:22:55.601]                       }
[13:22:55.601]                       invisible(muffled)
[13:22:55.601]                     }
[13:22:55.601]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.601]                   }
[13:22:55.601]                 }
[13:22:55.601]                 else {
[13:22:55.601]                   if (TRUE) {
[13:22:55.601]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.601]                     {
[13:22:55.601]                       inherits <- base::inherits
[13:22:55.601]                       invokeRestart <- base::invokeRestart
[13:22:55.601]                       is.null <- base::is.null
[13:22:55.601]                       muffled <- FALSE
[13:22:55.601]                       if (inherits(cond, "message")) {
[13:22:55.601]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.601]                         if (muffled) 
[13:22:55.601]                           invokeRestart("muffleMessage")
[13:22:55.601]                       }
[13:22:55.601]                       else if (inherits(cond, "warning")) {
[13:22:55.601]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.601]                         if (muffled) 
[13:22:55.601]                           invokeRestart("muffleWarning")
[13:22:55.601]                       }
[13:22:55.601]                       else if (inherits(cond, "condition")) {
[13:22:55.601]                         if (!is.null(pattern)) {
[13:22:55.601]                           computeRestarts <- base::computeRestarts
[13:22:55.601]                           grepl <- base::grepl
[13:22:55.601]                           restarts <- computeRestarts(cond)
[13:22:55.601]                           for (restart in restarts) {
[13:22:55.601]                             name <- restart$name
[13:22:55.601]                             if (is.null(name)) 
[13:22:55.601]                               next
[13:22:55.601]                             if (!grepl(pattern, name)) 
[13:22:55.601]                               next
[13:22:55.601]                             invokeRestart(restart)
[13:22:55.601]                             muffled <- TRUE
[13:22:55.601]                             break
[13:22:55.601]                           }
[13:22:55.601]                         }
[13:22:55.601]                       }
[13:22:55.601]                       invisible(muffled)
[13:22:55.601]                     }
[13:22:55.601]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.601]                   }
[13:22:55.601]                 }
[13:22:55.601]             }
[13:22:55.601]         }))
[13:22:55.601]     }, error = function(ex) {
[13:22:55.601]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:55.601]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.601]                 ...future.rng), started = ...future.startTime, 
[13:22:55.601]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:55.601]             version = "1.8"), class = "FutureResult")
[13:22:55.601]     }, finally = {
[13:22:55.601]         if (!identical(...future.workdir, getwd())) 
[13:22:55.601]             setwd(...future.workdir)
[13:22:55.601]         {
[13:22:55.601]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:55.601]                 ...future.oldOptions$nwarnings <- NULL
[13:22:55.601]             }
[13:22:55.601]             base::options(...future.oldOptions)
[13:22:55.601]             if (.Platform$OS.type == "windows") {
[13:22:55.601]                 old_names <- names(...future.oldEnvVars)
[13:22:55.601]                 envs <- base::Sys.getenv()
[13:22:55.601]                 names <- names(envs)
[13:22:55.601]                 common <- intersect(names, old_names)
[13:22:55.601]                 added <- setdiff(names, old_names)
[13:22:55.601]                 removed <- setdiff(old_names, names)
[13:22:55.601]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:55.601]                   envs[common]]
[13:22:55.601]                 NAMES <- toupper(changed)
[13:22:55.601]                 args <- list()
[13:22:55.601]                 for (kk in seq_along(NAMES)) {
[13:22:55.601]                   name <- changed[[kk]]
[13:22:55.601]                   NAME <- NAMES[[kk]]
[13:22:55.601]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.601]                     next
[13:22:55.601]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.601]                 }
[13:22:55.601]                 NAMES <- toupper(added)
[13:22:55.601]                 for (kk in seq_along(NAMES)) {
[13:22:55.601]                   name <- added[[kk]]
[13:22:55.601]                   NAME <- NAMES[[kk]]
[13:22:55.601]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.601]                     next
[13:22:55.601]                   args[[name]] <- ""
[13:22:55.601]                 }
[13:22:55.601]                 NAMES <- toupper(removed)
[13:22:55.601]                 for (kk in seq_along(NAMES)) {
[13:22:55.601]                   name <- removed[[kk]]
[13:22:55.601]                   NAME <- NAMES[[kk]]
[13:22:55.601]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.601]                     next
[13:22:55.601]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.601]                 }
[13:22:55.601]                 if (length(args) > 0) 
[13:22:55.601]                   base::do.call(base::Sys.setenv, args = args)
[13:22:55.601]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:55.601]             }
[13:22:55.601]             else {
[13:22:55.601]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:55.601]             }
[13:22:55.601]             {
[13:22:55.601]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:55.601]                   0L) {
[13:22:55.601]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:55.601]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:55.601]                   base::options(opts)
[13:22:55.601]                 }
[13:22:55.601]                 {
[13:22:55.601]                   {
[13:22:55.601]                     NULL
[13:22:55.601]                     RNGkind("Mersenne-Twister")
[13:22:55.601]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:22:55.601]                       inherits = FALSE)
[13:22:55.601]                   }
[13:22:55.601]                   options(future.plan = NULL)
[13:22:55.601]                   if (is.na(NA_character_)) 
[13:22:55.601]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.601]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:55.601]                   future::plan(list(function (..., envir = parent.frame()) 
[13:22:55.601]                   {
[13:22:55.601]                     future <- SequentialFuture(..., envir = envir)
[13:22:55.601]                     if (!future$lazy) 
[13:22:55.601]                       future <- run(future)
[13:22:55.601]                     invisible(future)
[13:22:55.601]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:55.601]                 }
[13:22:55.601]             }
[13:22:55.601]         }
[13:22:55.601]     })
[13:22:55.601]     if (TRUE) {
[13:22:55.601]         base::sink(type = "output", split = FALSE)
[13:22:55.601]         if (TRUE) {
[13:22:55.601]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:55.601]         }
[13:22:55.601]         else {
[13:22:55.601]             ...future.result["stdout"] <- base::list(NULL)
[13:22:55.601]         }
[13:22:55.601]         base::close(...future.stdout)
[13:22:55.601]         ...future.stdout <- NULL
[13:22:55.601]     }
[13:22:55.601]     ...future.result$conditions <- ...future.conditions
[13:22:55.601]     ...future.result$finished <- base::Sys.time()
[13:22:55.601]     ...future.result
[13:22:55.601] }
[13:22:55.641]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.603] plan(): Setting new future strategy stack:
[13:22:55.642]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.604] List of future strategies:
[13:22:55.604] 1. sequential:
[13:22:55.604]    - args: function (..., envir = parent.frame())
[13:22:55.604]    - tweaked: FALSE
[13:22:55.604]    - call: NULL
[13:22:55.642]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.604] plan(): nbrOfWorkers() = 1
[13:22:55.642]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.606] plan(): Setting new future strategy stack:
[13:22:55.642]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.606] List of future strategies:
[13:22:55.606] 1. sequential:
[13:22:55.606]    - args: function (..., envir = parent.frame())
[13:22:55.606]    - tweaked: FALSE
[13:22:55.606]    - call: NULL
[13:22:55.642]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.606] plan(): nbrOfWorkers() = 1
[13:22:55.642]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.607] SequentialFuture started (and completed)
[13:22:55.643]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.607] - Launch lazy future ... done
[13:22:55.643]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.607] run() for ‘SequentialFuture’ ... done
[13:22:55.643]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.607] getGlobalsAndPackages() ...
[13:22:55.643]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.608] Searching for globals...
[13:22:55.643]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.608] 
[13:22:55.643]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.608] Searching for globals ... DONE
[13:22:55.644]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.609] - globals: [0] <none>
[13:22:55.644]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.609] getGlobalsAndPackages() ... DONE
[13:22:55.644]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.609] run() for ‘Future’ ...
[13:22:55.644]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.609] - state: ‘created’
[13:22:55.644]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.610] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:22:55.644]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.610] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:22:55.645]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.610] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:22:55.645]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.610]   - Field: ‘label’
[13:22:55.645]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.611]   - Field: ‘local’
[13:22:55.645]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.611]   - Field: ‘owner’
[13:22:55.645]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.611]   - Field: ‘envir’
[13:22:55.645]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.611]   - Field: ‘packages’
[13:22:55.646]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.611]   - Field: ‘gc’
[13:22:55.646]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.611]   - Field: ‘conditions’
[13:22:55.646]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.612]   - Field: ‘expr’
[13:22:55.646]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.612]   - Field: ‘uuid’
[13:22:55.646]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.612]   - Field: ‘seed’
[13:22:55.646]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.612]   - Field: ‘version’
[13:22:55.647]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.612]   - Field: ‘result’
[13:22:55.647]  - Condition #68: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.612]   - Field: ‘asynchronous’
[13:22:55.647]  - Condition #69: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.613]   - Field: ‘calls’
[13:22:55.647]  - Condition #70: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.613]   - Field: ‘globals’
[13:22:55.647]  - Condition #71: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.613]   - Field: ‘stdout’
[13:22:55.647]  - Condition #72: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.613]   - Field: ‘earlySignal’
[13:22:55.648]  - Condition #73: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.613]   - Field: ‘lazy’
[13:22:55.648]  - Condition #74: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.613]   - Field: ‘state’
[13:22:55.648]  - Condition #75: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.613] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:22:55.648]  - Condition #76: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.614] - Launch lazy future ...
[13:22:55.648]  - Condition #77: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.614] Packages needed by the future expression (n = 0): <none>
[13:22:55.648]  - Condition #78: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.614] Packages needed by future strategies (n = 0): <none>
[13:22:55.649]  - Condition #79: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.615] {
[13:22:55.615]     {
[13:22:55.615]         {
[13:22:55.615]             ...future.startTime <- base::Sys.time()
[13:22:55.615]             {
[13:22:55.615]                 {
[13:22:55.615]                   {
[13:22:55.615]                     base::local({
[13:22:55.615]                       has_future <- base::requireNamespace("future", 
[13:22:55.615]                         quietly = TRUE)
[13:22:55.615]                       if (has_future) {
[13:22:55.615]                         ns <- base::getNamespace("future")
[13:22:55.615]                         version <- ns[[".package"]][["version"]]
[13:22:55.615]                         if (is.null(version)) 
[13:22:55.615]                           version <- utils::packageVersion("future")
[13:22:55.615]                       }
[13:22:55.615]                       else {
[13:22:55.615]                         version <- NULL
[13:22:55.615]                       }
[13:22:55.615]                       if (!has_future || version < "1.8.0") {
[13:22:55.615]                         info <- base::c(r_version = base::gsub("R version ", 
[13:22:55.615]                           "", base::R.version$version.string), 
[13:22:55.615]                           platform = base::sprintf("%s (%s-bit)", 
[13:22:55.615]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:55.615]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:55.615]                             "release", "version")], collapse = " "), 
[13:22:55.615]                           hostname = base::Sys.info()[["nodename"]])
[13:22:55.615]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:22:55.615]                           info)
[13:22:55.615]                         info <- base::paste(info, collapse = "; ")
[13:22:55.615]                         if (!has_future) {
[13:22:55.615]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:55.615]                             info)
[13:22:55.615]                         }
[13:22:55.615]                         else {
[13:22:55.615]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:55.615]                             info, version)
[13:22:55.615]                         }
[13:22:55.615]                         base::stop(msg)
[13:22:55.615]                       }
[13:22:55.615]                     })
[13:22:55.615]                   }
[13:22:55.615]                   options(future.plan = NULL)
[13:22:55.615]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.615]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:55.615]                 }
[13:22:55.615]                 ...future.workdir <- getwd()
[13:22:55.615]             }
[13:22:55.615]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:55.615]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:55.615]         }
[13:22:55.615]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:55.615]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:55.615]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:55.615]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:55.615]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:55.615]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:55.615]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:55.615]             base::names(...future.oldOptions))
[13:22:55.615]     }
[13:22:55.615]     if (FALSE) {
[13:22:55.615]     }
[13:22:55.615]     else {
[13:22:55.615]         if (TRUE) {
[13:22:55.615]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:55.615]                 open = "w")
[13:22:55.615]         }
[13:22:55.615]         else {
[13:22:55.615]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:55.615]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:55.615]         }
[13:22:55.615]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:55.615]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:55.615]             base::sink(type = "output", split = FALSE)
[13:22:55.615]             base::close(...future.stdout)
[13:22:55.615]         }, add = TRUE)
[13:22:55.615]     }
[13:22:55.615]     ...future.frame <- base::sys.nframe()
[13:22:55.615]     ...future.conditions <- base::list()
[13:22:55.615]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:55.615]     if (FALSE) {
[13:22:55.615]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:55.615]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:55.615]     }
[13:22:55.615]     ...future.result <- base::tryCatch({
[13:22:55.615]         base::withCallingHandlers({
[13:22:55.615]             ...future.value <- base::withVisible(base::local(4))
[13:22:55.615]             future::FutureResult(value = ...future.value$value, 
[13:22:55.615]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.615]                   ...future.rng), globalenv = if (FALSE) 
[13:22:55.615]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:55.615]                     ...future.globalenv.names))
[13:22:55.615]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:55.615]         }, condition = base::local({
[13:22:55.615]             c <- base::c
[13:22:55.615]             inherits <- base::inherits
[13:22:55.615]             invokeRestart <- base::invokeRestart
[13:22:55.615]             length <- base::length
[13:22:55.615]             list <- base::list
[13:22:55.615]             seq.int <- base::seq.int
[13:22:55.615]             signalCondition <- base::signalCondition
[13:22:55.615]             sys.calls <- base::sys.calls
[13:22:55.615]             `[[` <- base::`[[`
[13:22:55.615]             `+` <- base::`+`
[13:22:55.615]             `<<-` <- base::`<<-`
[13:22:55.615]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:55.615]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:55.615]                   3L)]
[13:22:55.615]             }
[13:22:55.615]             function(cond) {
[13:22:55.615]                 is_error <- inherits(cond, "error")
[13:22:55.615]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:55.615]                   NULL)
[13:22:55.615]                 if (is_error) {
[13:22:55.615]                   sessionInformation <- function() {
[13:22:55.615]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:55.615]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:55.615]                       search = base::search(), system = base::Sys.info())
[13:22:55.615]                   }
[13:22:55.615]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.615]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:55.615]                     cond$call), session = sessionInformation(), 
[13:22:55.615]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:55.615]                   signalCondition(cond)
[13:22:55.615]                 }
[13:22:55.615]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:55.615]                 "immediateCondition"))) {
[13:22:55.615]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:55.615]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.615]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:55.615]                   if (TRUE && !signal) {
[13:22:55.615]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.615]                     {
[13:22:55.615]                       inherits <- base::inherits
[13:22:55.615]                       invokeRestart <- base::invokeRestart
[13:22:55.615]                       is.null <- base::is.null
[13:22:55.615]                       muffled <- FALSE
[13:22:55.615]                       if (inherits(cond, "message")) {
[13:22:55.615]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.615]                         if (muffled) 
[13:22:55.615]                           invokeRestart("muffleMessage")
[13:22:55.615]                       }
[13:22:55.615]                       else if (inherits(cond, "warning")) {
[13:22:55.615]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.615]                         if (muffled) 
[13:22:55.615]                           invokeRestart("muffleWarning")
[13:22:55.615]                       }
[13:22:55.615]                       else if (inherits(cond, "condition")) {
[13:22:55.615]                         if (!is.null(pattern)) {
[13:22:55.615]                           computeRestarts <- base::computeRestarts
[13:22:55.615]                           grepl <- base::grepl
[13:22:55.615]                           restarts <- computeRestarts(cond)
[13:22:55.615]                           for (restart in restarts) {
[13:22:55.615]                             name <- restart$name
[13:22:55.615]                             if (is.null(name)) 
[13:22:55.615]                               next
[13:22:55.615]                             if (!grepl(pattern, name)) 
[13:22:55.615]                               next
[13:22:55.615]                             invokeRestart(restart)
[13:22:55.615]                             muffled <- TRUE
[13:22:55.615]                             break
[13:22:55.615]                           }
[13:22:55.615]                         }
[13:22:55.615]                       }
[13:22:55.615]                       invisible(muffled)
[13:22:55.615]                     }
[13:22:55.615]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.615]                   }
[13:22:55.615]                 }
[13:22:55.615]                 else {
[13:22:55.615]                   if (TRUE) {
[13:22:55.615]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.615]                     {
[13:22:55.615]                       inherits <- base::inherits
[13:22:55.615]                       invokeRestart <- base::invokeRestart
[13:22:55.615]                       is.null <- base::is.null
[13:22:55.615]                       muffled <- FALSE
[13:22:55.615]                       if (inherits(cond, "message")) {
[13:22:55.615]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.615]                         if (muffled) 
[13:22:55.615]                           invokeRestart("muffleMessage")
[13:22:55.615]                       }
[13:22:55.615]                       else if (inherits(cond, "warning")) {
[13:22:55.615]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.615]                         if (muffled) 
[13:22:55.615]                           invokeRestart("muffleWarning")
[13:22:55.615]                       }
[13:22:55.615]                       else if (inherits(cond, "condition")) {
[13:22:55.615]                         if (!is.null(pattern)) {
[13:22:55.615]                           computeRestarts <- base::computeRestarts
[13:22:55.615]                           grepl <- base::grepl
[13:22:55.615]                           restarts <- computeRestarts(cond)
[13:22:55.615]                           for (restart in restarts) {
[13:22:55.615]                             name <- restart$name
[13:22:55.615]                             if (is.null(name)) 
[13:22:55.615]                               next
[13:22:55.615]                             if (!grepl(pattern, name)) 
[13:22:55.615]                               next
[13:22:55.615]                             invokeRestart(restart)
[13:22:55.615]                             muffled <- TRUE
[13:22:55.615]                             break
[13:22:55.615]                           }
[13:22:55.615]                         }
[13:22:55.615]                       }
[13:22:55.615]                       invisible(muffled)
[13:22:55.615]                     }
[13:22:55.615]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.615]                   }
[13:22:55.615]                 }
[13:22:55.615]             }
[13:22:55.615]         }))
[13:22:55.615]     }, error = function(ex) {
[13:22:55.615]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:55.615]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.615]                 ...future.rng), started = ...future.startTime, 
[13:22:55.615]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:55.615]             version = "1.8"), class = "FutureResult")
[13:22:55.615]     }, finally = {
[13:22:55.615]         if (!identical(...future.workdir, getwd())) 
[13:22:55.615]             setwd(...future.workdir)
[13:22:55.615]         {
[13:22:55.615]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:55.615]                 ...future.oldOptions$nwarnings <- NULL
[13:22:55.615]             }
[13:22:55.615]             base::options(...future.oldOptions)
[13:22:55.615]             if (.Platform$OS.type == "windows") {
[13:22:55.615]                 old_names <- names(...future.oldEnvVars)
[13:22:55.615]                 envs <- base::Sys.getenv()
[13:22:55.615]                 names <- names(envs)
[13:22:55.615]                 common <- intersect(names, old_names)
[13:22:55.615]                 added <- setdiff(names, old_names)
[13:22:55.615]                 removed <- setdiff(old_names, names)
[13:22:55.615]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:55.615]                   envs[common]]
[13:22:55.615]                 NAMES <- toupper(changed)
[13:22:55.615]                 args <- list()
[13:22:55.615]                 for (kk in seq_along(NAMES)) {
[13:22:55.615]                   name <- changed[[kk]]
[13:22:55.615]                   NAME <- NAMES[[kk]]
[13:22:55.615]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.615]                     next
[13:22:55.615]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.615]                 }
[13:22:55.615]                 NAMES <- toupper(added)
[13:22:55.615]                 for (kk in seq_along(NAMES)) {
[13:22:55.615]                   name <- added[[kk]]
[13:22:55.615]                   NAME <- NAMES[[kk]]
[13:22:55.615]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.615]                     next
[13:22:55.615]                   args[[name]] <- ""
[13:22:55.615]                 }
[13:22:55.615]                 NAMES <- toupper(removed)
[13:22:55.615]                 for (kk in seq_along(NAMES)) {
[13:22:55.615]                   name <- removed[[kk]]
[13:22:55.615]                   NAME <- NAMES[[kk]]
[13:22:55.615]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.615]                     next
[13:22:55.615]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.615]                 }
[13:22:55.615]                 if (length(args) > 0) 
[13:22:55.615]                   base::do.call(base::Sys.setenv, args = args)
[13:22:55.615]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:55.615]             }
[13:22:55.615]             else {
[13:22:55.615]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:55.615]             }
[13:22:55.615]             {
[13:22:55.615]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:55.615]                   0L) {
[13:22:55.615]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:55.615]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:55.615]                   base::options(opts)
[13:22:55.615]                 }
[13:22:55.615]                 {
[13:22:55.615]                   {
[13:22:55.615]                     NULL
[13:22:55.615]                     RNGkind("Mersenne-Twister")
[13:22:55.615]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:22:55.615]                       inherits = FALSE)
[13:22:55.615]                   }
[13:22:55.615]                   options(future.plan = NULL)
[13:22:55.615]                   if (is.na(NA_character_)) 
[13:22:55.615]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.615]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:55.615]                   future::plan(list(function (..., envir = parent.frame()) 
[13:22:55.615]                   {
[13:22:55.615]                     future <- SequentialFuture(..., envir = envir)
[13:22:55.615]                     if (!future$lazy) 
[13:22:55.615]                       future <- run(future)
[13:22:55.615]                     invisible(future)
[13:22:55.615]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:55.615]                 }
[13:22:55.615]             }
[13:22:55.615]         }
[13:22:55.615]     })
[13:22:55.615]     if (TRUE) {
[13:22:55.615]         base::sink(type = "output", split = FALSE)
[13:22:55.615]         if (TRUE) {
[13:22:55.615]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:55.615]         }
[13:22:55.615]         else {
[13:22:55.615]             ...future.result["stdout"] <- base::list(NULL)
[13:22:55.615]         }
[13:22:55.615]         base::close(...future.stdout)
[13:22:55.615]         ...future.stdout <- NULL
[13:22:55.615]     }
[13:22:55.615]     ...future.result$conditions <- ...future.conditions
[13:22:55.615]     ...future.result$finished <- base::Sys.time()
[13:22:55.615]     ...future.result
[13:22:55.615] }
[13:22:55.649]  - Condition #80: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.617] plan(): Setting new future strategy stack:
[13:22:55.649]  - Condition #81: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.617] List of future strategies:
[13:22:55.617] 1. sequential:
[13:22:55.617]    - args: function (..., envir = parent.frame())
[13:22:55.617]    - tweaked: FALSE
[13:22:55.617]    - call: NULL
[13:22:55.649]  - Condition #82: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.618] plan(): nbrOfWorkers() = 1
[13:22:55.649]  - Condition #83: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.619] plan(): Setting new future strategy stack:
[13:22:55.649]  - Condition #84: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.619] List of future strategies:
[13:22:55.619] 1. sequential:
[13:22:55.619]    - args: function (..., envir = parent.frame())
[13:22:55.619]    - tweaked: FALSE
[13:22:55.619]    - call: NULL
[13:22:55.652]  - Condition #85: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.620] plan(): nbrOfWorkers() = 1
[13:22:55.653]  - Condition #86: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.620] SequentialFuture started (and completed)
[13:22:55.653]  - Condition #87: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.623] - Launch lazy future ... done
[13:22:55.653]  - Condition #88: ‘simpleMessage’, ‘message’, ‘condition’
[13:22:55.624] run() for ‘SequentialFuture’ ... done
[13:22:55.653] signalConditions() ... done
a = 10
[13:22:55.654] getGlobalsAndPackages() ...
[13:22:55.654] Searching for globals...
[13:22:55.655] - globals found: [3] ‘{’, ‘+’, ‘a’
[13:22:55.656] Searching for globals ... DONE
[13:22:55.656] Resolving globals: FALSE
[13:22:55.656] The total size of the 1 globals is 56 bytes (56 bytes)
[13:22:55.657] The total size of the 1 globals exported for future expression (‘{; a + 1; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:22:55.657] - globals: [1] ‘a’
[13:22:55.657] 
[13:22:55.657] getGlobalsAndPackages() ... DONE
[13:22:55.657] run() for ‘Future’ ...
[13:22:55.657] - state: ‘created’
[13:22:55.658] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:22:55.662] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:55.662] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:22:55.662]   - Field: ‘label’
[13:22:55.663]   - Field: ‘local’
[13:22:55.663]   - Field: ‘owner’
[13:22:55.663]   - Field: ‘envir’
[13:22:55.663]   - Field: ‘workers’
[13:22:55.663]   - Field: ‘packages’
[13:22:55.663]   - Field: ‘gc’
[13:22:55.663]   - Field: ‘job’
[13:22:55.663]   - Field: ‘conditions’
[13:22:55.664]   - Field: ‘expr’
[13:22:55.664]   - Field: ‘uuid’
[13:22:55.664]   - Field: ‘seed’
[13:22:55.664]   - Field: ‘version’
[13:22:55.664]   - Field: ‘result’
[13:22:55.664]   - Field: ‘asynchronous’
[13:22:55.664]   - Field: ‘calls’
[13:22:55.664]   - Field: ‘globals’
[13:22:55.664]   - Field: ‘stdout’
[13:22:55.665]   - Field: ‘earlySignal’
[13:22:55.665]   - Field: ‘lazy’
[13:22:55.665]   - Field: ‘state’
[13:22:55.665] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:22:55.665] - Launch lazy future ...
[13:22:55.665] Packages needed by the future expression (n = 0): <none>
[13:22:55.665] Packages needed by future strategies (n = 0): <none>
[13:22:55.666] {
[13:22:55.666]     {
[13:22:55.666]         {
[13:22:55.666]             ...future.startTime <- base::Sys.time()
[13:22:55.666]             {
[13:22:55.666]                 {
[13:22:55.666]                   {
[13:22:55.666]                     {
[13:22:55.666]                       base::local({
[13:22:55.666]                         has_future <- base::requireNamespace("future", 
[13:22:55.666]                           quietly = TRUE)
[13:22:55.666]                         if (has_future) {
[13:22:55.666]                           ns <- base::getNamespace("future")
[13:22:55.666]                           version <- ns[[".package"]][["version"]]
[13:22:55.666]                           if (is.null(version)) 
[13:22:55.666]                             version <- utils::packageVersion("future")
[13:22:55.666]                         }
[13:22:55.666]                         else {
[13:22:55.666]                           version <- NULL
[13:22:55.666]                         }
[13:22:55.666]                         if (!has_future || version < "1.8.0") {
[13:22:55.666]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:55.666]                             "", base::R.version$version.string), 
[13:22:55.666]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:55.666]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:55.666]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:55.666]                               "release", "version")], collapse = " "), 
[13:22:55.666]                             hostname = base::Sys.info()[["nodename"]])
[13:22:55.666]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:55.666]                             info)
[13:22:55.666]                           info <- base::paste(info, collapse = "; ")
[13:22:55.666]                           if (!has_future) {
[13:22:55.666]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:55.666]                               info)
[13:22:55.666]                           }
[13:22:55.666]                           else {
[13:22:55.666]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:55.666]                               info, version)
[13:22:55.666]                           }
[13:22:55.666]                           base::stop(msg)
[13:22:55.666]                         }
[13:22:55.666]                       })
[13:22:55.666]                     }
[13:22:55.666]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:55.666]                     base::options(mc.cores = 1L)
[13:22:55.666]                   }
[13:22:55.666]                   options(future.plan = NULL)
[13:22:55.666]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.666]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:55.666]                 }
[13:22:55.666]                 ...future.workdir <- getwd()
[13:22:55.666]             }
[13:22:55.666]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:55.666]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:55.666]         }
[13:22:55.666]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:55.666]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:55.666]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:55.666]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:55.666]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:55.666]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:55.666]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:55.666]             base::names(...future.oldOptions))
[13:22:55.666]     }
[13:22:55.666]     if (FALSE) {
[13:22:55.666]     }
[13:22:55.666]     else {
[13:22:55.666]         if (TRUE) {
[13:22:55.666]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:55.666]                 open = "w")
[13:22:55.666]         }
[13:22:55.666]         else {
[13:22:55.666]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:55.666]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:55.666]         }
[13:22:55.666]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:55.666]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:55.666]             base::sink(type = "output", split = FALSE)
[13:22:55.666]             base::close(...future.stdout)
[13:22:55.666]         }, add = TRUE)
[13:22:55.666]     }
[13:22:55.666]     ...future.frame <- base::sys.nframe()
[13:22:55.666]     ...future.conditions <- base::list()
[13:22:55.666]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:55.666]     if (FALSE) {
[13:22:55.666]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:55.666]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:55.666]     }
[13:22:55.666]     ...future.result <- base::tryCatch({
[13:22:55.666]         base::withCallingHandlers({
[13:22:55.666]             ...future.value <- base::withVisible(base::local({
[13:22:55.666]                 withCallingHandlers({
[13:22:55.666]                   {
[13:22:55.666]                     a + 1
[13:22:55.666]                   }
[13:22:55.666]                 }, immediateCondition = function(cond) {
[13:22:55.666]                   save_rds <- function (object, pathname, ...) 
[13:22:55.666]                   {
[13:22:55.666]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:22:55.666]                     if (file_test("-f", pathname_tmp)) {
[13:22:55.666]                       fi_tmp <- file.info(pathname_tmp)
[13:22:55.666]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:22:55.666]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:55.666]                         fi_tmp[["mtime"]])
[13:22:55.666]                     }
[13:22:55.666]                     tryCatch({
[13:22:55.666]                       saveRDS(object, file = pathname_tmp, ...)
[13:22:55.666]                     }, error = function(ex) {
[13:22:55.666]                       msg <- conditionMessage(ex)
[13:22:55.666]                       fi_tmp <- file.info(pathname_tmp)
[13:22:55.666]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:22:55.666]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:55.666]                         fi_tmp[["mtime"]], msg)
[13:22:55.666]                       ex$message <- msg
[13:22:55.666]                       stop(ex)
[13:22:55.666]                     })
[13:22:55.666]                     stopifnot(file_test("-f", pathname_tmp))
[13:22:55.666]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:22:55.666]                     if (!res || file_test("-f", pathname_tmp)) {
[13:22:55.666]                       fi_tmp <- file.info(pathname_tmp)
[13:22:55.666]                       fi <- file.info(pathname)
[13:22:55.666]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:22:55.666]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:55.666]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:22:55.666]                         fi[["size"]], fi[["mtime"]])
[13:22:55.666]                       stop(msg)
[13:22:55.666]                     }
[13:22:55.666]                     invisible(pathname)
[13:22:55.666]                   }
[13:22:55.666]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:22:55.666]                     rootPath = tempdir()) 
[13:22:55.666]                   {
[13:22:55.666]                     obj <- list(time = Sys.time(), condition = cond)
[13:22:55.666]                     file <- tempfile(pattern = class(cond)[1], 
[13:22:55.666]                       tmpdir = path, fileext = ".rds")
[13:22:55.666]                     save_rds(obj, file)
[13:22:55.666]                   }
[13:22:55.666]                   saveImmediateCondition(cond, path = "/tmp/RtmphhERam/.future/immediateConditions")
[13:22:55.666]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.666]                   {
[13:22:55.666]                     inherits <- base::inherits
[13:22:55.666]                     invokeRestart <- base::invokeRestart
[13:22:55.666]                     is.null <- base::is.null
[13:22:55.666]                     muffled <- FALSE
[13:22:55.666]                     if (inherits(cond, "message")) {
[13:22:55.666]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:55.666]                       if (muffled) 
[13:22:55.666]                         invokeRestart("muffleMessage")
[13:22:55.666]                     }
[13:22:55.666]                     else if (inherits(cond, "warning")) {
[13:22:55.666]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:55.666]                       if (muffled) 
[13:22:55.666]                         invokeRestart("muffleWarning")
[13:22:55.666]                     }
[13:22:55.666]                     else if (inherits(cond, "condition")) {
[13:22:55.666]                       if (!is.null(pattern)) {
[13:22:55.666]                         computeRestarts <- base::computeRestarts
[13:22:55.666]                         grepl <- base::grepl
[13:22:55.666]                         restarts <- computeRestarts(cond)
[13:22:55.666]                         for (restart in restarts) {
[13:22:55.666]                           name <- restart$name
[13:22:55.666]                           if (is.null(name)) 
[13:22:55.666]                             next
[13:22:55.666]                           if (!grepl(pattern, name)) 
[13:22:55.666]                             next
[13:22:55.666]                           invokeRestart(restart)
[13:22:55.666]                           muffled <- TRUE
[13:22:55.666]                           break
[13:22:55.666]                         }
[13:22:55.666]                       }
[13:22:55.666]                     }
[13:22:55.666]                     invisible(muffled)
[13:22:55.666]                   }
[13:22:55.666]                   muffleCondition(cond)
[13:22:55.666]                 })
[13:22:55.666]             }))
[13:22:55.666]             future::FutureResult(value = ...future.value$value, 
[13:22:55.666]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.666]                   ...future.rng), globalenv = if (FALSE) 
[13:22:55.666]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:55.666]                     ...future.globalenv.names))
[13:22:55.666]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:55.666]         }, condition = base::local({
[13:22:55.666]             c <- base::c
[13:22:55.666]             inherits <- base::inherits
[13:22:55.666]             invokeRestart <- base::invokeRestart
[13:22:55.666]             length <- base::length
[13:22:55.666]             list <- base::list
[13:22:55.666]             seq.int <- base::seq.int
[13:22:55.666]             signalCondition <- base::signalCondition
[13:22:55.666]             sys.calls <- base::sys.calls
[13:22:55.666]             `[[` <- base::`[[`
[13:22:55.666]             `+` <- base::`+`
[13:22:55.666]             `<<-` <- base::`<<-`
[13:22:55.666]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:55.666]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:55.666]                   3L)]
[13:22:55.666]             }
[13:22:55.666]             function(cond) {
[13:22:55.666]                 is_error <- inherits(cond, "error")
[13:22:55.666]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:55.666]                   NULL)
[13:22:55.666]                 if (is_error) {
[13:22:55.666]                   sessionInformation <- function() {
[13:22:55.666]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:55.666]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:55.666]                       search = base::search(), system = base::Sys.info())
[13:22:55.666]                   }
[13:22:55.666]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.666]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:55.666]                     cond$call), session = sessionInformation(), 
[13:22:55.666]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:55.666]                   signalCondition(cond)
[13:22:55.666]                 }
[13:22:55.666]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:55.666]                 "immediateCondition"))) {
[13:22:55.666]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:55.666]                   ...future.conditions[[length(...future.conditions) + 
[13:22:55.666]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:55.666]                   if (TRUE && !signal) {
[13:22:55.666]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.666]                     {
[13:22:55.666]                       inherits <- base::inherits
[13:22:55.666]                       invokeRestart <- base::invokeRestart
[13:22:55.666]                       is.null <- base::is.null
[13:22:55.666]                       muffled <- FALSE
[13:22:55.666]                       if (inherits(cond, "message")) {
[13:22:55.666]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.666]                         if (muffled) 
[13:22:55.666]                           invokeRestart("muffleMessage")
[13:22:55.666]                       }
[13:22:55.666]                       else if (inherits(cond, "warning")) {
[13:22:55.666]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.666]                         if (muffled) 
[13:22:55.666]                           invokeRestart("muffleWarning")
[13:22:55.666]                       }
[13:22:55.666]                       else if (inherits(cond, "condition")) {
[13:22:55.666]                         if (!is.null(pattern)) {
[13:22:55.666]                           computeRestarts <- base::computeRestarts
[13:22:55.666]                           grepl <- base::grepl
[13:22:55.666]                           restarts <- computeRestarts(cond)
[13:22:55.666]                           for (restart in restarts) {
[13:22:55.666]                             name <- restart$name
[13:22:55.666]                             if (is.null(name)) 
[13:22:55.666]                               next
[13:22:55.666]                             if (!grepl(pattern, name)) 
[13:22:55.666]                               next
[13:22:55.666]                             invokeRestart(restart)
[13:22:55.666]                             muffled <- TRUE
[13:22:55.666]                             break
[13:22:55.666]                           }
[13:22:55.666]                         }
[13:22:55.666]                       }
[13:22:55.666]                       invisible(muffled)
[13:22:55.666]                     }
[13:22:55.666]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.666]                   }
[13:22:55.666]                 }
[13:22:55.666]                 else {
[13:22:55.666]                   if (TRUE) {
[13:22:55.666]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:55.666]                     {
[13:22:55.666]                       inherits <- base::inherits
[13:22:55.666]                       invokeRestart <- base::invokeRestart
[13:22:55.666]                       is.null <- base::is.null
[13:22:55.666]                       muffled <- FALSE
[13:22:55.666]                       if (inherits(cond, "message")) {
[13:22:55.666]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:55.666]                         if (muffled) 
[13:22:55.666]                           invokeRestart("muffleMessage")
[13:22:55.666]                       }
[13:22:55.666]                       else if (inherits(cond, "warning")) {
[13:22:55.666]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:55.666]                         if (muffled) 
[13:22:55.666]                           invokeRestart("muffleWarning")
[13:22:55.666]                       }
[13:22:55.666]                       else if (inherits(cond, "condition")) {
[13:22:55.666]                         if (!is.null(pattern)) {
[13:22:55.666]                           computeRestarts <- base::computeRestarts
[13:22:55.666]                           grepl <- base::grepl
[13:22:55.666]                           restarts <- computeRestarts(cond)
[13:22:55.666]                           for (restart in restarts) {
[13:22:55.666]                             name <- restart$name
[13:22:55.666]                             if (is.null(name)) 
[13:22:55.666]                               next
[13:22:55.666]                             if (!grepl(pattern, name)) 
[13:22:55.666]                               next
[13:22:55.666]                             invokeRestart(restart)
[13:22:55.666]                             muffled <- TRUE
[13:22:55.666]                             break
[13:22:55.666]                           }
[13:22:55.666]                         }
[13:22:55.666]                       }
[13:22:55.666]                       invisible(muffled)
[13:22:55.666]                     }
[13:22:55.666]                     muffleCondition(cond, pattern = "^muffle")
[13:22:55.666]                   }
[13:22:55.666]                 }
[13:22:55.666]             }
[13:22:55.666]         }))
[13:22:55.666]     }, error = function(ex) {
[13:22:55.666]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:55.666]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:55.666]                 ...future.rng), started = ...future.startTime, 
[13:22:55.666]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:55.666]             version = "1.8"), class = "FutureResult")
[13:22:55.666]     }, finally = {
[13:22:55.666]         if (!identical(...future.workdir, getwd())) 
[13:22:55.666]             setwd(...future.workdir)
[13:22:55.666]         {
[13:22:55.666]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:55.666]                 ...future.oldOptions$nwarnings <- NULL
[13:22:55.666]             }
[13:22:55.666]             base::options(...future.oldOptions)
[13:22:55.666]             if (.Platform$OS.type == "windows") {
[13:22:55.666]                 old_names <- names(...future.oldEnvVars)
[13:22:55.666]                 envs <- base::Sys.getenv()
[13:22:55.666]                 names <- names(envs)
[13:22:55.666]                 common <- intersect(names, old_names)
[13:22:55.666]                 added <- setdiff(names, old_names)
[13:22:55.666]                 removed <- setdiff(old_names, names)
[13:22:55.666]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:55.666]                   envs[common]]
[13:22:55.666]                 NAMES <- toupper(changed)
[13:22:55.666]                 args <- list()
[13:22:55.666]                 for (kk in seq_along(NAMES)) {
[13:22:55.666]                   name <- changed[[kk]]
[13:22:55.666]                   NAME <- NAMES[[kk]]
[13:22:55.666]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.666]                     next
[13:22:55.666]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.666]                 }
[13:22:55.666]                 NAMES <- toupper(added)
[13:22:55.666]                 for (kk in seq_along(NAMES)) {
[13:22:55.666]                   name <- added[[kk]]
[13:22:55.666]                   NAME <- NAMES[[kk]]
[13:22:55.666]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.666]                     next
[13:22:55.666]                   args[[name]] <- ""
[13:22:55.666]                 }
[13:22:55.666]                 NAMES <- toupper(removed)
[13:22:55.666]                 for (kk in seq_along(NAMES)) {
[13:22:55.666]                   name <- removed[[kk]]
[13:22:55.666]                   NAME <- NAMES[[kk]]
[13:22:55.666]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:55.666]                     next
[13:22:55.666]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:55.666]                 }
[13:22:55.666]                 if (length(args) > 0) 
[13:22:55.666]                   base::do.call(base::Sys.setenv, args = args)
[13:22:55.666]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:55.666]             }
[13:22:55.666]             else {
[13:22:55.666]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:55.666]             }
[13:22:55.666]             {
[13:22:55.666]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:55.666]                   0L) {
[13:22:55.666]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:55.666]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:55.666]                   base::options(opts)
[13:22:55.666]                 }
[13:22:55.666]                 {
[13:22:55.666]                   {
[13:22:55.666]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:55.666]                     NULL
[13:22:55.666]                   }
[13:22:55.666]                   options(future.plan = NULL)
[13:22:55.666]                   if (is.na(NA_character_)) 
[13:22:55.666]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:55.666]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:55.666]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:22:55.666]                     envir = parent.frame()) 
[13:22:55.666]                   {
[13:22:55.666]                     default_workers <- missing(workers)
[13:22:55.666]                     if (is.function(workers)) 
[13:22:55.666]                       workers <- workers()
[13:22:55.666]                     workers <- structure(as.integer(workers), 
[13:22:55.666]                       class = class(workers))
[13:22:55.666]                     stop_if_not(is.finite(workers), workers >= 
[13:22:55.666]                       1L)
[13:22:55.666]                     if ((workers == 1L && !inherits(workers, 
[13:22:55.666]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:22:55.666]                       if (default_workers) 
[13:22:55.666]                         supportsMulticore(warn = TRUE)
[13:22:55.666]                       return(sequential(..., envir = envir))
[13:22:55.666]                     }
[13:22:55.666]                     oopts <- options(mc.cores = workers)
[13:22:55.666]                     on.exit(options(oopts))
[13:22:55.666]                     future <- MulticoreFuture(..., workers = workers, 
[13:22:55.666]                       envir = envir)
[13:22:55.666]                     if (!future$lazy) 
[13:22:55.666]                       future <- run(future)
[13:22:55.666]                     invisible(future)
[13:22:55.666]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:55.666]                 }
[13:22:55.666]             }
[13:22:55.666]         }
[13:22:55.666]     })
[13:22:55.666]     if (TRUE) {
[13:22:55.666]         base::sink(type = "output", split = FALSE)
[13:22:55.666]         if (TRUE) {
[13:22:55.666]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:55.666]         }
[13:22:55.666]         else {
[13:22:55.666]             ...future.result["stdout"] <- base::list(NULL)
[13:22:55.666]         }
[13:22:55.666]         base::close(...future.stdout)
[13:22:55.666]         ...future.stdout <- NULL
[13:22:55.666]     }
[13:22:55.666]     ...future.result$conditions <- ...future.conditions
[13:22:55.666]     ...future.result$finished <- base::Sys.time()
[13:22:55.666]     ...future.result
[13:22:55.666] }
[13:22:55.668] assign_globals() ...
[13:22:55.669] List of 1
[13:22:55.669]  $ a: num 10
[13:22:55.669]  - attr(*, "where")=List of 1
[13:22:55.669]   ..$ a:<environment: R_EmptyEnv> 
[13:22:55.669]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:22:55.669]  - attr(*, "resolved")= logi FALSE
[13:22:55.669]  - attr(*, "total_size")= num 56
[13:22:55.669]  - attr(*, "already-done")= logi TRUE
[13:22:55.671] - copied ‘a’ to environment
[13:22:55.672] assign_globals() ... done
[13:22:55.672] requestCore(): workers = 2
[13:22:55.674] MulticoreFuture started
[13:22:55.674] - Launch lazy future ... done
[13:22:55.675] run() for ‘MulticoreFuture’ ... done
[13:22:55.675] result() for MulticoreFuture ...
[13:22:55.675] plan(): Setting new future strategy stack:
[13:22:55.676] List of future strategies:
[13:22:55.676] 1. sequential:
[13:22:55.676]    - args: function (..., envir = parent.frame())
[13:22:55.676]    - tweaked: FALSE
[13:22:55.676]    - call: NULL
[13:22:55.676] plan(): nbrOfWorkers() = 1
[13:22:55.679] plan(): Setting new future strategy stack:
[13:22:55.679] List of future strategies:
[13:22:55.679] 1. multicore:
[13:22:55.679]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:22:55.679]    - tweaked: FALSE
[13:22:55.679]    - call: plan(strategy)
[13:22:55.684] plan(): nbrOfWorkers() = 2
[13:22:55.685] result() for MulticoreFuture ...
[13:22:55.685] result() for MulticoreFuture ... done
[13:22:55.685] result() for MulticoreFuture ... done
[13:22:55.686] result() for MulticoreFuture ...
[13:22:55.686] result() for MulticoreFuture ... done
b = 11
*** %<-% with ‘multicore’ futures ... DONE
*** %<-% with ‘multisession’ futures ...
[13:22:55.687] plan(): Setting new future strategy stack:
[13:22:55.687] List of future strategies:
[13:22:55.687] 1. multisession:
[13:22:55.687]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:22:55.687]    - tweaked: FALSE
[13:22:55.687]    - call: plan(strategy)
[13:22:55.687] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:22:55.687] multisession:
[13:22:55.687] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:22:55.687] - tweaked: FALSE
[13:22:55.687] - call: plan(strategy)
[13:22:55.695] getGlobalsAndPackages() ...
[13:22:55.695] Not searching for globals
[13:22:55.695] - globals: [0] <none>
[13:22:55.695] getGlobalsAndPackages() ... DONE
[13:22:55.696] [local output] makeClusterPSOCK() ...
[13:22:55.751] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:22:55.753] [local output] Base port: 11937
[13:22:55.753] [local output] Getting setup options for 2 cluster nodes ...
[13:22:55.753] [local output]  - Node 1 of 2 ...
[13:22:55.754] [local output] localMachine=TRUE => revtunnel=FALSE

[13:22:55.754] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmphhERam/worker.rank=1.parallelly.parent=83386.145ba5b630fb9.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmphhERam/worker.rank=1.parallelly.parent=83386.145ba5b630fb9.pid")'’
[13:22:55.952] - Possible to infer worker's PID: TRUE
[13:22:55.952] [local output] Rscript port: 11937

[13:22:55.952] [local output]  - Node 2 of 2 ...
[13:22:55.953] [local output] localMachine=TRUE => revtunnel=FALSE

[13:22:55.953] [local output] Rscript port: 11937

[13:22:55.954] [local output] Getting setup options for 2 cluster nodes ... done
[13:22:55.954] [local output]  - Parallel setup requested for some PSOCK nodes
[13:22:55.954] [local output] Setting up PSOCK nodes in parallel
[13:22:55.955] List of 36
[13:22:55.955]  $ worker          : chr "localhost"
[13:22:55.955]   ..- attr(*, "localhost")= logi TRUE
[13:22:55.955]  $ master          : chr "localhost"
[13:22:55.955]  $ port            : int 11937
[13:22:55.955]  $ connectTimeout  : num 120
[13:22:55.955]  $ timeout         : num 2592000
[13:22:55.955]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:22:55.955]  $ homogeneous     : logi TRUE
[13:22:55.955]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:22:55.955]  $ rscript_envs    : NULL
[13:22:55.955]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:22:55.955]  $ rscript_startup : NULL
[13:22:55.955]  $ rscript_sh      : chr "sh"
[13:22:55.955]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:22:55.955]  $ methods         : logi TRUE
[13:22:55.955]  $ socketOptions   : chr "no-delay"
[13:22:55.955]  $ useXDR          : logi FALSE
[13:22:55.955]  $ outfile         : chr "/dev/null"
[13:22:55.955]  $ renice          : int NA
[13:22:55.955]  $ rshcmd          : NULL
[13:22:55.955]  $ user            : chr(0) 
[13:22:55.955]  $ revtunnel       : logi FALSE
[13:22:55.955]  $ rshlogfile      : NULL
[13:22:55.955]  $ rshopts         : chr(0) 
[13:22:55.955]  $ rank            : int 1
[13:22:55.955]  $ manual          : logi FALSE
[13:22:55.955]  $ dryrun          : logi FALSE
[13:22:55.955]  $ quiet           : logi FALSE
[13:22:55.955]  $ setup_strategy  : chr "parallel"
[13:22:55.955]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:22:55.955]  $ pidfile         : chr "/tmp/RtmphhERam/worker.rank=1.parallelly.parent=83386.145ba5b630fb9.pid"
[13:22:55.955]  $ rshcmd_label    : NULL
[13:22:55.955]  $ rsh_call        : NULL
[13:22:55.955]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:22:55.955]  $ localMachine    : logi TRUE
[13:22:55.955]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:22:55.955]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:22:55.955]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:22:55.955]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:22:55.955]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:22:55.955]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:22:55.955]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:22:55.955]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:22:55.955]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:22:55.955]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:22:55.955]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:22:55.955]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:22:55.955]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:22:55.955]  $ arguments       :List of 28
[13:22:55.955]   ..$ worker          : chr "localhost"
[13:22:55.955]   ..$ master          : NULL
[13:22:55.955]   ..$ port            : int 11937
[13:22:55.955]   ..$ connectTimeout  : num 120
[13:22:55.955]   ..$ timeout         : num 2592000
[13:22:55.955]   ..$ rscript         : NULL
[13:22:55.955]   ..$ homogeneous     : NULL
[13:22:55.955]   ..$ rscript_args    : NULL
[13:22:55.955]   ..$ rscript_envs    : NULL
[13:22:55.955]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:22:55.955]   ..$ rscript_startup : NULL
[13:22:55.955]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:22:55.955]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:22:55.955]   ..$ methods         : logi TRUE
[13:22:55.955]   ..$ socketOptions   : chr "no-delay"
[13:22:55.955]   ..$ useXDR          : logi FALSE
[13:22:55.955]   ..$ outfile         : chr "/dev/null"
[13:22:55.955]   ..$ renice          : int NA
[13:22:55.955]   ..$ rshcmd          : NULL
[13:22:55.955]   ..$ user            : NULL
[13:22:55.955]   ..$ revtunnel       : logi NA
[13:22:55.955]   ..$ rshlogfile      : NULL
[13:22:55.955]   ..$ rshopts         : NULL
[13:22:55.955]   ..$ rank            : int 1
[13:22:55.955]   ..$ manual          : logi FALSE
[13:22:55.955]   ..$ dryrun          : logi FALSE
[13:22:55.955]   ..$ quiet           : logi FALSE
[13:22:55.955]   ..$ setup_strategy  : chr "parallel"
[13:22:55.955]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:22:55.972] [local output] System call to launch all workers:
[13:22:55.972] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmphhERam/worker.rank=1.parallelly.parent=83386.145ba5b630fb9.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11937 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:22:55.972] [local output] Starting PSOCK main server
[13:22:55.978] [local output] Workers launched
[13:22:55.978] [local output] Waiting for workers to connect back
[13:22:55.979]  - [local output] 0 workers out of 2 ready
[13:22:56.236]  - [local output] 0 workers out of 2 ready
[13:22:56.236]  - [local output] 1 workers out of 2 ready
[13:22:56.237]  - [local output] 2 workers out of 2 ready
[13:22:56.237] [local output] Launching of workers completed
[13:22:56.237] [local output] Collecting session information from workers
[13:22:56.238] [local output]  - Worker #1 of 2
[13:22:56.238] [local output]  - Worker #2 of 2
[13:22:56.238] [local output] makeClusterPSOCK() ... done
[13:22:56.250] Packages needed by the future expression (n = 0): <none>
[13:22:56.250] Packages needed by future strategies (n = 0): <none>
[13:22:56.251] {
[13:22:56.251]     {
[13:22:56.251]         {
[13:22:56.251]             ...future.startTime <- base::Sys.time()
[13:22:56.251]             {
[13:22:56.251]                 {
[13:22:56.251]                   {
[13:22:56.251]                     {
[13:22:56.251]                       base::local({
[13:22:56.251]                         has_future <- base::requireNamespace("future", 
[13:22:56.251]                           quietly = TRUE)
[13:22:56.251]                         if (has_future) {
[13:22:56.251]                           ns <- base::getNamespace("future")
[13:22:56.251]                           version <- ns[[".package"]][["version"]]
[13:22:56.251]                           if (is.null(version)) 
[13:22:56.251]                             version <- utils::packageVersion("future")
[13:22:56.251]                         }
[13:22:56.251]                         else {
[13:22:56.251]                           version <- NULL
[13:22:56.251]                         }
[13:22:56.251]                         if (!has_future || version < "1.8.0") {
[13:22:56.251]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:56.251]                             "", base::R.version$version.string), 
[13:22:56.251]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:56.251]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:56.251]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:56.251]                               "release", "version")], collapse = " "), 
[13:22:56.251]                             hostname = base::Sys.info()[["nodename"]])
[13:22:56.251]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:56.251]                             info)
[13:22:56.251]                           info <- base::paste(info, collapse = "; ")
[13:22:56.251]                           if (!has_future) {
[13:22:56.251]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:56.251]                               info)
[13:22:56.251]                           }
[13:22:56.251]                           else {
[13:22:56.251]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:56.251]                               info, version)
[13:22:56.251]                           }
[13:22:56.251]                           base::stop(msg)
[13:22:56.251]                         }
[13:22:56.251]                       })
[13:22:56.251]                     }
[13:22:56.251]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:56.251]                     base::options(mc.cores = 1L)
[13:22:56.251]                   }
[13:22:56.251]                   options(future.plan = NULL)
[13:22:56.251]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:56.251]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:56.251]                 }
[13:22:56.251]                 ...future.workdir <- getwd()
[13:22:56.251]             }
[13:22:56.251]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:56.251]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:56.251]         }
[13:22:56.251]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:56.251]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:56.251]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:56.251]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:56.251]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:56.251]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:56.251]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:56.251]             base::names(...future.oldOptions))
[13:22:56.251]     }
[13:22:56.251]     if (FALSE) {
[13:22:56.251]     }
[13:22:56.251]     else {
[13:22:56.251]         if (TRUE) {
[13:22:56.251]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:56.251]                 open = "w")
[13:22:56.251]         }
[13:22:56.251]         else {
[13:22:56.251]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:56.251]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:56.251]         }
[13:22:56.251]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:56.251]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:56.251]             base::sink(type = "output", split = FALSE)
[13:22:56.251]             base::close(...future.stdout)
[13:22:56.251]         }, add = TRUE)
[13:22:56.251]     }
[13:22:56.251]     ...future.frame <- base::sys.nframe()
[13:22:56.251]     ...future.conditions <- base::list()
[13:22:56.251]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:56.251]     if (FALSE) {
[13:22:56.251]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:56.251]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:56.251]     }
[13:22:56.251]     ...future.result <- base::tryCatch({
[13:22:56.251]         base::withCallingHandlers({
[13:22:56.251]             ...future.value <- base::withVisible(base::local({
[13:22:56.251]                 ...future.makeSendCondition <- base::local({
[13:22:56.251]                   sendCondition <- NULL
[13:22:56.251]                   function(frame = 1L) {
[13:22:56.251]                     if (is.function(sendCondition)) 
[13:22:56.251]                       return(sendCondition)
[13:22:56.251]                     ns <- getNamespace("parallel")
[13:22:56.251]                     if (exists("sendData", mode = "function", 
[13:22:56.251]                       envir = ns)) {
[13:22:56.251]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:56.251]                         envir = ns)
[13:22:56.251]                       envir <- sys.frame(frame)
[13:22:56.251]                       master <- NULL
[13:22:56.251]                       while (!identical(envir, .GlobalEnv) && 
[13:22:56.251]                         !identical(envir, emptyenv())) {
[13:22:56.251]                         if (exists("master", mode = "list", envir = envir, 
[13:22:56.251]                           inherits = FALSE)) {
[13:22:56.251]                           master <- get("master", mode = "list", 
[13:22:56.251]                             envir = envir, inherits = FALSE)
[13:22:56.251]                           if (inherits(master, c("SOCKnode", 
[13:22:56.251]                             "SOCK0node"))) {
[13:22:56.251]                             sendCondition <<- function(cond) {
[13:22:56.251]                               data <- list(type = "VALUE", value = cond, 
[13:22:56.251]                                 success = TRUE)
[13:22:56.251]                               parallel_sendData(master, data)
[13:22:56.251]                             }
[13:22:56.251]                             return(sendCondition)
[13:22:56.251]                           }
[13:22:56.251]                         }
[13:22:56.251]                         frame <- frame + 1L
[13:22:56.251]                         envir <- sys.frame(frame)
[13:22:56.251]                       }
[13:22:56.251]                     }
[13:22:56.251]                     sendCondition <<- function(cond) NULL
[13:22:56.251]                   }
[13:22:56.251]                 })
[13:22:56.251]                 withCallingHandlers({
[13:22:56.251]                   NA
[13:22:56.251]                 }, immediateCondition = function(cond) {
[13:22:56.251]                   sendCondition <- ...future.makeSendCondition()
[13:22:56.251]                   sendCondition(cond)
[13:22:56.251]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:56.251]                   {
[13:22:56.251]                     inherits <- base::inherits
[13:22:56.251]                     invokeRestart <- base::invokeRestart
[13:22:56.251]                     is.null <- base::is.null
[13:22:56.251]                     muffled <- FALSE
[13:22:56.251]                     if (inherits(cond, "message")) {
[13:22:56.251]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:56.251]                       if (muffled) 
[13:22:56.251]                         invokeRestart("muffleMessage")
[13:22:56.251]                     }
[13:22:56.251]                     else if (inherits(cond, "warning")) {
[13:22:56.251]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:56.251]                       if (muffled) 
[13:22:56.251]                         invokeRestart("muffleWarning")
[13:22:56.251]                     }
[13:22:56.251]                     else if (inherits(cond, "condition")) {
[13:22:56.251]                       if (!is.null(pattern)) {
[13:22:56.251]                         computeRestarts <- base::computeRestarts
[13:22:56.251]                         grepl <- base::grepl
[13:22:56.251]                         restarts <- computeRestarts(cond)
[13:22:56.251]                         for (restart in restarts) {
[13:22:56.251]                           name <- restart$name
[13:22:56.251]                           if (is.null(name)) 
[13:22:56.251]                             next
[13:22:56.251]                           if (!grepl(pattern, name)) 
[13:22:56.251]                             next
[13:22:56.251]                           invokeRestart(restart)
[13:22:56.251]                           muffled <- TRUE
[13:22:56.251]                           break
[13:22:56.251]                         }
[13:22:56.251]                       }
[13:22:56.251]                     }
[13:22:56.251]                     invisible(muffled)
[13:22:56.251]                   }
[13:22:56.251]                   muffleCondition(cond)
[13:22:56.251]                 })
[13:22:56.251]             }))
[13:22:56.251]             future::FutureResult(value = ...future.value$value, 
[13:22:56.251]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:56.251]                   ...future.rng), globalenv = if (FALSE) 
[13:22:56.251]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:56.251]                     ...future.globalenv.names))
[13:22:56.251]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:56.251]         }, condition = base::local({
[13:22:56.251]             c <- base::c
[13:22:56.251]             inherits <- base::inherits
[13:22:56.251]             invokeRestart <- base::invokeRestart
[13:22:56.251]             length <- base::length
[13:22:56.251]             list <- base::list
[13:22:56.251]             seq.int <- base::seq.int
[13:22:56.251]             signalCondition <- base::signalCondition
[13:22:56.251]             sys.calls <- base::sys.calls
[13:22:56.251]             `[[` <- base::`[[`
[13:22:56.251]             `+` <- base::`+`
[13:22:56.251]             `<<-` <- base::`<<-`
[13:22:56.251]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:56.251]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:56.251]                   3L)]
[13:22:56.251]             }
[13:22:56.251]             function(cond) {
[13:22:56.251]                 is_error <- inherits(cond, "error")
[13:22:56.251]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:56.251]                   NULL)
[13:22:56.251]                 if (is_error) {
[13:22:56.251]                   sessionInformation <- function() {
[13:22:56.251]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:56.251]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:56.251]                       search = base::search(), system = base::Sys.info())
[13:22:56.251]                   }
[13:22:56.251]                   ...future.conditions[[length(...future.conditions) + 
[13:22:56.251]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:56.251]                     cond$call), session = sessionInformation(), 
[13:22:56.251]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:56.251]                   signalCondition(cond)
[13:22:56.251]                 }
[13:22:56.251]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:56.251]                 "immediateCondition"))) {
[13:22:56.251]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:56.251]                   ...future.conditions[[length(...future.conditions) + 
[13:22:56.251]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:56.251]                   if (TRUE && !signal) {
[13:22:56.251]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:56.251]                     {
[13:22:56.251]                       inherits <- base::inherits
[13:22:56.251]                       invokeRestart <- base::invokeRestart
[13:22:56.251]                       is.null <- base::is.null
[13:22:56.251]                       muffled <- FALSE
[13:22:56.251]                       if (inherits(cond, "message")) {
[13:22:56.251]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:56.251]                         if (muffled) 
[13:22:56.251]                           invokeRestart("muffleMessage")
[13:22:56.251]                       }
[13:22:56.251]                       else if (inherits(cond, "warning")) {
[13:22:56.251]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:56.251]                         if (muffled) 
[13:22:56.251]                           invokeRestart("muffleWarning")
[13:22:56.251]                       }
[13:22:56.251]                       else if (inherits(cond, "condition")) {
[13:22:56.251]                         if (!is.null(pattern)) {
[13:22:56.251]                           computeRestarts <- base::computeRestarts
[13:22:56.251]                           grepl <- base::grepl
[13:22:56.251]                           restarts <- computeRestarts(cond)
[13:22:56.251]                           for (restart in restarts) {
[13:22:56.251]                             name <- restart$name
[13:22:56.251]                             if (is.null(name)) 
[13:22:56.251]                               next
[13:22:56.251]                             if (!grepl(pattern, name)) 
[13:22:56.251]                               next
[13:22:56.251]                             invokeRestart(restart)
[13:22:56.251]                             muffled <- TRUE
[13:22:56.251]                             break
[13:22:56.251]                           }
[13:22:56.251]                         }
[13:22:56.251]                       }
[13:22:56.251]                       invisible(muffled)
[13:22:56.251]                     }
[13:22:56.251]                     muffleCondition(cond, pattern = "^muffle")
[13:22:56.251]                   }
[13:22:56.251]                 }
[13:22:56.251]                 else {
[13:22:56.251]                   if (TRUE) {
[13:22:56.251]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:56.251]                     {
[13:22:56.251]                       inherits <- base::inherits
[13:22:56.251]                       invokeRestart <- base::invokeRestart
[13:22:56.251]                       is.null <- base::is.null
[13:22:56.251]                       muffled <- FALSE
[13:22:56.251]                       if (inherits(cond, "message")) {
[13:22:56.251]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:56.251]                         if (muffled) 
[13:22:56.251]                           invokeRestart("muffleMessage")
[13:22:56.251]                       }
[13:22:56.251]                       else if (inherits(cond, "warning")) {
[13:22:56.251]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:56.251]                         if (muffled) 
[13:22:56.251]                           invokeRestart("muffleWarning")
[13:22:56.251]                       }
[13:22:56.251]                       else if (inherits(cond, "condition")) {
[13:22:56.251]                         if (!is.null(pattern)) {
[13:22:56.251]                           computeRestarts <- base::computeRestarts
[13:22:56.251]                           grepl <- base::grepl
[13:22:56.251]                           restarts <- computeRestarts(cond)
[13:22:56.251]                           for (restart in restarts) {
[13:22:56.251]                             name <- restart$name
[13:22:56.251]                             if (is.null(name)) 
[13:22:56.251]                               next
[13:22:56.251]                             if (!grepl(pattern, name)) 
[13:22:56.251]                               next
[13:22:56.251]                             invokeRestart(restart)
[13:22:56.251]                             muffled <- TRUE
[13:22:56.251]                             break
[13:22:56.251]                           }
[13:22:56.251]                         }
[13:22:56.251]                       }
[13:22:56.251]                       invisible(muffled)
[13:22:56.251]                     }
[13:22:56.251]                     muffleCondition(cond, pattern = "^muffle")
[13:22:56.251]                   }
[13:22:56.251]                 }
[13:22:56.251]             }
[13:22:56.251]         }))
[13:22:56.251]     }, error = function(ex) {
[13:22:56.251]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:56.251]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:56.251]                 ...future.rng), started = ...future.startTime, 
[13:22:56.251]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:56.251]             version = "1.8"), class = "FutureResult")
[13:22:56.251]     }, finally = {
[13:22:56.251]         if (!identical(...future.workdir, getwd())) 
[13:22:56.251]             setwd(...future.workdir)
[13:22:56.251]         {
[13:22:56.251]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:56.251]                 ...future.oldOptions$nwarnings <- NULL
[13:22:56.251]             }
[13:22:56.251]             base::options(...future.oldOptions)
[13:22:56.251]             if (.Platform$OS.type == "windows") {
[13:22:56.251]                 old_names <- names(...future.oldEnvVars)
[13:22:56.251]                 envs <- base::Sys.getenv()
[13:22:56.251]                 names <- names(envs)
[13:22:56.251]                 common <- intersect(names, old_names)
[13:22:56.251]                 added <- setdiff(names, old_names)
[13:22:56.251]                 removed <- setdiff(old_names, names)
[13:22:56.251]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:56.251]                   envs[common]]
[13:22:56.251]                 NAMES <- toupper(changed)
[13:22:56.251]                 args <- list()
[13:22:56.251]                 for (kk in seq_along(NAMES)) {
[13:22:56.251]                   name <- changed[[kk]]
[13:22:56.251]                   NAME <- NAMES[[kk]]
[13:22:56.251]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:56.251]                     next
[13:22:56.251]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:56.251]                 }
[13:22:56.251]                 NAMES <- toupper(added)
[13:22:56.251]                 for (kk in seq_along(NAMES)) {
[13:22:56.251]                   name <- added[[kk]]
[13:22:56.251]                   NAME <- NAMES[[kk]]
[13:22:56.251]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:56.251]                     next
[13:22:56.251]                   args[[name]] <- ""
[13:22:56.251]                 }
[13:22:56.251]                 NAMES <- toupper(removed)
[13:22:56.251]                 for (kk in seq_along(NAMES)) {
[13:22:56.251]                   name <- removed[[kk]]
[13:22:56.251]                   NAME <- NAMES[[kk]]
[13:22:56.251]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:56.251]                     next
[13:22:56.251]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:56.251]                 }
[13:22:56.251]                 if (length(args) > 0) 
[13:22:56.251]                   base::do.call(base::Sys.setenv, args = args)
[13:22:56.251]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:56.251]             }
[13:22:56.251]             else {
[13:22:56.251]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:56.251]             }
[13:22:56.251]             {
[13:22:56.251]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:56.251]                   0L) {
[13:22:56.251]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:56.251]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:56.251]                   base::options(opts)
[13:22:56.251]                 }
[13:22:56.251]                 {
[13:22:56.251]                   {
[13:22:56.251]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:56.251]                     NULL
[13:22:56.251]                   }
[13:22:56.251]                   options(future.plan = NULL)
[13:22:56.251]                   if (is.na(NA_character_)) 
[13:22:56.251]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:56.251]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:56.251]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:56.251]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:56.251]                     envir = parent.frame()) 
[13:22:56.251]                   {
[13:22:56.251]                     if (is.function(workers)) 
[13:22:56.251]                       workers <- workers()
[13:22:56.251]                     workers <- structure(as.integer(workers), 
[13:22:56.251]                       class = class(workers))
[13:22:56.251]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:56.251]                       workers >= 1)
[13:22:56.251]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:56.251]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:56.251]                     }
[13:22:56.251]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:56.251]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:56.251]                       envir = envir)
[13:22:56.251]                     if (!future$lazy) 
[13:22:56.251]                       future <- run(future)
[13:22:56.251]                     invisible(future)
[13:22:56.251]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:56.251]                 }
[13:22:56.251]             }
[13:22:56.251]         }
[13:22:56.251]     })
[13:22:56.251]     if (TRUE) {
[13:22:56.251]         base::sink(type = "output", split = FALSE)
[13:22:56.251]         if (TRUE) {
[13:22:56.251]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:56.251]         }
[13:22:56.251]         else {
[13:22:56.251]             ...future.result["stdout"] <- base::list(NULL)
[13:22:56.251]         }
[13:22:56.251]         base::close(...future.stdout)
[13:22:56.251]         ...future.stdout <- NULL
[13:22:56.251]     }
[13:22:56.251]     ...future.result$conditions <- ...future.conditions
[13:22:56.251]     ...future.result$finished <- base::Sys.time()
[13:22:56.251]     ...future.result
[13:22:56.251] }
[13:22:56.307] MultisessionFuture started
[13:22:56.307] result() for ClusterFuture ...
[13:22:56.308] receiveMessageFromWorker() for ClusterFuture ...
[13:22:56.309] - Validating connection of MultisessionFuture
[13:22:56.354] - received message: FutureResult
[13:22:56.355] - Received FutureResult
[13:22:56.355] - Erased future from FutureRegistry
[13:22:56.355] result() for ClusterFuture ...
[13:22:56.355] - result already collected: FutureResult
[13:22:56.355] result() for ClusterFuture ... done
[13:22:56.356] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:56.356] result() for ClusterFuture ... done
[13:22:56.356] result() for ClusterFuture ...
[13:22:56.356] - result already collected: FutureResult
[13:22:56.356] result() for ClusterFuture ... done
[13:22:56.356] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:22:56.361] plan(): nbrOfWorkers() = 2
** Future evaluation without globals
[13:22:56.361] getGlobalsAndPackages() ...
[13:22:56.361] Searching for globals...
[13:22:56.362] - globals found: [2] ‘{’, ‘<-’
[13:22:56.363] Searching for globals ... DONE
[13:22:56.363] Resolving globals: FALSE
[13:22:56.363] 
[13:22:56.363] 
[13:22:56.363] getGlobalsAndPackages() ... DONE
[13:22:56.364] run() for ‘Future’ ...
[13:22:56.364] - state: ‘created’
[13:22:56.364] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:56.379] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:56.379] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:56.380]   - Field: ‘node’
[13:22:56.380]   - Field: ‘label’
[13:22:56.380]   - Field: ‘local’
[13:22:56.380]   - Field: ‘owner’
[13:22:56.380]   - Field: ‘envir’
[13:22:56.380]   - Field: ‘workers’
[13:22:56.380]   - Field: ‘packages’
[13:22:56.380]   - Field: ‘gc’
[13:22:56.380]   - Field: ‘conditions’
[13:22:56.381]   - Field: ‘persistent’
[13:22:56.381]   - Field: ‘expr’
[13:22:56.381]   - Field: ‘uuid’
[13:22:56.381]   - Field: ‘seed’
[13:22:56.381]   - Field: ‘version’
[13:22:56.381]   - Field: ‘result’
[13:22:56.381]   - Field: ‘asynchronous’
[13:22:56.381]   - Field: ‘calls’
[13:22:56.381]   - Field: ‘globals’
[13:22:56.382]   - Field: ‘stdout’
[13:22:56.382]   - Field: ‘earlySignal’
[13:22:56.382]   - Field: ‘lazy’
[13:22:56.382]   - Field: ‘state’
[13:22:56.382] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:56.382] - Launch lazy future ...
[13:22:56.383] Packages needed by the future expression (n = 0): <none>
[13:22:56.383] Packages needed by future strategies (n = 0): <none>
[13:22:56.383] {
[13:22:56.383]     {
[13:22:56.383]         {
[13:22:56.383]             ...future.startTime <- base::Sys.time()
[13:22:56.383]             {
[13:22:56.383]                 {
[13:22:56.383]                   {
[13:22:56.383]                     {
[13:22:56.383]                       base::local({
[13:22:56.383]                         has_future <- base::requireNamespace("future", 
[13:22:56.383]                           quietly = TRUE)
[13:22:56.383]                         if (has_future) {
[13:22:56.383]                           ns <- base::getNamespace("future")
[13:22:56.383]                           version <- ns[[".package"]][["version"]]
[13:22:56.383]                           if (is.null(version)) 
[13:22:56.383]                             version <- utils::packageVersion("future")
[13:22:56.383]                         }
[13:22:56.383]                         else {
[13:22:56.383]                           version <- NULL
[13:22:56.383]                         }
[13:22:56.383]                         if (!has_future || version < "1.8.0") {
[13:22:56.383]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:56.383]                             "", base::R.version$version.string), 
[13:22:56.383]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:56.383]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:56.383]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:56.383]                               "release", "version")], collapse = " "), 
[13:22:56.383]                             hostname = base::Sys.info()[["nodename"]])
[13:22:56.383]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:56.383]                             info)
[13:22:56.383]                           info <- base::paste(info, collapse = "; ")
[13:22:56.383]                           if (!has_future) {
[13:22:56.383]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:56.383]                               info)
[13:22:56.383]                           }
[13:22:56.383]                           else {
[13:22:56.383]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:56.383]                               info, version)
[13:22:56.383]                           }
[13:22:56.383]                           base::stop(msg)
[13:22:56.383]                         }
[13:22:56.383]                       })
[13:22:56.383]                     }
[13:22:56.383]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:56.383]                     base::options(mc.cores = 1L)
[13:22:56.383]                   }
[13:22:56.383]                   options(future.plan = NULL)
[13:22:56.383]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:56.383]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:56.383]                 }
[13:22:56.383]                 ...future.workdir <- getwd()
[13:22:56.383]             }
[13:22:56.383]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:56.383]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:56.383]         }
[13:22:56.383]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:56.383]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:56.383]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:56.383]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:56.383]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:56.383]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:56.383]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:56.383]             base::names(...future.oldOptions))
[13:22:56.383]     }
[13:22:56.383]     if (FALSE) {
[13:22:56.383]     }
[13:22:56.383]     else {
[13:22:56.383]         if (TRUE) {
[13:22:56.383]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:56.383]                 open = "w")
[13:22:56.383]         }
[13:22:56.383]         else {
[13:22:56.383]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:56.383]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:56.383]         }
[13:22:56.383]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:56.383]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:56.383]             base::sink(type = "output", split = FALSE)
[13:22:56.383]             base::close(...future.stdout)
[13:22:56.383]         }, add = TRUE)
[13:22:56.383]     }
[13:22:56.383]     ...future.frame <- base::sys.nframe()
[13:22:56.383]     ...future.conditions <- base::list()
[13:22:56.383]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:56.383]     if (FALSE) {
[13:22:56.383]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:56.383]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:56.383]     }
[13:22:56.383]     ...future.result <- base::tryCatch({
[13:22:56.383]         base::withCallingHandlers({
[13:22:56.383]             ...future.value <- base::withVisible(base::local({
[13:22:56.383]                 ...future.makeSendCondition <- base::local({
[13:22:56.383]                   sendCondition <- NULL
[13:22:56.383]                   function(frame = 1L) {
[13:22:56.383]                     if (is.function(sendCondition)) 
[13:22:56.383]                       return(sendCondition)
[13:22:56.383]                     ns <- getNamespace("parallel")
[13:22:56.383]                     if (exists("sendData", mode = "function", 
[13:22:56.383]                       envir = ns)) {
[13:22:56.383]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:56.383]                         envir = ns)
[13:22:56.383]                       envir <- sys.frame(frame)
[13:22:56.383]                       master <- NULL
[13:22:56.383]                       while (!identical(envir, .GlobalEnv) && 
[13:22:56.383]                         !identical(envir, emptyenv())) {
[13:22:56.383]                         if (exists("master", mode = "list", envir = envir, 
[13:22:56.383]                           inherits = FALSE)) {
[13:22:56.383]                           master <- get("master", mode = "list", 
[13:22:56.383]                             envir = envir, inherits = FALSE)
[13:22:56.383]                           if (inherits(master, c("SOCKnode", 
[13:22:56.383]                             "SOCK0node"))) {
[13:22:56.383]                             sendCondition <<- function(cond) {
[13:22:56.383]                               data <- list(type = "VALUE", value = cond, 
[13:22:56.383]                                 success = TRUE)
[13:22:56.383]                               parallel_sendData(master, data)
[13:22:56.383]                             }
[13:22:56.383]                             return(sendCondition)
[13:22:56.383]                           }
[13:22:56.383]                         }
[13:22:56.383]                         frame <- frame + 1L
[13:22:56.383]                         envir <- sys.frame(frame)
[13:22:56.383]                       }
[13:22:56.383]                     }
[13:22:56.383]                     sendCondition <<- function(cond) NULL
[13:22:56.383]                   }
[13:22:56.383]                 })
[13:22:56.383]                 withCallingHandlers({
[13:22:56.383]                   {
[13:22:56.383]                     x <- 1
[13:22:56.383]                   }
[13:22:56.383]                 }, immediateCondition = function(cond) {
[13:22:56.383]                   sendCondition <- ...future.makeSendCondition()
[13:22:56.383]                   sendCondition(cond)
[13:22:56.383]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:56.383]                   {
[13:22:56.383]                     inherits <- base::inherits
[13:22:56.383]                     invokeRestart <- base::invokeRestart
[13:22:56.383]                     is.null <- base::is.null
[13:22:56.383]                     muffled <- FALSE
[13:22:56.383]                     if (inherits(cond, "message")) {
[13:22:56.383]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:56.383]                       if (muffled) 
[13:22:56.383]                         invokeRestart("muffleMessage")
[13:22:56.383]                     }
[13:22:56.383]                     else if (inherits(cond, "warning")) {
[13:22:56.383]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:56.383]                       if (muffled) 
[13:22:56.383]                         invokeRestart("muffleWarning")
[13:22:56.383]                     }
[13:22:56.383]                     else if (inherits(cond, "condition")) {
[13:22:56.383]                       if (!is.null(pattern)) {
[13:22:56.383]                         computeRestarts <- base::computeRestarts
[13:22:56.383]                         grepl <- base::grepl
[13:22:56.383]                         restarts <- computeRestarts(cond)
[13:22:56.383]                         for (restart in restarts) {
[13:22:56.383]                           name <- restart$name
[13:22:56.383]                           if (is.null(name)) 
[13:22:56.383]                             next
[13:22:56.383]                           if (!grepl(pattern, name)) 
[13:22:56.383]                             next
[13:22:56.383]                           invokeRestart(restart)
[13:22:56.383]                           muffled <- TRUE
[13:22:56.383]                           break
[13:22:56.383]                         }
[13:22:56.383]                       }
[13:22:56.383]                     }
[13:22:56.383]                     invisible(muffled)
[13:22:56.383]                   }
[13:22:56.383]                   muffleCondition(cond)
[13:22:56.383]                 })
[13:22:56.383]             }))
[13:22:56.383]             future::FutureResult(value = ...future.value$value, 
[13:22:56.383]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:56.383]                   ...future.rng), globalenv = if (FALSE) 
[13:22:56.383]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:56.383]                     ...future.globalenv.names))
[13:22:56.383]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:56.383]         }, condition = base::local({
[13:22:56.383]             c <- base::c
[13:22:56.383]             inherits <- base::inherits
[13:22:56.383]             invokeRestart <- base::invokeRestart
[13:22:56.383]             length <- base::length
[13:22:56.383]             list <- base::list
[13:22:56.383]             seq.int <- base::seq.int
[13:22:56.383]             signalCondition <- base::signalCondition
[13:22:56.383]             sys.calls <- base::sys.calls
[13:22:56.383]             `[[` <- base::`[[`
[13:22:56.383]             `+` <- base::`+`
[13:22:56.383]             `<<-` <- base::`<<-`
[13:22:56.383]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:56.383]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:56.383]                   3L)]
[13:22:56.383]             }
[13:22:56.383]             function(cond) {
[13:22:56.383]                 is_error <- inherits(cond, "error")
[13:22:56.383]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:56.383]                   NULL)
[13:22:56.383]                 if (is_error) {
[13:22:56.383]                   sessionInformation <- function() {
[13:22:56.383]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:56.383]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:56.383]                       search = base::search(), system = base::Sys.info())
[13:22:56.383]                   }
[13:22:56.383]                   ...future.conditions[[length(...future.conditions) + 
[13:22:56.383]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:56.383]                     cond$call), session = sessionInformation(), 
[13:22:56.383]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:56.383]                   signalCondition(cond)
[13:22:56.383]                 }
[13:22:56.383]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:56.383]                 "immediateCondition"))) {
[13:22:56.383]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:56.383]                   ...future.conditions[[length(...future.conditions) + 
[13:22:56.383]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:56.383]                   if (TRUE && !signal) {
[13:22:56.383]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:56.383]                     {
[13:22:56.383]                       inherits <- base::inherits
[13:22:56.383]                       invokeRestart <- base::invokeRestart
[13:22:56.383]                       is.null <- base::is.null
[13:22:56.383]                       muffled <- FALSE
[13:22:56.383]                       if (inherits(cond, "message")) {
[13:22:56.383]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:56.383]                         if (muffled) 
[13:22:56.383]                           invokeRestart("muffleMessage")
[13:22:56.383]                       }
[13:22:56.383]                       else if (inherits(cond, "warning")) {
[13:22:56.383]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:56.383]                         if (muffled) 
[13:22:56.383]                           invokeRestart("muffleWarning")
[13:22:56.383]                       }
[13:22:56.383]                       else if (inherits(cond, "condition")) {
[13:22:56.383]                         if (!is.null(pattern)) {
[13:22:56.383]                           computeRestarts <- base::computeRestarts
[13:22:56.383]                           grepl <- base::grepl
[13:22:56.383]                           restarts <- computeRestarts(cond)
[13:22:56.383]                           for (restart in restarts) {
[13:22:56.383]                             name <- restart$name
[13:22:56.383]                             if (is.null(name)) 
[13:22:56.383]                               next
[13:22:56.383]                             if (!grepl(pattern, name)) 
[13:22:56.383]                               next
[13:22:56.383]                             invokeRestart(restart)
[13:22:56.383]                             muffled <- TRUE
[13:22:56.383]                             break
[13:22:56.383]                           }
[13:22:56.383]                         }
[13:22:56.383]                       }
[13:22:56.383]                       invisible(muffled)
[13:22:56.383]                     }
[13:22:56.383]                     muffleCondition(cond, pattern = "^muffle")
[13:22:56.383]                   }
[13:22:56.383]                 }
[13:22:56.383]                 else {
[13:22:56.383]                   if (TRUE) {
[13:22:56.383]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:56.383]                     {
[13:22:56.383]                       inherits <- base::inherits
[13:22:56.383]                       invokeRestart <- base::invokeRestart
[13:22:56.383]                       is.null <- base::is.null
[13:22:56.383]                       muffled <- FALSE
[13:22:56.383]                       if (inherits(cond, "message")) {
[13:22:56.383]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:56.383]                         if (muffled) 
[13:22:56.383]                           invokeRestart("muffleMessage")
[13:22:56.383]                       }
[13:22:56.383]                       else if (inherits(cond, "warning")) {
[13:22:56.383]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:56.383]                         if (muffled) 
[13:22:56.383]                           invokeRestart("muffleWarning")
[13:22:56.383]                       }
[13:22:56.383]                       else if (inherits(cond, "condition")) {
[13:22:56.383]                         if (!is.null(pattern)) {
[13:22:56.383]                           computeRestarts <- base::computeRestarts
[13:22:56.383]                           grepl <- base::grepl
[13:22:56.383]                           restarts <- computeRestarts(cond)
[13:22:56.383]                           for (restart in restarts) {
[13:22:56.383]                             name <- restart$name
[13:22:56.383]                             if (is.null(name)) 
[13:22:56.383]                               next
[13:22:56.383]                             if (!grepl(pattern, name)) 
[13:22:56.383]                               next
[13:22:56.383]                             invokeRestart(restart)
[13:22:56.383]                             muffled <- TRUE
[13:22:56.383]                             break
[13:22:56.383]                           }
[13:22:56.383]                         }
[13:22:56.383]                       }
[13:22:56.383]                       invisible(muffled)
[13:22:56.383]                     }
[13:22:56.383]                     muffleCondition(cond, pattern = "^muffle")
[13:22:56.383]                   }
[13:22:56.383]                 }
[13:22:56.383]             }
[13:22:56.383]         }))
[13:22:56.383]     }, error = function(ex) {
[13:22:56.383]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:56.383]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:56.383]                 ...future.rng), started = ...future.startTime, 
[13:22:56.383]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:56.383]             version = "1.8"), class = "FutureResult")
[13:22:56.383]     }, finally = {
[13:22:56.383]         if (!identical(...future.workdir, getwd())) 
[13:22:56.383]             setwd(...future.workdir)
[13:22:56.383]         {
[13:22:56.383]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:56.383]                 ...future.oldOptions$nwarnings <- NULL
[13:22:56.383]             }
[13:22:56.383]             base::options(...future.oldOptions)
[13:22:56.383]             if (.Platform$OS.type == "windows") {
[13:22:56.383]                 old_names <- names(...future.oldEnvVars)
[13:22:56.383]                 envs <- base::Sys.getenv()
[13:22:56.383]                 names <- names(envs)
[13:22:56.383]                 common <- intersect(names, old_names)
[13:22:56.383]                 added <- setdiff(names, old_names)
[13:22:56.383]                 removed <- setdiff(old_names, names)
[13:22:56.383]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:56.383]                   envs[common]]
[13:22:56.383]                 NAMES <- toupper(changed)
[13:22:56.383]                 args <- list()
[13:22:56.383]                 for (kk in seq_along(NAMES)) {
[13:22:56.383]                   name <- changed[[kk]]
[13:22:56.383]                   NAME <- NAMES[[kk]]
[13:22:56.383]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:56.383]                     next
[13:22:56.383]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:56.383]                 }
[13:22:56.383]                 NAMES <- toupper(added)
[13:22:56.383]                 for (kk in seq_along(NAMES)) {
[13:22:56.383]                   name <- added[[kk]]
[13:22:56.383]                   NAME <- NAMES[[kk]]
[13:22:56.383]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:56.383]                     next
[13:22:56.383]                   args[[name]] <- ""
[13:22:56.383]                 }
[13:22:56.383]                 NAMES <- toupper(removed)
[13:22:56.383]                 for (kk in seq_along(NAMES)) {
[13:22:56.383]                   name <- removed[[kk]]
[13:22:56.383]                   NAME <- NAMES[[kk]]
[13:22:56.383]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:56.383]                     next
[13:22:56.383]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:56.383]                 }
[13:22:56.383]                 if (length(args) > 0) 
[13:22:56.383]                   base::do.call(base::Sys.setenv, args = args)
[13:22:56.383]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:56.383]             }
[13:22:56.383]             else {
[13:22:56.383]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:56.383]             }
[13:22:56.383]             {
[13:22:56.383]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:56.383]                   0L) {
[13:22:56.383]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:56.383]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:56.383]                   base::options(opts)
[13:22:56.383]                 }
[13:22:56.383]                 {
[13:22:56.383]                   {
[13:22:56.383]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:56.383]                     NULL
[13:22:56.383]                   }
[13:22:56.383]                   options(future.plan = NULL)
[13:22:56.383]                   if (is.na(NA_character_)) 
[13:22:56.383]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:56.383]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:56.383]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:56.383]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:56.383]                     envir = parent.frame()) 
[13:22:56.383]                   {
[13:22:56.383]                     if (is.function(workers)) 
[13:22:56.383]                       workers <- workers()
[13:22:56.383]                     workers <- structure(as.integer(workers), 
[13:22:56.383]                       class = class(workers))
[13:22:56.383]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:56.383]                       workers >= 1)
[13:22:56.383]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:56.383]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:56.383]                     }
[13:22:56.383]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:56.383]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:56.383]                       envir = envir)
[13:22:56.383]                     if (!future$lazy) 
[13:22:56.383]                       future <- run(future)
[13:22:56.383]                     invisible(future)
[13:22:56.383]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:56.383]                 }
[13:22:56.383]             }
[13:22:56.383]         }
[13:22:56.383]     })
[13:22:56.383]     if (TRUE) {
[13:22:56.383]         base::sink(type = "output", split = FALSE)
[13:22:56.383]         if (TRUE) {
[13:22:56.383]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:56.383]         }
[13:22:56.383]         else {
[13:22:56.383]             ...future.result["stdout"] <- base::list(NULL)
[13:22:56.383]         }
[13:22:56.383]         base::close(...future.stdout)
[13:22:56.383]         ...future.stdout <- NULL
[13:22:56.383]     }
[13:22:56.383]     ...future.result$conditions <- ...future.conditions
[13:22:56.383]     ...future.result$finished <- base::Sys.time()
[13:22:56.383]     ...future.result
[13:22:56.383] }
[13:22:56.387] MultisessionFuture started
[13:22:56.387] - Launch lazy future ... done
[13:22:56.387] run() for ‘MultisessionFuture’ ... done
[13:22:56.388] result() for ClusterFuture ...
[13:22:56.388] receiveMessageFromWorker() for ClusterFuture ...
[13:22:56.388] - Validating connection of MultisessionFuture
[13:22:56.433] - received message: FutureResult
[13:22:56.434] - Received FutureResult
[13:22:56.434] - Erased future from FutureRegistry
[13:22:56.434] result() for ClusterFuture ...
[13:22:56.434] - result already collected: FutureResult
[13:22:56.434] result() for ClusterFuture ... done
[13:22:56.434] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:56.434] result() for ClusterFuture ... done
[13:22:56.434] result() for ClusterFuture ...
[13:22:56.435] - result already collected: FutureResult
[13:22:56.435] result() for ClusterFuture ... done
** Future evaluation with globals
[13:22:56.435] getGlobalsAndPackages() ...
[13:22:56.435] Searching for globals...
[13:22:56.437] - globals found: [3] ‘{’, ‘<-’, ‘a’
[13:22:56.437] Searching for globals ... DONE
[13:22:56.437] Resolving globals: FALSE
[13:22:56.437] The total size of the 1 globals is 56 bytes (56 bytes)
[13:22:56.438] The total size of the 1 globals exported for future expression (‘{; x <- a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:22:56.438] - globals: [1] ‘a’
[13:22:56.438] 
[13:22:56.438] getGlobalsAndPackages() ... DONE
[13:22:56.439] run() for ‘Future’ ...
[13:22:56.439] - state: ‘created’
[13:22:56.439] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:56.454] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:56.454] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:56.454]   - Field: ‘node’
[13:22:56.454]   - Field: ‘label’
[13:22:56.454]   - Field: ‘local’
[13:22:56.455]   - Field: ‘owner’
[13:22:56.455]   - Field: ‘envir’
[13:22:56.455]   - Field: ‘workers’
[13:22:56.455]   - Field: ‘packages’
[13:22:56.455]   - Field: ‘gc’
[13:22:56.455]   - Field: ‘conditions’
[13:22:56.455]   - Field: ‘persistent’
[13:22:56.455]   - Field: ‘expr’
[13:22:56.455]   - Field: ‘uuid’
[13:22:56.456]   - Field: ‘seed’
[13:22:56.456]   - Field: ‘version’
[13:22:56.456]   - Field: ‘result’
[13:22:56.456]   - Field: ‘asynchronous’
[13:22:56.456]   - Field: ‘calls’
[13:22:56.456]   - Field: ‘globals’
[13:22:56.456]   - Field: ‘stdout’
[13:22:56.456]   - Field: ‘earlySignal’
[13:22:56.457]   - Field: ‘lazy’
[13:22:56.457]   - Field: ‘state’
[13:22:56.457] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:56.457] - Launch lazy future ...
[13:22:56.457] Packages needed by the future expression (n = 0): <none>
[13:22:56.457] Packages needed by future strategies (n = 0): <none>
[13:22:56.458] {
[13:22:56.458]     {
[13:22:56.458]         {
[13:22:56.458]             ...future.startTime <- base::Sys.time()
[13:22:56.458]             {
[13:22:56.458]                 {
[13:22:56.458]                   {
[13:22:56.458]                     {
[13:22:56.458]                       base::local({
[13:22:56.458]                         has_future <- base::requireNamespace("future", 
[13:22:56.458]                           quietly = TRUE)
[13:22:56.458]                         if (has_future) {
[13:22:56.458]                           ns <- base::getNamespace("future")
[13:22:56.458]                           version <- ns[[".package"]][["version"]]
[13:22:56.458]                           if (is.null(version)) 
[13:22:56.458]                             version <- utils::packageVersion("future")
[13:22:56.458]                         }
[13:22:56.458]                         else {
[13:22:56.458]                           version <- NULL
[13:22:56.458]                         }
[13:22:56.458]                         if (!has_future || version < "1.8.0") {
[13:22:56.458]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:56.458]                             "", base::R.version$version.string), 
[13:22:56.458]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:56.458]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:56.458]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:56.458]                               "release", "version")], collapse = " "), 
[13:22:56.458]                             hostname = base::Sys.info()[["nodename"]])
[13:22:56.458]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:56.458]                             info)
[13:22:56.458]                           info <- base::paste(info, collapse = "; ")
[13:22:56.458]                           if (!has_future) {
[13:22:56.458]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:56.458]                               info)
[13:22:56.458]                           }
[13:22:56.458]                           else {
[13:22:56.458]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:56.458]                               info, version)
[13:22:56.458]                           }
[13:22:56.458]                           base::stop(msg)
[13:22:56.458]                         }
[13:22:56.458]                       })
[13:22:56.458]                     }
[13:22:56.458]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:56.458]                     base::options(mc.cores = 1L)
[13:22:56.458]                   }
[13:22:56.458]                   options(future.plan = NULL)
[13:22:56.458]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:56.458]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:56.458]                 }
[13:22:56.458]                 ...future.workdir <- getwd()
[13:22:56.458]             }
[13:22:56.458]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:56.458]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:56.458]         }
[13:22:56.458]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:56.458]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:56.458]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:56.458]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:56.458]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:56.458]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:56.458]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:56.458]             base::names(...future.oldOptions))
[13:22:56.458]     }
[13:22:56.458]     if (FALSE) {
[13:22:56.458]     }
[13:22:56.458]     else {
[13:22:56.458]         if (TRUE) {
[13:22:56.458]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:56.458]                 open = "w")
[13:22:56.458]         }
[13:22:56.458]         else {
[13:22:56.458]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:56.458]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:56.458]         }
[13:22:56.458]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:56.458]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:56.458]             base::sink(type = "output", split = FALSE)
[13:22:56.458]             base::close(...future.stdout)
[13:22:56.458]         }, add = TRUE)
[13:22:56.458]     }
[13:22:56.458]     ...future.frame <- base::sys.nframe()
[13:22:56.458]     ...future.conditions <- base::list()
[13:22:56.458]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:56.458]     if (FALSE) {
[13:22:56.458]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:56.458]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:56.458]     }
[13:22:56.458]     ...future.result <- base::tryCatch({
[13:22:56.458]         base::withCallingHandlers({
[13:22:56.458]             ...future.value <- base::withVisible(base::local({
[13:22:56.458]                 ...future.makeSendCondition <- base::local({
[13:22:56.458]                   sendCondition <- NULL
[13:22:56.458]                   function(frame = 1L) {
[13:22:56.458]                     if (is.function(sendCondition)) 
[13:22:56.458]                       return(sendCondition)
[13:22:56.458]                     ns <- getNamespace("parallel")
[13:22:56.458]                     if (exists("sendData", mode = "function", 
[13:22:56.458]                       envir = ns)) {
[13:22:56.458]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:56.458]                         envir = ns)
[13:22:56.458]                       envir <- sys.frame(frame)
[13:22:56.458]                       master <- NULL
[13:22:56.458]                       while (!identical(envir, .GlobalEnv) && 
[13:22:56.458]                         !identical(envir, emptyenv())) {
[13:22:56.458]                         if (exists("master", mode = "list", envir = envir, 
[13:22:56.458]                           inherits = FALSE)) {
[13:22:56.458]                           master <- get("master", mode = "list", 
[13:22:56.458]                             envir = envir, inherits = FALSE)
[13:22:56.458]                           if (inherits(master, c("SOCKnode", 
[13:22:56.458]                             "SOCK0node"))) {
[13:22:56.458]                             sendCondition <<- function(cond) {
[13:22:56.458]                               data <- list(type = "VALUE", value = cond, 
[13:22:56.458]                                 success = TRUE)
[13:22:56.458]                               parallel_sendData(master, data)
[13:22:56.458]                             }
[13:22:56.458]                             return(sendCondition)
[13:22:56.458]                           }
[13:22:56.458]                         }
[13:22:56.458]                         frame <- frame + 1L
[13:22:56.458]                         envir <- sys.frame(frame)
[13:22:56.458]                       }
[13:22:56.458]                     }
[13:22:56.458]                     sendCondition <<- function(cond) NULL
[13:22:56.458]                   }
[13:22:56.458]                 })
[13:22:56.458]                 withCallingHandlers({
[13:22:56.458]                   {
[13:22:56.458]                     x <- a
[13:22:56.458]                   }
[13:22:56.458]                 }, immediateCondition = function(cond) {
[13:22:56.458]                   sendCondition <- ...future.makeSendCondition()
[13:22:56.458]                   sendCondition(cond)
[13:22:56.458]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:56.458]                   {
[13:22:56.458]                     inherits <- base::inherits
[13:22:56.458]                     invokeRestart <- base::invokeRestart
[13:22:56.458]                     is.null <- base::is.null
[13:22:56.458]                     muffled <- FALSE
[13:22:56.458]                     if (inherits(cond, "message")) {
[13:22:56.458]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:56.458]                       if (muffled) 
[13:22:56.458]                         invokeRestart("muffleMessage")
[13:22:56.458]                     }
[13:22:56.458]                     else if (inherits(cond, "warning")) {
[13:22:56.458]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:56.458]                       if (muffled) 
[13:22:56.458]                         invokeRestart("muffleWarning")
[13:22:56.458]                     }
[13:22:56.458]                     else if (inherits(cond, "condition")) {
[13:22:56.458]                       if (!is.null(pattern)) {
[13:22:56.458]                         computeRestarts <- base::computeRestarts
[13:22:56.458]                         grepl <- base::grepl
[13:22:56.458]                         restarts <- computeRestarts(cond)
[13:22:56.458]                         for (restart in restarts) {
[13:22:56.458]                           name <- restart$name
[13:22:56.458]                           if (is.null(name)) 
[13:22:56.458]                             next
[13:22:56.458]                           if (!grepl(pattern, name)) 
[13:22:56.458]                             next
[13:22:56.458]                           invokeRestart(restart)
[13:22:56.458]                           muffled <- TRUE
[13:22:56.458]                           break
[13:22:56.458]                         }
[13:22:56.458]                       }
[13:22:56.458]                     }
[13:22:56.458]                     invisible(muffled)
[13:22:56.458]                   }
[13:22:56.458]                   muffleCondition(cond)
[13:22:56.458]                 })
[13:22:56.458]             }))
[13:22:56.458]             future::FutureResult(value = ...future.value$value, 
[13:22:56.458]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:56.458]                   ...future.rng), globalenv = if (FALSE) 
[13:22:56.458]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:56.458]                     ...future.globalenv.names))
[13:22:56.458]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:56.458]         }, condition = base::local({
[13:22:56.458]             c <- base::c
[13:22:56.458]             inherits <- base::inherits
[13:22:56.458]             invokeRestart <- base::invokeRestart
[13:22:56.458]             length <- base::length
[13:22:56.458]             list <- base::list
[13:22:56.458]             seq.int <- base::seq.int
[13:22:56.458]             signalCondition <- base::signalCondition
[13:22:56.458]             sys.calls <- base::sys.calls
[13:22:56.458]             `[[` <- base::`[[`
[13:22:56.458]             `+` <- base::`+`
[13:22:56.458]             `<<-` <- base::`<<-`
[13:22:56.458]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:56.458]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:56.458]                   3L)]
[13:22:56.458]             }
[13:22:56.458]             function(cond) {
[13:22:56.458]                 is_error <- inherits(cond, "error")
[13:22:56.458]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:56.458]                   NULL)
[13:22:56.458]                 if (is_error) {
[13:22:56.458]                   sessionInformation <- function() {
[13:22:56.458]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:56.458]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:56.458]                       search = base::search(), system = base::Sys.info())
[13:22:56.458]                   }
[13:22:56.458]                   ...future.conditions[[length(...future.conditions) + 
[13:22:56.458]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:56.458]                     cond$call), session = sessionInformation(), 
[13:22:56.458]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:56.458]                   signalCondition(cond)
[13:22:56.458]                 }
[13:22:56.458]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:56.458]                 "immediateCondition"))) {
[13:22:56.458]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:56.458]                   ...future.conditions[[length(...future.conditions) + 
[13:22:56.458]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:56.458]                   if (TRUE && !signal) {
[13:22:56.458]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:56.458]                     {
[13:22:56.458]                       inherits <- base::inherits
[13:22:56.458]                       invokeRestart <- base::invokeRestart
[13:22:56.458]                       is.null <- base::is.null
[13:22:56.458]                       muffled <- FALSE
[13:22:56.458]                       if (inherits(cond, "message")) {
[13:22:56.458]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:56.458]                         if (muffled) 
[13:22:56.458]                           invokeRestart("muffleMessage")
[13:22:56.458]                       }
[13:22:56.458]                       else if (inherits(cond, "warning")) {
[13:22:56.458]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:56.458]                         if (muffled) 
[13:22:56.458]                           invokeRestart("muffleWarning")
[13:22:56.458]                       }
[13:22:56.458]                       else if (inherits(cond, "condition")) {
[13:22:56.458]                         if (!is.null(pattern)) {
[13:22:56.458]                           computeRestarts <- base::computeRestarts
[13:22:56.458]                           grepl <- base::grepl
[13:22:56.458]                           restarts <- computeRestarts(cond)
[13:22:56.458]                           for (restart in restarts) {
[13:22:56.458]                             name <- restart$name
[13:22:56.458]                             if (is.null(name)) 
[13:22:56.458]                               next
[13:22:56.458]                             if (!grepl(pattern, name)) 
[13:22:56.458]                               next
[13:22:56.458]                             invokeRestart(restart)
[13:22:56.458]                             muffled <- TRUE
[13:22:56.458]                             break
[13:22:56.458]                           }
[13:22:56.458]                         }
[13:22:56.458]                       }
[13:22:56.458]                       invisible(muffled)
[13:22:56.458]                     }
[13:22:56.458]                     muffleCondition(cond, pattern = "^muffle")
[13:22:56.458]                   }
[13:22:56.458]                 }
[13:22:56.458]                 else {
[13:22:56.458]                   if (TRUE) {
[13:22:56.458]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:56.458]                     {
[13:22:56.458]                       inherits <- base::inherits
[13:22:56.458]                       invokeRestart <- base::invokeRestart
[13:22:56.458]                       is.null <- base::is.null
[13:22:56.458]                       muffled <- FALSE
[13:22:56.458]                       if (inherits(cond, "message")) {
[13:22:56.458]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:56.458]                         if (muffled) 
[13:22:56.458]                           invokeRestart("muffleMessage")
[13:22:56.458]                       }
[13:22:56.458]                       else if (inherits(cond, "warning")) {
[13:22:56.458]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:56.458]                         if (muffled) 
[13:22:56.458]                           invokeRestart("muffleWarning")
[13:22:56.458]                       }
[13:22:56.458]                       else if (inherits(cond, "condition")) {
[13:22:56.458]                         if (!is.null(pattern)) {
[13:22:56.458]                           computeRestarts <- base::computeRestarts
[13:22:56.458]                           grepl <- base::grepl
[13:22:56.458]                           restarts <- computeRestarts(cond)
[13:22:56.458]                           for (restart in restarts) {
[13:22:56.458]                             name <- restart$name
[13:22:56.458]                             if (is.null(name)) 
[13:22:56.458]                               next
[13:22:56.458]                             if (!grepl(pattern, name)) 
[13:22:56.458]                               next
[13:22:56.458]                             invokeRestart(restart)
[13:22:56.458]                             muffled <- TRUE
[13:22:56.458]                             break
[13:22:56.458]                           }
[13:22:56.458]                         }
[13:22:56.458]                       }
[13:22:56.458]                       invisible(muffled)
[13:22:56.458]                     }
[13:22:56.458]                     muffleCondition(cond, pattern = "^muffle")
[13:22:56.458]                   }
[13:22:56.458]                 }
[13:22:56.458]             }
[13:22:56.458]         }))
[13:22:56.458]     }, error = function(ex) {
[13:22:56.458]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:56.458]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:56.458]                 ...future.rng), started = ...future.startTime, 
[13:22:56.458]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:56.458]             version = "1.8"), class = "FutureResult")
[13:22:56.458]     }, finally = {
[13:22:56.458]         if (!identical(...future.workdir, getwd())) 
[13:22:56.458]             setwd(...future.workdir)
[13:22:56.458]         {
[13:22:56.458]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:56.458]                 ...future.oldOptions$nwarnings <- NULL
[13:22:56.458]             }
[13:22:56.458]             base::options(...future.oldOptions)
[13:22:56.458]             if (.Platform$OS.type == "windows") {
[13:22:56.458]                 old_names <- names(...future.oldEnvVars)
[13:22:56.458]                 envs <- base::Sys.getenv()
[13:22:56.458]                 names <- names(envs)
[13:22:56.458]                 common <- intersect(names, old_names)
[13:22:56.458]                 added <- setdiff(names, old_names)
[13:22:56.458]                 removed <- setdiff(old_names, names)
[13:22:56.458]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:56.458]                   envs[common]]
[13:22:56.458]                 NAMES <- toupper(changed)
[13:22:56.458]                 args <- list()
[13:22:56.458]                 for (kk in seq_along(NAMES)) {
[13:22:56.458]                   name <- changed[[kk]]
[13:22:56.458]                   NAME <- NAMES[[kk]]
[13:22:56.458]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:56.458]                     next
[13:22:56.458]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:56.458]                 }
[13:22:56.458]                 NAMES <- toupper(added)
[13:22:56.458]                 for (kk in seq_along(NAMES)) {
[13:22:56.458]                   name <- added[[kk]]
[13:22:56.458]                   NAME <- NAMES[[kk]]
[13:22:56.458]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:56.458]                     next
[13:22:56.458]                   args[[name]] <- ""
[13:22:56.458]                 }
[13:22:56.458]                 NAMES <- toupper(removed)
[13:22:56.458]                 for (kk in seq_along(NAMES)) {
[13:22:56.458]                   name <- removed[[kk]]
[13:22:56.458]                   NAME <- NAMES[[kk]]
[13:22:56.458]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:56.458]                     next
[13:22:56.458]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:56.458]                 }
[13:22:56.458]                 if (length(args) > 0) 
[13:22:56.458]                   base::do.call(base::Sys.setenv, args = args)
[13:22:56.458]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:56.458]             }
[13:22:56.458]             else {
[13:22:56.458]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:56.458]             }
[13:22:56.458]             {
[13:22:56.458]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:56.458]                   0L) {
[13:22:56.458]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:56.458]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:56.458]                   base::options(opts)
[13:22:56.458]                 }
[13:22:56.458]                 {
[13:22:56.458]                   {
[13:22:56.458]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:56.458]                     NULL
[13:22:56.458]                   }
[13:22:56.458]                   options(future.plan = NULL)
[13:22:56.458]                   if (is.na(NA_character_)) 
[13:22:56.458]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:56.458]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:56.458]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:56.458]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:56.458]                     envir = parent.frame()) 
[13:22:56.458]                   {
[13:22:56.458]                     if (is.function(workers)) 
[13:22:56.458]                       workers <- workers()
[13:22:56.458]                     workers <- structure(as.integer(workers), 
[13:22:56.458]                       class = class(workers))
[13:22:56.458]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:56.458]                       workers >= 1)
[13:22:56.458]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:56.458]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:56.458]                     }
[13:22:56.458]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:56.458]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:56.458]                       envir = envir)
[13:22:56.458]                     if (!future$lazy) 
[13:22:56.458]                       future <- run(future)
[13:22:56.458]                     invisible(future)
[13:22:56.458]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:56.458]                 }
[13:22:56.458]             }
[13:22:56.458]         }
[13:22:56.458]     })
[13:22:56.458]     if (TRUE) {
[13:22:56.458]         base::sink(type = "output", split = FALSE)
[13:22:56.458]         if (TRUE) {
[13:22:56.458]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:56.458]         }
[13:22:56.458]         else {
[13:22:56.458]             ...future.result["stdout"] <- base::list(NULL)
[13:22:56.458]         }
[13:22:56.458]         base::close(...future.stdout)
[13:22:56.458]         ...future.stdout <- NULL
[13:22:56.458]     }
[13:22:56.458]     ...future.result$conditions <- ...future.conditions
[13:22:56.458]     ...future.result$finished <- base::Sys.time()
[13:22:56.458]     ...future.result
[13:22:56.458] }
[13:22:56.461] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[13:22:56.461] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[13:22:56.462] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[13:22:56.462] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[13:22:56.463] MultisessionFuture started
[13:22:56.463] - Launch lazy future ... done
[13:22:56.463] run() for ‘MultisessionFuture’ ... done
[13:22:56.463] result() for ClusterFuture ...
[13:22:56.464] receiveMessageFromWorker() for ClusterFuture ...
[13:22:56.464] - Validating connection of MultisessionFuture
[13:22:56.509] - received message: FutureResult
[13:22:56.510] - Received FutureResult
[13:22:56.510] - Erased future from FutureRegistry
[13:22:56.510] result() for ClusterFuture ...
[13:22:56.510] - result already collected: FutureResult
[13:22:56.510] result() for ClusterFuture ... done
[13:22:56.510] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:56.510] result() for ClusterFuture ... done
[13:22:56.510] result() for ClusterFuture ...
[13:22:56.511] - result already collected: FutureResult
[13:22:56.511] result() for ClusterFuture ... done
** Future evaluation with errors
[13:22:56.511] getGlobalsAndPackages() ...
[13:22:56.511] Searching for globals...
[13:22:56.513] - globals found: [3] ‘{’, ‘<-’, ‘stop’
[13:22:56.513] Searching for globals ... DONE
[13:22:56.514] Resolving globals: FALSE
[13:22:56.514] 
[13:22:56.514] 
[13:22:56.514] getGlobalsAndPackages() ... DONE
[13:22:56.515] run() for ‘Future’ ...
[13:22:56.515] - state: ‘created’
[13:22:56.515] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:56.530] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:56.530] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:56.530]   - Field: ‘node’
[13:22:56.531]   - Field: ‘label’
[13:22:56.531]   - Field: ‘local’
[13:22:56.531]   - Field: ‘owner’
[13:22:56.531]   - Field: ‘envir’
[13:22:56.531]   - Field: ‘workers’
[13:22:56.531]   - Field: ‘packages’
[13:22:56.531]   - Field: ‘gc’
[13:22:56.531]   - Field: ‘conditions’
[13:22:56.531]   - Field: ‘persistent’
[13:22:56.531]   - Field: ‘expr’
[13:22:56.532]   - Field: ‘uuid’
[13:22:56.532]   - Field: ‘seed’
[13:22:56.532]   - Field: ‘version’
[13:22:56.532]   - Field: ‘result’
[13:22:56.532]   - Field: ‘asynchronous’
[13:22:56.532]   - Field: ‘calls’
[13:22:56.532]   - Field: ‘globals’
[13:22:56.532]   - Field: ‘stdout’
[13:22:56.533]   - Field: ‘earlySignal’
[13:22:56.533]   - Field: ‘lazy’
[13:22:56.533]   - Field: ‘state’
[13:22:56.533] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:56.533] - Launch lazy future ...
[13:22:56.533] Packages needed by the future expression (n = 0): <none>
[13:22:56.534] Packages needed by future strategies (n = 0): <none>
[13:22:56.534] {
[13:22:56.534]     {
[13:22:56.534]         {
[13:22:56.534]             ...future.startTime <- base::Sys.time()
[13:22:56.534]             {
[13:22:56.534]                 {
[13:22:56.534]                   {
[13:22:56.534]                     {
[13:22:56.534]                       base::local({
[13:22:56.534]                         has_future <- base::requireNamespace("future", 
[13:22:56.534]                           quietly = TRUE)
[13:22:56.534]                         if (has_future) {
[13:22:56.534]                           ns <- base::getNamespace("future")
[13:22:56.534]                           version <- ns[[".package"]][["version"]]
[13:22:56.534]                           if (is.null(version)) 
[13:22:56.534]                             version <- utils::packageVersion("future")
[13:22:56.534]                         }
[13:22:56.534]                         else {
[13:22:56.534]                           version <- NULL
[13:22:56.534]                         }
[13:22:56.534]                         if (!has_future || version < "1.8.0") {
[13:22:56.534]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:56.534]                             "", base::R.version$version.string), 
[13:22:56.534]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:56.534]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:56.534]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:56.534]                               "release", "version")], collapse = " "), 
[13:22:56.534]                             hostname = base::Sys.info()[["nodename"]])
[13:22:56.534]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:56.534]                             info)
[13:22:56.534]                           info <- base::paste(info, collapse = "; ")
[13:22:56.534]                           if (!has_future) {
[13:22:56.534]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:56.534]                               info)
[13:22:56.534]                           }
[13:22:56.534]                           else {
[13:22:56.534]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:56.534]                               info, version)
[13:22:56.534]                           }
[13:22:56.534]                           base::stop(msg)
[13:22:56.534]                         }
[13:22:56.534]                       })
[13:22:56.534]                     }
[13:22:56.534]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:56.534]                     base::options(mc.cores = 1L)
[13:22:56.534]                   }
[13:22:56.534]                   options(future.plan = NULL)
[13:22:56.534]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:56.534]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:56.534]                 }
[13:22:56.534]                 ...future.workdir <- getwd()
[13:22:56.534]             }
[13:22:56.534]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:56.534]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:56.534]         }
[13:22:56.534]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:56.534]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:56.534]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:56.534]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:56.534]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:56.534]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:56.534]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:56.534]             base::names(...future.oldOptions))
[13:22:56.534]     }
[13:22:56.534]     if (FALSE) {
[13:22:56.534]     }
[13:22:56.534]     else {
[13:22:56.534]         if (TRUE) {
[13:22:56.534]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:56.534]                 open = "w")
[13:22:56.534]         }
[13:22:56.534]         else {
[13:22:56.534]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:56.534]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:56.534]         }
[13:22:56.534]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:56.534]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:56.534]             base::sink(type = "output", split = FALSE)
[13:22:56.534]             base::close(...future.stdout)
[13:22:56.534]         }, add = TRUE)
[13:22:56.534]     }
[13:22:56.534]     ...future.frame <- base::sys.nframe()
[13:22:56.534]     ...future.conditions <- base::list()
[13:22:56.534]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:56.534]     if (FALSE) {
[13:22:56.534]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:56.534]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:56.534]     }
[13:22:56.534]     ...future.result <- base::tryCatch({
[13:22:56.534]         base::withCallingHandlers({
[13:22:56.534]             ...future.value <- base::withVisible(base::local({
[13:22:56.534]                 ...future.makeSendCondition <- base::local({
[13:22:56.534]                   sendCondition <- NULL
[13:22:56.534]                   function(frame = 1L) {
[13:22:56.534]                     if (is.function(sendCondition)) 
[13:22:56.534]                       return(sendCondition)
[13:22:56.534]                     ns <- getNamespace("parallel")
[13:22:56.534]                     if (exists("sendData", mode = "function", 
[13:22:56.534]                       envir = ns)) {
[13:22:56.534]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:56.534]                         envir = ns)
[13:22:56.534]                       envir <- sys.frame(frame)
[13:22:56.534]                       master <- NULL
[13:22:56.534]                       while (!identical(envir, .GlobalEnv) && 
[13:22:56.534]                         !identical(envir, emptyenv())) {
[13:22:56.534]                         if (exists("master", mode = "list", envir = envir, 
[13:22:56.534]                           inherits = FALSE)) {
[13:22:56.534]                           master <- get("master", mode = "list", 
[13:22:56.534]                             envir = envir, inherits = FALSE)
[13:22:56.534]                           if (inherits(master, c("SOCKnode", 
[13:22:56.534]                             "SOCK0node"))) {
[13:22:56.534]                             sendCondition <<- function(cond) {
[13:22:56.534]                               data <- list(type = "VALUE", value = cond, 
[13:22:56.534]                                 success = TRUE)
[13:22:56.534]                               parallel_sendData(master, data)
[13:22:56.534]                             }
[13:22:56.534]                             return(sendCondition)
[13:22:56.534]                           }
[13:22:56.534]                         }
[13:22:56.534]                         frame <- frame + 1L
[13:22:56.534]                         envir <- sys.frame(frame)
[13:22:56.534]                       }
[13:22:56.534]                     }
[13:22:56.534]                     sendCondition <<- function(cond) NULL
[13:22:56.534]                   }
[13:22:56.534]                 })
[13:22:56.534]                 withCallingHandlers({
[13:22:56.534]                   {
[13:22:56.534]                     x <- 3
[13:22:56.534]                     stop("Woops!")
[13:22:56.534]                     x
[13:22:56.534]                   }
[13:22:56.534]                 }, immediateCondition = function(cond) {
[13:22:56.534]                   sendCondition <- ...future.makeSendCondition()
[13:22:56.534]                   sendCondition(cond)
[13:22:56.534]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:56.534]                   {
[13:22:56.534]                     inherits <- base::inherits
[13:22:56.534]                     invokeRestart <- base::invokeRestart
[13:22:56.534]                     is.null <- base::is.null
[13:22:56.534]                     muffled <- FALSE
[13:22:56.534]                     if (inherits(cond, "message")) {
[13:22:56.534]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:56.534]                       if (muffled) 
[13:22:56.534]                         invokeRestart("muffleMessage")
[13:22:56.534]                     }
[13:22:56.534]                     else if (inherits(cond, "warning")) {
[13:22:56.534]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:56.534]                       if (muffled) 
[13:22:56.534]                         invokeRestart("muffleWarning")
[13:22:56.534]                     }
[13:22:56.534]                     else if (inherits(cond, "condition")) {
[13:22:56.534]                       if (!is.null(pattern)) {
[13:22:56.534]                         computeRestarts <- base::computeRestarts
[13:22:56.534]                         grepl <- base::grepl
[13:22:56.534]                         restarts <- computeRestarts(cond)
[13:22:56.534]                         for (restart in restarts) {
[13:22:56.534]                           name <- restart$name
[13:22:56.534]                           if (is.null(name)) 
[13:22:56.534]                             next
[13:22:56.534]                           if (!grepl(pattern, name)) 
[13:22:56.534]                             next
[13:22:56.534]                           invokeRestart(restart)
[13:22:56.534]                           muffled <- TRUE
[13:22:56.534]                           break
[13:22:56.534]                         }
[13:22:56.534]                       }
[13:22:56.534]                     }
[13:22:56.534]                     invisible(muffled)
[13:22:56.534]                   }
[13:22:56.534]                   muffleCondition(cond)
[13:22:56.534]                 })
[13:22:56.534]             }))
[13:22:56.534]             future::FutureResult(value = ...future.value$value, 
[13:22:56.534]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:56.534]                   ...future.rng), globalenv = if (FALSE) 
[13:22:56.534]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:56.534]                     ...future.globalenv.names))
[13:22:56.534]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:56.534]         }, condition = base::local({
[13:22:56.534]             c <- base::c
[13:22:56.534]             inherits <- base::inherits
[13:22:56.534]             invokeRestart <- base::invokeRestart
[13:22:56.534]             length <- base::length
[13:22:56.534]             list <- base::list
[13:22:56.534]             seq.int <- base::seq.int
[13:22:56.534]             signalCondition <- base::signalCondition
[13:22:56.534]             sys.calls <- base::sys.calls
[13:22:56.534]             `[[` <- base::`[[`
[13:22:56.534]             `+` <- base::`+`
[13:22:56.534]             `<<-` <- base::`<<-`
[13:22:56.534]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:56.534]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:56.534]                   3L)]
[13:22:56.534]             }
[13:22:56.534]             function(cond) {
[13:22:56.534]                 is_error <- inherits(cond, "error")
[13:22:56.534]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:56.534]                   NULL)
[13:22:56.534]                 if (is_error) {
[13:22:56.534]                   sessionInformation <- function() {
[13:22:56.534]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:56.534]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:56.534]                       search = base::search(), system = base::Sys.info())
[13:22:56.534]                   }
[13:22:56.534]                   ...future.conditions[[length(...future.conditions) + 
[13:22:56.534]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:56.534]                     cond$call), session = sessionInformation(), 
[13:22:56.534]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:56.534]                   signalCondition(cond)
[13:22:56.534]                 }
[13:22:56.534]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:56.534]                 "immediateCondition"))) {
[13:22:56.534]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:56.534]                   ...future.conditions[[length(...future.conditions) + 
[13:22:56.534]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:56.534]                   if (TRUE && !signal) {
[13:22:56.534]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:56.534]                     {
[13:22:56.534]                       inherits <- base::inherits
[13:22:56.534]                       invokeRestart <- base::invokeRestart
[13:22:56.534]                       is.null <- base::is.null
[13:22:56.534]                       muffled <- FALSE
[13:22:56.534]                       if (inherits(cond, "message")) {
[13:22:56.534]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:56.534]                         if (muffled) 
[13:22:56.534]                           invokeRestart("muffleMessage")
[13:22:56.534]                       }
[13:22:56.534]                       else if (inherits(cond, "warning")) {
[13:22:56.534]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:56.534]                         if (muffled) 
[13:22:56.534]                           invokeRestart("muffleWarning")
[13:22:56.534]                       }
[13:22:56.534]                       else if (inherits(cond, "condition")) {
[13:22:56.534]                         if (!is.null(pattern)) {
[13:22:56.534]                           computeRestarts <- base::computeRestarts
[13:22:56.534]                           grepl <- base::grepl
[13:22:56.534]                           restarts <- computeRestarts(cond)
[13:22:56.534]                           for (restart in restarts) {
[13:22:56.534]                             name <- restart$name
[13:22:56.534]                             if (is.null(name)) 
[13:22:56.534]                               next
[13:22:56.534]                             if (!grepl(pattern, name)) 
[13:22:56.534]                               next
[13:22:56.534]                             invokeRestart(restart)
[13:22:56.534]                             muffled <- TRUE
[13:22:56.534]                             break
[13:22:56.534]                           }
[13:22:56.534]                         }
[13:22:56.534]                       }
[13:22:56.534]                       invisible(muffled)
[13:22:56.534]                     }
[13:22:56.534]                     muffleCondition(cond, pattern = "^muffle")
[13:22:56.534]                   }
[13:22:56.534]                 }
[13:22:56.534]                 else {
[13:22:56.534]                   if (TRUE) {
[13:22:56.534]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:56.534]                     {
[13:22:56.534]                       inherits <- base::inherits
[13:22:56.534]                       invokeRestart <- base::invokeRestart
[13:22:56.534]                       is.null <- base::is.null
[13:22:56.534]                       muffled <- FALSE
[13:22:56.534]                       if (inherits(cond, "message")) {
[13:22:56.534]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:56.534]                         if (muffled) 
[13:22:56.534]                           invokeRestart("muffleMessage")
[13:22:56.534]                       }
[13:22:56.534]                       else if (inherits(cond, "warning")) {
[13:22:56.534]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:56.534]                         if (muffled) 
[13:22:56.534]                           invokeRestart("muffleWarning")
[13:22:56.534]                       }
[13:22:56.534]                       else if (inherits(cond, "condition")) {
[13:22:56.534]                         if (!is.null(pattern)) {
[13:22:56.534]                           computeRestarts <- base::computeRestarts
[13:22:56.534]                           grepl <- base::grepl
[13:22:56.534]                           restarts <- computeRestarts(cond)
[13:22:56.534]                           for (restart in restarts) {
[13:22:56.534]                             name <- restart$name
[13:22:56.534]                             if (is.null(name)) 
[13:22:56.534]                               next
[13:22:56.534]                             if (!grepl(pattern, name)) 
[13:22:56.534]                               next
[13:22:56.534]                             invokeRestart(restart)
[13:22:56.534]                             muffled <- TRUE
[13:22:56.534]                             break
[13:22:56.534]                           }
[13:22:56.534]                         }
[13:22:56.534]                       }
[13:22:56.534]                       invisible(muffled)
[13:22:56.534]                     }
[13:22:56.534]                     muffleCondition(cond, pattern = "^muffle")
[13:22:56.534]                   }
[13:22:56.534]                 }
[13:22:56.534]             }
[13:22:56.534]         }))
[13:22:56.534]     }, error = function(ex) {
[13:22:56.534]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:56.534]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:56.534]                 ...future.rng), started = ...future.startTime, 
[13:22:56.534]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:56.534]             version = "1.8"), class = "FutureResult")
[13:22:56.534]     }, finally = {
[13:22:56.534]         if (!identical(...future.workdir, getwd())) 
[13:22:56.534]             setwd(...future.workdir)
[13:22:56.534]         {
[13:22:56.534]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:56.534]                 ...future.oldOptions$nwarnings <- NULL
[13:22:56.534]             }
[13:22:56.534]             base::options(...future.oldOptions)
[13:22:56.534]             if (.Platform$OS.type == "windows") {
[13:22:56.534]                 old_names <- names(...future.oldEnvVars)
[13:22:56.534]                 envs <- base::Sys.getenv()
[13:22:56.534]                 names <- names(envs)
[13:22:56.534]                 common <- intersect(names, old_names)
[13:22:56.534]                 added <- setdiff(names, old_names)
[13:22:56.534]                 removed <- setdiff(old_names, names)
[13:22:56.534]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:56.534]                   envs[common]]
[13:22:56.534]                 NAMES <- toupper(changed)
[13:22:56.534]                 args <- list()
[13:22:56.534]                 for (kk in seq_along(NAMES)) {
[13:22:56.534]                   name <- changed[[kk]]
[13:22:56.534]                   NAME <- NAMES[[kk]]
[13:22:56.534]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:56.534]                     next
[13:22:56.534]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:56.534]                 }
[13:22:56.534]                 NAMES <- toupper(added)
[13:22:56.534]                 for (kk in seq_along(NAMES)) {
[13:22:56.534]                   name <- added[[kk]]
[13:22:56.534]                   NAME <- NAMES[[kk]]
[13:22:56.534]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:56.534]                     next
[13:22:56.534]                   args[[name]] <- ""
[13:22:56.534]                 }
[13:22:56.534]                 NAMES <- toupper(removed)
[13:22:56.534]                 for (kk in seq_along(NAMES)) {
[13:22:56.534]                   name <- removed[[kk]]
[13:22:56.534]                   NAME <- NAMES[[kk]]
[13:22:56.534]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:56.534]                     next
[13:22:56.534]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:56.534]                 }
[13:22:56.534]                 if (length(args) > 0) 
[13:22:56.534]                   base::do.call(base::Sys.setenv, args = args)
[13:22:56.534]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:56.534]             }
[13:22:56.534]             else {
[13:22:56.534]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:56.534]             }
[13:22:56.534]             {
[13:22:56.534]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:56.534]                   0L) {
[13:22:56.534]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:56.534]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:56.534]                   base::options(opts)
[13:22:56.534]                 }
[13:22:56.534]                 {
[13:22:56.534]                   {
[13:22:56.534]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:56.534]                     NULL
[13:22:56.534]                   }
[13:22:56.534]                   options(future.plan = NULL)
[13:22:56.534]                   if (is.na(NA_character_)) 
[13:22:56.534]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:56.534]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:56.534]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:56.534]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:56.534]                     envir = parent.frame()) 
[13:22:56.534]                   {
[13:22:56.534]                     if (is.function(workers)) 
[13:22:56.534]                       workers <- workers()
[13:22:56.534]                     workers <- structure(as.integer(workers), 
[13:22:56.534]                       class = class(workers))
[13:22:56.534]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:56.534]                       workers >= 1)
[13:22:56.534]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:56.534]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:56.534]                     }
[13:22:56.534]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:56.534]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:56.534]                       envir = envir)
[13:22:56.534]                     if (!future$lazy) 
[13:22:56.534]                       future <- run(future)
[13:22:56.534]                     invisible(future)
[13:22:56.534]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:56.534]                 }
[13:22:56.534]             }
[13:22:56.534]         }
[13:22:56.534]     })
[13:22:56.534]     if (TRUE) {
[13:22:56.534]         base::sink(type = "output", split = FALSE)
[13:22:56.534]         if (TRUE) {
[13:22:56.534]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:56.534]         }
[13:22:56.534]         else {
[13:22:56.534]             ...future.result["stdout"] <- base::list(NULL)
[13:22:56.534]         }
[13:22:56.534]         base::close(...future.stdout)
[13:22:56.534]         ...future.stdout <- NULL
[13:22:56.534]     }
[13:22:56.534]     ...future.result$conditions <- ...future.conditions
[13:22:56.534]     ...future.result$finished <- base::Sys.time()
[13:22:56.534]     ...future.result
[13:22:56.534] }
[13:22:56.538] MultisessionFuture started
[13:22:56.538] - Launch lazy future ... done
[13:22:56.538] run() for ‘MultisessionFuture’ ... done
[13:22:56.539] result() for ClusterFuture ...
[13:22:56.539] receiveMessageFromWorker() for ClusterFuture ...
[13:22:56.539] - Validating connection of MultisessionFuture
[13:22:56.586] - received message: FutureResult
[13:22:56.586] - Received FutureResult
[13:22:56.587] - Erased future from FutureRegistry
[13:22:56.587] result() for ClusterFuture ...
[13:22:56.587] - result already collected: FutureResult
[13:22:56.587] result() for ClusterFuture ... done
[13:22:56.587] signalConditions() ...
[13:22:56.587]  - include = ‘immediateCondition’
[13:22:56.587]  - exclude = 
[13:22:56.587]  - resignal = FALSE
[13:22:56.588]  - Number of conditions: 1
[13:22:56.588] signalConditions() ... done
[13:22:56.588] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:56.588] result() for ClusterFuture ... done
[13:22:56.588] result() for ClusterFuture ...
[13:22:56.588] - result already collected: FutureResult
[13:22:56.588] result() for ClusterFuture ... done
[13:22:56.588] signalConditions() ...
[13:22:56.589]  - include = ‘immediateCondition’
[13:22:56.589]  - exclude = 
[13:22:56.589]  - resignal = FALSE
[13:22:56.589]  - Number of conditions: 1
[13:22:56.589] signalConditions() ... done
[13:22:56.589] Future state: ‘finished’
[13:22:56.589] result() for ClusterFuture ...
[13:22:56.589] - result already collected: FutureResult
[13:22:56.589] result() for ClusterFuture ... done
[13:22:56.590] signalConditions() ...
[13:22:56.590]  - include = ‘condition’
[13:22:56.590]  - exclude = ‘immediateCondition’
[13:22:56.590]  - resignal = TRUE
[13:22:56.590]  - Number of conditions: 1
[13:22:56.590]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:22:56.590] signalConditions() ... done
[13:22:56.591] getGlobalsAndPackages() ...
[13:22:56.591] Searching for globals...
[13:22:56.593] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[13:22:56.593] Searching for globals ... DONE
[13:22:56.593] Resolving globals: FALSE
[13:22:56.594] The total size of the 1 globals is 56 bytes (56 bytes)
[13:22:56.594] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:22:56.595] - globals: [1] ‘ii’
[13:22:56.595] 
[13:22:56.595] getGlobalsAndPackages() ... DONE
[13:22:56.595] run() for ‘Future’ ...
[13:22:56.595] - state: ‘created’
[13:22:56.595] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:56.614] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:56.614] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:56.614]   - Field: ‘node’
[13:22:56.615]   - Field: ‘label’
[13:22:56.615]   - Field: ‘local’
[13:22:56.615]   - Field: ‘owner’
[13:22:56.615]   - Field: ‘envir’
[13:22:56.615]   - Field: ‘workers’
[13:22:56.615]   - Field: ‘packages’
[13:22:56.615]   - Field: ‘gc’
[13:22:56.615]   - Field: ‘conditions’
[13:22:56.615]   - Field: ‘persistent’
[13:22:56.615]   - Field: ‘expr’
[13:22:56.615]   - Field: ‘uuid’
[13:22:56.616]   - Field: ‘seed’
[13:22:56.616]   - Field: ‘version’
[13:22:56.616]   - Field: ‘result’
[13:22:56.616]   - Field: ‘asynchronous’
[13:22:56.616]   - Field: ‘calls’
[13:22:56.616]   - Field: ‘globals’
[13:22:56.616]   - Field: ‘stdout’
[13:22:56.616]   - Field: ‘earlySignal’
[13:22:56.616]   - Field: ‘lazy’
[13:22:56.616]   - Field: ‘state’
[13:22:56.617] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:56.617] - Launch lazy future ...
[13:22:56.617] Packages needed by the future expression (n = 0): <none>
[13:22:56.617] Packages needed by future strategies (n = 0): <none>
[13:22:56.618] {
[13:22:56.618]     {
[13:22:56.618]         {
[13:22:56.618]             ...future.startTime <- base::Sys.time()
[13:22:56.618]             {
[13:22:56.618]                 {
[13:22:56.618]                   {
[13:22:56.618]                     {
[13:22:56.618]                       base::local({
[13:22:56.618]                         has_future <- base::requireNamespace("future", 
[13:22:56.618]                           quietly = TRUE)
[13:22:56.618]                         if (has_future) {
[13:22:56.618]                           ns <- base::getNamespace("future")
[13:22:56.618]                           version <- ns[[".package"]][["version"]]
[13:22:56.618]                           if (is.null(version)) 
[13:22:56.618]                             version <- utils::packageVersion("future")
[13:22:56.618]                         }
[13:22:56.618]                         else {
[13:22:56.618]                           version <- NULL
[13:22:56.618]                         }
[13:22:56.618]                         if (!has_future || version < "1.8.0") {
[13:22:56.618]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:56.618]                             "", base::R.version$version.string), 
[13:22:56.618]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:56.618]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:56.618]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:56.618]                               "release", "version")], collapse = " "), 
[13:22:56.618]                             hostname = base::Sys.info()[["nodename"]])
[13:22:56.618]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:56.618]                             info)
[13:22:56.618]                           info <- base::paste(info, collapse = "; ")
[13:22:56.618]                           if (!has_future) {
[13:22:56.618]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:56.618]                               info)
[13:22:56.618]                           }
[13:22:56.618]                           else {
[13:22:56.618]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:56.618]                               info, version)
[13:22:56.618]                           }
[13:22:56.618]                           base::stop(msg)
[13:22:56.618]                         }
[13:22:56.618]                       })
[13:22:56.618]                     }
[13:22:56.618]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:56.618]                     base::options(mc.cores = 1L)
[13:22:56.618]                   }
[13:22:56.618]                   options(future.plan = NULL)
[13:22:56.618]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:56.618]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:56.618]                 }
[13:22:56.618]                 ...future.workdir <- getwd()
[13:22:56.618]             }
[13:22:56.618]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:56.618]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:56.618]         }
[13:22:56.618]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:56.618]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:56.618]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:56.618]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:56.618]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:56.618]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:56.618]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:56.618]             base::names(...future.oldOptions))
[13:22:56.618]     }
[13:22:56.618]     if (FALSE) {
[13:22:56.618]     }
[13:22:56.618]     else {
[13:22:56.618]         if (TRUE) {
[13:22:56.618]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:56.618]                 open = "w")
[13:22:56.618]         }
[13:22:56.618]         else {
[13:22:56.618]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:56.618]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:56.618]         }
[13:22:56.618]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:56.618]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:56.618]             base::sink(type = "output", split = FALSE)
[13:22:56.618]             base::close(...future.stdout)
[13:22:56.618]         }, add = TRUE)
[13:22:56.618]     }
[13:22:56.618]     ...future.frame <- base::sys.nframe()
[13:22:56.618]     ...future.conditions <- base::list()
[13:22:56.618]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:56.618]     if (FALSE) {
[13:22:56.618]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:56.618]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:56.618]     }
[13:22:56.618]     ...future.result <- base::tryCatch({
[13:22:56.618]         base::withCallingHandlers({
[13:22:56.618]             ...future.value <- base::withVisible(base::local({
[13:22:56.618]                 ...future.makeSendCondition <- base::local({
[13:22:56.618]                   sendCondition <- NULL
[13:22:56.618]                   function(frame = 1L) {
[13:22:56.618]                     if (is.function(sendCondition)) 
[13:22:56.618]                       return(sendCondition)
[13:22:56.618]                     ns <- getNamespace("parallel")
[13:22:56.618]                     if (exists("sendData", mode = "function", 
[13:22:56.618]                       envir = ns)) {
[13:22:56.618]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:56.618]                         envir = ns)
[13:22:56.618]                       envir <- sys.frame(frame)
[13:22:56.618]                       master <- NULL
[13:22:56.618]                       while (!identical(envir, .GlobalEnv) && 
[13:22:56.618]                         !identical(envir, emptyenv())) {
[13:22:56.618]                         if (exists("master", mode = "list", envir = envir, 
[13:22:56.618]                           inherits = FALSE)) {
[13:22:56.618]                           master <- get("master", mode = "list", 
[13:22:56.618]                             envir = envir, inherits = FALSE)
[13:22:56.618]                           if (inherits(master, c("SOCKnode", 
[13:22:56.618]                             "SOCK0node"))) {
[13:22:56.618]                             sendCondition <<- function(cond) {
[13:22:56.618]                               data <- list(type = "VALUE", value = cond, 
[13:22:56.618]                                 success = TRUE)
[13:22:56.618]                               parallel_sendData(master, data)
[13:22:56.618]                             }
[13:22:56.618]                             return(sendCondition)
[13:22:56.618]                           }
[13:22:56.618]                         }
[13:22:56.618]                         frame <- frame + 1L
[13:22:56.618]                         envir <- sys.frame(frame)
[13:22:56.618]                       }
[13:22:56.618]                     }
[13:22:56.618]                     sendCondition <<- function(cond) NULL
[13:22:56.618]                   }
[13:22:56.618]                 })
[13:22:56.618]                 withCallingHandlers({
[13:22:56.618]                   {
[13:22:56.618]                     if (ii%%2 == 0) 
[13:22:56.618]                       stop("Woops!")
[13:22:56.618]                     ii
[13:22:56.618]                   }
[13:22:56.618]                 }, immediateCondition = function(cond) {
[13:22:56.618]                   sendCondition <- ...future.makeSendCondition()
[13:22:56.618]                   sendCondition(cond)
[13:22:56.618]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:56.618]                   {
[13:22:56.618]                     inherits <- base::inherits
[13:22:56.618]                     invokeRestart <- base::invokeRestart
[13:22:56.618]                     is.null <- base::is.null
[13:22:56.618]                     muffled <- FALSE
[13:22:56.618]                     if (inherits(cond, "message")) {
[13:22:56.618]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:56.618]                       if (muffled) 
[13:22:56.618]                         invokeRestart("muffleMessage")
[13:22:56.618]                     }
[13:22:56.618]                     else if (inherits(cond, "warning")) {
[13:22:56.618]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:56.618]                       if (muffled) 
[13:22:56.618]                         invokeRestart("muffleWarning")
[13:22:56.618]                     }
[13:22:56.618]                     else if (inherits(cond, "condition")) {
[13:22:56.618]                       if (!is.null(pattern)) {
[13:22:56.618]                         computeRestarts <- base::computeRestarts
[13:22:56.618]                         grepl <- base::grepl
[13:22:56.618]                         restarts <- computeRestarts(cond)
[13:22:56.618]                         for (restart in restarts) {
[13:22:56.618]                           name <- restart$name
[13:22:56.618]                           if (is.null(name)) 
[13:22:56.618]                             next
[13:22:56.618]                           if (!grepl(pattern, name)) 
[13:22:56.618]                             next
[13:22:56.618]                           invokeRestart(restart)
[13:22:56.618]                           muffled <- TRUE
[13:22:56.618]                           break
[13:22:56.618]                         }
[13:22:56.618]                       }
[13:22:56.618]                     }
[13:22:56.618]                     invisible(muffled)
[13:22:56.618]                   }
[13:22:56.618]                   muffleCondition(cond)
[13:22:56.618]                 })
[13:22:56.618]             }))
[13:22:56.618]             future::FutureResult(value = ...future.value$value, 
[13:22:56.618]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:56.618]                   ...future.rng), globalenv = if (FALSE) 
[13:22:56.618]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:56.618]                     ...future.globalenv.names))
[13:22:56.618]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:56.618]         }, condition = base::local({
[13:22:56.618]             c <- base::c
[13:22:56.618]             inherits <- base::inherits
[13:22:56.618]             invokeRestart <- base::invokeRestart
[13:22:56.618]             length <- base::length
[13:22:56.618]             list <- base::list
[13:22:56.618]             seq.int <- base::seq.int
[13:22:56.618]             signalCondition <- base::signalCondition
[13:22:56.618]             sys.calls <- base::sys.calls
[13:22:56.618]             `[[` <- base::`[[`
[13:22:56.618]             `+` <- base::`+`
[13:22:56.618]             `<<-` <- base::`<<-`
[13:22:56.618]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:56.618]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:56.618]                   3L)]
[13:22:56.618]             }
[13:22:56.618]             function(cond) {
[13:22:56.618]                 is_error <- inherits(cond, "error")
[13:22:56.618]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:56.618]                   NULL)
[13:22:56.618]                 if (is_error) {
[13:22:56.618]                   sessionInformation <- function() {
[13:22:56.618]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:56.618]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:56.618]                       search = base::search(), system = base::Sys.info())
[13:22:56.618]                   }
[13:22:56.618]                   ...future.conditions[[length(...future.conditions) + 
[13:22:56.618]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:56.618]                     cond$call), session = sessionInformation(), 
[13:22:56.618]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:56.618]                   signalCondition(cond)
[13:22:56.618]                 }
[13:22:56.618]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:56.618]                 "immediateCondition"))) {
[13:22:56.618]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:56.618]                   ...future.conditions[[length(...future.conditions) + 
[13:22:56.618]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:56.618]                   if (TRUE && !signal) {
[13:22:56.618]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:56.618]                     {
[13:22:56.618]                       inherits <- base::inherits
[13:22:56.618]                       invokeRestart <- base::invokeRestart
[13:22:56.618]                       is.null <- base::is.null
[13:22:56.618]                       muffled <- FALSE
[13:22:56.618]                       if (inherits(cond, "message")) {
[13:22:56.618]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:56.618]                         if (muffled) 
[13:22:56.618]                           invokeRestart("muffleMessage")
[13:22:56.618]                       }
[13:22:56.618]                       else if (inherits(cond, "warning")) {
[13:22:56.618]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:56.618]                         if (muffled) 
[13:22:56.618]                           invokeRestart("muffleWarning")
[13:22:56.618]                       }
[13:22:56.618]                       else if (inherits(cond, "condition")) {
[13:22:56.618]                         if (!is.null(pattern)) {
[13:22:56.618]                           computeRestarts <- base::computeRestarts
[13:22:56.618]                           grepl <- base::grepl
[13:22:56.618]                           restarts <- computeRestarts(cond)
[13:22:56.618]                           for (restart in restarts) {
[13:22:56.618]                             name <- restart$name
[13:22:56.618]                             if (is.null(name)) 
[13:22:56.618]                               next
[13:22:56.618]                             if (!grepl(pattern, name)) 
[13:22:56.618]                               next
[13:22:56.618]                             invokeRestart(restart)
[13:22:56.618]                             muffled <- TRUE
[13:22:56.618]                             break
[13:22:56.618]                           }
[13:22:56.618]                         }
[13:22:56.618]                       }
[13:22:56.618]                       invisible(muffled)
[13:22:56.618]                     }
[13:22:56.618]                     muffleCondition(cond, pattern = "^muffle")
[13:22:56.618]                   }
[13:22:56.618]                 }
[13:22:56.618]                 else {
[13:22:56.618]                   if (TRUE) {
[13:22:56.618]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:56.618]                     {
[13:22:56.618]                       inherits <- base::inherits
[13:22:56.618]                       invokeRestart <- base::invokeRestart
[13:22:56.618]                       is.null <- base::is.null
[13:22:56.618]                       muffled <- FALSE
[13:22:56.618]                       if (inherits(cond, "message")) {
[13:22:56.618]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:56.618]                         if (muffled) 
[13:22:56.618]                           invokeRestart("muffleMessage")
[13:22:56.618]                       }
[13:22:56.618]                       else if (inherits(cond, "warning")) {
[13:22:56.618]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:56.618]                         if (muffled) 
[13:22:56.618]                           invokeRestart("muffleWarning")
[13:22:56.618]                       }
[13:22:56.618]                       else if (inherits(cond, "condition")) {
[13:22:56.618]                         if (!is.null(pattern)) {
[13:22:56.618]                           computeRestarts <- base::computeRestarts
[13:22:56.618]                           grepl <- base::grepl
[13:22:56.618]                           restarts <- computeRestarts(cond)
[13:22:56.618]                           for (restart in restarts) {
[13:22:56.618]                             name <- restart$name
[13:22:56.618]                             if (is.null(name)) 
[13:22:56.618]                               next
[13:22:56.618]                             if (!grepl(pattern, name)) 
[13:22:56.618]                               next
[13:22:56.618]                             invokeRestart(restart)
[13:22:56.618]                             muffled <- TRUE
[13:22:56.618]                             break
[13:22:56.618]                           }
[13:22:56.618]                         }
[13:22:56.618]                       }
[13:22:56.618]                       invisible(muffled)
[13:22:56.618]                     }
[13:22:56.618]                     muffleCondition(cond, pattern = "^muffle")
[13:22:56.618]                   }
[13:22:56.618]                 }
[13:22:56.618]             }
[13:22:56.618]         }))
[13:22:56.618]     }, error = function(ex) {
[13:22:56.618]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:56.618]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:56.618]                 ...future.rng), started = ...future.startTime, 
[13:22:56.618]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:56.618]             version = "1.8"), class = "FutureResult")
[13:22:56.618]     }, finally = {
[13:22:56.618]         if (!identical(...future.workdir, getwd())) 
[13:22:56.618]             setwd(...future.workdir)
[13:22:56.618]         {
[13:22:56.618]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:56.618]                 ...future.oldOptions$nwarnings <- NULL
[13:22:56.618]             }
[13:22:56.618]             base::options(...future.oldOptions)
[13:22:56.618]             if (.Platform$OS.type == "windows") {
[13:22:56.618]                 old_names <- names(...future.oldEnvVars)
[13:22:56.618]                 envs <- base::Sys.getenv()
[13:22:56.618]                 names <- names(envs)
[13:22:56.618]                 common <- intersect(names, old_names)
[13:22:56.618]                 added <- setdiff(names, old_names)
[13:22:56.618]                 removed <- setdiff(old_names, names)
[13:22:56.618]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:56.618]                   envs[common]]
[13:22:56.618]                 NAMES <- toupper(changed)
[13:22:56.618]                 args <- list()
[13:22:56.618]                 for (kk in seq_along(NAMES)) {
[13:22:56.618]                   name <- changed[[kk]]
[13:22:56.618]                   NAME <- NAMES[[kk]]
[13:22:56.618]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:56.618]                     next
[13:22:56.618]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:56.618]                 }
[13:22:56.618]                 NAMES <- toupper(added)
[13:22:56.618]                 for (kk in seq_along(NAMES)) {
[13:22:56.618]                   name <- added[[kk]]
[13:22:56.618]                   NAME <- NAMES[[kk]]
[13:22:56.618]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:56.618]                     next
[13:22:56.618]                   args[[name]] <- ""
[13:22:56.618]                 }
[13:22:56.618]                 NAMES <- toupper(removed)
[13:22:56.618]                 for (kk in seq_along(NAMES)) {
[13:22:56.618]                   name <- removed[[kk]]
[13:22:56.618]                   NAME <- NAMES[[kk]]
[13:22:56.618]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:56.618]                     next
[13:22:56.618]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:56.618]                 }
[13:22:56.618]                 if (length(args) > 0) 
[13:22:56.618]                   base::do.call(base::Sys.setenv, args = args)
[13:22:56.618]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:56.618]             }
[13:22:56.618]             else {
[13:22:56.618]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:56.618]             }
[13:22:56.618]             {
[13:22:56.618]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:56.618]                   0L) {
[13:22:56.618]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:56.618]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:56.618]                   base::options(opts)
[13:22:56.618]                 }
[13:22:56.618]                 {
[13:22:56.618]                   {
[13:22:56.618]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:56.618]                     NULL
[13:22:56.618]                   }
[13:22:56.618]                   options(future.plan = NULL)
[13:22:56.618]                   if (is.na(NA_character_)) 
[13:22:56.618]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:56.618]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:56.618]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:56.618]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:56.618]                     envir = parent.frame()) 
[13:22:56.618]                   {
[13:22:56.618]                     if (is.function(workers)) 
[13:22:56.618]                       workers <- workers()
[13:22:56.618]                     workers <- structure(as.integer(workers), 
[13:22:56.618]                       class = class(workers))
[13:22:56.618]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:56.618]                       workers >= 1)
[13:22:56.618]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:56.618]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:56.618]                     }
[13:22:56.618]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:56.618]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:56.618]                       envir = envir)
[13:22:56.618]                     if (!future$lazy) 
[13:22:56.618]                       future <- run(future)
[13:22:56.618]                     invisible(future)
[13:22:56.618]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:56.618]                 }
[13:22:56.618]             }
[13:22:56.618]         }
[13:22:56.618]     })
[13:22:56.618]     if (TRUE) {
[13:22:56.618]         base::sink(type = "output", split = FALSE)
[13:22:56.618]         if (TRUE) {
[13:22:56.618]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:56.618]         }
[13:22:56.618]         else {
[13:22:56.618]             ...future.result["stdout"] <- base::list(NULL)
[13:22:56.618]         }
[13:22:56.618]         base::close(...future.stdout)
[13:22:56.618]         ...future.stdout <- NULL
[13:22:56.618]     }
[13:22:56.618]     ...future.result$conditions <- ...future.conditions
[13:22:56.618]     ...future.result$finished <- base::Sys.time()
[13:22:56.618]     ...future.result
[13:22:56.618] }
[13:22:56.620] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[13:22:56.621] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[13:22:56.621] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[13:22:56.621] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[13:22:56.622] MultisessionFuture started
[13:22:56.622] - Launch lazy future ... done
[13:22:56.622] run() for ‘MultisessionFuture’ ... done
[13:22:56.622] getGlobalsAndPackages() ...
[13:22:56.623] Searching for globals...
[13:22:56.624] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[13:22:56.624] Searching for globals ... DONE
[13:22:56.624] Resolving globals: FALSE
[13:22:56.625] The total size of the 1 globals is 56 bytes (56 bytes)
[13:22:56.625] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:22:56.625] - globals: [1] ‘ii’
[13:22:56.625] 
[13:22:56.626] getGlobalsAndPackages() ... DONE
[13:22:56.626] run() for ‘Future’ ...
[13:22:56.626] - state: ‘created’
[13:22:56.626] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:56.640] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:56.640] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:56.640]   - Field: ‘node’
[13:22:56.641]   - Field: ‘label’
[13:22:56.641]   - Field: ‘local’
[13:22:56.641]   - Field: ‘owner’
[13:22:56.641]   - Field: ‘envir’
[13:22:56.641]   - Field: ‘workers’
[13:22:56.641]   - Field: ‘packages’
[13:22:56.641]   - Field: ‘gc’
[13:22:56.641]   - Field: ‘conditions’
[13:22:56.641]   - Field: ‘persistent’
[13:22:56.641]   - Field: ‘expr’
[13:22:56.642]   - Field: ‘uuid’
[13:22:56.642]   - Field: ‘seed’
[13:22:56.642]   - Field: ‘version’
[13:22:56.642]   - Field: ‘result’
[13:22:56.642]   - Field: ‘asynchronous’
[13:22:56.642]   - Field: ‘calls’
[13:22:56.642]   - Field: ‘globals’
[13:22:56.642]   - Field: ‘stdout’
[13:22:56.642]   - Field: ‘earlySignal’
[13:22:56.642]   - Field: ‘lazy’
[13:22:56.642]   - Field: ‘state’
[13:22:56.643] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:56.643] - Launch lazy future ...
[13:22:56.643] Packages needed by the future expression (n = 0): <none>
[13:22:56.643] Packages needed by future strategies (n = 0): <none>
[13:22:56.644] {
[13:22:56.644]     {
[13:22:56.644]         {
[13:22:56.644]             ...future.startTime <- base::Sys.time()
[13:22:56.644]             {
[13:22:56.644]                 {
[13:22:56.644]                   {
[13:22:56.644]                     {
[13:22:56.644]                       base::local({
[13:22:56.644]                         has_future <- base::requireNamespace("future", 
[13:22:56.644]                           quietly = TRUE)
[13:22:56.644]                         if (has_future) {
[13:22:56.644]                           ns <- base::getNamespace("future")
[13:22:56.644]                           version <- ns[[".package"]][["version"]]
[13:22:56.644]                           if (is.null(version)) 
[13:22:56.644]                             version <- utils::packageVersion("future")
[13:22:56.644]                         }
[13:22:56.644]                         else {
[13:22:56.644]                           version <- NULL
[13:22:56.644]                         }
[13:22:56.644]                         if (!has_future || version < "1.8.0") {
[13:22:56.644]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:56.644]                             "", base::R.version$version.string), 
[13:22:56.644]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:56.644]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:56.644]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:56.644]                               "release", "version")], collapse = " "), 
[13:22:56.644]                             hostname = base::Sys.info()[["nodename"]])
[13:22:56.644]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:56.644]                             info)
[13:22:56.644]                           info <- base::paste(info, collapse = "; ")
[13:22:56.644]                           if (!has_future) {
[13:22:56.644]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:56.644]                               info)
[13:22:56.644]                           }
[13:22:56.644]                           else {
[13:22:56.644]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:56.644]                               info, version)
[13:22:56.644]                           }
[13:22:56.644]                           base::stop(msg)
[13:22:56.644]                         }
[13:22:56.644]                       })
[13:22:56.644]                     }
[13:22:56.644]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:56.644]                     base::options(mc.cores = 1L)
[13:22:56.644]                   }
[13:22:56.644]                   options(future.plan = NULL)
[13:22:56.644]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:56.644]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:56.644]                 }
[13:22:56.644]                 ...future.workdir <- getwd()
[13:22:56.644]             }
[13:22:56.644]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:56.644]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:56.644]         }
[13:22:56.644]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:56.644]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:56.644]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:56.644]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:56.644]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:56.644]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:56.644]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:56.644]             base::names(...future.oldOptions))
[13:22:56.644]     }
[13:22:56.644]     if (FALSE) {
[13:22:56.644]     }
[13:22:56.644]     else {
[13:22:56.644]         if (TRUE) {
[13:22:56.644]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:56.644]                 open = "w")
[13:22:56.644]         }
[13:22:56.644]         else {
[13:22:56.644]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:56.644]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:56.644]         }
[13:22:56.644]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:56.644]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:56.644]             base::sink(type = "output", split = FALSE)
[13:22:56.644]             base::close(...future.stdout)
[13:22:56.644]         }, add = TRUE)
[13:22:56.644]     }
[13:22:56.644]     ...future.frame <- base::sys.nframe()
[13:22:56.644]     ...future.conditions <- base::list()
[13:22:56.644]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:56.644]     if (FALSE) {
[13:22:56.644]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:56.644]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:56.644]     }
[13:22:56.644]     ...future.result <- base::tryCatch({
[13:22:56.644]         base::withCallingHandlers({
[13:22:56.644]             ...future.value <- base::withVisible(base::local({
[13:22:56.644]                 ...future.makeSendCondition <- base::local({
[13:22:56.644]                   sendCondition <- NULL
[13:22:56.644]                   function(frame = 1L) {
[13:22:56.644]                     if (is.function(sendCondition)) 
[13:22:56.644]                       return(sendCondition)
[13:22:56.644]                     ns <- getNamespace("parallel")
[13:22:56.644]                     if (exists("sendData", mode = "function", 
[13:22:56.644]                       envir = ns)) {
[13:22:56.644]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:56.644]                         envir = ns)
[13:22:56.644]                       envir <- sys.frame(frame)
[13:22:56.644]                       master <- NULL
[13:22:56.644]                       while (!identical(envir, .GlobalEnv) && 
[13:22:56.644]                         !identical(envir, emptyenv())) {
[13:22:56.644]                         if (exists("master", mode = "list", envir = envir, 
[13:22:56.644]                           inherits = FALSE)) {
[13:22:56.644]                           master <- get("master", mode = "list", 
[13:22:56.644]                             envir = envir, inherits = FALSE)
[13:22:56.644]                           if (inherits(master, c("SOCKnode", 
[13:22:56.644]                             "SOCK0node"))) {
[13:22:56.644]                             sendCondition <<- function(cond) {
[13:22:56.644]                               data <- list(type = "VALUE", value = cond, 
[13:22:56.644]                                 success = TRUE)
[13:22:56.644]                               parallel_sendData(master, data)
[13:22:56.644]                             }
[13:22:56.644]                             return(sendCondition)
[13:22:56.644]                           }
[13:22:56.644]                         }
[13:22:56.644]                         frame <- frame + 1L
[13:22:56.644]                         envir <- sys.frame(frame)
[13:22:56.644]                       }
[13:22:56.644]                     }
[13:22:56.644]                     sendCondition <<- function(cond) NULL
[13:22:56.644]                   }
[13:22:56.644]                 })
[13:22:56.644]                 withCallingHandlers({
[13:22:56.644]                   {
[13:22:56.644]                     if (ii%%2 == 0) 
[13:22:56.644]                       stop("Woops!")
[13:22:56.644]                     ii
[13:22:56.644]                   }
[13:22:56.644]                 }, immediateCondition = function(cond) {
[13:22:56.644]                   sendCondition <- ...future.makeSendCondition()
[13:22:56.644]                   sendCondition(cond)
[13:22:56.644]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:56.644]                   {
[13:22:56.644]                     inherits <- base::inherits
[13:22:56.644]                     invokeRestart <- base::invokeRestart
[13:22:56.644]                     is.null <- base::is.null
[13:22:56.644]                     muffled <- FALSE
[13:22:56.644]                     if (inherits(cond, "message")) {
[13:22:56.644]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:56.644]                       if (muffled) 
[13:22:56.644]                         invokeRestart("muffleMessage")
[13:22:56.644]                     }
[13:22:56.644]                     else if (inherits(cond, "warning")) {
[13:22:56.644]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:56.644]                       if (muffled) 
[13:22:56.644]                         invokeRestart("muffleWarning")
[13:22:56.644]                     }
[13:22:56.644]                     else if (inherits(cond, "condition")) {
[13:22:56.644]                       if (!is.null(pattern)) {
[13:22:56.644]                         computeRestarts <- base::computeRestarts
[13:22:56.644]                         grepl <- base::grepl
[13:22:56.644]                         restarts <- computeRestarts(cond)
[13:22:56.644]                         for (restart in restarts) {
[13:22:56.644]                           name <- restart$name
[13:22:56.644]                           if (is.null(name)) 
[13:22:56.644]                             next
[13:22:56.644]                           if (!grepl(pattern, name)) 
[13:22:56.644]                             next
[13:22:56.644]                           invokeRestart(restart)
[13:22:56.644]                           muffled <- TRUE
[13:22:56.644]                           break
[13:22:56.644]                         }
[13:22:56.644]                       }
[13:22:56.644]                     }
[13:22:56.644]                     invisible(muffled)
[13:22:56.644]                   }
[13:22:56.644]                   muffleCondition(cond)
[13:22:56.644]                 })
[13:22:56.644]             }))
[13:22:56.644]             future::FutureResult(value = ...future.value$value, 
[13:22:56.644]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:56.644]                   ...future.rng), globalenv = if (FALSE) 
[13:22:56.644]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:56.644]                     ...future.globalenv.names))
[13:22:56.644]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:56.644]         }, condition = base::local({
[13:22:56.644]             c <- base::c
[13:22:56.644]             inherits <- base::inherits
[13:22:56.644]             invokeRestart <- base::invokeRestart
[13:22:56.644]             length <- base::length
[13:22:56.644]             list <- base::list
[13:22:56.644]             seq.int <- base::seq.int
[13:22:56.644]             signalCondition <- base::signalCondition
[13:22:56.644]             sys.calls <- base::sys.calls
[13:22:56.644]             `[[` <- base::`[[`
[13:22:56.644]             `+` <- base::`+`
[13:22:56.644]             `<<-` <- base::`<<-`
[13:22:56.644]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:56.644]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:56.644]                   3L)]
[13:22:56.644]             }
[13:22:56.644]             function(cond) {
[13:22:56.644]                 is_error <- inherits(cond, "error")
[13:22:56.644]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:56.644]                   NULL)
[13:22:56.644]                 if (is_error) {
[13:22:56.644]                   sessionInformation <- function() {
[13:22:56.644]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:56.644]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:56.644]                       search = base::search(), system = base::Sys.info())
[13:22:56.644]                   }
[13:22:56.644]                   ...future.conditions[[length(...future.conditions) + 
[13:22:56.644]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:56.644]                     cond$call), session = sessionInformation(), 
[13:22:56.644]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:56.644]                   signalCondition(cond)
[13:22:56.644]                 }
[13:22:56.644]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:56.644]                 "immediateCondition"))) {
[13:22:56.644]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:56.644]                   ...future.conditions[[length(...future.conditions) + 
[13:22:56.644]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:56.644]                   if (TRUE && !signal) {
[13:22:56.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:56.644]                     {
[13:22:56.644]                       inherits <- base::inherits
[13:22:56.644]                       invokeRestart <- base::invokeRestart
[13:22:56.644]                       is.null <- base::is.null
[13:22:56.644]                       muffled <- FALSE
[13:22:56.644]                       if (inherits(cond, "message")) {
[13:22:56.644]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:56.644]                         if (muffled) 
[13:22:56.644]                           invokeRestart("muffleMessage")
[13:22:56.644]                       }
[13:22:56.644]                       else if (inherits(cond, "warning")) {
[13:22:56.644]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:56.644]                         if (muffled) 
[13:22:56.644]                           invokeRestart("muffleWarning")
[13:22:56.644]                       }
[13:22:56.644]                       else if (inherits(cond, "condition")) {
[13:22:56.644]                         if (!is.null(pattern)) {
[13:22:56.644]                           computeRestarts <- base::computeRestarts
[13:22:56.644]                           grepl <- base::grepl
[13:22:56.644]                           restarts <- computeRestarts(cond)
[13:22:56.644]                           for (restart in restarts) {
[13:22:56.644]                             name <- restart$name
[13:22:56.644]                             if (is.null(name)) 
[13:22:56.644]                               next
[13:22:56.644]                             if (!grepl(pattern, name)) 
[13:22:56.644]                               next
[13:22:56.644]                             invokeRestart(restart)
[13:22:56.644]                             muffled <- TRUE
[13:22:56.644]                             break
[13:22:56.644]                           }
[13:22:56.644]                         }
[13:22:56.644]                       }
[13:22:56.644]                       invisible(muffled)
[13:22:56.644]                     }
[13:22:56.644]                     muffleCondition(cond, pattern = "^muffle")
[13:22:56.644]                   }
[13:22:56.644]                 }
[13:22:56.644]                 else {
[13:22:56.644]                   if (TRUE) {
[13:22:56.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:56.644]                     {
[13:22:56.644]                       inherits <- base::inherits
[13:22:56.644]                       invokeRestart <- base::invokeRestart
[13:22:56.644]                       is.null <- base::is.null
[13:22:56.644]                       muffled <- FALSE
[13:22:56.644]                       if (inherits(cond, "message")) {
[13:22:56.644]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:56.644]                         if (muffled) 
[13:22:56.644]                           invokeRestart("muffleMessage")
[13:22:56.644]                       }
[13:22:56.644]                       else if (inherits(cond, "warning")) {
[13:22:56.644]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:56.644]                         if (muffled) 
[13:22:56.644]                           invokeRestart("muffleWarning")
[13:22:56.644]                       }
[13:22:56.644]                       else if (inherits(cond, "condition")) {
[13:22:56.644]                         if (!is.null(pattern)) {
[13:22:56.644]                           computeRestarts <- base::computeRestarts
[13:22:56.644]                           grepl <- base::grepl
[13:22:56.644]                           restarts <- computeRestarts(cond)
[13:22:56.644]                           for (restart in restarts) {
[13:22:56.644]                             name <- restart$name
[13:22:56.644]                             if (is.null(name)) 
[13:22:56.644]                               next
[13:22:56.644]                             if (!grepl(pattern, name)) 
[13:22:56.644]                               next
[13:22:56.644]                             invokeRestart(restart)
[13:22:56.644]                             muffled <- TRUE
[13:22:56.644]                             break
[13:22:56.644]                           }
[13:22:56.644]                         }
[13:22:56.644]                       }
[13:22:56.644]                       invisible(muffled)
[13:22:56.644]                     }
[13:22:56.644]                     muffleCondition(cond, pattern = "^muffle")
[13:22:56.644]                   }
[13:22:56.644]                 }
[13:22:56.644]             }
[13:22:56.644]         }))
[13:22:56.644]     }, error = function(ex) {
[13:22:56.644]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:56.644]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:56.644]                 ...future.rng), started = ...future.startTime, 
[13:22:56.644]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:56.644]             version = "1.8"), class = "FutureResult")
[13:22:56.644]     }, finally = {
[13:22:56.644]         if (!identical(...future.workdir, getwd())) 
[13:22:56.644]             setwd(...future.workdir)
[13:22:56.644]         {
[13:22:56.644]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:56.644]                 ...future.oldOptions$nwarnings <- NULL
[13:22:56.644]             }
[13:22:56.644]             base::options(...future.oldOptions)
[13:22:56.644]             if (.Platform$OS.type == "windows") {
[13:22:56.644]                 old_names <- names(...future.oldEnvVars)
[13:22:56.644]                 envs <- base::Sys.getenv()
[13:22:56.644]                 names <- names(envs)
[13:22:56.644]                 common <- intersect(names, old_names)
[13:22:56.644]                 added <- setdiff(names, old_names)
[13:22:56.644]                 removed <- setdiff(old_names, names)
[13:22:56.644]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:56.644]                   envs[common]]
[13:22:56.644]                 NAMES <- toupper(changed)
[13:22:56.644]                 args <- list()
[13:22:56.644]                 for (kk in seq_along(NAMES)) {
[13:22:56.644]                   name <- changed[[kk]]
[13:22:56.644]                   NAME <- NAMES[[kk]]
[13:22:56.644]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:56.644]                     next
[13:22:56.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:56.644]                 }
[13:22:56.644]                 NAMES <- toupper(added)
[13:22:56.644]                 for (kk in seq_along(NAMES)) {
[13:22:56.644]                   name <- added[[kk]]
[13:22:56.644]                   NAME <- NAMES[[kk]]
[13:22:56.644]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:56.644]                     next
[13:22:56.644]                   args[[name]] <- ""
[13:22:56.644]                 }
[13:22:56.644]                 NAMES <- toupper(removed)
[13:22:56.644]                 for (kk in seq_along(NAMES)) {
[13:22:56.644]                   name <- removed[[kk]]
[13:22:56.644]                   NAME <- NAMES[[kk]]
[13:22:56.644]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:56.644]                     next
[13:22:56.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:56.644]                 }
[13:22:56.644]                 if (length(args) > 0) 
[13:22:56.644]                   base::do.call(base::Sys.setenv, args = args)
[13:22:56.644]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:56.644]             }
[13:22:56.644]             else {
[13:22:56.644]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:56.644]             }
[13:22:56.644]             {
[13:22:56.644]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:56.644]                   0L) {
[13:22:56.644]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:56.644]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:56.644]                   base::options(opts)
[13:22:56.644]                 }
[13:22:56.644]                 {
[13:22:56.644]                   {
[13:22:56.644]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:56.644]                     NULL
[13:22:56.644]                   }
[13:22:56.644]                   options(future.plan = NULL)
[13:22:56.644]                   if (is.na(NA_character_)) 
[13:22:56.644]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:56.644]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:56.644]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:56.644]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:56.644]                     envir = parent.frame()) 
[13:22:56.644]                   {
[13:22:56.644]                     if (is.function(workers)) 
[13:22:56.644]                       workers <- workers()
[13:22:56.644]                     workers <- structure(as.integer(workers), 
[13:22:56.644]                       class = class(workers))
[13:22:56.644]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:56.644]                       workers >= 1)
[13:22:56.644]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:56.644]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:56.644]                     }
[13:22:56.644]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:56.644]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:56.644]                       envir = envir)
[13:22:56.644]                     if (!future$lazy) 
[13:22:56.644]                       future <- run(future)
[13:22:56.644]                     invisible(future)
[13:22:56.644]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:56.644]                 }
[13:22:56.644]             }
[13:22:56.644]         }
[13:22:56.644]     })
[13:22:56.644]     if (TRUE) {
[13:22:56.644]         base::sink(type = "output", split = FALSE)
[13:22:56.644]         if (TRUE) {
[13:22:56.644]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:56.644]         }
[13:22:56.644]         else {
[13:22:56.644]             ...future.result["stdout"] <- base::list(NULL)
[13:22:56.644]         }
[13:22:56.644]         base::close(...future.stdout)
[13:22:56.644]         ...future.stdout <- NULL
[13:22:56.644]     }
[13:22:56.644]     ...future.result$conditions <- ...future.conditions
[13:22:56.644]     ...future.result$finished <- base::Sys.time()
[13:22:56.644]     ...future.result
[13:22:56.644] }
[13:22:56.700] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[13:22:56.700] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[13:22:56.701] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[13:22:56.701] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[13:22:56.702] MultisessionFuture started
[13:22:56.702] - Launch lazy future ... done
[13:22:56.702] run() for ‘MultisessionFuture’ ... done
[13:22:56.702] getGlobalsAndPackages() ...
[13:22:56.702] Searching for globals...
[13:22:56.704] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[13:22:56.704] Searching for globals ... DONE
[13:22:56.704] Resolving globals: FALSE
[13:22:56.705] The total size of the 1 globals is 56 bytes (56 bytes)
[13:22:56.705] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:22:56.705] - globals: [1] ‘ii’
[13:22:56.705] 
[13:22:56.706] getGlobalsAndPackages() ... DONE
[13:22:56.706] run() for ‘Future’ ...
[13:22:56.706] - state: ‘created’
[13:22:56.706] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:56.723] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:56.723] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:56.723]   - Field: ‘node’
[13:22:56.723]   - Field: ‘label’
[13:22:56.723]   - Field: ‘local’
[13:22:56.723]   - Field: ‘owner’
[13:22:56.724]   - Field: ‘envir’
[13:22:56.724]   - Field: ‘workers’
[13:22:56.724]   - Field: ‘packages’
[13:22:56.724]   - Field: ‘gc’
[13:22:56.724]   - Field: ‘conditions’
[13:22:56.724]   - Field: ‘persistent’
[13:22:56.724]   - Field: ‘expr’
[13:22:56.724]   - Field: ‘uuid’
[13:22:56.724]   - Field: ‘seed’
[13:22:56.724]   - Field: ‘version’
[13:22:56.725]   - Field: ‘result’
[13:22:56.725]   - Field: ‘asynchronous’
[13:22:56.725]   - Field: ‘calls’
[13:22:56.725]   - Field: ‘globals’
[13:22:56.725]   - Field: ‘stdout’
[13:22:56.725]   - Field: ‘earlySignal’
[13:22:56.725]   - Field: ‘lazy’
[13:22:56.725]   - Field: ‘state’
[13:22:56.725] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:56.725] - Launch lazy future ...
[13:22:56.726] Packages needed by the future expression (n = 0): <none>
[13:22:56.726] Packages needed by future strategies (n = 0): <none>
[13:22:56.726] {
[13:22:56.726]     {
[13:22:56.726]         {
[13:22:56.726]             ...future.startTime <- base::Sys.time()
[13:22:56.726]             {
[13:22:56.726]                 {
[13:22:56.726]                   {
[13:22:56.726]                     {
[13:22:56.726]                       base::local({
[13:22:56.726]                         has_future <- base::requireNamespace("future", 
[13:22:56.726]                           quietly = TRUE)
[13:22:56.726]                         if (has_future) {
[13:22:56.726]                           ns <- base::getNamespace("future")
[13:22:56.726]                           version <- ns[[".package"]][["version"]]
[13:22:56.726]                           if (is.null(version)) 
[13:22:56.726]                             version <- utils::packageVersion("future")
[13:22:56.726]                         }
[13:22:56.726]                         else {
[13:22:56.726]                           version <- NULL
[13:22:56.726]                         }
[13:22:56.726]                         if (!has_future || version < "1.8.0") {
[13:22:56.726]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:56.726]                             "", base::R.version$version.string), 
[13:22:56.726]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:56.726]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:56.726]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:56.726]                               "release", "version")], collapse = " "), 
[13:22:56.726]                             hostname = base::Sys.info()[["nodename"]])
[13:22:56.726]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:56.726]                             info)
[13:22:56.726]                           info <- base::paste(info, collapse = "; ")
[13:22:56.726]                           if (!has_future) {
[13:22:56.726]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:56.726]                               info)
[13:22:56.726]                           }
[13:22:56.726]                           else {
[13:22:56.726]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:56.726]                               info, version)
[13:22:56.726]                           }
[13:22:56.726]                           base::stop(msg)
[13:22:56.726]                         }
[13:22:56.726]                       })
[13:22:56.726]                     }
[13:22:56.726]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:56.726]                     base::options(mc.cores = 1L)
[13:22:56.726]                   }
[13:22:56.726]                   options(future.plan = NULL)
[13:22:56.726]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:56.726]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:56.726]                 }
[13:22:56.726]                 ...future.workdir <- getwd()
[13:22:56.726]             }
[13:22:56.726]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:56.726]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:56.726]         }
[13:22:56.726]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:56.726]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:56.726]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:56.726]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:56.726]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:56.726]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:56.726]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:56.726]             base::names(...future.oldOptions))
[13:22:56.726]     }
[13:22:56.726]     if (FALSE) {
[13:22:56.726]     }
[13:22:56.726]     else {
[13:22:56.726]         if (TRUE) {
[13:22:56.726]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:56.726]                 open = "w")
[13:22:56.726]         }
[13:22:56.726]         else {
[13:22:56.726]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:56.726]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:56.726]         }
[13:22:56.726]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:56.726]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:56.726]             base::sink(type = "output", split = FALSE)
[13:22:56.726]             base::close(...future.stdout)
[13:22:56.726]         }, add = TRUE)
[13:22:56.726]     }
[13:22:56.726]     ...future.frame <- base::sys.nframe()
[13:22:56.726]     ...future.conditions <- base::list()
[13:22:56.726]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:56.726]     if (FALSE) {
[13:22:56.726]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:56.726]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:56.726]     }
[13:22:56.726]     ...future.result <- base::tryCatch({
[13:22:56.726]         base::withCallingHandlers({
[13:22:56.726]             ...future.value <- base::withVisible(base::local({
[13:22:56.726]                 ...future.makeSendCondition <- base::local({
[13:22:56.726]                   sendCondition <- NULL
[13:22:56.726]                   function(frame = 1L) {
[13:22:56.726]                     if (is.function(sendCondition)) 
[13:22:56.726]                       return(sendCondition)
[13:22:56.726]                     ns <- getNamespace("parallel")
[13:22:56.726]                     if (exists("sendData", mode = "function", 
[13:22:56.726]                       envir = ns)) {
[13:22:56.726]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:56.726]                         envir = ns)
[13:22:56.726]                       envir <- sys.frame(frame)
[13:22:56.726]                       master <- NULL
[13:22:56.726]                       while (!identical(envir, .GlobalEnv) && 
[13:22:56.726]                         !identical(envir, emptyenv())) {
[13:22:56.726]                         if (exists("master", mode = "list", envir = envir, 
[13:22:56.726]                           inherits = FALSE)) {
[13:22:56.726]                           master <- get("master", mode = "list", 
[13:22:56.726]                             envir = envir, inherits = FALSE)
[13:22:56.726]                           if (inherits(master, c("SOCKnode", 
[13:22:56.726]                             "SOCK0node"))) {
[13:22:56.726]                             sendCondition <<- function(cond) {
[13:22:56.726]                               data <- list(type = "VALUE", value = cond, 
[13:22:56.726]                                 success = TRUE)
[13:22:56.726]                               parallel_sendData(master, data)
[13:22:56.726]                             }
[13:22:56.726]                             return(sendCondition)
[13:22:56.726]                           }
[13:22:56.726]                         }
[13:22:56.726]                         frame <- frame + 1L
[13:22:56.726]                         envir <- sys.frame(frame)
[13:22:56.726]                       }
[13:22:56.726]                     }
[13:22:56.726]                     sendCondition <<- function(cond) NULL
[13:22:56.726]                   }
[13:22:56.726]                 })
[13:22:56.726]                 withCallingHandlers({
[13:22:56.726]                   {
[13:22:56.726]                     if (ii%%2 == 0) 
[13:22:56.726]                       stop("Woops!")
[13:22:56.726]                     ii
[13:22:56.726]                   }
[13:22:56.726]                 }, immediateCondition = function(cond) {
[13:22:56.726]                   sendCondition <- ...future.makeSendCondition()
[13:22:56.726]                   sendCondition(cond)
[13:22:56.726]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:56.726]                   {
[13:22:56.726]                     inherits <- base::inherits
[13:22:56.726]                     invokeRestart <- base::invokeRestart
[13:22:56.726]                     is.null <- base::is.null
[13:22:56.726]                     muffled <- FALSE
[13:22:56.726]                     if (inherits(cond, "message")) {
[13:22:56.726]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:56.726]                       if (muffled) 
[13:22:56.726]                         invokeRestart("muffleMessage")
[13:22:56.726]                     }
[13:22:56.726]                     else if (inherits(cond, "warning")) {
[13:22:56.726]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:56.726]                       if (muffled) 
[13:22:56.726]                         invokeRestart("muffleWarning")
[13:22:56.726]                     }
[13:22:56.726]                     else if (inherits(cond, "condition")) {
[13:22:56.726]                       if (!is.null(pattern)) {
[13:22:56.726]                         computeRestarts <- base::computeRestarts
[13:22:56.726]                         grepl <- base::grepl
[13:22:56.726]                         restarts <- computeRestarts(cond)
[13:22:56.726]                         for (restart in restarts) {
[13:22:56.726]                           name <- restart$name
[13:22:56.726]                           if (is.null(name)) 
[13:22:56.726]                             next
[13:22:56.726]                           if (!grepl(pattern, name)) 
[13:22:56.726]                             next
[13:22:56.726]                           invokeRestart(restart)
[13:22:56.726]                           muffled <- TRUE
[13:22:56.726]                           break
[13:22:56.726]                         }
[13:22:56.726]                       }
[13:22:56.726]                     }
[13:22:56.726]                     invisible(muffled)
[13:22:56.726]                   }
[13:22:56.726]                   muffleCondition(cond)
[13:22:56.726]                 })
[13:22:56.726]             }))
[13:22:56.726]             future::FutureResult(value = ...future.value$value, 
[13:22:56.726]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:56.726]                   ...future.rng), globalenv = if (FALSE) 
[13:22:56.726]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:56.726]                     ...future.globalenv.names))
[13:22:56.726]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:56.726]         }, condition = base::local({
[13:22:56.726]             c <- base::c
[13:22:56.726]             inherits <- base::inherits
[13:22:56.726]             invokeRestart <- base::invokeRestart
[13:22:56.726]             length <- base::length
[13:22:56.726]             list <- base::list
[13:22:56.726]             seq.int <- base::seq.int
[13:22:56.726]             signalCondition <- base::signalCondition
[13:22:56.726]             sys.calls <- base::sys.calls
[13:22:56.726]             `[[` <- base::`[[`
[13:22:56.726]             `+` <- base::`+`
[13:22:56.726]             `<<-` <- base::`<<-`
[13:22:56.726]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:56.726]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:56.726]                   3L)]
[13:22:56.726]             }
[13:22:56.726]             function(cond) {
[13:22:56.726]                 is_error <- inherits(cond, "error")
[13:22:56.726]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:56.726]                   NULL)
[13:22:56.726]                 if (is_error) {
[13:22:56.726]                   sessionInformation <- function() {
[13:22:56.726]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:56.726]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:56.726]                       search = base::search(), system = base::Sys.info())
[13:22:56.726]                   }
[13:22:56.726]                   ...future.conditions[[length(...future.conditions) + 
[13:22:56.726]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:56.726]                     cond$call), session = sessionInformation(), 
[13:22:56.726]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:56.726]                   signalCondition(cond)
[13:22:56.726]                 }
[13:22:56.726]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:56.726]                 "immediateCondition"))) {
[13:22:56.726]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:56.726]                   ...future.conditions[[length(...future.conditions) + 
[13:22:56.726]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:56.726]                   if (TRUE && !signal) {
[13:22:56.726]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:56.726]                     {
[13:22:56.726]                       inherits <- base::inherits
[13:22:56.726]                       invokeRestart <- base::invokeRestart
[13:22:56.726]                       is.null <- base::is.null
[13:22:56.726]                       muffled <- FALSE
[13:22:56.726]                       if (inherits(cond, "message")) {
[13:22:56.726]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:56.726]                         if (muffled) 
[13:22:56.726]                           invokeRestart("muffleMessage")
[13:22:56.726]                       }
[13:22:56.726]                       else if (inherits(cond, "warning")) {
[13:22:56.726]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:56.726]                         if (muffled) 
[13:22:56.726]                           invokeRestart("muffleWarning")
[13:22:56.726]                       }
[13:22:56.726]                       else if (inherits(cond, "condition")) {
[13:22:56.726]                         if (!is.null(pattern)) {
[13:22:56.726]                           computeRestarts <- base::computeRestarts
[13:22:56.726]                           grepl <- base::grepl
[13:22:56.726]                           restarts <- computeRestarts(cond)
[13:22:56.726]                           for (restart in restarts) {
[13:22:56.726]                             name <- restart$name
[13:22:56.726]                             if (is.null(name)) 
[13:22:56.726]                               next
[13:22:56.726]                             if (!grepl(pattern, name)) 
[13:22:56.726]                               next
[13:22:56.726]                             invokeRestart(restart)
[13:22:56.726]                             muffled <- TRUE
[13:22:56.726]                             break
[13:22:56.726]                           }
[13:22:56.726]                         }
[13:22:56.726]                       }
[13:22:56.726]                       invisible(muffled)
[13:22:56.726]                     }
[13:22:56.726]                     muffleCondition(cond, pattern = "^muffle")
[13:22:56.726]                   }
[13:22:56.726]                 }
[13:22:56.726]                 else {
[13:22:56.726]                   if (TRUE) {
[13:22:56.726]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:56.726]                     {
[13:22:56.726]                       inherits <- base::inherits
[13:22:56.726]                       invokeRestart <- base::invokeRestart
[13:22:56.726]                       is.null <- base::is.null
[13:22:56.726]                       muffled <- FALSE
[13:22:56.726]                       if (inherits(cond, "message")) {
[13:22:56.726]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:56.726]                         if (muffled) 
[13:22:56.726]                           invokeRestart("muffleMessage")
[13:22:56.726]                       }
[13:22:56.726]                       else if (inherits(cond, "warning")) {
[13:22:56.726]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:56.726]                         if (muffled) 
[13:22:56.726]                           invokeRestart("muffleWarning")
[13:22:56.726]                       }
[13:22:56.726]                       else if (inherits(cond, "condition")) {
[13:22:56.726]                         if (!is.null(pattern)) {
[13:22:56.726]                           computeRestarts <- base::computeRestarts
[13:22:56.726]                           grepl <- base::grepl
[13:22:56.726]                           restarts <- computeRestarts(cond)
[13:22:56.726]                           for (restart in restarts) {
[13:22:56.726]                             name <- restart$name
[13:22:56.726]                             if (is.null(name)) 
[13:22:56.726]                               next
[13:22:56.726]                             if (!grepl(pattern, name)) 
[13:22:56.726]                               next
[13:22:56.726]                             invokeRestart(restart)
[13:22:56.726]                             muffled <- TRUE
[13:22:56.726]                             break
[13:22:56.726]                           }
[13:22:56.726]                         }
[13:22:56.726]                       }
[13:22:56.726]                       invisible(muffled)
[13:22:56.726]                     }
[13:22:56.726]                     muffleCondition(cond, pattern = "^muffle")
[13:22:56.726]                   }
[13:22:56.726]                 }
[13:22:56.726]             }
[13:22:56.726]         }))
[13:22:56.726]     }, error = function(ex) {
[13:22:56.726]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:56.726]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:56.726]                 ...future.rng), started = ...future.startTime, 
[13:22:56.726]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:56.726]             version = "1.8"), class = "FutureResult")
[13:22:56.726]     }, finally = {
[13:22:56.726]         if (!identical(...future.workdir, getwd())) 
[13:22:56.726]             setwd(...future.workdir)
[13:22:56.726]         {
[13:22:56.726]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:56.726]                 ...future.oldOptions$nwarnings <- NULL
[13:22:56.726]             }
[13:22:56.726]             base::options(...future.oldOptions)
[13:22:56.726]             if (.Platform$OS.type == "windows") {
[13:22:56.726]                 old_names <- names(...future.oldEnvVars)
[13:22:56.726]                 envs <- base::Sys.getenv()
[13:22:56.726]                 names <- names(envs)
[13:22:56.726]                 common <- intersect(names, old_names)
[13:22:56.726]                 added <- setdiff(names, old_names)
[13:22:56.726]                 removed <- setdiff(old_names, names)
[13:22:56.726]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:56.726]                   envs[common]]
[13:22:56.726]                 NAMES <- toupper(changed)
[13:22:56.726]                 args <- list()
[13:22:56.726]                 for (kk in seq_along(NAMES)) {
[13:22:56.726]                   name <- changed[[kk]]
[13:22:56.726]                   NAME <- NAMES[[kk]]
[13:22:56.726]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:56.726]                     next
[13:22:56.726]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:56.726]                 }
[13:22:56.726]                 NAMES <- toupper(added)
[13:22:56.726]                 for (kk in seq_along(NAMES)) {
[13:22:56.726]                   name <- added[[kk]]
[13:22:56.726]                   NAME <- NAMES[[kk]]
[13:22:56.726]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:56.726]                     next
[13:22:56.726]                   args[[name]] <- ""
[13:22:56.726]                 }
[13:22:56.726]                 NAMES <- toupper(removed)
[13:22:56.726]                 for (kk in seq_along(NAMES)) {
[13:22:56.726]                   name <- removed[[kk]]
[13:22:56.726]                   NAME <- NAMES[[kk]]
[13:22:56.726]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:56.726]                     next
[13:22:56.726]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:56.726]                 }
[13:22:56.726]                 if (length(args) > 0) 
[13:22:56.726]                   base::do.call(base::Sys.setenv, args = args)
[13:22:56.726]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:56.726]             }
[13:22:56.726]             else {
[13:22:56.726]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:56.726]             }
[13:22:56.726]             {
[13:22:56.726]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:56.726]                   0L) {
[13:22:56.726]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:56.726]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:56.726]                   base::options(opts)
[13:22:56.726]                 }
[13:22:56.726]                 {
[13:22:56.726]                   {
[13:22:56.726]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:56.726]                     NULL
[13:22:56.726]                   }
[13:22:56.726]                   options(future.plan = NULL)
[13:22:56.726]                   if (is.na(NA_character_)) 
[13:22:56.726]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:56.726]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:56.726]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:56.726]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:56.726]                     envir = parent.frame()) 
[13:22:56.726]                   {
[13:22:56.726]                     if (is.function(workers)) 
[13:22:56.726]                       workers <- workers()
[13:22:56.726]                     workers <- structure(as.integer(workers), 
[13:22:56.726]                       class = class(workers))
[13:22:56.726]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:56.726]                       workers >= 1)
[13:22:56.726]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:56.726]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:56.726]                     }
[13:22:56.726]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:56.726]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:56.726]                       envir = envir)
[13:22:56.726]                     if (!future$lazy) 
[13:22:56.726]                       future <- run(future)
[13:22:56.726]                     invisible(future)
[13:22:56.726]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:56.726]                 }
[13:22:56.726]             }
[13:22:56.726]         }
[13:22:56.726]     })
[13:22:56.726]     if (TRUE) {
[13:22:56.726]         base::sink(type = "output", split = FALSE)
[13:22:56.726]         if (TRUE) {
[13:22:56.726]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:56.726]         }
[13:22:56.726]         else {
[13:22:56.726]             ...future.result["stdout"] <- base::list(NULL)
[13:22:56.726]         }
[13:22:56.726]         base::close(...future.stdout)
[13:22:56.726]         ...future.stdout <- NULL
[13:22:56.726]     }
[13:22:56.726]     ...future.result$conditions <- ...future.conditions
[13:22:56.726]     ...future.result$finished <- base::Sys.time()
[13:22:56.726]     ...future.result
[13:22:56.726] }
[13:22:56.729] Poll #1 (0): usedNodes() = 2, workers = 2
[13:22:56.749] receiveMessageFromWorker() for ClusterFuture ...
[13:22:56.749] - Validating connection of MultisessionFuture
[13:22:56.749] - received message: FutureResult
[13:22:56.749] - Received FutureResult
[13:22:56.749] - Erased future from FutureRegistry
[13:22:56.749] result() for ClusterFuture ...
[13:22:56.749] - result already collected: FutureResult
[13:22:56.750] result() for ClusterFuture ... done
[13:22:56.750] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:56.750] result() for ClusterFuture ...
[13:22:56.750] - result already collected: FutureResult
[13:22:56.750] result() for ClusterFuture ... done
[13:22:56.750] result() for ClusterFuture ...
[13:22:56.750] - result already collected: FutureResult
[13:22:56.750] result() for ClusterFuture ... done
[13:22:56.751] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[13:22:56.751] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[13:22:56.752] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[13:22:56.752] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[13:22:56.752] MultisessionFuture started
[13:22:56.753] - Launch lazy future ... done
[13:22:56.753] run() for ‘MultisessionFuture’ ... done
[13:22:56.753] result() for ClusterFuture ...
[13:22:56.753] - result already collected: FutureResult
[13:22:56.753] result() for ClusterFuture ... done
[13:22:56.753] result() for ClusterFuture ...
[13:22:56.753] - result already collected: FutureResult
[13:22:56.754] result() for ClusterFuture ... done
[13:22:56.754] result() for ClusterFuture ...
[13:22:56.754] receiveMessageFromWorker() for ClusterFuture ...
[13:22:56.754] - Validating connection of MultisessionFuture
[13:22:56.792] - received message: FutureResult
[13:22:56.792] - Received FutureResult
[13:22:56.793] - Erased future from FutureRegistry
[13:22:56.793] result() for ClusterFuture ...
[13:22:56.793] - result already collected: FutureResult
[13:22:56.793] result() for ClusterFuture ... done
[13:22:56.793] signalConditions() ...
[13:22:56.793]  - include = ‘immediateCondition’
[13:22:56.793]  - exclude = 
[13:22:56.793]  - resignal = FALSE
[13:22:56.793]  - Number of conditions: 1
[13:22:56.793] signalConditions() ... done
[13:22:56.794] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:56.794] result() for ClusterFuture ... done
[13:22:56.794] result() for ClusterFuture ...
[13:22:56.794] - result already collected: FutureResult
[13:22:56.794] result() for ClusterFuture ... done
[13:22:56.794] signalConditions() ...
[13:22:56.794]  - include = ‘immediateCondition’
[13:22:56.794]  - exclude = 
[13:22:56.794]  - resignal = FALSE
[13:22:56.794]  - Number of conditions: 1
[13:22:56.794] signalConditions() ... done
[13:22:56.795] Future state: ‘finished’
[13:22:56.795] result() for ClusterFuture ...
[13:22:56.795] - result already collected: FutureResult
[13:22:56.795] result() for ClusterFuture ... done
[13:22:56.795] signalConditions() ...
[13:22:56.795]  - include = ‘condition’
[13:22:56.795]  - exclude = ‘immediateCondition’
[13:22:56.795]  - resignal = TRUE
[13:22:56.795]  - Number of conditions: 1
[13:22:56.795]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:22:56.796] signalConditions() ... done
[13:22:56.796] result() for ClusterFuture ...
[13:22:56.796] receiveMessageFromWorker() for ClusterFuture ...
[13:22:56.796] - Validating connection of MultisessionFuture
[13:22:56.801] - received message: FutureResult
[13:22:56.801] - Received FutureResult
[13:22:56.801] - Erased future from FutureRegistry
[13:22:56.802] result() for ClusterFuture ...
[13:22:56.802] - result already collected: FutureResult
[13:22:56.802] result() for ClusterFuture ... done
[13:22:56.802] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:56.802] result() for ClusterFuture ... done
[13:22:56.802] result() for ClusterFuture ...
[13:22:56.802] - result already collected: FutureResult
[13:22:56.802] result() for ClusterFuture ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[13:22:56.803] result() for ClusterFuture ...
[13:22:56.803] - result already collected: FutureResult
[13:22:56.803] result() for ClusterFuture ... done
[13:22:56.803] result() for ClusterFuture ...
[13:22:56.803] - result already collected: FutureResult
[13:22:56.803] result() for ClusterFuture ... done
[13:22:56.803] signalConditions() ...
[13:22:56.803]  - include = ‘immediateCondition’
[13:22:56.803]  - exclude = 
[13:22:56.803]  - resignal = FALSE
[13:22:56.803]  - Number of conditions: 1
[13:22:56.804] signalConditions() ... done
[13:22:56.804] Future state: ‘finished’
[13:22:56.804] result() for ClusterFuture ...
[13:22:56.804] - result already collected: FutureResult
[13:22:56.804] result() for ClusterFuture ... done
[13:22:56.804] signalConditions() ...
[13:22:56.804]  - include = ‘condition’
[13:22:56.804]  - exclude = ‘immediateCondition’
[13:22:56.804]  - resignal = TRUE
[13:22:56.804]  - Number of conditions: 1
[13:22:56.805]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:22:56.805] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[13:22:56.805] result() for ClusterFuture ...
[13:22:56.805] - result already collected: FutureResult
[13:22:56.805] result() for ClusterFuture ... done
[13:22:56.805] result() for ClusterFuture ...
[13:22:56.805] - result already collected: FutureResult
[13:22:56.806] result() for ClusterFuture ... done
[13:22:56.806] signalConditions() ...
[13:22:56.806]  - include = ‘immediateCondition’
[13:22:56.806]  - exclude = 
[13:22:56.806]  - resignal = FALSE
[13:22:56.806]  - Number of conditions: 1
[13:22:56.806] signalConditions() ... done
[13:22:56.806] Future state: ‘finished’
[13:22:56.806] result() for ClusterFuture ...
[13:22:56.806] - result already collected: FutureResult
[13:22:56.806] result() for ClusterFuture ... done
[13:22:56.807] signalConditions() ...
[13:22:56.807]  - include = ‘condition’
[13:22:56.807]  - exclude = ‘immediateCondition’
[13:22:56.807]  - resignal = TRUE
[13:22:56.807]  - Number of conditions: 1
[13:22:56.807]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:22:56.807] signalConditions() ... done
** Future evaluation with a poor-man's "progress bar"
[13:22:56.807] getGlobalsAndPackages() ...
[13:22:56.808] Searching for globals...
[13:22:56.810] - globals found: [4] ‘{’, ‘cat’, ‘for’, ‘:’
[13:22:56.810] Searching for globals ... DONE
[13:22:56.810] Resolving globals: FALSE
[13:22:56.810] 
[13:22:56.810] 
[13:22:56.810] getGlobalsAndPackages() ... DONE
[13:22:56.811] run() for ‘Future’ ...
[13:22:56.811] - state: ‘created’
[13:22:56.811] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:56.825] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:56.825] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:56.825]   - Field: ‘node’
[13:22:56.825]   - Field: ‘label’
[13:22:56.826]   - Field: ‘local’
[13:22:56.826]   - Field: ‘owner’
[13:22:56.826]   - Field: ‘envir’
[13:22:56.826]   - Field: ‘workers’
[13:22:56.826]   - Field: ‘packages’
[13:22:56.826]   - Field: ‘gc’
[13:22:56.826]   - Field: ‘conditions’
[13:22:56.826]   - Field: ‘persistent’
[13:22:56.826]   - Field: ‘expr’
[13:22:56.826]   - Field: ‘uuid’
[13:22:56.827]   - Field: ‘seed’
[13:22:56.827]   - Field: ‘version’
[13:22:56.827]   - Field: ‘result’
[13:22:56.827]   - Field: ‘asynchronous’
[13:22:56.827]   - Field: ‘calls’
[13:22:56.827]   - Field: ‘globals’
[13:22:56.827]   - Field: ‘stdout’
[13:22:56.827]   - Field: ‘earlySignal’
[13:22:56.827]   - Field: ‘lazy’
[13:22:56.827]   - Field: ‘state’
[13:22:56.827] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:56.828] - Launch lazy future ...
[13:22:56.828] Packages needed by the future expression (n = 0): <none>
[13:22:56.828] Packages needed by future strategies (n = 0): <none>
[13:22:56.829] {
[13:22:56.829]     {
[13:22:56.829]         {
[13:22:56.829]             ...future.startTime <- base::Sys.time()
[13:22:56.829]             {
[13:22:56.829]                 {
[13:22:56.829]                   {
[13:22:56.829]                     {
[13:22:56.829]                       base::local({
[13:22:56.829]                         has_future <- base::requireNamespace("future", 
[13:22:56.829]                           quietly = TRUE)
[13:22:56.829]                         if (has_future) {
[13:22:56.829]                           ns <- base::getNamespace("future")
[13:22:56.829]                           version <- ns[[".package"]][["version"]]
[13:22:56.829]                           if (is.null(version)) 
[13:22:56.829]                             version <- utils::packageVersion("future")
[13:22:56.829]                         }
[13:22:56.829]                         else {
[13:22:56.829]                           version <- NULL
[13:22:56.829]                         }
[13:22:56.829]                         if (!has_future || version < "1.8.0") {
[13:22:56.829]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:56.829]                             "", base::R.version$version.string), 
[13:22:56.829]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:56.829]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:56.829]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:56.829]                               "release", "version")], collapse = " "), 
[13:22:56.829]                             hostname = base::Sys.info()[["nodename"]])
[13:22:56.829]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:56.829]                             info)
[13:22:56.829]                           info <- base::paste(info, collapse = "; ")
[13:22:56.829]                           if (!has_future) {
[13:22:56.829]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:56.829]                               info)
[13:22:56.829]                           }
[13:22:56.829]                           else {
[13:22:56.829]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:56.829]                               info, version)
[13:22:56.829]                           }
[13:22:56.829]                           base::stop(msg)
[13:22:56.829]                         }
[13:22:56.829]                       })
[13:22:56.829]                     }
[13:22:56.829]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:56.829]                     base::options(mc.cores = 1L)
[13:22:56.829]                   }
[13:22:56.829]                   options(future.plan = NULL)
[13:22:56.829]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:56.829]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:56.829]                 }
[13:22:56.829]                 ...future.workdir <- getwd()
[13:22:56.829]             }
[13:22:56.829]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:56.829]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:56.829]         }
[13:22:56.829]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:56.829]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:56.829]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:56.829]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:56.829]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:56.829]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:56.829]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:56.829]             base::names(...future.oldOptions))
[13:22:56.829]     }
[13:22:56.829]     if (FALSE) {
[13:22:56.829]     }
[13:22:56.829]     else {
[13:22:56.829]         if (TRUE) {
[13:22:56.829]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:56.829]                 open = "w")
[13:22:56.829]         }
[13:22:56.829]         else {
[13:22:56.829]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:56.829]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:56.829]         }
[13:22:56.829]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:56.829]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:56.829]             base::sink(type = "output", split = FALSE)
[13:22:56.829]             base::close(...future.stdout)
[13:22:56.829]         }, add = TRUE)
[13:22:56.829]     }
[13:22:56.829]     ...future.frame <- base::sys.nframe()
[13:22:56.829]     ...future.conditions <- base::list()
[13:22:56.829]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:56.829]     if (FALSE) {
[13:22:56.829]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:56.829]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:56.829]     }
[13:22:56.829]     ...future.result <- base::tryCatch({
[13:22:56.829]         base::withCallingHandlers({
[13:22:56.829]             ...future.value <- base::withVisible(base::local({
[13:22:56.829]                 ...future.makeSendCondition <- base::local({
[13:22:56.829]                   sendCondition <- NULL
[13:22:56.829]                   function(frame = 1L) {
[13:22:56.829]                     if (is.function(sendCondition)) 
[13:22:56.829]                       return(sendCondition)
[13:22:56.829]                     ns <- getNamespace("parallel")
[13:22:56.829]                     if (exists("sendData", mode = "function", 
[13:22:56.829]                       envir = ns)) {
[13:22:56.829]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:56.829]                         envir = ns)
[13:22:56.829]                       envir <- sys.frame(frame)
[13:22:56.829]                       master <- NULL
[13:22:56.829]                       while (!identical(envir, .GlobalEnv) && 
[13:22:56.829]                         !identical(envir, emptyenv())) {
[13:22:56.829]                         if (exists("master", mode = "list", envir = envir, 
[13:22:56.829]                           inherits = FALSE)) {
[13:22:56.829]                           master <- get("master", mode = "list", 
[13:22:56.829]                             envir = envir, inherits = FALSE)
[13:22:56.829]                           if (inherits(master, c("SOCKnode", 
[13:22:56.829]                             "SOCK0node"))) {
[13:22:56.829]                             sendCondition <<- function(cond) {
[13:22:56.829]                               data <- list(type = "VALUE", value = cond, 
[13:22:56.829]                                 success = TRUE)
[13:22:56.829]                               parallel_sendData(master, data)
[13:22:56.829]                             }
[13:22:56.829]                             return(sendCondition)
[13:22:56.829]                           }
[13:22:56.829]                         }
[13:22:56.829]                         frame <- frame + 1L
[13:22:56.829]                         envir <- sys.frame(frame)
[13:22:56.829]                       }
[13:22:56.829]                     }
[13:22:56.829]                     sendCondition <<- function(cond) NULL
[13:22:56.829]                   }
[13:22:56.829]                 })
[13:22:56.829]                 withCallingHandlers({
[13:22:56.829]                   {
[13:22:56.829]                     cat("Processing: ")
[13:22:56.829]                     for (ii in 1:10) {
[13:22:56.829]                       cat(".")
[13:22:56.829]                     }
[13:22:56.829]                     cat(" [100%]\n")
[13:22:56.829]                     4
[13:22:56.829]                   }
[13:22:56.829]                 }, immediateCondition = function(cond) {
[13:22:56.829]                   sendCondition <- ...future.makeSendCondition()
[13:22:56.829]                   sendCondition(cond)
[13:22:56.829]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:56.829]                   {
[13:22:56.829]                     inherits <- base::inherits
[13:22:56.829]                     invokeRestart <- base::invokeRestart
[13:22:56.829]                     is.null <- base::is.null
[13:22:56.829]                     muffled <- FALSE
[13:22:56.829]                     if (inherits(cond, "message")) {
[13:22:56.829]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:56.829]                       if (muffled) 
[13:22:56.829]                         invokeRestart("muffleMessage")
[13:22:56.829]                     }
[13:22:56.829]                     else if (inherits(cond, "warning")) {
[13:22:56.829]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:56.829]                       if (muffled) 
[13:22:56.829]                         invokeRestart("muffleWarning")
[13:22:56.829]                     }
[13:22:56.829]                     else if (inherits(cond, "condition")) {
[13:22:56.829]                       if (!is.null(pattern)) {
[13:22:56.829]                         computeRestarts <- base::computeRestarts
[13:22:56.829]                         grepl <- base::grepl
[13:22:56.829]                         restarts <- computeRestarts(cond)
[13:22:56.829]                         for (restart in restarts) {
[13:22:56.829]                           name <- restart$name
[13:22:56.829]                           if (is.null(name)) 
[13:22:56.829]                             next
[13:22:56.829]                           if (!grepl(pattern, name)) 
[13:22:56.829]                             next
[13:22:56.829]                           invokeRestart(restart)
[13:22:56.829]                           muffled <- TRUE
[13:22:56.829]                           break
[13:22:56.829]                         }
[13:22:56.829]                       }
[13:22:56.829]                     }
[13:22:56.829]                     invisible(muffled)
[13:22:56.829]                   }
[13:22:56.829]                   muffleCondition(cond)
[13:22:56.829]                 })
[13:22:56.829]             }))
[13:22:56.829]             future::FutureResult(value = ...future.value$value, 
[13:22:56.829]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:56.829]                   ...future.rng), globalenv = if (FALSE) 
[13:22:56.829]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:56.829]                     ...future.globalenv.names))
[13:22:56.829]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:56.829]         }, condition = base::local({
[13:22:56.829]             c <- base::c
[13:22:56.829]             inherits <- base::inherits
[13:22:56.829]             invokeRestart <- base::invokeRestart
[13:22:56.829]             length <- base::length
[13:22:56.829]             list <- base::list
[13:22:56.829]             seq.int <- base::seq.int
[13:22:56.829]             signalCondition <- base::signalCondition
[13:22:56.829]             sys.calls <- base::sys.calls
[13:22:56.829]             `[[` <- base::`[[`
[13:22:56.829]             `+` <- base::`+`
[13:22:56.829]             `<<-` <- base::`<<-`
[13:22:56.829]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:56.829]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:56.829]                   3L)]
[13:22:56.829]             }
[13:22:56.829]             function(cond) {
[13:22:56.829]                 is_error <- inherits(cond, "error")
[13:22:56.829]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:56.829]                   NULL)
[13:22:56.829]                 if (is_error) {
[13:22:56.829]                   sessionInformation <- function() {
[13:22:56.829]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:56.829]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:56.829]                       search = base::search(), system = base::Sys.info())
[13:22:56.829]                   }
[13:22:56.829]                   ...future.conditions[[length(...future.conditions) + 
[13:22:56.829]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:56.829]                     cond$call), session = sessionInformation(), 
[13:22:56.829]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:56.829]                   signalCondition(cond)
[13:22:56.829]                 }
[13:22:56.829]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:56.829]                 "immediateCondition"))) {
[13:22:56.829]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:56.829]                   ...future.conditions[[length(...future.conditions) + 
[13:22:56.829]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:56.829]                   if (TRUE && !signal) {
[13:22:56.829]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:56.829]                     {
[13:22:56.829]                       inherits <- base::inherits
[13:22:56.829]                       invokeRestart <- base::invokeRestart
[13:22:56.829]                       is.null <- base::is.null
[13:22:56.829]                       muffled <- FALSE
[13:22:56.829]                       if (inherits(cond, "message")) {
[13:22:56.829]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:56.829]                         if (muffled) 
[13:22:56.829]                           invokeRestart("muffleMessage")
[13:22:56.829]                       }
[13:22:56.829]                       else if (inherits(cond, "warning")) {
[13:22:56.829]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:56.829]                         if (muffled) 
[13:22:56.829]                           invokeRestart("muffleWarning")
[13:22:56.829]                       }
[13:22:56.829]                       else if (inherits(cond, "condition")) {
[13:22:56.829]                         if (!is.null(pattern)) {
[13:22:56.829]                           computeRestarts <- base::computeRestarts
[13:22:56.829]                           grepl <- base::grepl
[13:22:56.829]                           restarts <- computeRestarts(cond)
[13:22:56.829]                           for (restart in restarts) {
[13:22:56.829]                             name <- restart$name
[13:22:56.829]                             if (is.null(name)) 
[13:22:56.829]                               next
[13:22:56.829]                             if (!grepl(pattern, name)) 
[13:22:56.829]                               next
[13:22:56.829]                             invokeRestart(restart)
[13:22:56.829]                             muffled <- TRUE
[13:22:56.829]                             break
[13:22:56.829]                           }
[13:22:56.829]                         }
[13:22:56.829]                       }
[13:22:56.829]                       invisible(muffled)
[13:22:56.829]                     }
[13:22:56.829]                     muffleCondition(cond, pattern = "^muffle")
[13:22:56.829]                   }
[13:22:56.829]                 }
[13:22:56.829]                 else {
[13:22:56.829]                   if (TRUE) {
[13:22:56.829]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:56.829]                     {
[13:22:56.829]                       inherits <- base::inherits
[13:22:56.829]                       invokeRestart <- base::invokeRestart
[13:22:56.829]                       is.null <- base::is.null
[13:22:56.829]                       muffled <- FALSE
[13:22:56.829]                       if (inherits(cond, "message")) {
[13:22:56.829]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:56.829]                         if (muffled) 
[13:22:56.829]                           invokeRestart("muffleMessage")
[13:22:56.829]                       }
[13:22:56.829]                       else if (inherits(cond, "warning")) {
[13:22:56.829]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:56.829]                         if (muffled) 
[13:22:56.829]                           invokeRestart("muffleWarning")
[13:22:56.829]                       }
[13:22:56.829]                       else if (inherits(cond, "condition")) {
[13:22:56.829]                         if (!is.null(pattern)) {
[13:22:56.829]                           computeRestarts <- base::computeRestarts
[13:22:56.829]                           grepl <- base::grepl
[13:22:56.829]                           restarts <- computeRestarts(cond)
[13:22:56.829]                           for (restart in restarts) {
[13:22:56.829]                             name <- restart$name
[13:22:56.829]                             if (is.null(name)) 
[13:22:56.829]                               next
[13:22:56.829]                             if (!grepl(pattern, name)) 
[13:22:56.829]                               next
[13:22:56.829]                             invokeRestart(restart)
[13:22:56.829]                             muffled <- TRUE
[13:22:56.829]                             break
[13:22:56.829]                           }
[13:22:56.829]                         }
[13:22:56.829]                       }
[13:22:56.829]                       invisible(muffled)
[13:22:56.829]                     }
[13:22:56.829]                     muffleCondition(cond, pattern = "^muffle")
[13:22:56.829]                   }
[13:22:56.829]                 }
[13:22:56.829]             }
[13:22:56.829]         }))
[13:22:56.829]     }, error = function(ex) {
[13:22:56.829]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:56.829]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:56.829]                 ...future.rng), started = ...future.startTime, 
[13:22:56.829]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:56.829]             version = "1.8"), class = "FutureResult")
[13:22:56.829]     }, finally = {
[13:22:56.829]         if (!identical(...future.workdir, getwd())) 
[13:22:56.829]             setwd(...future.workdir)
[13:22:56.829]         {
[13:22:56.829]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:56.829]                 ...future.oldOptions$nwarnings <- NULL
[13:22:56.829]             }
[13:22:56.829]             base::options(...future.oldOptions)
[13:22:56.829]             if (.Platform$OS.type == "windows") {
[13:22:56.829]                 old_names <- names(...future.oldEnvVars)
[13:22:56.829]                 envs <- base::Sys.getenv()
[13:22:56.829]                 names <- names(envs)
[13:22:56.829]                 common <- intersect(names, old_names)
[13:22:56.829]                 added <- setdiff(names, old_names)
[13:22:56.829]                 removed <- setdiff(old_names, names)
[13:22:56.829]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:56.829]                   envs[common]]
[13:22:56.829]                 NAMES <- toupper(changed)
[13:22:56.829]                 args <- list()
[13:22:56.829]                 for (kk in seq_along(NAMES)) {
[13:22:56.829]                   name <- changed[[kk]]
[13:22:56.829]                   NAME <- NAMES[[kk]]
[13:22:56.829]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:56.829]                     next
[13:22:56.829]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:56.829]                 }
[13:22:56.829]                 NAMES <- toupper(added)
[13:22:56.829]                 for (kk in seq_along(NAMES)) {
[13:22:56.829]                   name <- added[[kk]]
[13:22:56.829]                   NAME <- NAMES[[kk]]
[13:22:56.829]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:56.829]                     next
[13:22:56.829]                   args[[name]] <- ""
[13:22:56.829]                 }
[13:22:56.829]                 NAMES <- toupper(removed)
[13:22:56.829]                 for (kk in seq_along(NAMES)) {
[13:22:56.829]                   name <- removed[[kk]]
[13:22:56.829]                   NAME <- NAMES[[kk]]
[13:22:56.829]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:56.829]                     next
[13:22:56.829]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:56.829]                 }
[13:22:56.829]                 if (length(args) > 0) 
[13:22:56.829]                   base::do.call(base::Sys.setenv, args = args)
[13:22:56.829]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:56.829]             }
[13:22:56.829]             else {
[13:22:56.829]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:56.829]             }
[13:22:56.829]             {
[13:22:56.829]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:56.829]                   0L) {
[13:22:56.829]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:56.829]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:56.829]                   base::options(opts)
[13:22:56.829]                 }
[13:22:56.829]                 {
[13:22:56.829]                   {
[13:22:56.829]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:56.829]                     NULL
[13:22:56.829]                   }
[13:22:56.829]                   options(future.plan = NULL)
[13:22:56.829]                   if (is.na(NA_character_)) 
[13:22:56.829]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:56.829]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:56.829]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:56.829]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:56.829]                     envir = parent.frame()) 
[13:22:56.829]                   {
[13:22:56.829]                     if (is.function(workers)) 
[13:22:56.829]                       workers <- workers()
[13:22:56.829]                     workers <- structure(as.integer(workers), 
[13:22:56.829]                       class = class(workers))
[13:22:56.829]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:56.829]                       workers >= 1)
[13:22:56.829]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:56.829]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:56.829]                     }
[13:22:56.829]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:56.829]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:56.829]                       envir = envir)
[13:22:56.829]                     if (!future$lazy) 
[13:22:56.829]                       future <- run(future)
[13:22:56.829]                     invisible(future)
[13:22:56.829]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:56.829]                 }
[13:22:56.829]             }
[13:22:56.829]         }
[13:22:56.829]     })
[13:22:56.829]     if (TRUE) {
[13:22:56.829]         base::sink(type = "output", split = FALSE)
[13:22:56.829]         if (TRUE) {
[13:22:56.829]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:56.829]         }
[13:22:56.829]         else {
[13:22:56.829]             ...future.result["stdout"] <- base::list(NULL)
[13:22:56.829]         }
[13:22:56.829]         base::close(...future.stdout)
[13:22:56.829]         ...future.stdout <- NULL
[13:22:56.829]     }
[13:22:56.829]     ...future.result$conditions <- ...future.conditions
[13:22:56.829]     ...future.result$finished <- base::Sys.time()
[13:22:56.829]     ...future.result
[13:22:56.829] }
[13:22:56.832] MultisessionFuture started
[13:22:56.832] - Launch lazy future ... done
[13:22:56.832] run() for ‘MultisessionFuture’ ... done
** Collecting results
v1 = 1
v2 = 2
Warning in sprintf(...) : restarting interrupted promise evaluation
[13:22:56.833] result() for ClusterFuture ...
[13:22:56.833] - result already collected: FutureResult
[13:22:56.833] result() for ClusterFuture ... done
[13:22:56.833] result() for ClusterFuture ...
[13:22:56.833] - result already collected: FutureResult
[13:22:56.833] result() for ClusterFuture ... done
[13:22:56.833] signalConditions() ...
[13:22:56.833]  - include = ‘immediateCondition’
[13:22:56.833]  - exclude = 
[13:22:56.834]  - resignal = FALSE
[13:22:56.834]  - Number of conditions: 1
[13:22:56.834] signalConditions() ... done
[13:22:56.834] Future state: ‘finished’
[13:22:56.834] result() for ClusterFuture ...
[13:22:56.834] - result already collected: FutureResult
[13:22:56.834] result() for ClusterFuture ... done
[13:22:56.834] signalConditions() ...
[13:22:56.834]  - include = ‘condition’
[13:22:56.834]  - exclude = ‘immediateCondition’
[13:22:56.834]  - resignal = TRUE
[13:22:56.835]  - Number of conditions: 1
[13:22:56.835]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:22:56.835] signalConditions() ... done
v3: <simpleError> (as expect)
[13:22:56.835] result() for ClusterFuture ...
[13:22:56.835] receiveMessageFromWorker() for ClusterFuture ...
[13:22:56.835] - Validating connection of MultisessionFuture
[13:22:56.881] - received message: FutureResult
[13:22:56.881] - Received FutureResult
[13:22:56.882] - Erased future from FutureRegistry
[13:22:56.882] result() for ClusterFuture ...
[13:22:56.882] - result already collected: FutureResult
[13:22:56.882] result() for ClusterFuture ... done
[13:22:56.882] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:56.882] result() for ClusterFuture ... done
[13:22:56.882] result() for ClusterFuture ...
[13:22:56.882] - result already collected: FutureResult
[13:22:56.882] result() for ClusterFuture ... done
Processing: .......... [100%]
v4 = 4
** Left-to-right and right-to-left future assignments
[13:22:56.883] getGlobalsAndPackages() ...
[13:22:56.883] Searching for globals...
[13:22:56.883] 
[13:22:56.883] Searching for globals ... DONE
[13:22:56.884] - globals: [0] <none>
[13:22:56.884] getGlobalsAndPackages() ... DONE
[13:22:56.884] run() for ‘Future’ ...
[13:22:56.884] - state: ‘created’
[13:22:56.884] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:56.898] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:56.898] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:56.898]   - Field: ‘node’
[13:22:56.899]   - Field: ‘label’
[13:22:56.899]   - Field: ‘local’
[13:22:56.899]   - Field: ‘owner’
[13:22:56.899]   - Field: ‘envir’
[13:22:56.899]   - Field: ‘workers’
[13:22:56.899]   - Field: ‘packages’
[13:22:56.899]   - Field: ‘gc’
[13:22:56.899]   - Field: ‘conditions’
[13:22:56.899]   - Field: ‘persistent’
[13:22:56.899]   - Field: ‘expr’
[13:22:56.899]   - Field: ‘uuid’
[13:22:56.899]   - Field: ‘seed’
[13:22:56.900]   - Field: ‘version’
[13:22:56.900]   - Field: ‘result’
[13:22:56.900]   - Field: ‘asynchronous’
[13:22:56.900]   - Field: ‘calls’
[13:22:56.900]   - Field: ‘globals’
[13:22:56.900]   - Field: ‘stdout’
[13:22:56.900]   - Field: ‘earlySignal’
[13:22:56.900]   - Field: ‘lazy’
[13:22:56.900]   - Field: ‘state’
[13:22:56.900] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:56.901] - Launch lazy future ...
[13:22:56.901] Packages needed by the future expression (n = 0): <none>
[13:22:56.901] Packages needed by future strategies (n = 0): <none>
[13:22:56.904] {
[13:22:56.904]     {
[13:22:56.904]         {
[13:22:56.904]             ...future.startTime <- base::Sys.time()
[13:22:56.904]             {
[13:22:56.904]                 {
[13:22:56.904]                   {
[13:22:56.904]                     {
[13:22:56.904]                       base::local({
[13:22:56.904]                         has_future <- base::requireNamespace("future", 
[13:22:56.904]                           quietly = TRUE)
[13:22:56.904]                         if (has_future) {
[13:22:56.904]                           ns <- base::getNamespace("future")
[13:22:56.904]                           version <- ns[[".package"]][["version"]]
[13:22:56.904]                           if (is.null(version)) 
[13:22:56.904]                             version <- utils::packageVersion("future")
[13:22:56.904]                         }
[13:22:56.904]                         else {
[13:22:56.904]                           version <- NULL
[13:22:56.904]                         }
[13:22:56.904]                         if (!has_future || version < "1.8.0") {
[13:22:56.904]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:56.904]                             "", base::R.version$version.string), 
[13:22:56.904]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:56.904]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:56.904]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:56.904]                               "release", "version")], collapse = " "), 
[13:22:56.904]                             hostname = base::Sys.info()[["nodename"]])
[13:22:56.904]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:56.904]                             info)
[13:22:56.904]                           info <- base::paste(info, collapse = "; ")
[13:22:56.904]                           if (!has_future) {
[13:22:56.904]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:56.904]                               info)
[13:22:56.904]                           }
[13:22:56.904]                           else {
[13:22:56.904]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:56.904]                               info, version)
[13:22:56.904]                           }
[13:22:56.904]                           base::stop(msg)
[13:22:56.904]                         }
[13:22:56.904]                       })
[13:22:56.904]                     }
[13:22:56.904]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:56.904]                     base::options(mc.cores = 1L)
[13:22:56.904]                   }
[13:22:56.904]                   options(future.plan = NULL)
[13:22:56.904]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:56.904]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:56.904]                 }
[13:22:56.904]                 ...future.workdir <- getwd()
[13:22:56.904]             }
[13:22:56.904]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:56.904]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:56.904]         }
[13:22:56.904]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:56.904]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:56.904]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:56.904]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:56.904]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:56.904]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:56.904]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:56.904]             base::names(...future.oldOptions))
[13:22:56.904]     }
[13:22:56.904]     if (FALSE) {
[13:22:56.904]     }
[13:22:56.904]     else {
[13:22:56.904]         if (TRUE) {
[13:22:56.904]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:56.904]                 open = "w")
[13:22:56.904]         }
[13:22:56.904]         else {
[13:22:56.904]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:56.904]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:56.904]         }
[13:22:56.904]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:56.904]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:56.904]             base::sink(type = "output", split = FALSE)
[13:22:56.904]             base::close(...future.stdout)
[13:22:56.904]         }, add = TRUE)
[13:22:56.904]     }
[13:22:56.904]     ...future.frame <- base::sys.nframe()
[13:22:56.904]     ...future.conditions <- base::list()
[13:22:56.904]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:56.904]     if (FALSE) {
[13:22:56.904]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:56.904]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:56.904]     }
[13:22:56.904]     ...future.result <- base::tryCatch({
[13:22:56.904]         base::withCallingHandlers({
[13:22:56.904]             ...future.value <- base::withVisible(base::local({
[13:22:56.904]                 ...future.makeSendCondition <- base::local({
[13:22:56.904]                   sendCondition <- NULL
[13:22:56.904]                   function(frame = 1L) {
[13:22:56.904]                     if (is.function(sendCondition)) 
[13:22:56.904]                       return(sendCondition)
[13:22:56.904]                     ns <- getNamespace("parallel")
[13:22:56.904]                     if (exists("sendData", mode = "function", 
[13:22:56.904]                       envir = ns)) {
[13:22:56.904]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:56.904]                         envir = ns)
[13:22:56.904]                       envir <- sys.frame(frame)
[13:22:56.904]                       master <- NULL
[13:22:56.904]                       while (!identical(envir, .GlobalEnv) && 
[13:22:56.904]                         !identical(envir, emptyenv())) {
[13:22:56.904]                         if (exists("master", mode = "list", envir = envir, 
[13:22:56.904]                           inherits = FALSE)) {
[13:22:56.904]                           master <- get("master", mode = "list", 
[13:22:56.904]                             envir = envir, inherits = FALSE)
[13:22:56.904]                           if (inherits(master, c("SOCKnode", 
[13:22:56.904]                             "SOCK0node"))) {
[13:22:56.904]                             sendCondition <<- function(cond) {
[13:22:56.904]                               data <- list(type = "VALUE", value = cond, 
[13:22:56.904]                                 success = TRUE)
[13:22:56.904]                               parallel_sendData(master, data)
[13:22:56.904]                             }
[13:22:56.904]                             return(sendCondition)
[13:22:56.904]                           }
[13:22:56.904]                         }
[13:22:56.904]                         frame <- frame + 1L
[13:22:56.904]                         envir <- sys.frame(frame)
[13:22:56.904]                       }
[13:22:56.904]                     }
[13:22:56.904]                     sendCondition <<- function(cond) NULL
[13:22:56.904]                   }
[13:22:56.904]                 })
[13:22:56.904]                 withCallingHandlers({
[13:22:56.904]                   1
[13:22:56.904]                 }, immediateCondition = function(cond) {
[13:22:56.904]                   sendCondition <- ...future.makeSendCondition()
[13:22:56.904]                   sendCondition(cond)
[13:22:56.904]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:56.904]                   {
[13:22:56.904]                     inherits <- base::inherits
[13:22:56.904]                     invokeRestart <- base::invokeRestart
[13:22:56.904]                     is.null <- base::is.null
[13:22:56.904]                     muffled <- FALSE
[13:22:56.904]                     if (inherits(cond, "message")) {
[13:22:56.904]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:56.904]                       if (muffled) 
[13:22:56.904]                         invokeRestart("muffleMessage")
[13:22:56.904]                     }
[13:22:56.904]                     else if (inherits(cond, "warning")) {
[13:22:56.904]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:56.904]                       if (muffled) 
[13:22:56.904]                         invokeRestart("muffleWarning")
[13:22:56.904]                     }
[13:22:56.904]                     else if (inherits(cond, "condition")) {
[13:22:56.904]                       if (!is.null(pattern)) {
[13:22:56.904]                         computeRestarts <- base::computeRestarts
[13:22:56.904]                         grepl <- base::grepl
[13:22:56.904]                         restarts <- computeRestarts(cond)
[13:22:56.904]                         for (restart in restarts) {
[13:22:56.904]                           name <- restart$name
[13:22:56.904]                           if (is.null(name)) 
[13:22:56.904]                             next
[13:22:56.904]                           if (!grepl(pattern, name)) 
[13:22:56.904]                             next
[13:22:56.904]                           invokeRestart(restart)
[13:22:56.904]                           muffled <- TRUE
[13:22:56.904]                           break
[13:22:56.904]                         }
[13:22:56.904]                       }
[13:22:56.904]                     }
[13:22:56.904]                     invisible(muffled)
[13:22:56.904]                   }
[13:22:56.904]                   muffleCondition(cond)
[13:22:56.904]                 })
[13:22:56.904]             }))
[13:22:56.904]             future::FutureResult(value = ...future.value$value, 
[13:22:56.904]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:56.904]                   ...future.rng), globalenv = if (FALSE) 
[13:22:56.904]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:56.904]                     ...future.globalenv.names))
[13:22:56.904]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:56.904]         }, condition = base::local({
[13:22:56.904]             c <- base::c
[13:22:56.904]             inherits <- base::inherits
[13:22:56.904]             invokeRestart <- base::invokeRestart
[13:22:56.904]             length <- base::length
[13:22:56.904]             list <- base::list
[13:22:56.904]             seq.int <- base::seq.int
[13:22:56.904]             signalCondition <- base::signalCondition
[13:22:56.904]             sys.calls <- base::sys.calls
[13:22:56.904]             `[[` <- base::`[[`
[13:22:56.904]             `+` <- base::`+`
[13:22:56.904]             `<<-` <- base::`<<-`
[13:22:56.904]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:56.904]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:56.904]                   3L)]
[13:22:56.904]             }
[13:22:56.904]             function(cond) {
[13:22:56.904]                 is_error <- inherits(cond, "error")
[13:22:56.904]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:56.904]                   NULL)
[13:22:56.904]                 if (is_error) {
[13:22:56.904]                   sessionInformation <- function() {
[13:22:56.904]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:56.904]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:56.904]                       search = base::search(), system = base::Sys.info())
[13:22:56.904]                   }
[13:22:56.904]                   ...future.conditions[[length(...future.conditions) + 
[13:22:56.904]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:56.904]                     cond$call), session = sessionInformation(), 
[13:22:56.904]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:56.904]                   signalCondition(cond)
[13:22:56.904]                 }
[13:22:56.904]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:56.904]                 "immediateCondition"))) {
[13:22:56.904]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:56.904]                   ...future.conditions[[length(...future.conditions) + 
[13:22:56.904]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:56.904]                   if (TRUE && !signal) {
[13:22:56.904]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:56.904]                     {
[13:22:56.904]                       inherits <- base::inherits
[13:22:56.904]                       invokeRestart <- base::invokeRestart
[13:22:56.904]                       is.null <- base::is.null
[13:22:56.904]                       muffled <- FALSE
[13:22:56.904]                       if (inherits(cond, "message")) {
[13:22:56.904]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:56.904]                         if (muffled) 
[13:22:56.904]                           invokeRestart("muffleMessage")
[13:22:56.904]                       }
[13:22:56.904]                       else if (inherits(cond, "warning")) {
[13:22:56.904]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:56.904]                         if (muffled) 
[13:22:56.904]                           invokeRestart("muffleWarning")
[13:22:56.904]                       }
[13:22:56.904]                       else if (inherits(cond, "condition")) {
[13:22:56.904]                         if (!is.null(pattern)) {
[13:22:56.904]                           computeRestarts <- base::computeRestarts
[13:22:56.904]                           grepl <- base::grepl
[13:22:56.904]                           restarts <- computeRestarts(cond)
[13:22:56.904]                           for (restart in restarts) {
[13:22:56.904]                             name <- restart$name
[13:22:56.904]                             if (is.null(name)) 
[13:22:56.904]                               next
[13:22:56.904]                             if (!grepl(pattern, name)) 
[13:22:56.904]                               next
[13:22:56.904]                             invokeRestart(restart)
[13:22:56.904]                             muffled <- TRUE
[13:22:56.904]                             break
[13:22:56.904]                           }
[13:22:56.904]                         }
[13:22:56.904]                       }
[13:22:56.904]                       invisible(muffled)
[13:22:56.904]                     }
[13:22:56.904]                     muffleCondition(cond, pattern = "^muffle")
[13:22:56.904]                   }
[13:22:56.904]                 }
[13:22:56.904]                 else {
[13:22:56.904]                   if (TRUE) {
[13:22:56.904]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:56.904]                     {
[13:22:56.904]                       inherits <- base::inherits
[13:22:56.904]                       invokeRestart <- base::invokeRestart
[13:22:56.904]                       is.null <- base::is.null
[13:22:56.904]                       muffled <- FALSE
[13:22:56.904]                       if (inherits(cond, "message")) {
[13:22:56.904]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:56.904]                         if (muffled) 
[13:22:56.904]                           invokeRestart("muffleMessage")
[13:22:56.904]                       }
[13:22:56.904]                       else if (inherits(cond, "warning")) {
[13:22:56.904]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:56.904]                         if (muffled) 
[13:22:56.904]                           invokeRestart("muffleWarning")
[13:22:56.904]                       }
[13:22:56.904]                       else if (inherits(cond, "condition")) {
[13:22:56.904]                         if (!is.null(pattern)) {
[13:22:56.904]                           computeRestarts <- base::computeRestarts
[13:22:56.904]                           grepl <- base::grepl
[13:22:56.904]                           restarts <- computeRestarts(cond)
[13:22:56.904]                           for (restart in restarts) {
[13:22:56.904]                             name <- restart$name
[13:22:56.904]                             if (is.null(name)) 
[13:22:56.904]                               next
[13:22:56.904]                             if (!grepl(pattern, name)) 
[13:22:56.904]                               next
[13:22:56.904]                             invokeRestart(restart)
[13:22:56.904]                             muffled <- TRUE
[13:22:56.904]                             break
[13:22:56.904]                           }
[13:22:56.904]                         }
[13:22:56.904]                       }
[13:22:56.904]                       invisible(muffled)
[13:22:56.904]                     }
[13:22:56.904]                     muffleCondition(cond, pattern = "^muffle")
[13:22:56.904]                   }
[13:22:56.904]                 }
[13:22:56.904]             }
[13:22:56.904]         }))
[13:22:56.904]     }, error = function(ex) {
[13:22:56.904]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:56.904]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:56.904]                 ...future.rng), started = ...future.startTime, 
[13:22:56.904]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:56.904]             version = "1.8"), class = "FutureResult")
[13:22:56.904]     }, finally = {
[13:22:56.904]         if (!identical(...future.workdir, getwd())) 
[13:22:56.904]             setwd(...future.workdir)
[13:22:56.904]         {
[13:22:56.904]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:56.904]                 ...future.oldOptions$nwarnings <- NULL
[13:22:56.904]             }
[13:22:56.904]             base::options(...future.oldOptions)
[13:22:56.904]             if (.Platform$OS.type == "windows") {
[13:22:56.904]                 old_names <- names(...future.oldEnvVars)
[13:22:56.904]                 envs <- base::Sys.getenv()
[13:22:56.904]                 names <- names(envs)
[13:22:56.904]                 common <- intersect(names, old_names)
[13:22:56.904]                 added <- setdiff(names, old_names)
[13:22:56.904]                 removed <- setdiff(old_names, names)
[13:22:56.904]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:56.904]                   envs[common]]
[13:22:56.904]                 NAMES <- toupper(changed)
[13:22:56.904]                 args <- list()
[13:22:56.904]                 for (kk in seq_along(NAMES)) {
[13:22:56.904]                   name <- changed[[kk]]
[13:22:56.904]                   NAME <- NAMES[[kk]]
[13:22:56.904]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:56.904]                     next
[13:22:56.904]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:56.904]                 }
[13:22:56.904]                 NAMES <- toupper(added)
[13:22:56.904]                 for (kk in seq_along(NAMES)) {
[13:22:56.904]                   name <- added[[kk]]
[13:22:56.904]                   NAME <- NAMES[[kk]]
[13:22:56.904]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:56.904]                     next
[13:22:56.904]                   args[[name]] <- ""
[13:22:56.904]                 }
[13:22:56.904]                 NAMES <- toupper(removed)
[13:22:56.904]                 for (kk in seq_along(NAMES)) {
[13:22:56.904]                   name <- removed[[kk]]
[13:22:56.904]                   NAME <- NAMES[[kk]]
[13:22:56.904]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:56.904]                     next
[13:22:56.904]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:56.904]                 }
[13:22:56.904]                 if (length(args) > 0) 
[13:22:56.904]                   base::do.call(base::Sys.setenv, args = args)
[13:22:56.904]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:56.904]             }
[13:22:56.904]             else {
[13:22:56.904]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:56.904]             }
[13:22:56.904]             {
[13:22:56.904]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:56.904]                   0L) {
[13:22:56.904]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:56.904]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:56.904]                   base::options(opts)
[13:22:56.904]                 }
[13:22:56.904]                 {
[13:22:56.904]                   {
[13:22:56.904]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:56.904]                     NULL
[13:22:56.904]                   }
[13:22:56.904]                   options(future.plan = NULL)
[13:22:56.904]                   if (is.na(NA_character_)) 
[13:22:56.904]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:56.904]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:56.904]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:56.904]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:56.904]                     envir = parent.frame()) 
[13:22:56.904]                   {
[13:22:56.904]                     if (is.function(workers)) 
[13:22:56.904]                       workers <- workers()
[13:22:56.904]                     workers <- structure(as.integer(workers), 
[13:22:56.904]                       class = class(workers))
[13:22:56.904]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:56.904]                       workers >= 1)
[13:22:56.904]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:56.904]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:56.904]                     }
[13:22:56.904]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:56.904]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:56.904]                       envir = envir)
[13:22:56.904]                     if (!future$lazy) 
[13:22:56.904]                       future <- run(future)
[13:22:56.904]                     invisible(future)
[13:22:56.904]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:56.904]                 }
[13:22:56.904]             }
[13:22:56.904]         }
[13:22:56.904]     })
[13:22:56.904]     if (TRUE) {
[13:22:56.904]         base::sink(type = "output", split = FALSE)
[13:22:56.904]         if (TRUE) {
[13:22:56.904]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:56.904]         }
[13:22:56.904]         else {
[13:22:56.904]             ...future.result["stdout"] <- base::list(NULL)
[13:22:56.904]         }
[13:22:56.904]         base::close(...future.stdout)
[13:22:56.904]         ...future.stdout <- NULL
[13:22:56.904]     }
[13:22:56.904]     ...future.result$conditions <- ...future.conditions
[13:22:56.904]     ...future.result$finished <- base::Sys.time()
[13:22:56.904]     ...future.result
[13:22:56.904] }
[13:22:56.907] MultisessionFuture started
[13:22:56.907] - Launch lazy future ... done
[13:22:56.907] run() for ‘MultisessionFuture’ ... done
[13:22:56.907] result() for ClusterFuture ...
[13:22:56.908] receiveMessageFromWorker() for ClusterFuture ...
[13:22:56.908] - Validating connection of MultisessionFuture
[13:22:56.953] - received message: FutureResult
[13:22:56.954] - Received FutureResult
[13:22:56.954] - Erased future from FutureRegistry
[13:22:56.954] result() for ClusterFuture ...
[13:22:56.954] - result already collected: FutureResult
[13:22:56.954] result() for ClusterFuture ... done
[13:22:56.954] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:56.954] result() for ClusterFuture ... done
[13:22:56.954] result() for ClusterFuture ...
[13:22:56.954] - result already collected: FutureResult
[13:22:56.954] result() for ClusterFuture ... done
c = 1
[13:22:56.955] getGlobalsAndPackages() ...
[13:22:56.955] Searching for globals...
[13:22:56.955] 
[13:22:56.955] Searching for globals ... DONE
[13:22:56.956] - globals: [0] <none>
[13:22:56.956] getGlobalsAndPackages() ... DONE
[13:22:56.956] run() for ‘Future’ ...
[13:22:56.956] - state: ‘created’
[13:22:56.956] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:56.971] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:56.971] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:56.971]   - Field: ‘node’
[13:22:56.971]   - Field: ‘label’
[13:22:56.971]   - Field: ‘local’
[13:22:56.971]   - Field: ‘owner’
[13:22:56.971]   - Field: ‘envir’
[13:22:56.971]   - Field: ‘workers’
[13:22:56.972]   - Field: ‘packages’
[13:22:56.972]   - Field: ‘gc’
[13:22:56.972]   - Field: ‘conditions’
[13:22:56.972]   - Field: ‘persistent’
[13:22:56.972]   - Field: ‘expr’
[13:22:56.972]   - Field: ‘uuid’
[13:22:56.972]   - Field: ‘seed’
[13:22:56.972]   - Field: ‘version’
[13:22:56.972]   - Field: ‘result’
[13:22:56.972]   - Field: ‘asynchronous’
[13:22:56.973]   - Field: ‘calls’
[13:22:56.973]   - Field: ‘globals’
[13:22:56.973]   - Field: ‘stdout’
[13:22:56.973]   - Field: ‘earlySignal’
[13:22:56.973]   - Field: ‘lazy’
[13:22:56.973]   - Field: ‘state’
[13:22:56.973] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:56.973] - Launch lazy future ...
[13:22:56.973] Packages needed by the future expression (n = 0): <none>
[13:22:56.974] Packages needed by future strategies (n = 0): <none>
[13:22:56.974] {
[13:22:56.974]     {
[13:22:56.974]         {
[13:22:56.974]             ...future.startTime <- base::Sys.time()
[13:22:56.974]             {
[13:22:56.974]                 {
[13:22:56.974]                   {
[13:22:56.974]                     {
[13:22:56.974]                       base::local({
[13:22:56.974]                         has_future <- base::requireNamespace("future", 
[13:22:56.974]                           quietly = TRUE)
[13:22:56.974]                         if (has_future) {
[13:22:56.974]                           ns <- base::getNamespace("future")
[13:22:56.974]                           version <- ns[[".package"]][["version"]]
[13:22:56.974]                           if (is.null(version)) 
[13:22:56.974]                             version <- utils::packageVersion("future")
[13:22:56.974]                         }
[13:22:56.974]                         else {
[13:22:56.974]                           version <- NULL
[13:22:56.974]                         }
[13:22:56.974]                         if (!has_future || version < "1.8.0") {
[13:22:56.974]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:56.974]                             "", base::R.version$version.string), 
[13:22:56.974]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:56.974]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:56.974]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:56.974]                               "release", "version")], collapse = " "), 
[13:22:56.974]                             hostname = base::Sys.info()[["nodename"]])
[13:22:56.974]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:56.974]                             info)
[13:22:56.974]                           info <- base::paste(info, collapse = "; ")
[13:22:56.974]                           if (!has_future) {
[13:22:56.974]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:56.974]                               info)
[13:22:56.974]                           }
[13:22:56.974]                           else {
[13:22:56.974]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:56.974]                               info, version)
[13:22:56.974]                           }
[13:22:56.974]                           base::stop(msg)
[13:22:56.974]                         }
[13:22:56.974]                       })
[13:22:56.974]                     }
[13:22:56.974]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:56.974]                     base::options(mc.cores = 1L)
[13:22:56.974]                   }
[13:22:56.974]                   options(future.plan = NULL)
[13:22:56.974]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:56.974]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:56.974]                 }
[13:22:56.974]                 ...future.workdir <- getwd()
[13:22:56.974]             }
[13:22:56.974]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:56.974]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:56.974]         }
[13:22:56.974]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:56.974]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:56.974]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:56.974]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:56.974]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:56.974]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:56.974]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:56.974]             base::names(...future.oldOptions))
[13:22:56.974]     }
[13:22:56.974]     if (FALSE) {
[13:22:56.974]     }
[13:22:56.974]     else {
[13:22:56.974]         if (TRUE) {
[13:22:56.974]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:56.974]                 open = "w")
[13:22:56.974]         }
[13:22:56.974]         else {
[13:22:56.974]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:56.974]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:56.974]         }
[13:22:56.974]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:56.974]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:56.974]             base::sink(type = "output", split = FALSE)
[13:22:56.974]             base::close(...future.stdout)
[13:22:56.974]         }, add = TRUE)
[13:22:56.974]     }
[13:22:56.974]     ...future.frame <- base::sys.nframe()
[13:22:56.974]     ...future.conditions <- base::list()
[13:22:56.974]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:56.974]     if (FALSE) {
[13:22:56.974]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:56.974]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:56.974]     }
[13:22:56.974]     ...future.result <- base::tryCatch({
[13:22:56.974]         base::withCallingHandlers({
[13:22:56.974]             ...future.value <- base::withVisible(base::local({
[13:22:56.974]                 ...future.makeSendCondition <- base::local({
[13:22:56.974]                   sendCondition <- NULL
[13:22:56.974]                   function(frame = 1L) {
[13:22:56.974]                     if (is.function(sendCondition)) 
[13:22:56.974]                       return(sendCondition)
[13:22:56.974]                     ns <- getNamespace("parallel")
[13:22:56.974]                     if (exists("sendData", mode = "function", 
[13:22:56.974]                       envir = ns)) {
[13:22:56.974]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:56.974]                         envir = ns)
[13:22:56.974]                       envir <- sys.frame(frame)
[13:22:56.974]                       master <- NULL
[13:22:56.974]                       while (!identical(envir, .GlobalEnv) && 
[13:22:56.974]                         !identical(envir, emptyenv())) {
[13:22:56.974]                         if (exists("master", mode = "list", envir = envir, 
[13:22:56.974]                           inherits = FALSE)) {
[13:22:56.974]                           master <- get("master", mode = "list", 
[13:22:56.974]                             envir = envir, inherits = FALSE)
[13:22:56.974]                           if (inherits(master, c("SOCKnode", 
[13:22:56.974]                             "SOCK0node"))) {
[13:22:56.974]                             sendCondition <<- function(cond) {
[13:22:56.974]                               data <- list(type = "VALUE", value = cond, 
[13:22:56.974]                                 success = TRUE)
[13:22:56.974]                               parallel_sendData(master, data)
[13:22:56.974]                             }
[13:22:56.974]                             return(sendCondition)
[13:22:56.974]                           }
[13:22:56.974]                         }
[13:22:56.974]                         frame <- frame + 1L
[13:22:56.974]                         envir <- sys.frame(frame)
[13:22:56.974]                       }
[13:22:56.974]                     }
[13:22:56.974]                     sendCondition <<- function(cond) NULL
[13:22:56.974]                   }
[13:22:56.974]                 })
[13:22:56.974]                 withCallingHandlers({
[13:22:56.974]                   1
[13:22:56.974]                 }, immediateCondition = function(cond) {
[13:22:56.974]                   sendCondition <- ...future.makeSendCondition()
[13:22:56.974]                   sendCondition(cond)
[13:22:56.974]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:56.974]                   {
[13:22:56.974]                     inherits <- base::inherits
[13:22:56.974]                     invokeRestart <- base::invokeRestart
[13:22:56.974]                     is.null <- base::is.null
[13:22:56.974]                     muffled <- FALSE
[13:22:56.974]                     if (inherits(cond, "message")) {
[13:22:56.974]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:56.974]                       if (muffled) 
[13:22:56.974]                         invokeRestart("muffleMessage")
[13:22:56.974]                     }
[13:22:56.974]                     else if (inherits(cond, "warning")) {
[13:22:56.974]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:56.974]                       if (muffled) 
[13:22:56.974]                         invokeRestart("muffleWarning")
[13:22:56.974]                     }
[13:22:56.974]                     else if (inherits(cond, "condition")) {
[13:22:56.974]                       if (!is.null(pattern)) {
[13:22:56.974]                         computeRestarts <- base::computeRestarts
[13:22:56.974]                         grepl <- base::grepl
[13:22:56.974]                         restarts <- computeRestarts(cond)
[13:22:56.974]                         for (restart in restarts) {
[13:22:56.974]                           name <- restart$name
[13:22:56.974]                           if (is.null(name)) 
[13:22:56.974]                             next
[13:22:56.974]                           if (!grepl(pattern, name)) 
[13:22:56.974]                             next
[13:22:56.974]                           invokeRestart(restart)
[13:22:56.974]                           muffled <- TRUE
[13:22:56.974]                           break
[13:22:56.974]                         }
[13:22:56.974]                       }
[13:22:56.974]                     }
[13:22:56.974]                     invisible(muffled)
[13:22:56.974]                   }
[13:22:56.974]                   muffleCondition(cond)
[13:22:56.974]                 })
[13:22:56.974]             }))
[13:22:56.974]             future::FutureResult(value = ...future.value$value, 
[13:22:56.974]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:56.974]                   ...future.rng), globalenv = if (FALSE) 
[13:22:56.974]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:56.974]                     ...future.globalenv.names))
[13:22:56.974]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:56.974]         }, condition = base::local({
[13:22:56.974]             c <- base::c
[13:22:56.974]             inherits <- base::inherits
[13:22:56.974]             invokeRestart <- base::invokeRestart
[13:22:56.974]             length <- base::length
[13:22:56.974]             list <- base::list
[13:22:56.974]             seq.int <- base::seq.int
[13:22:56.974]             signalCondition <- base::signalCondition
[13:22:56.974]             sys.calls <- base::sys.calls
[13:22:56.974]             `[[` <- base::`[[`
[13:22:56.974]             `+` <- base::`+`
[13:22:56.974]             `<<-` <- base::`<<-`
[13:22:56.974]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:56.974]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:56.974]                   3L)]
[13:22:56.974]             }
[13:22:56.974]             function(cond) {
[13:22:56.974]                 is_error <- inherits(cond, "error")
[13:22:56.974]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:56.974]                   NULL)
[13:22:56.974]                 if (is_error) {
[13:22:56.974]                   sessionInformation <- function() {
[13:22:56.974]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:56.974]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:56.974]                       search = base::search(), system = base::Sys.info())
[13:22:56.974]                   }
[13:22:56.974]                   ...future.conditions[[length(...future.conditions) + 
[13:22:56.974]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:56.974]                     cond$call), session = sessionInformation(), 
[13:22:56.974]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:56.974]                   signalCondition(cond)
[13:22:56.974]                 }
[13:22:56.974]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:56.974]                 "immediateCondition"))) {
[13:22:56.974]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:56.974]                   ...future.conditions[[length(...future.conditions) + 
[13:22:56.974]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:56.974]                   if (TRUE && !signal) {
[13:22:56.974]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:56.974]                     {
[13:22:56.974]                       inherits <- base::inherits
[13:22:56.974]                       invokeRestart <- base::invokeRestart
[13:22:56.974]                       is.null <- base::is.null
[13:22:56.974]                       muffled <- FALSE
[13:22:56.974]                       if (inherits(cond, "message")) {
[13:22:56.974]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:56.974]                         if (muffled) 
[13:22:56.974]                           invokeRestart("muffleMessage")
[13:22:56.974]                       }
[13:22:56.974]                       else if (inherits(cond, "warning")) {
[13:22:56.974]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:56.974]                         if (muffled) 
[13:22:56.974]                           invokeRestart("muffleWarning")
[13:22:56.974]                       }
[13:22:56.974]                       else if (inherits(cond, "condition")) {
[13:22:56.974]                         if (!is.null(pattern)) {
[13:22:56.974]                           computeRestarts <- base::computeRestarts
[13:22:56.974]                           grepl <- base::grepl
[13:22:56.974]                           restarts <- computeRestarts(cond)
[13:22:56.974]                           for (restart in restarts) {
[13:22:56.974]                             name <- restart$name
[13:22:56.974]                             if (is.null(name)) 
[13:22:56.974]                               next
[13:22:56.974]                             if (!grepl(pattern, name)) 
[13:22:56.974]                               next
[13:22:56.974]                             invokeRestart(restart)
[13:22:56.974]                             muffled <- TRUE
[13:22:56.974]                             break
[13:22:56.974]                           }
[13:22:56.974]                         }
[13:22:56.974]                       }
[13:22:56.974]                       invisible(muffled)
[13:22:56.974]                     }
[13:22:56.974]                     muffleCondition(cond, pattern = "^muffle")
[13:22:56.974]                   }
[13:22:56.974]                 }
[13:22:56.974]                 else {
[13:22:56.974]                   if (TRUE) {
[13:22:56.974]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:56.974]                     {
[13:22:56.974]                       inherits <- base::inherits
[13:22:56.974]                       invokeRestart <- base::invokeRestart
[13:22:56.974]                       is.null <- base::is.null
[13:22:56.974]                       muffled <- FALSE
[13:22:56.974]                       if (inherits(cond, "message")) {
[13:22:56.974]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:56.974]                         if (muffled) 
[13:22:56.974]                           invokeRestart("muffleMessage")
[13:22:56.974]                       }
[13:22:56.974]                       else if (inherits(cond, "warning")) {
[13:22:56.974]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:56.974]                         if (muffled) 
[13:22:56.974]                           invokeRestart("muffleWarning")
[13:22:56.974]                       }
[13:22:56.974]                       else if (inherits(cond, "condition")) {
[13:22:56.974]                         if (!is.null(pattern)) {
[13:22:56.974]                           computeRestarts <- base::computeRestarts
[13:22:56.974]                           grepl <- base::grepl
[13:22:56.974]                           restarts <- computeRestarts(cond)
[13:22:56.974]                           for (restart in restarts) {
[13:22:56.974]                             name <- restart$name
[13:22:56.974]                             if (is.null(name)) 
[13:22:56.974]                               next
[13:22:56.974]                             if (!grepl(pattern, name)) 
[13:22:56.974]                               next
[13:22:56.974]                             invokeRestart(restart)
[13:22:56.974]                             muffled <- TRUE
[13:22:56.974]                             break
[13:22:56.974]                           }
[13:22:56.974]                         }
[13:22:56.974]                       }
[13:22:56.974]                       invisible(muffled)
[13:22:56.974]                     }
[13:22:56.974]                     muffleCondition(cond, pattern = "^muffle")
[13:22:56.974]                   }
[13:22:56.974]                 }
[13:22:56.974]             }
[13:22:56.974]         }))
[13:22:56.974]     }, error = function(ex) {
[13:22:56.974]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:56.974]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:56.974]                 ...future.rng), started = ...future.startTime, 
[13:22:56.974]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:56.974]             version = "1.8"), class = "FutureResult")
[13:22:56.974]     }, finally = {
[13:22:56.974]         if (!identical(...future.workdir, getwd())) 
[13:22:56.974]             setwd(...future.workdir)
[13:22:56.974]         {
[13:22:56.974]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:56.974]                 ...future.oldOptions$nwarnings <- NULL
[13:22:56.974]             }
[13:22:56.974]             base::options(...future.oldOptions)
[13:22:56.974]             if (.Platform$OS.type == "windows") {
[13:22:56.974]                 old_names <- names(...future.oldEnvVars)
[13:22:56.974]                 envs <- base::Sys.getenv()
[13:22:56.974]                 names <- names(envs)
[13:22:56.974]                 common <- intersect(names, old_names)
[13:22:56.974]                 added <- setdiff(names, old_names)
[13:22:56.974]                 removed <- setdiff(old_names, names)
[13:22:56.974]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:56.974]                   envs[common]]
[13:22:56.974]                 NAMES <- toupper(changed)
[13:22:56.974]                 args <- list()
[13:22:56.974]                 for (kk in seq_along(NAMES)) {
[13:22:56.974]                   name <- changed[[kk]]
[13:22:56.974]                   NAME <- NAMES[[kk]]
[13:22:56.974]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:56.974]                     next
[13:22:56.974]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:56.974]                 }
[13:22:56.974]                 NAMES <- toupper(added)
[13:22:56.974]                 for (kk in seq_along(NAMES)) {
[13:22:56.974]                   name <- added[[kk]]
[13:22:56.974]                   NAME <- NAMES[[kk]]
[13:22:56.974]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:56.974]                     next
[13:22:56.974]                   args[[name]] <- ""
[13:22:56.974]                 }
[13:22:56.974]                 NAMES <- toupper(removed)
[13:22:56.974]                 for (kk in seq_along(NAMES)) {
[13:22:56.974]                   name <- removed[[kk]]
[13:22:56.974]                   NAME <- NAMES[[kk]]
[13:22:56.974]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:56.974]                     next
[13:22:56.974]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:56.974]                 }
[13:22:56.974]                 if (length(args) > 0) 
[13:22:56.974]                   base::do.call(base::Sys.setenv, args = args)
[13:22:56.974]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:56.974]             }
[13:22:56.974]             else {
[13:22:56.974]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:56.974]             }
[13:22:56.974]             {
[13:22:56.974]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:56.974]                   0L) {
[13:22:56.974]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:56.974]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:56.974]                   base::options(opts)
[13:22:56.974]                 }
[13:22:56.974]                 {
[13:22:56.974]                   {
[13:22:56.974]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:56.974]                     NULL
[13:22:56.974]                   }
[13:22:56.974]                   options(future.plan = NULL)
[13:22:56.974]                   if (is.na(NA_character_)) 
[13:22:56.974]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:56.974]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:56.974]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:56.974]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:56.974]                     envir = parent.frame()) 
[13:22:56.974]                   {
[13:22:56.974]                     if (is.function(workers)) 
[13:22:56.974]                       workers <- workers()
[13:22:56.974]                     workers <- structure(as.integer(workers), 
[13:22:56.974]                       class = class(workers))
[13:22:56.974]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:56.974]                       workers >= 1)
[13:22:56.974]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:56.974]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:56.974]                     }
[13:22:56.974]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:56.974]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:56.974]                       envir = envir)
[13:22:56.974]                     if (!future$lazy) 
[13:22:56.974]                       future <- run(future)
[13:22:56.974]                     invisible(future)
[13:22:56.974]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:56.974]                 }
[13:22:56.974]             }
[13:22:56.974]         }
[13:22:56.974]     })
[13:22:56.974]     if (TRUE) {
[13:22:56.974]         base::sink(type = "output", split = FALSE)
[13:22:56.974]         if (TRUE) {
[13:22:56.974]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:56.974]         }
[13:22:56.974]         else {
[13:22:56.974]             ...future.result["stdout"] <- base::list(NULL)
[13:22:56.974]         }
[13:22:56.974]         base::close(...future.stdout)
[13:22:56.974]         ...future.stdout <- NULL
[13:22:56.974]     }
[13:22:56.974]     ...future.result$conditions <- ...future.conditions
[13:22:56.974]     ...future.result$finished <- base::Sys.time()
[13:22:56.974]     ...future.result
[13:22:56.974] }
[13:22:56.977] MultisessionFuture started
[13:22:56.978] - Launch lazy future ... done
[13:22:56.978] run() for ‘MultisessionFuture’ ... done
[13:22:56.978] result() for ClusterFuture ...
[13:22:56.978] receiveMessageFromWorker() for ClusterFuture ...
[13:22:56.978] - Validating connection of MultisessionFuture
[13:22:57.025] - received message: FutureResult
[13:22:57.026] - Received FutureResult
[13:22:57.026] - Erased future from FutureRegistry
[13:22:57.026] result() for ClusterFuture ...
[13:22:57.026] - result already collected: FutureResult
[13:22:57.026] result() for ClusterFuture ... done
[13:22:57.026] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:57.026] result() for ClusterFuture ... done
[13:22:57.026] result() for ClusterFuture ...
[13:22:57.026] - result already collected: FutureResult
[13:22:57.026] result() for ClusterFuture ... done
d = 1
** Nested future assignments
[13:22:57.027] getGlobalsAndPackages() ...
[13:22:57.027] Searching for globals...
[13:22:57.031] - globals found: [5] ‘{’, ‘<-’, ‘%<-%’, ‘%->%’, ‘+’
[13:22:57.031] Searching for globals ... DONE
[13:22:57.031] Resolving globals: FALSE
[13:22:57.032] 
[13:22:57.032] - packages: [1] ‘future’
[13:22:57.032] getGlobalsAndPackages() ... DONE
[13:22:57.032] run() for ‘Future’ ...
[13:22:57.032] - state: ‘created’
[13:22:57.032] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:57.048] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:57.049] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:57.049]   - Field: ‘node’
[13:22:57.049]   - Field: ‘label’
[13:22:57.049]   - Field: ‘local’
[13:22:57.049]   - Field: ‘owner’
[13:22:57.049]   - Field: ‘envir’
[13:22:57.049]   - Field: ‘workers’
[13:22:57.049]   - Field: ‘packages’
[13:22:57.050]   - Field: ‘gc’
[13:22:57.050]   - Field: ‘conditions’
[13:22:57.050]   - Field: ‘persistent’
[13:22:57.050]   - Field: ‘expr’
[13:22:57.050]   - Field: ‘uuid’
[13:22:57.050]   - Field: ‘seed’
[13:22:57.050]   - Field: ‘version’
[13:22:57.050]   - Field: ‘result’
[13:22:57.050]   - Field: ‘asynchronous’
[13:22:57.050]   - Field: ‘calls’
[13:22:57.051]   - Field: ‘globals’
[13:22:57.051]   - Field: ‘stdout’
[13:22:57.051]   - Field: ‘earlySignal’
[13:22:57.051]   - Field: ‘lazy’
[13:22:57.051]   - Field: ‘state’
[13:22:57.051] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:57.051] - Launch lazy future ...
[13:22:57.051] Packages needed by the future expression (n = 1): ‘future’
[13:22:57.052] Packages needed by future strategies (n = 0): <none>
[13:22:57.052] {
[13:22:57.052]     {
[13:22:57.052]         {
[13:22:57.052]             ...future.startTime <- base::Sys.time()
[13:22:57.052]             {
[13:22:57.052]                 {
[13:22:57.052]                   {
[13:22:57.052]                     {
[13:22:57.052]                       {
[13:22:57.052]                         base::local({
[13:22:57.052]                           has_future <- base::requireNamespace("future", 
[13:22:57.052]                             quietly = TRUE)
[13:22:57.052]                           if (has_future) {
[13:22:57.052]                             ns <- base::getNamespace("future")
[13:22:57.052]                             version <- ns[[".package"]][["version"]]
[13:22:57.052]                             if (is.null(version)) 
[13:22:57.052]                               version <- utils::packageVersion("future")
[13:22:57.052]                           }
[13:22:57.052]                           else {
[13:22:57.052]                             version <- NULL
[13:22:57.052]                           }
[13:22:57.052]                           if (!has_future || version < "1.8.0") {
[13:22:57.052]                             info <- base::c(r_version = base::gsub("R version ", 
[13:22:57.052]                               "", base::R.version$version.string), 
[13:22:57.052]                               platform = base::sprintf("%s (%s-bit)", 
[13:22:57.052]                                 base::R.version$platform, 8 * 
[13:22:57.052]                                   base::.Machine$sizeof.pointer), 
[13:22:57.052]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:57.052]                                 "release", "version")], collapse = " "), 
[13:22:57.052]                               hostname = base::Sys.info()[["nodename"]])
[13:22:57.052]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:22:57.052]                               info)
[13:22:57.052]                             info <- base::paste(info, collapse = "; ")
[13:22:57.052]                             if (!has_future) {
[13:22:57.052]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:57.052]                                 info)
[13:22:57.052]                             }
[13:22:57.052]                             else {
[13:22:57.052]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:57.052]                                 info, version)
[13:22:57.052]                             }
[13:22:57.052]                             base::stop(msg)
[13:22:57.052]                           }
[13:22:57.052]                         })
[13:22:57.052]                       }
[13:22:57.052]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:57.052]                       base::options(mc.cores = 1L)
[13:22:57.052]                     }
[13:22:57.052]                     base::local({
[13:22:57.052]                       for (pkg in "future") {
[13:22:57.052]                         base::loadNamespace(pkg)
[13:22:57.052]                         base::library(pkg, character.only = TRUE)
[13:22:57.052]                       }
[13:22:57.052]                     })
[13:22:57.052]                   }
[13:22:57.052]                   options(future.plan = NULL)
[13:22:57.052]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:57.052]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:57.052]                 }
[13:22:57.052]                 ...future.workdir <- getwd()
[13:22:57.052]             }
[13:22:57.052]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:57.052]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:57.052]         }
[13:22:57.052]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:57.052]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:57.052]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:57.052]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:57.052]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:57.052]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:57.052]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:57.052]             base::names(...future.oldOptions))
[13:22:57.052]     }
[13:22:57.052]     if (FALSE) {
[13:22:57.052]     }
[13:22:57.052]     else {
[13:22:57.052]         if (TRUE) {
[13:22:57.052]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:57.052]                 open = "w")
[13:22:57.052]         }
[13:22:57.052]         else {
[13:22:57.052]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:57.052]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:57.052]         }
[13:22:57.052]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:57.052]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:57.052]             base::sink(type = "output", split = FALSE)
[13:22:57.052]             base::close(...future.stdout)
[13:22:57.052]         }, add = TRUE)
[13:22:57.052]     }
[13:22:57.052]     ...future.frame <- base::sys.nframe()
[13:22:57.052]     ...future.conditions <- base::list()
[13:22:57.052]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:57.052]     if (FALSE) {
[13:22:57.052]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:57.052]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:57.052]     }
[13:22:57.052]     ...future.result <- base::tryCatch({
[13:22:57.052]         base::withCallingHandlers({
[13:22:57.052]             ...future.value <- base::withVisible(base::local({
[13:22:57.052]                 ...future.makeSendCondition <- base::local({
[13:22:57.052]                   sendCondition <- NULL
[13:22:57.052]                   function(frame = 1L) {
[13:22:57.052]                     if (is.function(sendCondition)) 
[13:22:57.052]                       return(sendCondition)
[13:22:57.052]                     ns <- getNamespace("parallel")
[13:22:57.052]                     if (exists("sendData", mode = "function", 
[13:22:57.052]                       envir = ns)) {
[13:22:57.052]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:57.052]                         envir = ns)
[13:22:57.052]                       envir <- sys.frame(frame)
[13:22:57.052]                       master <- NULL
[13:22:57.052]                       while (!identical(envir, .GlobalEnv) && 
[13:22:57.052]                         !identical(envir, emptyenv())) {
[13:22:57.052]                         if (exists("master", mode = "list", envir = envir, 
[13:22:57.052]                           inherits = FALSE)) {
[13:22:57.052]                           master <- get("master", mode = "list", 
[13:22:57.052]                             envir = envir, inherits = FALSE)
[13:22:57.052]                           if (inherits(master, c("SOCKnode", 
[13:22:57.052]                             "SOCK0node"))) {
[13:22:57.052]                             sendCondition <<- function(cond) {
[13:22:57.052]                               data <- list(type = "VALUE", value = cond, 
[13:22:57.052]                                 success = TRUE)
[13:22:57.052]                               parallel_sendData(master, data)
[13:22:57.052]                             }
[13:22:57.052]                             return(sendCondition)
[13:22:57.052]                           }
[13:22:57.052]                         }
[13:22:57.052]                         frame <- frame + 1L
[13:22:57.052]                         envir <- sys.frame(frame)
[13:22:57.052]                       }
[13:22:57.052]                     }
[13:22:57.052]                     sendCondition <<- function(cond) NULL
[13:22:57.052]                   }
[13:22:57.052]                 })
[13:22:57.052]                 withCallingHandlers({
[13:22:57.052]                   {
[13:22:57.052]                     b <- 1
[13:22:57.052]                     c %<-% 2
[13:22:57.052]                     d <- 3
[13:22:57.052]                     4 %->% e
[13:22:57.052]                     b + c + d + e
[13:22:57.052]                   }
[13:22:57.052]                 }, immediateCondition = function(cond) {
[13:22:57.052]                   sendCondition <- ...future.makeSendCondition()
[13:22:57.052]                   sendCondition(cond)
[13:22:57.052]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.052]                   {
[13:22:57.052]                     inherits <- base::inherits
[13:22:57.052]                     invokeRestart <- base::invokeRestart
[13:22:57.052]                     is.null <- base::is.null
[13:22:57.052]                     muffled <- FALSE
[13:22:57.052]                     if (inherits(cond, "message")) {
[13:22:57.052]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:57.052]                       if (muffled) 
[13:22:57.052]                         invokeRestart("muffleMessage")
[13:22:57.052]                     }
[13:22:57.052]                     else if (inherits(cond, "warning")) {
[13:22:57.052]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:57.052]                       if (muffled) 
[13:22:57.052]                         invokeRestart("muffleWarning")
[13:22:57.052]                     }
[13:22:57.052]                     else if (inherits(cond, "condition")) {
[13:22:57.052]                       if (!is.null(pattern)) {
[13:22:57.052]                         computeRestarts <- base::computeRestarts
[13:22:57.052]                         grepl <- base::grepl
[13:22:57.052]                         restarts <- computeRestarts(cond)
[13:22:57.052]                         for (restart in restarts) {
[13:22:57.052]                           name <- restart$name
[13:22:57.052]                           if (is.null(name)) 
[13:22:57.052]                             next
[13:22:57.052]                           if (!grepl(pattern, name)) 
[13:22:57.052]                             next
[13:22:57.052]                           invokeRestart(restart)
[13:22:57.052]                           muffled <- TRUE
[13:22:57.052]                           break
[13:22:57.052]                         }
[13:22:57.052]                       }
[13:22:57.052]                     }
[13:22:57.052]                     invisible(muffled)
[13:22:57.052]                   }
[13:22:57.052]                   muffleCondition(cond)
[13:22:57.052]                 })
[13:22:57.052]             }))
[13:22:57.052]             future::FutureResult(value = ...future.value$value, 
[13:22:57.052]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:57.052]                   ...future.rng), globalenv = if (FALSE) 
[13:22:57.052]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:57.052]                     ...future.globalenv.names))
[13:22:57.052]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:57.052]         }, condition = base::local({
[13:22:57.052]             c <- base::c
[13:22:57.052]             inherits <- base::inherits
[13:22:57.052]             invokeRestart <- base::invokeRestart
[13:22:57.052]             length <- base::length
[13:22:57.052]             list <- base::list
[13:22:57.052]             seq.int <- base::seq.int
[13:22:57.052]             signalCondition <- base::signalCondition
[13:22:57.052]             sys.calls <- base::sys.calls
[13:22:57.052]             `[[` <- base::`[[`
[13:22:57.052]             `+` <- base::`+`
[13:22:57.052]             `<<-` <- base::`<<-`
[13:22:57.052]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:57.052]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:57.052]                   3L)]
[13:22:57.052]             }
[13:22:57.052]             function(cond) {
[13:22:57.052]                 is_error <- inherits(cond, "error")
[13:22:57.052]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:57.052]                   NULL)
[13:22:57.052]                 if (is_error) {
[13:22:57.052]                   sessionInformation <- function() {
[13:22:57.052]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:57.052]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:57.052]                       search = base::search(), system = base::Sys.info())
[13:22:57.052]                   }
[13:22:57.052]                   ...future.conditions[[length(...future.conditions) + 
[13:22:57.052]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:57.052]                     cond$call), session = sessionInformation(), 
[13:22:57.052]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:57.052]                   signalCondition(cond)
[13:22:57.052]                 }
[13:22:57.052]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:57.052]                 "immediateCondition"))) {
[13:22:57.052]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:57.052]                   ...future.conditions[[length(...future.conditions) + 
[13:22:57.052]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:57.052]                   if (TRUE && !signal) {
[13:22:57.052]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.052]                     {
[13:22:57.052]                       inherits <- base::inherits
[13:22:57.052]                       invokeRestart <- base::invokeRestart
[13:22:57.052]                       is.null <- base::is.null
[13:22:57.052]                       muffled <- FALSE
[13:22:57.052]                       if (inherits(cond, "message")) {
[13:22:57.052]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:57.052]                         if (muffled) 
[13:22:57.052]                           invokeRestart("muffleMessage")
[13:22:57.052]                       }
[13:22:57.052]                       else if (inherits(cond, "warning")) {
[13:22:57.052]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:57.052]                         if (muffled) 
[13:22:57.052]                           invokeRestart("muffleWarning")
[13:22:57.052]                       }
[13:22:57.052]                       else if (inherits(cond, "condition")) {
[13:22:57.052]                         if (!is.null(pattern)) {
[13:22:57.052]                           computeRestarts <- base::computeRestarts
[13:22:57.052]                           grepl <- base::grepl
[13:22:57.052]                           restarts <- computeRestarts(cond)
[13:22:57.052]                           for (restart in restarts) {
[13:22:57.052]                             name <- restart$name
[13:22:57.052]                             if (is.null(name)) 
[13:22:57.052]                               next
[13:22:57.052]                             if (!grepl(pattern, name)) 
[13:22:57.052]                               next
[13:22:57.052]                             invokeRestart(restart)
[13:22:57.052]                             muffled <- TRUE
[13:22:57.052]                             break
[13:22:57.052]                           }
[13:22:57.052]                         }
[13:22:57.052]                       }
[13:22:57.052]                       invisible(muffled)
[13:22:57.052]                     }
[13:22:57.052]                     muffleCondition(cond, pattern = "^muffle")
[13:22:57.052]                   }
[13:22:57.052]                 }
[13:22:57.052]                 else {
[13:22:57.052]                   if (TRUE) {
[13:22:57.052]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.052]                     {
[13:22:57.052]                       inherits <- base::inherits
[13:22:57.052]                       invokeRestart <- base::invokeRestart
[13:22:57.052]                       is.null <- base::is.null
[13:22:57.052]                       muffled <- FALSE
[13:22:57.052]                       if (inherits(cond, "message")) {
[13:22:57.052]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:57.052]                         if (muffled) 
[13:22:57.052]                           invokeRestart("muffleMessage")
[13:22:57.052]                       }
[13:22:57.052]                       else if (inherits(cond, "warning")) {
[13:22:57.052]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:57.052]                         if (muffled) 
[13:22:57.052]                           invokeRestart("muffleWarning")
[13:22:57.052]                       }
[13:22:57.052]                       else if (inherits(cond, "condition")) {
[13:22:57.052]                         if (!is.null(pattern)) {
[13:22:57.052]                           computeRestarts <- base::computeRestarts
[13:22:57.052]                           grepl <- base::grepl
[13:22:57.052]                           restarts <- computeRestarts(cond)
[13:22:57.052]                           for (restart in restarts) {
[13:22:57.052]                             name <- restart$name
[13:22:57.052]                             if (is.null(name)) 
[13:22:57.052]                               next
[13:22:57.052]                             if (!grepl(pattern, name)) 
[13:22:57.052]                               next
[13:22:57.052]                             invokeRestart(restart)
[13:22:57.052]                             muffled <- TRUE
[13:22:57.052]                             break
[13:22:57.052]                           }
[13:22:57.052]                         }
[13:22:57.052]                       }
[13:22:57.052]                       invisible(muffled)
[13:22:57.052]                     }
[13:22:57.052]                     muffleCondition(cond, pattern = "^muffle")
[13:22:57.052]                   }
[13:22:57.052]                 }
[13:22:57.052]             }
[13:22:57.052]         }))
[13:22:57.052]     }, error = function(ex) {
[13:22:57.052]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:57.052]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:57.052]                 ...future.rng), started = ...future.startTime, 
[13:22:57.052]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:57.052]             version = "1.8"), class = "FutureResult")
[13:22:57.052]     }, finally = {
[13:22:57.052]         if (!identical(...future.workdir, getwd())) 
[13:22:57.052]             setwd(...future.workdir)
[13:22:57.052]         {
[13:22:57.052]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:57.052]                 ...future.oldOptions$nwarnings <- NULL
[13:22:57.052]             }
[13:22:57.052]             base::options(...future.oldOptions)
[13:22:57.052]             if (.Platform$OS.type == "windows") {
[13:22:57.052]                 old_names <- names(...future.oldEnvVars)
[13:22:57.052]                 envs <- base::Sys.getenv()
[13:22:57.052]                 names <- names(envs)
[13:22:57.052]                 common <- intersect(names, old_names)
[13:22:57.052]                 added <- setdiff(names, old_names)
[13:22:57.052]                 removed <- setdiff(old_names, names)
[13:22:57.052]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:57.052]                   envs[common]]
[13:22:57.052]                 NAMES <- toupper(changed)
[13:22:57.052]                 args <- list()
[13:22:57.052]                 for (kk in seq_along(NAMES)) {
[13:22:57.052]                   name <- changed[[kk]]
[13:22:57.052]                   NAME <- NAMES[[kk]]
[13:22:57.052]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.052]                     next
[13:22:57.052]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:57.052]                 }
[13:22:57.052]                 NAMES <- toupper(added)
[13:22:57.052]                 for (kk in seq_along(NAMES)) {
[13:22:57.052]                   name <- added[[kk]]
[13:22:57.052]                   NAME <- NAMES[[kk]]
[13:22:57.052]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.052]                     next
[13:22:57.052]                   args[[name]] <- ""
[13:22:57.052]                 }
[13:22:57.052]                 NAMES <- toupper(removed)
[13:22:57.052]                 for (kk in seq_along(NAMES)) {
[13:22:57.052]                   name <- removed[[kk]]
[13:22:57.052]                   NAME <- NAMES[[kk]]
[13:22:57.052]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.052]                     next
[13:22:57.052]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:57.052]                 }
[13:22:57.052]                 if (length(args) > 0) 
[13:22:57.052]                   base::do.call(base::Sys.setenv, args = args)
[13:22:57.052]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:57.052]             }
[13:22:57.052]             else {
[13:22:57.052]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:57.052]             }
[13:22:57.052]             {
[13:22:57.052]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:57.052]                   0L) {
[13:22:57.052]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:57.052]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:57.052]                   base::options(opts)
[13:22:57.052]                 }
[13:22:57.052]                 {
[13:22:57.052]                   {
[13:22:57.052]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:57.052]                     NULL
[13:22:57.052]                   }
[13:22:57.052]                   options(future.plan = NULL)
[13:22:57.052]                   if (is.na(NA_character_)) 
[13:22:57.052]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:57.052]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:57.052]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:57.052]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:57.052]                     envir = parent.frame()) 
[13:22:57.052]                   {
[13:22:57.052]                     if (is.function(workers)) 
[13:22:57.052]                       workers <- workers()
[13:22:57.052]                     workers <- structure(as.integer(workers), 
[13:22:57.052]                       class = class(workers))
[13:22:57.052]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:57.052]                       workers >= 1)
[13:22:57.052]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:57.052]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:57.052]                     }
[13:22:57.052]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:57.052]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:57.052]                       envir = envir)
[13:22:57.052]                     if (!future$lazy) 
[13:22:57.052]                       future <- run(future)
[13:22:57.052]                     invisible(future)
[13:22:57.052]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:57.052]                 }
[13:22:57.052]             }
[13:22:57.052]         }
[13:22:57.052]     })
[13:22:57.052]     if (TRUE) {
[13:22:57.052]         base::sink(type = "output", split = FALSE)
[13:22:57.052]         if (TRUE) {
[13:22:57.052]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:57.052]         }
[13:22:57.052]         else {
[13:22:57.052]             ...future.result["stdout"] <- base::list(NULL)
[13:22:57.052]         }
[13:22:57.052]         base::close(...future.stdout)
[13:22:57.052]         ...future.stdout <- NULL
[13:22:57.052]     }
[13:22:57.052]     ...future.result$conditions <- ...future.conditions
[13:22:57.052]     ...future.result$finished <- base::Sys.time()
[13:22:57.052]     ...future.result
[13:22:57.052] }
[13:22:57.056] MultisessionFuture started
[13:22:57.056] - Launch lazy future ... done
[13:22:57.056] run() for ‘MultisessionFuture’ ... done
[13:22:57.056] result() for ClusterFuture ...
[13:22:57.056] receiveMessageFromWorker() for ClusterFuture ...
[13:22:57.056] - Validating connection of MultisessionFuture
[13:22:57.115] - received message: FutureResult
[13:22:57.115] - Received FutureResult
[13:22:57.116] - Erased future from FutureRegistry
[13:22:57.116] result() for ClusterFuture ...
[13:22:57.116] - result already collected: FutureResult
[13:22:57.116] result() for ClusterFuture ... done
[13:22:57.116] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:57.116] result() for ClusterFuture ... done
[13:22:57.116] result() for ClusterFuture ...
[13:22:57.116] - result already collected: FutureResult
[13:22:57.116] result() for ClusterFuture ... done
a = 10
[13:22:57.117] getGlobalsAndPackages() ...
[13:22:57.117] Searching for globals...
[13:22:57.118] - globals found: [3] ‘{’, ‘+’, ‘a’
[13:22:57.118] Searching for globals ... DONE
[13:22:57.118] Resolving globals: FALSE
[13:22:57.118] The total size of the 1 globals is 56 bytes (56 bytes)
[13:22:57.119] The total size of the 1 globals exported for future expression (‘{; a + 1; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:22:57.119] - globals: [1] ‘a’
[13:22:57.119] 
[13:22:57.119] getGlobalsAndPackages() ... DONE
[13:22:57.119] run() for ‘Future’ ...
[13:22:57.120] - state: ‘created’
[13:22:57.120] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:57.134] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:57.134] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:57.134]   - Field: ‘node’
[13:22:57.134]   - Field: ‘label’
[13:22:57.134]   - Field: ‘local’
[13:22:57.134]   - Field: ‘owner’
[13:22:57.134]   - Field: ‘envir’
[13:22:57.134]   - Field: ‘workers’
[13:22:57.135]   - Field: ‘packages’
[13:22:57.135]   - Field: ‘gc’
[13:22:57.135]   - Field: ‘conditions’
[13:22:57.135]   - Field: ‘persistent’
[13:22:57.135]   - Field: ‘expr’
[13:22:57.135]   - Field: ‘uuid’
[13:22:57.135]   - Field: ‘seed’
[13:22:57.135]   - Field: ‘version’
[13:22:57.135]   - Field: ‘result’
[13:22:57.135]   - Field: ‘asynchronous’
[13:22:57.135]   - Field: ‘calls’
[13:22:57.136]   - Field: ‘globals’
[13:22:57.136]   - Field: ‘stdout’
[13:22:57.136]   - Field: ‘earlySignal’
[13:22:57.136]   - Field: ‘lazy’
[13:22:57.136]   - Field: ‘state’
[13:22:57.136] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:57.136] - Launch lazy future ...
[13:22:57.137] Packages needed by the future expression (n = 0): <none>
[13:22:57.137] Packages needed by future strategies (n = 0): <none>
[13:22:57.137] {
[13:22:57.137]     {
[13:22:57.137]         {
[13:22:57.137]             ...future.startTime <- base::Sys.time()
[13:22:57.137]             {
[13:22:57.137]                 {
[13:22:57.137]                   {
[13:22:57.137]                     {
[13:22:57.137]                       base::local({
[13:22:57.137]                         has_future <- base::requireNamespace("future", 
[13:22:57.137]                           quietly = TRUE)
[13:22:57.137]                         if (has_future) {
[13:22:57.137]                           ns <- base::getNamespace("future")
[13:22:57.137]                           version <- ns[[".package"]][["version"]]
[13:22:57.137]                           if (is.null(version)) 
[13:22:57.137]                             version <- utils::packageVersion("future")
[13:22:57.137]                         }
[13:22:57.137]                         else {
[13:22:57.137]                           version <- NULL
[13:22:57.137]                         }
[13:22:57.137]                         if (!has_future || version < "1.8.0") {
[13:22:57.137]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:57.137]                             "", base::R.version$version.string), 
[13:22:57.137]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:57.137]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:57.137]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:57.137]                               "release", "version")], collapse = " "), 
[13:22:57.137]                             hostname = base::Sys.info()[["nodename"]])
[13:22:57.137]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:57.137]                             info)
[13:22:57.137]                           info <- base::paste(info, collapse = "; ")
[13:22:57.137]                           if (!has_future) {
[13:22:57.137]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:57.137]                               info)
[13:22:57.137]                           }
[13:22:57.137]                           else {
[13:22:57.137]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:57.137]                               info, version)
[13:22:57.137]                           }
[13:22:57.137]                           base::stop(msg)
[13:22:57.137]                         }
[13:22:57.137]                       })
[13:22:57.137]                     }
[13:22:57.137]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:57.137]                     base::options(mc.cores = 1L)
[13:22:57.137]                   }
[13:22:57.137]                   options(future.plan = NULL)
[13:22:57.137]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:57.137]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:57.137]                 }
[13:22:57.137]                 ...future.workdir <- getwd()
[13:22:57.137]             }
[13:22:57.137]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:57.137]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:57.137]         }
[13:22:57.137]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:57.137]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:57.137]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:57.137]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:57.137]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:57.137]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:57.137]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:57.137]             base::names(...future.oldOptions))
[13:22:57.137]     }
[13:22:57.137]     if (FALSE) {
[13:22:57.137]     }
[13:22:57.137]     else {
[13:22:57.137]         if (TRUE) {
[13:22:57.137]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:57.137]                 open = "w")
[13:22:57.137]         }
[13:22:57.137]         else {
[13:22:57.137]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:57.137]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:57.137]         }
[13:22:57.137]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:57.137]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:57.137]             base::sink(type = "output", split = FALSE)
[13:22:57.137]             base::close(...future.stdout)
[13:22:57.137]         }, add = TRUE)
[13:22:57.137]     }
[13:22:57.137]     ...future.frame <- base::sys.nframe()
[13:22:57.137]     ...future.conditions <- base::list()
[13:22:57.137]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:57.137]     if (FALSE) {
[13:22:57.137]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:57.137]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:57.137]     }
[13:22:57.137]     ...future.result <- base::tryCatch({
[13:22:57.137]         base::withCallingHandlers({
[13:22:57.137]             ...future.value <- base::withVisible(base::local({
[13:22:57.137]                 ...future.makeSendCondition <- base::local({
[13:22:57.137]                   sendCondition <- NULL
[13:22:57.137]                   function(frame = 1L) {
[13:22:57.137]                     if (is.function(sendCondition)) 
[13:22:57.137]                       return(sendCondition)
[13:22:57.137]                     ns <- getNamespace("parallel")
[13:22:57.137]                     if (exists("sendData", mode = "function", 
[13:22:57.137]                       envir = ns)) {
[13:22:57.137]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:57.137]                         envir = ns)
[13:22:57.137]                       envir <- sys.frame(frame)
[13:22:57.137]                       master <- NULL
[13:22:57.137]                       while (!identical(envir, .GlobalEnv) && 
[13:22:57.137]                         !identical(envir, emptyenv())) {
[13:22:57.137]                         if (exists("master", mode = "list", envir = envir, 
[13:22:57.137]                           inherits = FALSE)) {
[13:22:57.137]                           master <- get("master", mode = "list", 
[13:22:57.137]                             envir = envir, inherits = FALSE)
[13:22:57.137]                           if (inherits(master, c("SOCKnode", 
[13:22:57.137]                             "SOCK0node"))) {
[13:22:57.137]                             sendCondition <<- function(cond) {
[13:22:57.137]                               data <- list(type = "VALUE", value = cond, 
[13:22:57.137]                                 success = TRUE)
[13:22:57.137]                               parallel_sendData(master, data)
[13:22:57.137]                             }
[13:22:57.137]                             return(sendCondition)
[13:22:57.137]                           }
[13:22:57.137]                         }
[13:22:57.137]                         frame <- frame + 1L
[13:22:57.137]                         envir <- sys.frame(frame)
[13:22:57.137]                       }
[13:22:57.137]                     }
[13:22:57.137]                     sendCondition <<- function(cond) NULL
[13:22:57.137]                   }
[13:22:57.137]                 })
[13:22:57.137]                 withCallingHandlers({
[13:22:57.137]                   {
[13:22:57.137]                     a + 1
[13:22:57.137]                   }
[13:22:57.137]                 }, immediateCondition = function(cond) {
[13:22:57.137]                   sendCondition <- ...future.makeSendCondition()
[13:22:57.137]                   sendCondition(cond)
[13:22:57.137]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.137]                   {
[13:22:57.137]                     inherits <- base::inherits
[13:22:57.137]                     invokeRestart <- base::invokeRestart
[13:22:57.137]                     is.null <- base::is.null
[13:22:57.137]                     muffled <- FALSE
[13:22:57.137]                     if (inherits(cond, "message")) {
[13:22:57.137]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:57.137]                       if (muffled) 
[13:22:57.137]                         invokeRestart("muffleMessage")
[13:22:57.137]                     }
[13:22:57.137]                     else if (inherits(cond, "warning")) {
[13:22:57.137]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:57.137]                       if (muffled) 
[13:22:57.137]                         invokeRestart("muffleWarning")
[13:22:57.137]                     }
[13:22:57.137]                     else if (inherits(cond, "condition")) {
[13:22:57.137]                       if (!is.null(pattern)) {
[13:22:57.137]                         computeRestarts <- base::computeRestarts
[13:22:57.137]                         grepl <- base::grepl
[13:22:57.137]                         restarts <- computeRestarts(cond)
[13:22:57.137]                         for (restart in restarts) {
[13:22:57.137]                           name <- restart$name
[13:22:57.137]                           if (is.null(name)) 
[13:22:57.137]                             next
[13:22:57.137]                           if (!grepl(pattern, name)) 
[13:22:57.137]                             next
[13:22:57.137]                           invokeRestart(restart)
[13:22:57.137]                           muffled <- TRUE
[13:22:57.137]                           break
[13:22:57.137]                         }
[13:22:57.137]                       }
[13:22:57.137]                     }
[13:22:57.137]                     invisible(muffled)
[13:22:57.137]                   }
[13:22:57.137]                   muffleCondition(cond)
[13:22:57.137]                 })
[13:22:57.137]             }))
[13:22:57.137]             future::FutureResult(value = ...future.value$value, 
[13:22:57.137]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:57.137]                   ...future.rng), globalenv = if (FALSE) 
[13:22:57.137]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:57.137]                     ...future.globalenv.names))
[13:22:57.137]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:57.137]         }, condition = base::local({
[13:22:57.137]             c <- base::c
[13:22:57.137]             inherits <- base::inherits
[13:22:57.137]             invokeRestart <- base::invokeRestart
[13:22:57.137]             length <- base::length
[13:22:57.137]             list <- base::list
[13:22:57.137]             seq.int <- base::seq.int
[13:22:57.137]             signalCondition <- base::signalCondition
[13:22:57.137]             sys.calls <- base::sys.calls
[13:22:57.137]             `[[` <- base::`[[`
[13:22:57.137]             `+` <- base::`+`
[13:22:57.137]             `<<-` <- base::`<<-`
[13:22:57.137]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:57.137]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:57.137]                   3L)]
[13:22:57.137]             }
[13:22:57.137]             function(cond) {
[13:22:57.137]                 is_error <- inherits(cond, "error")
[13:22:57.137]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:57.137]                   NULL)
[13:22:57.137]                 if (is_error) {
[13:22:57.137]                   sessionInformation <- function() {
[13:22:57.137]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:57.137]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:57.137]                       search = base::search(), system = base::Sys.info())
[13:22:57.137]                   }
[13:22:57.137]                   ...future.conditions[[length(...future.conditions) + 
[13:22:57.137]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:57.137]                     cond$call), session = sessionInformation(), 
[13:22:57.137]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:57.137]                   signalCondition(cond)
[13:22:57.137]                 }
[13:22:57.137]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:57.137]                 "immediateCondition"))) {
[13:22:57.137]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:57.137]                   ...future.conditions[[length(...future.conditions) + 
[13:22:57.137]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:57.137]                   if (TRUE && !signal) {
[13:22:57.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.137]                     {
[13:22:57.137]                       inherits <- base::inherits
[13:22:57.137]                       invokeRestart <- base::invokeRestart
[13:22:57.137]                       is.null <- base::is.null
[13:22:57.137]                       muffled <- FALSE
[13:22:57.137]                       if (inherits(cond, "message")) {
[13:22:57.137]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:57.137]                         if (muffled) 
[13:22:57.137]                           invokeRestart("muffleMessage")
[13:22:57.137]                       }
[13:22:57.137]                       else if (inherits(cond, "warning")) {
[13:22:57.137]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:57.137]                         if (muffled) 
[13:22:57.137]                           invokeRestart("muffleWarning")
[13:22:57.137]                       }
[13:22:57.137]                       else if (inherits(cond, "condition")) {
[13:22:57.137]                         if (!is.null(pattern)) {
[13:22:57.137]                           computeRestarts <- base::computeRestarts
[13:22:57.137]                           grepl <- base::grepl
[13:22:57.137]                           restarts <- computeRestarts(cond)
[13:22:57.137]                           for (restart in restarts) {
[13:22:57.137]                             name <- restart$name
[13:22:57.137]                             if (is.null(name)) 
[13:22:57.137]                               next
[13:22:57.137]                             if (!grepl(pattern, name)) 
[13:22:57.137]                               next
[13:22:57.137]                             invokeRestart(restart)
[13:22:57.137]                             muffled <- TRUE
[13:22:57.137]                             break
[13:22:57.137]                           }
[13:22:57.137]                         }
[13:22:57.137]                       }
[13:22:57.137]                       invisible(muffled)
[13:22:57.137]                     }
[13:22:57.137]                     muffleCondition(cond, pattern = "^muffle")
[13:22:57.137]                   }
[13:22:57.137]                 }
[13:22:57.137]                 else {
[13:22:57.137]                   if (TRUE) {
[13:22:57.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.137]                     {
[13:22:57.137]                       inherits <- base::inherits
[13:22:57.137]                       invokeRestart <- base::invokeRestart
[13:22:57.137]                       is.null <- base::is.null
[13:22:57.137]                       muffled <- FALSE
[13:22:57.137]                       if (inherits(cond, "message")) {
[13:22:57.137]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:57.137]                         if (muffled) 
[13:22:57.137]                           invokeRestart("muffleMessage")
[13:22:57.137]                       }
[13:22:57.137]                       else if (inherits(cond, "warning")) {
[13:22:57.137]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:57.137]                         if (muffled) 
[13:22:57.137]                           invokeRestart("muffleWarning")
[13:22:57.137]                       }
[13:22:57.137]                       else if (inherits(cond, "condition")) {
[13:22:57.137]                         if (!is.null(pattern)) {
[13:22:57.137]                           computeRestarts <- base::computeRestarts
[13:22:57.137]                           grepl <- base::grepl
[13:22:57.137]                           restarts <- computeRestarts(cond)
[13:22:57.137]                           for (restart in restarts) {
[13:22:57.137]                             name <- restart$name
[13:22:57.137]                             if (is.null(name)) 
[13:22:57.137]                               next
[13:22:57.137]                             if (!grepl(pattern, name)) 
[13:22:57.137]                               next
[13:22:57.137]                             invokeRestart(restart)
[13:22:57.137]                             muffled <- TRUE
[13:22:57.137]                             break
[13:22:57.137]                           }
[13:22:57.137]                         }
[13:22:57.137]                       }
[13:22:57.137]                       invisible(muffled)
[13:22:57.137]                     }
[13:22:57.137]                     muffleCondition(cond, pattern = "^muffle")
[13:22:57.137]                   }
[13:22:57.137]                 }
[13:22:57.137]             }
[13:22:57.137]         }))
[13:22:57.137]     }, error = function(ex) {
[13:22:57.137]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:57.137]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:57.137]                 ...future.rng), started = ...future.startTime, 
[13:22:57.137]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:57.137]             version = "1.8"), class = "FutureResult")
[13:22:57.137]     }, finally = {
[13:22:57.137]         if (!identical(...future.workdir, getwd())) 
[13:22:57.137]             setwd(...future.workdir)
[13:22:57.137]         {
[13:22:57.137]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:57.137]                 ...future.oldOptions$nwarnings <- NULL
[13:22:57.137]             }
[13:22:57.137]             base::options(...future.oldOptions)
[13:22:57.137]             if (.Platform$OS.type == "windows") {
[13:22:57.137]                 old_names <- names(...future.oldEnvVars)
[13:22:57.137]                 envs <- base::Sys.getenv()
[13:22:57.137]                 names <- names(envs)
[13:22:57.137]                 common <- intersect(names, old_names)
[13:22:57.137]                 added <- setdiff(names, old_names)
[13:22:57.137]                 removed <- setdiff(old_names, names)
[13:22:57.137]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:57.137]                   envs[common]]
[13:22:57.137]                 NAMES <- toupper(changed)
[13:22:57.137]                 args <- list()
[13:22:57.137]                 for (kk in seq_along(NAMES)) {
[13:22:57.137]                   name <- changed[[kk]]
[13:22:57.137]                   NAME <- NAMES[[kk]]
[13:22:57.137]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.137]                     next
[13:22:57.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:57.137]                 }
[13:22:57.137]                 NAMES <- toupper(added)
[13:22:57.137]                 for (kk in seq_along(NAMES)) {
[13:22:57.137]                   name <- added[[kk]]
[13:22:57.137]                   NAME <- NAMES[[kk]]
[13:22:57.137]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.137]                     next
[13:22:57.137]                   args[[name]] <- ""
[13:22:57.137]                 }
[13:22:57.137]                 NAMES <- toupper(removed)
[13:22:57.137]                 for (kk in seq_along(NAMES)) {
[13:22:57.137]                   name <- removed[[kk]]
[13:22:57.137]                   NAME <- NAMES[[kk]]
[13:22:57.137]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.137]                     next
[13:22:57.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:57.137]                 }
[13:22:57.137]                 if (length(args) > 0) 
[13:22:57.137]                   base::do.call(base::Sys.setenv, args = args)
[13:22:57.137]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:57.137]             }
[13:22:57.137]             else {
[13:22:57.137]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:57.137]             }
[13:22:57.137]             {
[13:22:57.137]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:57.137]                   0L) {
[13:22:57.137]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:57.137]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:57.137]                   base::options(opts)
[13:22:57.137]                 }
[13:22:57.137]                 {
[13:22:57.137]                   {
[13:22:57.137]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:57.137]                     NULL
[13:22:57.137]                   }
[13:22:57.137]                   options(future.plan = NULL)
[13:22:57.137]                   if (is.na(NA_character_)) 
[13:22:57.137]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:57.137]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:57.137]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:57.137]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:57.137]                     envir = parent.frame()) 
[13:22:57.137]                   {
[13:22:57.137]                     if (is.function(workers)) 
[13:22:57.137]                       workers <- workers()
[13:22:57.137]                     workers <- structure(as.integer(workers), 
[13:22:57.137]                       class = class(workers))
[13:22:57.137]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:57.137]                       workers >= 1)
[13:22:57.137]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:57.137]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:57.137]                     }
[13:22:57.137]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:57.137]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:57.137]                       envir = envir)
[13:22:57.137]                     if (!future$lazy) 
[13:22:57.137]                       future <- run(future)
[13:22:57.137]                     invisible(future)
[13:22:57.137]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:57.137]                 }
[13:22:57.137]             }
[13:22:57.137]         }
[13:22:57.137]     })
[13:22:57.137]     if (TRUE) {
[13:22:57.137]         base::sink(type = "output", split = FALSE)
[13:22:57.137]         if (TRUE) {
[13:22:57.137]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:57.137]         }
[13:22:57.137]         else {
[13:22:57.137]             ...future.result["stdout"] <- base::list(NULL)
[13:22:57.137]         }
[13:22:57.137]         base::close(...future.stdout)
[13:22:57.137]         ...future.stdout <- NULL
[13:22:57.137]     }
[13:22:57.137]     ...future.result$conditions <- ...future.conditions
[13:22:57.137]     ...future.result$finished <- base::Sys.time()
[13:22:57.137]     ...future.result
[13:22:57.137] }
[13:22:57.140] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[13:22:57.140] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[13:22:57.141] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[13:22:57.141] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[13:22:57.141] MultisessionFuture started
[13:22:57.141] - Launch lazy future ... done
[13:22:57.142] run() for ‘MultisessionFuture’ ... done
[13:22:57.142] result() for ClusterFuture ...
[13:22:57.142] receiveMessageFromWorker() for ClusterFuture ...
[13:22:57.142] - Validating connection of MultisessionFuture
[13:22:57.189] - received message: FutureResult
[13:22:57.189] - Received FutureResult
[13:22:57.190] - Erased future from FutureRegistry
[13:22:57.190] result() for ClusterFuture ...
[13:22:57.190] - result already collected: FutureResult
[13:22:57.190] result() for ClusterFuture ... done
[13:22:57.190] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:57.190] result() for ClusterFuture ... done
[13:22:57.190] result() for ClusterFuture ...
[13:22:57.190] - result already collected: FutureResult
[13:22:57.190] result() for ClusterFuture ... done
b = 11
*** %<-% with ‘multisession’ futures ... DONE
Testing with 2 cores ... DONE
> 
> message("*** %<-% ... DONE")
*** %<-% ... DONE
> 
> source("incl/end.R")
[13:22:57.191] plan(): Setting new future strategy stack:
[13:22:57.191] List of future strategies:
[13:22:57.191] 1. FutureStrategy:
[13:22:57.191]    - args: function (..., envir = parent.frame())
[13:22:57.191]    - tweaked: FALSE
[13:22:57.191]    - call: future::plan(oplan)
[13:22:57.192] plan(): nbrOfWorkers() = 1
> 
