
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[16:05:03.775] plan(): Setting new future strategy stack:
[16:05:03.775] List of future strategies:
[16:05:03.775] 1. sequential:
[16:05:03.775]    - args: function (..., envir = parent.frame())
[16:05:03.775]    - tweaked: FALSE
[16:05:03.775]    - call: future::plan("sequential")
[16:05:03.790] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> message("*** Globals - too large ...")
*** Globals - too large ...
> 
> ooptsT <- options(future.globals.maxSize = object.size(1:1000) - 1L)
> limit <- getOption("future.globals.maxSize")
> cat(sprintf("Max total size of globals: %g bytes\n", limit))
Max total size of globals: 4047 bytes
> 
> plan(multisession)
[16:05:03.803] plan(): Setting new future strategy stack:
[16:05:03.803] List of future strategies:
[16:05:03.803] 1. multisession:
[16:05:03.803]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:05:03.803]    - tweaked: FALSE
[16:05:03.803]    - call: plan(multisession)
[16:05:03.814] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:05:03.814] multisession:
[16:05:03.814] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:05:03.814] - tweaked: FALSE
[16:05:03.814] - call: plan(multisession)
[16:05:03.820] getGlobalsAndPackages() ...
[16:05:03.820] Not searching for globals
[16:05:03.821] - globals: [0] <none>
[16:05:03.821] getGlobalsAndPackages() ... DONE
[16:05:03.821] [local output] makeClusterPSOCK() ...
[16:05:03.854] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:05:03.855] [local output] Base port: 11790
[16:05:03.856] [local output] Getting setup options for 2 cluster nodes ...
[16:05:03.856] [local output]  - Node 1 of 2 ...
[16:05:03.856] [local output] localMachine=TRUE => revtunnel=FALSE

[16:05:03.857] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmpy1UD9y/worker.rank=1.parallelly.parent=85854.14f5e1ae3097b.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmpy1UD9y/worker.rank=1.parallelly.parent=85854.14f5e1ae3097b.pid")'’
[16:05:04.046] - Possible to infer worker's PID: TRUE
[16:05:04.046] [local output] Rscript port: 11790

[16:05:04.047] [local output]  - Node 2 of 2 ...
[16:05:04.047] [local output] localMachine=TRUE => revtunnel=FALSE

[16:05:04.048] [local output] Rscript port: 11790

[16:05:04.048] [local output] Getting setup options for 2 cluster nodes ... done
[16:05:04.048] [local output]  - Parallel setup requested for some PSOCK nodes
[16:05:04.049] [local output] Setting up PSOCK nodes in parallel
[16:05:04.049] List of 36
[16:05:04.049]  $ worker          : chr "localhost"
[16:05:04.049]   ..- attr(*, "localhost")= logi TRUE
[16:05:04.049]  $ master          : chr "localhost"
[16:05:04.049]  $ port            : int 11790
[16:05:04.049]  $ connectTimeout  : num 120
[16:05:04.049]  $ timeout         : num 2592000
[16:05:04.049]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:05:04.049]  $ homogeneous     : logi TRUE
[16:05:04.049]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:05:04.049]  $ rscript_envs    : NULL
[16:05:04.049]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:05:04.049]  $ rscript_startup : NULL
[16:05:04.049]  $ rscript_sh      : chr "sh"
[16:05:04.049]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:05:04.049]  $ methods         : logi TRUE
[16:05:04.049]  $ socketOptions   : chr "no-delay"
[16:05:04.049]  $ useXDR          : logi FALSE
[16:05:04.049]  $ outfile         : chr "/dev/null"
[16:05:04.049]  $ renice          : int NA
[16:05:04.049]  $ rshcmd          : NULL
[16:05:04.049]  $ user            : chr(0) 
[16:05:04.049]  $ revtunnel       : logi FALSE
[16:05:04.049]  $ rshlogfile      : NULL
[16:05:04.049]  $ rshopts         : chr(0) 
[16:05:04.049]  $ rank            : int 1
[16:05:04.049]  $ manual          : logi FALSE
[16:05:04.049]  $ dryrun          : logi FALSE
[16:05:04.049]  $ quiet           : logi FALSE
[16:05:04.049]  $ setup_strategy  : chr "parallel"
[16:05:04.049]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:05:04.049]  $ pidfile         : chr "/tmp/Rtmpy1UD9y/worker.rank=1.parallelly.parent=85854.14f5e1ae3097b.pid"
[16:05:04.049]  $ rshcmd_label    : NULL
[16:05:04.049]  $ rsh_call        : NULL
[16:05:04.049]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:05:04.049]  $ localMachine    : logi TRUE
[16:05:04.049]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:05:04.049]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:05:04.049]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:05:04.049]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:05:04.049]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:05:04.049]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:05:04.049]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:05:04.049]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:05:04.049]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:05:04.049]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:05:04.049]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:05:04.049]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:05:04.049]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:05:04.049]  $ arguments       :List of 28
[16:05:04.049]   ..$ worker          : chr "localhost"
[16:05:04.049]   ..$ master          : NULL
[16:05:04.049]   ..$ port            : int 11790
[16:05:04.049]   ..$ connectTimeout  : num 120
[16:05:04.049]   ..$ timeout         : num 2592000
[16:05:04.049]   ..$ rscript         : NULL
[16:05:04.049]   ..$ homogeneous     : NULL
[16:05:04.049]   ..$ rscript_args    : NULL
[16:05:04.049]   ..$ rscript_envs    : NULL
[16:05:04.049]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:05:04.049]   ..$ rscript_startup : NULL
[16:05:04.049]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:05:04.049]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:05:04.049]   ..$ methods         : logi TRUE
[16:05:04.049]   ..$ socketOptions   : chr "no-delay"
[16:05:04.049]   ..$ useXDR          : logi FALSE
[16:05:04.049]   ..$ outfile         : chr "/dev/null"
[16:05:04.049]   ..$ renice          : int NA
[16:05:04.049]   ..$ rshcmd          : NULL
[16:05:04.049]   ..$ user            : NULL
[16:05:04.049]   ..$ revtunnel       : logi NA
[16:05:04.049]   ..$ rshlogfile      : NULL
[16:05:04.049]   ..$ rshopts         : NULL
[16:05:04.049]   ..$ rank            : int 1
[16:05:04.049]   ..$ manual          : logi FALSE
[16:05:04.049]   ..$ dryrun          : logi FALSE
[16:05:04.049]   ..$ quiet           : logi FALSE
[16:05:04.049]   ..$ setup_strategy  : chr "parallel"
[16:05:04.049]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:05:04.068] [local output] System call to launch all workers:
[16:05:04.068] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmpy1UD9y/worker.rank=1.parallelly.parent=85854.14f5e1ae3097b.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11790 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:05:04.068] [local output] Starting PSOCK main server
[16:05:04.074] [local output] Workers launched
[16:05:04.074] [local output] Waiting for workers to connect back
[16:05:04.074]  - [local output] 0 workers out of 2 ready
[16:05:04.342]  - [local output] 0 workers out of 2 ready
[16:05:04.343]  - [local output] 1 workers out of 2 ready
[16:05:04.343]  - [local output] 2 workers out of 2 ready
[16:05:04.343] [local output] Launching of workers completed
[16:05:04.343] [local output] Collecting session information from workers
[16:05:04.344] [local output]  - Worker #1 of 2
[16:05:04.345] [local output]  - Worker #2 of 2
[16:05:04.345] [local output] makeClusterPSOCK() ... done
[16:05:04.358] Packages needed by the future expression (n = 0): <none>
[16:05:04.358] Packages needed by future strategies (n = 0): <none>
[16:05:04.359] {
[16:05:04.359]     {
[16:05:04.359]         {
[16:05:04.359]             ...future.startTime <- base::Sys.time()
[16:05:04.359]             {
[16:05:04.359]                 {
[16:05:04.359]                   {
[16:05:04.359]                     {
[16:05:04.359]                       base::local({
[16:05:04.359]                         has_future <- base::requireNamespace("future", 
[16:05:04.359]                           quietly = TRUE)
[16:05:04.359]                         if (has_future) {
[16:05:04.359]                           ns <- base::getNamespace("future")
[16:05:04.359]                           version <- ns[[".package"]][["version"]]
[16:05:04.359]                           if (is.null(version)) 
[16:05:04.359]                             version <- utils::packageVersion("future")
[16:05:04.359]                         }
[16:05:04.359]                         else {
[16:05:04.359]                           version <- NULL
[16:05:04.359]                         }
[16:05:04.359]                         if (!has_future || version < "1.8.0") {
[16:05:04.359]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:04.359]                             "", base::R.version$version.string), 
[16:05:04.359]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:04.359]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:04.359]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:04.359]                               "release", "version")], collapse = " "), 
[16:05:04.359]                             hostname = base::Sys.info()[["nodename"]])
[16:05:04.359]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:04.359]                             info)
[16:05:04.359]                           info <- base::paste(info, collapse = "; ")
[16:05:04.359]                           if (!has_future) {
[16:05:04.359]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:04.359]                               info)
[16:05:04.359]                           }
[16:05:04.359]                           else {
[16:05:04.359]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:04.359]                               info, version)
[16:05:04.359]                           }
[16:05:04.359]                           base::stop(msg)
[16:05:04.359]                         }
[16:05:04.359]                       })
[16:05:04.359]                     }
[16:05:04.359]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:04.359]                     base::options(mc.cores = 1L)
[16:05:04.359]                   }
[16:05:04.359]                   options(future.plan = NULL)
[16:05:04.359]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:04.359]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:04.359]                 }
[16:05:04.359]                 ...future.workdir <- getwd()
[16:05:04.359]             }
[16:05:04.359]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:04.359]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:04.359]         }
[16:05:04.359]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:04.359]             future.globals.maxSize = 4047, future.globals.method = NULL, 
[16:05:04.359]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:04.359]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:04.359]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:04.359]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:04.359]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:04.359]             base::names(...future.oldOptions))
[16:05:04.359]     }
[16:05:04.359]     if (FALSE) {
[16:05:04.359]     }
[16:05:04.359]     else {
[16:05:04.359]         if (TRUE) {
[16:05:04.359]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:04.359]                 open = "w")
[16:05:04.359]         }
[16:05:04.359]         else {
[16:05:04.359]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:04.359]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:04.359]         }
[16:05:04.359]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:04.359]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:04.359]             base::sink(type = "output", split = FALSE)
[16:05:04.359]             base::close(...future.stdout)
[16:05:04.359]         }, add = TRUE)
[16:05:04.359]     }
[16:05:04.359]     ...future.frame <- base::sys.nframe()
[16:05:04.359]     ...future.conditions <- base::list()
[16:05:04.359]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:04.359]     if (FALSE) {
[16:05:04.359]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:04.359]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:04.359]     }
[16:05:04.359]     ...future.result <- base::tryCatch({
[16:05:04.359]         base::withCallingHandlers({
[16:05:04.359]             ...future.value <- base::withVisible(base::local({
[16:05:04.359]                 ...future.makeSendCondition <- base::local({
[16:05:04.359]                   sendCondition <- NULL
[16:05:04.359]                   function(frame = 1L) {
[16:05:04.359]                     if (is.function(sendCondition)) 
[16:05:04.359]                       return(sendCondition)
[16:05:04.359]                     ns <- getNamespace("parallel")
[16:05:04.359]                     if (exists("sendData", mode = "function", 
[16:05:04.359]                       envir = ns)) {
[16:05:04.359]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:04.359]                         envir = ns)
[16:05:04.359]                       envir <- sys.frame(frame)
[16:05:04.359]                       master <- NULL
[16:05:04.359]                       while (!identical(envir, .GlobalEnv) && 
[16:05:04.359]                         !identical(envir, emptyenv())) {
[16:05:04.359]                         if (exists("master", mode = "list", envir = envir, 
[16:05:04.359]                           inherits = FALSE)) {
[16:05:04.359]                           master <- get("master", mode = "list", 
[16:05:04.359]                             envir = envir, inherits = FALSE)
[16:05:04.359]                           if (inherits(master, c("SOCKnode", 
[16:05:04.359]                             "SOCK0node"))) {
[16:05:04.359]                             sendCondition <<- function(cond) {
[16:05:04.359]                               data <- list(type = "VALUE", value = cond, 
[16:05:04.359]                                 success = TRUE)
[16:05:04.359]                               parallel_sendData(master, data)
[16:05:04.359]                             }
[16:05:04.359]                             return(sendCondition)
[16:05:04.359]                           }
[16:05:04.359]                         }
[16:05:04.359]                         frame <- frame + 1L
[16:05:04.359]                         envir <- sys.frame(frame)
[16:05:04.359]                       }
[16:05:04.359]                     }
[16:05:04.359]                     sendCondition <<- function(cond) NULL
[16:05:04.359]                   }
[16:05:04.359]                 })
[16:05:04.359]                 withCallingHandlers({
[16:05:04.359]                   NA
[16:05:04.359]                 }, immediateCondition = function(cond) {
[16:05:04.359]                   sendCondition <- ...future.makeSendCondition()
[16:05:04.359]                   sendCondition(cond)
[16:05:04.359]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:04.359]                   {
[16:05:04.359]                     inherits <- base::inherits
[16:05:04.359]                     invokeRestart <- base::invokeRestart
[16:05:04.359]                     is.null <- base::is.null
[16:05:04.359]                     muffled <- FALSE
[16:05:04.359]                     if (inherits(cond, "message")) {
[16:05:04.359]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:04.359]                       if (muffled) 
[16:05:04.359]                         invokeRestart("muffleMessage")
[16:05:04.359]                     }
[16:05:04.359]                     else if (inherits(cond, "warning")) {
[16:05:04.359]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:04.359]                       if (muffled) 
[16:05:04.359]                         invokeRestart("muffleWarning")
[16:05:04.359]                     }
[16:05:04.359]                     else if (inherits(cond, "condition")) {
[16:05:04.359]                       if (!is.null(pattern)) {
[16:05:04.359]                         computeRestarts <- base::computeRestarts
[16:05:04.359]                         grepl <- base::grepl
[16:05:04.359]                         restarts <- computeRestarts(cond)
[16:05:04.359]                         for (restart in restarts) {
[16:05:04.359]                           name <- restart$name
[16:05:04.359]                           if (is.null(name)) 
[16:05:04.359]                             next
[16:05:04.359]                           if (!grepl(pattern, name)) 
[16:05:04.359]                             next
[16:05:04.359]                           invokeRestart(restart)
[16:05:04.359]                           muffled <- TRUE
[16:05:04.359]                           break
[16:05:04.359]                         }
[16:05:04.359]                       }
[16:05:04.359]                     }
[16:05:04.359]                     invisible(muffled)
[16:05:04.359]                   }
[16:05:04.359]                   muffleCondition(cond)
[16:05:04.359]                 })
[16:05:04.359]             }))
[16:05:04.359]             future::FutureResult(value = ...future.value$value, 
[16:05:04.359]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:04.359]                   ...future.rng), globalenv = if (FALSE) 
[16:05:04.359]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:04.359]                     ...future.globalenv.names))
[16:05:04.359]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:04.359]         }, condition = base::local({
[16:05:04.359]             c <- base::c
[16:05:04.359]             inherits <- base::inherits
[16:05:04.359]             invokeRestart <- base::invokeRestart
[16:05:04.359]             length <- base::length
[16:05:04.359]             list <- base::list
[16:05:04.359]             seq.int <- base::seq.int
[16:05:04.359]             signalCondition <- base::signalCondition
[16:05:04.359]             sys.calls <- base::sys.calls
[16:05:04.359]             `[[` <- base::`[[`
[16:05:04.359]             `+` <- base::`+`
[16:05:04.359]             `<<-` <- base::`<<-`
[16:05:04.359]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:04.359]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:04.359]                   3L)]
[16:05:04.359]             }
[16:05:04.359]             function(cond) {
[16:05:04.359]                 is_error <- inherits(cond, "error")
[16:05:04.359]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:04.359]                   NULL)
[16:05:04.359]                 if (is_error) {
[16:05:04.359]                   sessionInformation <- function() {
[16:05:04.359]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:04.359]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:04.359]                       search = base::search(), system = base::Sys.info())
[16:05:04.359]                   }
[16:05:04.359]                   ...future.conditions[[length(...future.conditions) + 
[16:05:04.359]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:04.359]                     cond$call), session = sessionInformation(), 
[16:05:04.359]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:04.359]                   signalCondition(cond)
[16:05:04.359]                 }
[16:05:04.359]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:04.359]                 "immediateCondition"))) {
[16:05:04.359]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:04.359]                   ...future.conditions[[length(...future.conditions) + 
[16:05:04.359]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:04.359]                   if (TRUE && !signal) {
[16:05:04.359]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:04.359]                     {
[16:05:04.359]                       inherits <- base::inherits
[16:05:04.359]                       invokeRestart <- base::invokeRestart
[16:05:04.359]                       is.null <- base::is.null
[16:05:04.359]                       muffled <- FALSE
[16:05:04.359]                       if (inherits(cond, "message")) {
[16:05:04.359]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:04.359]                         if (muffled) 
[16:05:04.359]                           invokeRestart("muffleMessage")
[16:05:04.359]                       }
[16:05:04.359]                       else if (inherits(cond, "warning")) {
[16:05:04.359]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:04.359]                         if (muffled) 
[16:05:04.359]                           invokeRestart("muffleWarning")
[16:05:04.359]                       }
[16:05:04.359]                       else if (inherits(cond, "condition")) {
[16:05:04.359]                         if (!is.null(pattern)) {
[16:05:04.359]                           computeRestarts <- base::computeRestarts
[16:05:04.359]                           grepl <- base::grepl
[16:05:04.359]                           restarts <- computeRestarts(cond)
[16:05:04.359]                           for (restart in restarts) {
[16:05:04.359]                             name <- restart$name
[16:05:04.359]                             if (is.null(name)) 
[16:05:04.359]                               next
[16:05:04.359]                             if (!grepl(pattern, name)) 
[16:05:04.359]                               next
[16:05:04.359]                             invokeRestart(restart)
[16:05:04.359]                             muffled <- TRUE
[16:05:04.359]                             break
[16:05:04.359]                           }
[16:05:04.359]                         }
[16:05:04.359]                       }
[16:05:04.359]                       invisible(muffled)
[16:05:04.359]                     }
[16:05:04.359]                     muffleCondition(cond, pattern = "^muffle")
[16:05:04.359]                   }
[16:05:04.359]                 }
[16:05:04.359]                 else {
[16:05:04.359]                   if (TRUE) {
[16:05:04.359]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:04.359]                     {
[16:05:04.359]                       inherits <- base::inherits
[16:05:04.359]                       invokeRestart <- base::invokeRestart
[16:05:04.359]                       is.null <- base::is.null
[16:05:04.359]                       muffled <- FALSE
[16:05:04.359]                       if (inherits(cond, "message")) {
[16:05:04.359]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:04.359]                         if (muffled) 
[16:05:04.359]                           invokeRestart("muffleMessage")
[16:05:04.359]                       }
[16:05:04.359]                       else if (inherits(cond, "warning")) {
[16:05:04.359]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:04.359]                         if (muffled) 
[16:05:04.359]                           invokeRestart("muffleWarning")
[16:05:04.359]                       }
[16:05:04.359]                       else if (inherits(cond, "condition")) {
[16:05:04.359]                         if (!is.null(pattern)) {
[16:05:04.359]                           computeRestarts <- base::computeRestarts
[16:05:04.359]                           grepl <- base::grepl
[16:05:04.359]                           restarts <- computeRestarts(cond)
[16:05:04.359]                           for (restart in restarts) {
[16:05:04.359]                             name <- restart$name
[16:05:04.359]                             if (is.null(name)) 
[16:05:04.359]                               next
[16:05:04.359]                             if (!grepl(pattern, name)) 
[16:05:04.359]                               next
[16:05:04.359]                             invokeRestart(restart)
[16:05:04.359]                             muffled <- TRUE
[16:05:04.359]                             break
[16:05:04.359]                           }
[16:05:04.359]                         }
[16:05:04.359]                       }
[16:05:04.359]                       invisible(muffled)
[16:05:04.359]                     }
[16:05:04.359]                     muffleCondition(cond, pattern = "^muffle")
[16:05:04.359]                   }
[16:05:04.359]                 }
[16:05:04.359]             }
[16:05:04.359]         }))
[16:05:04.359]     }, error = function(ex) {
[16:05:04.359]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:04.359]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:04.359]                 ...future.rng), started = ...future.startTime, 
[16:05:04.359]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:04.359]             version = "1.8"), class = "FutureResult")
[16:05:04.359]     }, finally = {
[16:05:04.359]         if (!identical(...future.workdir, getwd())) 
[16:05:04.359]             setwd(...future.workdir)
[16:05:04.359]         {
[16:05:04.359]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:04.359]                 ...future.oldOptions$nwarnings <- NULL
[16:05:04.359]             }
[16:05:04.359]             base::options(...future.oldOptions)
[16:05:04.359]             if (.Platform$OS.type == "windows") {
[16:05:04.359]                 old_names <- names(...future.oldEnvVars)
[16:05:04.359]                 envs <- base::Sys.getenv()
[16:05:04.359]                 names <- names(envs)
[16:05:04.359]                 common <- intersect(names, old_names)
[16:05:04.359]                 added <- setdiff(names, old_names)
[16:05:04.359]                 removed <- setdiff(old_names, names)
[16:05:04.359]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:04.359]                   envs[common]]
[16:05:04.359]                 NAMES <- toupper(changed)
[16:05:04.359]                 args <- list()
[16:05:04.359]                 for (kk in seq_along(NAMES)) {
[16:05:04.359]                   name <- changed[[kk]]
[16:05:04.359]                   NAME <- NAMES[[kk]]
[16:05:04.359]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:04.359]                     next
[16:05:04.359]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:04.359]                 }
[16:05:04.359]                 NAMES <- toupper(added)
[16:05:04.359]                 for (kk in seq_along(NAMES)) {
[16:05:04.359]                   name <- added[[kk]]
[16:05:04.359]                   NAME <- NAMES[[kk]]
[16:05:04.359]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:04.359]                     next
[16:05:04.359]                   args[[name]] <- ""
[16:05:04.359]                 }
[16:05:04.359]                 NAMES <- toupper(removed)
[16:05:04.359]                 for (kk in seq_along(NAMES)) {
[16:05:04.359]                   name <- removed[[kk]]
[16:05:04.359]                   NAME <- NAMES[[kk]]
[16:05:04.359]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:04.359]                     next
[16:05:04.359]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:04.359]                 }
[16:05:04.359]                 if (length(args) > 0) 
[16:05:04.359]                   base::do.call(base::Sys.setenv, args = args)
[16:05:04.359]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:04.359]             }
[16:05:04.359]             else {
[16:05:04.359]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:04.359]             }
[16:05:04.359]             {
[16:05:04.359]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:04.359]                   0L) {
[16:05:04.359]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:04.359]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:04.359]                   base::options(opts)
[16:05:04.359]                 }
[16:05:04.359]                 {
[16:05:04.359]                   {
[16:05:04.359]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:04.359]                     NULL
[16:05:04.359]                   }
[16:05:04.359]                   options(future.plan = NULL)
[16:05:04.359]                   if (is.na(NA_character_)) 
[16:05:04.359]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:04.359]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:04.359]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:04.359]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:04.359]                     envir = parent.frame()) 
[16:05:04.359]                   {
[16:05:04.359]                     if (is.function(workers)) 
[16:05:04.359]                       workers <- workers()
[16:05:04.359]                     workers <- structure(as.integer(workers), 
[16:05:04.359]                       class = class(workers))
[16:05:04.359]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:04.359]                       workers >= 1)
[16:05:04.359]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:04.359]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:04.359]                     }
[16:05:04.359]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:04.359]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:04.359]                       envir = envir)
[16:05:04.359]                     if (!future$lazy) 
[16:05:04.359]                       future <- run(future)
[16:05:04.359]                     invisible(future)
[16:05:04.359]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:04.359]                 }
[16:05:04.359]             }
[16:05:04.359]         }
[16:05:04.359]     })
[16:05:04.359]     if (TRUE) {
[16:05:04.359]         base::sink(type = "output", split = FALSE)
[16:05:04.359]         if (TRUE) {
[16:05:04.359]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:04.359]         }
[16:05:04.359]         else {
[16:05:04.359]             ...future.result["stdout"] <- base::list(NULL)
[16:05:04.359]         }
[16:05:04.359]         base::close(...future.stdout)
[16:05:04.359]         ...future.stdout <- NULL
[16:05:04.359]     }
[16:05:04.359]     ...future.result$conditions <- ...future.conditions
[16:05:04.359]     ...future.result$finished <- base::Sys.time()
[16:05:04.359]     ...future.result
[16:05:04.359] }
[16:05:04.414] MultisessionFuture started
[16:05:04.415] result() for ClusterFuture ...
[16:05:04.415] receiveMessageFromWorker() for ClusterFuture ...
[16:05:04.415] - Validating connection of MultisessionFuture
[16:05:04.459] - received message: FutureResult
[16:05:04.460] - Received FutureResult
[16:05:04.462] - Erased future from FutureRegistry
[16:05:04.463] result() for ClusterFuture ...
[16:05:04.463] - result already collected: FutureResult
[16:05:04.463] result() for ClusterFuture ... done
[16:05:04.463] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:04.463] result() for ClusterFuture ... done
[16:05:04.464] result() for ClusterFuture ...
[16:05:04.464] - result already collected: FutureResult
[16:05:04.464] result() for ClusterFuture ... done
[16:05:04.464] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:05:04.468] plan(): nbrOfWorkers() = 2
> 
> exprs <- list(
+   A = substitute({ a }, env = list()),
+   B = substitute({ a * b }, env = list()),
+   C = substitute({ a * b * c }, env = list()),
+   D = substitute({ a * b * c * d }, env = list()),
+   E = substitute({ a * b * c * d * e }, env = list())
+ )
> 
> a <- 1:1000
> b <- 1:900
> c <- 1:800
> d <- 1:700
> e <- 1
> 
> for (name in names(exprs)) {
+   message(sprintf("Expression %s:", name))
+   expr <- exprs[[name]]
+   print(expr)
+   res <- tryCatch({
+     f <- future(expr, substitute = FALSE)
+   }, error = function(ex) ex)
+   print(res)
+   stopifnot(inherits(res, "error"))
+   msg <- conditionMessage(res)
+   stopifnot(grepl("exceeds the maximum allowed size", msg))
+ }
Expression A:
{
    a
}
[16:05:04.476] getGlobalsAndPackages() ...
[16:05:04.477] Searching for globals...
[16:05:04.481] - globals found: [2] ‘{’, ‘a’
[16:05:04.481] Searching for globals ... DONE
[16:05:04.481] Resolving globals: FALSE
[16:05:04.482] The total size of the 1 globals is 3.95 KiB (4048 bytes)
[16:05:04.483] The total size of the 1 globals exported for future expression (‘{; a; }’) is 3.95 KiB.. This exceeds the maximum allowed size of 3.95 KiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.95 KiB of class ‘numeric’)
<simpleError in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,     globals = globals): The total size of the 1 globals exported for future expression (‘{; a; }’) is 3.95 KiB.. This exceeds the maximum allowed size of 3.95 KiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.95 KiB of class ‘numeric’)>
Expression B:
{
    a * b
}
[16:05:04.483] getGlobalsAndPackages() ...
[16:05:04.483] Searching for globals...
[16:05:04.488] - globals found: [4] ‘{’, ‘*’, ‘a’, ‘b’
[16:05:04.488] Searching for globals ... DONE
[16:05:04.489] Resolving globals: FALSE
[16:05:04.489] The total size of the 2 globals is 7.52 KiB (7696 bytes)
[16:05:04.489] The total size of the 2 globals exported for future expression (‘{; a * b; }’) is 7.52 KiB.. This exceeds the maximum allowed size of 3.95 KiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (3.95 KiB of class ‘numeric’) and ‘b’ (3.56 KiB of class ‘numeric’)
<simpleError in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,     globals = globals): The total size of the 2 globals exported for future expression (‘{; a * b; }’) is 7.52 KiB.. This exceeds the maximum allowed size of 3.95 KiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (3.95 KiB of class ‘numeric’) and ‘b’ (3.56 KiB of class ‘numeric’)>
Expression C:
{
    a * b * c
}
[16:05:04.490] getGlobalsAndPackages() ...
[16:05:04.490] Searching for globals...
[16:05:04.494] - globals found: [5] ‘{’, ‘*’, ‘a’, ‘b’, ‘c’
[16:05:04.494] Searching for globals ... DONE
[16:05:04.494] Resolving globals: FALSE
[16:05:04.495] The total size of the 3 globals is 10.69 KiB (10944 bytes)
[16:05:04.495] The total size of the 3 globals exported for future expression (‘{; a * b * c; }’) is 10.69 KiB.. This exceeds the maximum allowed size of 3.95 KiB (option 'future.globals.maxSize'). There are three globals: ‘a’ (3.95 KiB of class ‘numeric’), ‘b’ (3.56 KiB of class ‘numeric’) and ‘c’ (3.17 KiB of class ‘numeric’)
<simpleError in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,     globals = globals): The total size of the 3 globals exported for future expression (‘{; a * b * c; }’) is 10.69 KiB.. This exceeds the maximum allowed size of 3.95 KiB (option 'future.globals.maxSize'). There are three globals: ‘a’ (3.95 KiB of class ‘numeric’), ‘b’ (3.56 KiB of class ‘numeric’) and ‘c’ (3.17 KiB of class ‘numeric’)>
Expression D:
{
    a * b * c * d
}
[16:05:04.495] getGlobalsAndPackages() ...
[16:05:04.495] Searching for globals...
[16:05:04.497] - globals found: [6] ‘{’, ‘*’, ‘a’, ‘b’, ‘c’, ‘d’
[16:05:04.497] Searching for globals ... DONE
[16:05:04.497] Resolving globals: FALSE
[16:05:04.497] The total size of the 4 globals is 13.47 KiB (13792 bytes)
[16:05:04.498] The total size of the 4 globals exported for future expression (‘{; a * b * c * d; }’) is 13.47 KiB.. This exceeds the maximum allowed size of 3.95 KiB (option 'future.globals.maxSize'). The three largest globals are ‘a’ (3.95 KiB of class ‘numeric’), ‘b’ (3.56 KiB of class ‘numeric’) and ‘c’ (3.17 KiB of class ‘numeric’)
<simpleError in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,     globals = globals): The total size of the 4 globals exported for future expression (‘{; a * b * c * d; }’) is 13.47 KiB.. This exceeds the maximum allowed size of 3.95 KiB (option 'future.globals.maxSize'). The three largest globals are ‘a’ (3.95 KiB of class ‘numeric’), ‘b’ (3.56 KiB of class ‘numeric’) and ‘c’ (3.17 KiB of class ‘numeric’)>
Expression E:
{
    a * b * c * d * e
}
[16:05:04.498] getGlobalsAndPackages() ...
[16:05:04.498] Searching for globals...
[16:05:04.499] - globals found: [7] ‘{’, ‘*’, ‘a’, ‘b’, ‘c’, ‘d’, ‘e’
[16:05:04.499] Searching for globals ... DONE
[16:05:04.499] Resolving globals: FALSE
[16:05:04.500] The total size of the 5 globals is 13.52 KiB (13848 bytes)
[16:05:04.500] The total size of the 5 globals exported for future expression (‘{; a * b * c * d * e; }’) is 13.52 KiB.. This exceeds the maximum allowed size of 3.95 KiB (option 'future.globals.maxSize'). The three largest globals are ‘a’ (3.95 KiB of class ‘numeric’), ‘b’ (3.56 KiB of class ‘numeric’) and ‘c’ (3.17 KiB of class ‘numeric’)
<simpleError in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,     globals = globals): The total size of the 5 globals exported for future expression (‘{; a * b * c * d * e; }’) is 13.52 KiB.. This exceeds the maximum allowed size of 3.95 KiB (option 'future.globals.maxSize'). The three largest globals are ‘a’ (3.95 KiB of class ‘numeric’), ‘b’ (3.56 KiB of class ‘numeric’) and ‘c’ (3.17 KiB of class ‘numeric’)>
> 
> message("*** Globals - too large ... DONE")
*** Globals - too large ... DONE
> 
> source("incl/end.R")
[16:05:04.501] plan(): Setting new future strategy stack:
[16:05:04.501] List of future strategies:
[16:05:04.501] 1. FutureStrategy:
[16:05:04.501]    - args: function (..., envir = parent.frame())
[16:05:04.501]    - tweaked: FALSE
[16:05:04.501]    - call: future::plan(oplan)
[16:05:04.502] plan(): nbrOfWorkers() = 1
> 
