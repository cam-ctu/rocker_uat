
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[10:26:01.720] plan(): Setting new future strategy stack:
[10:26:01.721] List of future strategies:
[10:26:01.721] 1. sequential:
[10:26:01.721]    - args: function (..., envir = parent.frame())
[10:26:01.721]    - tweaked: FALSE
[10:26:01.721]    - call: future::plan("sequential")
[10:26:01.735] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> message("*** Globals w/ non-standard evaluation (NSE) ...")
*** Globals w/ non-standard evaluation (NSE) ...
> 
> data <- data.frame(x = 1:5, y = 1:5)
> v0 <- subset(data, x < 3)$y
> 
> for (strategy in supportedStrategies()) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("- Strategy: %s ...", strategy))
+   
+   plan(strategy)
+ 
+   ## Assert option is passed on to future
+   options(future.globals.onMissing = "error")
+   opt1 %<-% getOption("future.globals.onMissing")
+   stopifnot(identical(opt1, "error"))
+ 
+   options(future.globals.onMissing = "ignore")
+   opt2 %<-% getOption("future.globals.onMissing")
+   stopifnot(identical(opt2, "ignore"))
+ 
+   options(future.globals.onMissing = "error")
+   res <- try({ v1 %<-% subset(data, x < 3)$y }, silent = TRUE)
+   stopifnot(inherits(res, "try-error"))
+ 
+   options(future.globals.onMissing = "ignore")
+   v2 %<-% subset(data, x < 3)$y
+   stopifnot(identical(v2, v0))
+ 
+   ## Nested futures (requires option is passed on to future)
+   plan(list(sequential, strategy))
+   options(future.globals.onMissing = "ignore")
+   v3 %<-% {
+     a %<-% subset(data, x < 3)$y
+     a
+   } %lazy% TRUE
+   stopifnot(identical(v3, v0))
+ 
+   message(sprintf("- Strategy: %s ... DONE", strategy))
+ }
- Strategy: sequential ...
[10:26:01.764] plan(): Setting new future strategy stack:
[10:26:01.764] List of future strategies:
[10:26:01.764] 1. sequential:
[10:26:01.764]    - args: function (..., envir = parent.frame())
[10:26:01.764]    - tweaked: FALSE
[10:26:01.764]    - call: plan(strategy)
[10:26:01.776] plan(): nbrOfWorkers() = 1
[10:26:01.778] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:01.778] Searching for globals...
[10:26:01.782] - globals found: [1] ‘getOption’
[10:26:01.782] Searching for globals ... DONE
[10:26:01.782] Resolving globals: FALSE
[10:26:01.783] 
[10:26:01.783] 
[10:26:01.783] getGlobalsAndPackages() ... DONE
[10:26:01.783] run() for ‘Future’ ...
[10:26:01.784] - state: ‘created’
[10:26:01.784] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:01.784] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:01.784] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:01.784]   - Field: ‘label’
[10:26:01.784]   - Field: ‘local’
[10:26:01.784]   - Field: ‘owner’
[10:26:01.785]   - Field: ‘envir’
[10:26:01.785]   - Field: ‘packages’
[10:26:01.785]   - Field: ‘gc’
[10:26:01.785]   - Field: ‘conditions’
[10:26:01.785]   - Field: ‘expr’
[10:26:01.785]   - Field: ‘uuid’
[10:26:01.785]   - Field: ‘seed’
[10:26:01.785]   - Field: ‘version’
[10:26:01.785]   - Field: ‘result’
[10:26:01.785]   - Field: ‘asynchronous’
[10:26:01.786]   - Field: ‘calls’
[10:26:01.786]   - Field: ‘globals’
[10:26:01.786]   - Field: ‘stdout’
[10:26:01.786]   - Field: ‘earlySignal’
[10:26:01.786]   - Field: ‘lazy’
[10:26:01.786]   - Field: ‘state’
[10:26:01.786] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:01.786] - Launch lazy future ...
[10:26:01.787] Packages needed by the future expression (n = 0): <none>
[10:26:01.787] Packages needed by future strategies (n = 0): <none>
[10:26:01.788] {
[10:26:01.788]     {
[10:26:01.788]         {
[10:26:01.788]             ...future.startTime <- base::Sys.time()
[10:26:01.788]             {
[10:26:01.788]                 {
[10:26:01.788]                   {
[10:26:01.788]                     base::local({
[10:26:01.788]                       has_future <- base::requireNamespace("future", 
[10:26:01.788]                         quietly = TRUE)
[10:26:01.788]                       if (has_future) {
[10:26:01.788]                         ns <- base::getNamespace("future")
[10:26:01.788]                         version <- ns[[".package"]][["version"]]
[10:26:01.788]                         if (is.null(version)) 
[10:26:01.788]                           version <- utils::packageVersion("future")
[10:26:01.788]                       }
[10:26:01.788]                       else {
[10:26:01.788]                         version <- NULL
[10:26:01.788]                       }
[10:26:01.788]                       if (!has_future || version < "1.8.0") {
[10:26:01.788]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:01.788]                           "", base::R.version$version.string), 
[10:26:01.788]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:01.788]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:01.788]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:01.788]                             "release", "version")], collapse = " "), 
[10:26:01.788]                           hostname = base::Sys.info()[["nodename"]])
[10:26:01.788]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:01.788]                           info)
[10:26:01.788]                         info <- base::paste(info, collapse = "; ")
[10:26:01.788]                         if (!has_future) {
[10:26:01.788]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:01.788]                             info)
[10:26:01.788]                         }
[10:26:01.788]                         else {
[10:26:01.788]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:01.788]                             info, version)
[10:26:01.788]                         }
[10:26:01.788]                         base::stop(msg)
[10:26:01.788]                       }
[10:26:01.788]                     })
[10:26:01.788]                   }
[10:26:01.788]                   options(future.plan = NULL)
[10:26:01.788]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:01.788]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:01.788]                 }
[10:26:01.788]                 ...future.workdir <- getwd()
[10:26:01.788]             }
[10:26:01.788]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:01.788]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:01.788]         }
[10:26:01.788]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:01.788]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:01.788]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:01.788]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:01.788]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:01.788]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:01.788]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:01.788]             base::names(...future.oldOptions))
[10:26:01.788]     }
[10:26:01.788]     if (FALSE) {
[10:26:01.788]     }
[10:26:01.788]     else {
[10:26:01.788]         if (TRUE) {
[10:26:01.788]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:01.788]                 open = "w")
[10:26:01.788]         }
[10:26:01.788]         else {
[10:26:01.788]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:01.788]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:01.788]         }
[10:26:01.788]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:01.788]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:01.788]             base::sink(type = "output", split = FALSE)
[10:26:01.788]             base::close(...future.stdout)
[10:26:01.788]         }, add = TRUE)
[10:26:01.788]     }
[10:26:01.788]     ...future.frame <- base::sys.nframe()
[10:26:01.788]     ...future.conditions <- base::list()
[10:26:01.788]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:01.788]     if (FALSE) {
[10:26:01.788]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:01.788]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:01.788]     }
[10:26:01.788]     ...future.result <- base::tryCatch({
[10:26:01.788]         base::withCallingHandlers({
[10:26:01.788]             ...future.value <- base::withVisible(base::local(getOption("future.globals.onMissing")))
[10:26:01.788]             future::FutureResult(value = ...future.value$value, 
[10:26:01.788]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:01.788]                   ...future.rng), globalenv = if (FALSE) 
[10:26:01.788]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:01.788]                     ...future.globalenv.names))
[10:26:01.788]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:01.788]         }, condition = base::local({
[10:26:01.788]             c <- base::c
[10:26:01.788]             inherits <- base::inherits
[10:26:01.788]             invokeRestart <- base::invokeRestart
[10:26:01.788]             length <- base::length
[10:26:01.788]             list <- base::list
[10:26:01.788]             seq.int <- base::seq.int
[10:26:01.788]             signalCondition <- base::signalCondition
[10:26:01.788]             sys.calls <- base::sys.calls
[10:26:01.788]             `[[` <- base::`[[`
[10:26:01.788]             `+` <- base::`+`
[10:26:01.788]             `<<-` <- base::`<<-`
[10:26:01.788]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:01.788]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:01.788]                   3L)]
[10:26:01.788]             }
[10:26:01.788]             function(cond) {
[10:26:01.788]                 is_error <- inherits(cond, "error")
[10:26:01.788]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:01.788]                   NULL)
[10:26:01.788]                 if (is_error) {
[10:26:01.788]                   sessionInformation <- function() {
[10:26:01.788]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:01.788]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:01.788]                       search = base::search(), system = base::Sys.info())
[10:26:01.788]                   }
[10:26:01.788]                   ...future.conditions[[length(...future.conditions) + 
[10:26:01.788]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:01.788]                     cond$call), session = sessionInformation(), 
[10:26:01.788]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:01.788]                   signalCondition(cond)
[10:26:01.788]                 }
[10:26:01.788]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:01.788]                 "immediateCondition"))) {
[10:26:01.788]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:01.788]                   ...future.conditions[[length(...future.conditions) + 
[10:26:01.788]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:01.788]                   if (TRUE && !signal) {
[10:26:01.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:01.788]                     {
[10:26:01.788]                       inherits <- base::inherits
[10:26:01.788]                       invokeRestart <- base::invokeRestart
[10:26:01.788]                       is.null <- base::is.null
[10:26:01.788]                       muffled <- FALSE
[10:26:01.788]                       if (inherits(cond, "message")) {
[10:26:01.788]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:01.788]                         if (muffled) 
[10:26:01.788]                           invokeRestart("muffleMessage")
[10:26:01.788]                       }
[10:26:01.788]                       else if (inherits(cond, "warning")) {
[10:26:01.788]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:01.788]                         if (muffled) 
[10:26:01.788]                           invokeRestart("muffleWarning")
[10:26:01.788]                       }
[10:26:01.788]                       else if (inherits(cond, "condition")) {
[10:26:01.788]                         if (!is.null(pattern)) {
[10:26:01.788]                           computeRestarts <- base::computeRestarts
[10:26:01.788]                           grepl <- base::grepl
[10:26:01.788]                           restarts <- computeRestarts(cond)
[10:26:01.788]                           for (restart in restarts) {
[10:26:01.788]                             name <- restart$name
[10:26:01.788]                             if (is.null(name)) 
[10:26:01.788]                               next
[10:26:01.788]                             if (!grepl(pattern, name)) 
[10:26:01.788]                               next
[10:26:01.788]                             invokeRestart(restart)
[10:26:01.788]                             muffled <- TRUE
[10:26:01.788]                             break
[10:26:01.788]                           }
[10:26:01.788]                         }
[10:26:01.788]                       }
[10:26:01.788]                       invisible(muffled)
[10:26:01.788]                     }
[10:26:01.788]                     muffleCondition(cond, pattern = "^muffle")
[10:26:01.788]                   }
[10:26:01.788]                 }
[10:26:01.788]                 else {
[10:26:01.788]                   if (TRUE) {
[10:26:01.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:01.788]                     {
[10:26:01.788]                       inherits <- base::inherits
[10:26:01.788]                       invokeRestart <- base::invokeRestart
[10:26:01.788]                       is.null <- base::is.null
[10:26:01.788]                       muffled <- FALSE
[10:26:01.788]                       if (inherits(cond, "message")) {
[10:26:01.788]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:01.788]                         if (muffled) 
[10:26:01.788]                           invokeRestart("muffleMessage")
[10:26:01.788]                       }
[10:26:01.788]                       else if (inherits(cond, "warning")) {
[10:26:01.788]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:01.788]                         if (muffled) 
[10:26:01.788]                           invokeRestart("muffleWarning")
[10:26:01.788]                       }
[10:26:01.788]                       else if (inherits(cond, "condition")) {
[10:26:01.788]                         if (!is.null(pattern)) {
[10:26:01.788]                           computeRestarts <- base::computeRestarts
[10:26:01.788]                           grepl <- base::grepl
[10:26:01.788]                           restarts <- computeRestarts(cond)
[10:26:01.788]                           for (restart in restarts) {
[10:26:01.788]                             name <- restart$name
[10:26:01.788]                             if (is.null(name)) 
[10:26:01.788]                               next
[10:26:01.788]                             if (!grepl(pattern, name)) 
[10:26:01.788]                               next
[10:26:01.788]                             invokeRestart(restart)
[10:26:01.788]                             muffled <- TRUE
[10:26:01.788]                             break
[10:26:01.788]                           }
[10:26:01.788]                         }
[10:26:01.788]                       }
[10:26:01.788]                       invisible(muffled)
[10:26:01.788]                     }
[10:26:01.788]                     muffleCondition(cond, pattern = "^muffle")
[10:26:01.788]                   }
[10:26:01.788]                 }
[10:26:01.788]             }
[10:26:01.788]         }))
[10:26:01.788]     }, error = function(ex) {
[10:26:01.788]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:01.788]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:01.788]                 ...future.rng), started = ...future.startTime, 
[10:26:01.788]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:01.788]             version = "1.8"), class = "FutureResult")
[10:26:01.788]     }, finally = {
[10:26:01.788]         if (!identical(...future.workdir, getwd())) 
[10:26:01.788]             setwd(...future.workdir)
[10:26:01.788]         {
[10:26:01.788]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:01.788]                 ...future.oldOptions$nwarnings <- NULL
[10:26:01.788]             }
[10:26:01.788]             base::options(...future.oldOptions)
[10:26:01.788]             if (.Platform$OS.type == "windows") {
[10:26:01.788]                 old_names <- names(...future.oldEnvVars)
[10:26:01.788]                 envs <- base::Sys.getenv()
[10:26:01.788]                 names <- names(envs)
[10:26:01.788]                 common <- intersect(names, old_names)
[10:26:01.788]                 added <- setdiff(names, old_names)
[10:26:01.788]                 removed <- setdiff(old_names, names)
[10:26:01.788]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:01.788]                   envs[common]]
[10:26:01.788]                 NAMES <- toupper(changed)
[10:26:01.788]                 args <- list()
[10:26:01.788]                 for (kk in seq_along(NAMES)) {
[10:26:01.788]                   name <- changed[[kk]]
[10:26:01.788]                   NAME <- NAMES[[kk]]
[10:26:01.788]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:01.788]                     next
[10:26:01.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:01.788]                 }
[10:26:01.788]                 NAMES <- toupper(added)
[10:26:01.788]                 for (kk in seq_along(NAMES)) {
[10:26:01.788]                   name <- added[[kk]]
[10:26:01.788]                   NAME <- NAMES[[kk]]
[10:26:01.788]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:01.788]                     next
[10:26:01.788]                   args[[name]] <- ""
[10:26:01.788]                 }
[10:26:01.788]                 NAMES <- toupper(removed)
[10:26:01.788]                 for (kk in seq_along(NAMES)) {
[10:26:01.788]                   name <- removed[[kk]]
[10:26:01.788]                   NAME <- NAMES[[kk]]
[10:26:01.788]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:01.788]                     next
[10:26:01.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:01.788]                 }
[10:26:01.788]                 if (length(args) > 0) 
[10:26:01.788]                   base::do.call(base::Sys.setenv, args = args)
[10:26:01.788]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:01.788]             }
[10:26:01.788]             else {
[10:26:01.788]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:01.788]             }
[10:26:01.788]             {
[10:26:01.788]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:01.788]                   0L) {
[10:26:01.788]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:01.788]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:01.788]                   base::options(opts)
[10:26:01.788]                 }
[10:26:01.788]                 {
[10:26:01.788]                   {
[10:26:01.788]                     NULL
[10:26:01.788]                     RNGkind("Mersenne-Twister")
[10:26:01.788]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:01.788]                       inherits = FALSE)
[10:26:01.788]                   }
[10:26:01.788]                   options(future.plan = NULL)
[10:26:01.788]                   if (is.na(NA_character_)) 
[10:26:01.788]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:01.788]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:01.788]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:01.788]                   {
[10:26:01.788]                     future <- SequentialFuture(..., envir = envir)
[10:26:01.788]                     if (!future$lazy) 
[10:26:01.788]                       future <- run(future)
[10:26:01.788]                     invisible(future)
[10:26:01.788]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:01.788]                 }
[10:26:01.788]             }
[10:26:01.788]         }
[10:26:01.788]     })
[10:26:01.788]     if (TRUE) {
[10:26:01.788]         base::sink(type = "output", split = FALSE)
[10:26:01.788]         if (TRUE) {
[10:26:01.788]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:01.788]         }
[10:26:01.788]         else {
[10:26:01.788]             ...future.result["stdout"] <- base::list(NULL)
[10:26:01.788]         }
[10:26:01.788]         base::close(...future.stdout)
[10:26:01.788]         ...future.stdout <- NULL
[10:26:01.788]     }
[10:26:01.788]     ...future.result$conditions <- ...future.conditions
[10:26:01.788]     ...future.result$finished <- base::Sys.time()
[10:26:01.788]     ...future.result
[10:26:01.788] }
[10:26:01.790] plan(): Setting new future strategy stack:
[10:26:01.790] List of future strategies:
[10:26:01.790] 1. sequential:
[10:26:01.790]    - args: function (..., envir = parent.frame())
[10:26:01.790]    - tweaked: FALSE
[10:26:01.790]    - call: NULL
[10:26:01.790] plan(): nbrOfWorkers() = 1
[10:26:01.791] plan(): Setting new future strategy stack:
[10:26:01.791] List of future strategies:
[10:26:01.791] 1. sequential:
[10:26:01.791]    - args: function (..., envir = parent.frame())
[10:26:01.791]    - tweaked: FALSE
[10:26:01.791]    - call: plan(strategy)
[10:26:01.792] plan(): nbrOfWorkers() = 1
[10:26:01.792] SequentialFuture started (and completed)
[10:26:01.792] - Launch lazy future ... done
[10:26:01.792] run() for ‘SequentialFuture’ ... done
[10:26:01.793] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[10:26:01.793] Searching for globals...
[10:26:01.794] - globals found: [1] ‘getOption’
[10:26:01.794] Searching for globals ... DONE
[10:26:01.794] Resolving globals: FALSE
[10:26:01.794] 
[10:26:01.794] 
[10:26:01.794] getGlobalsAndPackages() ... DONE
[10:26:01.794] run() for ‘Future’ ...
[10:26:01.795] - state: ‘created’
[10:26:01.795] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:01.795] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:01.795] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:01.795]   - Field: ‘label’
[10:26:01.795]   - Field: ‘local’
[10:26:01.795]   - Field: ‘owner’
[10:26:01.795]   - Field: ‘envir’
[10:26:01.795]   - Field: ‘packages’
[10:26:01.796]   - Field: ‘gc’
[10:26:01.796]   - Field: ‘conditions’
[10:26:01.796]   - Field: ‘expr’
[10:26:01.796]   - Field: ‘uuid’
[10:26:01.796]   - Field: ‘seed’
[10:26:01.796]   - Field: ‘version’
[10:26:01.796]   - Field: ‘result’
[10:26:01.796]   - Field: ‘asynchronous’
[10:26:01.796]   - Field: ‘calls’
[10:26:01.796]   - Field: ‘globals’
[10:26:01.796]   - Field: ‘stdout’
[10:26:01.797]   - Field: ‘earlySignal’
[10:26:01.797]   - Field: ‘lazy’
[10:26:01.797]   - Field: ‘state’
[10:26:01.797] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:01.797] - Launch lazy future ...
[10:26:01.797] Packages needed by the future expression (n = 0): <none>
[10:26:01.797] Packages needed by future strategies (n = 0): <none>
[10:26:01.798] {
[10:26:01.798]     {
[10:26:01.798]         {
[10:26:01.798]             ...future.startTime <- base::Sys.time()
[10:26:01.798]             {
[10:26:01.798]                 {
[10:26:01.798]                   {
[10:26:01.798]                     base::local({
[10:26:01.798]                       has_future <- base::requireNamespace("future", 
[10:26:01.798]                         quietly = TRUE)
[10:26:01.798]                       if (has_future) {
[10:26:01.798]                         ns <- base::getNamespace("future")
[10:26:01.798]                         version <- ns[[".package"]][["version"]]
[10:26:01.798]                         if (is.null(version)) 
[10:26:01.798]                           version <- utils::packageVersion("future")
[10:26:01.798]                       }
[10:26:01.798]                       else {
[10:26:01.798]                         version <- NULL
[10:26:01.798]                       }
[10:26:01.798]                       if (!has_future || version < "1.8.0") {
[10:26:01.798]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:01.798]                           "", base::R.version$version.string), 
[10:26:01.798]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:01.798]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:01.798]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:01.798]                             "release", "version")], collapse = " "), 
[10:26:01.798]                           hostname = base::Sys.info()[["nodename"]])
[10:26:01.798]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:01.798]                           info)
[10:26:01.798]                         info <- base::paste(info, collapse = "; ")
[10:26:01.798]                         if (!has_future) {
[10:26:01.798]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:01.798]                             info)
[10:26:01.798]                         }
[10:26:01.798]                         else {
[10:26:01.798]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:01.798]                             info, version)
[10:26:01.798]                         }
[10:26:01.798]                         base::stop(msg)
[10:26:01.798]                       }
[10:26:01.798]                     })
[10:26:01.798]                   }
[10:26:01.798]                   options(future.plan = NULL)
[10:26:01.798]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:01.798]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:01.798]                 }
[10:26:01.798]                 ...future.workdir <- getwd()
[10:26:01.798]             }
[10:26:01.798]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:01.798]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:01.798]         }
[10:26:01.798]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[10:26:01.798]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:01.798]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[10:26:01.798]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:01.798]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:01.798]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:01.798]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:01.798]             base::names(...future.oldOptions))
[10:26:01.798]     }
[10:26:01.798]     if (FALSE) {
[10:26:01.798]     }
[10:26:01.798]     else {
[10:26:01.798]         if (TRUE) {
[10:26:01.798]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:01.798]                 open = "w")
[10:26:01.798]         }
[10:26:01.798]         else {
[10:26:01.798]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:01.798]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:01.798]         }
[10:26:01.798]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:01.798]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:01.798]             base::sink(type = "output", split = FALSE)
[10:26:01.798]             base::close(...future.stdout)
[10:26:01.798]         }, add = TRUE)
[10:26:01.798]     }
[10:26:01.798]     ...future.frame <- base::sys.nframe()
[10:26:01.798]     ...future.conditions <- base::list()
[10:26:01.798]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:01.798]     if (FALSE) {
[10:26:01.798]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:01.798]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:01.798]     }
[10:26:01.798]     ...future.result <- base::tryCatch({
[10:26:01.798]         base::withCallingHandlers({
[10:26:01.798]             ...future.value <- base::withVisible(base::local(getOption("future.globals.onMissing")))
[10:26:01.798]             future::FutureResult(value = ...future.value$value, 
[10:26:01.798]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:01.798]                   ...future.rng), globalenv = if (FALSE) 
[10:26:01.798]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:01.798]                     ...future.globalenv.names))
[10:26:01.798]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:01.798]         }, condition = base::local({
[10:26:01.798]             c <- base::c
[10:26:01.798]             inherits <- base::inherits
[10:26:01.798]             invokeRestart <- base::invokeRestart
[10:26:01.798]             length <- base::length
[10:26:01.798]             list <- base::list
[10:26:01.798]             seq.int <- base::seq.int
[10:26:01.798]             signalCondition <- base::signalCondition
[10:26:01.798]             sys.calls <- base::sys.calls
[10:26:01.798]             `[[` <- base::`[[`
[10:26:01.798]             `+` <- base::`+`
[10:26:01.798]             `<<-` <- base::`<<-`
[10:26:01.798]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:01.798]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:01.798]                   3L)]
[10:26:01.798]             }
[10:26:01.798]             function(cond) {
[10:26:01.798]                 is_error <- inherits(cond, "error")
[10:26:01.798]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:01.798]                   NULL)
[10:26:01.798]                 if (is_error) {
[10:26:01.798]                   sessionInformation <- function() {
[10:26:01.798]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:01.798]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:01.798]                       search = base::search(), system = base::Sys.info())
[10:26:01.798]                   }
[10:26:01.798]                   ...future.conditions[[length(...future.conditions) + 
[10:26:01.798]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:01.798]                     cond$call), session = sessionInformation(), 
[10:26:01.798]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:01.798]                   signalCondition(cond)
[10:26:01.798]                 }
[10:26:01.798]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:01.798]                 "immediateCondition"))) {
[10:26:01.798]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:01.798]                   ...future.conditions[[length(...future.conditions) + 
[10:26:01.798]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:01.798]                   if (TRUE && !signal) {
[10:26:01.798]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:01.798]                     {
[10:26:01.798]                       inherits <- base::inherits
[10:26:01.798]                       invokeRestart <- base::invokeRestart
[10:26:01.798]                       is.null <- base::is.null
[10:26:01.798]                       muffled <- FALSE
[10:26:01.798]                       if (inherits(cond, "message")) {
[10:26:01.798]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:01.798]                         if (muffled) 
[10:26:01.798]                           invokeRestart("muffleMessage")
[10:26:01.798]                       }
[10:26:01.798]                       else if (inherits(cond, "warning")) {
[10:26:01.798]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:01.798]                         if (muffled) 
[10:26:01.798]                           invokeRestart("muffleWarning")
[10:26:01.798]                       }
[10:26:01.798]                       else if (inherits(cond, "condition")) {
[10:26:01.798]                         if (!is.null(pattern)) {
[10:26:01.798]                           computeRestarts <- base::computeRestarts
[10:26:01.798]                           grepl <- base::grepl
[10:26:01.798]                           restarts <- computeRestarts(cond)
[10:26:01.798]                           for (restart in restarts) {
[10:26:01.798]                             name <- restart$name
[10:26:01.798]                             if (is.null(name)) 
[10:26:01.798]                               next
[10:26:01.798]                             if (!grepl(pattern, name)) 
[10:26:01.798]                               next
[10:26:01.798]                             invokeRestart(restart)
[10:26:01.798]                             muffled <- TRUE
[10:26:01.798]                             break
[10:26:01.798]                           }
[10:26:01.798]                         }
[10:26:01.798]                       }
[10:26:01.798]                       invisible(muffled)
[10:26:01.798]                     }
[10:26:01.798]                     muffleCondition(cond, pattern = "^muffle")
[10:26:01.798]                   }
[10:26:01.798]                 }
[10:26:01.798]                 else {
[10:26:01.798]                   if (TRUE) {
[10:26:01.798]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:01.798]                     {
[10:26:01.798]                       inherits <- base::inherits
[10:26:01.798]                       invokeRestart <- base::invokeRestart
[10:26:01.798]                       is.null <- base::is.null
[10:26:01.798]                       muffled <- FALSE
[10:26:01.798]                       if (inherits(cond, "message")) {
[10:26:01.798]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:01.798]                         if (muffled) 
[10:26:01.798]                           invokeRestart("muffleMessage")
[10:26:01.798]                       }
[10:26:01.798]                       else if (inherits(cond, "warning")) {
[10:26:01.798]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:01.798]                         if (muffled) 
[10:26:01.798]                           invokeRestart("muffleWarning")
[10:26:01.798]                       }
[10:26:01.798]                       else if (inherits(cond, "condition")) {
[10:26:01.798]                         if (!is.null(pattern)) {
[10:26:01.798]                           computeRestarts <- base::computeRestarts
[10:26:01.798]                           grepl <- base::grepl
[10:26:01.798]                           restarts <- computeRestarts(cond)
[10:26:01.798]                           for (restart in restarts) {
[10:26:01.798]                             name <- restart$name
[10:26:01.798]                             if (is.null(name)) 
[10:26:01.798]                               next
[10:26:01.798]                             if (!grepl(pattern, name)) 
[10:26:01.798]                               next
[10:26:01.798]                             invokeRestart(restart)
[10:26:01.798]                             muffled <- TRUE
[10:26:01.798]                             break
[10:26:01.798]                           }
[10:26:01.798]                         }
[10:26:01.798]                       }
[10:26:01.798]                       invisible(muffled)
[10:26:01.798]                     }
[10:26:01.798]                     muffleCondition(cond, pattern = "^muffle")
[10:26:01.798]                   }
[10:26:01.798]                 }
[10:26:01.798]             }
[10:26:01.798]         }))
[10:26:01.798]     }, error = function(ex) {
[10:26:01.798]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:01.798]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:01.798]                 ...future.rng), started = ...future.startTime, 
[10:26:01.798]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:01.798]             version = "1.8"), class = "FutureResult")
[10:26:01.798]     }, finally = {
[10:26:01.798]         if (!identical(...future.workdir, getwd())) 
[10:26:01.798]             setwd(...future.workdir)
[10:26:01.798]         {
[10:26:01.798]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:01.798]                 ...future.oldOptions$nwarnings <- NULL
[10:26:01.798]             }
[10:26:01.798]             base::options(...future.oldOptions)
[10:26:01.798]             if (.Platform$OS.type == "windows") {
[10:26:01.798]                 old_names <- names(...future.oldEnvVars)
[10:26:01.798]                 envs <- base::Sys.getenv()
[10:26:01.798]                 names <- names(envs)
[10:26:01.798]                 common <- intersect(names, old_names)
[10:26:01.798]                 added <- setdiff(names, old_names)
[10:26:01.798]                 removed <- setdiff(old_names, names)
[10:26:01.798]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:01.798]                   envs[common]]
[10:26:01.798]                 NAMES <- toupper(changed)
[10:26:01.798]                 args <- list()
[10:26:01.798]                 for (kk in seq_along(NAMES)) {
[10:26:01.798]                   name <- changed[[kk]]
[10:26:01.798]                   NAME <- NAMES[[kk]]
[10:26:01.798]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:01.798]                     next
[10:26:01.798]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:01.798]                 }
[10:26:01.798]                 NAMES <- toupper(added)
[10:26:01.798]                 for (kk in seq_along(NAMES)) {
[10:26:01.798]                   name <- added[[kk]]
[10:26:01.798]                   NAME <- NAMES[[kk]]
[10:26:01.798]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:01.798]                     next
[10:26:01.798]                   args[[name]] <- ""
[10:26:01.798]                 }
[10:26:01.798]                 NAMES <- toupper(removed)
[10:26:01.798]                 for (kk in seq_along(NAMES)) {
[10:26:01.798]                   name <- removed[[kk]]
[10:26:01.798]                   NAME <- NAMES[[kk]]
[10:26:01.798]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:01.798]                     next
[10:26:01.798]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:01.798]                 }
[10:26:01.798]                 if (length(args) > 0) 
[10:26:01.798]                   base::do.call(base::Sys.setenv, args = args)
[10:26:01.798]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:01.798]             }
[10:26:01.798]             else {
[10:26:01.798]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:01.798]             }
[10:26:01.798]             {
[10:26:01.798]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:01.798]                   0L) {
[10:26:01.798]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:01.798]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:01.798]                   base::options(opts)
[10:26:01.798]                 }
[10:26:01.798]                 {
[10:26:01.798]                   {
[10:26:01.798]                     NULL
[10:26:01.798]                     RNGkind("Mersenne-Twister")
[10:26:01.798]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:01.798]                       inherits = FALSE)
[10:26:01.798]                   }
[10:26:01.798]                   options(future.plan = NULL)
[10:26:01.798]                   if (is.na(NA_character_)) 
[10:26:01.798]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:01.798]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:01.798]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:01.798]                   {
[10:26:01.798]                     future <- SequentialFuture(..., envir = envir)
[10:26:01.798]                     if (!future$lazy) 
[10:26:01.798]                       future <- run(future)
[10:26:01.798]                     invisible(future)
[10:26:01.798]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:01.798]                 }
[10:26:01.798]             }
[10:26:01.798]         }
[10:26:01.798]     })
[10:26:01.798]     if (TRUE) {
[10:26:01.798]         base::sink(type = "output", split = FALSE)
[10:26:01.798]         if (TRUE) {
[10:26:01.798]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:01.798]         }
[10:26:01.798]         else {
[10:26:01.798]             ...future.result["stdout"] <- base::list(NULL)
[10:26:01.798]         }
[10:26:01.798]         base::close(...future.stdout)
[10:26:01.798]         ...future.stdout <- NULL
[10:26:01.798]     }
[10:26:01.798]     ...future.result$conditions <- ...future.conditions
[10:26:01.798]     ...future.result$finished <- base::Sys.time()
[10:26:01.798]     ...future.result
[10:26:01.798] }
[10:26:01.799] plan(): Setting new future strategy stack:
[10:26:01.799] List of future strategies:
[10:26:01.799] 1. sequential:
[10:26:01.799]    - args: function (..., envir = parent.frame())
[10:26:01.799]    - tweaked: FALSE
[10:26:01.799]    - call: NULL
[10:26:01.800] plan(): nbrOfWorkers() = 1
[10:26:01.800] plan(): Setting new future strategy stack:
[10:26:01.800] List of future strategies:
[10:26:01.800] 1. sequential:
[10:26:01.800]    - args: function (..., envir = parent.frame())
[10:26:01.800]    - tweaked: FALSE
[10:26:01.800]    - call: plan(strategy)
[10:26:01.801] plan(): nbrOfWorkers() = 1
[10:26:01.801] SequentialFuture started (and completed)
[10:26:01.801] - Launch lazy future ... done
[10:26:01.801] run() for ‘SequentialFuture’ ... done
[10:26:01.801] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:01.802] Searching for globals...
[10:26:01.803] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[10:26:01.803] Searching for globals...
[10:26:01.804] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[10:26:01.804] Searching for globals ... DONE
[10:26:01.804] Resolving globals: FALSE
[10:26:01.807] The total size of the 1 globals is 160 bytes (160 bytes)
[10:26:01.807] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 160 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (160 bytes of class ‘list’)
[10:26:01.807] - globals: [1] ‘data’
[10:26:01.807] 
[10:26:01.808] getGlobalsAndPackages() ... DONE
[10:26:01.808] run() for ‘Future’ ...
[10:26:01.808] - state: ‘created’
[10:26:01.808] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:01.808] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:01.808] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:01.808]   - Field: ‘label’
[10:26:01.809]   - Field: ‘local’
[10:26:01.809]   - Field: ‘owner’
[10:26:01.809]   - Field: ‘envir’
[10:26:01.809]   - Field: ‘packages’
[10:26:01.809]   - Field: ‘gc’
[10:26:01.809]   - Field: ‘conditions’
[10:26:01.809]   - Field: ‘expr’
[10:26:01.809]   - Field: ‘uuid’
[10:26:01.809]   - Field: ‘seed’
[10:26:01.809]   - Field: ‘version’
[10:26:01.809]   - Field: ‘result’
[10:26:01.810]   - Field: ‘asynchronous’
[10:26:01.810]   - Field: ‘calls’
[10:26:01.810]   - Field: ‘globals’
[10:26:01.810]   - Field: ‘stdout’
[10:26:01.810]   - Field: ‘earlySignal’
[10:26:01.810]   - Field: ‘lazy’
[10:26:01.810]   - Field: ‘state’
[10:26:01.810] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:01.810] - Launch lazy future ...
[10:26:01.810] Packages needed by the future expression (n = 0): <none>
[10:26:01.811] Packages needed by future strategies (n = 0): <none>
[10:26:01.811] {
[10:26:01.811]     {
[10:26:01.811]         {
[10:26:01.811]             ...future.startTime <- base::Sys.time()
[10:26:01.811]             {
[10:26:01.811]                 {
[10:26:01.811]                   {
[10:26:01.811]                     base::local({
[10:26:01.811]                       has_future <- base::requireNamespace("future", 
[10:26:01.811]                         quietly = TRUE)
[10:26:01.811]                       if (has_future) {
[10:26:01.811]                         ns <- base::getNamespace("future")
[10:26:01.811]                         version <- ns[[".package"]][["version"]]
[10:26:01.811]                         if (is.null(version)) 
[10:26:01.811]                           version <- utils::packageVersion("future")
[10:26:01.811]                       }
[10:26:01.811]                       else {
[10:26:01.811]                         version <- NULL
[10:26:01.811]                       }
[10:26:01.811]                       if (!has_future || version < "1.8.0") {
[10:26:01.811]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:01.811]                           "", base::R.version$version.string), 
[10:26:01.811]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:01.811]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:01.811]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:01.811]                             "release", "version")], collapse = " "), 
[10:26:01.811]                           hostname = base::Sys.info()[["nodename"]])
[10:26:01.811]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:01.811]                           info)
[10:26:01.811]                         info <- base::paste(info, collapse = "; ")
[10:26:01.811]                         if (!has_future) {
[10:26:01.811]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:01.811]                             info)
[10:26:01.811]                         }
[10:26:01.811]                         else {
[10:26:01.811]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:01.811]                             info, version)
[10:26:01.811]                         }
[10:26:01.811]                         base::stop(msg)
[10:26:01.811]                       }
[10:26:01.811]                     })
[10:26:01.811]                   }
[10:26:01.811]                   options(future.plan = NULL)
[10:26:01.811]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:01.811]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:01.811]                 }
[10:26:01.811]                 ...future.workdir <- getwd()
[10:26:01.811]             }
[10:26:01.811]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:01.811]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:01.811]         }
[10:26:01.811]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[10:26:01.811]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:01.811]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[10:26:01.811]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:01.811]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:01.811]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:01.811]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:01.811]             base::names(...future.oldOptions))
[10:26:01.811]     }
[10:26:01.811]     if (FALSE) {
[10:26:01.811]     }
[10:26:01.811]     else {
[10:26:01.811]         if (TRUE) {
[10:26:01.811]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:01.811]                 open = "w")
[10:26:01.811]         }
[10:26:01.811]         else {
[10:26:01.811]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:01.811]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:01.811]         }
[10:26:01.811]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:01.811]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:01.811]             base::sink(type = "output", split = FALSE)
[10:26:01.811]             base::close(...future.stdout)
[10:26:01.811]         }, add = TRUE)
[10:26:01.811]     }
[10:26:01.811]     ...future.frame <- base::sys.nframe()
[10:26:01.811]     ...future.conditions <- base::list()
[10:26:01.811]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:01.811]     if (FALSE) {
[10:26:01.811]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:01.811]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:01.811]     }
[10:26:01.811]     ...future.result <- base::tryCatch({
[10:26:01.811]         base::withCallingHandlers({
[10:26:01.811]             ...future.value <- base::withVisible(base::local(subset(data, 
[10:26:01.811]                 x < 3)$y))
[10:26:01.811]             future::FutureResult(value = ...future.value$value, 
[10:26:01.811]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:01.811]                   ...future.rng), globalenv = if (FALSE) 
[10:26:01.811]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:01.811]                     ...future.globalenv.names))
[10:26:01.811]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:01.811]         }, condition = base::local({
[10:26:01.811]             c <- base::c
[10:26:01.811]             inherits <- base::inherits
[10:26:01.811]             invokeRestart <- base::invokeRestart
[10:26:01.811]             length <- base::length
[10:26:01.811]             list <- base::list
[10:26:01.811]             seq.int <- base::seq.int
[10:26:01.811]             signalCondition <- base::signalCondition
[10:26:01.811]             sys.calls <- base::sys.calls
[10:26:01.811]             `[[` <- base::`[[`
[10:26:01.811]             `+` <- base::`+`
[10:26:01.811]             `<<-` <- base::`<<-`
[10:26:01.811]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:01.811]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:01.811]                   3L)]
[10:26:01.811]             }
[10:26:01.811]             function(cond) {
[10:26:01.811]                 is_error <- inherits(cond, "error")
[10:26:01.811]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:01.811]                   NULL)
[10:26:01.811]                 if (is_error) {
[10:26:01.811]                   sessionInformation <- function() {
[10:26:01.811]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:01.811]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:01.811]                       search = base::search(), system = base::Sys.info())
[10:26:01.811]                   }
[10:26:01.811]                   ...future.conditions[[length(...future.conditions) + 
[10:26:01.811]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:01.811]                     cond$call), session = sessionInformation(), 
[10:26:01.811]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:01.811]                   signalCondition(cond)
[10:26:01.811]                 }
[10:26:01.811]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:01.811]                 "immediateCondition"))) {
[10:26:01.811]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:01.811]                   ...future.conditions[[length(...future.conditions) + 
[10:26:01.811]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:01.811]                   if (TRUE && !signal) {
[10:26:01.811]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:01.811]                     {
[10:26:01.811]                       inherits <- base::inherits
[10:26:01.811]                       invokeRestart <- base::invokeRestart
[10:26:01.811]                       is.null <- base::is.null
[10:26:01.811]                       muffled <- FALSE
[10:26:01.811]                       if (inherits(cond, "message")) {
[10:26:01.811]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:01.811]                         if (muffled) 
[10:26:01.811]                           invokeRestart("muffleMessage")
[10:26:01.811]                       }
[10:26:01.811]                       else if (inherits(cond, "warning")) {
[10:26:01.811]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:01.811]                         if (muffled) 
[10:26:01.811]                           invokeRestart("muffleWarning")
[10:26:01.811]                       }
[10:26:01.811]                       else if (inherits(cond, "condition")) {
[10:26:01.811]                         if (!is.null(pattern)) {
[10:26:01.811]                           computeRestarts <- base::computeRestarts
[10:26:01.811]                           grepl <- base::grepl
[10:26:01.811]                           restarts <- computeRestarts(cond)
[10:26:01.811]                           for (restart in restarts) {
[10:26:01.811]                             name <- restart$name
[10:26:01.811]                             if (is.null(name)) 
[10:26:01.811]                               next
[10:26:01.811]                             if (!grepl(pattern, name)) 
[10:26:01.811]                               next
[10:26:01.811]                             invokeRestart(restart)
[10:26:01.811]                             muffled <- TRUE
[10:26:01.811]                             break
[10:26:01.811]                           }
[10:26:01.811]                         }
[10:26:01.811]                       }
[10:26:01.811]                       invisible(muffled)
[10:26:01.811]                     }
[10:26:01.811]                     muffleCondition(cond, pattern = "^muffle")
[10:26:01.811]                   }
[10:26:01.811]                 }
[10:26:01.811]                 else {
[10:26:01.811]                   if (TRUE) {
[10:26:01.811]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:01.811]                     {
[10:26:01.811]                       inherits <- base::inherits
[10:26:01.811]                       invokeRestart <- base::invokeRestart
[10:26:01.811]                       is.null <- base::is.null
[10:26:01.811]                       muffled <- FALSE
[10:26:01.811]                       if (inherits(cond, "message")) {
[10:26:01.811]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:01.811]                         if (muffled) 
[10:26:01.811]                           invokeRestart("muffleMessage")
[10:26:01.811]                       }
[10:26:01.811]                       else if (inherits(cond, "warning")) {
[10:26:01.811]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:01.811]                         if (muffled) 
[10:26:01.811]                           invokeRestart("muffleWarning")
[10:26:01.811]                       }
[10:26:01.811]                       else if (inherits(cond, "condition")) {
[10:26:01.811]                         if (!is.null(pattern)) {
[10:26:01.811]                           computeRestarts <- base::computeRestarts
[10:26:01.811]                           grepl <- base::grepl
[10:26:01.811]                           restarts <- computeRestarts(cond)
[10:26:01.811]                           for (restart in restarts) {
[10:26:01.811]                             name <- restart$name
[10:26:01.811]                             if (is.null(name)) 
[10:26:01.811]                               next
[10:26:01.811]                             if (!grepl(pattern, name)) 
[10:26:01.811]                               next
[10:26:01.811]                             invokeRestart(restart)
[10:26:01.811]                             muffled <- TRUE
[10:26:01.811]                             break
[10:26:01.811]                           }
[10:26:01.811]                         }
[10:26:01.811]                       }
[10:26:01.811]                       invisible(muffled)
[10:26:01.811]                     }
[10:26:01.811]                     muffleCondition(cond, pattern = "^muffle")
[10:26:01.811]                   }
[10:26:01.811]                 }
[10:26:01.811]             }
[10:26:01.811]         }))
[10:26:01.811]     }, error = function(ex) {
[10:26:01.811]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:01.811]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:01.811]                 ...future.rng), started = ...future.startTime, 
[10:26:01.811]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:01.811]             version = "1.8"), class = "FutureResult")
[10:26:01.811]     }, finally = {
[10:26:01.811]         if (!identical(...future.workdir, getwd())) 
[10:26:01.811]             setwd(...future.workdir)
[10:26:01.811]         {
[10:26:01.811]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:01.811]                 ...future.oldOptions$nwarnings <- NULL
[10:26:01.811]             }
[10:26:01.811]             base::options(...future.oldOptions)
[10:26:01.811]             if (.Platform$OS.type == "windows") {
[10:26:01.811]                 old_names <- names(...future.oldEnvVars)
[10:26:01.811]                 envs <- base::Sys.getenv()
[10:26:01.811]                 names <- names(envs)
[10:26:01.811]                 common <- intersect(names, old_names)
[10:26:01.811]                 added <- setdiff(names, old_names)
[10:26:01.811]                 removed <- setdiff(old_names, names)
[10:26:01.811]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:01.811]                   envs[common]]
[10:26:01.811]                 NAMES <- toupper(changed)
[10:26:01.811]                 args <- list()
[10:26:01.811]                 for (kk in seq_along(NAMES)) {
[10:26:01.811]                   name <- changed[[kk]]
[10:26:01.811]                   NAME <- NAMES[[kk]]
[10:26:01.811]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:01.811]                     next
[10:26:01.811]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:01.811]                 }
[10:26:01.811]                 NAMES <- toupper(added)
[10:26:01.811]                 for (kk in seq_along(NAMES)) {
[10:26:01.811]                   name <- added[[kk]]
[10:26:01.811]                   NAME <- NAMES[[kk]]
[10:26:01.811]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:01.811]                     next
[10:26:01.811]                   args[[name]] <- ""
[10:26:01.811]                 }
[10:26:01.811]                 NAMES <- toupper(removed)
[10:26:01.811]                 for (kk in seq_along(NAMES)) {
[10:26:01.811]                   name <- removed[[kk]]
[10:26:01.811]                   NAME <- NAMES[[kk]]
[10:26:01.811]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:01.811]                     next
[10:26:01.811]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:01.811]                 }
[10:26:01.811]                 if (length(args) > 0) 
[10:26:01.811]                   base::do.call(base::Sys.setenv, args = args)
[10:26:01.811]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:01.811]             }
[10:26:01.811]             else {
[10:26:01.811]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:01.811]             }
[10:26:01.811]             {
[10:26:01.811]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:01.811]                   0L) {
[10:26:01.811]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:01.811]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:01.811]                   base::options(opts)
[10:26:01.811]                 }
[10:26:01.811]                 {
[10:26:01.811]                   {
[10:26:01.811]                     NULL
[10:26:01.811]                     RNGkind("Mersenne-Twister")
[10:26:01.811]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:01.811]                       inherits = FALSE)
[10:26:01.811]                   }
[10:26:01.811]                   options(future.plan = NULL)
[10:26:01.811]                   if (is.na(NA_character_)) 
[10:26:01.811]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:01.811]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:01.811]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:01.811]                   {
[10:26:01.811]                     future <- SequentialFuture(..., envir = envir)
[10:26:01.811]                     if (!future$lazy) 
[10:26:01.811]                       future <- run(future)
[10:26:01.811]                     invisible(future)
[10:26:01.811]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:01.811]                 }
[10:26:01.811]             }
[10:26:01.811]         }
[10:26:01.811]     })
[10:26:01.811]     if (TRUE) {
[10:26:01.811]         base::sink(type = "output", split = FALSE)
[10:26:01.811]         if (TRUE) {
[10:26:01.811]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:01.811]         }
[10:26:01.811]         else {
[10:26:01.811]             ...future.result["stdout"] <- base::list(NULL)
[10:26:01.811]         }
[10:26:01.811]         base::close(...future.stdout)
[10:26:01.811]         ...future.stdout <- NULL
[10:26:01.811]     }
[10:26:01.811]     ...future.result$conditions <- ...future.conditions
[10:26:01.811]     ...future.result$finished <- base::Sys.time()
[10:26:01.811]     ...future.result
[10:26:01.811] }
[10:26:01.813] assign_globals() ...
[10:26:01.813] List of 1
[10:26:01.813]  $ data:'data.frame':	5 obs. of  2 variables:
[10:26:01.813]   ..$ x: int [1:5] 1 2 3 4 5
[10:26:01.813]   ..$ y: int [1:5] 1 2 3 4 5
[10:26:01.813]  - attr(*, "where")=List of 1
[10:26:01.813]   ..$ data:<environment: R_EmptyEnv> 
[10:26:01.813]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:01.813]  - attr(*, "resolved")= logi FALSE
[10:26:01.813]  - attr(*, "total_size")= num 160
[10:26:01.813]  - attr(*, "already-done")= logi TRUE
[10:26:01.818] - copied ‘data’ to environment
[10:26:01.818] assign_globals() ... done
[10:26:01.818] plan(): Setting new future strategy stack:
[10:26:01.819] List of future strategies:
[10:26:01.819] 1. sequential:
[10:26:01.819]    - args: function (..., envir = parent.frame())
[10:26:01.819]    - tweaked: FALSE
[10:26:01.819]    - call: NULL
[10:26:01.819] plan(): nbrOfWorkers() = 1
[10:26:01.820] plan(): Setting new future strategy stack:
[10:26:01.820] List of future strategies:
[10:26:01.820] 1. sequential:
[10:26:01.820]    - args: function (..., envir = parent.frame())
[10:26:01.820]    - tweaked: FALSE
[10:26:01.820]    - call: plan(strategy)
[10:26:01.820] plan(): nbrOfWorkers() = 1
[10:26:01.820] SequentialFuture started (and completed)
[10:26:01.820] - Launch lazy future ... done
[10:26:01.820] run() for ‘SequentialFuture’ ... done
[10:26:01.821] plan(): Setting new future strategy stack:
[10:26:01.821] List of future strategies:
[10:26:01.821] 1. sequential:
[10:26:01.821]    - args: function (..., envir = parent.frame())
[10:26:01.821]    - tweaked: FALSE
[10:26:01.821]    - call: plan(list(sequential, strategy))
[10:26:01.821] 2. sequential:
[10:26:01.821]    - args: function (..., envir = parent.frame())
[10:26:01.821]    - tweaked: FALSE
[10:26:01.821]    - call: plan(list(sequential, strategy))
[10:26:01.821] plan(): nbrOfWorkers() = 1
[10:26:01.821] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[10:26:01.822] Searching for globals...
[10:26:01.826] - globals found: [8] ‘{’, ‘<-’, ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’, ‘%<-%’
[10:26:01.826] Searching for globals ... DONE
[10:26:01.827] Resolving globals: FALSE
[10:26:01.827] The total size of the 1 globals is 160 bytes (160 bytes)
[10:26:01.827] The total size of the 1 globals exported for future expression (‘{; a %<-% subset(data, x < 3)$y; a; }’) is 160 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (160 bytes of class ‘list’)
[10:26:01.828] - globals: [1] ‘data’
[10:26:01.828] - packages: [1] ‘future’
[10:26:01.828] getGlobalsAndPackages() ... DONE
[10:26:01.828] run() for ‘Future’ ...
[10:26:01.828] - state: ‘created’
[10:26:01.828] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:01.829] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:01.829] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:01.829]   - Field: ‘label’
[10:26:01.829]   - Field: ‘local’
[10:26:01.829]   - Field: ‘owner’
[10:26:01.829]   - Field: ‘envir’
[10:26:01.829]   - Field: ‘packages’
[10:26:01.829]   - Field: ‘gc’
[10:26:01.829]   - Field: ‘conditions’
[10:26:01.829]   - Field: ‘expr’
[10:26:01.830]   - Field: ‘uuid’
[10:26:01.830]   - Field: ‘seed’
[10:26:01.830]   - Field: ‘version’
[10:26:01.830]   - Field: ‘result’
[10:26:01.830]   - Field: ‘asynchronous’
[10:26:01.830]   - Field: ‘calls’
[10:26:01.830]   - Field: ‘globals’
[10:26:01.830]   - Field: ‘stdout’
[10:26:01.830]   - Field: ‘earlySignal’
[10:26:01.830]   - Field: ‘lazy’
[10:26:01.830]   - Field: ‘state’
[10:26:01.831] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:01.831] - Launch lazy future ...
[10:26:01.831] Packages needed by the future expression (n = 1): ‘future’
[10:26:01.831] Packages needed by future strategies (n = 1): ‘future’
[10:26:01.831] {
[10:26:01.831]     {
[10:26:01.831]         {
[10:26:01.831]             ...future.startTime <- base::Sys.time()
[10:26:01.831]             {
[10:26:01.831]                 {
[10:26:01.831]                   {
[10:26:01.831]                     {
[10:26:01.831]                       base::local({
[10:26:01.831]                         has_future <- base::requireNamespace("future", 
[10:26:01.831]                           quietly = TRUE)
[10:26:01.831]                         if (has_future) {
[10:26:01.831]                           ns <- base::getNamespace("future")
[10:26:01.831]                           version <- ns[[".package"]][["version"]]
[10:26:01.831]                           if (is.null(version)) 
[10:26:01.831]                             version <- utils::packageVersion("future")
[10:26:01.831]                         }
[10:26:01.831]                         else {
[10:26:01.831]                           version <- NULL
[10:26:01.831]                         }
[10:26:01.831]                         if (!has_future || version < "1.8.0") {
[10:26:01.831]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:01.831]                             "", base::R.version$version.string), 
[10:26:01.831]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:01.831]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:01.831]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:01.831]                               "release", "version")], collapse = " "), 
[10:26:01.831]                             hostname = base::Sys.info()[["nodename"]])
[10:26:01.831]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:01.831]                             info)
[10:26:01.831]                           info <- base::paste(info, collapse = "; ")
[10:26:01.831]                           if (!has_future) {
[10:26:01.831]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:01.831]                               info)
[10:26:01.831]                           }
[10:26:01.831]                           else {
[10:26:01.831]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:01.831]                               info, version)
[10:26:01.831]                           }
[10:26:01.831]                           base::stop(msg)
[10:26:01.831]                         }
[10:26:01.831]                       })
[10:26:01.831]                     }
[10:26:01.831]                     base::local({
[10:26:01.831]                       for (pkg in "future") {
[10:26:01.831]                         base::loadNamespace(pkg)
[10:26:01.831]                         base::library(pkg, character.only = TRUE)
[10:26:01.831]                       }
[10:26:01.831]                     })
[10:26:01.831]                   }
[10:26:01.831]                   options(future.plan = NULL)
[10:26:01.831]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:01.831]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:01.831]                   {
[10:26:01.831]                     future <- SequentialFuture(..., envir = envir)
[10:26:01.831]                     if (!future$lazy) 
[10:26:01.831]                       future <- run(future)
[10:26:01.831]                     invisible(future)
[10:26:01.831]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:01.831]                 }
[10:26:01.831]                 ...future.workdir <- getwd()
[10:26:01.831]             }
[10:26:01.831]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:01.831]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:01.831]         }
[10:26:01.831]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[10:26:01.831]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:01.831]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[10:26:01.831]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:01.831]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:01.831]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:01.831]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:01.831]             base::names(...future.oldOptions))
[10:26:01.831]     }
[10:26:01.831]     if (FALSE) {
[10:26:01.831]     }
[10:26:01.831]     else {
[10:26:01.831]         if (TRUE) {
[10:26:01.831]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:01.831]                 open = "w")
[10:26:01.831]         }
[10:26:01.831]         else {
[10:26:01.831]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:01.831]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:01.831]         }
[10:26:01.831]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:01.831]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:01.831]             base::sink(type = "output", split = FALSE)
[10:26:01.831]             base::close(...future.stdout)
[10:26:01.831]         }, add = TRUE)
[10:26:01.831]     }
[10:26:01.831]     ...future.frame <- base::sys.nframe()
[10:26:01.831]     ...future.conditions <- base::list()
[10:26:01.831]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:01.831]     if (FALSE) {
[10:26:01.831]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:01.831]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:01.831]     }
[10:26:01.831]     ...future.result <- base::tryCatch({
[10:26:01.831]         base::withCallingHandlers({
[10:26:01.831]             ...future.value <- base::withVisible(base::local({
[10:26:01.831]                 a %<-% subset(data, x < 3)$y
[10:26:01.831]                 a
[10:26:01.831]             }))
[10:26:01.831]             future::FutureResult(value = ...future.value$value, 
[10:26:01.831]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:01.831]                   ...future.rng), globalenv = if (FALSE) 
[10:26:01.831]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:01.831]                     ...future.globalenv.names))
[10:26:01.831]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:01.831]         }, condition = base::local({
[10:26:01.831]             c <- base::c
[10:26:01.831]             inherits <- base::inherits
[10:26:01.831]             invokeRestart <- base::invokeRestart
[10:26:01.831]             length <- base::length
[10:26:01.831]             list <- base::list
[10:26:01.831]             seq.int <- base::seq.int
[10:26:01.831]             signalCondition <- base::signalCondition
[10:26:01.831]             sys.calls <- base::sys.calls
[10:26:01.831]             `[[` <- base::`[[`
[10:26:01.831]             `+` <- base::`+`
[10:26:01.831]             `<<-` <- base::`<<-`
[10:26:01.831]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:01.831]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:01.831]                   3L)]
[10:26:01.831]             }
[10:26:01.831]             function(cond) {
[10:26:01.831]                 is_error <- inherits(cond, "error")
[10:26:01.831]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:01.831]                   NULL)
[10:26:01.831]                 if (is_error) {
[10:26:01.831]                   sessionInformation <- function() {
[10:26:01.831]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:01.831]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:01.831]                       search = base::search(), system = base::Sys.info())
[10:26:01.831]                   }
[10:26:01.831]                   ...future.conditions[[length(...future.conditions) + 
[10:26:01.831]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:01.831]                     cond$call), session = sessionInformation(), 
[10:26:01.831]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:01.831]                   signalCondition(cond)
[10:26:01.831]                 }
[10:26:01.831]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:01.831]                 "immediateCondition"))) {
[10:26:01.831]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:01.831]                   ...future.conditions[[length(...future.conditions) + 
[10:26:01.831]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:01.831]                   if (TRUE && !signal) {
[10:26:01.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:01.831]                     {
[10:26:01.831]                       inherits <- base::inherits
[10:26:01.831]                       invokeRestart <- base::invokeRestart
[10:26:01.831]                       is.null <- base::is.null
[10:26:01.831]                       muffled <- FALSE
[10:26:01.831]                       if (inherits(cond, "message")) {
[10:26:01.831]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:01.831]                         if (muffled) 
[10:26:01.831]                           invokeRestart("muffleMessage")
[10:26:01.831]                       }
[10:26:01.831]                       else if (inherits(cond, "warning")) {
[10:26:01.831]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:01.831]                         if (muffled) 
[10:26:01.831]                           invokeRestart("muffleWarning")
[10:26:01.831]                       }
[10:26:01.831]                       else if (inherits(cond, "condition")) {
[10:26:01.831]                         if (!is.null(pattern)) {
[10:26:01.831]                           computeRestarts <- base::computeRestarts
[10:26:01.831]                           grepl <- base::grepl
[10:26:01.831]                           restarts <- computeRestarts(cond)
[10:26:01.831]                           for (restart in restarts) {
[10:26:01.831]                             name <- restart$name
[10:26:01.831]                             if (is.null(name)) 
[10:26:01.831]                               next
[10:26:01.831]                             if (!grepl(pattern, name)) 
[10:26:01.831]                               next
[10:26:01.831]                             invokeRestart(restart)
[10:26:01.831]                             muffled <- TRUE
[10:26:01.831]                             break
[10:26:01.831]                           }
[10:26:01.831]                         }
[10:26:01.831]                       }
[10:26:01.831]                       invisible(muffled)
[10:26:01.831]                     }
[10:26:01.831]                     muffleCondition(cond, pattern = "^muffle")
[10:26:01.831]                   }
[10:26:01.831]                 }
[10:26:01.831]                 else {
[10:26:01.831]                   if (TRUE) {
[10:26:01.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:01.831]                     {
[10:26:01.831]                       inherits <- base::inherits
[10:26:01.831]                       invokeRestart <- base::invokeRestart
[10:26:01.831]                       is.null <- base::is.null
[10:26:01.831]                       muffled <- FALSE
[10:26:01.831]                       if (inherits(cond, "message")) {
[10:26:01.831]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:01.831]                         if (muffled) 
[10:26:01.831]                           invokeRestart("muffleMessage")
[10:26:01.831]                       }
[10:26:01.831]                       else if (inherits(cond, "warning")) {
[10:26:01.831]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:01.831]                         if (muffled) 
[10:26:01.831]                           invokeRestart("muffleWarning")
[10:26:01.831]                       }
[10:26:01.831]                       else if (inherits(cond, "condition")) {
[10:26:01.831]                         if (!is.null(pattern)) {
[10:26:01.831]                           computeRestarts <- base::computeRestarts
[10:26:01.831]                           grepl <- base::grepl
[10:26:01.831]                           restarts <- computeRestarts(cond)
[10:26:01.831]                           for (restart in restarts) {
[10:26:01.831]                             name <- restart$name
[10:26:01.831]                             if (is.null(name)) 
[10:26:01.831]                               next
[10:26:01.831]                             if (!grepl(pattern, name)) 
[10:26:01.831]                               next
[10:26:01.831]                             invokeRestart(restart)
[10:26:01.831]                             muffled <- TRUE
[10:26:01.831]                             break
[10:26:01.831]                           }
[10:26:01.831]                         }
[10:26:01.831]                       }
[10:26:01.831]                       invisible(muffled)
[10:26:01.831]                     }
[10:26:01.831]                     muffleCondition(cond, pattern = "^muffle")
[10:26:01.831]                   }
[10:26:01.831]                 }
[10:26:01.831]             }
[10:26:01.831]         }))
[10:26:01.831]     }, error = function(ex) {
[10:26:01.831]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:01.831]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:01.831]                 ...future.rng), started = ...future.startTime, 
[10:26:01.831]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:01.831]             version = "1.8"), class = "FutureResult")
[10:26:01.831]     }, finally = {
[10:26:01.831]         if (!identical(...future.workdir, getwd())) 
[10:26:01.831]             setwd(...future.workdir)
[10:26:01.831]         {
[10:26:01.831]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:01.831]                 ...future.oldOptions$nwarnings <- NULL
[10:26:01.831]             }
[10:26:01.831]             base::options(...future.oldOptions)
[10:26:01.831]             if (.Platform$OS.type == "windows") {
[10:26:01.831]                 old_names <- names(...future.oldEnvVars)
[10:26:01.831]                 envs <- base::Sys.getenv()
[10:26:01.831]                 names <- names(envs)
[10:26:01.831]                 common <- intersect(names, old_names)
[10:26:01.831]                 added <- setdiff(names, old_names)
[10:26:01.831]                 removed <- setdiff(old_names, names)
[10:26:01.831]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:01.831]                   envs[common]]
[10:26:01.831]                 NAMES <- toupper(changed)
[10:26:01.831]                 args <- list()
[10:26:01.831]                 for (kk in seq_along(NAMES)) {
[10:26:01.831]                   name <- changed[[kk]]
[10:26:01.831]                   NAME <- NAMES[[kk]]
[10:26:01.831]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:01.831]                     next
[10:26:01.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:01.831]                 }
[10:26:01.831]                 NAMES <- toupper(added)
[10:26:01.831]                 for (kk in seq_along(NAMES)) {
[10:26:01.831]                   name <- added[[kk]]
[10:26:01.831]                   NAME <- NAMES[[kk]]
[10:26:01.831]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:01.831]                     next
[10:26:01.831]                   args[[name]] <- ""
[10:26:01.831]                 }
[10:26:01.831]                 NAMES <- toupper(removed)
[10:26:01.831]                 for (kk in seq_along(NAMES)) {
[10:26:01.831]                   name <- removed[[kk]]
[10:26:01.831]                   NAME <- NAMES[[kk]]
[10:26:01.831]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:01.831]                     next
[10:26:01.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:01.831]                 }
[10:26:01.831]                 if (length(args) > 0) 
[10:26:01.831]                   base::do.call(base::Sys.setenv, args = args)
[10:26:01.831]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:01.831]             }
[10:26:01.831]             else {
[10:26:01.831]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:01.831]             }
[10:26:01.831]             {
[10:26:01.831]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:01.831]                   0L) {
[10:26:01.831]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:01.831]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:01.831]                   base::options(opts)
[10:26:01.831]                 }
[10:26:01.831]                 {
[10:26:01.831]                   {
[10:26:01.831]                     NULL
[10:26:01.831]                     RNGkind("Mersenne-Twister")
[10:26:01.831]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:01.831]                       inherits = FALSE)
[10:26:01.831]                   }
[10:26:01.831]                   options(future.plan = NULL)
[10:26:01.831]                   if (is.na(NA_character_)) 
[10:26:01.831]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:01.831]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:01.831]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:01.831]                   {
[10:26:01.831]                     future <- SequentialFuture(..., envir = envir)
[10:26:01.831]                     if (!future$lazy) 
[10:26:01.831]                       future <- run(future)
[10:26:01.831]                     invisible(future)
[10:26:01.831]                   }, function (..., envir = parent.frame()) 
[10:26:01.831]                   {
[10:26:01.831]                     future <- SequentialFuture(..., envir = envir)
[10:26:01.831]                     if (!future$lazy) 
[10:26:01.831]                       future <- run(future)
[10:26:01.831]                     invisible(future)
[10:26:01.831]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:01.831]                 }
[10:26:01.831]             }
[10:26:01.831]         }
[10:26:01.831]     })
[10:26:01.831]     if (TRUE) {
[10:26:01.831]         base::sink(type = "output", split = FALSE)
[10:26:01.831]         if (TRUE) {
[10:26:01.831]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:01.831]         }
[10:26:01.831]         else {
[10:26:01.831]             ...future.result["stdout"] <- base::list(NULL)
[10:26:01.831]         }
[10:26:01.831]         base::close(...future.stdout)
[10:26:01.831]         ...future.stdout <- NULL
[10:26:01.831]     }
[10:26:01.831]     ...future.result$conditions <- ...future.conditions
[10:26:01.831]     ...future.result$finished <- base::Sys.time()
[10:26:01.831]     ...future.result
[10:26:01.831] }
[10:26:01.833] assign_globals() ...
[10:26:01.833] List of 1
[10:26:01.833]  $ data:'data.frame':	5 obs. of  2 variables:
[10:26:01.833]   ..$ x: int [1:5] 1 2 3 4 5
[10:26:01.833]   ..$ y: int [1:5] 1 2 3 4 5
[10:26:01.833]  - attr(*, "where")=List of 1
[10:26:01.833]   ..$ data:<environment: R_EmptyEnv> 
[10:26:01.833]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:01.833]  - attr(*, "resolved")= logi FALSE
[10:26:01.833]  - attr(*, "total_size")= num 160
[10:26:01.833]  - attr(*, "already-done")= logi TRUE
[10:26:01.838] - copied ‘data’ to environment
[10:26:01.838] assign_globals() ... done
[10:26:01.838] plan(): Setting new future strategy stack:
[10:26:01.838] List of future strategies:
[10:26:01.838] 1. sequential:
[10:26:01.838]    - args: function (..., envir = parent.frame())
[10:26:01.838]    - tweaked: FALSE
[10:26:01.838]    - call: plan(list(sequential, strategy))
[10:26:01.839] plan(): nbrOfWorkers() = 1
[10:26:01.867] plan(): Setting new future strategy stack:
[10:26:01.867] List of future strategies:
[10:26:01.867] 1. sequential:
[10:26:01.867]    - args: function (..., envir = parent.frame())
[10:26:01.867]    - tweaked: FALSE
[10:26:01.867]    - call: plan(list(sequential, strategy))
[10:26:01.867] 2. sequential:
[10:26:01.867]    - args: function (..., envir = parent.frame())
[10:26:01.867]    - tweaked: FALSE
[10:26:01.867]    - call: plan(list(sequential, strategy))
[10:26:01.867] plan(): nbrOfWorkers() = 1
[10:26:01.867] SequentialFuture started (and completed)
[10:26:01.867] signalConditions() ...
[10:26:01.867]  - include = ‘immediateCondition’
[10:26:01.868]  - exclude = 
[10:26:01.868]  - resignal = FALSE
[10:26:01.868]  - Number of conditions: 53
[10:26:01.868] signalConditions() ... done
[10:26:01.868] - Launch lazy future ... done
[10:26:01.868] run() for ‘SequentialFuture’ ... done
[10:26:01.868] signalConditions() ...
[10:26:01.868]  - include = ‘immediateCondition’
[10:26:01.868]  - exclude = 
[10:26:01.868]  - resignal = FALSE
[10:26:01.868]  - Number of conditions: 53
[10:26:01.869] signalConditions() ... done
[10:26:01.869] Future state: ‘finished’
[10:26:01.869] signalConditions() ...
[10:26:01.869]  - include = ‘condition’
[10:26:01.869]  - exclude = ‘immediateCondition’
[10:26:01.869]  - resignal = TRUE
[10:26:01.869]  - Number of conditions: 53
[10:26:01.869]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.839] getGlobalsAndPackages() ...
[10:26:01.869]  - Condition #2: ‘deprecatedWarning’, ‘warning’, ‘condition’
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[10:26:01.869]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.852] Searching for globals...
[10:26:01.870]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.853] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[10:26:01.870]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.853] Searching for globals ... DONE
[10:26:01.870]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.853] Resolving globals: FALSE
[10:26:01.870]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.853] The total size of the 1 globals is 160 bytes (160 bytes)
[10:26:01.870]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.854] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 160 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (160 bytes of class ‘list’)
[10:26:01.870]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.855] - globals: [1] ‘data’
[10:26:01.870]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.855] 
[10:26:01.871]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.855] getGlobalsAndPackages() ... DONE
[10:26:01.871]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.855] run() for ‘Future’ ...
[10:26:01.871]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.855] - state: ‘created’
[10:26:01.871]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.855] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:01.871]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.856] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:01.871]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.856] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:01.871]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.856]   - Field: ‘label’
[10:26:01.871]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.856]   - Field: ‘local’
[10:26:01.872]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.856]   - Field: ‘owner’
[10:26:01.872]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.856]   - Field: ‘envir’
[10:26:01.872]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.856]   - Field: ‘packages’
[10:26:01.872]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.856]   - Field: ‘gc’
[10:26:01.872]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.857]   - Field: ‘conditions’
[10:26:01.872]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.857]   - Field: ‘expr’
[10:26:01.872]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.857]   - Field: ‘uuid’
[10:26:01.872]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.857]   - Field: ‘seed’
[10:26:01.873]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.857]   - Field: ‘version’
[10:26:01.873]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.857]   - Field: ‘result’
[10:26:01.873]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.857]   - Field: ‘asynchronous’
[10:26:01.873]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.857]   - Field: ‘calls’
[10:26:01.873]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.857]   - Field: ‘globals’
[10:26:01.873]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.857]   - Field: ‘stdout’
[10:26:01.873]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.858]   - Field: ‘earlySignal’
[10:26:01.873]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.858]   - Field: ‘lazy’
[10:26:01.874]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.858]   - Field: ‘state’
[10:26:01.874]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.858] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:01.874]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.858] - Launch lazy future ...
[10:26:01.874]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.858] Packages needed by the future expression (n = 0): <none>
[10:26:01.874]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.858] Packages needed by future strategies (n = 0): <none>
[10:26:01.874]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.859] {
[10:26:01.859]     {
[10:26:01.859]         {
[10:26:01.859]             ...future.startTime <- base::Sys.time()
[10:26:01.859]             {
[10:26:01.859]                 {
[10:26:01.859]                   {
[10:26:01.859]                     base::local({
[10:26:01.859]                       has_future <- base::requireNamespace("future", 
[10:26:01.859]                         quietly = TRUE)
[10:26:01.859]                       if (has_future) {
[10:26:01.859]                         ns <- base::getNamespace("future")
[10:26:01.859]                         version <- ns[[".package"]][["version"]]
[10:26:01.859]                         if (is.null(version)) 
[10:26:01.859]                           version <- utils::packageVersion("future")
[10:26:01.859]                       }
[10:26:01.859]                       else {
[10:26:01.859]                         version <- NULL
[10:26:01.859]                       }
[10:26:01.859]                       if (!has_future || version < "1.8.0") {
[10:26:01.859]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:01.859]                           "", base::R.version$version.string), 
[10:26:01.859]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:01.859]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:01.859]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:01.859]                             "release", "version")], collapse = " "), 
[10:26:01.859]                           hostname = base::Sys.info()[["nodename"]])
[10:26:01.859]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:01.859]                           info)
[10:26:01.859]                         info <- base::paste(info, collapse = "; ")
[10:26:01.859]                         if (!has_future) {
[10:26:01.859]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:01.859]                             info)
[10:26:01.859]                         }
[10:26:01.859]                         else {
[10:26:01.859]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:01.859]                             info, version)
[10:26:01.859]                         }
[10:26:01.859]                         base::stop(msg)
[10:26:01.859]                       }
[10:26:01.859]                     })
[10:26:01.859]                   }
[10:26:01.859]                   options(future.plan = NULL)
[10:26:01.859]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:01.859]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:01.859]                 }
[10:26:01.859]                 ...future.workdir <- getwd()
[10:26:01.859]             }
[10:26:01.859]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:01.859]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:01.859]         }
[10:26:01.859]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[10:26:01.859]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:01.859]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[10:26:01.859]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:01.859]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:01.859]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:01.859]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:01.859]             base::names(...future.oldOptions))
[10:26:01.859]     }
[10:26:01.859]     if (FALSE) {
[10:26:01.859]     }
[10:26:01.859]     else {
[10:26:01.859]         if (TRUE) {
[10:26:01.859]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:01.859]                 open = "w")
[10:26:01.859]         }
[10:26:01.859]         else {
[10:26:01.859]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:01.859]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:01.859]         }
[10:26:01.859]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:01.859]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:01.859]             base::sink(type = "output", split = FALSE)
[10:26:01.859]             base::close(...future.stdout)
[10:26:01.859]         }, add = TRUE)
[10:26:01.859]     }
[10:26:01.859]     ...future.frame <- base::sys.nframe()
[10:26:01.859]     ...future.conditions <- base::list()
[10:26:01.859]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:01.859]     if (FALSE) {
[10:26:01.859]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:01.859]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:01.859]     }
[10:26:01.859]     ...future.result <- base::tryCatch({
[10:26:01.859]         base::withCallingHandlers({
[10:26:01.859]             ...future.value <- base::withVisible(base::local(subset(data, 
[10:26:01.859]                 x < 3)$y))
[10:26:01.859]             future::FutureResult(value = ...future.value$value, 
[10:26:01.859]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:01.859]                   ...future.rng), globalenv = if (FALSE) 
[10:26:01.859]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:01.859]                     ...future.globalenv.names))
[10:26:01.859]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:01.859]         }, condition = base::local({
[10:26:01.859]             c <- base::c
[10:26:01.859]             inherits <- base::inherits
[10:26:01.859]             invokeRestart <- base::invokeRestart
[10:26:01.859]             length <- base::length
[10:26:01.859]             list <- base::list
[10:26:01.859]             seq.int <- base::seq.int
[10:26:01.859]             signalCondition <- base::signalCondition
[10:26:01.859]             sys.calls <- base::sys.calls
[10:26:01.859]             `[[` <- base::`[[`
[10:26:01.859]             `+` <- base::`+`
[10:26:01.859]             `<<-` <- base::`<<-`
[10:26:01.859]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:01.859]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:01.859]                   3L)]
[10:26:01.859]             }
[10:26:01.859]             function(cond) {
[10:26:01.859]                 is_error <- inherits(cond, "error")
[10:26:01.859]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:01.859]                   NULL)
[10:26:01.859]                 if (is_error) {
[10:26:01.859]                   sessionInformation <- function() {
[10:26:01.859]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:01.859]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:01.859]                       search = base::search(), system = base::Sys.info())
[10:26:01.859]                   }
[10:26:01.859]                   ...future.conditions[[length(...future.conditions) + 
[10:26:01.859]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:01.859]                     cond$call), session = sessionInformation(), 
[10:26:01.859]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:01.859]                   signalCondition(cond)
[10:26:01.859]                 }
[10:26:01.859]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:01.859]                 "immediateCondition"))) {
[10:26:01.859]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:01.859]                   ...future.conditions[[length(...future.conditions) + 
[10:26:01.859]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:01.859]                   if (TRUE && !signal) {
[10:26:01.859]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:01.859]                     {
[10:26:01.859]                       inherits <- base::inherits
[10:26:01.859]                       invokeRestart <- base::invokeRestart
[10:26:01.859]                       is.null <- base::is.null
[10:26:01.859]                       muffled <- FALSE
[10:26:01.859]                       if (inherits(cond, "message")) {
[10:26:01.859]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:01.859]                         if (muffled) 
[10:26:01.859]                           invokeRestart("muffleMessage")
[10:26:01.859]                       }
[10:26:01.859]                       else if (inherits(cond, "warning")) {
[10:26:01.859]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:01.859]                         if (muffled) 
[10:26:01.859]                           invokeRestart("muffleWarning")
[10:26:01.859]                       }
[10:26:01.859]                       else if (inherits(cond, "condition")) {
[10:26:01.859]                         if (!is.null(pattern)) {
[10:26:01.859]                           computeRestarts <- base::computeRestarts
[10:26:01.859]                           grepl <- base::grepl
[10:26:01.859]                           restarts <- computeRestarts(cond)
[10:26:01.859]                           for (restart in restarts) {
[10:26:01.859]                             name <- restart$name
[10:26:01.859]                             if (is.null(name)) 
[10:26:01.859]                               next
[10:26:01.859]                             if (!grepl(pattern, name)) 
[10:26:01.859]                               next
[10:26:01.859]                             invokeRestart(restart)
[10:26:01.859]                             muffled <- TRUE
[10:26:01.859]                             break
[10:26:01.859]                           }
[10:26:01.859]                         }
[10:26:01.859]                       }
[10:26:01.859]                       invisible(muffled)
[10:26:01.859]                     }
[10:26:01.859]                     muffleCondition(cond, pattern = "^muffle")
[10:26:01.859]                   }
[10:26:01.859]                 }
[10:26:01.859]                 else {
[10:26:01.859]                   if (TRUE) {
[10:26:01.859]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:01.859]                     {
[10:26:01.859]                       inherits <- base::inherits
[10:26:01.859]                       invokeRestart <- base::invokeRestart
[10:26:01.859]                       is.null <- base::is.null
[10:26:01.859]                       muffled <- FALSE
[10:26:01.859]                       if (inherits(cond, "message")) {
[10:26:01.859]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:01.859]                         if (muffled) 
[10:26:01.859]                           invokeRestart("muffleMessage")
[10:26:01.859]                       }
[10:26:01.859]                       else if (inherits(cond, "warning")) {
[10:26:01.859]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:01.859]                         if (muffled) 
[10:26:01.859]                           invokeRestart("muffleWarning")
[10:26:01.859]                       }
[10:26:01.859]                       else if (inherits(cond, "condition")) {
[10:26:01.859]                         if (!is.null(pattern)) {
[10:26:01.859]                           computeRestarts <- base::computeRestarts
[10:26:01.859]                           grepl <- base::grepl
[10:26:01.859]                           restarts <- computeRestarts(cond)
[10:26:01.859]                           for (restart in restarts) {
[10:26:01.859]                             name <- restart$name
[10:26:01.859]                             if (is.null(name)) 
[10:26:01.859]                               next
[10:26:01.859]                             if (!grepl(pattern, name)) 
[10:26:01.859]                               next
[10:26:01.859]                             invokeRestart(restart)
[10:26:01.859]                             muffled <- TRUE
[10:26:01.859]                             break
[10:26:01.859]                           }
[10:26:01.859]                         }
[10:26:01.859]                       }
[10:26:01.859]                       invisible(muffled)
[10:26:01.859]                     }
[10:26:01.859]                     muffleCondition(cond, pattern = "^muffle")
[10:26:01.859]                   }
[10:26:01.859]                 }
[10:26:01.859]             }
[10:26:01.859]         }))
[10:26:01.859]     }, error = function(ex) {
[10:26:01.859]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:01.859]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:01.859]                 ...future.rng), started = ...future.startTime, 
[10:26:01.859]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:01.859]             version = "1.8"), class = "FutureResult")
[10:26:01.859]     }, finally = {
[10:26:01.859]         if (!identical(...future.workdir, getwd())) 
[10:26:01.859]             setwd(...future.workdir)
[10:26:01.859]         {
[10:26:01.859]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:01.859]                 ...future.oldOptions$nwarnings <- NULL
[10:26:01.859]             }
[10:26:01.859]             base::options(...future.oldOptions)
[10:26:01.859]             if (.Platform$OS.type == "windows") {
[10:26:01.859]                 old_names <- names(...future.oldEnvVars)
[10:26:01.859]                 envs <- base::Sys.getenv()
[10:26:01.859]                 names <- names(envs)
[10:26:01.859]                 common <- intersect(names, old_names)
[10:26:01.859]                 added <- setdiff(names, old_names)
[10:26:01.859]                 removed <- setdiff(old_names, names)
[10:26:01.859]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:01.859]                   envs[common]]
[10:26:01.859]                 NAMES <- toupper(changed)
[10:26:01.859]                 args <- list()
[10:26:01.859]                 for (kk in seq_along(NAMES)) {
[10:26:01.859]                   name <- changed[[kk]]
[10:26:01.859]                   NAME <- NAMES[[kk]]
[10:26:01.859]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:01.859]                     next
[10:26:01.859]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:01.859]                 }
[10:26:01.859]                 NAMES <- toupper(added)
[10:26:01.859]                 for (kk in seq_along(NAMES)) {
[10:26:01.859]                   name <- added[[kk]]
[10:26:01.859]                   NAME <- NAMES[[kk]]
[10:26:01.859]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:01.859]                     next
[10:26:01.859]                   args[[name]] <- ""
[10:26:01.859]                 }
[10:26:01.859]                 NAMES <- toupper(removed)
[10:26:01.859]                 for (kk in seq_along(NAMES)) {
[10:26:01.859]                   name <- removed[[kk]]
[10:26:01.859]                   NAME <- NAMES[[kk]]
[10:26:01.859]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:01.859]                     next
[10:26:01.859]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:01.859]                 }
[10:26:01.859]                 if (length(args) > 0) 
[10:26:01.859]                   base::do.call(base::Sys.setenv, args = args)
[10:26:01.859]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:01.859]             }
[10:26:01.859]             else {
[10:26:01.859]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:01.859]             }
[10:26:01.859]             {
[10:26:01.859]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:01.859]                   0L) {
[10:26:01.859]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:01.859]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:01.859]                   base::options(opts)
[10:26:01.859]                 }
[10:26:01.859]                 {
[10:26:01.859]                   {
[10:26:01.859]                     NULL
[10:26:01.859]                     RNGkind("Mersenne-Twister")
[10:26:01.859]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:01.859]                       inherits = FALSE)
[10:26:01.859]                   }
[10:26:01.859]                   options(future.plan = NULL)
[10:26:01.859]                   if (is.na(NA_character_)) 
[10:26:01.859]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:01.859]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:01.859]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:01.859]                   {
[10:26:01.859]                     future <- SequentialFuture(..., envir = envir)
[10:26:01.859]                     if (!future$lazy) 
[10:26:01.859]                       future <- run(future)
[10:26:01.859]                     invisible(future)
[10:26:01.859]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:01.859]                 }
[10:26:01.859]             }
[10:26:01.859]         }
[10:26:01.859]     })
[10:26:01.859]     if (TRUE) {
[10:26:01.859]         base::sink(type = "output", split = FALSE)
[10:26:01.859]         if (TRUE) {
[10:26:01.859]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:01.859]         }
[10:26:01.859]         else {
[10:26:01.859]             ...future.result["stdout"] <- base::list(NULL)
[10:26:01.859]         }
[10:26:01.859]         base::close(...future.stdout)
[10:26:01.859]         ...future.stdout <- NULL
[10:26:01.859]     }
[10:26:01.859]     ...future.result$conditions <- ...future.conditions
[10:26:01.859]     ...future.result$finished <- base::Sys.time()
[10:26:01.859]     ...future.result
[10:26:01.859] }
[10:26:01.874]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.861] assign_globals() ...
[10:26:01.874]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.861] List of 1
[10:26:01.861]  $ data:'data.frame':	5 obs. of  2 variables:
[10:26:01.861]   ..$ x: int [1:5] 1 2 3 4 5
[10:26:01.861]   ..$ y: int [1:5] 1 2 3 4 5
[10:26:01.861]  - attr(*, "where")=List of 1
[10:26:01.861]   ..$ data:<environment: R_EmptyEnv> 
[10:26:01.861]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:01.861]  - attr(*, "resolved")= logi FALSE
[10:26:01.861]  - attr(*, "total_size")= num 160
[10:26:01.861]  - attr(*, "already-done")= logi TRUE
[10:26:01.875]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.864] - copied ‘data’ to environment
[10:26:01.875]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.864] assign_globals() ... done
[10:26:01.875]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.864] plan(): Setting new future strategy stack:
[10:26:01.875]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.864] List of future strategies:
[10:26:01.864] 1. sequential:
[10:26:01.864]    - args: function (..., envir = parent.frame())
[10:26:01.864]    - tweaked: FALSE
[10:26:01.864]    - call: NULL
[10:26:01.875]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.864] plan(): nbrOfWorkers() = 1
[10:26:01.875]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.865] plan(): Setting new future strategy stack:
[10:26:01.875]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.865] List of future strategies:
[10:26:01.865] 1. sequential:
[10:26:01.865]    - args: function (..., envir = parent.frame())
[10:26:01.865]    - tweaked: FALSE
[10:26:01.865]    - call: plan(list(sequential, strategy))
[10:26:01.875]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.866] plan(): nbrOfWorkers() = 1
[10:26:01.876]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.866] SequentialFuture started (and completed)
[10:26:01.876]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.866] - Launch lazy future ... done
[10:26:01.876]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.866] run() for ‘SequentialFuture’ ... done
[10:26:01.876] signalConditions() ... done
- Strategy: sequential ... DONE
- Strategy: multicore ...
[10:26:01.876] plan(): Setting new future strategy stack:
[10:26:01.876] List of future strategies:
[10:26:01.876] 1. multicore:
[10:26:01.876]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:01.876]    - tweaked: FALSE
[10:26:01.876]    - call: plan(strategy)
[10:26:01.880] plan(): nbrOfWorkers() = 2
[10:26:01.881] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:01.881] Searching for globals...
[10:26:01.882] - globals found: [1] ‘getOption’
[10:26:01.882] Searching for globals ... DONE
[10:26:01.882] Resolving globals: FALSE
[10:26:01.883] 
[10:26:01.883] 
[10:26:01.883] getGlobalsAndPackages() ... DONE
[10:26:01.883] run() for ‘Future’ ...
[10:26:01.883] - state: ‘created’
[10:26:01.883] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:01.887] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:01.887] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:01.887]   - Field: ‘label’
[10:26:01.887]   - Field: ‘local’
[10:26:01.887]   - Field: ‘owner’
[10:26:01.887]   - Field: ‘envir’
[10:26:01.888]   - Field: ‘workers’
[10:26:01.888]   - Field: ‘packages’
[10:26:01.888]   - Field: ‘gc’
[10:26:01.888]   - Field: ‘job’
[10:26:01.888]   - Field: ‘conditions’
[10:26:01.888]   - Field: ‘expr’
[10:26:01.888]   - Field: ‘uuid’
[10:26:01.888]   - Field: ‘seed’
[10:26:01.888]   - Field: ‘version’
[10:26:01.888]   - Field: ‘result’
[10:26:01.888]   - Field: ‘asynchronous’
[10:26:01.888]   - Field: ‘calls’
[10:26:01.889]   - Field: ‘globals’
[10:26:01.889]   - Field: ‘stdout’
[10:26:01.889]   - Field: ‘earlySignal’
[10:26:01.889]   - Field: ‘lazy’
[10:26:01.889]   - Field: ‘state’
[10:26:01.889] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:01.889] - Launch lazy future ...
[10:26:01.890] Packages needed by the future expression (n = 0): <none>
[10:26:01.890] Packages needed by future strategies (n = 0): <none>
[10:26:01.891] {
[10:26:01.891]     {
[10:26:01.891]         {
[10:26:01.891]             ...future.startTime <- base::Sys.time()
[10:26:01.891]             {
[10:26:01.891]                 {
[10:26:01.891]                   {
[10:26:01.891]                     {
[10:26:01.891]                       base::local({
[10:26:01.891]                         has_future <- base::requireNamespace("future", 
[10:26:01.891]                           quietly = TRUE)
[10:26:01.891]                         if (has_future) {
[10:26:01.891]                           ns <- base::getNamespace("future")
[10:26:01.891]                           version <- ns[[".package"]][["version"]]
[10:26:01.891]                           if (is.null(version)) 
[10:26:01.891]                             version <- utils::packageVersion("future")
[10:26:01.891]                         }
[10:26:01.891]                         else {
[10:26:01.891]                           version <- NULL
[10:26:01.891]                         }
[10:26:01.891]                         if (!has_future || version < "1.8.0") {
[10:26:01.891]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:01.891]                             "", base::R.version$version.string), 
[10:26:01.891]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:01.891]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:01.891]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:01.891]                               "release", "version")], collapse = " "), 
[10:26:01.891]                             hostname = base::Sys.info()[["nodename"]])
[10:26:01.891]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:01.891]                             info)
[10:26:01.891]                           info <- base::paste(info, collapse = "; ")
[10:26:01.891]                           if (!has_future) {
[10:26:01.891]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:01.891]                               info)
[10:26:01.891]                           }
[10:26:01.891]                           else {
[10:26:01.891]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:01.891]                               info, version)
[10:26:01.891]                           }
[10:26:01.891]                           base::stop(msg)
[10:26:01.891]                         }
[10:26:01.891]                       })
[10:26:01.891]                     }
[10:26:01.891]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:01.891]                     base::options(mc.cores = 1L)
[10:26:01.891]                   }
[10:26:01.891]                   options(future.plan = NULL)
[10:26:01.891]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:01.891]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:01.891]                 }
[10:26:01.891]                 ...future.workdir <- getwd()
[10:26:01.891]             }
[10:26:01.891]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:01.891]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:01.891]         }
[10:26:01.891]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:01.891]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:01.891]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:01.891]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:01.891]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:01.891]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:01.891]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:01.891]             base::names(...future.oldOptions))
[10:26:01.891]     }
[10:26:01.891]     if (FALSE) {
[10:26:01.891]     }
[10:26:01.891]     else {
[10:26:01.891]         if (TRUE) {
[10:26:01.891]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:01.891]                 open = "w")
[10:26:01.891]         }
[10:26:01.891]         else {
[10:26:01.891]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:01.891]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:01.891]         }
[10:26:01.891]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:01.891]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:01.891]             base::sink(type = "output", split = FALSE)
[10:26:01.891]             base::close(...future.stdout)
[10:26:01.891]         }, add = TRUE)
[10:26:01.891]     }
[10:26:01.891]     ...future.frame <- base::sys.nframe()
[10:26:01.891]     ...future.conditions <- base::list()
[10:26:01.891]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:01.891]     if (FALSE) {
[10:26:01.891]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:01.891]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:01.891]     }
[10:26:01.891]     ...future.result <- base::tryCatch({
[10:26:01.891]         base::withCallingHandlers({
[10:26:01.891]             ...future.value <- base::withVisible(base::local({
[10:26:01.891]                 withCallingHandlers({
[10:26:01.891]                   getOption("future.globals.onMissing")
[10:26:01.891]                 }, immediateCondition = function(cond) {
[10:26:01.891]                   save_rds <- function (object, pathname, ...) 
[10:26:01.891]                   {
[10:26:01.891]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:01.891]                     if (file_test("-f", pathname_tmp)) {
[10:26:01.891]                       fi_tmp <- file.info(pathname_tmp)
[10:26:01.891]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:01.891]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:01.891]                         fi_tmp[["mtime"]])
[10:26:01.891]                     }
[10:26:01.891]                     tryCatch({
[10:26:01.891]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:01.891]                     }, error = function(ex) {
[10:26:01.891]                       msg <- conditionMessage(ex)
[10:26:01.891]                       fi_tmp <- file.info(pathname_tmp)
[10:26:01.891]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:01.891]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:01.891]                         fi_tmp[["mtime"]], msg)
[10:26:01.891]                       ex$message <- msg
[10:26:01.891]                       stop(ex)
[10:26:01.891]                     })
[10:26:01.891]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:01.891]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:01.891]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:01.891]                       fi_tmp <- file.info(pathname_tmp)
[10:26:01.891]                       fi <- file.info(pathname)
[10:26:01.891]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:01.891]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:01.891]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:01.891]                         fi[["size"]], fi[["mtime"]])
[10:26:01.891]                       stop(msg)
[10:26:01.891]                     }
[10:26:01.891]                     invisible(pathname)
[10:26:01.891]                   }
[10:26:01.891]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:01.891]                     rootPath = tempdir()) 
[10:26:01.891]                   {
[10:26:01.891]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:01.891]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:01.891]                       tmpdir = path, fileext = ".rds")
[10:26:01.891]                     save_rds(obj, file)
[10:26:01.891]                   }
[10:26:01.891]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4gE0AX/.future/immediateConditions")
[10:26:01.891]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:01.891]                   {
[10:26:01.891]                     inherits <- base::inherits
[10:26:01.891]                     invokeRestart <- base::invokeRestart
[10:26:01.891]                     is.null <- base::is.null
[10:26:01.891]                     muffled <- FALSE
[10:26:01.891]                     if (inherits(cond, "message")) {
[10:26:01.891]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:01.891]                       if (muffled) 
[10:26:01.891]                         invokeRestart("muffleMessage")
[10:26:01.891]                     }
[10:26:01.891]                     else if (inherits(cond, "warning")) {
[10:26:01.891]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:01.891]                       if (muffled) 
[10:26:01.891]                         invokeRestart("muffleWarning")
[10:26:01.891]                     }
[10:26:01.891]                     else if (inherits(cond, "condition")) {
[10:26:01.891]                       if (!is.null(pattern)) {
[10:26:01.891]                         computeRestarts <- base::computeRestarts
[10:26:01.891]                         grepl <- base::grepl
[10:26:01.891]                         restarts <- computeRestarts(cond)
[10:26:01.891]                         for (restart in restarts) {
[10:26:01.891]                           name <- restart$name
[10:26:01.891]                           if (is.null(name)) 
[10:26:01.891]                             next
[10:26:01.891]                           if (!grepl(pattern, name)) 
[10:26:01.891]                             next
[10:26:01.891]                           invokeRestart(restart)
[10:26:01.891]                           muffled <- TRUE
[10:26:01.891]                           break
[10:26:01.891]                         }
[10:26:01.891]                       }
[10:26:01.891]                     }
[10:26:01.891]                     invisible(muffled)
[10:26:01.891]                   }
[10:26:01.891]                   muffleCondition(cond)
[10:26:01.891]                 })
[10:26:01.891]             }))
[10:26:01.891]             future::FutureResult(value = ...future.value$value, 
[10:26:01.891]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:01.891]                   ...future.rng), globalenv = if (FALSE) 
[10:26:01.891]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:01.891]                     ...future.globalenv.names))
[10:26:01.891]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:01.891]         }, condition = base::local({
[10:26:01.891]             c <- base::c
[10:26:01.891]             inherits <- base::inherits
[10:26:01.891]             invokeRestart <- base::invokeRestart
[10:26:01.891]             length <- base::length
[10:26:01.891]             list <- base::list
[10:26:01.891]             seq.int <- base::seq.int
[10:26:01.891]             signalCondition <- base::signalCondition
[10:26:01.891]             sys.calls <- base::sys.calls
[10:26:01.891]             `[[` <- base::`[[`
[10:26:01.891]             `+` <- base::`+`
[10:26:01.891]             `<<-` <- base::`<<-`
[10:26:01.891]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:01.891]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:01.891]                   3L)]
[10:26:01.891]             }
[10:26:01.891]             function(cond) {
[10:26:01.891]                 is_error <- inherits(cond, "error")
[10:26:01.891]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:01.891]                   NULL)
[10:26:01.891]                 if (is_error) {
[10:26:01.891]                   sessionInformation <- function() {
[10:26:01.891]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:01.891]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:01.891]                       search = base::search(), system = base::Sys.info())
[10:26:01.891]                   }
[10:26:01.891]                   ...future.conditions[[length(...future.conditions) + 
[10:26:01.891]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:01.891]                     cond$call), session = sessionInformation(), 
[10:26:01.891]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:01.891]                   signalCondition(cond)
[10:26:01.891]                 }
[10:26:01.891]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:01.891]                 "immediateCondition"))) {
[10:26:01.891]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:01.891]                   ...future.conditions[[length(...future.conditions) + 
[10:26:01.891]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:01.891]                   if (TRUE && !signal) {
[10:26:01.891]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:01.891]                     {
[10:26:01.891]                       inherits <- base::inherits
[10:26:01.891]                       invokeRestart <- base::invokeRestart
[10:26:01.891]                       is.null <- base::is.null
[10:26:01.891]                       muffled <- FALSE
[10:26:01.891]                       if (inherits(cond, "message")) {
[10:26:01.891]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:01.891]                         if (muffled) 
[10:26:01.891]                           invokeRestart("muffleMessage")
[10:26:01.891]                       }
[10:26:01.891]                       else if (inherits(cond, "warning")) {
[10:26:01.891]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:01.891]                         if (muffled) 
[10:26:01.891]                           invokeRestart("muffleWarning")
[10:26:01.891]                       }
[10:26:01.891]                       else if (inherits(cond, "condition")) {
[10:26:01.891]                         if (!is.null(pattern)) {
[10:26:01.891]                           computeRestarts <- base::computeRestarts
[10:26:01.891]                           grepl <- base::grepl
[10:26:01.891]                           restarts <- computeRestarts(cond)
[10:26:01.891]                           for (restart in restarts) {
[10:26:01.891]                             name <- restart$name
[10:26:01.891]                             if (is.null(name)) 
[10:26:01.891]                               next
[10:26:01.891]                             if (!grepl(pattern, name)) 
[10:26:01.891]                               next
[10:26:01.891]                             invokeRestart(restart)
[10:26:01.891]                             muffled <- TRUE
[10:26:01.891]                             break
[10:26:01.891]                           }
[10:26:01.891]                         }
[10:26:01.891]                       }
[10:26:01.891]                       invisible(muffled)
[10:26:01.891]                     }
[10:26:01.891]                     muffleCondition(cond, pattern = "^muffle")
[10:26:01.891]                   }
[10:26:01.891]                 }
[10:26:01.891]                 else {
[10:26:01.891]                   if (TRUE) {
[10:26:01.891]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:01.891]                     {
[10:26:01.891]                       inherits <- base::inherits
[10:26:01.891]                       invokeRestart <- base::invokeRestart
[10:26:01.891]                       is.null <- base::is.null
[10:26:01.891]                       muffled <- FALSE
[10:26:01.891]                       if (inherits(cond, "message")) {
[10:26:01.891]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:01.891]                         if (muffled) 
[10:26:01.891]                           invokeRestart("muffleMessage")
[10:26:01.891]                       }
[10:26:01.891]                       else if (inherits(cond, "warning")) {
[10:26:01.891]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:01.891]                         if (muffled) 
[10:26:01.891]                           invokeRestart("muffleWarning")
[10:26:01.891]                       }
[10:26:01.891]                       else if (inherits(cond, "condition")) {
[10:26:01.891]                         if (!is.null(pattern)) {
[10:26:01.891]                           computeRestarts <- base::computeRestarts
[10:26:01.891]                           grepl <- base::grepl
[10:26:01.891]                           restarts <- computeRestarts(cond)
[10:26:01.891]                           for (restart in restarts) {
[10:26:01.891]                             name <- restart$name
[10:26:01.891]                             if (is.null(name)) 
[10:26:01.891]                               next
[10:26:01.891]                             if (!grepl(pattern, name)) 
[10:26:01.891]                               next
[10:26:01.891]                             invokeRestart(restart)
[10:26:01.891]                             muffled <- TRUE
[10:26:01.891]                             break
[10:26:01.891]                           }
[10:26:01.891]                         }
[10:26:01.891]                       }
[10:26:01.891]                       invisible(muffled)
[10:26:01.891]                     }
[10:26:01.891]                     muffleCondition(cond, pattern = "^muffle")
[10:26:01.891]                   }
[10:26:01.891]                 }
[10:26:01.891]             }
[10:26:01.891]         }))
[10:26:01.891]     }, error = function(ex) {
[10:26:01.891]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:01.891]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:01.891]                 ...future.rng), started = ...future.startTime, 
[10:26:01.891]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:01.891]             version = "1.8"), class = "FutureResult")
[10:26:01.891]     }, finally = {
[10:26:01.891]         if (!identical(...future.workdir, getwd())) 
[10:26:01.891]             setwd(...future.workdir)
[10:26:01.891]         {
[10:26:01.891]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:01.891]                 ...future.oldOptions$nwarnings <- NULL
[10:26:01.891]             }
[10:26:01.891]             base::options(...future.oldOptions)
[10:26:01.891]             if (.Platform$OS.type == "windows") {
[10:26:01.891]                 old_names <- names(...future.oldEnvVars)
[10:26:01.891]                 envs <- base::Sys.getenv()
[10:26:01.891]                 names <- names(envs)
[10:26:01.891]                 common <- intersect(names, old_names)
[10:26:01.891]                 added <- setdiff(names, old_names)
[10:26:01.891]                 removed <- setdiff(old_names, names)
[10:26:01.891]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:01.891]                   envs[common]]
[10:26:01.891]                 NAMES <- toupper(changed)
[10:26:01.891]                 args <- list()
[10:26:01.891]                 for (kk in seq_along(NAMES)) {
[10:26:01.891]                   name <- changed[[kk]]
[10:26:01.891]                   NAME <- NAMES[[kk]]
[10:26:01.891]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:01.891]                     next
[10:26:01.891]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:01.891]                 }
[10:26:01.891]                 NAMES <- toupper(added)
[10:26:01.891]                 for (kk in seq_along(NAMES)) {
[10:26:01.891]                   name <- added[[kk]]
[10:26:01.891]                   NAME <- NAMES[[kk]]
[10:26:01.891]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:01.891]                     next
[10:26:01.891]                   args[[name]] <- ""
[10:26:01.891]                 }
[10:26:01.891]                 NAMES <- toupper(removed)
[10:26:01.891]                 for (kk in seq_along(NAMES)) {
[10:26:01.891]                   name <- removed[[kk]]
[10:26:01.891]                   NAME <- NAMES[[kk]]
[10:26:01.891]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:01.891]                     next
[10:26:01.891]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:01.891]                 }
[10:26:01.891]                 if (length(args) > 0) 
[10:26:01.891]                   base::do.call(base::Sys.setenv, args = args)
[10:26:01.891]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:01.891]             }
[10:26:01.891]             else {
[10:26:01.891]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:01.891]             }
[10:26:01.891]             {
[10:26:01.891]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:01.891]                   0L) {
[10:26:01.891]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:01.891]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:01.891]                   base::options(opts)
[10:26:01.891]                 }
[10:26:01.891]                 {
[10:26:01.891]                   {
[10:26:01.891]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:01.891]                     NULL
[10:26:01.891]                   }
[10:26:01.891]                   options(future.plan = NULL)
[10:26:01.891]                   if (is.na(NA_character_)) 
[10:26:01.891]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:01.891]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:01.891]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:01.891]                     envir = parent.frame()) 
[10:26:01.891]                   {
[10:26:01.891]                     default_workers <- missing(workers)
[10:26:01.891]                     if (is.function(workers)) 
[10:26:01.891]                       workers <- workers()
[10:26:01.891]                     workers <- structure(as.integer(workers), 
[10:26:01.891]                       class = class(workers))
[10:26:01.891]                     stop_if_not(is.finite(workers), workers >= 
[10:26:01.891]                       1L)
[10:26:01.891]                     if ((workers == 1L && !inherits(workers, 
[10:26:01.891]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:01.891]                       if (default_workers) 
[10:26:01.891]                         supportsMulticore(warn = TRUE)
[10:26:01.891]                       return(sequential(..., envir = envir))
[10:26:01.891]                     }
[10:26:01.891]                     oopts <- options(mc.cores = workers)
[10:26:01.891]                     on.exit(options(oopts))
[10:26:01.891]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:01.891]                       envir = envir)
[10:26:01.891]                     if (!future$lazy) 
[10:26:01.891]                       future <- run(future)
[10:26:01.891]                     invisible(future)
[10:26:01.891]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:01.891]                 }
[10:26:01.891]             }
[10:26:01.891]         }
[10:26:01.891]     })
[10:26:01.891]     if (TRUE) {
[10:26:01.891]         base::sink(type = "output", split = FALSE)
[10:26:01.891]         if (TRUE) {
[10:26:01.891]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:01.891]         }
[10:26:01.891]         else {
[10:26:01.891]             ...future.result["stdout"] <- base::list(NULL)
[10:26:01.891]         }
[10:26:01.891]         base::close(...future.stdout)
[10:26:01.891]         ...future.stdout <- NULL
[10:26:01.891]     }
[10:26:01.891]     ...future.result$conditions <- ...future.conditions
[10:26:01.891]     ...future.result$finished <- base::Sys.time()
[10:26:01.891]     ...future.result
[10:26:01.891] }
[10:26:01.893] requestCore(): workers = 2
[10:26:01.896] MulticoreFuture started
[10:26:01.896] - Launch lazy future ... done
[10:26:01.897] run() for ‘MulticoreFuture’ ... done
[10:26:01.897] plan(): Setting new future strategy stack:
[10:26:01.897] List of future strategies:
[10:26:01.897] 1. sequential:
[10:26:01.897]    - args: function (..., envir = parent.frame())
[10:26:01.897]    - tweaked: FALSE
[10:26:01.897]    - call: NULL
[10:26:01.898] plan(): nbrOfWorkers() = 1
[10:26:01.898] result() for MulticoreFuture ...
[10:26:01.900] plan(): Setting new future strategy stack:
[10:26:01.900] List of future strategies:
[10:26:01.900] 1. multicore:
[10:26:01.900]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:01.900]    - tweaked: FALSE
[10:26:01.900]    - call: plan(strategy)
[10:26:01.905] plan(): nbrOfWorkers() = 2
[10:26:01.910] result() for MulticoreFuture ...
[10:26:01.910] result() for MulticoreFuture ... done
[10:26:01.910] result() for MulticoreFuture ... done
[10:26:01.910] result() for MulticoreFuture ...
[10:26:01.910] result() for MulticoreFuture ... done
[10:26:01.911] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[10:26:01.911] Searching for globals...
[10:26:01.912] - globals found: [1] ‘getOption’
[10:26:01.912] Searching for globals ... DONE
[10:26:01.912] Resolving globals: FALSE
[10:26:01.912] 
[10:26:01.913] 
[10:26:01.913] getGlobalsAndPackages() ... DONE
[10:26:01.913] run() for ‘Future’ ...
[10:26:01.913] - state: ‘created’
[10:26:01.913] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:01.917] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:01.917] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:01.918]   - Field: ‘label’
[10:26:01.918]   - Field: ‘local’
[10:26:01.918]   - Field: ‘owner’
[10:26:01.918]   - Field: ‘envir’
[10:26:01.918]   - Field: ‘workers’
[10:26:01.918]   - Field: ‘packages’
[10:26:01.918]   - Field: ‘gc’
[10:26:01.918]   - Field: ‘job’
[10:26:01.918]   - Field: ‘conditions’
[10:26:01.919]   - Field: ‘expr’
[10:26:01.919]   - Field: ‘uuid’
[10:26:01.919]   - Field: ‘seed’
[10:26:01.919]   - Field: ‘version’
[10:26:01.919]   - Field: ‘result’
[10:26:01.919]   - Field: ‘asynchronous’
[10:26:01.919]   - Field: ‘calls’
[10:26:01.919]   - Field: ‘globals’
[10:26:01.919]   - Field: ‘stdout’
[10:26:01.920]   - Field: ‘earlySignal’
[10:26:01.920]   - Field: ‘lazy’
[10:26:01.920]   - Field: ‘state’
[10:26:01.920] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:01.920] - Launch lazy future ...
[10:26:01.920] Packages needed by the future expression (n = 0): <none>
[10:26:01.920] Packages needed by future strategies (n = 0): <none>
[10:26:01.921] {
[10:26:01.921]     {
[10:26:01.921]         {
[10:26:01.921]             ...future.startTime <- base::Sys.time()
[10:26:01.921]             {
[10:26:01.921]                 {
[10:26:01.921]                   {
[10:26:01.921]                     {
[10:26:01.921]                       base::local({
[10:26:01.921]                         has_future <- base::requireNamespace("future", 
[10:26:01.921]                           quietly = TRUE)
[10:26:01.921]                         if (has_future) {
[10:26:01.921]                           ns <- base::getNamespace("future")
[10:26:01.921]                           version <- ns[[".package"]][["version"]]
[10:26:01.921]                           if (is.null(version)) 
[10:26:01.921]                             version <- utils::packageVersion("future")
[10:26:01.921]                         }
[10:26:01.921]                         else {
[10:26:01.921]                           version <- NULL
[10:26:01.921]                         }
[10:26:01.921]                         if (!has_future || version < "1.8.0") {
[10:26:01.921]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:01.921]                             "", base::R.version$version.string), 
[10:26:01.921]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:01.921]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:01.921]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:01.921]                               "release", "version")], collapse = " "), 
[10:26:01.921]                             hostname = base::Sys.info()[["nodename"]])
[10:26:01.921]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:01.921]                             info)
[10:26:01.921]                           info <- base::paste(info, collapse = "; ")
[10:26:01.921]                           if (!has_future) {
[10:26:01.921]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:01.921]                               info)
[10:26:01.921]                           }
[10:26:01.921]                           else {
[10:26:01.921]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:01.921]                               info, version)
[10:26:01.921]                           }
[10:26:01.921]                           base::stop(msg)
[10:26:01.921]                         }
[10:26:01.921]                       })
[10:26:01.921]                     }
[10:26:01.921]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:01.921]                     base::options(mc.cores = 1L)
[10:26:01.921]                   }
[10:26:01.921]                   options(future.plan = NULL)
[10:26:01.921]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:01.921]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:01.921]                 }
[10:26:01.921]                 ...future.workdir <- getwd()
[10:26:01.921]             }
[10:26:01.921]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:01.921]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:01.921]         }
[10:26:01.921]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[10:26:01.921]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:01.921]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[10:26:01.921]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:01.921]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:01.921]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:01.921]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:01.921]             base::names(...future.oldOptions))
[10:26:01.921]     }
[10:26:01.921]     if (FALSE) {
[10:26:01.921]     }
[10:26:01.921]     else {
[10:26:01.921]         if (TRUE) {
[10:26:01.921]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:01.921]                 open = "w")
[10:26:01.921]         }
[10:26:01.921]         else {
[10:26:01.921]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:01.921]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:01.921]         }
[10:26:01.921]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:01.921]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:01.921]             base::sink(type = "output", split = FALSE)
[10:26:01.921]             base::close(...future.stdout)
[10:26:01.921]         }, add = TRUE)
[10:26:01.921]     }
[10:26:01.921]     ...future.frame <- base::sys.nframe()
[10:26:01.921]     ...future.conditions <- base::list()
[10:26:01.921]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:01.921]     if (FALSE) {
[10:26:01.921]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:01.921]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:01.921]     }
[10:26:01.921]     ...future.result <- base::tryCatch({
[10:26:01.921]         base::withCallingHandlers({
[10:26:01.921]             ...future.value <- base::withVisible(base::local({
[10:26:01.921]                 withCallingHandlers({
[10:26:01.921]                   getOption("future.globals.onMissing")
[10:26:01.921]                 }, immediateCondition = function(cond) {
[10:26:01.921]                   save_rds <- function (object, pathname, ...) 
[10:26:01.921]                   {
[10:26:01.921]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:01.921]                     if (file_test("-f", pathname_tmp)) {
[10:26:01.921]                       fi_tmp <- file.info(pathname_tmp)
[10:26:01.921]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:01.921]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:01.921]                         fi_tmp[["mtime"]])
[10:26:01.921]                     }
[10:26:01.921]                     tryCatch({
[10:26:01.921]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:01.921]                     }, error = function(ex) {
[10:26:01.921]                       msg <- conditionMessage(ex)
[10:26:01.921]                       fi_tmp <- file.info(pathname_tmp)
[10:26:01.921]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:01.921]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:01.921]                         fi_tmp[["mtime"]], msg)
[10:26:01.921]                       ex$message <- msg
[10:26:01.921]                       stop(ex)
[10:26:01.921]                     })
[10:26:01.921]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:01.921]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:01.921]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:01.921]                       fi_tmp <- file.info(pathname_tmp)
[10:26:01.921]                       fi <- file.info(pathname)
[10:26:01.921]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:01.921]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:01.921]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:01.921]                         fi[["size"]], fi[["mtime"]])
[10:26:01.921]                       stop(msg)
[10:26:01.921]                     }
[10:26:01.921]                     invisible(pathname)
[10:26:01.921]                   }
[10:26:01.921]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:01.921]                     rootPath = tempdir()) 
[10:26:01.921]                   {
[10:26:01.921]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:01.921]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:01.921]                       tmpdir = path, fileext = ".rds")
[10:26:01.921]                     save_rds(obj, file)
[10:26:01.921]                   }
[10:26:01.921]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4gE0AX/.future/immediateConditions")
[10:26:01.921]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:01.921]                   {
[10:26:01.921]                     inherits <- base::inherits
[10:26:01.921]                     invokeRestart <- base::invokeRestart
[10:26:01.921]                     is.null <- base::is.null
[10:26:01.921]                     muffled <- FALSE
[10:26:01.921]                     if (inherits(cond, "message")) {
[10:26:01.921]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:01.921]                       if (muffled) 
[10:26:01.921]                         invokeRestart("muffleMessage")
[10:26:01.921]                     }
[10:26:01.921]                     else if (inherits(cond, "warning")) {
[10:26:01.921]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:01.921]                       if (muffled) 
[10:26:01.921]                         invokeRestart("muffleWarning")
[10:26:01.921]                     }
[10:26:01.921]                     else if (inherits(cond, "condition")) {
[10:26:01.921]                       if (!is.null(pattern)) {
[10:26:01.921]                         computeRestarts <- base::computeRestarts
[10:26:01.921]                         grepl <- base::grepl
[10:26:01.921]                         restarts <- computeRestarts(cond)
[10:26:01.921]                         for (restart in restarts) {
[10:26:01.921]                           name <- restart$name
[10:26:01.921]                           if (is.null(name)) 
[10:26:01.921]                             next
[10:26:01.921]                           if (!grepl(pattern, name)) 
[10:26:01.921]                             next
[10:26:01.921]                           invokeRestart(restart)
[10:26:01.921]                           muffled <- TRUE
[10:26:01.921]                           break
[10:26:01.921]                         }
[10:26:01.921]                       }
[10:26:01.921]                     }
[10:26:01.921]                     invisible(muffled)
[10:26:01.921]                   }
[10:26:01.921]                   muffleCondition(cond)
[10:26:01.921]                 })
[10:26:01.921]             }))
[10:26:01.921]             future::FutureResult(value = ...future.value$value, 
[10:26:01.921]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:01.921]                   ...future.rng), globalenv = if (FALSE) 
[10:26:01.921]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:01.921]                     ...future.globalenv.names))
[10:26:01.921]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:01.921]         }, condition = base::local({
[10:26:01.921]             c <- base::c
[10:26:01.921]             inherits <- base::inherits
[10:26:01.921]             invokeRestart <- base::invokeRestart
[10:26:01.921]             length <- base::length
[10:26:01.921]             list <- base::list
[10:26:01.921]             seq.int <- base::seq.int
[10:26:01.921]             signalCondition <- base::signalCondition
[10:26:01.921]             sys.calls <- base::sys.calls
[10:26:01.921]             `[[` <- base::`[[`
[10:26:01.921]             `+` <- base::`+`
[10:26:01.921]             `<<-` <- base::`<<-`
[10:26:01.921]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:01.921]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:01.921]                   3L)]
[10:26:01.921]             }
[10:26:01.921]             function(cond) {
[10:26:01.921]                 is_error <- inherits(cond, "error")
[10:26:01.921]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:01.921]                   NULL)
[10:26:01.921]                 if (is_error) {
[10:26:01.921]                   sessionInformation <- function() {
[10:26:01.921]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:01.921]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:01.921]                       search = base::search(), system = base::Sys.info())
[10:26:01.921]                   }
[10:26:01.921]                   ...future.conditions[[length(...future.conditions) + 
[10:26:01.921]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:01.921]                     cond$call), session = sessionInformation(), 
[10:26:01.921]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:01.921]                   signalCondition(cond)
[10:26:01.921]                 }
[10:26:01.921]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:01.921]                 "immediateCondition"))) {
[10:26:01.921]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:01.921]                   ...future.conditions[[length(...future.conditions) + 
[10:26:01.921]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:01.921]                   if (TRUE && !signal) {
[10:26:01.921]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:01.921]                     {
[10:26:01.921]                       inherits <- base::inherits
[10:26:01.921]                       invokeRestart <- base::invokeRestart
[10:26:01.921]                       is.null <- base::is.null
[10:26:01.921]                       muffled <- FALSE
[10:26:01.921]                       if (inherits(cond, "message")) {
[10:26:01.921]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:01.921]                         if (muffled) 
[10:26:01.921]                           invokeRestart("muffleMessage")
[10:26:01.921]                       }
[10:26:01.921]                       else if (inherits(cond, "warning")) {
[10:26:01.921]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:01.921]                         if (muffled) 
[10:26:01.921]                           invokeRestart("muffleWarning")
[10:26:01.921]                       }
[10:26:01.921]                       else if (inherits(cond, "condition")) {
[10:26:01.921]                         if (!is.null(pattern)) {
[10:26:01.921]                           computeRestarts <- base::computeRestarts
[10:26:01.921]                           grepl <- base::grepl
[10:26:01.921]                           restarts <- computeRestarts(cond)
[10:26:01.921]                           for (restart in restarts) {
[10:26:01.921]                             name <- restart$name
[10:26:01.921]                             if (is.null(name)) 
[10:26:01.921]                               next
[10:26:01.921]                             if (!grepl(pattern, name)) 
[10:26:01.921]                               next
[10:26:01.921]                             invokeRestart(restart)
[10:26:01.921]                             muffled <- TRUE
[10:26:01.921]                             break
[10:26:01.921]                           }
[10:26:01.921]                         }
[10:26:01.921]                       }
[10:26:01.921]                       invisible(muffled)
[10:26:01.921]                     }
[10:26:01.921]                     muffleCondition(cond, pattern = "^muffle")
[10:26:01.921]                   }
[10:26:01.921]                 }
[10:26:01.921]                 else {
[10:26:01.921]                   if (TRUE) {
[10:26:01.921]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:01.921]                     {
[10:26:01.921]                       inherits <- base::inherits
[10:26:01.921]                       invokeRestart <- base::invokeRestart
[10:26:01.921]                       is.null <- base::is.null
[10:26:01.921]                       muffled <- FALSE
[10:26:01.921]                       if (inherits(cond, "message")) {
[10:26:01.921]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:01.921]                         if (muffled) 
[10:26:01.921]                           invokeRestart("muffleMessage")
[10:26:01.921]                       }
[10:26:01.921]                       else if (inherits(cond, "warning")) {
[10:26:01.921]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:01.921]                         if (muffled) 
[10:26:01.921]                           invokeRestart("muffleWarning")
[10:26:01.921]                       }
[10:26:01.921]                       else if (inherits(cond, "condition")) {
[10:26:01.921]                         if (!is.null(pattern)) {
[10:26:01.921]                           computeRestarts <- base::computeRestarts
[10:26:01.921]                           grepl <- base::grepl
[10:26:01.921]                           restarts <- computeRestarts(cond)
[10:26:01.921]                           for (restart in restarts) {
[10:26:01.921]                             name <- restart$name
[10:26:01.921]                             if (is.null(name)) 
[10:26:01.921]                               next
[10:26:01.921]                             if (!grepl(pattern, name)) 
[10:26:01.921]                               next
[10:26:01.921]                             invokeRestart(restart)
[10:26:01.921]                             muffled <- TRUE
[10:26:01.921]                             break
[10:26:01.921]                           }
[10:26:01.921]                         }
[10:26:01.921]                       }
[10:26:01.921]                       invisible(muffled)
[10:26:01.921]                     }
[10:26:01.921]                     muffleCondition(cond, pattern = "^muffle")
[10:26:01.921]                   }
[10:26:01.921]                 }
[10:26:01.921]             }
[10:26:01.921]         }))
[10:26:01.921]     }, error = function(ex) {
[10:26:01.921]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:01.921]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:01.921]                 ...future.rng), started = ...future.startTime, 
[10:26:01.921]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:01.921]             version = "1.8"), class = "FutureResult")
[10:26:01.921]     }, finally = {
[10:26:01.921]         if (!identical(...future.workdir, getwd())) 
[10:26:01.921]             setwd(...future.workdir)
[10:26:01.921]         {
[10:26:01.921]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:01.921]                 ...future.oldOptions$nwarnings <- NULL
[10:26:01.921]             }
[10:26:01.921]             base::options(...future.oldOptions)
[10:26:01.921]             if (.Platform$OS.type == "windows") {
[10:26:01.921]                 old_names <- names(...future.oldEnvVars)
[10:26:01.921]                 envs <- base::Sys.getenv()
[10:26:01.921]                 names <- names(envs)
[10:26:01.921]                 common <- intersect(names, old_names)
[10:26:01.921]                 added <- setdiff(names, old_names)
[10:26:01.921]                 removed <- setdiff(old_names, names)
[10:26:01.921]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:01.921]                   envs[common]]
[10:26:01.921]                 NAMES <- toupper(changed)
[10:26:01.921]                 args <- list()
[10:26:01.921]                 for (kk in seq_along(NAMES)) {
[10:26:01.921]                   name <- changed[[kk]]
[10:26:01.921]                   NAME <- NAMES[[kk]]
[10:26:01.921]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:01.921]                     next
[10:26:01.921]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:01.921]                 }
[10:26:01.921]                 NAMES <- toupper(added)
[10:26:01.921]                 for (kk in seq_along(NAMES)) {
[10:26:01.921]                   name <- added[[kk]]
[10:26:01.921]                   NAME <- NAMES[[kk]]
[10:26:01.921]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:01.921]                     next
[10:26:01.921]                   args[[name]] <- ""
[10:26:01.921]                 }
[10:26:01.921]                 NAMES <- toupper(removed)
[10:26:01.921]                 for (kk in seq_along(NAMES)) {
[10:26:01.921]                   name <- removed[[kk]]
[10:26:01.921]                   NAME <- NAMES[[kk]]
[10:26:01.921]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:01.921]                     next
[10:26:01.921]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:01.921]                 }
[10:26:01.921]                 if (length(args) > 0) 
[10:26:01.921]                   base::do.call(base::Sys.setenv, args = args)
[10:26:01.921]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:01.921]             }
[10:26:01.921]             else {
[10:26:01.921]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:01.921]             }
[10:26:01.921]             {
[10:26:01.921]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:01.921]                   0L) {
[10:26:01.921]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:01.921]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:01.921]                   base::options(opts)
[10:26:01.921]                 }
[10:26:01.921]                 {
[10:26:01.921]                   {
[10:26:01.921]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:01.921]                     NULL
[10:26:01.921]                   }
[10:26:01.921]                   options(future.plan = NULL)
[10:26:01.921]                   if (is.na(NA_character_)) 
[10:26:01.921]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:01.921]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:01.921]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:01.921]                     envir = parent.frame()) 
[10:26:01.921]                   {
[10:26:01.921]                     default_workers <- missing(workers)
[10:26:01.921]                     if (is.function(workers)) 
[10:26:01.921]                       workers <- workers()
[10:26:01.921]                     workers <- structure(as.integer(workers), 
[10:26:01.921]                       class = class(workers))
[10:26:01.921]                     stop_if_not(is.finite(workers), workers >= 
[10:26:01.921]                       1L)
[10:26:01.921]                     if ((workers == 1L && !inherits(workers, 
[10:26:01.921]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:01.921]                       if (default_workers) 
[10:26:01.921]                         supportsMulticore(warn = TRUE)
[10:26:01.921]                       return(sequential(..., envir = envir))
[10:26:01.921]                     }
[10:26:01.921]                     oopts <- options(mc.cores = workers)
[10:26:01.921]                     on.exit(options(oopts))
[10:26:01.921]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:01.921]                       envir = envir)
[10:26:01.921]                     if (!future$lazy) 
[10:26:01.921]                       future <- run(future)
[10:26:01.921]                     invisible(future)
[10:26:01.921]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:01.921]                 }
[10:26:01.921]             }
[10:26:01.921]         }
[10:26:01.921]     })
[10:26:01.921]     if (TRUE) {
[10:26:01.921]         base::sink(type = "output", split = FALSE)
[10:26:01.921]         if (TRUE) {
[10:26:01.921]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:01.921]         }
[10:26:01.921]         else {
[10:26:01.921]             ...future.result["stdout"] <- base::list(NULL)
[10:26:01.921]         }
[10:26:01.921]         base::close(...future.stdout)
[10:26:01.921]         ...future.stdout <- NULL
[10:26:01.921]     }
[10:26:01.921]     ...future.result$conditions <- ...future.conditions
[10:26:01.921]     ...future.result$finished <- base::Sys.time()
[10:26:01.921]     ...future.result
[10:26:01.921] }
[10:26:01.924] requestCore(): workers = 2
[10:26:01.925] MulticoreFuture started
[10:26:01.926] - Launch lazy future ... done
[10:26:01.926] run() for ‘MulticoreFuture’ ... done
[10:26:01.926] result() for MulticoreFuture ...
[10:26:01.926] plan(): Setting new future strategy stack:
[10:26:01.927] List of future strategies:
[10:26:01.927] 1. sequential:
[10:26:01.927]    - args: function (..., envir = parent.frame())
[10:26:01.927]    - tweaked: FALSE
[10:26:01.927]    - call: NULL
[10:26:01.927] plan(): nbrOfWorkers() = 1
[10:26:01.929] plan(): Setting new future strategy stack:
[10:26:01.929] List of future strategies:
[10:26:01.929] 1. multicore:
[10:26:01.929]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:01.929]    - tweaked: FALSE
[10:26:01.929]    - call: plan(strategy)
[10:26:01.934] plan(): nbrOfWorkers() = 2
[10:26:01.935] result() for MulticoreFuture ...
[10:26:01.935] result() for MulticoreFuture ... done
[10:26:01.935] result() for MulticoreFuture ... done
[10:26:01.935] result() for MulticoreFuture ...
[10:26:01.935] result() for MulticoreFuture ... done
[10:26:01.936] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:01.936] Searching for globals...
[10:26:01.938] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[10:26:01.938] Searching for globals...
[10:26:01.939] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[10:26:01.939] Searching for globals ... DONE
[10:26:01.939] Resolving globals: FALSE
[10:26:01.940] The total size of the 1 globals is 160 bytes (160 bytes)
[10:26:01.940] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 160 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (160 bytes of class ‘list’)
[10:26:01.940] - globals: [1] ‘data’
[10:26:01.941] 
[10:26:01.941] getGlobalsAndPackages() ... DONE
[10:26:01.941] run() for ‘Future’ ...
[10:26:01.944] - state: ‘created’
[10:26:01.944] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:01.948] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:01.948] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:01.949]   - Field: ‘label’
[10:26:01.949]   - Field: ‘local’
[10:26:01.949]   - Field: ‘owner’
[10:26:01.949]   - Field: ‘envir’
[10:26:01.949]   - Field: ‘workers’
[10:26:01.949]   - Field: ‘packages’
[10:26:01.949]   - Field: ‘gc’
[10:26:01.949]   - Field: ‘job’
[10:26:01.950]   - Field: ‘conditions’
[10:26:01.950]   - Field: ‘expr’
[10:26:01.950]   - Field: ‘uuid’
[10:26:01.950]   - Field: ‘seed’
[10:26:01.950]   - Field: ‘version’
[10:26:01.950]   - Field: ‘result’
[10:26:01.950]   - Field: ‘asynchronous’
[10:26:01.950]   - Field: ‘calls’
[10:26:01.951]   - Field: ‘globals’
[10:26:01.951]   - Field: ‘stdout’
[10:26:01.951]   - Field: ‘earlySignal’
[10:26:01.951]   - Field: ‘lazy’
[10:26:01.951]   - Field: ‘state’
[10:26:01.951] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:01.951] - Launch lazy future ...
[10:26:01.952] Packages needed by the future expression (n = 0): <none>
[10:26:01.952] Packages needed by future strategies (n = 0): <none>
[10:26:01.952] {
[10:26:01.952]     {
[10:26:01.952]         {
[10:26:01.952]             ...future.startTime <- base::Sys.time()
[10:26:01.952]             {
[10:26:01.952]                 {
[10:26:01.952]                   {
[10:26:01.952]                     {
[10:26:01.952]                       base::local({
[10:26:01.952]                         has_future <- base::requireNamespace("future", 
[10:26:01.952]                           quietly = TRUE)
[10:26:01.952]                         if (has_future) {
[10:26:01.952]                           ns <- base::getNamespace("future")
[10:26:01.952]                           version <- ns[[".package"]][["version"]]
[10:26:01.952]                           if (is.null(version)) 
[10:26:01.952]                             version <- utils::packageVersion("future")
[10:26:01.952]                         }
[10:26:01.952]                         else {
[10:26:01.952]                           version <- NULL
[10:26:01.952]                         }
[10:26:01.952]                         if (!has_future || version < "1.8.0") {
[10:26:01.952]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:01.952]                             "", base::R.version$version.string), 
[10:26:01.952]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:01.952]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:01.952]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:01.952]                               "release", "version")], collapse = " "), 
[10:26:01.952]                             hostname = base::Sys.info()[["nodename"]])
[10:26:01.952]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:01.952]                             info)
[10:26:01.952]                           info <- base::paste(info, collapse = "; ")
[10:26:01.952]                           if (!has_future) {
[10:26:01.952]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:01.952]                               info)
[10:26:01.952]                           }
[10:26:01.952]                           else {
[10:26:01.952]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:01.952]                               info, version)
[10:26:01.952]                           }
[10:26:01.952]                           base::stop(msg)
[10:26:01.952]                         }
[10:26:01.952]                       })
[10:26:01.952]                     }
[10:26:01.952]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:01.952]                     base::options(mc.cores = 1L)
[10:26:01.952]                   }
[10:26:01.952]                   options(future.plan = NULL)
[10:26:01.952]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:01.952]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:01.952]                 }
[10:26:01.952]                 ...future.workdir <- getwd()
[10:26:01.952]             }
[10:26:01.952]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:01.952]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:01.952]         }
[10:26:01.952]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[10:26:01.952]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:01.952]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[10:26:01.952]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:01.952]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:01.952]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:01.952]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:01.952]             base::names(...future.oldOptions))
[10:26:01.952]     }
[10:26:01.952]     if (FALSE) {
[10:26:01.952]     }
[10:26:01.952]     else {
[10:26:01.952]         if (TRUE) {
[10:26:01.952]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:01.952]                 open = "w")
[10:26:01.952]         }
[10:26:01.952]         else {
[10:26:01.952]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:01.952]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:01.952]         }
[10:26:01.952]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:01.952]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:01.952]             base::sink(type = "output", split = FALSE)
[10:26:01.952]             base::close(...future.stdout)
[10:26:01.952]         }, add = TRUE)
[10:26:01.952]     }
[10:26:01.952]     ...future.frame <- base::sys.nframe()
[10:26:01.952]     ...future.conditions <- base::list()
[10:26:01.952]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:01.952]     if (FALSE) {
[10:26:01.952]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:01.952]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:01.952]     }
[10:26:01.952]     ...future.result <- base::tryCatch({
[10:26:01.952]         base::withCallingHandlers({
[10:26:01.952]             ...future.value <- base::withVisible(base::local({
[10:26:01.952]                 withCallingHandlers({
[10:26:01.952]                   subset(data, x < 3)$y
[10:26:01.952]                 }, immediateCondition = function(cond) {
[10:26:01.952]                   save_rds <- function (object, pathname, ...) 
[10:26:01.952]                   {
[10:26:01.952]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:01.952]                     if (file_test("-f", pathname_tmp)) {
[10:26:01.952]                       fi_tmp <- file.info(pathname_tmp)
[10:26:01.952]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:01.952]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:01.952]                         fi_tmp[["mtime"]])
[10:26:01.952]                     }
[10:26:01.952]                     tryCatch({
[10:26:01.952]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:01.952]                     }, error = function(ex) {
[10:26:01.952]                       msg <- conditionMessage(ex)
[10:26:01.952]                       fi_tmp <- file.info(pathname_tmp)
[10:26:01.952]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:01.952]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:01.952]                         fi_tmp[["mtime"]], msg)
[10:26:01.952]                       ex$message <- msg
[10:26:01.952]                       stop(ex)
[10:26:01.952]                     })
[10:26:01.952]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:01.952]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:01.952]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:01.952]                       fi_tmp <- file.info(pathname_tmp)
[10:26:01.952]                       fi <- file.info(pathname)
[10:26:01.952]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:01.952]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:01.952]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:01.952]                         fi[["size"]], fi[["mtime"]])
[10:26:01.952]                       stop(msg)
[10:26:01.952]                     }
[10:26:01.952]                     invisible(pathname)
[10:26:01.952]                   }
[10:26:01.952]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:01.952]                     rootPath = tempdir()) 
[10:26:01.952]                   {
[10:26:01.952]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:01.952]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:01.952]                       tmpdir = path, fileext = ".rds")
[10:26:01.952]                     save_rds(obj, file)
[10:26:01.952]                   }
[10:26:01.952]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4gE0AX/.future/immediateConditions")
[10:26:01.952]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:01.952]                   {
[10:26:01.952]                     inherits <- base::inherits
[10:26:01.952]                     invokeRestart <- base::invokeRestart
[10:26:01.952]                     is.null <- base::is.null
[10:26:01.952]                     muffled <- FALSE
[10:26:01.952]                     if (inherits(cond, "message")) {
[10:26:01.952]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:01.952]                       if (muffled) 
[10:26:01.952]                         invokeRestart("muffleMessage")
[10:26:01.952]                     }
[10:26:01.952]                     else if (inherits(cond, "warning")) {
[10:26:01.952]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:01.952]                       if (muffled) 
[10:26:01.952]                         invokeRestart("muffleWarning")
[10:26:01.952]                     }
[10:26:01.952]                     else if (inherits(cond, "condition")) {
[10:26:01.952]                       if (!is.null(pattern)) {
[10:26:01.952]                         computeRestarts <- base::computeRestarts
[10:26:01.952]                         grepl <- base::grepl
[10:26:01.952]                         restarts <- computeRestarts(cond)
[10:26:01.952]                         for (restart in restarts) {
[10:26:01.952]                           name <- restart$name
[10:26:01.952]                           if (is.null(name)) 
[10:26:01.952]                             next
[10:26:01.952]                           if (!grepl(pattern, name)) 
[10:26:01.952]                             next
[10:26:01.952]                           invokeRestart(restart)
[10:26:01.952]                           muffled <- TRUE
[10:26:01.952]                           break
[10:26:01.952]                         }
[10:26:01.952]                       }
[10:26:01.952]                     }
[10:26:01.952]                     invisible(muffled)
[10:26:01.952]                   }
[10:26:01.952]                   muffleCondition(cond)
[10:26:01.952]                 })
[10:26:01.952]             }))
[10:26:01.952]             future::FutureResult(value = ...future.value$value, 
[10:26:01.952]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:01.952]                   ...future.rng), globalenv = if (FALSE) 
[10:26:01.952]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:01.952]                     ...future.globalenv.names))
[10:26:01.952]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:01.952]         }, condition = base::local({
[10:26:01.952]             c <- base::c
[10:26:01.952]             inherits <- base::inherits
[10:26:01.952]             invokeRestart <- base::invokeRestart
[10:26:01.952]             length <- base::length
[10:26:01.952]             list <- base::list
[10:26:01.952]             seq.int <- base::seq.int
[10:26:01.952]             signalCondition <- base::signalCondition
[10:26:01.952]             sys.calls <- base::sys.calls
[10:26:01.952]             `[[` <- base::`[[`
[10:26:01.952]             `+` <- base::`+`
[10:26:01.952]             `<<-` <- base::`<<-`
[10:26:01.952]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:01.952]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:01.952]                   3L)]
[10:26:01.952]             }
[10:26:01.952]             function(cond) {
[10:26:01.952]                 is_error <- inherits(cond, "error")
[10:26:01.952]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:01.952]                   NULL)
[10:26:01.952]                 if (is_error) {
[10:26:01.952]                   sessionInformation <- function() {
[10:26:01.952]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:01.952]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:01.952]                       search = base::search(), system = base::Sys.info())
[10:26:01.952]                   }
[10:26:01.952]                   ...future.conditions[[length(...future.conditions) + 
[10:26:01.952]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:01.952]                     cond$call), session = sessionInformation(), 
[10:26:01.952]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:01.952]                   signalCondition(cond)
[10:26:01.952]                 }
[10:26:01.952]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:01.952]                 "immediateCondition"))) {
[10:26:01.952]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:01.952]                   ...future.conditions[[length(...future.conditions) + 
[10:26:01.952]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:01.952]                   if (TRUE && !signal) {
[10:26:01.952]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:01.952]                     {
[10:26:01.952]                       inherits <- base::inherits
[10:26:01.952]                       invokeRestart <- base::invokeRestart
[10:26:01.952]                       is.null <- base::is.null
[10:26:01.952]                       muffled <- FALSE
[10:26:01.952]                       if (inherits(cond, "message")) {
[10:26:01.952]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:01.952]                         if (muffled) 
[10:26:01.952]                           invokeRestart("muffleMessage")
[10:26:01.952]                       }
[10:26:01.952]                       else if (inherits(cond, "warning")) {
[10:26:01.952]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:01.952]                         if (muffled) 
[10:26:01.952]                           invokeRestart("muffleWarning")
[10:26:01.952]                       }
[10:26:01.952]                       else if (inherits(cond, "condition")) {
[10:26:01.952]                         if (!is.null(pattern)) {
[10:26:01.952]                           computeRestarts <- base::computeRestarts
[10:26:01.952]                           grepl <- base::grepl
[10:26:01.952]                           restarts <- computeRestarts(cond)
[10:26:01.952]                           for (restart in restarts) {
[10:26:01.952]                             name <- restart$name
[10:26:01.952]                             if (is.null(name)) 
[10:26:01.952]                               next
[10:26:01.952]                             if (!grepl(pattern, name)) 
[10:26:01.952]                               next
[10:26:01.952]                             invokeRestart(restart)
[10:26:01.952]                             muffled <- TRUE
[10:26:01.952]                             break
[10:26:01.952]                           }
[10:26:01.952]                         }
[10:26:01.952]                       }
[10:26:01.952]                       invisible(muffled)
[10:26:01.952]                     }
[10:26:01.952]                     muffleCondition(cond, pattern = "^muffle")
[10:26:01.952]                   }
[10:26:01.952]                 }
[10:26:01.952]                 else {
[10:26:01.952]                   if (TRUE) {
[10:26:01.952]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:01.952]                     {
[10:26:01.952]                       inherits <- base::inherits
[10:26:01.952]                       invokeRestart <- base::invokeRestart
[10:26:01.952]                       is.null <- base::is.null
[10:26:01.952]                       muffled <- FALSE
[10:26:01.952]                       if (inherits(cond, "message")) {
[10:26:01.952]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:01.952]                         if (muffled) 
[10:26:01.952]                           invokeRestart("muffleMessage")
[10:26:01.952]                       }
[10:26:01.952]                       else if (inherits(cond, "warning")) {
[10:26:01.952]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:01.952]                         if (muffled) 
[10:26:01.952]                           invokeRestart("muffleWarning")
[10:26:01.952]                       }
[10:26:01.952]                       else if (inherits(cond, "condition")) {
[10:26:01.952]                         if (!is.null(pattern)) {
[10:26:01.952]                           computeRestarts <- base::computeRestarts
[10:26:01.952]                           grepl <- base::grepl
[10:26:01.952]                           restarts <- computeRestarts(cond)
[10:26:01.952]                           for (restart in restarts) {
[10:26:01.952]                             name <- restart$name
[10:26:01.952]                             if (is.null(name)) 
[10:26:01.952]                               next
[10:26:01.952]                             if (!grepl(pattern, name)) 
[10:26:01.952]                               next
[10:26:01.952]                             invokeRestart(restart)
[10:26:01.952]                             muffled <- TRUE
[10:26:01.952]                             break
[10:26:01.952]                           }
[10:26:01.952]                         }
[10:26:01.952]                       }
[10:26:01.952]                       invisible(muffled)
[10:26:01.952]                     }
[10:26:01.952]                     muffleCondition(cond, pattern = "^muffle")
[10:26:01.952]                   }
[10:26:01.952]                 }
[10:26:01.952]             }
[10:26:01.952]         }))
[10:26:01.952]     }, error = function(ex) {
[10:26:01.952]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:01.952]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:01.952]                 ...future.rng), started = ...future.startTime, 
[10:26:01.952]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:01.952]             version = "1.8"), class = "FutureResult")
[10:26:01.952]     }, finally = {
[10:26:01.952]         if (!identical(...future.workdir, getwd())) 
[10:26:01.952]             setwd(...future.workdir)
[10:26:01.952]         {
[10:26:01.952]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:01.952]                 ...future.oldOptions$nwarnings <- NULL
[10:26:01.952]             }
[10:26:01.952]             base::options(...future.oldOptions)
[10:26:01.952]             if (.Platform$OS.type == "windows") {
[10:26:01.952]                 old_names <- names(...future.oldEnvVars)
[10:26:01.952]                 envs <- base::Sys.getenv()
[10:26:01.952]                 names <- names(envs)
[10:26:01.952]                 common <- intersect(names, old_names)
[10:26:01.952]                 added <- setdiff(names, old_names)
[10:26:01.952]                 removed <- setdiff(old_names, names)
[10:26:01.952]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:01.952]                   envs[common]]
[10:26:01.952]                 NAMES <- toupper(changed)
[10:26:01.952]                 args <- list()
[10:26:01.952]                 for (kk in seq_along(NAMES)) {
[10:26:01.952]                   name <- changed[[kk]]
[10:26:01.952]                   NAME <- NAMES[[kk]]
[10:26:01.952]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:01.952]                     next
[10:26:01.952]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:01.952]                 }
[10:26:01.952]                 NAMES <- toupper(added)
[10:26:01.952]                 for (kk in seq_along(NAMES)) {
[10:26:01.952]                   name <- added[[kk]]
[10:26:01.952]                   NAME <- NAMES[[kk]]
[10:26:01.952]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:01.952]                     next
[10:26:01.952]                   args[[name]] <- ""
[10:26:01.952]                 }
[10:26:01.952]                 NAMES <- toupper(removed)
[10:26:01.952]                 for (kk in seq_along(NAMES)) {
[10:26:01.952]                   name <- removed[[kk]]
[10:26:01.952]                   NAME <- NAMES[[kk]]
[10:26:01.952]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:01.952]                     next
[10:26:01.952]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:01.952]                 }
[10:26:01.952]                 if (length(args) > 0) 
[10:26:01.952]                   base::do.call(base::Sys.setenv, args = args)
[10:26:01.952]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:01.952]             }
[10:26:01.952]             else {
[10:26:01.952]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:01.952]             }
[10:26:01.952]             {
[10:26:01.952]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:01.952]                   0L) {
[10:26:01.952]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:01.952]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:01.952]                   base::options(opts)
[10:26:01.952]                 }
[10:26:01.952]                 {
[10:26:01.952]                   {
[10:26:01.952]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:01.952]                     NULL
[10:26:01.952]                   }
[10:26:01.952]                   options(future.plan = NULL)
[10:26:01.952]                   if (is.na(NA_character_)) 
[10:26:01.952]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:01.952]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:01.952]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:01.952]                     envir = parent.frame()) 
[10:26:01.952]                   {
[10:26:01.952]                     default_workers <- missing(workers)
[10:26:01.952]                     if (is.function(workers)) 
[10:26:01.952]                       workers <- workers()
[10:26:01.952]                     workers <- structure(as.integer(workers), 
[10:26:01.952]                       class = class(workers))
[10:26:01.952]                     stop_if_not(is.finite(workers), workers >= 
[10:26:01.952]                       1L)
[10:26:01.952]                     if ((workers == 1L && !inherits(workers, 
[10:26:01.952]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:01.952]                       if (default_workers) 
[10:26:01.952]                         supportsMulticore(warn = TRUE)
[10:26:01.952]                       return(sequential(..., envir = envir))
[10:26:01.952]                     }
[10:26:01.952]                     oopts <- options(mc.cores = workers)
[10:26:01.952]                     on.exit(options(oopts))
[10:26:01.952]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:01.952]                       envir = envir)
[10:26:01.952]                     if (!future$lazy) 
[10:26:01.952]                       future <- run(future)
[10:26:01.952]                     invisible(future)
[10:26:01.952]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:01.952]                 }
[10:26:01.952]             }
[10:26:01.952]         }
[10:26:01.952]     })
[10:26:01.952]     if (TRUE) {
[10:26:01.952]         base::sink(type = "output", split = FALSE)
[10:26:01.952]         if (TRUE) {
[10:26:01.952]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:01.952]         }
[10:26:01.952]         else {
[10:26:01.952]             ...future.result["stdout"] <- base::list(NULL)
[10:26:01.952]         }
[10:26:01.952]         base::close(...future.stdout)
[10:26:01.952]         ...future.stdout <- NULL
[10:26:01.952]     }
[10:26:01.952]     ...future.result$conditions <- ...future.conditions
[10:26:01.952]     ...future.result$finished <- base::Sys.time()
[10:26:01.952]     ...future.result
[10:26:01.952] }
[10:26:01.955] assign_globals() ...
[10:26:01.955] List of 1
[10:26:01.955]  $ data:'data.frame':	5 obs. of  2 variables:
[10:26:01.955]   ..$ x: int [1:5] 1 2 3 4 5
[10:26:01.955]   ..$ y: int [1:5] 1 2 3 4 5
[10:26:01.955]  - attr(*, "where")=List of 1
[10:26:01.955]   ..$ data:<environment: R_EmptyEnv> 
[10:26:01.955]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:01.955]  - attr(*, "resolved")= logi FALSE
[10:26:01.955]  - attr(*, "total_size")= num 160
[10:26:01.955]  - attr(*, "already-done")= logi TRUE
[10:26:01.959] - copied ‘data’ to environment
[10:26:01.959] assign_globals() ... done
[10:26:01.959] requestCore(): workers = 2
[10:26:01.961] MulticoreFuture started
[10:26:01.961] - Launch lazy future ... done
[10:26:01.961] run() for ‘MulticoreFuture’ ... done
[10:26:01.962] result() for MulticoreFuture ...
[10:26:01.962] plan(): Setting new future strategy stack:
[10:26:01.962] List of future strategies:
[10:26:01.962] 1. sequential:
[10:26:01.962]    - args: function (..., envir = parent.frame())
[10:26:01.962]    - tweaked: FALSE
[10:26:01.962]    - call: NULL
[10:26:01.963] plan(): nbrOfWorkers() = 1
[10:26:01.965] plan(): Setting new future strategy stack:
[10:26:01.965] List of future strategies:
[10:26:01.965] 1. multicore:
[10:26:01.965]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:01.965]    - tweaked: FALSE
[10:26:01.965]    - call: plan(strategy)
[10:26:01.970] plan(): nbrOfWorkers() = 2
[10:26:01.971] result() for MulticoreFuture ...
[10:26:01.971] result() for MulticoreFuture ... done
[10:26:01.971] result() for MulticoreFuture ... done
[10:26:01.971] result() for MulticoreFuture ...
[10:26:01.971] result() for MulticoreFuture ... done
[10:26:01.972] plan(): Setting new future strategy stack:
[10:26:01.972] List of future strategies:
[10:26:01.972] 1. sequential:
[10:26:01.972]    - args: function (..., envir = parent.frame())
[10:26:01.972]    - tweaked: FALSE
[10:26:01.972]    - call: plan(list(sequential, strategy))
[10:26:01.972] 2. multicore:
[10:26:01.972]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:01.972]    - tweaked: FALSE
[10:26:01.972]    - call: plan(list(sequential, strategy))
[10:26:01.973] plan(): nbrOfWorkers() = 1
[10:26:01.973] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[10:26:01.974] Searching for globals...
[10:26:01.977] - globals found: [8] ‘{’, ‘<-’, ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’, ‘%<-%’
[10:26:01.977] Searching for globals ... DONE
[10:26:01.978] Resolving globals: FALSE
[10:26:01.978] The total size of the 1 globals is 160 bytes (160 bytes)
[10:26:01.979] The total size of the 1 globals exported for future expression (‘{; a %<-% subset(data, x < 3)$y; a; }’) is 160 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (160 bytes of class ‘list’)
[10:26:01.979] - globals: [1] ‘data’
[10:26:01.979] - packages: [1] ‘future’
[10:26:01.979] getGlobalsAndPackages() ... DONE
[10:26:01.980] run() for ‘Future’ ...
[10:26:01.980] - state: ‘created’
[10:26:01.980] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:01.980] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:01.980] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:01.980]   - Field: ‘label’
[10:26:01.981]   - Field: ‘local’
[10:26:01.981]   - Field: ‘owner’
[10:26:01.981]   - Field: ‘envir’
[10:26:01.981]   - Field: ‘packages’
[10:26:01.981]   - Field: ‘gc’
[10:26:01.981]   - Field: ‘conditions’
[10:26:01.981]   - Field: ‘expr’
[10:26:01.981]   - Field: ‘uuid’
[10:26:01.982]   - Field: ‘seed’
[10:26:01.982]   - Field: ‘version’
[10:26:01.982]   - Field: ‘result’
[10:26:01.982]   - Field: ‘asynchronous’
[10:26:01.982]   - Field: ‘calls’
[10:26:01.982]   - Field: ‘globals’
[10:26:01.982]   - Field: ‘stdout’
[10:26:01.982]   - Field: ‘earlySignal’
[10:26:01.982]   - Field: ‘lazy’
[10:26:01.983]   - Field: ‘state’
[10:26:01.983] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:01.983] - Launch lazy future ...
[10:26:01.983] Packages needed by the future expression (n = 1): ‘future’
[10:26:01.983] Packages needed by future strategies (n = 1): ‘future’
[10:26:01.984] {
[10:26:01.984]     {
[10:26:01.984]         {
[10:26:01.984]             ...future.startTime <- base::Sys.time()
[10:26:01.984]             {
[10:26:01.984]                 {
[10:26:01.984]                   {
[10:26:01.984]                     {
[10:26:01.984]                       base::local({
[10:26:01.984]                         has_future <- base::requireNamespace("future", 
[10:26:01.984]                           quietly = TRUE)
[10:26:01.984]                         if (has_future) {
[10:26:01.984]                           ns <- base::getNamespace("future")
[10:26:01.984]                           version <- ns[[".package"]][["version"]]
[10:26:01.984]                           if (is.null(version)) 
[10:26:01.984]                             version <- utils::packageVersion("future")
[10:26:01.984]                         }
[10:26:01.984]                         else {
[10:26:01.984]                           version <- NULL
[10:26:01.984]                         }
[10:26:01.984]                         if (!has_future || version < "1.8.0") {
[10:26:01.984]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:01.984]                             "", base::R.version$version.string), 
[10:26:01.984]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:01.984]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:01.984]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:01.984]                               "release", "version")], collapse = " "), 
[10:26:01.984]                             hostname = base::Sys.info()[["nodename"]])
[10:26:01.984]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:01.984]                             info)
[10:26:01.984]                           info <- base::paste(info, collapse = "; ")
[10:26:01.984]                           if (!has_future) {
[10:26:01.984]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:01.984]                               info)
[10:26:01.984]                           }
[10:26:01.984]                           else {
[10:26:01.984]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:01.984]                               info, version)
[10:26:01.984]                           }
[10:26:01.984]                           base::stop(msg)
[10:26:01.984]                         }
[10:26:01.984]                       })
[10:26:01.984]                     }
[10:26:01.984]                     base::local({
[10:26:01.984]                       for (pkg in "future") {
[10:26:01.984]                         base::loadNamespace(pkg)
[10:26:01.984]                         base::library(pkg, character.only = TRUE)
[10:26:01.984]                       }
[10:26:01.984]                     })
[10:26:01.984]                   }
[10:26:01.984]                   options(future.plan = NULL)
[10:26:01.984]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:01.984]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:01.984]                     envir = parent.frame()) 
[10:26:01.984]                   {
[10:26:01.984]                     default_workers <- missing(workers)
[10:26:01.984]                     if (is.function(workers)) 
[10:26:01.984]                       workers <- workers()
[10:26:01.984]                     workers <- structure(as.integer(workers), 
[10:26:01.984]                       class = class(workers))
[10:26:01.984]                     stop_if_not(is.finite(workers), workers >= 
[10:26:01.984]                       1L)
[10:26:01.984]                     if ((workers == 1L && !inherits(workers, 
[10:26:01.984]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:01.984]                       if (default_workers) 
[10:26:01.984]                         supportsMulticore(warn = TRUE)
[10:26:01.984]                       return(sequential(..., envir = envir))
[10:26:01.984]                     }
[10:26:01.984]                     oopts <- options(mc.cores = workers)
[10:26:01.984]                     on.exit(options(oopts))
[10:26:01.984]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:01.984]                       envir = envir)
[10:26:01.984]                     if (!future$lazy) 
[10:26:01.984]                       future <- run(future)
[10:26:01.984]                     invisible(future)
[10:26:01.984]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:01.984]                 }
[10:26:01.984]                 ...future.workdir <- getwd()
[10:26:01.984]             }
[10:26:01.984]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:01.984]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:01.984]         }
[10:26:01.984]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[10:26:01.984]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:01.984]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[10:26:01.984]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:01.984]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:01.984]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:01.984]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:01.984]             base::names(...future.oldOptions))
[10:26:01.984]     }
[10:26:01.984]     if (FALSE) {
[10:26:01.984]     }
[10:26:01.984]     else {
[10:26:01.984]         if (TRUE) {
[10:26:01.984]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:01.984]                 open = "w")
[10:26:01.984]         }
[10:26:01.984]         else {
[10:26:01.984]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:01.984]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:01.984]         }
[10:26:01.984]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:01.984]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:01.984]             base::sink(type = "output", split = FALSE)
[10:26:01.984]             base::close(...future.stdout)
[10:26:01.984]         }, add = TRUE)
[10:26:01.984]     }
[10:26:01.984]     ...future.frame <- base::sys.nframe()
[10:26:01.984]     ...future.conditions <- base::list()
[10:26:01.984]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:01.984]     if (FALSE) {
[10:26:01.984]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:01.984]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:01.984]     }
[10:26:01.984]     ...future.result <- base::tryCatch({
[10:26:01.984]         base::withCallingHandlers({
[10:26:01.984]             ...future.value <- base::withVisible(base::local({
[10:26:01.984]                 a %<-% subset(data, x < 3)$y
[10:26:01.984]                 a
[10:26:01.984]             }))
[10:26:01.984]             future::FutureResult(value = ...future.value$value, 
[10:26:01.984]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:01.984]                   ...future.rng), globalenv = if (FALSE) 
[10:26:01.984]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:01.984]                     ...future.globalenv.names))
[10:26:01.984]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:01.984]         }, condition = base::local({
[10:26:01.984]             c <- base::c
[10:26:01.984]             inherits <- base::inherits
[10:26:01.984]             invokeRestart <- base::invokeRestart
[10:26:01.984]             length <- base::length
[10:26:01.984]             list <- base::list
[10:26:01.984]             seq.int <- base::seq.int
[10:26:01.984]             signalCondition <- base::signalCondition
[10:26:01.984]             sys.calls <- base::sys.calls
[10:26:01.984]             `[[` <- base::`[[`
[10:26:01.984]             `+` <- base::`+`
[10:26:01.984]             `<<-` <- base::`<<-`
[10:26:01.984]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:01.984]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:01.984]                   3L)]
[10:26:01.984]             }
[10:26:01.984]             function(cond) {
[10:26:01.984]                 is_error <- inherits(cond, "error")
[10:26:01.984]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:01.984]                   NULL)
[10:26:01.984]                 if (is_error) {
[10:26:01.984]                   sessionInformation <- function() {
[10:26:01.984]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:01.984]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:01.984]                       search = base::search(), system = base::Sys.info())
[10:26:01.984]                   }
[10:26:01.984]                   ...future.conditions[[length(...future.conditions) + 
[10:26:01.984]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:01.984]                     cond$call), session = sessionInformation(), 
[10:26:01.984]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:01.984]                   signalCondition(cond)
[10:26:01.984]                 }
[10:26:01.984]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:01.984]                 "immediateCondition"))) {
[10:26:01.984]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:01.984]                   ...future.conditions[[length(...future.conditions) + 
[10:26:01.984]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:01.984]                   if (TRUE && !signal) {
[10:26:01.984]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:01.984]                     {
[10:26:01.984]                       inherits <- base::inherits
[10:26:01.984]                       invokeRestart <- base::invokeRestart
[10:26:01.984]                       is.null <- base::is.null
[10:26:01.984]                       muffled <- FALSE
[10:26:01.984]                       if (inherits(cond, "message")) {
[10:26:01.984]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:01.984]                         if (muffled) 
[10:26:01.984]                           invokeRestart("muffleMessage")
[10:26:01.984]                       }
[10:26:01.984]                       else if (inherits(cond, "warning")) {
[10:26:01.984]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:01.984]                         if (muffled) 
[10:26:01.984]                           invokeRestart("muffleWarning")
[10:26:01.984]                       }
[10:26:01.984]                       else if (inherits(cond, "condition")) {
[10:26:01.984]                         if (!is.null(pattern)) {
[10:26:01.984]                           computeRestarts <- base::computeRestarts
[10:26:01.984]                           grepl <- base::grepl
[10:26:01.984]                           restarts <- computeRestarts(cond)
[10:26:01.984]                           for (restart in restarts) {
[10:26:01.984]                             name <- restart$name
[10:26:01.984]                             if (is.null(name)) 
[10:26:01.984]                               next
[10:26:01.984]                             if (!grepl(pattern, name)) 
[10:26:01.984]                               next
[10:26:01.984]                             invokeRestart(restart)
[10:26:01.984]                             muffled <- TRUE
[10:26:01.984]                             break
[10:26:01.984]                           }
[10:26:01.984]                         }
[10:26:01.984]                       }
[10:26:01.984]                       invisible(muffled)
[10:26:01.984]                     }
[10:26:01.984]                     muffleCondition(cond, pattern = "^muffle")
[10:26:01.984]                   }
[10:26:01.984]                 }
[10:26:01.984]                 else {
[10:26:01.984]                   if (TRUE) {
[10:26:01.984]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:01.984]                     {
[10:26:01.984]                       inherits <- base::inherits
[10:26:01.984]                       invokeRestart <- base::invokeRestart
[10:26:01.984]                       is.null <- base::is.null
[10:26:01.984]                       muffled <- FALSE
[10:26:01.984]                       if (inherits(cond, "message")) {
[10:26:01.984]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:01.984]                         if (muffled) 
[10:26:01.984]                           invokeRestart("muffleMessage")
[10:26:01.984]                       }
[10:26:01.984]                       else if (inherits(cond, "warning")) {
[10:26:01.984]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:01.984]                         if (muffled) 
[10:26:01.984]                           invokeRestart("muffleWarning")
[10:26:01.984]                       }
[10:26:01.984]                       else if (inherits(cond, "condition")) {
[10:26:01.984]                         if (!is.null(pattern)) {
[10:26:01.984]                           computeRestarts <- base::computeRestarts
[10:26:01.984]                           grepl <- base::grepl
[10:26:01.984]                           restarts <- computeRestarts(cond)
[10:26:01.984]                           for (restart in restarts) {
[10:26:01.984]                             name <- restart$name
[10:26:01.984]                             if (is.null(name)) 
[10:26:01.984]                               next
[10:26:01.984]                             if (!grepl(pattern, name)) 
[10:26:01.984]                               next
[10:26:01.984]                             invokeRestart(restart)
[10:26:01.984]                             muffled <- TRUE
[10:26:01.984]                             break
[10:26:01.984]                           }
[10:26:01.984]                         }
[10:26:01.984]                       }
[10:26:01.984]                       invisible(muffled)
[10:26:01.984]                     }
[10:26:01.984]                     muffleCondition(cond, pattern = "^muffle")
[10:26:01.984]                   }
[10:26:01.984]                 }
[10:26:01.984]             }
[10:26:01.984]         }))
[10:26:01.984]     }, error = function(ex) {
[10:26:01.984]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:01.984]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:01.984]                 ...future.rng), started = ...future.startTime, 
[10:26:01.984]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:01.984]             version = "1.8"), class = "FutureResult")
[10:26:01.984]     }, finally = {
[10:26:01.984]         if (!identical(...future.workdir, getwd())) 
[10:26:01.984]             setwd(...future.workdir)
[10:26:01.984]         {
[10:26:01.984]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:01.984]                 ...future.oldOptions$nwarnings <- NULL
[10:26:01.984]             }
[10:26:01.984]             base::options(...future.oldOptions)
[10:26:01.984]             if (.Platform$OS.type == "windows") {
[10:26:01.984]                 old_names <- names(...future.oldEnvVars)
[10:26:01.984]                 envs <- base::Sys.getenv()
[10:26:01.984]                 names <- names(envs)
[10:26:01.984]                 common <- intersect(names, old_names)
[10:26:01.984]                 added <- setdiff(names, old_names)
[10:26:01.984]                 removed <- setdiff(old_names, names)
[10:26:01.984]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:01.984]                   envs[common]]
[10:26:01.984]                 NAMES <- toupper(changed)
[10:26:01.984]                 args <- list()
[10:26:01.984]                 for (kk in seq_along(NAMES)) {
[10:26:01.984]                   name <- changed[[kk]]
[10:26:01.984]                   NAME <- NAMES[[kk]]
[10:26:01.984]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:01.984]                     next
[10:26:01.984]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:01.984]                 }
[10:26:01.984]                 NAMES <- toupper(added)
[10:26:01.984]                 for (kk in seq_along(NAMES)) {
[10:26:01.984]                   name <- added[[kk]]
[10:26:01.984]                   NAME <- NAMES[[kk]]
[10:26:01.984]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:01.984]                     next
[10:26:01.984]                   args[[name]] <- ""
[10:26:01.984]                 }
[10:26:01.984]                 NAMES <- toupper(removed)
[10:26:01.984]                 for (kk in seq_along(NAMES)) {
[10:26:01.984]                   name <- removed[[kk]]
[10:26:01.984]                   NAME <- NAMES[[kk]]
[10:26:01.984]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:01.984]                     next
[10:26:01.984]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:01.984]                 }
[10:26:01.984]                 if (length(args) > 0) 
[10:26:01.984]                   base::do.call(base::Sys.setenv, args = args)
[10:26:01.984]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:01.984]             }
[10:26:01.984]             else {
[10:26:01.984]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:01.984]             }
[10:26:01.984]             {
[10:26:01.984]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:01.984]                   0L) {
[10:26:01.984]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:01.984]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:01.984]                   base::options(opts)
[10:26:01.984]                 }
[10:26:01.984]                 {
[10:26:01.984]                   {
[10:26:01.984]                     NULL
[10:26:01.984]                     RNGkind("Mersenne-Twister")
[10:26:01.984]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:01.984]                       inherits = FALSE)
[10:26:01.984]                   }
[10:26:01.984]                   options(future.plan = NULL)
[10:26:01.984]                   if (is.na(NA_character_)) 
[10:26:01.984]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:01.984]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:01.984]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:01.984]                   {
[10:26:01.984]                     future <- SequentialFuture(..., envir = envir)
[10:26:01.984]                     if (!future$lazy) 
[10:26:01.984]                       future <- run(future)
[10:26:01.984]                     invisible(future)
[10:26:01.984]                   }, function (..., workers = availableCores(constraints = "multicore"), 
[10:26:01.984]                     envir = parent.frame()) 
[10:26:01.984]                   {
[10:26:01.984]                     default_workers <- missing(workers)
[10:26:01.984]                     if (is.function(workers)) 
[10:26:01.984]                       workers <- workers()
[10:26:01.984]                     workers <- structure(as.integer(workers), 
[10:26:01.984]                       class = class(workers))
[10:26:01.984]                     stop_if_not(is.finite(workers), workers >= 
[10:26:01.984]                       1L)
[10:26:01.984]                     if ((workers == 1L && !inherits(workers, 
[10:26:01.984]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:01.984]                       if (default_workers) 
[10:26:01.984]                         supportsMulticore(warn = TRUE)
[10:26:01.984]                       return(sequential(..., envir = envir))
[10:26:01.984]                     }
[10:26:01.984]                     oopts <- options(mc.cores = workers)
[10:26:01.984]                     on.exit(options(oopts))
[10:26:01.984]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:01.984]                       envir = envir)
[10:26:01.984]                     if (!future$lazy) 
[10:26:01.984]                       future <- run(future)
[10:26:01.984]                     invisible(future)
[10:26:01.984]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:01.984]                 }
[10:26:01.984]             }
[10:26:01.984]         }
[10:26:01.984]     })
[10:26:01.984]     if (TRUE) {
[10:26:01.984]         base::sink(type = "output", split = FALSE)
[10:26:01.984]         if (TRUE) {
[10:26:01.984]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:01.984]         }
[10:26:01.984]         else {
[10:26:01.984]             ...future.result["stdout"] <- base::list(NULL)
[10:26:01.984]         }
[10:26:01.984]         base::close(...future.stdout)
[10:26:01.984]         ...future.stdout <- NULL
[10:26:01.984]     }
[10:26:01.984]     ...future.result$conditions <- ...future.conditions
[10:26:01.984]     ...future.result$finished <- base::Sys.time()
[10:26:01.984]     ...future.result
[10:26:01.984] }
[10:26:01.986] assign_globals() ...
[10:26:01.986] List of 1
[10:26:01.986]  $ data:'data.frame':	5 obs. of  2 variables:
[10:26:01.986]   ..$ x: int [1:5] 1 2 3 4 5
[10:26:01.986]   ..$ y: int [1:5] 1 2 3 4 5
[10:26:01.986]  - attr(*, "where")=List of 1
[10:26:01.986]   ..$ data:<environment: R_EmptyEnv> 
[10:26:01.986]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:01.986]  - attr(*, "resolved")= logi FALSE
[10:26:01.986]  - attr(*, "total_size")= num 160
[10:26:01.986]  - attr(*, "already-done")= logi TRUE
[10:26:01.992] - copied ‘data’ to environment
[10:26:01.992] assign_globals() ... done
[10:26:01.993] plan(): Setting new future strategy stack:
[10:26:01.993] List of future strategies:
[10:26:01.993] 1. multicore:
[10:26:01.993]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:01.993]    - tweaked: FALSE
[10:26:01.993]    - call: plan(list(sequential, strategy))
[10:26:01.997] plan(): nbrOfWorkers() = 2
[10:26:02.043] plan(): Setting new future strategy stack:
[10:26:02.043] List of future strategies:
[10:26:02.043] 1. sequential:
[10:26:02.043]    - args: function (..., envir = parent.frame())
[10:26:02.043]    - tweaked: FALSE
[10:26:02.043]    - call: plan(list(sequential, strategy))
[10:26:02.043] 2. multicore:
[10:26:02.043]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:02.043]    - tweaked: FALSE
[10:26:02.043]    - call: plan(list(sequential, strategy))
[10:26:02.044] plan(): nbrOfWorkers() = 1
[10:26:02.044] SequentialFuture started (and completed)
[10:26:02.044] signalConditions() ...
[10:26:02.044]  - include = ‘immediateCondition’
[10:26:02.045]  - exclude = 
[10:26:02.045]  - resignal = FALSE
[10:26:02.045]  - Number of conditions: 56
[10:26:02.045] signalConditions() ... done
[10:26:02.045] - Launch lazy future ... done
[10:26:02.045] run() for ‘SequentialFuture’ ... done
[10:26:02.045] signalConditions() ...
[10:26:02.046]  - include = ‘immediateCondition’
[10:26:02.046]  - exclude = 
[10:26:02.046]  - resignal = FALSE
[10:26:02.046]  - Number of conditions: 56
[10:26:02.046] signalConditions() ... done
[10:26:02.046] Future state: ‘finished’
[10:26:02.046] signalConditions() ...
[10:26:02.046]  - include = ‘condition’
[10:26:02.046]  - exclude = ‘immediateCondition’
[10:26:02.047]  - resignal = TRUE
[10:26:02.047]  - Number of conditions: 56
[10:26:02.047]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:01.997] getGlobalsAndPackages() ...
[10:26:02.047]  - Condition #2: ‘deprecatedWarning’, ‘warning’, ‘condition’
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[10:26:02.047]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.011] Searching for globals...
[10:26:02.047]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.014] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[10:26:02.047]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.014] Searching for globals ... DONE
[10:26:02.048]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.014] Resolving globals: FALSE
[10:26:02.048]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.014] The total size of the 1 globals is 160 bytes (160 bytes)
[10:26:02.048]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.015] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 160 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (160 bytes of class ‘list’)
[10:26:02.048]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.015] - globals: [1] ‘data’
[10:26:02.048]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.015] 
[10:26:02.048]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.015] getGlobalsAndPackages() ... DONE
[10:26:02.049]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.015] run() for ‘Future’ ...
[10:26:02.049]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.015] - state: ‘created’
[10:26:02.049]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.016] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:02.049]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.019] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:02.049]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.019] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:02.049]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.019]   - Field: ‘label’
[10:26:02.050]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.020]   - Field: ‘local’
[10:26:02.050]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.020]   - Field: ‘owner’
[10:26:02.050]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.020]   - Field: ‘envir’
[10:26:02.050]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.020]   - Field: ‘workers’
[10:26:02.050]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.020]   - Field: ‘packages’
[10:26:02.050]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.020]   - Field: ‘gc’
[10:26:02.051]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.020]   - Field: ‘job’
[10:26:02.051]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.020]   - Field: ‘conditions’
[10:26:02.051]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.020]   - Field: ‘expr’
[10:26:02.051]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.020]   - Field: ‘uuid’
[10:26:02.051]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.021]   - Field: ‘seed’
[10:26:02.051]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.021]   - Field: ‘version’
[10:26:02.051]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.021]   - Field: ‘result’
[10:26:02.052]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.021]   - Field: ‘asynchronous’
[10:26:02.052]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.021]   - Field: ‘calls’
[10:26:02.052]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.021]   - Field: ‘globals’
[10:26:02.052]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.021]   - Field: ‘stdout’
[10:26:02.052]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.021]   - Field: ‘earlySignal’
[10:26:02.052]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.021]   - Field: ‘lazy’
[10:26:02.053]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.022]   - Field: ‘state’
[10:26:02.053]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.022] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:02.053]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.022] - Launch lazy future ...
[10:26:02.053]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.022] Packages needed by the future expression (n = 0): <none>
[10:26:02.053]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.022] Packages needed by future strategies (n = 0): <none>
[10:26:02.053]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.023] {
[10:26:02.023]     {
[10:26:02.023]         {
[10:26:02.023]             ...future.startTime <- base::Sys.time()
[10:26:02.023]             {
[10:26:02.023]                 {
[10:26:02.023]                   {
[10:26:02.023]                     {
[10:26:02.023]                       base::local({
[10:26:02.023]                         has_future <- base::requireNamespace("future", 
[10:26:02.023]                           quietly = TRUE)
[10:26:02.023]                         if (has_future) {
[10:26:02.023]                           ns <- base::getNamespace("future")
[10:26:02.023]                           version <- ns[[".package"]][["version"]]
[10:26:02.023]                           if (is.null(version)) 
[10:26:02.023]                             version <- utils::packageVersion("future")
[10:26:02.023]                         }
[10:26:02.023]                         else {
[10:26:02.023]                           version <- NULL
[10:26:02.023]                         }
[10:26:02.023]                         if (!has_future || version < "1.8.0") {
[10:26:02.023]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:02.023]                             "", base::R.version$version.string), 
[10:26:02.023]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:02.023]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:02.023]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:02.023]                               "release", "version")], collapse = " "), 
[10:26:02.023]                             hostname = base::Sys.info()[["nodename"]])
[10:26:02.023]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:02.023]                             info)
[10:26:02.023]                           info <- base::paste(info, collapse = "; ")
[10:26:02.023]                           if (!has_future) {
[10:26:02.023]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:02.023]                               info)
[10:26:02.023]                           }
[10:26:02.023]                           else {
[10:26:02.023]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:02.023]                               info, version)
[10:26:02.023]                           }
[10:26:02.023]                           base::stop(msg)
[10:26:02.023]                         }
[10:26:02.023]                       })
[10:26:02.023]                     }
[10:26:02.023]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:02.023]                     base::options(mc.cores = 1L)
[10:26:02.023]                   }
[10:26:02.023]                   options(future.plan = NULL)
[10:26:02.023]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:02.023]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:02.023]                 }
[10:26:02.023]                 ...future.workdir <- getwd()
[10:26:02.023]             }
[10:26:02.023]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:02.023]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:02.023]         }
[10:26:02.023]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[10:26:02.023]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:02.023]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[10:26:02.023]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:02.023]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:02.023]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:02.023]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:02.023]             base::names(...future.oldOptions))
[10:26:02.023]     }
[10:26:02.023]     if (FALSE) {
[10:26:02.023]     }
[10:26:02.023]     else {
[10:26:02.023]         if (TRUE) {
[10:26:02.023]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:02.023]                 open = "w")
[10:26:02.023]         }
[10:26:02.023]         else {
[10:26:02.023]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:02.023]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:02.023]         }
[10:26:02.023]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:02.023]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:02.023]             base::sink(type = "output", split = FALSE)
[10:26:02.023]             base::close(...future.stdout)
[10:26:02.023]         }, add = TRUE)
[10:26:02.023]     }
[10:26:02.023]     ...future.frame <- base::sys.nframe()
[10:26:02.023]     ...future.conditions <- base::list()
[10:26:02.023]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:02.023]     if (FALSE) {
[10:26:02.023]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:02.023]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:02.023]     }
[10:26:02.023]     ...future.result <- base::tryCatch({
[10:26:02.023]         base::withCallingHandlers({
[10:26:02.023]             ...future.value <- base::withVisible(base::local({
[10:26:02.023]                 withCallingHandlers({
[10:26:02.023]                   subset(data, x < 3)$y
[10:26:02.023]                 }, immediateCondition = function(cond) {
[10:26:02.023]                   save_rds <- function (object, pathname, ...) 
[10:26:02.023]                   {
[10:26:02.023]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:02.023]                     if (file_test("-f", pathname_tmp)) {
[10:26:02.023]                       fi_tmp <- file.info(pathname_tmp)
[10:26:02.023]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:02.023]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:02.023]                         fi_tmp[["mtime"]])
[10:26:02.023]                     }
[10:26:02.023]                     tryCatch({
[10:26:02.023]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:02.023]                     }, error = function(ex) {
[10:26:02.023]                       msg <- conditionMessage(ex)
[10:26:02.023]                       fi_tmp <- file.info(pathname_tmp)
[10:26:02.023]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:02.023]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:02.023]                         fi_tmp[["mtime"]], msg)
[10:26:02.023]                       ex$message <- msg
[10:26:02.023]                       stop(ex)
[10:26:02.023]                     })
[10:26:02.023]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:02.023]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:02.023]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:02.023]                       fi_tmp <- file.info(pathname_tmp)
[10:26:02.023]                       fi <- file.info(pathname)
[10:26:02.023]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:02.023]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:02.023]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:02.023]                         fi[["size"]], fi[["mtime"]])
[10:26:02.023]                       stop(msg)
[10:26:02.023]                     }
[10:26:02.023]                     invisible(pathname)
[10:26:02.023]                   }
[10:26:02.023]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:02.023]                     rootPath = tempdir()) 
[10:26:02.023]                   {
[10:26:02.023]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:02.023]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:02.023]                       tmpdir = path, fileext = ".rds")
[10:26:02.023]                     save_rds(obj, file)
[10:26:02.023]                   }
[10:26:02.023]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4gE0AX/.future/immediateConditions")
[10:26:02.023]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:02.023]                   {
[10:26:02.023]                     inherits <- base::inherits
[10:26:02.023]                     invokeRestart <- base::invokeRestart
[10:26:02.023]                     is.null <- base::is.null
[10:26:02.023]                     muffled <- FALSE
[10:26:02.023]                     if (inherits(cond, "message")) {
[10:26:02.023]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:02.023]                       if (muffled) 
[10:26:02.023]                         invokeRestart("muffleMessage")
[10:26:02.023]                     }
[10:26:02.023]                     else if (inherits(cond, "warning")) {
[10:26:02.023]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:02.023]                       if (muffled) 
[10:26:02.023]                         invokeRestart("muffleWarning")
[10:26:02.023]                     }
[10:26:02.023]                     else if (inherits(cond, "condition")) {
[10:26:02.023]                       if (!is.null(pattern)) {
[10:26:02.023]                         computeRestarts <- base::computeRestarts
[10:26:02.023]                         grepl <- base::grepl
[10:26:02.023]                         restarts <- computeRestarts(cond)
[10:26:02.023]                         for (restart in restarts) {
[10:26:02.023]                           name <- restart$name
[10:26:02.023]                           if (is.null(name)) 
[10:26:02.023]                             next
[10:26:02.023]                           if (!grepl(pattern, name)) 
[10:26:02.023]                             next
[10:26:02.023]                           invokeRestart(restart)
[10:26:02.023]                           muffled <- TRUE
[10:26:02.023]                           break
[10:26:02.023]                         }
[10:26:02.023]                       }
[10:26:02.023]                     }
[10:26:02.023]                     invisible(muffled)
[10:26:02.023]                   }
[10:26:02.023]                   muffleCondition(cond)
[10:26:02.023]                 })
[10:26:02.023]             }))
[10:26:02.023]             future::FutureResult(value = ...future.value$value, 
[10:26:02.023]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:02.023]                   ...future.rng), globalenv = if (FALSE) 
[10:26:02.023]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:02.023]                     ...future.globalenv.names))
[10:26:02.023]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:02.023]         }, condition = base::local({
[10:26:02.023]             c <- base::c
[10:26:02.023]             inherits <- base::inherits
[10:26:02.023]             invokeRestart <- base::invokeRestart
[10:26:02.023]             length <- base::length
[10:26:02.023]             list <- base::list
[10:26:02.023]             seq.int <- base::seq.int
[10:26:02.023]             signalCondition <- base::signalCondition
[10:26:02.023]             sys.calls <- base::sys.calls
[10:26:02.023]             `[[` <- base::`[[`
[10:26:02.023]             `+` <- base::`+`
[10:26:02.023]             `<<-` <- base::`<<-`
[10:26:02.023]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:02.023]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:02.023]                   3L)]
[10:26:02.023]             }
[10:26:02.023]             function(cond) {
[10:26:02.023]                 is_error <- inherits(cond, "error")
[10:26:02.023]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:02.023]                   NULL)
[10:26:02.023]                 if (is_error) {
[10:26:02.023]                   sessionInformation <- function() {
[10:26:02.023]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:02.023]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:02.023]                       search = base::search(), system = base::Sys.info())
[10:26:02.023]                   }
[10:26:02.023]                   ...future.conditions[[length(...future.conditions) + 
[10:26:02.023]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:02.023]                     cond$call), session = sessionInformation(), 
[10:26:02.023]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:02.023]                   signalCondition(cond)
[10:26:02.023]                 }
[10:26:02.023]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:02.023]                 "immediateCondition"))) {
[10:26:02.023]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:02.023]                   ...future.conditions[[length(...future.conditions) + 
[10:26:02.023]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:02.023]                   if (TRUE && !signal) {
[10:26:02.023]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:02.023]                     {
[10:26:02.023]                       inherits <- base::inherits
[10:26:02.023]                       invokeRestart <- base::invokeRestart
[10:26:02.023]                       is.null <- base::is.null
[10:26:02.023]                       muffled <- FALSE
[10:26:02.023]                       if (inherits(cond, "message")) {
[10:26:02.023]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:02.023]                         if (muffled) 
[10:26:02.023]                           invokeRestart("muffleMessage")
[10:26:02.023]                       }
[10:26:02.023]                       else if (inherits(cond, "warning")) {
[10:26:02.023]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:02.023]                         if (muffled) 
[10:26:02.023]                           invokeRestart("muffleWarning")
[10:26:02.023]                       }
[10:26:02.023]                       else if (inherits(cond, "condition")) {
[10:26:02.023]                         if (!is.null(pattern)) {
[10:26:02.023]                           computeRestarts <- base::computeRestarts
[10:26:02.023]                           grepl <- base::grepl
[10:26:02.023]                           restarts <- computeRestarts(cond)
[10:26:02.023]                           for (restart in restarts) {
[10:26:02.023]                             name <- restart$name
[10:26:02.023]                             if (is.null(name)) 
[10:26:02.023]                               next
[10:26:02.023]                             if (!grepl(pattern, name)) 
[10:26:02.023]                               next
[10:26:02.023]                             invokeRestart(restart)
[10:26:02.023]                             muffled <- TRUE
[10:26:02.023]                             break
[10:26:02.023]                           }
[10:26:02.023]                         }
[10:26:02.023]                       }
[10:26:02.023]                       invisible(muffled)
[10:26:02.023]                     }
[10:26:02.023]                     muffleCondition(cond, pattern = "^muffle")
[10:26:02.023]                   }
[10:26:02.023]                 }
[10:26:02.023]                 else {
[10:26:02.023]                   if (TRUE) {
[10:26:02.023]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:02.023]                     {
[10:26:02.023]                       inherits <- base::inherits
[10:26:02.023]                       invokeRestart <- base::invokeRestart
[10:26:02.023]                       is.null <- base::is.null
[10:26:02.023]                       muffled <- FALSE
[10:26:02.023]                       if (inherits(cond, "message")) {
[10:26:02.023]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:02.023]                         if (muffled) 
[10:26:02.023]                           invokeRestart("muffleMessage")
[10:26:02.023]                       }
[10:26:02.023]                       else if (inherits(cond, "warning")) {
[10:26:02.023]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:02.023]                         if (muffled) 
[10:26:02.023]                           invokeRestart("muffleWarning")
[10:26:02.023]                       }
[10:26:02.023]                       else if (inherits(cond, "condition")) {
[10:26:02.023]                         if (!is.null(pattern)) {
[10:26:02.023]                           computeRestarts <- base::computeRestarts
[10:26:02.023]                           grepl <- base::grepl
[10:26:02.023]                           restarts <- computeRestarts(cond)
[10:26:02.023]                           for (restart in restarts) {
[10:26:02.023]                             name <- restart$name
[10:26:02.023]                             if (is.null(name)) 
[10:26:02.023]                               next
[10:26:02.023]                             if (!grepl(pattern, name)) 
[10:26:02.023]                               next
[10:26:02.023]                             invokeRestart(restart)
[10:26:02.023]                             muffled <- TRUE
[10:26:02.023]                             break
[10:26:02.023]                           }
[10:26:02.023]                         }
[10:26:02.023]                       }
[10:26:02.023]                       invisible(muffled)
[10:26:02.023]                     }
[10:26:02.023]                     muffleCondition(cond, pattern = "^muffle")
[10:26:02.023]                   }
[10:26:02.023]                 }
[10:26:02.023]             }
[10:26:02.023]         }))
[10:26:02.023]     }, error = function(ex) {
[10:26:02.023]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:02.023]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:02.023]                 ...future.rng), started = ...future.startTime, 
[10:26:02.023]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:02.023]             version = "1.8"), class = "FutureResult")
[10:26:02.023]     }, finally = {
[10:26:02.023]         if (!identical(...future.workdir, getwd())) 
[10:26:02.023]             setwd(...future.workdir)
[10:26:02.023]         {
[10:26:02.023]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:02.023]                 ...future.oldOptions$nwarnings <- NULL
[10:26:02.023]             }
[10:26:02.023]             base::options(...future.oldOptions)
[10:26:02.023]             if (.Platform$OS.type == "windows") {
[10:26:02.023]                 old_names <- names(...future.oldEnvVars)
[10:26:02.023]                 envs <- base::Sys.getenv()
[10:26:02.023]                 names <- names(envs)
[10:26:02.023]                 common <- intersect(names, old_names)
[10:26:02.023]                 added <- setdiff(names, old_names)
[10:26:02.023]                 removed <- setdiff(old_names, names)
[10:26:02.023]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:02.023]                   envs[common]]
[10:26:02.023]                 NAMES <- toupper(changed)
[10:26:02.023]                 args <- list()
[10:26:02.023]                 for (kk in seq_along(NAMES)) {
[10:26:02.023]                   name <- changed[[kk]]
[10:26:02.023]                   NAME <- NAMES[[kk]]
[10:26:02.023]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:02.023]                     next
[10:26:02.023]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:02.023]                 }
[10:26:02.023]                 NAMES <- toupper(added)
[10:26:02.023]                 for (kk in seq_along(NAMES)) {
[10:26:02.023]                   name <- added[[kk]]
[10:26:02.023]                   NAME <- NAMES[[kk]]
[10:26:02.023]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:02.023]                     next
[10:26:02.023]                   args[[name]] <- ""
[10:26:02.023]                 }
[10:26:02.023]                 NAMES <- toupper(removed)
[10:26:02.023]                 for (kk in seq_along(NAMES)) {
[10:26:02.023]                   name <- removed[[kk]]
[10:26:02.023]                   NAME <- NAMES[[kk]]
[10:26:02.023]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:02.023]                     next
[10:26:02.023]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:02.023]                 }
[10:26:02.023]                 if (length(args) > 0) 
[10:26:02.023]                   base::do.call(base::Sys.setenv, args = args)
[10:26:02.023]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:02.023]             }
[10:26:02.023]             else {
[10:26:02.023]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:02.023]             }
[10:26:02.023]             {
[10:26:02.023]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:02.023]                   0L) {
[10:26:02.023]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:02.023]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:02.023]                   base::options(opts)
[10:26:02.023]                 }
[10:26:02.023]                 {
[10:26:02.023]                   {
[10:26:02.023]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:02.023]                     NULL
[10:26:02.023]                   }
[10:26:02.023]                   options(future.plan = NULL)
[10:26:02.023]                   if (is.na(NA_character_)) 
[10:26:02.023]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:02.023]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:02.023]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:02.023]                     envir = parent.frame()) 
[10:26:02.023]                   {
[10:26:02.023]                     default_workers <- missing(workers)
[10:26:02.023]                     if (is.function(workers)) 
[10:26:02.023]                       workers <- workers()
[10:26:02.023]                     workers <- structure(as.integer(workers), 
[10:26:02.023]                       class = class(workers))
[10:26:02.023]                     stop_if_not(is.finite(workers), workers >= 
[10:26:02.023]                       1L)
[10:26:02.023]                     if ((workers == 1L && !inherits(workers, 
[10:26:02.023]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:02.023]                       if (default_workers) 
[10:26:02.023]                         supportsMulticore(warn = TRUE)
[10:26:02.023]                       return(sequential(..., envir = envir))
[10:26:02.023]                     }
[10:26:02.023]                     oopts <- options(mc.cores = workers)
[10:26:02.023]                     on.exit(options(oopts))
[10:26:02.023]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:02.023]                       envir = envir)
[10:26:02.023]                     if (!future$lazy) 
[10:26:02.023]                       future <- run(future)
[10:26:02.023]                     invisible(future)
[10:26:02.023]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:02.023]                 }
[10:26:02.023]             }
[10:26:02.023]         }
[10:26:02.023]     })
[10:26:02.023]     if (TRUE) {
[10:26:02.023]         base::sink(type = "output", split = FALSE)
[10:26:02.023]         if (TRUE) {
[10:26:02.023]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:02.023]         }
[10:26:02.023]         else {
[10:26:02.023]             ...future.result["stdout"] <- base::list(NULL)
[10:26:02.023]         }
[10:26:02.023]         base::close(...future.stdout)
[10:26:02.023]         ...future.stdout <- NULL
[10:26:02.023]     }
[10:26:02.023]     ...future.result$conditions <- ...future.conditions
[10:26:02.023]     ...future.result$finished <- base::Sys.time()
[10:26:02.023]     ...future.result
[10:26:02.023] }
[10:26:02.054]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.026] assign_globals() ...
[10:26:02.054]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.026] List of 1
[10:26:02.026]  $ data:'data.frame':	5 obs. of  2 variables:
[10:26:02.026]   ..$ x: int [1:5] 1 2 3 4 5
[10:26:02.026]   ..$ y: int [1:5] 1 2 3 4 5
[10:26:02.026]  - attr(*, "where")=List of 1
[10:26:02.026]   ..$ data:<environment: R_EmptyEnv> 
[10:26:02.026]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:02.026]  - attr(*, "resolved")= logi FALSE
[10:26:02.026]  - attr(*, "total_size")= num 160
[10:26:02.026]  - attr(*, "already-done")= logi TRUE
[10:26:02.054]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.029] - copied ‘data’ to environment
[10:26:02.054]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.029] assign_globals() ... done
[10:26:02.056]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.029] requestCore(): workers = 2
[10:26:02.056]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.031] MulticoreFuture started
[10:26:02.057]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.031] - Launch lazy future ... done
[10:26:02.057]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.032] run() for ‘MulticoreFuture’ ... done
[10:26:02.057]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.032] result() for MulticoreFuture ...
[10:26:02.057]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.041] result() for MulticoreFuture ...
[10:26:02.058]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.041] result() for MulticoreFuture ... done
[10:26:02.058]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.042] result() for MulticoreFuture ... done
[10:26:02.058]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.042] result() for MulticoreFuture ...
[10:26:02.058]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.042] result() for MulticoreFuture ... done
[10:26:02.058] signalConditions() ... done
- Strategy: multicore ... DONE
- Strategy: multisession ...
[10:26:02.059] plan(): Setting new future strategy stack:
[10:26:02.059] List of future strategies:
[10:26:02.059] 1. multisession:
[10:26:02.059]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:26:02.059]    - tweaked: FALSE
[10:26:02.059]    - call: plan(strategy)
[10:26:02.059] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:26:02.060] multisession:
[10:26:02.060] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:26:02.060] - tweaked: FALSE
[10:26:02.060] - call: plan(strategy)
[10:26:02.066] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[10:26:02.066] Not searching for globals
[10:26:02.067] - globals: [0] <none>
[10:26:02.067] getGlobalsAndPackages() ... DONE
[10:26:02.067] [local output] makeClusterPSOCK() ...
[10:26:02.106] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:26:02.108] [local output] Base port: 11989
[10:26:02.108] [local output] Getting setup options for 2 cluster nodes ...
[10:26:02.108] [local output]  - Node 1 of 2 ...
[10:26:02.108] [local output] localMachine=TRUE => revtunnel=FALSE

[10:26:02.109] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp4gE0AX/worker.rank=1.parallelly.parent=85238.14cf646ffb079.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmp4gE0AX/worker.rank=1.parallelly.parent=85238.14cf646ffb079.pid")'’
[10:26:02.297] - Possible to infer worker's PID: TRUE
[10:26:02.297] [local output] Rscript port: 11989

[10:26:02.298] [local output]  - Node 2 of 2 ...
[10:26:02.298] [local output] localMachine=TRUE => revtunnel=FALSE

[10:26:02.299] [local output] Rscript port: 11989

[10:26:02.299] [local output] Getting setup options for 2 cluster nodes ... done
[10:26:02.299] [local output]  - Parallel setup requested for some PSOCK nodes
[10:26:02.300] [local output] Setting up PSOCK nodes in parallel
[10:26:02.300] List of 36
[10:26:02.300]  $ worker          : chr "localhost"
[10:26:02.300]   ..- attr(*, "localhost")= logi TRUE
[10:26:02.300]  $ master          : chr "localhost"
[10:26:02.300]  $ port            : int 11989
[10:26:02.300]  $ connectTimeout  : num 120
[10:26:02.300]  $ timeout         : num 2592000
[10:26:02.300]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:26:02.300]  $ homogeneous     : logi TRUE
[10:26:02.300]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:26:02.300]  $ rscript_envs    : NULL
[10:26:02.300]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:26:02.300]  $ rscript_startup : NULL
[10:26:02.300]  $ rscript_sh      : chr "sh"
[10:26:02.300]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:26:02.300]  $ methods         : logi TRUE
[10:26:02.300]  $ socketOptions   : chr "no-delay"
[10:26:02.300]  $ useXDR          : logi FALSE
[10:26:02.300]  $ outfile         : chr "/dev/null"
[10:26:02.300]  $ renice          : int NA
[10:26:02.300]  $ rshcmd          : NULL
[10:26:02.300]  $ user            : chr(0) 
[10:26:02.300]  $ revtunnel       : logi FALSE
[10:26:02.300]  $ rshlogfile      : NULL
[10:26:02.300]  $ rshopts         : chr(0) 
[10:26:02.300]  $ rank            : int 1
[10:26:02.300]  $ manual          : logi FALSE
[10:26:02.300]  $ dryrun          : logi FALSE
[10:26:02.300]  $ quiet           : logi FALSE
[10:26:02.300]  $ setup_strategy  : chr "parallel"
[10:26:02.300]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:26:02.300]  $ pidfile         : chr "/tmp/Rtmp4gE0AX/worker.rank=1.parallelly.parent=85238.14cf646ffb079.pid"
[10:26:02.300]  $ rshcmd_label    : NULL
[10:26:02.300]  $ rsh_call        : NULL
[10:26:02.300]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:26:02.300]  $ localMachine    : logi TRUE
[10:26:02.300]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:26:02.300]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:26:02.300]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:26:02.300]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:26:02.300]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:26:02.300]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:26:02.300]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:26:02.300]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:26:02.300]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:26:02.300]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:26:02.300]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:26:02.300]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:26:02.300]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:26:02.300]  $ arguments       :List of 28
[10:26:02.300]   ..$ worker          : chr "localhost"
[10:26:02.300]   ..$ master          : NULL
[10:26:02.300]   ..$ port            : int 11989
[10:26:02.300]   ..$ connectTimeout  : num 120
[10:26:02.300]   ..$ timeout         : num 2592000
[10:26:02.300]   ..$ rscript         : NULL
[10:26:02.300]   ..$ homogeneous     : NULL
[10:26:02.300]   ..$ rscript_args    : NULL
[10:26:02.300]   ..$ rscript_envs    : NULL
[10:26:02.300]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:26:02.300]   ..$ rscript_startup : NULL
[10:26:02.300]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:26:02.300]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:26:02.300]   ..$ methods         : logi TRUE
[10:26:02.300]   ..$ socketOptions   : chr "no-delay"
[10:26:02.300]   ..$ useXDR          : logi FALSE
[10:26:02.300]   ..$ outfile         : chr "/dev/null"
[10:26:02.300]   ..$ renice          : int NA
[10:26:02.300]   ..$ rshcmd          : NULL
[10:26:02.300]   ..$ user            : NULL
[10:26:02.300]   ..$ revtunnel       : logi NA
[10:26:02.300]   ..$ rshlogfile      : NULL
[10:26:02.300]   ..$ rshopts         : NULL
[10:26:02.300]   ..$ rank            : int 1
[10:26:02.300]   ..$ manual          : logi FALSE
[10:26:02.300]   ..$ dryrun          : logi FALSE
[10:26:02.300]   ..$ quiet           : logi FALSE
[10:26:02.300]   ..$ setup_strategy  : chr "parallel"
[10:26:02.300]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:26:02.317] [local output] System call to launch all workers:
[10:26:02.318] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp4gE0AX/worker.rank=1.parallelly.parent=85238.14cf646ffb079.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11989 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:26:02.318] [local output] Starting PSOCK main server
[10:26:02.323] [local output] Workers launched
[10:26:02.323] [local output] Waiting for workers to connect back
[10:26:02.324]  - [local output] 0 workers out of 2 ready
[10:26:02.559]  - [local output] 0 workers out of 2 ready
[10:26:02.560]  - [local output] 1 workers out of 2 ready
[10:26:02.564]  - [local output] 1 workers out of 2 ready
[10:26:02.564]  - [local output] 2 workers out of 2 ready
[10:26:02.564] [local output] Launching of workers completed
[10:26:02.564] [local output] Collecting session information from workers
[10:26:02.565] [local output]  - Worker #1 of 2
[10:26:02.566] [local output]  - Worker #2 of 2
[10:26:02.566] [local output] makeClusterPSOCK() ... done
[10:26:02.577] Packages needed by the future expression (n = 0): <none>
[10:26:02.578] Packages needed by future strategies (n = 0): <none>
[10:26:02.578] {
[10:26:02.578]     {
[10:26:02.578]         {
[10:26:02.578]             ...future.startTime <- base::Sys.time()
[10:26:02.578]             {
[10:26:02.578]                 {
[10:26:02.578]                   {
[10:26:02.578]                     {
[10:26:02.578]                       base::local({
[10:26:02.578]                         has_future <- base::requireNamespace("future", 
[10:26:02.578]                           quietly = TRUE)
[10:26:02.578]                         if (has_future) {
[10:26:02.578]                           ns <- base::getNamespace("future")
[10:26:02.578]                           version <- ns[[".package"]][["version"]]
[10:26:02.578]                           if (is.null(version)) 
[10:26:02.578]                             version <- utils::packageVersion("future")
[10:26:02.578]                         }
[10:26:02.578]                         else {
[10:26:02.578]                           version <- NULL
[10:26:02.578]                         }
[10:26:02.578]                         if (!has_future || version < "1.8.0") {
[10:26:02.578]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:02.578]                             "", base::R.version$version.string), 
[10:26:02.578]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:02.578]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:02.578]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:02.578]                               "release", "version")], collapse = " "), 
[10:26:02.578]                             hostname = base::Sys.info()[["nodename"]])
[10:26:02.578]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:02.578]                             info)
[10:26:02.578]                           info <- base::paste(info, collapse = "; ")
[10:26:02.578]                           if (!has_future) {
[10:26:02.578]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:02.578]                               info)
[10:26:02.578]                           }
[10:26:02.578]                           else {
[10:26:02.578]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:02.578]                               info, version)
[10:26:02.578]                           }
[10:26:02.578]                           base::stop(msg)
[10:26:02.578]                         }
[10:26:02.578]                       })
[10:26:02.578]                     }
[10:26:02.578]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:02.578]                     base::options(mc.cores = 1L)
[10:26:02.578]                   }
[10:26:02.578]                   options(future.plan = NULL)
[10:26:02.578]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:02.578]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:02.578]                 }
[10:26:02.578]                 ...future.workdir <- getwd()
[10:26:02.578]             }
[10:26:02.578]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:02.578]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:02.578]         }
[10:26:02.578]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[10:26:02.578]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:02.578]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[10:26:02.578]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:02.578]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:02.578]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:02.578]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:02.578]             base::names(...future.oldOptions))
[10:26:02.578]     }
[10:26:02.578]     if (FALSE) {
[10:26:02.578]     }
[10:26:02.578]     else {
[10:26:02.578]         if (TRUE) {
[10:26:02.578]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:02.578]                 open = "w")
[10:26:02.578]         }
[10:26:02.578]         else {
[10:26:02.578]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:02.578]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:02.578]         }
[10:26:02.578]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:02.578]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:02.578]             base::sink(type = "output", split = FALSE)
[10:26:02.578]             base::close(...future.stdout)
[10:26:02.578]         }, add = TRUE)
[10:26:02.578]     }
[10:26:02.578]     ...future.frame <- base::sys.nframe()
[10:26:02.578]     ...future.conditions <- base::list()
[10:26:02.578]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:02.578]     if (FALSE) {
[10:26:02.578]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:02.578]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:02.578]     }
[10:26:02.578]     ...future.result <- base::tryCatch({
[10:26:02.578]         base::withCallingHandlers({
[10:26:02.578]             ...future.value <- base::withVisible(base::local({
[10:26:02.578]                 ...future.makeSendCondition <- base::local({
[10:26:02.578]                   sendCondition <- NULL
[10:26:02.578]                   function(frame = 1L) {
[10:26:02.578]                     if (is.function(sendCondition)) 
[10:26:02.578]                       return(sendCondition)
[10:26:02.578]                     ns <- getNamespace("parallel")
[10:26:02.578]                     if (exists("sendData", mode = "function", 
[10:26:02.578]                       envir = ns)) {
[10:26:02.578]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:02.578]                         envir = ns)
[10:26:02.578]                       envir <- sys.frame(frame)
[10:26:02.578]                       master <- NULL
[10:26:02.578]                       while (!identical(envir, .GlobalEnv) && 
[10:26:02.578]                         !identical(envir, emptyenv())) {
[10:26:02.578]                         if (exists("master", mode = "list", envir = envir, 
[10:26:02.578]                           inherits = FALSE)) {
[10:26:02.578]                           master <- get("master", mode = "list", 
[10:26:02.578]                             envir = envir, inherits = FALSE)
[10:26:02.578]                           if (inherits(master, c("SOCKnode", 
[10:26:02.578]                             "SOCK0node"))) {
[10:26:02.578]                             sendCondition <<- function(cond) {
[10:26:02.578]                               data <- list(type = "VALUE", value = cond, 
[10:26:02.578]                                 success = TRUE)
[10:26:02.578]                               parallel_sendData(master, data)
[10:26:02.578]                             }
[10:26:02.578]                             return(sendCondition)
[10:26:02.578]                           }
[10:26:02.578]                         }
[10:26:02.578]                         frame <- frame + 1L
[10:26:02.578]                         envir <- sys.frame(frame)
[10:26:02.578]                       }
[10:26:02.578]                     }
[10:26:02.578]                     sendCondition <<- function(cond) NULL
[10:26:02.578]                   }
[10:26:02.578]                 })
[10:26:02.578]                 withCallingHandlers({
[10:26:02.578]                   NA
[10:26:02.578]                 }, immediateCondition = function(cond) {
[10:26:02.578]                   sendCondition <- ...future.makeSendCondition()
[10:26:02.578]                   sendCondition(cond)
[10:26:02.578]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:02.578]                   {
[10:26:02.578]                     inherits <- base::inherits
[10:26:02.578]                     invokeRestart <- base::invokeRestart
[10:26:02.578]                     is.null <- base::is.null
[10:26:02.578]                     muffled <- FALSE
[10:26:02.578]                     if (inherits(cond, "message")) {
[10:26:02.578]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:02.578]                       if (muffled) 
[10:26:02.578]                         invokeRestart("muffleMessage")
[10:26:02.578]                     }
[10:26:02.578]                     else if (inherits(cond, "warning")) {
[10:26:02.578]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:02.578]                       if (muffled) 
[10:26:02.578]                         invokeRestart("muffleWarning")
[10:26:02.578]                     }
[10:26:02.578]                     else if (inherits(cond, "condition")) {
[10:26:02.578]                       if (!is.null(pattern)) {
[10:26:02.578]                         computeRestarts <- base::computeRestarts
[10:26:02.578]                         grepl <- base::grepl
[10:26:02.578]                         restarts <- computeRestarts(cond)
[10:26:02.578]                         for (restart in restarts) {
[10:26:02.578]                           name <- restart$name
[10:26:02.578]                           if (is.null(name)) 
[10:26:02.578]                             next
[10:26:02.578]                           if (!grepl(pattern, name)) 
[10:26:02.578]                             next
[10:26:02.578]                           invokeRestart(restart)
[10:26:02.578]                           muffled <- TRUE
[10:26:02.578]                           break
[10:26:02.578]                         }
[10:26:02.578]                       }
[10:26:02.578]                     }
[10:26:02.578]                     invisible(muffled)
[10:26:02.578]                   }
[10:26:02.578]                   muffleCondition(cond)
[10:26:02.578]                 })
[10:26:02.578]             }))
[10:26:02.578]             future::FutureResult(value = ...future.value$value, 
[10:26:02.578]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:02.578]                   ...future.rng), globalenv = if (FALSE) 
[10:26:02.578]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:02.578]                     ...future.globalenv.names))
[10:26:02.578]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:02.578]         }, condition = base::local({
[10:26:02.578]             c <- base::c
[10:26:02.578]             inherits <- base::inherits
[10:26:02.578]             invokeRestart <- base::invokeRestart
[10:26:02.578]             length <- base::length
[10:26:02.578]             list <- base::list
[10:26:02.578]             seq.int <- base::seq.int
[10:26:02.578]             signalCondition <- base::signalCondition
[10:26:02.578]             sys.calls <- base::sys.calls
[10:26:02.578]             `[[` <- base::`[[`
[10:26:02.578]             `+` <- base::`+`
[10:26:02.578]             `<<-` <- base::`<<-`
[10:26:02.578]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:02.578]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:02.578]                   3L)]
[10:26:02.578]             }
[10:26:02.578]             function(cond) {
[10:26:02.578]                 is_error <- inherits(cond, "error")
[10:26:02.578]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:02.578]                   NULL)
[10:26:02.578]                 if (is_error) {
[10:26:02.578]                   sessionInformation <- function() {
[10:26:02.578]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:02.578]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:02.578]                       search = base::search(), system = base::Sys.info())
[10:26:02.578]                   }
[10:26:02.578]                   ...future.conditions[[length(...future.conditions) + 
[10:26:02.578]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:02.578]                     cond$call), session = sessionInformation(), 
[10:26:02.578]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:02.578]                   signalCondition(cond)
[10:26:02.578]                 }
[10:26:02.578]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:02.578]                 "immediateCondition"))) {
[10:26:02.578]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:02.578]                   ...future.conditions[[length(...future.conditions) + 
[10:26:02.578]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:02.578]                   if (TRUE && !signal) {
[10:26:02.578]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:02.578]                     {
[10:26:02.578]                       inherits <- base::inherits
[10:26:02.578]                       invokeRestart <- base::invokeRestart
[10:26:02.578]                       is.null <- base::is.null
[10:26:02.578]                       muffled <- FALSE
[10:26:02.578]                       if (inherits(cond, "message")) {
[10:26:02.578]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:02.578]                         if (muffled) 
[10:26:02.578]                           invokeRestart("muffleMessage")
[10:26:02.578]                       }
[10:26:02.578]                       else if (inherits(cond, "warning")) {
[10:26:02.578]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:02.578]                         if (muffled) 
[10:26:02.578]                           invokeRestart("muffleWarning")
[10:26:02.578]                       }
[10:26:02.578]                       else if (inherits(cond, "condition")) {
[10:26:02.578]                         if (!is.null(pattern)) {
[10:26:02.578]                           computeRestarts <- base::computeRestarts
[10:26:02.578]                           grepl <- base::grepl
[10:26:02.578]                           restarts <- computeRestarts(cond)
[10:26:02.578]                           for (restart in restarts) {
[10:26:02.578]                             name <- restart$name
[10:26:02.578]                             if (is.null(name)) 
[10:26:02.578]                               next
[10:26:02.578]                             if (!grepl(pattern, name)) 
[10:26:02.578]                               next
[10:26:02.578]                             invokeRestart(restart)
[10:26:02.578]                             muffled <- TRUE
[10:26:02.578]                             break
[10:26:02.578]                           }
[10:26:02.578]                         }
[10:26:02.578]                       }
[10:26:02.578]                       invisible(muffled)
[10:26:02.578]                     }
[10:26:02.578]                     muffleCondition(cond, pattern = "^muffle")
[10:26:02.578]                   }
[10:26:02.578]                 }
[10:26:02.578]                 else {
[10:26:02.578]                   if (TRUE) {
[10:26:02.578]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:02.578]                     {
[10:26:02.578]                       inherits <- base::inherits
[10:26:02.578]                       invokeRestart <- base::invokeRestart
[10:26:02.578]                       is.null <- base::is.null
[10:26:02.578]                       muffled <- FALSE
[10:26:02.578]                       if (inherits(cond, "message")) {
[10:26:02.578]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:02.578]                         if (muffled) 
[10:26:02.578]                           invokeRestart("muffleMessage")
[10:26:02.578]                       }
[10:26:02.578]                       else if (inherits(cond, "warning")) {
[10:26:02.578]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:02.578]                         if (muffled) 
[10:26:02.578]                           invokeRestart("muffleWarning")
[10:26:02.578]                       }
[10:26:02.578]                       else if (inherits(cond, "condition")) {
[10:26:02.578]                         if (!is.null(pattern)) {
[10:26:02.578]                           computeRestarts <- base::computeRestarts
[10:26:02.578]                           grepl <- base::grepl
[10:26:02.578]                           restarts <- computeRestarts(cond)
[10:26:02.578]                           for (restart in restarts) {
[10:26:02.578]                             name <- restart$name
[10:26:02.578]                             if (is.null(name)) 
[10:26:02.578]                               next
[10:26:02.578]                             if (!grepl(pattern, name)) 
[10:26:02.578]                               next
[10:26:02.578]                             invokeRestart(restart)
[10:26:02.578]                             muffled <- TRUE
[10:26:02.578]                             break
[10:26:02.578]                           }
[10:26:02.578]                         }
[10:26:02.578]                       }
[10:26:02.578]                       invisible(muffled)
[10:26:02.578]                     }
[10:26:02.578]                     muffleCondition(cond, pattern = "^muffle")
[10:26:02.578]                   }
[10:26:02.578]                 }
[10:26:02.578]             }
[10:26:02.578]         }))
[10:26:02.578]     }, error = function(ex) {
[10:26:02.578]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:02.578]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:02.578]                 ...future.rng), started = ...future.startTime, 
[10:26:02.578]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:02.578]             version = "1.8"), class = "FutureResult")
[10:26:02.578]     }, finally = {
[10:26:02.578]         if (!identical(...future.workdir, getwd())) 
[10:26:02.578]             setwd(...future.workdir)
[10:26:02.578]         {
[10:26:02.578]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:02.578]                 ...future.oldOptions$nwarnings <- NULL
[10:26:02.578]             }
[10:26:02.578]             base::options(...future.oldOptions)
[10:26:02.578]             if (.Platform$OS.type == "windows") {
[10:26:02.578]                 old_names <- names(...future.oldEnvVars)
[10:26:02.578]                 envs <- base::Sys.getenv()
[10:26:02.578]                 names <- names(envs)
[10:26:02.578]                 common <- intersect(names, old_names)
[10:26:02.578]                 added <- setdiff(names, old_names)
[10:26:02.578]                 removed <- setdiff(old_names, names)
[10:26:02.578]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:02.578]                   envs[common]]
[10:26:02.578]                 NAMES <- toupper(changed)
[10:26:02.578]                 args <- list()
[10:26:02.578]                 for (kk in seq_along(NAMES)) {
[10:26:02.578]                   name <- changed[[kk]]
[10:26:02.578]                   NAME <- NAMES[[kk]]
[10:26:02.578]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:02.578]                     next
[10:26:02.578]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:02.578]                 }
[10:26:02.578]                 NAMES <- toupper(added)
[10:26:02.578]                 for (kk in seq_along(NAMES)) {
[10:26:02.578]                   name <- added[[kk]]
[10:26:02.578]                   NAME <- NAMES[[kk]]
[10:26:02.578]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:02.578]                     next
[10:26:02.578]                   args[[name]] <- ""
[10:26:02.578]                 }
[10:26:02.578]                 NAMES <- toupper(removed)
[10:26:02.578]                 for (kk in seq_along(NAMES)) {
[10:26:02.578]                   name <- removed[[kk]]
[10:26:02.578]                   NAME <- NAMES[[kk]]
[10:26:02.578]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:02.578]                     next
[10:26:02.578]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:02.578]                 }
[10:26:02.578]                 if (length(args) > 0) 
[10:26:02.578]                   base::do.call(base::Sys.setenv, args = args)
[10:26:02.578]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:02.578]             }
[10:26:02.578]             else {
[10:26:02.578]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:02.578]             }
[10:26:02.578]             {
[10:26:02.578]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:02.578]                   0L) {
[10:26:02.578]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:02.578]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:02.578]                   base::options(opts)
[10:26:02.578]                 }
[10:26:02.578]                 {
[10:26:02.578]                   {
[10:26:02.578]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:02.578]                     NULL
[10:26:02.578]                   }
[10:26:02.578]                   options(future.plan = NULL)
[10:26:02.578]                   if (is.na(NA_character_)) 
[10:26:02.578]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:02.578]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:02.578]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:02.578]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:02.578]                     envir = parent.frame()) 
[10:26:02.578]                   {
[10:26:02.578]                     if (is.function(workers)) 
[10:26:02.578]                       workers <- workers()
[10:26:02.578]                     workers <- structure(as.integer(workers), 
[10:26:02.578]                       class = class(workers))
[10:26:02.578]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:02.578]                       workers >= 1)
[10:26:02.578]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:02.578]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:02.578]                     }
[10:26:02.578]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:02.578]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:02.578]                       envir = envir)
[10:26:02.578]                     if (!future$lazy) 
[10:26:02.578]                       future <- run(future)
[10:26:02.578]                     invisible(future)
[10:26:02.578]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:02.578]                 }
[10:26:02.578]             }
[10:26:02.578]         }
[10:26:02.578]     })
[10:26:02.578]     if (TRUE) {
[10:26:02.578]         base::sink(type = "output", split = FALSE)
[10:26:02.578]         if (TRUE) {
[10:26:02.578]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:02.578]         }
[10:26:02.578]         else {
[10:26:02.578]             ...future.result["stdout"] <- base::list(NULL)
[10:26:02.578]         }
[10:26:02.578]         base::close(...future.stdout)
[10:26:02.578]         ...future.stdout <- NULL
[10:26:02.578]     }
[10:26:02.578]     ...future.result$conditions <- ...future.conditions
[10:26:02.578]     ...future.result$finished <- base::Sys.time()
[10:26:02.578]     ...future.result
[10:26:02.578] }
[10:26:02.631] MultisessionFuture started
[10:26:02.632] result() for ClusterFuture ...
[10:26:02.633] receiveMessageFromWorker() for ClusterFuture ...
[10:26:02.633] - Validating connection of MultisessionFuture
[10:26:02.677] - received message: FutureResult
[10:26:02.677] - Received FutureResult
[10:26:02.677] - Erased future from FutureRegistry
[10:26:02.677] result() for ClusterFuture ...
[10:26:02.677] - result already collected: FutureResult
[10:26:02.677] result() for ClusterFuture ... done
[10:26:02.678] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:02.678] result() for ClusterFuture ... done
[10:26:02.678] result() for ClusterFuture ...
[10:26:02.678] - result already collected: FutureResult
[10:26:02.678] result() for ClusterFuture ... done
[10:26:02.678] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:26:02.682] plan(): nbrOfWorkers() = 2
[10:26:02.682] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:02.683] Searching for globals...
[10:26:02.683] - globals found: [1] ‘getOption’
[10:26:02.683] Searching for globals ... DONE
[10:26:02.683] Resolving globals: FALSE
[10:26:02.684] 
[10:26:02.684] 
[10:26:02.684] getGlobalsAndPackages() ... DONE
[10:26:02.684] run() for ‘Future’ ...
[10:26:02.684] - state: ‘created’
[10:26:02.685] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:02.699] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:02.699] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:02.699]   - Field: ‘node’
[10:26:02.699]   - Field: ‘label’
[10:26:02.699]   - Field: ‘local’
[10:26:02.700]   - Field: ‘owner’
[10:26:02.700]   - Field: ‘envir’
[10:26:02.700]   - Field: ‘workers’
[10:26:02.700]   - Field: ‘packages’
[10:26:02.700]   - Field: ‘gc’
[10:26:02.700]   - Field: ‘conditions’
[10:26:02.700]   - Field: ‘persistent’
[10:26:02.700]   - Field: ‘expr’
[10:26:02.700]   - Field: ‘uuid’
[10:26:02.701]   - Field: ‘seed’
[10:26:02.701]   - Field: ‘version’
[10:26:02.701]   - Field: ‘result’
[10:26:02.701]   - Field: ‘asynchronous’
[10:26:02.701]   - Field: ‘calls’
[10:26:02.701]   - Field: ‘globals’
[10:26:02.701]   - Field: ‘stdout’
[10:26:02.701]   - Field: ‘earlySignal’
[10:26:02.701]   - Field: ‘lazy’
[10:26:02.702]   - Field: ‘state’
[10:26:02.702] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:02.702] - Launch lazy future ...
[10:26:02.702] Packages needed by the future expression (n = 0): <none>
[10:26:02.702] Packages needed by future strategies (n = 0): <none>
[10:26:02.703] {
[10:26:02.703]     {
[10:26:02.703]         {
[10:26:02.703]             ...future.startTime <- base::Sys.time()
[10:26:02.703]             {
[10:26:02.703]                 {
[10:26:02.703]                   {
[10:26:02.703]                     {
[10:26:02.703]                       base::local({
[10:26:02.703]                         has_future <- base::requireNamespace("future", 
[10:26:02.703]                           quietly = TRUE)
[10:26:02.703]                         if (has_future) {
[10:26:02.703]                           ns <- base::getNamespace("future")
[10:26:02.703]                           version <- ns[[".package"]][["version"]]
[10:26:02.703]                           if (is.null(version)) 
[10:26:02.703]                             version <- utils::packageVersion("future")
[10:26:02.703]                         }
[10:26:02.703]                         else {
[10:26:02.703]                           version <- NULL
[10:26:02.703]                         }
[10:26:02.703]                         if (!has_future || version < "1.8.0") {
[10:26:02.703]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:02.703]                             "", base::R.version$version.string), 
[10:26:02.703]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:02.703]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:02.703]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:02.703]                               "release", "version")], collapse = " "), 
[10:26:02.703]                             hostname = base::Sys.info()[["nodename"]])
[10:26:02.703]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:02.703]                             info)
[10:26:02.703]                           info <- base::paste(info, collapse = "; ")
[10:26:02.703]                           if (!has_future) {
[10:26:02.703]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:02.703]                               info)
[10:26:02.703]                           }
[10:26:02.703]                           else {
[10:26:02.703]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:02.703]                               info, version)
[10:26:02.703]                           }
[10:26:02.703]                           base::stop(msg)
[10:26:02.703]                         }
[10:26:02.703]                       })
[10:26:02.703]                     }
[10:26:02.703]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:02.703]                     base::options(mc.cores = 1L)
[10:26:02.703]                   }
[10:26:02.703]                   options(future.plan = NULL)
[10:26:02.703]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:02.703]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:02.703]                 }
[10:26:02.703]                 ...future.workdir <- getwd()
[10:26:02.703]             }
[10:26:02.703]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:02.703]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:02.703]         }
[10:26:02.703]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:26:02.703]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:02.703]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:26:02.703]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:02.703]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:02.703]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:02.703]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:02.703]             base::names(...future.oldOptions))
[10:26:02.703]     }
[10:26:02.703]     if (FALSE) {
[10:26:02.703]     }
[10:26:02.703]     else {
[10:26:02.703]         if (TRUE) {
[10:26:02.703]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:02.703]                 open = "w")
[10:26:02.703]         }
[10:26:02.703]         else {
[10:26:02.703]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:02.703]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:02.703]         }
[10:26:02.703]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:02.703]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:02.703]             base::sink(type = "output", split = FALSE)
[10:26:02.703]             base::close(...future.stdout)
[10:26:02.703]         }, add = TRUE)
[10:26:02.703]     }
[10:26:02.703]     ...future.frame <- base::sys.nframe()
[10:26:02.703]     ...future.conditions <- base::list()
[10:26:02.703]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:02.703]     if (FALSE) {
[10:26:02.703]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:02.703]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:02.703]     }
[10:26:02.703]     ...future.result <- base::tryCatch({
[10:26:02.703]         base::withCallingHandlers({
[10:26:02.703]             ...future.value <- base::withVisible(base::local({
[10:26:02.703]                 ...future.makeSendCondition <- base::local({
[10:26:02.703]                   sendCondition <- NULL
[10:26:02.703]                   function(frame = 1L) {
[10:26:02.703]                     if (is.function(sendCondition)) 
[10:26:02.703]                       return(sendCondition)
[10:26:02.703]                     ns <- getNamespace("parallel")
[10:26:02.703]                     if (exists("sendData", mode = "function", 
[10:26:02.703]                       envir = ns)) {
[10:26:02.703]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:02.703]                         envir = ns)
[10:26:02.703]                       envir <- sys.frame(frame)
[10:26:02.703]                       master <- NULL
[10:26:02.703]                       while (!identical(envir, .GlobalEnv) && 
[10:26:02.703]                         !identical(envir, emptyenv())) {
[10:26:02.703]                         if (exists("master", mode = "list", envir = envir, 
[10:26:02.703]                           inherits = FALSE)) {
[10:26:02.703]                           master <- get("master", mode = "list", 
[10:26:02.703]                             envir = envir, inherits = FALSE)
[10:26:02.703]                           if (inherits(master, c("SOCKnode", 
[10:26:02.703]                             "SOCK0node"))) {
[10:26:02.703]                             sendCondition <<- function(cond) {
[10:26:02.703]                               data <- list(type = "VALUE", value = cond, 
[10:26:02.703]                                 success = TRUE)
[10:26:02.703]                               parallel_sendData(master, data)
[10:26:02.703]                             }
[10:26:02.703]                             return(sendCondition)
[10:26:02.703]                           }
[10:26:02.703]                         }
[10:26:02.703]                         frame <- frame + 1L
[10:26:02.703]                         envir <- sys.frame(frame)
[10:26:02.703]                       }
[10:26:02.703]                     }
[10:26:02.703]                     sendCondition <<- function(cond) NULL
[10:26:02.703]                   }
[10:26:02.703]                 })
[10:26:02.703]                 withCallingHandlers({
[10:26:02.703]                   getOption("future.globals.onMissing")
[10:26:02.703]                 }, immediateCondition = function(cond) {
[10:26:02.703]                   sendCondition <- ...future.makeSendCondition()
[10:26:02.703]                   sendCondition(cond)
[10:26:02.703]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:02.703]                   {
[10:26:02.703]                     inherits <- base::inherits
[10:26:02.703]                     invokeRestart <- base::invokeRestart
[10:26:02.703]                     is.null <- base::is.null
[10:26:02.703]                     muffled <- FALSE
[10:26:02.703]                     if (inherits(cond, "message")) {
[10:26:02.703]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:02.703]                       if (muffled) 
[10:26:02.703]                         invokeRestart("muffleMessage")
[10:26:02.703]                     }
[10:26:02.703]                     else if (inherits(cond, "warning")) {
[10:26:02.703]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:02.703]                       if (muffled) 
[10:26:02.703]                         invokeRestart("muffleWarning")
[10:26:02.703]                     }
[10:26:02.703]                     else if (inherits(cond, "condition")) {
[10:26:02.703]                       if (!is.null(pattern)) {
[10:26:02.703]                         computeRestarts <- base::computeRestarts
[10:26:02.703]                         grepl <- base::grepl
[10:26:02.703]                         restarts <- computeRestarts(cond)
[10:26:02.703]                         for (restart in restarts) {
[10:26:02.703]                           name <- restart$name
[10:26:02.703]                           if (is.null(name)) 
[10:26:02.703]                             next
[10:26:02.703]                           if (!grepl(pattern, name)) 
[10:26:02.703]                             next
[10:26:02.703]                           invokeRestart(restart)
[10:26:02.703]                           muffled <- TRUE
[10:26:02.703]                           break
[10:26:02.703]                         }
[10:26:02.703]                       }
[10:26:02.703]                     }
[10:26:02.703]                     invisible(muffled)
[10:26:02.703]                   }
[10:26:02.703]                   muffleCondition(cond)
[10:26:02.703]                 })
[10:26:02.703]             }))
[10:26:02.703]             future::FutureResult(value = ...future.value$value, 
[10:26:02.703]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:02.703]                   ...future.rng), globalenv = if (FALSE) 
[10:26:02.703]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:02.703]                     ...future.globalenv.names))
[10:26:02.703]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:02.703]         }, condition = base::local({
[10:26:02.703]             c <- base::c
[10:26:02.703]             inherits <- base::inherits
[10:26:02.703]             invokeRestart <- base::invokeRestart
[10:26:02.703]             length <- base::length
[10:26:02.703]             list <- base::list
[10:26:02.703]             seq.int <- base::seq.int
[10:26:02.703]             signalCondition <- base::signalCondition
[10:26:02.703]             sys.calls <- base::sys.calls
[10:26:02.703]             `[[` <- base::`[[`
[10:26:02.703]             `+` <- base::`+`
[10:26:02.703]             `<<-` <- base::`<<-`
[10:26:02.703]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:02.703]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:02.703]                   3L)]
[10:26:02.703]             }
[10:26:02.703]             function(cond) {
[10:26:02.703]                 is_error <- inherits(cond, "error")
[10:26:02.703]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:02.703]                   NULL)
[10:26:02.703]                 if (is_error) {
[10:26:02.703]                   sessionInformation <- function() {
[10:26:02.703]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:02.703]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:02.703]                       search = base::search(), system = base::Sys.info())
[10:26:02.703]                   }
[10:26:02.703]                   ...future.conditions[[length(...future.conditions) + 
[10:26:02.703]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:02.703]                     cond$call), session = sessionInformation(), 
[10:26:02.703]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:02.703]                   signalCondition(cond)
[10:26:02.703]                 }
[10:26:02.703]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:02.703]                 "immediateCondition"))) {
[10:26:02.703]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:02.703]                   ...future.conditions[[length(...future.conditions) + 
[10:26:02.703]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:02.703]                   if (TRUE && !signal) {
[10:26:02.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:02.703]                     {
[10:26:02.703]                       inherits <- base::inherits
[10:26:02.703]                       invokeRestart <- base::invokeRestart
[10:26:02.703]                       is.null <- base::is.null
[10:26:02.703]                       muffled <- FALSE
[10:26:02.703]                       if (inherits(cond, "message")) {
[10:26:02.703]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:02.703]                         if (muffled) 
[10:26:02.703]                           invokeRestart("muffleMessage")
[10:26:02.703]                       }
[10:26:02.703]                       else if (inherits(cond, "warning")) {
[10:26:02.703]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:02.703]                         if (muffled) 
[10:26:02.703]                           invokeRestart("muffleWarning")
[10:26:02.703]                       }
[10:26:02.703]                       else if (inherits(cond, "condition")) {
[10:26:02.703]                         if (!is.null(pattern)) {
[10:26:02.703]                           computeRestarts <- base::computeRestarts
[10:26:02.703]                           grepl <- base::grepl
[10:26:02.703]                           restarts <- computeRestarts(cond)
[10:26:02.703]                           for (restart in restarts) {
[10:26:02.703]                             name <- restart$name
[10:26:02.703]                             if (is.null(name)) 
[10:26:02.703]                               next
[10:26:02.703]                             if (!grepl(pattern, name)) 
[10:26:02.703]                               next
[10:26:02.703]                             invokeRestart(restart)
[10:26:02.703]                             muffled <- TRUE
[10:26:02.703]                             break
[10:26:02.703]                           }
[10:26:02.703]                         }
[10:26:02.703]                       }
[10:26:02.703]                       invisible(muffled)
[10:26:02.703]                     }
[10:26:02.703]                     muffleCondition(cond, pattern = "^muffle")
[10:26:02.703]                   }
[10:26:02.703]                 }
[10:26:02.703]                 else {
[10:26:02.703]                   if (TRUE) {
[10:26:02.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:02.703]                     {
[10:26:02.703]                       inherits <- base::inherits
[10:26:02.703]                       invokeRestart <- base::invokeRestart
[10:26:02.703]                       is.null <- base::is.null
[10:26:02.703]                       muffled <- FALSE
[10:26:02.703]                       if (inherits(cond, "message")) {
[10:26:02.703]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:02.703]                         if (muffled) 
[10:26:02.703]                           invokeRestart("muffleMessage")
[10:26:02.703]                       }
[10:26:02.703]                       else if (inherits(cond, "warning")) {
[10:26:02.703]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:02.703]                         if (muffled) 
[10:26:02.703]                           invokeRestart("muffleWarning")
[10:26:02.703]                       }
[10:26:02.703]                       else if (inherits(cond, "condition")) {
[10:26:02.703]                         if (!is.null(pattern)) {
[10:26:02.703]                           computeRestarts <- base::computeRestarts
[10:26:02.703]                           grepl <- base::grepl
[10:26:02.703]                           restarts <- computeRestarts(cond)
[10:26:02.703]                           for (restart in restarts) {
[10:26:02.703]                             name <- restart$name
[10:26:02.703]                             if (is.null(name)) 
[10:26:02.703]                               next
[10:26:02.703]                             if (!grepl(pattern, name)) 
[10:26:02.703]                               next
[10:26:02.703]                             invokeRestart(restart)
[10:26:02.703]                             muffled <- TRUE
[10:26:02.703]                             break
[10:26:02.703]                           }
[10:26:02.703]                         }
[10:26:02.703]                       }
[10:26:02.703]                       invisible(muffled)
[10:26:02.703]                     }
[10:26:02.703]                     muffleCondition(cond, pattern = "^muffle")
[10:26:02.703]                   }
[10:26:02.703]                 }
[10:26:02.703]             }
[10:26:02.703]         }))
[10:26:02.703]     }, error = function(ex) {
[10:26:02.703]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:02.703]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:02.703]                 ...future.rng), started = ...future.startTime, 
[10:26:02.703]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:02.703]             version = "1.8"), class = "FutureResult")
[10:26:02.703]     }, finally = {
[10:26:02.703]         if (!identical(...future.workdir, getwd())) 
[10:26:02.703]             setwd(...future.workdir)
[10:26:02.703]         {
[10:26:02.703]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:02.703]                 ...future.oldOptions$nwarnings <- NULL
[10:26:02.703]             }
[10:26:02.703]             base::options(...future.oldOptions)
[10:26:02.703]             if (.Platform$OS.type == "windows") {
[10:26:02.703]                 old_names <- names(...future.oldEnvVars)
[10:26:02.703]                 envs <- base::Sys.getenv()
[10:26:02.703]                 names <- names(envs)
[10:26:02.703]                 common <- intersect(names, old_names)
[10:26:02.703]                 added <- setdiff(names, old_names)
[10:26:02.703]                 removed <- setdiff(old_names, names)
[10:26:02.703]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:02.703]                   envs[common]]
[10:26:02.703]                 NAMES <- toupper(changed)
[10:26:02.703]                 args <- list()
[10:26:02.703]                 for (kk in seq_along(NAMES)) {
[10:26:02.703]                   name <- changed[[kk]]
[10:26:02.703]                   NAME <- NAMES[[kk]]
[10:26:02.703]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:02.703]                     next
[10:26:02.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:02.703]                 }
[10:26:02.703]                 NAMES <- toupper(added)
[10:26:02.703]                 for (kk in seq_along(NAMES)) {
[10:26:02.703]                   name <- added[[kk]]
[10:26:02.703]                   NAME <- NAMES[[kk]]
[10:26:02.703]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:02.703]                     next
[10:26:02.703]                   args[[name]] <- ""
[10:26:02.703]                 }
[10:26:02.703]                 NAMES <- toupper(removed)
[10:26:02.703]                 for (kk in seq_along(NAMES)) {
[10:26:02.703]                   name <- removed[[kk]]
[10:26:02.703]                   NAME <- NAMES[[kk]]
[10:26:02.703]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:02.703]                     next
[10:26:02.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:02.703]                 }
[10:26:02.703]                 if (length(args) > 0) 
[10:26:02.703]                   base::do.call(base::Sys.setenv, args = args)
[10:26:02.703]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:02.703]             }
[10:26:02.703]             else {
[10:26:02.703]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:02.703]             }
[10:26:02.703]             {
[10:26:02.703]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:02.703]                   0L) {
[10:26:02.703]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:02.703]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:02.703]                   base::options(opts)
[10:26:02.703]                 }
[10:26:02.703]                 {
[10:26:02.703]                   {
[10:26:02.703]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:02.703]                     NULL
[10:26:02.703]                   }
[10:26:02.703]                   options(future.plan = NULL)
[10:26:02.703]                   if (is.na(NA_character_)) 
[10:26:02.703]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:02.703]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:02.703]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:02.703]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:02.703]                     envir = parent.frame()) 
[10:26:02.703]                   {
[10:26:02.703]                     if (is.function(workers)) 
[10:26:02.703]                       workers <- workers()
[10:26:02.703]                     workers <- structure(as.integer(workers), 
[10:26:02.703]                       class = class(workers))
[10:26:02.703]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:02.703]                       workers >= 1)
[10:26:02.703]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:02.703]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:02.703]                     }
[10:26:02.703]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:02.703]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:02.703]                       envir = envir)
[10:26:02.703]                     if (!future$lazy) 
[10:26:02.703]                       future <- run(future)
[10:26:02.703]                     invisible(future)
[10:26:02.703]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:02.703]                 }
[10:26:02.703]             }
[10:26:02.703]         }
[10:26:02.703]     })
[10:26:02.703]     if (TRUE) {
[10:26:02.703]         base::sink(type = "output", split = FALSE)
[10:26:02.703]         if (TRUE) {
[10:26:02.703]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:02.703]         }
[10:26:02.703]         else {
[10:26:02.703]             ...future.result["stdout"] <- base::list(NULL)
[10:26:02.703]         }
[10:26:02.703]         base::close(...future.stdout)
[10:26:02.703]         ...future.stdout <- NULL
[10:26:02.703]     }
[10:26:02.703]     ...future.result$conditions <- ...future.conditions
[10:26:02.703]     ...future.result$finished <- base::Sys.time()
[10:26:02.703]     ...future.result
[10:26:02.703] }
[10:26:02.706] MultisessionFuture started
[10:26:02.707] - Launch lazy future ... done
[10:26:02.707] run() for ‘MultisessionFuture’ ... done
[10:26:02.707] result() for ClusterFuture ...
[10:26:02.707] receiveMessageFromWorker() for ClusterFuture ...
[10:26:02.707] - Validating connection of MultisessionFuture
[10:26:02.754] - received message: FutureResult
[10:26:02.754] - Received FutureResult
[10:26:02.754] - Erased future from FutureRegistry
[10:26:02.755] result() for ClusterFuture ...
[10:26:02.755] - result already collected: FutureResult
[10:26:02.755] result() for ClusterFuture ... done
[10:26:02.755] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:02.755] result() for ClusterFuture ... done
[10:26:02.755] result() for ClusterFuture ...
[10:26:02.755] - result already collected: FutureResult
[10:26:02.755] result() for ClusterFuture ... done
[10:26:02.756] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[10:26:02.756] Searching for globals...
[10:26:02.757] - globals found: [1] ‘getOption’
[10:26:02.757] Searching for globals ... DONE
[10:26:02.757] Resolving globals: FALSE
[10:26:02.757] 
[10:26:02.757] 
[10:26:02.757] getGlobalsAndPackages() ... DONE
[10:26:02.758] run() for ‘Future’ ...
[10:26:02.758] - state: ‘created’
[10:26:02.758] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:02.772] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:02.772] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:02.773]   - Field: ‘node’
[10:26:02.773]   - Field: ‘label’
[10:26:02.773]   - Field: ‘local’
[10:26:02.773]   - Field: ‘owner’
[10:26:02.773]   - Field: ‘envir’
[10:26:02.773]   - Field: ‘workers’
[10:26:02.773]   - Field: ‘packages’
[10:26:02.773]   - Field: ‘gc’
[10:26:02.773]   - Field: ‘conditions’
[10:26:02.774]   - Field: ‘persistent’
[10:26:02.774]   - Field: ‘expr’
[10:26:02.774]   - Field: ‘uuid’
[10:26:02.774]   - Field: ‘seed’
[10:26:02.774]   - Field: ‘version’
[10:26:02.774]   - Field: ‘result’
[10:26:02.774]   - Field: ‘asynchronous’
[10:26:02.774]   - Field: ‘calls’
[10:26:02.775]   - Field: ‘globals’
[10:26:02.775]   - Field: ‘stdout’
[10:26:02.775]   - Field: ‘earlySignal’
[10:26:02.775]   - Field: ‘lazy’
[10:26:02.775]   - Field: ‘state’
[10:26:02.775] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:02.775] - Launch lazy future ...
[10:26:02.776] Packages needed by the future expression (n = 0): <none>
[10:26:02.776] Packages needed by future strategies (n = 0): <none>
[10:26:02.776] {
[10:26:02.776]     {
[10:26:02.776]         {
[10:26:02.776]             ...future.startTime <- base::Sys.time()
[10:26:02.776]             {
[10:26:02.776]                 {
[10:26:02.776]                   {
[10:26:02.776]                     {
[10:26:02.776]                       base::local({
[10:26:02.776]                         has_future <- base::requireNamespace("future", 
[10:26:02.776]                           quietly = TRUE)
[10:26:02.776]                         if (has_future) {
[10:26:02.776]                           ns <- base::getNamespace("future")
[10:26:02.776]                           version <- ns[[".package"]][["version"]]
[10:26:02.776]                           if (is.null(version)) 
[10:26:02.776]                             version <- utils::packageVersion("future")
[10:26:02.776]                         }
[10:26:02.776]                         else {
[10:26:02.776]                           version <- NULL
[10:26:02.776]                         }
[10:26:02.776]                         if (!has_future || version < "1.8.0") {
[10:26:02.776]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:02.776]                             "", base::R.version$version.string), 
[10:26:02.776]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:02.776]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:02.776]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:02.776]                               "release", "version")], collapse = " "), 
[10:26:02.776]                             hostname = base::Sys.info()[["nodename"]])
[10:26:02.776]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:02.776]                             info)
[10:26:02.776]                           info <- base::paste(info, collapse = "; ")
[10:26:02.776]                           if (!has_future) {
[10:26:02.776]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:02.776]                               info)
[10:26:02.776]                           }
[10:26:02.776]                           else {
[10:26:02.776]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:02.776]                               info, version)
[10:26:02.776]                           }
[10:26:02.776]                           base::stop(msg)
[10:26:02.776]                         }
[10:26:02.776]                       })
[10:26:02.776]                     }
[10:26:02.776]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:02.776]                     base::options(mc.cores = 1L)
[10:26:02.776]                   }
[10:26:02.776]                   options(future.plan = NULL)
[10:26:02.776]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:02.776]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:02.776]                 }
[10:26:02.776]                 ...future.workdir <- getwd()
[10:26:02.776]             }
[10:26:02.776]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:02.776]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:02.776]         }
[10:26:02.776]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[10:26:02.776]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:02.776]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[10:26:02.776]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:02.776]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:02.776]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:02.776]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:02.776]             base::names(...future.oldOptions))
[10:26:02.776]     }
[10:26:02.776]     if (FALSE) {
[10:26:02.776]     }
[10:26:02.776]     else {
[10:26:02.776]         if (TRUE) {
[10:26:02.776]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:02.776]                 open = "w")
[10:26:02.776]         }
[10:26:02.776]         else {
[10:26:02.776]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:02.776]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:02.776]         }
[10:26:02.776]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:02.776]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:02.776]             base::sink(type = "output", split = FALSE)
[10:26:02.776]             base::close(...future.stdout)
[10:26:02.776]         }, add = TRUE)
[10:26:02.776]     }
[10:26:02.776]     ...future.frame <- base::sys.nframe()
[10:26:02.776]     ...future.conditions <- base::list()
[10:26:02.776]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:02.776]     if (FALSE) {
[10:26:02.776]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:02.776]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:02.776]     }
[10:26:02.776]     ...future.result <- base::tryCatch({
[10:26:02.776]         base::withCallingHandlers({
[10:26:02.776]             ...future.value <- base::withVisible(base::local({
[10:26:02.776]                 ...future.makeSendCondition <- base::local({
[10:26:02.776]                   sendCondition <- NULL
[10:26:02.776]                   function(frame = 1L) {
[10:26:02.776]                     if (is.function(sendCondition)) 
[10:26:02.776]                       return(sendCondition)
[10:26:02.776]                     ns <- getNamespace("parallel")
[10:26:02.776]                     if (exists("sendData", mode = "function", 
[10:26:02.776]                       envir = ns)) {
[10:26:02.776]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:02.776]                         envir = ns)
[10:26:02.776]                       envir <- sys.frame(frame)
[10:26:02.776]                       master <- NULL
[10:26:02.776]                       while (!identical(envir, .GlobalEnv) && 
[10:26:02.776]                         !identical(envir, emptyenv())) {
[10:26:02.776]                         if (exists("master", mode = "list", envir = envir, 
[10:26:02.776]                           inherits = FALSE)) {
[10:26:02.776]                           master <- get("master", mode = "list", 
[10:26:02.776]                             envir = envir, inherits = FALSE)
[10:26:02.776]                           if (inherits(master, c("SOCKnode", 
[10:26:02.776]                             "SOCK0node"))) {
[10:26:02.776]                             sendCondition <<- function(cond) {
[10:26:02.776]                               data <- list(type = "VALUE", value = cond, 
[10:26:02.776]                                 success = TRUE)
[10:26:02.776]                               parallel_sendData(master, data)
[10:26:02.776]                             }
[10:26:02.776]                             return(sendCondition)
[10:26:02.776]                           }
[10:26:02.776]                         }
[10:26:02.776]                         frame <- frame + 1L
[10:26:02.776]                         envir <- sys.frame(frame)
[10:26:02.776]                       }
[10:26:02.776]                     }
[10:26:02.776]                     sendCondition <<- function(cond) NULL
[10:26:02.776]                   }
[10:26:02.776]                 })
[10:26:02.776]                 withCallingHandlers({
[10:26:02.776]                   getOption("future.globals.onMissing")
[10:26:02.776]                 }, immediateCondition = function(cond) {
[10:26:02.776]                   sendCondition <- ...future.makeSendCondition()
[10:26:02.776]                   sendCondition(cond)
[10:26:02.776]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:02.776]                   {
[10:26:02.776]                     inherits <- base::inherits
[10:26:02.776]                     invokeRestart <- base::invokeRestart
[10:26:02.776]                     is.null <- base::is.null
[10:26:02.776]                     muffled <- FALSE
[10:26:02.776]                     if (inherits(cond, "message")) {
[10:26:02.776]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:02.776]                       if (muffled) 
[10:26:02.776]                         invokeRestart("muffleMessage")
[10:26:02.776]                     }
[10:26:02.776]                     else if (inherits(cond, "warning")) {
[10:26:02.776]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:02.776]                       if (muffled) 
[10:26:02.776]                         invokeRestart("muffleWarning")
[10:26:02.776]                     }
[10:26:02.776]                     else if (inherits(cond, "condition")) {
[10:26:02.776]                       if (!is.null(pattern)) {
[10:26:02.776]                         computeRestarts <- base::computeRestarts
[10:26:02.776]                         grepl <- base::grepl
[10:26:02.776]                         restarts <- computeRestarts(cond)
[10:26:02.776]                         for (restart in restarts) {
[10:26:02.776]                           name <- restart$name
[10:26:02.776]                           if (is.null(name)) 
[10:26:02.776]                             next
[10:26:02.776]                           if (!grepl(pattern, name)) 
[10:26:02.776]                             next
[10:26:02.776]                           invokeRestart(restart)
[10:26:02.776]                           muffled <- TRUE
[10:26:02.776]                           break
[10:26:02.776]                         }
[10:26:02.776]                       }
[10:26:02.776]                     }
[10:26:02.776]                     invisible(muffled)
[10:26:02.776]                   }
[10:26:02.776]                   muffleCondition(cond)
[10:26:02.776]                 })
[10:26:02.776]             }))
[10:26:02.776]             future::FutureResult(value = ...future.value$value, 
[10:26:02.776]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:02.776]                   ...future.rng), globalenv = if (FALSE) 
[10:26:02.776]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:02.776]                     ...future.globalenv.names))
[10:26:02.776]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:02.776]         }, condition = base::local({
[10:26:02.776]             c <- base::c
[10:26:02.776]             inherits <- base::inherits
[10:26:02.776]             invokeRestart <- base::invokeRestart
[10:26:02.776]             length <- base::length
[10:26:02.776]             list <- base::list
[10:26:02.776]             seq.int <- base::seq.int
[10:26:02.776]             signalCondition <- base::signalCondition
[10:26:02.776]             sys.calls <- base::sys.calls
[10:26:02.776]             `[[` <- base::`[[`
[10:26:02.776]             `+` <- base::`+`
[10:26:02.776]             `<<-` <- base::`<<-`
[10:26:02.776]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:02.776]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:02.776]                   3L)]
[10:26:02.776]             }
[10:26:02.776]             function(cond) {
[10:26:02.776]                 is_error <- inherits(cond, "error")
[10:26:02.776]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:02.776]                   NULL)
[10:26:02.776]                 if (is_error) {
[10:26:02.776]                   sessionInformation <- function() {
[10:26:02.776]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:02.776]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:02.776]                       search = base::search(), system = base::Sys.info())
[10:26:02.776]                   }
[10:26:02.776]                   ...future.conditions[[length(...future.conditions) + 
[10:26:02.776]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:02.776]                     cond$call), session = sessionInformation(), 
[10:26:02.776]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:02.776]                   signalCondition(cond)
[10:26:02.776]                 }
[10:26:02.776]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:02.776]                 "immediateCondition"))) {
[10:26:02.776]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:02.776]                   ...future.conditions[[length(...future.conditions) + 
[10:26:02.776]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:02.776]                   if (TRUE && !signal) {
[10:26:02.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:02.776]                     {
[10:26:02.776]                       inherits <- base::inherits
[10:26:02.776]                       invokeRestart <- base::invokeRestart
[10:26:02.776]                       is.null <- base::is.null
[10:26:02.776]                       muffled <- FALSE
[10:26:02.776]                       if (inherits(cond, "message")) {
[10:26:02.776]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:02.776]                         if (muffled) 
[10:26:02.776]                           invokeRestart("muffleMessage")
[10:26:02.776]                       }
[10:26:02.776]                       else if (inherits(cond, "warning")) {
[10:26:02.776]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:02.776]                         if (muffled) 
[10:26:02.776]                           invokeRestart("muffleWarning")
[10:26:02.776]                       }
[10:26:02.776]                       else if (inherits(cond, "condition")) {
[10:26:02.776]                         if (!is.null(pattern)) {
[10:26:02.776]                           computeRestarts <- base::computeRestarts
[10:26:02.776]                           grepl <- base::grepl
[10:26:02.776]                           restarts <- computeRestarts(cond)
[10:26:02.776]                           for (restart in restarts) {
[10:26:02.776]                             name <- restart$name
[10:26:02.776]                             if (is.null(name)) 
[10:26:02.776]                               next
[10:26:02.776]                             if (!grepl(pattern, name)) 
[10:26:02.776]                               next
[10:26:02.776]                             invokeRestart(restart)
[10:26:02.776]                             muffled <- TRUE
[10:26:02.776]                             break
[10:26:02.776]                           }
[10:26:02.776]                         }
[10:26:02.776]                       }
[10:26:02.776]                       invisible(muffled)
[10:26:02.776]                     }
[10:26:02.776]                     muffleCondition(cond, pattern = "^muffle")
[10:26:02.776]                   }
[10:26:02.776]                 }
[10:26:02.776]                 else {
[10:26:02.776]                   if (TRUE) {
[10:26:02.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:02.776]                     {
[10:26:02.776]                       inherits <- base::inherits
[10:26:02.776]                       invokeRestart <- base::invokeRestart
[10:26:02.776]                       is.null <- base::is.null
[10:26:02.776]                       muffled <- FALSE
[10:26:02.776]                       if (inherits(cond, "message")) {
[10:26:02.776]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:02.776]                         if (muffled) 
[10:26:02.776]                           invokeRestart("muffleMessage")
[10:26:02.776]                       }
[10:26:02.776]                       else if (inherits(cond, "warning")) {
[10:26:02.776]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:02.776]                         if (muffled) 
[10:26:02.776]                           invokeRestart("muffleWarning")
[10:26:02.776]                       }
[10:26:02.776]                       else if (inherits(cond, "condition")) {
[10:26:02.776]                         if (!is.null(pattern)) {
[10:26:02.776]                           computeRestarts <- base::computeRestarts
[10:26:02.776]                           grepl <- base::grepl
[10:26:02.776]                           restarts <- computeRestarts(cond)
[10:26:02.776]                           for (restart in restarts) {
[10:26:02.776]                             name <- restart$name
[10:26:02.776]                             if (is.null(name)) 
[10:26:02.776]                               next
[10:26:02.776]                             if (!grepl(pattern, name)) 
[10:26:02.776]                               next
[10:26:02.776]                             invokeRestart(restart)
[10:26:02.776]                             muffled <- TRUE
[10:26:02.776]                             break
[10:26:02.776]                           }
[10:26:02.776]                         }
[10:26:02.776]                       }
[10:26:02.776]                       invisible(muffled)
[10:26:02.776]                     }
[10:26:02.776]                     muffleCondition(cond, pattern = "^muffle")
[10:26:02.776]                   }
[10:26:02.776]                 }
[10:26:02.776]             }
[10:26:02.776]         }))
[10:26:02.776]     }, error = function(ex) {
[10:26:02.776]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:02.776]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:02.776]                 ...future.rng), started = ...future.startTime, 
[10:26:02.776]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:02.776]             version = "1.8"), class = "FutureResult")
[10:26:02.776]     }, finally = {
[10:26:02.776]         if (!identical(...future.workdir, getwd())) 
[10:26:02.776]             setwd(...future.workdir)
[10:26:02.776]         {
[10:26:02.776]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:02.776]                 ...future.oldOptions$nwarnings <- NULL
[10:26:02.776]             }
[10:26:02.776]             base::options(...future.oldOptions)
[10:26:02.776]             if (.Platform$OS.type == "windows") {
[10:26:02.776]                 old_names <- names(...future.oldEnvVars)
[10:26:02.776]                 envs <- base::Sys.getenv()
[10:26:02.776]                 names <- names(envs)
[10:26:02.776]                 common <- intersect(names, old_names)
[10:26:02.776]                 added <- setdiff(names, old_names)
[10:26:02.776]                 removed <- setdiff(old_names, names)
[10:26:02.776]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:02.776]                   envs[common]]
[10:26:02.776]                 NAMES <- toupper(changed)
[10:26:02.776]                 args <- list()
[10:26:02.776]                 for (kk in seq_along(NAMES)) {
[10:26:02.776]                   name <- changed[[kk]]
[10:26:02.776]                   NAME <- NAMES[[kk]]
[10:26:02.776]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:02.776]                     next
[10:26:02.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:02.776]                 }
[10:26:02.776]                 NAMES <- toupper(added)
[10:26:02.776]                 for (kk in seq_along(NAMES)) {
[10:26:02.776]                   name <- added[[kk]]
[10:26:02.776]                   NAME <- NAMES[[kk]]
[10:26:02.776]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:02.776]                     next
[10:26:02.776]                   args[[name]] <- ""
[10:26:02.776]                 }
[10:26:02.776]                 NAMES <- toupper(removed)
[10:26:02.776]                 for (kk in seq_along(NAMES)) {
[10:26:02.776]                   name <- removed[[kk]]
[10:26:02.776]                   NAME <- NAMES[[kk]]
[10:26:02.776]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:02.776]                     next
[10:26:02.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:02.776]                 }
[10:26:02.776]                 if (length(args) > 0) 
[10:26:02.776]                   base::do.call(base::Sys.setenv, args = args)
[10:26:02.776]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:02.776]             }
[10:26:02.776]             else {
[10:26:02.776]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:02.776]             }
[10:26:02.776]             {
[10:26:02.776]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:02.776]                   0L) {
[10:26:02.776]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:02.776]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:02.776]                   base::options(opts)
[10:26:02.776]                 }
[10:26:02.776]                 {
[10:26:02.776]                   {
[10:26:02.776]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:02.776]                     NULL
[10:26:02.776]                   }
[10:26:02.776]                   options(future.plan = NULL)
[10:26:02.776]                   if (is.na(NA_character_)) 
[10:26:02.776]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:02.776]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:02.776]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:02.776]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:02.776]                     envir = parent.frame()) 
[10:26:02.776]                   {
[10:26:02.776]                     if (is.function(workers)) 
[10:26:02.776]                       workers <- workers()
[10:26:02.776]                     workers <- structure(as.integer(workers), 
[10:26:02.776]                       class = class(workers))
[10:26:02.776]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:02.776]                       workers >= 1)
[10:26:02.776]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:02.776]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:02.776]                     }
[10:26:02.776]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:02.776]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:02.776]                       envir = envir)
[10:26:02.776]                     if (!future$lazy) 
[10:26:02.776]                       future <- run(future)
[10:26:02.776]                     invisible(future)
[10:26:02.776]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:02.776]                 }
[10:26:02.776]             }
[10:26:02.776]         }
[10:26:02.776]     })
[10:26:02.776]     if (TRUE) {
[10:26:02.776]         base::sink(type = "output", split = FALSE)
[10:26:02.776]         if (TRUE) {
[10:26:02.776]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:02.776]         }
[10:26:02.776]         else {
[10:26:02.776]             ...future.result["stdout"] <- base::list(NULL)
[10:26:02.776]         }
[10:26:02.776]         base::close(...future.stdout)
[10:26:02.776]         ...future.stdout <- NULL
[10:26:02.776]     }
[10:26:02.776]     ...future.result$conditions <- ...future.conditions
[10:26:02.776]     ...future.result$finished <- base::Sys.time()
[10:26:02.776]     ...future.result
[10:26:02.776] }
[10:26:02.780] MultisessionFuture started
[10:26:02.780] - Launch lazy future ... done
[10:26:02.780] run() for ‘MultisessionFuture’ ... done
[10:26:02.780] result() for ClusterFuture ...
[10:26:02.780] receiveMessageFromWorker() for ClusterFuture ...
[10:26:02.780] - Validating connection of MultisessionFuture
[10:26:02.826] - received message: FutureResult
[10:26:02.826] - Received FutureResult
[10:26:02.826] - Erased future from FutureRegistry
[10:26:02.826] result() for ClusterFuture ...
[10:26:02.826] - result already collected: FutureResult
[10:26:02.827] result() for ClusterFuture ... done
[10:26:02.827] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:02.827] result() for ClusterFuture ... done
[10:26:02.827] result() for ClusterFuture ...
[10:26:02.827] - result already collected: FutureResult
[10:26:02.827] result() for ClusterFuture ... done
[10:26:02.828] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:26:02.828] Searching for globals...
[10:26:02.829] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[10:26:02.830] Searching for globals...
[10:26:02.831] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[10:26:02.831] Searching for globals ... DONE
[10:26:02.831] Resolving globals: FALSE
[10:26:02.832] The total size of the 1 globals is 160 bytes (160 bytes)
[10:26:02.832] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 160 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (160 bytes of class ‘list’)
[10:26:02.832] - globals: [1] ‘data’
[10:26:02.832] 
[10:26:02.832] getGlobalsAndPackages() ... DONE
[10:26:02.833] run() for ‘Future’ ...
[10:26:02.833] - state: ‘created’
[10:26:02.833] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:02.847] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:02.847] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:02.847]   - Field: ‘node’
[10:26:02.847]   - Field: ‘label’
[10:26:02.848]   - Field: ‘local’
[10:26:02.848]   - Field: ‘owner’
[10:26:02.848]   - Field: ‘envir’
[10:26:02.848]   - Field: ‘workers’
[10:26:02.848]   - Field: ‘packages’
[10:26:02.848]   - Field: ‘gc’
[10:26:02.848]   - Field: ‘conditions’
[10:26:02.848]   - Field: ‘persistent’
[10:26:02.848]   - Field: ‘expr’
[10:26:02.848]   - Field: ‘uuid’
[10:26:02.849]   - Field: ‘seed’
[10:26:02.849]   - Field: ‘version’
[10:26:02.849]   - Field: ‘result’
[10:26:02.849]   - Field: ‘asynchronous’
[10:26:02.849]   - Field: ‘calls’
[10:26:02.849]   - Field: ‘globals’
[10:26:02.849]   - Field: ‘stdout’
[10:26:02.850]   - Field: ‘earlySignal’
[10:26:02.850]   - Field: ‘lazy’
[10:26:02.850]   - Field: ‘state’
[10:26:02.850] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:02.850] - Launch lazy future ...
[10:26:02.850] Packages needed by the future expression (n = 0): <none>
[10:26:02.850] Packages needed by future strategies (n = 0): <none>
[10:26:02.851] {
[10:26:02.851]     {
[10:26:02.851]         {
[10:26:02.851]             ...future.startTime <- base::Sys.time()
[10:26:02.851]             {
[10:26:02.851]                 {
[10:26:02.851]                   {
[10:26:02.851]                     {
[10:26:02.851]                       base::local({
[10:26:02.851]                         has_future <- base::requireNamespace("future", 
[10:26:02.851]                           quietly = TRUE)
[10:26:02.851]                         if (has_future) {
[10:26:02.851]                           ns <- base::getNamespace("future")
[10:26:02.851]                           version <- ns[[".package"]][["version"]]
[10:26:02.851]                           if (is.null(version)) 
[10:26:02.851]                             version <- utils::packageVersion("future")
[10:26:02.851]                         }
[10:26:02.851]                         else {
[10:26:02.851]                           version <- NULL
[10:26:02.851]                         }
[10:26:02.851]                         if (!has_future || version < "1.8.0") {
[10:26:02.851]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:02.851]                             "", base::R.version$version.string), 
[10:26:02.851]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:02.851]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:02.851]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:02.851]                               "release", "version")], collapse = " "), 
[10:26:02.851]                             hostname = base::Sys.info()[["nodename"]])
[10:26:02.851]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:02.851]                             info)
[10:26:02.851]                           info <- base::paste(info, collapse = "; ")
[10:26:02.851]                           if (!has_future) {
[10:26:02.851]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:02.851]                               info)
[10:26:02.851]                           }
[10:26:02.851]                           else {
[10:26:02.851]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:02.851]                               info, version)
[10:26:02.851]                           }
[10:26:02.851]                           base::stop(msg)
[10:26:02.851]                         }
[10:26:02.851]                       })
[10:26:02.851]                     }
[10:26:02.851]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:02.851]                     base::options(mc.cores = 1L)
[10:26:02.851]                   }
[10:26:02.851]                   options(future.plan = NULL)
[10:26:02.851]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:02.851]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:02.851]                 }
[10:26:02.851]                 ...future.workdir <- getwd()
[10:26:02.851]             }
[10:26:02.851]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:02.851]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:02.851]         }
[10:26:02.851]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[10:26:02.851]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:02.851]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[10:26:02.851]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:02.851]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:02.851]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:02.851]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:02.851]             base::names(...future.oldOptions))
[10:26:02.851]     }
[10:26:02.851]     if (FALSE) {
[10:26:02.851]     }
[10:26:02.851]     else {
[10:26:02.851]         if (TRUE) {
[10:26:02.851]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:02.851]                 open = "w")
[10:26:02.851]         }
[10:26:02.851]         else {
[10:26:02.851]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:02.851]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:02.851]         }
[10:26:02.851]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:02.851]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:02.851]             base::sink(type = "output", split = FALSE)
[10:26:02.851]             base::close(...future.stdout)
[10:26:02.851]         }, add = TRUE)
[10:26:02.851]     }
[10:26:02.851]     ...future.frame <- base::sys.nframe()
[10:26:02.851]     ...future.conditions <- base::list()
[10:26:02.851]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:02.851]     if (FALSE) {
[10:26:02.851]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:02.851]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:02.851]     }
[10:26:02.851]     ...future.result <- base::tryCatch({
[10:26:02.851]         base::withCallingHandlers({
[10:26:02.851]             ...future.value <- base::withVisible(base::local({
[10:26:02.851]                 ...future.makeSendCondition <- base::local({
[10:26:02.851]                   sendCondition <- NULL
[10:26:02.851]                   function(frame = 1L) {
[10:26:02.851]                     if (is.function(sendCondition)) 
[10:26:02.851]                       return(sendCondition)
[10:26:02.851]                     ns <- getNamespace("parallel")
[10:26:02.851]                     if (exists("sendData", mode = "function", 
[10:26:02.851]                       envir = ns)) {
[10:26:02.851]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:02.851]                         envir = ns)
[10:26:02.851]                       envir <- sys.frame(frame)
[10:26:02.851]                       master <- NULL
[10:26:02.851]                       while (!identical(envir, .GlobalEnv) && 
[10:26:02.851]                         !identical(envir, emptyenv())) {
[10:26:02.851]                         if (exists("master", mode = "list", envir = envir, 
[10:26:02.851]                           inherits = FALSE)) {
[10:26:02.851]                           master <- get("master", mode = "list", 
[10:26:02.851]                             envir = envir, inherits = FALSE)
[10:26:02.851]                           if (inherits(master, c("SOCKnode", 
[10:26:02.851]                             "SOCK0node"))) {
[10:26:02.851]                             sendCondition <<- function(cond) {
[10:26:02.851]                               data <- list(type = "VALUE", value = cond, 
[10:26:02.851]                                 success = TRUE)
[10:26:02.851]                               parallel_sendData(master, data)
[10:26:02.851]                             }
[10:26:02.851]                             return(sendCondition)
[10:26:02.851]                           }
[10:26:02.851]                         }
[10:26:02.851]                         frame <- frame + 1L
[10:26:02.851]                         envir <- sys.frame(frame)
[10:26:02.851]                       }
[10:26:02.851]                     }
[10:26:02.851]                     sendCondition <<- function(cond) NULL
[10:26:02.851]                   }
[10:26:02.851]                 })
[10:26:02.851]                 withCallingHandlers({
[10:26:02.851]                   subset(data, x < 3)$y
[10:26:02.851]                 }, immediateCondition = function(cond) {
[10:26:02.851]                   sendCondition <- ...future.makeSendCondition()
[10:26:02.851]                   sendCondition(cond)
[10:26:02.851]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:02.851]                   {
[10:26:02.851]                     inherits <- base::inherits
[10:26:02.851]                     invokeRestart <- base::invokeRestart
[10:26:02.851]                     is.null <- base::is.null
[10:26:02.851]                     muffled <- FALSE
[10:26:02.851]                     if (inherits(cond, "message")) {
[10:26:02.851]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:02.851]                       if (muffled) 
[10:26:02.851]                         invokeRestart("muffleMessage")
[10:26:02.851]                     }
[10:26:02.851]                     else if (inherits(cond, "warning")) {
[10:26:02.851]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:02.851]                       if (muffled) 
[10:26:02.851]                         invokeRestart("muffleWarning")
[10:26:02.851]                     }
[10:26:02.851]                     else if (inherits(cond, "condition")) {
[10:26:02.851]                       if (!is.null(pattern)) {
[10:26:02.851]                         computeRestarts <- base::computeRestarts
[10:26:02.851]                         grepl <- base::grepl
[10:26:02.851]                         restarts <- computeRestarts(cond)
[10:26:02.851]                         for (restart in restarts) {
[10:26:02.851]                           name <- restart$name
[10:26:02.851]                           if (is.null(name)) 
[10:26:02.851]                             next
[10:26:02.851]                           if (!grepl(pattern, name)) 
[10:26:02.851]                             next
[10:26:02.851]                           invokeRestart(restart)
[10:26:02.851]                           muffled <- TRUE
[10:26:02.851]                           break
[10:26:02.851]                         }
[10:26:02.851]                       }
[10:26:02.851]                     }
[10:26:02.851]                     invisible(muffled)
[10:26:02.851]                   }
[10:26:02.851]                   muffleCondition(cond)
[10:26:02.851]                 })
[10:26:02.851]             }))
[10:26:02.851]             future::FutureResult(value = ...future.value$value, 
[10:26:02.851]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:02.851]                   ...future.rng), globalenv = if (FALSE) 
[10:26:02.851]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:02.851]                     ...future.globalenv.names))
[10:26:02.851]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:02.851]         }, condition = base::local({
[10:26:02.851]             c <- base::c
[10:26:02.851]             inherits <- base::inherits
[10:26:02.851]             invokeRestart <- base::invokeRestart
[10:26:02.851]             length <- base::length
[10:26:02.851]             list <- base::list
[10:26:02.851]             seq.int <- base::seq.int
[10:26:02.851]             signalCondition <- base::signalCondition
[10:26:02.851]             sys.calls <- base::sys.calls
[10:26:02.851]             `[[` <- base::`[[`
[10:26:02.851]             `+` <- base::`+`
[10:26:02.851]             `<<-` <- base::`<<-`
[10:26:02.851]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:02.851]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:02.851]                   3L)]
[10:26:02.851]             }
[10:26:02.851]             function(cond) {
[10:26:02.851]                 is_error <- inherits(cond, "error")
[10:26:02.851]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:02.851]                   NULL)
[10:26:02.851]                 if (is_error) {
[10:26:02.851]                   sessionInformation <- function() {
[10:26:02.851]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:02.851]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:02.851]                       search = base::search(), system = base::Sys.info())
[10:26:02.851]                   }
[10:26:02.851]                   ...future.conditions[[length(...future.conditions) + 
[10:26:02.851]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:02.851]                     cond$call), session = sessionInformation(), 
[10:26:02.851]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:02.851]                   signalCondition(cond)
[10:26:02.851]                 }
[10:26:02.851]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:02.851]                 "immediateCondition"))) {
[10:26:02.851]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:02.851]                   ...future.conditions[[length(...future.conditions) + 
[10:26:02.851]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:02.851]                   if (TRUE && !signal) {
[10:26:02.851]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:02.851]                     {
[10:26:02.851]                       inherits <- base::inherits
[10:26:02.851]                       invokeRestart <- base::invokeRestart
[10:26:02.851]                       is.null <- base::is.null
[10:26:02.851]                       muffled <- FALSE
[10:26:02.851]                       if (inherits(cond, "message")) {
[10:26:02.851]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:02.851]                         if (muffled) 
[10:26:02.851]                           invokeRestart("muffleMessage")
[10:26:02.851]                       }
[10:26:02.851]                       else if (inherits(cond, "warning")) {
[10:26:02.851]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:02.851]                         if (muffled) 
[10:26:02.851]                           invokeRestart("muffleWarning")
[10:26:02.851]                       }
[10:26:02.851]                       else if (inherits(cond, "condition")) {
[10:26:02.851]                         if (!is.null(pattern)) {
[10:26:02.851]                           computeRestarts <- base::computeRestarts
[10:26:02.851]                           grepl <- base::grepl
[10:26:02.851]                           restarts <- computeRestarts(cond)
[10:26:02.851]                           for (restart in restarts) {
[10:26:02.851]                             name <- restart$name
[10:26:02.851]                             if (is.null(name)) 
[10:26:02.851]                               next
[10:26:02.851]                             if (!grepl(pattern, name)) 
[10:26:02.851]                               next
[10:26:02.851]                             invokeRestart(restart)
[10:26:02.851]                             muffled <- TRUE
[10:26:02.851]                             break
[10:26:02.851]                           }
[10:26:02.851]                         }
[10:26:02.851]                       }
[10:26:02.851]                       invisible(muffled)
[10:26:02.851]                     }
[10:26:02.851]                     muffleCondition(cond, pattern = "^muffle")
[10:26:02.851]                   }
[10:26:02.851]                 }
[10:26:02.851]                 else {
[10:26:02.851]                   if (TRUE) {
[10:26:02.851]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:02.851]                     {
[10:26:02.851]                       inherits <- base::inherits
[10:26:02.851]                       invokeRestart <- base::invokeRestart
[10:26:02.851]                       is.null <- base::is.null
[10:26:02.851]                       muffled <- FALSE
[10:26:02.851]                       if (inherits(cond, "message")) {
[10:26:02.851]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:02.851]                         if (muffled) 
[10:26:02.851]                           invokeRestart("muffleMessage")
[10:26:02.851]                       }
[10:26:02.851]                       else if (inherits(cond, "warning")) {
[10:26:02.851]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:02.851]                         if (muffled) 
[10:26:02.851]                           invokeRestart("muffleWarning")
[10:26:02.851]                       }
[10:26:02.851]                       else if (inherits(cond, "condition")) {
[10:26:02.851]                         if (!is.null(pattern)) {
[10:26:02.851]                           computeRestarts <- base::computeRestarts
[10:26:02.851]                           grepl <- base::grepl
[10:26:02.851]                           restarts <- computeRestarts(cond)
[10:26:02.851]                           for (restart in restarts) {
[10:26:02.851]                             name <- restart$name
[10:26:02.851]                             if (is.null(name)) 
[10:26:02.851]                               next
[10:26:02.851]                             if (!grepl(pattern, name)) 
[10:26:02.851]                               next
[10:26:02.851]                             invokeRestart(restart)
[10:26:02.851]                             muffled <- TRUE
[10:26:02.851]                             break
[10:26:02.851]                           }
[10:26:02.851]                         }
[10:26:02.851]                       }
[10:26:02.851]                       invisible(muffled)
[10:26:02.851]                     }
[10:26:02.851]                     muffleCondition(cond, pattern = "^muffle")
[10:26:02.851]                   }
[10:26:02.851]                 }
[10:26:02.851]             }
[10:26:02.851]         }))
[10:26:02.851]     }, error = function(ex) {
[10:26:02.851]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:02.851]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:02.851]                 ...future.rng), started = ...future.startTime, 
[10:26:02.851]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:02.851]             version = "1.8"), class = "FutureResult")
[10:26:02.851]     }, finally = {
[10:26:02.851]         if (!identical(...future.workdir, getwd())) 
[10:26:02.851]             setwd(...future.workdir)
[10:26:02.851]         {
[10:26:02.851]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:02.851]                 ...future.oldOptions$nwarnings <- NULL
[10:26:02.851]             }
[10:26:02.851]             base::options(...future.oldOptions)
[10:26:02.851]             if (.Platform$OS.type == "windows") {
[10:26:02.851]                 old_names <- names(...future.oldEnvVars)
[10:26:02.851]                 envs <- base::Sys.getenv()
[10:26:02.851]                 names <- names(envs)
[10:26:02.851]                 common <- intersect(names, old_names)
[10:26:02.851]                 added <- setdiff(names, old_names)
[10:26:02.851]                 removed <- setdiff(old_names, names)
[10:26:02.851]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:02.851]                   envs[common]]
[10:26:02.851]                 NAMES <- toupper(changed)
[10:26:02.851]                 args <- list()
[10:26:02.851]                 for (kk in seq_along(NAMES)) {
[10:26:02.851]                   name <- changed[[kk]]
[10:26:02.851]                   NAME <- NAMES[[kk]]
[10:26:02.851]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:02.851]                     next
[10:26:02.851]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:02.851]                 }
[10:26:02.851]                 NAMES <- toupper(added)
[10:26:02.851]                 for (kk in seq_along(NAMES)) {
[10:26:02.851]                   name <- added[[kk]]
[10:26:02.851]                   NAME <- NAMES[[kk]]
[10:26:02.851]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:02.851]                     next
[10:26:02.851]                   args[[name]] <- ""
[10:26:02.851]                 }
[10:26:02.851]                 NAMES <- toupper(removed)
[10:26:02.851]                 for (kk in seq_along(NAMES)) {
[10:26:02.851]                   name <- removed[[kk]]
[10:26:02.851]                   NAME <- NAMES[[kk]]
[10:26:02.851]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:02.851]                     next
[10:26:02.851]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:02.851]                 }
[10:26:02.851]                 if (length(args) > 0) 
[10:26:02.851]                   base::do.call(base::Sys.setenv, args = args)
[10:26:02.851]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:02.851]             }
[10:26:02.851]             else {
[10:26:02.851]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:02.851]             }
[10:26:02.851]             {
[10:26:02.851]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:02.851]                   0L) {
[10:26:02.851]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:02.851]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:02.851]                   base::options(opts)
[10:26:02.851]                 }
[10:26:02.851]                 {
[10:26:02.851]                   {
[10:26:02.851]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:02.851]                     NULL
[10:26:02.851]                   }
[10:26:02.851]                   options(future.plan = NULL)
[10:26:02.851]                   if (is.na(NA_character_)) 
[10:26:02.851]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:02.851]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:02.851]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:02.851]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:02.851]                     envir = parent.frame()) 
[10:26:02.851]                   {
[10:26:02.851]                     if (is.function(workers)) 
[10:26:02.851]                       workers <- workers()
[10:26:02.851]                     workers <- structure(as.integer(workers), 
[10:26:02.851]                       class = class(workers))
[10:26:02.851]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:02.851]                       workers >= 1)
[10:26:02.851]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:02.851]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:02.851]                     }
[10:26:02.851]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:02.851]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:02.851]                       envir = envir)
[10:26:02.851]                     if (!future$lazy) 
[10:26:02.851]                       future <- run(future)
[10:26:02.851]                     invisible(future)
[10:26:02.851]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:02.851]                 }
[10:26:02.851]             }
[10:26:02.851]         }
[10:26:02.851]     })
[10:26:02.851]     if (TRUE) {
[10:26:02.851]         base::sink(type = "output", split = FALSE)
[10:26:02.851]         if (TRUE) {
[10:26:02.851]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:02.851]         }
[10:26:02.851]         else {
[10:26:02.851]             ...future.result["stdout"] <- base::list(NULL)
[10:26:02.851]         }
[10:26:02.851]         base::close(...future.stdout)
[10:26:02.851]         ...future.stdout <- NULL
[10:26:02.851]     }
[10:26:02.851]     ...future.result$conditions <- ...future.conditions
[10:26:02.851]     ...future.result$finished <- base::Sys.time()
[10:26:02.851]     ...future.result
[10:26:02.851] }
[10:26:02.854] Exporting 1 global objects (160 bytes) to cluster node #1 ...
[10:26:02.854] Exporting ‘data’ (160 bytes) to cluster node #1 ...
[10:26:02.855] Exporting ‘data’ (160 bytes) to cluster node #1 ... DONE
[10:26:02.855] Exporting 1 global objects (160 bytes) to cluster node #1 ... DONE
[10:26:02.855] MultisessionFuture started
[10:26:02.856] - Launch lazy future ... done
[10:26:02.856] run() for ‘MultisessionFuture’ ... done
[10:26:02.856] result() for ClusterFuture ...
[10:26:02.856] receiveMessageFromWorker() for ClusterFuture ...
[10:26:02.856] - Validating connection of MultisessionFuture
[10:26:02.902] - received message: FutureResult
[10:26:02.902] - Received FutureResult
[10:26:02.903] - Erased future from FutureRegistry
[10:26:02.903] result() for ClusterFuture ...
[10:26:02.903] - result already collected: FutureResult
[10:26:02.903] result() for ClusterFuture ... done
[10:26:02.903] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:02.903] result() for ClusterFuture ... done
[10:26:02.903] result() for ClusterFuture ...
[10:26:02.903] - result already collected: FutureResult
[10:26:02.903] result() for ClusterFuture ... done
[10:26:02.904] plan(): Setting new future strategy stack:
[10:26:02.904] List of future strategies:
[10:26:02.904] 1. sequential:
[10:26:02.904]    - args: function (..., envir = parent.frame())
[10:26:02.904]    - tweaked: FALSE
[10:26:02.904]    - call: plan(list(sequential, strategy))
[10:26:02.904] 2. multisession:
[10:26:02.904]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:26:02.904]    - tweaked: FALSE
[10:26:02.904]    - call: plan(list(sequential, strategy))
[10:26:02.905] plan(): nbrOfWorkers() = 1
[10:26:02.905] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[10:26:02.906] Searching for globals...
[10:26:02.911] - globals found: [8] ‘{’, ‘<-’, ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’, ‘%<-%’
[10:26:02.911] Searching for globals ... DONE
[10:26:02.911] Resolving globals: FALSE
[10:26:02.912] The total size of the 1 globals is 160 bytes (160 bytes)
[10:26:02.912] The total size of the 1 globals exported for future expression (‘{; a %<-% subset(data, x < 3)$y; a; }’) is 160 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (160 bytes of class ‘list’)
[10:26:02.912] - globals: [1] ‘data’
[10:26:02.913] - packages: [1] ‘future’
[10:26:02.913] getGlobalsAndPackages() ... DONE
[10:26:02.913] run() for ‘Future’ ...
[10:26:02.913] - state: ‘created’
[10:26:02.913] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:02.914] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:02.914] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:02.914]   - Field: ‘label’
[10:26:02.914]   - Field: ‘local’
[10:26:02.914]   - Field: ‘owner’
[10:26:02.914]   - Field: ‘envir’
[10:26:02.914]   - Field: ‘packages’
[10:26:02.914]   - Field: ‘gc’
[10:26:02.914]   - Field: ‘conditions’
[10:26:02.914]   - Field: ‘expr’
[10:26:02.915]   - Field: ‘uuid’
[10:26:02.915]   - Field: ‘seed’
[10:26:02.915]   - Field: ‘version’
[10:26:02.915]   - Field: ‘result’
[10:26:02.915]   - Field: ‘asynchronous’
[10:26:02.915]   - Field: ‘calls’
[10:26:02.915]   - Field: ‘globals’
[10:26:02.915]   - Field: ‘stdout’
[10:26:02.915]   - Field: ‘earlySignal’
[10:26:02.915]   - Field: ‘lazy’
[10:26:02.915]   - Field: ‘state’
[10:26:02.916] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:02.916] - Launch lazy future ...
[10:26:02.916] Packages needed by the future expression (n = 1): ‘future’
[10:26:02.916] Packages needed by future strategies (n = 1): ‘future’
[10:26:02.917] {
[10:26:02.917]     {
[10:26:02.917]         {
[10:26:02.917]             ...future.startTime <- base::Sys.time()
[10:26:02.917]             {
[10:26:02.917]                 {
[10:26:02.917]                   {
[10:26:02.917]                     {
[10:26:02.917]                       base::local({
[10:26:02.917]                         has_future <- base::requireNamespace("future", 
[10:26:02.917]                           quietly = TRUE)
[10:26:02.917]                         if (has_future) {
[10:26:02.917]                           ns <- base::getNamespace("future")
[10:26:02.917]                           version <- ns[[".package"]][["version"]]
[10:26:02.917]                           if (is.null(version)) 
[10:26:02.917]                             version <- utils::packageVersion("future")
[10:26:02.917]                         }
[10:26:02.917]                         else {
[10:26:02.917]                           version <- NULL
[10:26:02.917]                         }
[10:26:02.917]                         if (!has_future || version < "1.8.0") {
[10:26:02.917]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:02.917]                             "", base::R.version$version.string), 
[10:26:02.917]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:02.917]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:02.917]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:02.917]                               "release", "version")], collapse = " "), 
[10:26:02.917]                             hostname = base::Sys.info()[["nodename"]])
[10:26:02.917]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:02.917]                             info)
[10:26:02.917]                           info <- base::paste(info, collapse = "; ")
[10:26:02.917]                           if (!has_future) {
[10:26:02.917]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:02.917]                               info)
[10:26:02.917]                           }
[10:26:02.917]                           else {
[10:26:02.917]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:02.917]                               info, version)
[10:26:02.917]                           }
[10:26:02.917]                           base::stop(msg)
[10:26:02.917]                         }
[10:26:02.917]                       })
[10:26:02.917]                     }
[10:26:02.917]                     base::local({
[10:26:02.917]                       for (pkg in "future") {
[10:26:02.917]                         base::loadNamespace(pkg)
[10:26:02.917]                         base::library(pkg, character.only = TRUE)
[10:26:02.917]                       }
[10:26:02.917]                     })
[10:26:02.917]                   }
[10:26:02.917]                   options(future.plan = NULL)
[10:26:02.917]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:02.917]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:02.917]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:02.917]                     envir = parent.frame()) 
[10:26:02.917]                   {
[10:26:02.917]                     if (is.function(workers)) 
[10:26:02.917]                       workers <- workers()
[10:26:02.917]                     workers <- structure(as.integer(workers), 
[10:26:02.917]                       class = class(workers))
[10:26:02.917]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:02.917]                       workers >= 1)
[10:26:02.917]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:02.917]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:02.917]                     }
[10:26:02.917]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:02.917]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:02.917]                       envir = envir)
[10:26:02.917]                     if (!future$lazy) 
[10:26:02.917]                       future <- run(future)
[10:26:02.917]                     invisible(future)
[10:26:02.917]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:02.917]                 }
[10:26:02.917]                 ...future.workdir <- getwd()
[10:26:02.917]             }
[10:26:02.917]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:02.917]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:02.917]         }
[10:26:02.917]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[10:26:02.917]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:02.917]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[10:26:02.917]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:02.917]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:02.917]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:02.917]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:02.917]             base::names(...future.oldOptions))
[10:26:02.917]     }
[10:26:02.917]     if (FALSE) {
[10:26:02.917]     }
[10:26:02.917]     else {
[10:26:02.917]         if (TRUE) {
[10:26:02.917]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:02.917]                 open = "w")
[10:26:02.917]         }
[10:26:02.917]         else {
[10:26:02.917]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:02.917]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:02.917]         }
[10:26:02.917]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:02.917]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:02.917]             base::sink(type = "output", split = FALSE)
[10:26:02.917]             base::close(...future.stdout)
[10:26:02.917]         }, add = TRUE)
[10:26:02.917]     }
[10:26:02.917]     ...future.frame <- base::sys.nframe()
[10:26:02.917]     ...future.conditions <- base::list()
[10:26:02.917]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:02.917]     if (FALSE) {
[10:26:02.917]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:02.917]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:02.917]     }
[10:26:02.917]     ...future.result <- base::tryCatch({
[10:26:02.917]         base::withCallingHandlers({
[10:26:02.917]             ...future.value <- base::withVisible(base::local({
[10:26:02.917]                 a %<-% subset(data, x < 3)$y
[10:26:02.917]                 a
[10:26:02.917]             }))
[10:26:02.917]             future::FutureResult(value = ...future.value$value, 
[10:26:02.917]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:02.917]                   ...future.rng), globalenv = if (FALSE) 
[10:26:02.917]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:02.917]                     ...future.globalenv.names))
[10:26:02.917]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:02.917]         }, condition = base::local({
[10:26:02.917]             c <- base::c
[10:26:02.917]             inherits <- base::inherits
[10:26:02.917]             invokeRestart <- base::invokeRestart
[10:26:02.917]             length <- base::length
[10:26:02.917]             list <- base::list
[10:26:02.917]             seq.int <- base::seq.int
[10:26:02.917]             signalCondition <- base::signalCondition
[10:26:02.917]             sys.calls <- base::sys.calls
[10:26:02.917]             `[[` <- base::`[[`
[10:26:02.917]             `+` <- base::`+`
[10:26:02.917]             `<<-` <- base::`<<-`
[10:26:02.917]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:02.917]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:02.917]                   3L)]
[10:26:02.917]             }
[10:26:02.917]             function(cond) {
[10:26:02.917]                 is_error <- inherits(cond, "error")
[10:26:02.917]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:02.917]                   NULL)
[10:26:02.917]                 if (is_error) {
[10:26:02.917]                   sessionInformation <- function() {
[10:26:02.917]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:02.917]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:02.917]                       search = base::search(), system = base::Sys.info())
[10:26:02.917]                   }
[10:26:02.917]                   ...future.conditions[[length(...future.conditions) + 
[10:26:02.917]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:02.917]                     cond$call), session = sessionInformation(), 
[10:26:02.917]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:02.917]                   signalCondition(cond)
[10:26:02.917]                 }
[10:26:02.917]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:02.917]                 "immediateCondition"))) {
[10:26:02.917]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:02.917]                   ...future.conditions[[length(...future.conditions) + 
[10:26:02.917]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:02.917]                   if (TRUE && !signal) {
[10:26:02.917]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:02.917]                     {
[10:26:02.917]                       inherits <- base::inherits
[10:26:02.917]                       invokeRestart <- base::invokeRestart
[10:26:02.917]                       is.null <- base::is.null
[10:26:02.917]                       muffled <- FALSE
[10:26:02.917]                       if (inherits(cond, "message")) {
[10:26:02.917]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:02.917]                         if (muffled) 
[10:26:02.917]                           invokeRestart("muffleMessage")
[10:26:02.917]                       }
[10:26:02.917]                       else if (inherits(cond, "warning")) {
[10:26:02.917]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:02.917]                         if (muffled) 
[10:26:02.917]                           invokeRestart("muffleWarning")
[10:26:02.917]                       }
[10:26:02.917]                       else if (inherits(cond, "condition")) {
[10:26:02.917]                         if (!is.null(pattern)) {
[10:26:02.917]                           computeRestarts <- base::computeRestarts
[10:26:02.917]                           grepl <- base::grepl
[10:26:02.917]                           restarts <- computeRestarts(cond)
[10:26:02.917]                           for (restart in restarts) {
[10:26:02.917]                             name <- restart$name
[10:26:02.917]                             if (is.null(name)) 
[10:26:02.917]                               next
[10:26:02.917]                             if (!grepl(pattern, name)) 
[10:26:02.917]                               next
[10:26:02.917]                             invokeRestart(restart)
[10:26:02.917]                             muffled <- TRUE
[10:26:02.917]                             break
[10:26:02.917]                           }
[10:26:02.917]                         }
[10:26:02.917]                       }
[10:26:02.917]                       invisible(muffled)
[10:26:02.917]                     }
[10:26:02.917]                     muffleCondition(cond, pattern = "^muffle")
[10:26:02.917]                   }
[10:26:02.917]                 }
[10:26:02.917]                 else {
[10:26:02.917]                   if (TRUE) {
[10:26:02.917]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:02.917]                     {
[10:26:02.917]                       inherits <- base::inherits
[10:26:02.917]                       invokeRestart <- base::invokeRestart
[10:26:02.917]                       is.null <- base::is.null
[10:26:02.917]                       muffled <- FALSE
[10:26:02.917]                       if (inherits(cond, "message")) {
[10:26:02.917]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:02.917]                         if (muffled) 
[10:26:02.917]                           invokeRestart("muffleMessage")
[10:26:02.917]                       }
[10:26:02.917]                       else if (inherits(cond, "warning")) {
[10:26:02.917]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:02.917]                         if (muffled) 
[10:26:02.917]                           invokeRestart("muffleWarning")
[10:26:02.917]                       }
[10:26:02.917]                       else if (inherits(cond, "condition")) {
[10:26:02.917]                         if (!is.null(pattern)) {
[10:26:02.917]                           computeRestarts <- base::computeRestarts
[10:26:02.917]                           grepl <- base::grepl
[10:26:02.917]                           restarts <- computeRestarts(cond)
[10:26:02.917]                           for (restart in restarts) {
[10:26:02.917]                             name <- restart$name
[10:26:02.917]                             if (is.null(name)) 
[10:26:02.917]                               next
[10:26:02.917]                             if (!grepl(pattern, name)) 
[10:26:02.917]                               next
[10:26:02.917]                             invokeRestart(restart)
[10:26:02.917]                             muffled <- TRUE
[10:26:02.917]                             break
[10:26:02.917]                           }
[10:26:02.917]                         }
[10:26:02.917]                       }
[10:26:02.917]                       invisible(muffled)
[10:26:02.917]                     }
[10:26:02.917]                     muffleCondition(cond, pattern = "^muffle")
[10:26:02.917]                   }
[10:26:02.917]                 }
[10:26:02.917]             }
[10:26:02.917]         }))
[10:26:02.917]     }, error = function(ex) {
[10:26:02.917]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:02.917]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:02.917]                 ...future.rng), started = ...future.startTime, 
[10:26:02.917]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:02.917]             version = "1.8"), class = "FutureResult")
[10:26:02.917]     }, finally = {
[10:26:02.917]         if (!identical(...future.workdir, getwd())) 
[10:26:02.917]             setwd(...future.workdir)
[10:26:02.917]         {
[10:26:02.917]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:02.917]                 ...future.oldOptions$nwarnings <- NULL
[10:26:02.917]             }
[10:26:02.917]             base::options(...future.oldOptions)
[10:26:02.917]             if (.Platform$OS.type == "windows") {
[10:26:02.917]                 old_names <- names(...future.oldEnvVars)
[10:26:02.917]                 envs <- base::Sys.getenv()
[10:26:02.917]                 names <- names(envs)
[10:26:02.917]                 common <- intersect(names, old_names)
[10:26:02.917]                 added <- setdiff(names, old_names)
[10:26:02.917]                 removed <- setdiff(old_names, names)
[10:26:02.917]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:02.917]                   envs[common]]
[10:26:02.917]                 NAMES <- toupper(changed)
[10:26:02.917]                 args <- list()
[10:26:02.917]                 for (kk in seq_along(NAMES)) {
[10:26:02.917]                   name <- changed[[kk]]
[10:26:02.917]                   NAME <- NAMES[[kk]]
[10:26:02.917]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:02.917]                     next
[10:26:02.917]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:02.917]                 }
[10:26:02.917]                 NAMES <- toupper(added)
[10:26:02.917]                 for (kk in seq_along(NAMES)) {
[10:26:02.917]                   name <- added[[kk]]
[10:26:02.917]                   NAME <- NAMES[[kk]]
[10:26:02.917]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:02.917]                     next
[10:26:02.917]                   args[[name]] <- ""
[10:26:02.917]                 }
[10:26:02.917]                 NAMES <- toupper(removed)
[10:26:02.917]                 for (kk in seq_along(NAMES)) {
[10:26:02.917]                   name <- removed[[kk]]
[10:26:02.917]                   NAME <- NAMES[[kk]]
[10:26:02.917]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:02.917]                     next
[10:26:02.917]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:02.917]                 }
[10:26:02.917]                 if (length(args) > 0) 
[10:26:02.917]                   base::do.call(base::Sys.setenv, args = args)
[10:26:02.917]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:02.917]             }
[10:26:02.917]             else {
[10:26:02.917]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:02.917]             }
[10:26:02.917]             {
[10:26:02.917]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:02.917]                   0L) {
[10:26:02.917]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:02.917]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:02.917]                   base::options(opts)
[10:26:02.917]                 }
[10:26:02.917]                 {
[10:26:02.917]                   {
[10:26:02.917]                     NULL
[10:26:02.917]                     RNGkind("Mersenne-Twister")
[10:26:02.917]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:02.917]                       inherits = FALSE)
[10:26:02.917]                   }
[10:26:02.917]                   options(future.plan = NULL)
[10:26:02.917]                   if (is.na(NA_character_)) 
[10:26:02.917]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:02.917]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:02.917]                   future::plan(list(function (..., envir = parent.frame()) 
[10:26:02.917]                   {
[10:26:02.917]                     future <- SequentialFuture(..., envir = envir)
[10:26:02.917]                     if (!future$lazy) 
[10:26:02.917]                       future <- run(future)
[10:26:02.917]                     invisible(future)
[10:26:02.917]                   }, function (..., workers = availableCores(), 
[10:26:02.917]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:02.917]                     envir = parent.frame()) 
[10:26:02.917]                   {
[10:26:02.917]                     if (is.function(workers)) 
[10:26:02.917]                       workers <- workers()
[10:26:02.917]                     workers <- structure(as.integer(workers), 
[10:26:02.917]                       class = class(workers))
[10:26:02.917]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:02.917]                       workers >= 1)
[10:26:02.917]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:02.917]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:02.917]                     }
[10:26:02.917]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:02.917]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:02.917]                       envir = envir)
[10:26:02.917]                     if (!future$lazy) 
[10:26:02.917]                       future <- run(future)
[10:26:02.917]                     invisible(future)
[10:26:02.917]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:02.917]                 }
[10:26:02.917]             }
[10:26:02.917]         }
[10:26:02.917]     })
[10:26:02.917]     if (TRUE) {
[10:26:02.917]         base::sink(type = "output", split = FALSE)
[10:26:02.917]         if (TRUE) {
[10:26:02.917]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:02.917]         }
[10:26:02.917]         else {
[10:26:02.917]             ...future.result["stdout"] <- base::list(NULL)
[10:26:02.917]         }
[10:26:02.917]         base::close(...future.stdout)
[10:26:02.917]         ...future.stdout <- NULL
[10:26:02.917]     }
[10:26:02.917]     ...future.result$conditions <- ...future.conditions
[10:26:02.917]     ...future.result$finished <- base::Sys.time()
[10:26:02.917]     ...future.result
[10:26:02.917] }
[10:26:02.919] assign_globals() ...
[10:26:02.919] List of 1
[10:26:02.919]  $ data:'data.frame':	5 obs. of  2 variables:
[10:26:02.919]   ..$ x: int [1:5] 1 2 3 4 5
[10:26:02.919]   ..$ y: int [1:5] 1 2 3 4 5
[10:26:02.919]  - attr(*, "where")=List of 1
[10:26:02.919]   ..$ data:<environment: R_EmptyEnv> 
[10:26:02.919]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:02.919]  - attr(*, "resolved")= logi FALSE
[10:26:02.919]  - attr(*, "total_size")= num 160
[10:26:02.919]  - attr(*, "already-done")= logi TRUE
[10:26:02.922] - copied ‘data’ to environment
[10:26:02.923] assign_globals() ... done
[10:26:02.923] plan(): Setting new future strategy stack:
[10:26:02.923] List of future strategies:
[10:26:02.923] 1. multisession:
[10:26:02.923]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:26:02.923]    - tweaked: FALSE
[10:26:02.923]    - call: plan(list(sequential, strategy))
[10:26:02.927] plan(): nbrOfWorkers() = 2
[10:26:03.385] plan(): Setting new future strategy stack:
[10:26:03.385] List of future strategies:
[10:26:03.385] 1. sequential:
[10:26:03.385]    - args: function (..., envir = parent.frame())
[10:26:03.385]    - tweaked: FALSE
[10:26:03.385]    - call: plan(list(sequential, strategy))
[10:26:03.385] 2. multisession:
[10:26:03.385]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:26:03.385]    - tweaked: FALSE
[10:26:03.385]    - call: plan(list(sequential, strategy))
[10:26:03.386] plan(): nbrOfWorkers() = 1
[10:26:03.386] SequentialFuture started (and completed)
[10:26:03.386] signalConditions() ...
[10:26:03.386]  - include = ‘immediateCondition’
[10:26:03.386]  - exclude = 
[10:26:03.387]  - resignal = FALSE
[10:26:03.387]  - Number of conditions: 93
[10:26:03.387] signalConditions() ... done
[10:26:03.387] - Launch lazy future ... done
[10:26:03.387] run() for ‘SequentialFuture’ ... done
[10:26:03.387] signalConditions() ...
[10:26:03.387]  - include = ‘immediateCondition’
[10:26:03.387]  - exclude = 
[10:26:03.387]  - resignal = FALSE
[10:26:03.387]  - Number of conditions: 93
[10:26:03.388] signalConditions() ... done
[10:26:03.388] Future state: ‘finished’
[10:26:03.388] signalConditions() ...
[10:26:03.388]  - include = ‘condition’
[10:26:03.388]  - exclude = ‘immediateCondition’
[10:26:03.388]  - resignal = TRUE
[10:26:03.388]  - Number of conditions: 93
[10:26:03.388]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.928] getGlobalsAndPackages() ...
[10:26:03.388]  - Condition #2: ‘deprecatedWarning’, ‘warning’, ‘condition’
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[10:26:03.389]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.942] Searching for globals...
[10:26:03.389]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.943] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[10:26:03.389]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.943] Searching for globals ... DONE
[10:26:03.389]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.943] Resolving globals: FALSE
[10:26:03.389]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.944] The total size of the 1 globals is 160 bytes (160 bytes)
[10:26:03.389]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.944] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 160 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (160 bytes of class ‘list’)
[10:26:03.389]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.944] - globals: [1] ‘data’
[10:26:03.389]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.944] 
[10:26:03.390]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.944] getGlobalsAndPackages() ... DONE
[10:26:03.390]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.945] run() for ‘Future’ ...
[10:26:03.390]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.945] - state: ‘created’
[10:26:03.390]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.945] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:03.390]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.948] [local output] makeClusterPSOCK() ...
[10:26:03.390]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.951] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:26:03.390]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.952] [local output] Base port: 11413
[10:26:03.391]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.952] [local output] Getting setup options for 2 cluster nodes ...
[10:26:03.391]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.952] [local output]  - Node 1 of 2 ...
[10:26:03.391]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.953] [local output] localMachine=TRUE => revtunnel=FALSE

[10:26:03.391]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.953] [local output] Rscript port: 11413

[10:26:03.391]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.954] [local output]  - Node 2 of 2 ...
[10:26:03.391]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.954] [local output] localMachine=TRUE => revtunnel=FALSE

[10:26:03.391]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.954] [local output] Rscript port: 11413

[10:26:03.391]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.955] [local output] Getting setup options for 2 cluster nodes ... done
[10:26:03.392]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.955] [local output]  - Parallel setup requested for some PSOCK nodes
[10:26:03.392]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.955] [local output] Setting up PSOCK nodes in parallel
[10:26:03.392]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.955] List of 36
[10:26:02.955]  $ worker          : chr "localhost"
[10:26:02.955]   ..- attr(*, "localhost")= logi TRUE
[10:26:02.955]  $ master          : chr "localhost"
[10:26:02.955]  $ port            : int 11413
[10:26:02.955]  $ connectTimeout  : num 120
[10:26:02.955]  $ timeout         : num 2592000
[10:26:02.955]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:26:02.955]  $ homogeneous     : logi TRUE
[10:26:02.955]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:26:02.955]  $ rscript_envs    : NULL
[10:26:02.955]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:26:02.955]  $ rscript_startup : NULL
[10:26:02.955]  $ rscript_sh      : chr "sh"
[10:26:02.955]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:26:02.955]  $ methods         : logi TRUE
[10:26:02.955]  $ socketOptions   : chr "no-delay"
[10:26:02.955]  $ useXDR          : logi FALSE
[10:26:02.955]  $ outfile         : chr "/dev/null"
[10:26:02.955]  $ renice          : int NA
[10:26:02.955]  $ rshcmd          : NULL
[10:26:02.955]  $ user            : chr(0) 
[10:26:02.955]  $ revtunnel       : logi FALSE
[10:26:02.955]  $ rshlogfile      : NULL
[10:26:02.955]  $ rshopts         : chr(0) 
[10:26:02.955]  $ rank            : int 1
[10:26:02.955]  $ manual          : logi FALSE
[10:26:02.955]  $ dryrun          : logi FALSE
[10:26:02.955]  $ quiet           : logi FALSE
[10:26:02.955]  $ setup_strategy  : chr "parallel"
[10:26:02.955]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:26:02.955]  $ pidfile         : chr "/tmp/Rtmp4gE0AX/worker.rank=1.parallelly.parent=85238.14cf63e6299d9.pid"
[10:26:02.955]  $ rshcmd_label    : NULL
[10:26:02.955]  $ rsh_call        : NULL
[10:26:02.955]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:26:02.955]  $ localMachine    : logi TRUE
[10:26:02.955]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:26:02.955]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:26:02.955]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:26:02.955]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:26:02.955]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:26:02.955]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:26:02.955]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:26:02.955]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:26:02.955]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:26:02.955]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:26:02.955]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:26:02.955]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:26:02.955]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:26:02.955]  $ arguments       :List of 28
[10:26:02.955]   ..$ worker          : chr "localhost"
[10:26:02.955]   ..$ master          : NULL
[10:26:02.955]   ..$ port            : int 11413
[10:26:02.955]   ..$ connectTimeout  : num 120
[10:26:02.955]   ..$ timeout         : num 2592000
[10:26:02.955]   ..$ rscript         : NULL
[10:26:02.955]   ..$ homogeneous     : NULL
[10:26:02.955]   ..$ rscript_args    : NULL
[10:26:02.955]   ..$ rscript_envs    : NULL
[10:26:02.955]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:26:02.955]   ..$ rscript_startup : NULL
[10:26:02.955]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:26:02.955]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:26:02.955]   ..$ methods         : logi TRUE
[10:26:02.955]   ..$ socketOptions   : chr "no-delay"
[10:26:02.955]   ..$ useXDR          : logi FALSE
[10:26:02.955]   ..$ outfile         : chr "/dev/null"
[10:26:02.955]   ..$ renice          : int NA
[10:26:02.955]   ..$ rshcmd          : NULL
[10:26:02.955]   ..$ user            : NULL
[10:26:02.955]   ..$ revtunnel       : logi NA
[10:26:02.955]   ..$ rshlogfile      : NULL
[10:26:02.955]   ..$ rshopts         : NULL
[10:26:02.955]   ..$ rank            : int 1
[10:26:02.955]   ..$ manual          : logi FALSE
[10:26:02.955]   ..$ dryrun          : logi FALSE
[10:26:02.955]   ..$ quiet           : logi FALSE
[10:26:02.955]   ..$ setup_strategy  : chr "parallel"
[10:26:02.955]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:26:03.392]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.972] [local output] System call to launch all workers:
[10:26:03.392]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.972] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp4gE0AX/worker.rank=1.parallelly.parent=85238.14cf63e6299d9.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11413 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:26:03.392]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.972] [local output] Starting PSOCK main server
[10:26:03.392]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.974] [local output] Workers launched
[10:26:03.392]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.974] [local output] Waiting for workers to connect back
[10:26:03.393]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:02.974]  - [local output] 0 workers out of 2 ready
[10:26:03.393]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.221]  - [local output] 0 workers out of 2 ready
[10:26:03.393]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.222]  - [local output] 0 workers out of 2 ready
[10:26:03.393]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.222]  - [local output] 1 workers out of 2 ready
[10:26:03.393]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.222]  - [local output] 2 workers out of 2 ready
[10:26:03.393]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.223] [local output] Launching of workers completed
[10:26:03.393]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.223] [local output] Collecting session information from workers
[10:26:03.394]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.223] [local output]  - Worker #1 of 2
[10:26:03.394]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.224] [local output]  - Worker #2 of 2
[10:26:03.394]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.224] [local output] makeClusterPSOCK() ... done
[10:26:03.394]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.234] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:03.394]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.235] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:03.394]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.235]   - Field: ‘node’
[10:26:03.394]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.235]   - Field: ‘label’
[10:26:03.394]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.235]   - Field: ‘local’
[10:26:03.395]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.235]   - Field: ‘owner’
[10:26:03.395]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.235]   - Field: ‘envir’
[10:26:03.395]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.235]   - Field: ‘workers’
[10:26:03.395]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.235]   - Field: ‘packages’
[10:26:03.395]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.235]   - Field: ‘gc’
[10:26:03.395]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.236]   - Field: ‘conditions’
[10:26:03.395]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.236]   - Field: ‘persistent’
[10:26:03.395]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.236]   - Field: ‘expr’
[10:26:03.396]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.236]   - Field: ‘uuid’
[10:26:03.396]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.236]   - Field: ‘seed’
[10:26:03.396]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.236]   - Field: ‘version’
[10:26:03.396]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.236]   - Field: ‘result’
[10:26:03.396]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.236]   - Field: ‘asynchronous’
[10:26:03.396]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.236]   - Field: ‘calls’
[10:26:03.396]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.237]   - Field: ‘globals’
[10:26:03.396]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.237]   - Field: ‘stdout’
[10:26:03.397]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.237]   - Field: ‘earlySignal’
[10:26:03.397]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.237]   - Field: ‘lazy’
[10:26:03.397]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.237]   - Field: ‘state’
[10:26:03.397]  - Condition #68: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.237] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:03.397]  - Condition #69: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.237] - Launch lazy future ...
[10:26:03.397]  - Condition #70: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.238] Packages needed by the future expression (n = 0): <none>
[10:26:03.397]  - Condition #71: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.238] Packages needed by future strategies (n = 0): <none>
[10:26:03.398]  - Condition #72: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.238] {
[10:26:03.238]     {
[10:26:03.238]         {
[10:26:03.238]             ...future.startTime <- base::Sys.time()
[10:26:03.238]             {
[10:26:03.238]                 {
[10:26:03.238]                   {
[10:26:03.238]                     {
[10:26:03.238]                       base::local({
[10:26:03.238]                         has_future <- base::requireNamespace("future", 
[10:26:03.238]                           quietly = TRUE)
[10:26:03.238]                         if (has_future) {
[10:26:03.238]                           ns <- base::getNamespace("future")
[10:26:03.238]                           version <- ns[[".package"]][["version"]]
[10:26:03.238]                           if (is.null(version)) 
[10:26:03.238]                             version <- utils::packageVersion("future")
[10:26:03.238]                         }
[10:26:03.238]                         else {
[10:26:03.238]                           version <- NULL
[10:26:03.238]                         }
[10:26:03.238]                         if (!has_future || version < "1.8.0") {
[10:26:03.238]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:03.238]                             "", base::R.version$version.string), 
[10:26:03.238]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:03.238]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:03.238]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:03.238]                               "release", "version")], collapse = " "), 
[10:26:03.238]                             hostname = base::Sys.info()[["nodename"]])
[10:26:03.238]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:03.238]                             info)
[10:26:03.238]                           info <- base::paste(info, collapse = "; ")
[10:26:03.238]                           if (!has_future) {
[10:26:03.238]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:03.238]                               info)
[10:26:03.238]                           }
[10:26:03.238]                           else {
[10:26:03.238]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:03.238]                               info, version)
[10:26:03.238]                           }
[10:26:03.238]                           base::stop(msg)
[10:26:03.238]                         }
[10:26:03.238]                       })
[10:26:03.238]                     }
[10:26:03.238]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:03.238]                     base::options(mc.cores = 1L)
[10:26:03.238]                   }
[10:26:03.238]                   options(future.plan = NULL)
[10:26:03.238]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:03.238]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:03.238]                 }
[10:26:03.238]                 ...future.workdir <- getwd()
[10:26:03.238]             }
[10:26:03.238]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:03.238]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:03.238]         }
[10:26:03.238]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[10:26:03.238]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:03.238]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[10:26:03.238]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:03.238]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:03.238]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:03.238]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:03.238]             base::names(...future.oldOptions))
[10:26:03.238]     }
[10:26:03.238]     if (FALSE) {
[10:26:03.238]     }
[10:26:03.238]     else {
[10:26:03.238]         if (TRUE) {
[10:26:03.238]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:03.238]                 open = "w")
[10:26:03.238]         }
[10:26:03.238]         else {
[10:26:03.238]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:03.238]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:03.238]         }
[10:26:03.238]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:03.238]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:03.238]             base::sink(type = "output", split = FALSE)
[10:26:03.238]             base::close(...future.stdout)
[10:26:03.238]         }, add = TRUE)
[10:26:03.238]     }
[10:26:03.238]     ...future.frame <- base::sys.nframe()
[10:26:03.238]     ...future.conditions <- base::list()
[10:26:03.238]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:03.238]     if (FALSE) {
[10:26:03.238]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:03.238]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:03.238]     }
[10:26:03.238]     ...future.result <- base::tryCatch({
[10:26:03.238]         base::withCallingHandlers({
[10:26:03.238]             ...future.value <- base::withVisible(base::local({
[10:26:03.238]                 ...future.makeSendCondition <- base::local({
[10:26:03.238]                   sendCondition <- NULL
[10:26:03.238]                   function(frame = 1L) {
[10:26:03.238]                     if (is.function(sendCondition)) 
[10:26:03.238]                       return(sendCondition)
[10:26:03.238]                     ns <- getNamespace("parallel")
[10:26:03.238]                     if (exists("sendData", mode = "function", 
[10:26:03.238]                       envir = ns)) {
[10:26:03.238]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:03.238]                         envir = ns)
[10:26:03.238]                       envir <- sys.frame(frame)
[10:26:03.238]                       master <- NULL
[10:26:03.238]                       while (!identical(envir, .GlobalEnv) && 
[10:26:03.238]                         !identical(envir, emptyenv())) {
[10:26:03.238]                         if (exists("master", mode = "list", envir = envir, 
[10:26:03.238]                           inherits = FALSE)) {
[10:26:03.238]                           master <- get("master", mode = "list", 
[10:26:03.238]                             envir = envir, inherits = FALSE)
[10:26:03.238]                           if (inherits(master, c("SOCKnode", 
[10:26:03.238]                             "SOCK0node"))) {
[10:26:03.238]                             sendCondition <<- function(cond) {
[10:26:03.238]                               data <- list(type = "VALUE", value = cond, 
[10:26:03.238]                                 success = TRUE)
[10:26:03.238]                               parallel_sendData(master, data)
[10:26:03.238]                             }
[10:26:03.238]                             return(sendCondition)
[10:26:03.238]                           }
[10:26:03.238]                         }
[10:26:03.238]                         frame <- frame + 1L
[10:26:03.238]                         envir <- sys.frame(frame)
[10:26:03.238]                       }
[10:26:03.238]                     }
[10:26:03.238]                     sendCondition <<- function(cond) NULL
[10:26:03.238]                   }
[10:26:03.238]                 })
[10:26:03.238]                 withCallingHandlers({
[10:26:03.238]                   subset(data, x < 3)$y
[10:26:03.238]                 }, immediateCondition = function(cond) {
[10:26:03.238]                   sendCondition <- ...future.makeSendCondition()
[10:26:03.238]                   sendCondition(cond)
[10:26:03.238]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:03.238]                   {
[10:26:03.238]                     inherits <- base::inherits
[10:26:03.238]                     invokeRestart <- base::invokeRestart
[10:26:03.238]                     is.null <- base::is.null
[10:26:03.238]                     muffled <- FALSE
[10:26:03.238]                     if (inherits(cond, "message")) {
[10:26:03.238]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:03.238]                       if (muffled) 
[10:26:03.238]                         invokeRestart("muffleMessage")
[10:26:03.238]                     }
[10:26:03.238]                     else if (inherits(cond, "warning")) {
[10:26:03.238]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:03.238]                       if (muffled) 
[10:26:03.238]                         invokeRestart("muffleWarning")
[10:26:03.238]                     }
[10:26:03.238]                     else if (inherits(cond, "condition")) {
[10:26:03.238]                       if (!is.null(pattern)) {
[10:26:03.238]                         computeRestarts <- base::computeRestarts
[10:26:03.238]                         grepl <- base::grepl
[10:26:03.238]                         restarts <- computeRestarts(cond)
[10:26:03.238]                         for (restart in restarts) {
[10:26:03.238]                           name <- restart$name
[10:26:03.238]                           if (is.null(name)) 
[10:26:03.238]                             next
[10:26:03.238]                           if (!grepl(pattern, name)) 
[10:26:03.238]                             next
[10:26:03.238]                           invokeRestart(restart)
[10:26:03.238]                           muffled <- TRUE
[10:26:03.238]                           break
[10:26:03.238]                         }
[10:26:03.238]                       }
[10:26:03.238]                     }
[10:26:03.238]                     invisible(muffled)
[10:26:03.238]                   }
[10:26:03.238]                   muffleCondition(cond)
[10:26:03.238]                 })
[10:26:03.238]             }))
[10:26:03.238]             future::FutureResult(value = ...future.value$value, 
[10:26:03.238]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:03.238]                   ...future.rng), globalenv = if (FALSE) 
[10:26:03.238]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:03.238]                     ...future.globalenv.names))
[10:26:03.238]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:03.238]         }, condition = base::local({
[10:26:03.238]             c <- base::c
[10:26:03.238]             inherits <- base::inherits
[10:26:03.238]             invokeRestart <- base::invokeRestart
[10:26:03.238]             length <- base::length
[10:26:03.238]             list <- base::list
[10:26:03.238]             seq.int <- base::seq.int
[10:26:03.238]             signalCondition <- base::signalCondition
[10:26:03.238]             sys.calls <- base::sys.calls
[10:26:03.238]             `[[` <- base::`[[`
[10:26:03.238]             `+` <- base::`+`
[10:26:03.238]             `<<-` <- base::`<<-`
[10:26:03.238]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:03.238]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:03.238]                   3L)]
[10:26:03.238]             }
[10:26:03.238]             function(cond) {
[10:26:03.238]                 is_error <- inherits(cond, "error")
[10:26:03.238]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:03.238]                   NULL)
[10:26:03.238]                 if (is_error) {
[10:26:03.238]                   sessionInformation <- function() {
[10:26:03.238]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:03.238]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:03.238]                       search = base::search(), system = base::Sys.info())
[10:26:03.238]                   }
[10:26:03.238]                   ...future.conditions[[length(...future.conditions) + 
[10:26:03.238]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:03.238]                     cond$call), session = sessionInformation(), 
[10:26:03.238]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:03.238]                   signalCondition(cond)
[10:26:03.238]                 }
[10:26:03.238]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:03.238]                 "immediateCondition"))) {
[10:26:03.238]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:03.238]                   ...future.conditions[[length(...future.conditions) + 
[10:26:03.238]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:03.238]                   if (TRUE && !signal) {
[10:26:03.238]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:03.238]                     {
[10:26:03.238]                       inherits <- base::inherits
[10:26:03.238]                       invokeRestart <- base::invokeRestart
[10:26:03.238]                       is.null <- base::is.null
[10:26:03.238]                       muffled <- FALSE
[10:26:03.238]                       if (inherits(cond, "message")) {
[10:26:03.238]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:03.238]                         if (muffled) 
[10:26:03.238]                           invokeRestart("muffleMessage")
[10:26:03.238]                       }
[10:26:03.238]                       else if (inherits(cond, "warning")) {
[10:26:03.238]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:03.238]                         if (muffled) 
[10:26:03.238]                           invokeRestart("muffleWarning")
[10:26:03.238]                       }
[10:26:03.238]                       else if (inherits(cond, "condition")) {
[10:26:03.238]                         if (!is.null(pattern)) {
[10:26:03.238]                           computeRestarts <- base::computeRestarts
[10:26:03.238]                           grepl <- base::grepl
[10:26:03.238]                           restarts <- computeRestarts(cond)
[10:26:03.238]                           for (restart in restarts) {
[10:26:03.238]                             name <- restart$name
[10:26:03.238]                             if (is.null(name)) 
[10:26:03.238]                               next
[10:26:03.238]                             if (!grepl(pattern, name)) 
[10:26:03.238]                               next
[10:26:03.238]                             invokeRestart(restart)
[10:26:03.238]                             muffled <- TRUE
[10:26:03.238]                             break
[10:26:03.238]                           }
[10:26:03.238]                         }
[10:26:03.238]                       }
[10:26:03.238]                       invisible(muffled)
[10:26:03.238]                     }
[10:26:03.238]                     muffleCondition(cond, pattern = "^muffle")
[10:26:03.238]                   }
[10:26:03.238]                 }
[10:26:03.238]                 else {
[10:26:03.238]                   if (TRUE) {
[10:26:03.238]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:03.238]                     {
[10:26:03.238]                       inherits <- base::inherits
[10:26:03.238]                       invokeRestart <- base::invokeRestart
[10:26:03.238]                       is.null <- base::is.null
[10:26:03.238]                       muffled <- FALSE
[10:26:03.238]                       if (inherits(cond, "message")) {
[10:26:03.238]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:03.238]                         if (muffled) 
[10:26:03.238]                           invokeRestart("muffleMessage")
[10:26:03.238]                       }
[10:26:03.238]                       else if (inherits(cond, "warning")) {
[10:26:03.238]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:03.238]                         if (muffled) 
[10:26:03.238]                           invokeRestart("muffleWarning")
[10:26:03.238]                       }
[10:26:03.238]                       else if (inherits(cond, "condition")) {
[10:26:03.238]                         if (!is.null(pattern)) {
[10:26:03.238]                           computeRestarts <- base::computeRestarts
[10:26:03.238]                           grepl <- base::grepl
[10:26:03.238]                           restarts <- computeRestarts(cond)
[10:26:03.238]                           for (restart in restarts) {
[10:26:03.238]                             name <- restart$name
[10:26:03.238]                             if (is.null(name)) 
[10:26:03.238]                               next
[10:26:03.238]                             if (!grepl(pattern, name)) 
[10:26:03.238]                               next
[10:26:03.238]                             invokeRestart(restart)
[10:26:03.238]                             muffled <- TRUE
[10:26:03.238]                             break
[10:26:03.238]                           }
[10:26:03.238]                         }
[10:26:03.238]                       }
[10:26:03.238]                       invisible(muffled)
[10:26:03.238]                     }
[10:26:03.238]                     muffleCondition(cond, pattern = "^muffle")
[10:26:03.238]                   }
[10:26:03.238]                 }
[10:26:03.238]             }
[10:26:03.238]         }))
[10:26:03.238]     }, error = function(ex) {
[10:26:03.238]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:03.238]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:03.238]                 ...future.rng), started = ...future.startTime, 
[10:26:03.238]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:03.238]             version = "1.8"), class = "FutureResult")
[10:26:03.238]     }, finally = {
[10:26:03.238]         if (!identical(...future.workdir, getwd())) 
[10:26:03.238]             setwd(...future.workdir)
[10:26:03.238]         {
[10:26:03.238]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:03.238]                 ...future.oldOptions$nwarnings <- NULL
[10:26:03.238]             }
[10:26:03.238]             base::options(...future.oldOptions)
[10:26:03.238]             if (.Platform$OS.type == "windows") {
[10:26:03.238]                 old_names <- names(...future.oldEnvVars)
[10:26:03.238]                 envs <- base::Sys.getenv()
[10:26:03.238]                 names <- names(envs)
[10:26:03.238]                 common <- intersect(names, old_names)
[10:26:03.238]                 added <- setdiff(names, old_names)
[10:26:03.238]                 removed <- setdiff(old_names, names)
[10:26:03.238]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:03.238]                   envs[common]]
[10:26:03.238]                 NAMES <- toupper(changed)
[10:26:03.238]                 args <- list()
[10:26:03.238]                 for (kk in seq_along(NAMES)) {
[10:26:03.238]                   name <- changed[[kk]]
[10:26:03.238]                   NAME <- NAMES[[kk]]
[10:26:03.238]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:03.238]                     next
[10:26:03.238]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:03.238]                 }
[10:26:03.238]                 NAMES <- toupper(added)
[10:26:03.238]                 for (kk in seq_along(NAMES)) {
[10:26:03.238]                   name <- added[[kk]]
[10:26:03.238]                   NAME <- NAMES[[kk]]
[10:26:03.238]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:03.238]                     next
[10:26:03.238]                   args[[name]] <- ""
[10:26:03.238]                 }
[10:26:03.238]                 NAMES <- toupper(removed)
[10:26:03.238]                 for (kk in seq_along(NAMES)) {
[10:26:03.238]                   name <- removed[[kk]]
[10:26:03.238]                   NAME <- NAMES[[kk]]
[10:26:03.238]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:03.238]                     next
[10:26:03.238]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:03.238]                 }
[10:26:03.238]                 if (length(args) > 0) 
[10:26:03.238]                   base::do.call(base::Sys.setenv, args = args)
[10:26:03.238]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:03.238]             }
[10:26:03.238]             else {
[10:26:03.238]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:03.238]             }
[10:26:03.238]             {
[10:26:03.238]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:03.238]                   0L) {
[10:26:03.238]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:03.238]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:03.238]                   base::options(opts)
[10:26:03.238]                 }
[10:26:03.238]                 {
[10:26:03.238]                   {
[10:26:03.238]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:03.238]                     NULL
[10:26:03.238]                   }
[10:26:03.238]                   options(future.plan = NULL)
[10:26:03.238]                   if (is.na(NA_character_)) 
[10:26:03.238]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:03.238]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:03.238]                   future::plan(list(function (..., workers = availableCores(), 
[10:26:03.238]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:03.238]                     envir = parent.frame()) 
[10:26:03.238]                   {
[10:26:03.238]                     if (is.function(workers)) 
[10:26:03.238]                       workers <- workers()
[10:26:03.238]                     workers <- structure(as.integer(workers), 
[10:26:03.238]                       class = class(workers))
[10:26:03.238]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:03.238]                       workers >= 1)
[10:26:03.238]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:03.238]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:03.238]                     }
[10:26:03.238]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:03.238]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:03.238]                       envir = envir)
[10:26:03.238]                     if (!future$lazy) 
[10:26:03.238]                       future <- run(future)
[10:26:03.238]                     invisible(future)
[10:26:03.238]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:03.238]                 }
[10:26:03.238]             }
[10:26:03.238]         }
[10:26:03.238]     })
[10:26:03.238]     if (TRUE) {
[10:26:03.238]         base::sink(type = "output", split = FALSE)
[10:26:03.238]         if (TRUE) {
[10:26:03.238]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:03.238]         }
[10:26:03.238]         else {
[10:26:03.238]             ...future.result["stdout"] <- base::list(NULL)
[10:26:03.238]         }
[10:26:03.238]         base::close(...future.stdout)
[10:26:03.238]         ...future.stdout <- NULL
[10:26:03.238]     }
[10:26:03.238]     ...future.result$conditions <- ...future.conditions
[10:26:03.238]     ...future.result$finished <- base::Sys.time()
[10:26:03.238]     ...future.result
[10:26:03.238] }
[10:26:03.398]  - Condition #73: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.291] Exporting 1 global objects (160 bytes) to cluster node #1 ...
[10:26:03.398]  - Condition #74: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.293] Exporting ‘data’ (160 bytes) to cluster node #1 ...
[10:26:03.398]  - Condition #75: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.294] Exporting ‘data’ (160 bytes) to cluster node #1 ... DONE
[10:26:03.398]  - Condition #76: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.294] Exporting 1 global objects (160 bytes) to cluster node #1 ... DONE
[10:26:03.398]  - Condition #77: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.295] MultisessionFuture started
[10:26:03.398]  - Condition #78: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.295] - Launch lazy future ... done
[10:26:03.398]  - Condition #79: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.295] run() for ‘MultisessionFuture’ ... done
[10:26:03.399]  - Condition #80: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.295] result() for ClusterFuture ...
[10:26:03.399]  - Condition #81: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.295] receiveMessageFromWorker() for ClusterFuture ...
[10:26:03.399]  - Condition #82: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.295] - Validating connection of MultisessionFuture
[10:26:03.399]  - Condition #83: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.383] - received message: FutureResult
[10:26:03.399]  - Condition #84: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.384] - Received FutureResult
[10:26:03.399]  - Condition #85: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.384] - Erased future from FutureRegistry
[10:26:03.399]  - Condition #86: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.384] result() for ClusterFuture ...
[10:26:03.400]  - Condition #87: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.384] - result already collected: FutureResult
[10:26:03.400]  - Condition #88: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.384] result() for ClusterFuture ... done
[10:26:03.400]  - Condition #89: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.384] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:03.400]  - Condition #90: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.384] result() for ClusterFuture ... done
[10:26:03.400]  - Condition #91: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.384] result() for ClusterFuture ...
[10:26:03.400]  - Condition #92: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.385] - result already collected: FutureResult
[10:26:03.400]  - Condition #93: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:03.385] result() for ClusterFuture ... done
[10:26:03.400] signalConditions() ... done
- Strategy: multisession ... DONE
> 
> 
> message("*** Globals w/ non-standard evaluation (NSE) ... DONE")
*** Globals w/ non-standard evaluation (NSE) ... DONE
> 
> source("incl/end.R")
[10:26:03.401] plan(): Setting new future strategy stack:
[10:26:03.401] List of future strategies:
[10:26:03.401] 1. FutureStrategy:
[10:26:03.401]    - args: function (..., envir = parent.frame())
[10:26:03.401]    - tweaked: FALSE
[10:26:03.401]    - call: future::plan(oplan)
[10:26:03.402] plan(): nbrOfWorkers() = 1
> 
