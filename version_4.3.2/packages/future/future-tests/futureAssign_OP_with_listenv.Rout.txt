
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[10:25:35.947] plan(): Setting new future strategy stack:
[10:25:35.948] List of future strategies:
[10:25:35.948] 1. sequential:
[10:25:35.948]    - args: function (..., envir = parent.frame())
[10:25:35.948]    - tweaked: FALSE
[10:25:35.948]    - call: future::plan("sequential")
[10:25:35.961] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> message("*** %<-% to listenv ...")
*** %<-% to listenv ...
> 
> ## - - - - - - - - - - - - - - - - - - - - - - - - - - - -
> ## Future assignment via infix operator
> ## - - - - - - - - - - - - - - - - - - - - - - - - - - - -
> z <- listenv()
> stopifnot(length(names(z)) == 0)
> 
> message("*** %<-% to listenv: Assign by index")
*** %<-% to listenv: Assign by index
> z[[1]] %<-% { 2 } %lazy% TRUE
[10:25:35.975] getGlobalsAndPackages() ...
[10:25:35.976] Searching for globals...
[10:25:35.979] - globals found: [1] ‘{’
[10:25:35.979] Searching for globals ... DONE
[10:25:35.979] Resolving globals: FALSE
[10:25:35.979] 
[10:25:35.980] 
[10:25:35.980] getGlobalsAndPackages() ... DONE
> stopifnot(length(z) == 1)
> stopifnot(length(names(z)) == 0)
> 
> z[[1]] %<-% { 2 } %lazy% TRUE
[10:25:35.980] getGlobalsAndPackages() ...
[10:25:35.981] Searching for globals...
[10:25:35.981] - globals found: [1] ‘{’
[10:25:35.981] Searching for globals ... DONE
[10:25:35.981] Resolving globals: FALSE
[10:25:35.982] 
[10:25:35.982] 
[10:25:35.982] getGlobalsAndPackages() ... DONE
> stopifnot(length(z) == 1)
> stopifnot(length(names(z)) == 0)
> 
> z[[4]] %<-% { "async!" } %lazy% TRUE
[10:25:35.982] getGlobalsAndPackages() ...
[10:25:35.982] Searching for globals...
[10:25:35.983] - globals found: [1] ‘{’
[10:25:35.983] Searching for globals ... DONE
[10:25:35.983] Resolving globals: FALSE
[10:25:35.983] 
[10:25:35.983] 
[10:25:35.984] getGlobalsAndPackages() ... DONE
> stopifnot(length(z) == 4)
> stopifnot(length(names(z)) == 0)
> 
> message("*** %<-% to listenv: Update names")
*** %<-% to listenv: Update names
> names(z) <- c("A", "B", "C", "D")
> stopifnot(identical(names(z), c("A", "B", "C", "D")))
> 
> 
> message("*** %<-% to listenv: Assign by name (existing)")
*** %<-% to listenv: Assign by name (existing)
> z$B %<-% { TRUE } %lazy% TRUE
[10:25:35.984] getGlobalsAndPackages() ...
[10:25:35.984] Searching for globals...
[10:25:35.985] - globals found: [1] ‘{’
[10:25:35.985] Searching for globals ... DONE
[10:25:35.985] Resolving globals: FALSE
[10:25:35.985] 
[10:25:35.986] 
[10:25:35.986] getGlobalsAndPackages() ... DONE
> stopifnot(length(z) == 4)
> stopifnot(identical(names(z), c("A", "B", "C", "D")))
> 
> y <- as.list(z)
[10:25:35.986] run() for ‘Future’ ...
[10:25:35.987] - state: ‘created’
[10:25:35.987] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:35.987] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:35.987] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:35.987]   - Field: ‘label’
[10:25:35.987]   - Field: ‘local’
[10:25:35.988]   - Field: ‘owner’
[10:25:35.988]   - Field: ‘envir’
[10:25:35.988]   - Field: ‘packages’
[10:25:35.988]   - Field: ‘gc’
[10:25:35.988]   - Field: ‘conditions’
[10:25:35.988]   - Field: ‘expr’
[10:25:35.988]   - Field: ‘uuid’
[10:25:35.988]   - Field: ‘seed’
[10:25:35.988]   - Field: ‘version’
[10:25:35.988]   - Field: ‘result’
[10:25:35.988]   - Field: ‘asynchronous’
[10:25:35.989]   - Field: ‘calls’
[10:25:35.989]   - Field: ‘globals’
[10:25:35.989]   - Field: ‘stdout’
[10:25:35.989]   - Field: ‘earlySignal’
[10:25:35.989]   - Field: ‘lazy’
[10:25:35.989]   - Field: ‘state’
[10:25:35.989] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:35.989] - Launch lazy future ...
[10:25:35.990] Packages needed by the future expression (n = 0): <none>
[10:25:35.990] Packages needed by future strategies (n = 0): <none>
[10:25:35.991] {
[10:25:35.991]     {
[10:25:35.991]         {
[10:25:35.991]             ...future.startTime <- base::Sys.time()
[10:25:35.991]             {
[10:25:35.991]                 {
[10:25:35.991]                   {
[10:25:35.991]                     base::local({
[10:25:35.991]                       has_future <- base::requireNamespace("future", 
[10:25:35.991]                         quietly = TRUE)
[10:25:35.991]                       if (has_future) {
[10:25:35.991]                         ns <- base::getNamespace("future")
[10:25:35.991]                         version <- ns[[".package"]][["version"]]
[10:25:35.991]                         if (is.null(version)) 
[10:25:35.991]                           version <- utils::packageVersion("future")
[10:25:35.991]                       }
[10:25:35.991]                       else {
[10:25:35.991]                         version <- NULL
[10:25:35.991]                       }
[10:25:35.991]                       if (!has_future || version < "1.8.0") {
[10:25:35.991]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:35.991]                           "", base::R.version$version.string), 
[10:25:35.991]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:35.991]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:35.991]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:35.991]                             "release", "version")], collapse = " "), 
[10:25:35.991]                           hostname = base::Sys.info()[["nodename"]])
[10:25:35.991]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:35.991]                           info)
[10:25:35.991]                         info <- base::paste(info, collapse = "; ")
[10:25:35.991]                         if (!has_future) {
[10:25:35.991]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:35.991]                             info)
[10:25:35.991]                         }
[10:25:35.991]                         else {
[10:25:35.991]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:35.991]                             info, version)
[10:25:35.991]                         }
[10:25:35.991]                         base::stop(msg)
[10:25:35.991]                       }
[10:25:35.991]                     })
[10:25:35.991]                   }
[10:25:35.991]                   options(future.plan = NULL)
[10:25:35.991]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:35.991]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:35.991]                 }
[10:25:35.991]                 ...future.workdir <- getwd()
[10:25:35.991]             }
[10:25:35.991]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:35.991]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:35.991]         }
[10:25:35.991]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:35.991]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:35.991]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:35.991]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:35.991]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:35.991]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:35.991]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:35.991]             base::names(...future.oldOptions))
[10:25:35.991]     }
[10:25:35.991]     if (FALSE) {
[10:25:35.991]     }
[10:25:35.991]     else {
[10:25:35.991]         if (TRUE) {
[10:25:35.991]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:35.991]                 open = "w")
[10:25:35.991]         }
[10:25:35.991]         else {
[10:25:35.991]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:35.991]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:35.991]         }
[10:25:35.991]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:35.991]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:35.991]             base::sink(type = "output", split = FALSE)
[10:25:35.991]             base::close(...future.stdout)
[10:25:35.991]         }, add = TRUE)
[10:25:35.991]     }
[10:25:35.991]     ...future.frame <- base::sys.nframe()
[10:25:35.991]     ...future.conditions <- base::list()
[10:25:35.991]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:35.991]     if (FALSE) {
[10:25:35.991]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:35.991]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:35.991]     }
[10:25:35.991]     ...future.result <- base::tryCatch({
[10:25:35.991]         base::withCallingHandlers({
[10:25:35.991]             ...future.value <- base::withVisible(base::local({
[10:25:35.991]                 2
[10:25:35.991]             }))
[10:25:35.991]             future::FutureResult(value = ...future.value$value, 
[10:25:35.991]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:35.991]                   ...future.rng), globalenv = if (FALSE) 
[10:25:35.991]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:35.991]                     ...future.globalenv.names))
[10:25:35.991]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:35.991]         }, condition = base::local({
[10:25:35.991]             c <- base::c
[10:25:35.991]             inherits <- base::inherits
[10:25:35.991]             invokeRestart <- base::invokeRestart
[10:25:35.991]             length <- base::length
[10:25:35.991]             list <- base::list
[10:25:35.991]             seq.int <- base::seq.int
[10:25:35.991]             signalCondition <- base::signalCondition
[10:25:35.991]             sys.calls <- base::sys.calls
[10:25:35.991]             `[[` <- base::`[[`
[10:25:35.991]             `+` <- base::`+`
[10:25:35.991]             `<<-` <- base::`<<-`
[10:25:35.991]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:35.991]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:35.991]                   3L)]
[10:25:35.991]             }
[10:25:35.991]             function(cond) {
[10:25:35.991]                 is_error <- inherits(cond, "error")
[10:25:35.991]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:35.991]                   NULL)
[10:25:35.991]                 if (is_error) {
[10:25:35.991]                   sessionInformation <- function() {
[10:25:35.991]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:35.991]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:35.991]                       search = base::search(), system = base::Sys.info())
[10:25:35.991]                   }
[10:25:35.991]                   ...future.conditions[[length(...future.conditions) + 
[10:25:35.991]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:35.991]                     cond$call), session = sessionInformation(), 
[10:25:35.991]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:35.991]                   signalCondition(cond)
[10:25:35.991]                 }
[10:25:35.991]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:35.991]                 "immediateCondition"))) {
[10:25:35.991]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:35.991]                   ...future.conditions[[length(...future.conditions) + 
[10:25:35.991]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:35.991]                   if (TRUE && !signal) {
[10:25:35.991]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:35.991]                     {
[10:25:35.991]                       inherits <- base::inherits
[10:25:35.991]                       invokeRestart <- base::invokeRestart
[10:25:35.991]                       is.null <- base::is.null
[10:25:35.991]                       muffled <- FALSE
[10:25:35.991]                       if (inherits(cond, "message")) {
[10:25:35.991]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:35.991]                         if (muffled) 
[10:25:35.991]                           invokeRestart("muffleMessage")
[10:25:35.991]                       }
[10:25:35.991]                       else if (inherits(cond, "warning")) {
[10:25:35.991]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:35.991]                         if (muffled) 
[10:25:35.991]                           invokeRestart("muffleWarning")
[10:25:35.991]                       }
[10:25:35.991]                       else if (inherits(cond, "condition")) {
[10:25:35.991]                         if (!is.null(pattern)) {
[10:25:35.991]                           computeRestarts <- base::computeRestarts
[10:25:35.991]                           grepl <- base::grepl
[10:25:35.991]                           restarts <- computeRestarts(cond)
[10:25:35.991]                           for (restart in restarts) {
[10:25:35.991]                             name <- restart$name
[10:25:35.991]                             if (is.null(name)) 
[10:25:35.991]                               next
[10:25:35.991]                             if (!grepl(pattern, name)) 
[10:25:35.991]                               next
[10:25:35.991]                             invokeRestart(restart)
[10:25:35.991]                             muffled <- TRUE
[10:25:35.991]                             break
[10:25:35.991]                           }
[10:25:35.991]                         }
[10:25:35.991]                       }
[10:25:35.991]                       invisible(muffled)
[10:25:35.991]                     }
[10:25:35.991]                     muffleCondition(cond, pattern = "^muffle")
[10:25:35.991]                   }
[10:25:35.991]                 }
[10:25:35.991]                 else {
[10:25:35.991]                   if (TRUE) {
[10:25:35.991]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:35.991]                     {
[10:25:35.991]                       inherits <- base::inherits
[10:25:35.991]                       invokeRestart <- base::invokeRestart
[10:25:35.991]                       is.null <- base::is.null
[10:25:35.991]                       muffled <- FALSE
[10:25:35.991]                       if (inherits(cond, "message")) {
[10:25:35.991]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:35.991]                         if (muffled) 
[10:25:35.991]                           invokeRestart("muffleMessage")
[10:25:35.991]                       }
[10:25:35.991]                       else if (inherits(cond, "warning")) {
[10:25:35.991]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:35.991]                         if (muffled) 
[10:25:35.991]                           invokeRestart("muffleWarning")
[10:25:35.991]                       }
[10:25:35.991]                       else if (inherits(cond, "condition")) {
[10:25:35.991]                         if (!is.null(pattern)) {
[10:25:35.991]                           computeRestarts <- base::computeRestarts
[10:25:35.991]                           grepl <- base::grepl
[10:25:35.991]                           restarts <- computeRestarts(cond)
[10:25:35.991]                           for (restart in restarts) {
[10:25:35.991]                             name <- restart$name
[10:25:35.991]                             if (is.null(name)) 
[10:25:35.991]                               next
[10:25:35.991]                             if (!grepl(pattern, name)) 
[10:25:35.991]                               next
[10:25:35.991]                             invokeRestart(restart)
[10:25:35.991]                             muffled <- TRUE
[10:25:35.991]                             break
[10:25:35.991]                           }
[10:25:35.991]                         }
[10:25:35.991]                       }
[10:25:35.991]                       invisible(muffled)
[10:25:35.991]                     }
[10:25:35.991]                     muffleCondition(cond, pattern = "^muffle")
[10:25:35.991]                   }
[10:25:35.991]                 }
[10:25:35.991]             }
[10:25:35.991]         }))
[10:25:35.991]     }, error = function(ex) {
[10:25:35.991]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:35.991]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:35.991]                 ...future.rng), started = ...future.startTime, 
[10:25:35.991]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:35.991]             version = "1.8"), class = "FutureResult")
[10:25:35.991]     }, finally = {
[10:25:35.991]         if (!identical(...future.workdir, getwd())) 
[10:25:35.991]             setwd(...future.workdir)
[10:25:35.991]         {
[10:25:35.991]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:35.991]                 ...future.oldOptions$nwarnings <- NULL
[10:25:35.991]             }
[10:25:35.991]             base::options(...future.oldOptions)
[10:25:35.991]             if (.Platform$OS.type == "windows") {
[10:25:35.991]                 old_names <- names(...future.oldEnvVars)
[10:25:35.991]                 envs <- base::Sys.getenv()
[10:25:35.991]                 names <- names(envs)
[10:25:35.991]                 common <- intersect(names, old_names)
[10:25:35.991]                 added <- setdiff(names, old_names)
[10:25:35.991]                 removed <- setdiff(old_names, names)
[10:25:35.991]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:35.991]                   envs[common]]
[10:25:35.991]                 NAMES <- toupper(changed)
[10:25:35.991]                 args <- list()
[10:25:35.991]                 for (kk in seq_along(NAMES)) {
[10:25:35.991]                   name <- changed[[kk]]
[10:25:35.991]                   NAME <- NAMES[[kk]]
[10:25:35.991]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:35.991]                     next
[10:25:35.991]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:35.991]                 }
[10:25:35.991]                 NAMES <- toupper(added)
[10:25:35.991]                 for (kk in seq_along(NAMES)) {
[10:25:35.991]                   name <- added[[kk]]
[10:25:35.991]                   NAME <- NAMES[[kk]]
[10:25:35.991]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:35.991]                     next
[10:25:35.991]                   args[[name]] <- ""
[10:25:35.991]                 }
[10:25:35.991]                 NAMES <- toupper(removed)
[10:25:35.991]                 for (kk in seq_along(NAMES)) {
[10:25:35.991]                   name <- removed[[kk]]
[10:25:35.991]                   NAME <- NAMES[[kk]]
[10:25:35.991]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:35.991]                     next
[10:25:35.991]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:35.991]                 }
[10:25:35.991]                 if (length(args) > 0) 
[10:25:35.991]                   base::do.call(base::Sys.setenv, args = args)
[10:25:35.991]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:35.991]             }
[10:25:35.991]             else {
[10:25:35.991]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:35.991]             }
[10:25:35.991]             {
[10:25:35.991]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:35.991]                   0L) {
[10:25:35.991]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:35.991]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:35.991]                   base::options(opts)
[10:25:35.991]                 }
[10:25:35.991]                 {
[10:25:35.991]                   {
[10:25:35.991]                     NULL
[10:25:35.991]                     RNGkind("Mersenne-Twister")
[10:25:35.991]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:35.991]                       inherits = FALSE)
[10:25:35.991]                   }
[10:25:35.991]                   options(future.plan = NULL)
[10:25:35.991]                   if (is.na(NA_character_)) 
[10:25:35.991]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:35.991]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:35.991]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:35.991]                   {
[10:25:35.991]                     future <- SequentialFuture(..., envir = envir)
[10:25:35.991]                     if (!future$lazy) 
[10:25:35.991]                       future <- run(future)
[10:25:35.991]                     invisible(future)
[10:25:35.991]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:35.991]                 }
[10:25:35.991]             }
[10:25:35.991]         }
[10:25:35.991]     })
[10:25:35.991]     if (TRUE) {
[10:25:35.991]         base::sink(type = "output", split = FALSE)
[10:25:35.991]         if (TRUE) {
[10:25:35.991]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:35.991]         }
[10:25:35.991]         else {
[10:25:35.991]             ...future.result["stdout"] <- base::list(NULL)
[10:25:35.991]         }
[10:25:35.991]         base::close(...future.stdout)
[10:25:35.991]         ...future.stdout <- NULL
[10:25:35.991]     }
[10:25:35.991]     ...future.result$conditions <- ...future.conditions
[10:25:35.991]     ...future.result$finished <- base::Sys.time()
[10:25:35.991]     ...future.result
[10:25:35.991] }
[10:25:35.993] plan(): Setting new future strategy stack:
[10:25:35.993] List of future strategies:
[10:25:35.993] 1. sequential:
[10:25:35.993]    - args: function (..., envir = parent.frame())
[10:25:35.993]    - tweaked: FALSE
[10:25:35.993]    - call: NULL
[10:25:35.993] plan(): nbrOfWorkers() = 1
[10:25:35.994] plan(): Setting new future strategy stack:
[10:25:35.995] List of future strategies:
[10:25:35.995] 1. sequential:
[10:25:35.995]    - args: function (..., envir = parent.frame())
[10:25:35.995]    - tweaked: FALSE
[10:25:35.995]    - call: future::plan("sequential")
[10:25:35.995] plan(): nbrOfWorkers() = 1
[10:25:35.995] SequentialFuture started (and completed)
[10:25:35.996] - Launch lazy future ... done
[10:25:35.996] run() for ‘SequentialFuture’ ... done
[10:25:35.996] run() for ‘Future’ ...
[10:25:35.996] - state: ‘created’
[10:25:35.996] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:35.996] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:35.996] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:35.997]   - Field: ‘label’
[10:25:35.997]   - Field: ‘local’
[10:25:35.997]   - Field: ‘owner’
[10:25:35.997]   - Field: ‘envir’
[10:25:35.997]   - Field: ‘packages’
[10:25:35.997]   - Field: ‘gc’
[10:25:35.997]   - Field: ‘conditions’
[10:25:35.997]   - Field: ‘expr’
[10:25:35.997]   - Field: ‘uuid’
[10:25:35.997]   - Field: ‘seed’
[10:25:35.998]   - Field: ‘version’
[10:25:35.998]   - Field: ‘result’
[10:25:35.998]   - Field: ‘asynchronous’
[10:25:35.998]   - Field: ‘calls’
[10:25:35.998]   - Field: ‘globals’
[10:25:35.998]   - Field: ‘stdout’
[10:25:35.998]   - Field: ‘earlySignal’
[10:25:35.998]   - Field: ‘lazy’
[10:25:35.998]   - Field: ‘state’
[10:25:35.998] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:35.998] - Launch lazy future ...
[10:25:35.999] Packages needed by the future expression (n = 0): <none>
[10:25:35.999] Packages needed by future strategies (n = 0): <none>
[10:25:35.999] {
[10:25:35.999]     {
[10:25:35.999]         {
[10:25:35.999]             ...future.startTime <- base::Sys.time()
[10:25:35.999]             {
[10:25:35.999]                 {
[10:25:35.999]                   {
[10:25:35.999]                     base::local({
[10:25:35.999]                       has_future <- base::requireNamespace("future", 
[10:25:35.999]                         quietly = TRUE)
[10:25:35.999]                       if (has_future) {
[10:25:35.999]                         ns <- base::getNamespace("future")
[10:25:35.999]                         version <- ns[[".package"]][["version"]]
[10:25:35.999]                         if (is.null(version)) 
[10:25:35.999]                           version <- utils::packageVersion("future")
[10:25:35.999]                       }
[10:25:35.999]                       else {
[10:25:35.999]                         version <- NULL
[10:25:35.999]                       }
[10:25:35.999]                       if (!has_future || version < "1.8.0") {
[10:25:35.999]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:35.999]                           "", base::R.version$version.string), 
[10:25:35.999]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:35.999]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:35.999]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:35.999]                             "release", "version")], collapse = " "), 
[10:25:35.999]                           hostname = base::Sys.info()[["nodename"]])
[10:25:35.999]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:35.999]                           info)
[10:25:35.999]                         info <- base::paste(info, collapse = "; ")
[10:25:35.999]                         if (!has_future) {
[10:25:35.999]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:35.999]                             info)
[10:25:35.999]                         }
[10:25:35.999]                         else {
[10:25:35.999]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:35.999]                             info, version)
[10:25:35.999]                         }
[10:25:35.999]                         base::stop(msg)
[10:25:35.999]                       }
[10:25:35.999]                     })
[10:25:35.999]                   }
[10:25:35.999]                   options(future.plan = NULL)
[10:25:35.999]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:35.999]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:35.999]                 }
[10:25:35.999]                 ...future.workdir <- getwd()
[10:25:35.999]             }
[10:25:35.999]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:35.999]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:35.999]         }
[10:25:35.999]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:35.999]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:35.999]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:35.999]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:35.999]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:35.999]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:35.999]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:35.999]             base::names(...future.oldOptions))
[10:25:35.999]     }
[10:25:35.999]     if (FALSE) {
[10:25:35.999]     }
[10:25:35.999]     else {
[10:25:35.999]         if (TRUE) {
[10:25:35.999]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:35.999]                 open = "w")
[10:25:35.999]         }
[10:25:35.999]         else {
[10:25:35.999]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:35.999]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:35.999]         }
[10:25:35.999]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:35.999]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:35.999]             base::sink(type = "output", split = FALSE)
[10:25:35.999]             base::close(...future.stdout)
[10:25:35.999]         }, add = TRUE)
[10:25:35.999]     }
[10:25:35.999]     ...future.frame <- base::sys.nframe()
[10:25:35.999]     ...future.conditions <- base::list()
[10:25:35.999]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:35.999]     if (FALSE) {
[10:25:35.999]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:35.999]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:35.999]     }
[10:25:35.999]     ...future.result <- base::tryCatch({
[10:25:35.999]         base::withCallingHandlers({
[10:25:35.999]             ...future.value <- base::withVisible(base::local({
[10:25:35.999]                 "async!"
[10:25:35.999]             }))
[10:25:35.999]             future::FutureResult(value = ...future.value$value, 
[10:25:35.999]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:35.999]                   ...future.rng), globalenv = if (FALSE) 
[10:25:35.999]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:35.999]                     ...future.globalenv.names))
[10:25:35.999]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:35.999]         }, condition = base::local({
[10:25:35.999]             c <- base::c
[10:25:35.999]             inherits <- base::inherits
[10:25:35.999]             invokeRestart <- base::invokeRestart
[10:25:35.999]             length <- base::length
[10:25:35.999]             list <- base::list
[10:25:35.999]             seq.int <- base::seq.int
[10:25:35.999]             signalCondition <- base::signalCondition
[10:25:35.999]             sys.calls <- base::sys.calls
[10:25:35.999]             `[[` <- base::`[[`
[10:25:35.999]             `+` <- base::`+`
[10:25:35.999]             `<<-` <- base::`<<-`
[10:25:35.999]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:35.999]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:35.999]                   3L)]
[10:25:35.999]             }
[10:25:35.999]             function(cond) {
[10:25:35.999]                 is_error <- inherits(cond, "error")
[10:25:35.999]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:35.999]                   NULL)
[10:25:35.999]                 if (is_error) {
[10:25:35.999]                   sessionInformation <- function() {
[10:25:35.999]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:35.999]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:35.999]                       search = base::search(), system = base::Sys.info())
[10:25:35.999]                   }
[10:25:35.999]                   ...future.conditions[[length(...future.conditions) + 
[10:25:35.999]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:35.999]                     cond$call), session = sessionInformation(), 
[10:25:35.999]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:35.999]                   signalCondition(cond)
[10:25:35.999]                 }
[10:25:35.999]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:35.999]                 "immediateCondition"))) {
[10:25:35.999]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:35.999]                   ...future.conditions[[length(...future.conditions) + 
[10:25:35.999]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:35.999]                   if (TRUE && !signal) {
[10:25:35.999]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:35.999]                     {
[10:25:35.999]                       inherits <- base::inherits
[10:25:35.999]                       invokeRestart <- base::invokeRestart
[10:25:35.999]                       is.null <- base::is.null
[10:25:35.999]                       muffled <- FALSE
[10:25:35.999]                       if (inherits(cond, "message")) {
[10:25:35.999]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:35.999]                         if (muffled) 
[10:25:35.999]                           invokeRestart("muffleMessage")
[10:25:35.999]                       }
[10:25:35.999]                       else if (inherits(cond, "warning")) {
[10:25:35.999]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:35.999]                         if (muffled) 
[10:25:35.999]                           invokeRestart("muffleWarning")
[10:25:35.999]                       }
[10:25:35.999]                       else if (inherits(cond, "condition")) {
[10:25:35.999]                         if (!is.null(pattern)) {
[10:25:35.999]                           computeRestarts <- base::computeRestarts
[10:25:35.999]                           grepl <- base::grepl
[10:25:35.999]                           restarts <- computeRestarts(cond)
[10:25:35.999]                           for (restart in restarts) {
[10:25:35.999]                             name <- restart$name
[10:25:35.999]                             if (is.null(name)) 
[10:25:35.999]                               next
[10:25:35.999]                             if (!grepl(pattern, name)) 
[10:25:35.999]                               next
[10:25:35.999]                             invokeRestart(restart)
[10:25:35.999]                             muffled <- TRUE
[10:25:35.999]                             break
[10:25:35.999]                           }
[10:25:35.999]                         }
[10:25:35.999]                       }
[10:25:35.999]                       invisible(muffled)
[10:25:35.999]                     }
[10:25:35.999]                     muffleCondition(cond, pattern = "^muffle")
[10:25:35.999]                   }
[10:25:35.999]                 }
[10:25:35.999]                 else {
[10:25:35.999]                   if (TRUE) {
[10:25:35.999]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:35.999]                     {
[10:25:35.999]                       inherits <- base::inherits
[10:25:35.999]                       invokeRestart <- base::invokeRestart
[10:25:35.999]                       is.null <- base::is.null
[10:25:35.999]                       muffled <- FALSE
[10:25:35.999]                       if (inherits(cond, "message")) {
[10:25:35.999]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:35.999]                         if (muffled) 
[10:25:35.999]                           invokeRestart("muffleMessage")
[10:25:35.999]                       }
[10:25:35.999]                       else if (inherits(cond, "warning")) {
[10:25:35.999]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:35.999]                         if (muffled) 
[10:25:35.999]                           invokeRestart("muffleWarning")
[10:25:35.999]                       }
[10:25:35.999]                       else if (inherits(cond, "condition")) {
[10:25:35.999]                         if (!is.null(pattern)) {
[10:25:35.999]                           computeRestarts <- base::computeRestarts
[10:25:35.999]                           grepl <- base::grepl
[10:25:35.999]                           restarts <- computeRestarts(cond)
[10:25:35.999]                           for (restart in restarts) {
[10:25:35.999]                             name <- restart$name
[10:25:35.999]                             if (is.null(name)) 
[10:25:35.999]                               next
[10:25:35.999]                             if (!grepl(pattern, name)) 
[10:25:35.999]                               next
[10:25:35.999]                             invokeRestart(restart)
[10:25:35.999]                             muffled <- TRUE
[10:25:35.999]                             break
[10:25:35.999]                           }
[10:25:35.999]                         }
[10:25:35.999]                       }
[10:25:35.999]                       invisible(muffled)
[10:25:35.999]                     }
[10:25:35.999]                     muffleCondition(cond, pattern = "^muffle")
[10:25:35.999]                   }
[10:25:35.999]                 }
[10:25:35.999]             }
[10:25:35.999]         }))
[10:25:35.999]     }, error = function(ex) {
[10:25:35.999]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:35.999]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:35.999]                 ...future.rng), started = ...future.startTime, 
[10:25:35.999]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:35.999]             version = "1.8"), class = "FutureResult")
[10:25:35.999]     }, finally = {
[10:25:35.999]         if (!identical(...future.workdir, getwd())) 
[10:25:35.999]             setwd(...future.workdir)
[10:25:35.999]         {
[10:25:35.999]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:35.999]                 ...future.oldOptions$nwarnings <- NULL
[10:25:35.999]             }
[10:25:35.999]             base::options(...future.oldOptions)
[10:25:35.999]             if (.Platform$OS.type == "windows") {
[10:25:35.999]                 old_names <- names(...future.oldEnvVars)
[10:25:35.999]                 envs <- base::Sys.getenv()
[10:25:35.999]                 names <- names(envs)
[10:25:35.999]                 common <- intersect(names, old_names)
[10:25:35.999]                 added <- setdiff(names, old_names)
[10:25:35.999]                 removed <- setdiff(old_names, names)
[10:25:35.999]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:35.999]                   envs[common]]
[10:25:35.999]                 NAMES <- toupper(changed)
[10:25:35.999]                 args <- list()
[10:25:35.999]                 for (kk in seq_along(NAMES)) {
[10:25:35.999]                   name <- changed[[kk]]
[10:25:35.999]                   NAME <- NAMES[[kk]]
[10:25:35.999]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:35.999]                     next
[10:25:35.999]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:35.999]                 }
[10:25:35.999]                 NAMES <- toupper(added)
[10:25:35.999]                 for (kk in seq_along(NAMES)) {
[10:25:35.999]                   name <- added[[kk]]
[10:25:35.999]                   NAME <- NAMES[[kk]]
[10:25:35.999]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:35.999]                     next
[10:25:35.999]                   args[[name]] <- ""
[10:25:35.999]                 }
[10:25:35.999]                 NAMES <- toupper(removed)
[10:25:35.999]                 for (kk in seq_along(NAMES)) {
[10:25:35.999]                   name <- removed[[kk]]
[10:25:35.999]                   NAME <- NAMES[[kk]]
[10:25:35.999]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:35.999]                     next
[10:25:35.999]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:35.999]                 }
[10:25:35.999]                 if (length(args) > 0) 
[10:25:35.999]                   base::do.call(base::Sys.setenv, args = args)
[10:25:35.999]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:35.999]             }
[10:25:35.999]             else {
[10:25:35.999]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:35.999]             }
[10:25:35.999]             {
[10:25:35.999]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:35.999]                   0L) {
[10:25:35.999]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:35.999]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:35.999]                   base::options(opts)
[10:25:35.999]                 }
[10:25:35.999]                 {
[10:25:35.999]                   {
[10:25:35.999]                     NULL
[10:25:35.999]                     RNGkind("Mersenne-Twister")
[10:25:35.999]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:35.999]                       inherits = FALSE)
[10:25:35.999]                   }
[10:25:35.999]                   options(future.plan = NULL)
[10:25:35.999]                   if (is.na(NA_character_)) 
[10:25:35.999]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:35.999]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:35.999]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:35.999]                   {
[10:25:35.999]                     future <- SequentialFuture(..., envir = envir)
[10:25:35.999]                     if (!future$lazy) 
[10:25:35.999]                       future <- run(future)
[10:25:35.999]                     invisible(future)
[10:25:35.999]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:35.999]                 }
[10:25:35.999]             }
[10:25:35.999]         }
[10:25:35.999]     })
[10:25:35.999]     if (TRUE) {
[10:25:35.999]         base::sink(type = "output", split = FALSE)
[10:25:35.999]         if (TRUE) {
[10:25:35.999]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:35.999]         }
[10:25:35.999]         else {
[10:25:35.999]             ...future.result["stdout"] <- base::list(NULL)
[10:25:35.999]         }
[10:25:35.999]         base::close(...future.stdout)
[10:25:35.999]         ...future.stdout <- NULL
[10:25:35.999]     }
[10:25:35.999]     ...future.result$conditions <- ...future.conditions
[10:25:35.999]     ...future.result$finished <- base::Sys.time()
[10:25:35.999]     ...future.result
[10:25:35.999] }
[10:25:36.001] plan(): Setting new future strategy stack:
[10:25:36.001] List of future strategies:
[10:25:36.001] 1. sequential:
[10:25:36.001]    - args: function (..., envir = parent.frame())
[10:25:36.001]    - tweaked: FALSE
[10:25:36.001]    - call: NULL
[10:25:36.001] plan(): nbrOfWorkers() = 1
[10:25:36.002] plan(): Setting new future strategy stack:
[10:25:36.002] List of future strategies:
[10:25:36.002] 1. sequential:
[10:25:36.002]    - args: function (..., envir = parent.frame())
[10:25:36.002]    - tweaked: FALSE
[10:25:36.002]    - call: future::plan("sequential")
[10:25:36.002] plan(): nbrOfWorkers() = 1
[10:25:36.003] SequentialFuture started (and completed)
[10:25:36.003] - Launch lazy future ... done
[10:25:36.003] run() for ‘SequentialFuture’ ... done
> str(y)
List of 4
 $ A: num 2
 $ B: NULL
 $ C: NULL
 $ D: chr "async!"
> stopifnot(length(y) == 4)
> stopifnot(identical(names(y), c("A", "B", "C", "D")))
> 
> 
> message("*** %<-% to listenv: Asserting no name clashes among futures")
*** %<-% to listenv: Asserting no name clashes among futures
> u <- listenv()
> u$a %<-% { 1 } %lazy% TRUE
[10:25:36.007] getGlobalsAndPackages() ...
[10:25:36.007] Searching for globals...
[10:25:36.008] - globals found: [1] ‘{’
[10:25:36.008] Searching for globals ... DONE
[10:25:36.008] Resolving globals: FALSE
[10:25:36.008] 
[10:25:36.008] 
[10:25:36.009] getGlobalsAndPackages() ... DONE
> stopifnot(identical(names(u), "a"))
> fu <- futureOf(u$a)
> 
> v <- listenv()
> v$a %<-% { 2 } %lazy% TRUE
[10:25:36.012] getGlobalsAndPackages() ...
[10:25:36.012] Searching for globals...
[10:25:36.012] - globals found: [1] ‘{’
[10:25:36.012] Searching for globals ... DONE
[10:25:36.013] Resolving globals: FALSE
[10:25:36.013] 
[10:25:36.013] 
[10:25:36.013] getGlobalsAndPackages() ... DONE
> stopifnot(identical(names(v), "a"))
> fv <- futureOf(v$a)
> stopifnot(!identical(fu, fv))
> 
> fu <- futureOf(u$a)
> stopifnot(!identical(fu, fv))
> 
> stopifnot(identical(u$a, 1))
[10:25:36.014] run() for ‘Future’ ...
[10:25:36.014] - state: ‘created’
[10:25:36.014] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:36.014] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:36.014] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:36.014]   - Field: ‘label’
[10:25:36.015]   - Field: ‘local’
[10:25:36.015]   - Field: ‘owner’
[10:25:36.015]   - Field: ‘envir’
[10:25:36.015]   - Field: ‘packages’
[10:25:36.015]   - Field: ‘gc’
[10:25:36.015]   - Field: ‘conditions’
[10:25:36.015]   - Field: ‘expr’
[10:25:36.015]   - Field: ‘uuid’
[10:25:36.015]   - Field: ‘seed’
[10:25:36.015]   - Field: ‘version’
[10:25:36.015]   - Field: ‘result’
[10:25:36.016]   - Field: ‘asynchronous’
[10:25:36.016]   - Field: ‘calls’
[10:25:36.016]   - Field: ‘globals’
[10:25:36.016]   - Field: ‘stdout’
[10:25:36.016]   - Field: ‘earlySignal’
[10:25:36.016]   - Field: ‘lazy’
[10:25:36.016]   - Field: ‘state’
[10:25:36.016] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:36.016] - Launch lazy future ...
[10:25:36.016] Packages needed by the future expression (n = 0): <none>
[10:25:36.017] Packages needed by future strategies (n = 0): <none>
[10:25:36.017] {
[10:25:36.017]     {
[10:25:36.017]         {
[10:25:36.017]             ...future.startTime <- base::Sys.time()
[10:25:36.017]             {
[10:25:36.017]                 {
[10:25:36.017]                   {
[10:25:36.017]                     base::local({
[10:25:36.017]                       has_future <- base::requireNamespace("future", 
[10:25:36.017]                         quietly = TRUE)
[10:25:36.017]                       if (has_future) {
[10:25:36.017]                         ns <- base::getNamespace("future")
[10:25:36.017]                         version <- ns[[".package"]][["version"]]
[10:25:36.017]                         if (is.null(version)) 
[10:25:36.017]                           version <- utils::packageVersion("future")
[10:25:36.017]                       }
[10:25:36.017]                       else {
[10:25:36.017]                         version <- NULL
[10:25:36.017]                       }
[10:25:36.017]                       if (!has_future || version < "1.8.0") {
[10:25:36.017]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:36.017]                           "", base::R.version$version.string), 
[10:25:36.017]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:36.017]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:36.017]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:36.017]                             "release", "version")], collapse = " "), 
[10:25:36.017]                           hostname = base::Sys.info()[["nodename"]])
[10:25:36.017]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:36.017]                           info)
[10:25:36.017]                         info <- base::paste(info, collapse = "; ")
[10:25:36.017]                         if (!has_future) {
[10:25:36.017]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:36.017]                             info)
[10:25:36.017]                         }
[10:25:36.017]                         else {
[10:25:36.017]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:36.017]                             info, version)
[10:25:36.017]                         }
[10:25:36.017]                         base::stop(msg)
[10:25:36.017]                       }
[10:25:36.017]                     })
[10:25:36.017]                   }
[10:25:36.017]                   options(future.plan = NULL)
[10:25:36.017]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:36.017]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:36.017]                 }
[10:25:36.017]                 ...future.workdir <- getwd()
[10:25:36.017]             }
[10:25:36.017]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:36.017]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:36.017]         }
[10:25:36.017]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:36.017]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:36.017]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:36.017]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:36.017]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:36.017]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:36.017]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:36.017]             base::names(...future.oldOptions))
[10:25:36.017]     }
[10:25:36.017]     if (FALSE) {
[10:25:36.017]     }
[10:25:36.017]     else {
[10:25:36.017]         if (TRUE) {
[10:25:36.017]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:36.017]                 open = "w")
[10:25:36.017]         }
[10:25:36.017]         else {
[10:25:36.017]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:36.017]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:36.017]         }
[10:25:36.017]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:36.017]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:36.017]             base::sink(type = "output", split = FALSE)
[10:25:36.017]             base::close(...future.stdout)
[10:25:36.017]         }, add = TRUE)
[10:25:36.017]     }
[10:25:36.017]     ...future.frame <- base::sys.nframe()
[10:25:36.017]     ...future.conditions <- base::list()
[10:25:36.017]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:36.017]     if (FALSE) {
[10:25:36.017]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:36.017]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:36.017]     }
[10:25:36.017]     ...future.result <- base::tryCatch({
[10:25:36.017]         base::withCallingHandlers({
[10:25:36.017]             ...future.value <- base::withVisible(base::local({
[10:25:36.017]                 1
[10:25:36.017]             }))
[10:25:36.017]             future::FutureResult(value = ...future.value$value, 
[10:25:36.017]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:36.017]                   ...future.rng), globalenv = if (FALSE) 
[10:25:36.017]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:36.017]                     ...future.globalenv.names))
[10:25:36.017]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:36.017]         }, condition = base::local({
[10:25:36.017]             c <- base::c
[10:25:36.017]             inherits <- base::inherits
[10:25:36.017]             invokeRestart <- base::invokeRestart
[10:25:36.017]             length <- base::length
[10:25:36.017]             list <- base::list
[10:25:36.017]             seq.int <- base::seq.int
[10:25:36.017]             signalCondition <- base::signalCondition
[10:25:36.017]             sys.calls <- base::sys.calls
[10:25:36.017]             `[[` <- base::`[[`
[10:25:36.017]             `+` <- base::`+`
[10:25:36.017]             `<<-` <- base::`<<-`
[10:25:36.017]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:36.017]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:36.017]                   3L)]
[10:25:36.017]             }
[10:25:36.017]             function(cond) {
[10:25:36.017]                 is_error <- inherits(cond, "error")
[10:25:36.017]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:36.017]                   NULL)
[10:25:36.017]                 if (is_error) {
[10:25:36.017]                   sessionInformation <- function() {
[10:25:36.017]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:36.017]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:36.017]                       search = base::search(), system = base::Sys.info())
[10:25:36.017]                   }
[10:25:36.017]                   ...future.conditions[[length(...future.conditions) + 
[10:25:36.017]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:36.017]                     cond$call), session = sessionInformation(), 
[10:25:36.017]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:36.017]                   signalCondition(cond)
[10:25:36.017]                 }
[10:25:36.017]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:36.017]                 "immediateCondition"))) {
[10:25:36.017]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:36.017]                   ...future.conditions[[length(...future.conditions) + 
[10:25:36.017]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:36.017]                   if (TRUE && !signal) {
[10:25:36.017]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:36.017]                     {
[10:25:36.017]                       inherits <- base::inherits
[10:25:36.017]                       invokeRestart <- base::invokeRestart
[10:25:36.017]                       is.null <- base::is.null
[10:25:36.017]                       muffled <- FALSE
[10:25:36.017]                       if (inherits(cond, "message")) {
[10:25:36.017]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:36.017]                         if (muffled) 
[10:25:36.017]                           invokeRestart("muffleMessage")
[10:25:36.017]                       }
[10:25:36.017]                       else if (inherits(cond, "warning")) {
[10:25:36.017]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:36.017]                         if (muffled) 
[10:25:36.017]                           invokeRestart("muffleWarning")
[10:25:36.017]                       }
[10:25:36.017]                       else if (inherits(cond, "condition")) {
[10:25:36.017]                         if (!is.null(pattern)) {
[10:25:36.017]                           computeRestarts <- base::computeRestarts
[10:25:36.017]                           grepl <- base::grepl
[10:25:36.017]                           restarts <- computeRestarts(cond)
[10:25:36.017]                           for (restart in restarts) {
[10:25:36.017]                             name <- restart$name
[10:25:36.017]                             if (is.null(name)) 
[10:25:36.017]                               next
[10:25:36.017]                             if (!grepl(pattern, name)) 
[10:25:36.017]                               next
[10:25:36.017]                             invokeRestart(restart)
[10:25:36.017]                             muffled <- TRUE
[10:25:36.017]                             break
[10:25:36.017]                           }
[10:25:36.017]                         }
[10:25:36.017]                       }
[10:25:36.017]                       invisible(muffled)
[10:25:36.017]                     }
[10:25:36.017]                     muffleCondition(cond, pattern = "^muffle")
[10:25:36.017]                   }
[10:25:36.017]                 }
[10:25:36.017]                 else {
[10:25:36.017]                   if (TRUE) {
[10:25:36.017]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:36.017]                     {
[10:25:36.017]                       inherits <- base::inherits
[10:25:36.017]                       invokeRestart <- base::invokeRestart
[10:25:36.017]                       is.null <- base::is.null
[10:25:36.017]                       muffled <- FALSE
[10:25:36.017]                       if (inherits(cond, "message")) {
[10:25:36.017]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:36.017]                         if (muffled) 
[10:25:36.017]                           invokeRestart("muffleMessage")
[10:25:36.017]                       }
[10:25:36.017]                       else if (inherits(cond, "warning")) {
[10:25:36.017]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:36.017]                         if (muffled) 
[10:25:36.017]                           invokeRestart("muffleWarning")
[10:25:36.017]                       }
[10:25:36.017]                       else if (inherits(cond, "condition")) {
[10:25:36.017]                         if (!is.null(pattern)) {
[10:25:36.017]                           computeRestarts <- base::computeRestarts
[10:25:36.017]                           grepl <- base::grepl
[10:25:36.017]                           restarts <- computeRestarts(cond)
[10:25:36.017]                           for (restart in restarts) {
[10:25:36.017]                             name <- restart$name
[10:25:36.017]                             if (is.null(name)) 
[10:25:36.017]                               next
[10:25:36.017]                             if (!grepl(pattern, name)) 
[10:25:36.017]                               next
[10:25:36.017]                             invokeRestart(restart)
[10:25:36.017]                             muffled <- TRUE
[10:25:36.017]                             break
[10:25:36.017]                           }
[10:25:36.017]                         }
[10:25:36.017]                       }
[10:25:36.017]                       invisible(muffled)
[10:25:36.017]                     }
[10:25:36.017]                     muffleCondition(cond, pattern = "^muffle")
[10:25:36.017]                   }
[10:25:36.017]                 }
[10:25:36.017]             }
[10:25:36.017]         }))
[10:25:36.017]     }, error = function(ex) {
[10:25:36.017]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:36.017]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:36.017]                 ...future.rng), started = ...future.startTime, 
[10:25:36.017]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:36.017]             version = "1.8"), class = "FutureResult")
[10:25:36.017]     }, finally = {
[10:25:36.017]         if (!identical(...future.workdir, getwd())) 
[10:25:36.017]             setwd(...future.workdir)
[10:25:36.017]         {
[10:25:36.017]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:36.017]                 ...future.oldOptions$nwarnings <- NULL
[10:25:36.017]             }
[10:25:36.017]             base::options(...future.oldOptions)
[10:25:36.017]             if (.Platform$OS.type == "windows") {
[10:25:36.017]                 old_names <- names(...future.oldEnvVars)
[10:25:36.017]                 envs <- base::Sys.getenv()
[10:25:36.017]                 names <- names(envs)
[10:25:36.017]                 common <- intersect(names, old_names)
[10:25:36.017]                 added <- setdiff(names, old_names)
[10:25:36.017]                 removed <- setdiff(old_names, names)
[10:25:36.017]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:36.017]                   envs[common]]
[10:25:36.017]                 NAMES <- toupper(changed)
[10:25:36.017]                 args <- list()
[10:25:36.017]                 for (kk in seq_along(NAMES)) {
[10:25:36.017]                   name <- changed[[kk]]
[10:25:36.017]                   NAME <- NAMES[[kk]]
[10:25:36.017]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:36.017]                     next
[10:25:36.017]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:36.017]                 }
[10:25:36.017]                 NAMES <- toupper(added)
[10:25:36.017]                 for (kk in seq_along(NAMES)) {
[10:25:36.017]                   name <- added[[kk]]
[10:25:36.017]                   NAME <- NAMES[[kk]]
[10:25:36.017]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:36.017]                     next
[10:25:36.017]                   args[[name]] <- ""
[10:25:36.017]                 }
[10:25:36.017]                 NAMES <- toupper(removed)
[10:25:36.017]                 for (kk in seq_along(NAMES)) {
[10:25:36.017]                   name <- removed[[kk]]
[10:25:36.017]                   NAME <- NAMES[[kk]]
[10:25:36.017]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:36.017]                     next
[10:25:36.017]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:36.017]                 }
[10:25:36.017]                 if (length(args) > 0) 
[10:25:36.017]                   base::do.call(base::Sys.setenv, args = args)
[10:25:36.017]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:36.017]             }
[10:25:36.017]             else {
[10:25:36.017]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:36.017]             }
[10:25:36.017]             {
[10:25:36.017]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:36.017]                   0L) {
[10:25:36.017]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:36.017]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:36.017]                   base::options(opts)
[10:25:36.017]                 }
[10:25:36.017]                 {
[10:25:36.017]                   {
[10:25:36.017]                     NULL
[10:25:36.017]                     RNGkind("Mersenne-Twister")
[10:25:36.017]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:36.017]                       inherits = FALSE)
[10:25:36.017]                   }
[10:25:36.017]                   options(future.plan = NULL)
[10:25:36.017]                   if (is.na(NA_character_)) 
[10:25:36.017]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:36.017]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:36.017]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:36.017]                   {
[10:25:36.017]                     future <- SequentialFuture(..., envir = envir)
[10:25:36.017]                     if (!future$lazy) 
[10:25:36.017]                       future <- run(future)
[10:25:36.017]                     invisible(future)
[10:25:36.017]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:36.017]                 }
[10:25:36.017]             }
[10:25:36.017]         }
[10:25:36.017]     })
[10:25:36.017]     if (TRUE) {
[10:25:36.017]         base::sink(type = "output", split = FALSE)
[10:25:36.017]         if (TRUE) {
[10:25:36.017]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:36.017]         }
[10:25:36.017]         else {
[10:25:36.017]             ...future.result["stdout"] <- base::list(NULL)
[10:25:36.017]         }
[10:25:36.017]         base::close(...future.stdout)
[10:25:36.017]         ...future.stdout <- NULL
[10:25:36.017]     }
[10:25:36.017]     ...future.result$conditions <- ...future.conditions
[10:25:36.017]     ...future.result$finished <- base::Sys.time()
[10:25:36.017]     ...future.result
[10:25:36.017] }
[10:25:36.019] plan(): Setting new future strategy stack:
[10:25:36.019] List of future strategies:
[10:25:36.019] 1. sequential:
[10:25:36.019]    - args: function (..., envir = parent.frame())
[10:25:36.019]    - tweaked: FALSE
[10:25:36.019]    - call: NULL
[10:25:36.019] plan(): nbrOfWorkers() = 1
[10:25:36.020] plan(): Setting new future strategy stack:
[10:25:36.020] List of future strategies:
[10:25:36.020] 1. sequential:
[10:25:36.020]    - args: function (..., envir = parent.frame())
[10:25:36.020]    - tweaked: FALSE
[10:25:36.020]    - call: future::plan("sequential")
[10:25:36.020] plan(): nbrOfWorkers() = 1
[10:25:36.020] SequentialFuture started (and completed)
[10:25:36.021] - Launch lazy future ... done
[10:25:36.021] run() for ‘SequentialFuture’ ... done
> stopifnot(identical(v$a, 2))
[10:25:36.021] run() for ‘Future’ ...
[10:25:36.021] - state: ‘created’
[10:25:36.021] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:36.021] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:36.021] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:36.022]   - Field: ‘label’
[10:25:36.022]   - Field: ‘local’
[10:25:36.022]   - Field: ‘owner’
[10:25:36.022]   - Field: ‘envir’
[10:25:36.022]   - Field: ‘packages’
[10:25:36.022]   - Field: ‘gc’
[10:25:36.022]   - Field: ‘conditions’
[10:25:36.022]   - Field: ‘expr’
[10:25:36.022]   - Field: ‘uuid’
[10:25:36.022]   - Field: ‘seed’
[10:25:36.022]   - Field: ‘version’
[10:25:36.023]   - Field: ‘result’
[10:25:36.023]   - Field: ‘asynchronous’
[10:25:36.023]   - Field: ‘calls’
[10:25:36.023]   - Field: ‘globals’
[10:25:36.023]   - Field: ‘stdout’
[10:25:36.023]   - Field: ‘earlySignal’
[10:25:36.023]   - Field: ‘lazy’
[10:25:36.023]   - Field: ‘state’
[10:25:36.023] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:36.023] - Launch lazy future ...
[10:25:36.024] Packages needed by the future expression (n = 0): <none>
[10:25:36.024] Packages needed by future strategies (n = 0): <none>
[10:25:36.024] {
[10:25:36.024]     {
[10:25:36.024]         {
[10:25:36.024]             ...future.startTime <- base::Sys.time()
[10:25:36.024]             {
[10:25:36.024]                 {
[10:25:36.024]                   {
[10:25:36.024]                     base::local({
[10:25:36.024]                       has_future <- base::requireNamespace("future", 
[10:25:36.024]                         quietly = TRUE)
[10:25:36.024]                       if (has_future) {
[10:25:36.024]                         ns <- base::getNamespace("future")
[10:25:36.024]                         version <- ns[[".package"]][["version"]]
[10:25:36.024]                         if (is.null(version)) 
[10:25:36.024]                           version <- utils::packageVersion("future")
[10:25:36.024]                       }
[10:25:36.024]                       else {
[10:25:36.024]                         version <- NULL
[10:25:36.024]                       }
[10:25:36.024]                       if (!has_future || version < "1.8.0") {
[10:25:36.024]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:36.024]                           "", base::R.version$version.string), 
[10:25:36.024]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:36.024]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:36.024]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:36.024]                             "release", "version")], collapse = " "), 
[10:25:36.024]                           hostname = base::Sys.info()[["nodename"]])
[10:25:36.024]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:36.024]                           info)
[10:25:36.024]                         info <- base::paste(info, collapse = "; ")
[10:25:36.024]                         if (!has_future) {
[10:25:36.024]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:36.024]                             info)
[10:25:36.024]                         }
[10:25:36.024]                         else {
[10:25:36.024]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:36.024]                             info, version)
[10:25:36.024]                         }
[10:25:36.024]                         base::stop(msg)
[10:25:36.024]                       }
[10:25:36.024]                     })
[10:25:36.024]                   }
[10:25:36.024]                   options(future.plan = NULL)
[10:25:36.024]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:36.024]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:36.024]                 }
[10:25:36.024]                 ...future.workdir <- getwd()
[10:25:36.024]             }
[10:25:36.024]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:36.024]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:36.024]         }
[10:25:36.024]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:36.024]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:36.024]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:36.024]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:36.024]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:36.024]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:36.024]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:36.024]             base::names(...future.oldOptions))
[10:25:36.024]     }
[10:25:36.024]     if (FALSE) {
[10:25:36.024]     }
[10:25:36.024]     else {
[10:25:36.024]         if (TRUE) {
[10:25:36.024]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:36.024]                 open = "w")
[10:25:36.024]         }
[10:25:36.024]         else {
[10:25:36.024]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:36.024]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:36.024]         }
[10:25:36.024]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:36.024]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:36.024]             base::sink(type = "output", split = FALSE)
[10:25:36.024]             base::close(...future.stdout)
[10:25:36.024]         }, add = TRUE)
[10:25:36.024]     }
[10:25:36.024]     ...future.frame <- base::sys.nframe()
[10:25:36.024]     ...future.conditions <- base::list()
[10:25:36.024]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:36.024]     if (FALSE) {
[10:25:36.024]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:36.024]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:36.024]     }
[10:25:36.024]     ...future.result <- base::tryCatch({
[10:25:36.024]         base::withCallingHandlers({
[10:25:36.024]             ...future.value <- base::withVisible(base::local({
[10:25:36.024]                 2
[10:25:36.024]             }))
[10:25:36.024]             future::FutureResult(value = ...future.value$value, 
[10:25:36.024]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:36.024]                   ...future.rng), globalenv = if (FALSE) 
[10:25:36.024]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:36.024]                     ...future.globalenv.names))
[10:25:36.024]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:36.024]         }, condition = base::local({
[10:25:36.024]             c <- base::c
[10:25:36.024]             inherits <- base::inherits
[10:25:36.024]             invokeRestart <- base::invokeRestart
[10:25:36.024]             length <- base::length
[10:25:36.024]             list <- base::list
[10:25:36.024]             seq.int <- base::seq.int
[10:25:36.024]             signalCondition <- base::signalCondition
[10:25:36.024]             sys.calls <- base::sys.calls
[10:25:36.024]             `[[` <- base::`[[`
[10:25:36.024]             `+` <- base::`+`
[10:25:36.024]             `<<-` <- base::`<<-`
[10:25:36.024]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:36.024]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:36.024]                   3L)]
[10:25:36.024]             }
[10:25:36.024]             function(cond) {
[10:25:36.024]                 is_error <- inherits(cond, "error")
[10:25:36.024]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:36.024]                   NULL)
[10:25:36.024]                 if (is_error) {
[10:25:36.024]                   sessionInformation <- function() {
[10:25:36.024]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:36.024]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:36.024]                       search = base::search(), system = base::Sys.info())
[10:25:36.024]                   }
[10:25:36.024]                   ...future.conditions[[length(...future.conditions) + 
[10:25:36.024]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:36.024]                     cond$call), session = sessionInformation(), 
[10:25:36.024]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:36.024]                   signalCondition(cond)
[10:25:36.024]                 }
[10:25:36.024]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:36.024]                 "immediateCondition"))) {
[10:25:36.024]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:36.024]                   ...future.conditions[[length(...future.conditions) + 
[10:25:36.024]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:36.024]                   if (TRUE && !signal) {
[10:25:36.024]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:36.024]                     {
[10:25:36.024]                       inherits <- base::inherits
[10:25:36.024]                       invokeRestart <- base::invokeRestart
[10:25:36.024]                       is.null <- base::is.null
[10:25:36.024]                       muffled <- FALSE
[10:25:36.024]                       if (inherits(cond, "message")) {
[10:25:36.024]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:36.024]                         if (muffled) 
[10:25:36.024]                           invokeRestart("muffleMessage")
[10:25:36.024]                       }
[10:25:36.024]                       else if (inherits(cond, "warning")) {
[10:25:36.024]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:36.024]                         if (muffled) 
[10:25:36.024]                           invokeRestart("muffleWarning")
[10:25:36.024]                       }
[10:25:36.024]                       else if (inherits(cond, "condition")) {
[10:25:36.024]                         if (!is.null(pattern)) {
[10:25:36.024]                           computeRestarts <- base::computeRestarts
[10:25:36.024]                           grepl <- base::grepl
[10:25:36.024]                           restarts <- computeRestarts(cond)
[10:25:36.024]                           for (restart in restarts) {
[10:25:36.024]                             name <- restart$name
[10:25:36.024]                             if (is.null(name)) 
[10:25:36.024]                               next
[10:25:36.024]                             if (!grepl(pattern, name)) 
[10:25:36.024]                               next
[10:25:36.024]                             invokeRestart(restart)
[10:25:36.024]                             muffled <- TRUE
[10:25:36.024]                             break
[10:25:36.024]                           }
[10:25:36.024]                         }
[10:25:36.024]                       }
[10:25:36.024]                       invisible(muffled)
[10:25:36.024]                     }
[10:25:36.024]                     muffleCondition(cond, pattern = "^muffle")
[10:25:36.024]                   }
[10:25:36.024]                 }
[10:25:36.024]                 else {
[10:25:36.024]                   if (TRUE) {
[10:25:36.024]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:36.024]                     {
[10:25:36.024]                       inherits <- base::inherits
[10:25:36.024]                       invokeRestart <- base::invokeRestart
[10:25:36.024]                       is.null <- base::is.null
[10:25:36.024]                       muffled <- FALSE
[10:25:36.024]                       if (inherits(cond, "message")) {
[10:25:36.024]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:36.024]                         if (muffled) 
[10:25:36.024]                           invokeRestart("muffleMessage")
[10:25:36.024]                       }
[10:25:36.024]                       else if (inherits(cond, "warning")) {
[10:25:36.024]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:36.024]                         if (muffled) 
[10:25:36.024]                           invokeRestart("muffleWarning")
[10:25:36.024]                       }
[10:25:36.024]                       else if (inherits(cond, "condition")) {
[10:25:36.024]                         if (!is.null(pattern)) {
[10:25:36.024]                           computeRestarts <- base::computeRestarts
[10:25:36.024]                           grepl <- base::grepl
[10:25:36.024]                           restarts <- computeRestarts(cond)
[10:25:36.024]                           for (restart in restarts) {
[10:25:36.024]                             name <- restart$name
[10:25:36.024]                             if (is.null(name)) 
[10:25:36.024]                               next
[10:25:36.024]                             if (!grepl(pattern, name)) 
[10:25:36.024]                               next
[10:25:36.024]                             invokeRestart(restart)
[10:25:36.024]                             muffled <- TRUE
[10:25:36.024]                             break
[10:25:36.024]                           }
[10:25:36.024]                         }
[10:25:36.024]                       }
[10:25:36.024]                       invisible(muffled)
[10:25:36.024]                     }
[10:25:36.024]                     muffleCondition(cond, pattern = "^muffle")
[10:25:36.024]                   }
[10:25:36.024]                 }
[10:25:36.024]             }
[10:25:36.024]         }))
[10:25:36.024]     }, error = function(ex) {
[10:25:36.024]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:36.024]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:36.024]                 ...future.rng), started = ...future.startTime, 
[10:25:36.024]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:36.024]             version = "1.8"), class = "FutureResult")
[10:25:36.024]     }, finally = {
[10:25:36.024]         if (!identical(...future.workdir, getwd())) 
[10:25:36.024]             setwd(...future.workdir)
[10:25:36.024]         {
[10:25:36.024]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:36.024]                 ...future.oldOptions$nwarnings <- NULL
[10:25:36.024]             }
[10:25:36.024]             base::options(...future.oldOptions)
[10:25:36.024]             if (.Platform$OS.type == "windows") {
[10:25:36.024]                 old_names <- names(...future.oldEnvVars)
[10:25:36.024]                 envs <- base::Sys.getenv()
[10:25:36.024]                 names <- names(envs)
[10:25:36.024]                 common <- intersect(names, old_names)
[10:25:36.024]                 added <- setdiff(names, old_names)
[10:25:36.024]                 removed <- setdiff(old_names, names)
[10:25:36.024]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:36.024]                   envs[common]]
[10:25:36.024]                 NAMES <- toupper(changed)
[10:25:36.024]                 args <- list()
[10:25:36.024]                 for (kk in seq_along(NAMES)) {
[10:25:36.024]                   name <- changed[[kk]]
[10:25:36.024]                   NAME <- NAMES[[kk]]
[10:25:36.024]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:36.024]                     next
[10:25:36.024]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:36.024]                 }
[10:25:36.024]                 NAMES <- toupper(added)
[10:25:36.024]                 for (kk in seq_along(NAMES)) {
[10:25:36.024]                   name <- added[[kk]]
[10:25:36.024]                   NAME <- NAMES[[kk]]
[10:25:36.024]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:36.024]                     next
[10:25:36.024]                   args[[name]] <- ""
[10:25:36.024]                 }
[10:25:36.024]                 NAMES <- toupper(removed)
[10:25:36.024]                 for (kk in seq_along(NAMES)) {
[10:25:36.024]                   name <- removed[[kk]]
[10:25:36.024]                   NAME <- NAMES[[kk]]
[10:25:36.024]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:36.024]                     next
[10:25:36.024]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:36.024]                 }
[10:25:36.024]                 if (length(args) > 0) 
[10:25:36.024]                   base::do.call(base::Sys.setenv, args = args)
[10:25:36.024]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:36.024]             }
[10:25:36.024]             else {
[10:25:36.024]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:36.024]             }
[10:25:36.024]             {
[10:25:36.024]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:36.024]                   0L) {
[10:25:36.024]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:36.024]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:36.024]                   base::options(opts)
[10:25:36.024]                 }
[10:25:36.024]                 {
[10:25:36.024]                   {
[10:25:36.024]                     NULL
[10:25:36.024]                     RNGkind("Mersenne-Twister")
[10:25:36.024]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:36.024]                       inherits = FALSE)
[10:25:36.024]                   }
[10:25:36.024]                   options(future.plan = NULL)
[10:25:36.024]                   if (is.na(NA_character_)) 
[10:25:36.024]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:36.024]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:36.024]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:36.024]                   {
[10:25:36.024]                     future <- SequentialFuture(..., envir = envir)
[10:25:36.024]                     if (!future$lazy) 
[10:25:36.024]                       future <- run(future)
[10:25:36.024]                     invisible(future)
[10:25:36.024]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:36.024]                 }
[10:25:36.024]             }
[10:25:36.024]         }
[10:25:36.024]     })
[10:25:36.024]     if (TRUE) {
[10:25:36.024]         base::sink(type = "output", split = FALSE)
[10:25:36.024]         if (TRUE) {
[10:25:36.024]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:36.024]         }
[10:25:36.024]         else {
[10:25:36.024]             ...future.result["stdout"] <- base::list(NULL)
[10:25:36.024]         }
[10:25:36.024]         base::close(...future.stdout)
[10:25:36.024]         ...future.stdout <- NULL
[10:25:36.024]     }
[10:25:36.024]     ...future.result$conditions <- ...future.conditions
[10:25:36.024]     ...future.result$finished <- base::Sys.time()
[10:25:36.024]     ...future.result
[10:25:36.024] }
[10:25:36.026] plan(): Setting new future strategy stack:
[10:25:36.026] List of future strategies:
[10:25:36.026] 1. sequential:
[10:25:36.026]    - args: function (..., envir = parent.frame())
[10:25:36.026]    - tweaked: FALSE
[10:25:36.026]    - call: NULL
[10:25:36.026] plan(): nbrOfWorkers() = 1
[10:25:36.027] plan(): Setting new future strategy stack:
[10:25:36.027] List of future strategies:
[10:25:36.027] 1. sequential:
[10:25:36.027]    - args: function (..., envir = parent.frame())
[10:25:36.027]    - tweaked: FALSE
[10:25:36.027]    - call: future::plan("sequential")
[10:25:36.027] plan(): nbrOfWorkers() = 1
[10:25:36.027] SequentialFuture started (and completed)
[10:25:36.027] - Launch lazy future ... done
[10:25:36.028] run() for ‘SequentialFuture’ ... done
> 
> 
> message("*** %<-% to listenv: multiple dimensions ...")
*** %<-% to listenv: multiple dimensions ...
> 
> x0 <- list()
> length(x0) <- 6
> dim(x0) <- c(3, 2)
> 
> x <- listenv()
> length(x) <- 6
> dim(x) <- c(3, 2)
> 
> for (cc in 1:ncol(x)) {
+   for (rr in 1:nrow(x)) {
+     x0[[rr, cc]] <- sprintf("(%s, %s)", rr, cc)
+     x[[rr, cc]] %<-% sprintf("(%s, %s)", rr, cc) %lazy% TRUE
+   }
+ }
[10:25:36.033] getGlobalsAndPackages() ...
[10:25:36.033] Searching for globals...
[10:25:36.035] - globals found: [3] ‘sprintf’, ‘rr’, ‘cc’
[10:25:36.035] Searching for globals ... DONE
[10:25:36.035] Resolving globals: FALSE
[10:25:36.036] The total size of the 2 globals is 112 bytes (112 bytes)
[10:25:36.036] The total size of the 2 globals exported for future expression (‘sprintf("(%s, %s)", rr, cc)’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘rr’ (56 bytes of class ‘numeric’) and ‘cc’ (56 bytes of class ‘numeric’)
[10:25:36.036] - globals: [2] ‘rr’, ‘cc’
[10:25:36.036] 
[10:25:36.037] getGlobalsAndPackages() ... DONE
[10:25:36.037] getGlobalsAndPackages() ...
[10:25:36.037] Searching for globals...
[10:25:36.038] - globals found: [3] ‘sprintf’, ‘rr’, ‘cc’
[10:25:36.038] Searching for globals ... DONE
[10:25:36.038] Resolving globals: FALSE
[10:25:36.038] The total size of the 2 globals is 112 bytes (112 bytes)
[10:25:36.039] The total size of the 2 globals exported for future expression (‘sprintf("(%s, %s)", rr, cc)’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘rr’ (56 bytes of class ‘numeric’) and ‘cc’ (56 bytes of class ‘numeric’)
[10:25:36.039] - globals: [2] ‘rr’, ‘cc’
[10:25:36.039] 
[10:25:36.039] getGlobalsAndPackages() ... DONE
[10:25:36.039] getGlobalsAndPackages() ...
[10:25:36.039] Searching for globals...
[10:25:36.041] - globals found: [3] ‘sprintf’, ‘rr’, ‘cc’
[10:25:36.041] Searching for globals ... DONE
[10:25:36.042] Resolving globals: FALSE
[10:25:36.042] The total size of the 2 globals is 112 bytes (112 bytes)
[10:25:36.042] The total size of the 2 globals exported for future expression (‘sprintf("(%s, %s)", rr, cc)’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘rr’ (56 bytes of class ‘numeric’) and ‘cc’ (56 bytes of class ‘numeric’)
[10:25:36.042] - globals: [2] ‘rr’, ‘cc’
[10:25:36.043] 
[10:25:36.043] getGlobalsAndPackages() ... DONE
[10:25:36.043] getGlobalsAndPackages() ...
[10:25:36.043] Searching for globals...
[10:25:36.044] - globals found: [3] ‘sprintf’, ‘rr’, ‘cc’
[10:25:36.044] Searching for globals ... DONE
[10:25:36.044] Resolving globals: FALSE
[10:25:36.044] The total size of the 2 globals is 112 bytes (112 bytes)
[10:25:36.045] The total size of the 2 globals exported for future expression (‘sprintf("(%s, %s)", rr, cc)’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘rr’ (56 bytes of class ‘numeric’) and ‘cc’ (56 bytes of class ‘numeric’)
[10:25:36.045] - globals: [2] ‘rr’, ‘cc’
[10:25:36.045] 
[10:25:36.045] getGlobalsAndPackages() ... DONE
[10:25:36.045] getGlobalsAndPackages() ...
[10:25:36.046] Searching for globals...
[10:25:36.046] - globals found: [3] ‘sprintf’, ‘rr’, ‘cc’
[10:25:36.046] Searching for globals ... DONE
[10:25:36.046] Resolving globals: FALSE
[10:25:36.047] The total size of the 2 globals is 112 bytes (112 bytes)
[10:25:36.047] The total size of the 2 globals exported for future expression (‘sprintf("(%s, %s)", rr, cc)’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘rr’ (56 bytes of class ‘numeric’) and ‘cc’ (56 bytes of class ‘numeric’)
[10:25:36.047] - globals: [2] ‘rr’, ‘cc’
[10:25:36.047] 
[10:25:36.047] getGlobalsAndPackages() ... DONE
[10:25:36.048] getGlobalsAndPackages() ...
[10:25:36.048] Searching for globals...
[10:25:36.048] - globals found: [3] ‘sprintf’, ‘rr’, ‘cc’
[10:25:36.048] Searching for globals ... DONE
[10:25:36.049] Resolving globals: FALSE
[10:25:36.049] The total size of the 2 globals is 112 bytes (112 bytes)
[10:25:36.049] The total size of the 2 globals exported for future expression (‘sprintf("(%s, %s)", rr, cc)’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘rr’ (56 bytes of class ‘numeric’) and ‘cc’ (56 bytes of class ‘numeric’)
[10:25:36.049] - globals: [2] ‘rr’, ‘cc’
[10:25:36.049] 
[10:25:36.050] getGlobalsAndPackages() ... DONE
> 
> y <- as.list(x)
[10:25:36.050] run() for ‘Future’ ...
[10:25:36.050] - state: ‘created’
[10:25:36.050] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:36.050] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:36.050] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:36.050]   - Field: ‘label’
[10:25:36.051]   - Field: ‘local’
[10:25:36.051]   - Field: ‘owner’
[10:25:36.051]   - Field: ‘envir’
[10:25:36.051]   - Field: ‘packages’
[10:25:36.051]   - Field: ‘gc’
[10:25:36.051]   - Field: ‘conditions’
[10:25:36.051]   - Field: ‘expr’
[10:25:36.051]   - Field: ‘uuid’
[10:25:36.051]   - Field: ‘seed’
[10:25:36.051]   - Field: ‘version’
[10:25:36.051]   - Field: ‘result’
[10:25:36.052]   - Field: ‘asynchronous’
[10:25:36.052]   - Field: ‘calls’
[10:25:36.052]   - Field: ‘globals’
[10:25:36.052]   - Field: ‘stdout’
[10:25:36.052]   - Field: ‘earlySignal’
[10:25:36.052]   - Field: ‘lazy’
[10:25:36.052]   - Field: ‘state’
[10:25:36.052] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:36.052] - Launch lazy future ...
[10:25:36.052] Packages needed by the future expression (n = 0): <none>
[10:25:36.053] Packages needed by future strategies (n = 0): <none>
[10:25:36.053] {
[10:25:36.053]     {
[10:25:36.053]         {
[10:25:36.053]             ...future.startTime <- base::Sys.time()
[10:25:36.053]             {
[10:25:36.053]                 {
[10:25:36.053]                   {
[10:25:36.053]                     base::local({
[10:25:36.053]                       has_future <- base::requireNamespace("future", 
[10:25:36.053]                         quietly = TRUE)
[10:25:36.053]                       if (has_future) {
[10:25:36.053]                         ns <- base::getNamespace("future")
[10:25:36.053]                         version <- ns[[".package"]][["version"]]
[10:25:36.053]                         if (is.null(version)) 
[10:25:36.053]                           version <- utils::packageVersion("future")
[10:25:36.053]                       }
[10:25:36.053]                       else {
[10:25:36.053]                         version <- NULL
[10:25:36.053]                       }
[10:25:36.053]                       if (!has_future || version < "1.8.0") {
[10:25:36.053]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:36.053]                           "", base::R.version$version.string), 
[10:25:36.053]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:36.053]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:36.053]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:36.053]                             "release", "version")], collapse = " "), 
[10:25:36.053]                           hostname = base::Sys.info()[["nodename"]])
[10:25:36.053]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:36.053]                           info)
[10:25:36.053]                         info <- base::paste(info, collapse = "; ")
[10:25:36.053]                         if (!has_future) {
[10:25:36.053]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:36.053]                             info)
[10:25:36.053]                         }
[10:25:36.053]                         else {
[10:25:36.053]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:36.053]                             info, version)
[10:25:36.053]                         }
[10:25:36.053]                         base::stop(msg)
[10:25:36.053]                       }
[10:25:36.053]                     })
[10:25:36.053]                   }
[10:25:36.053]                   options(future.plan = NULL)
[10:25:36.053]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:36.053]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:36.053]                 }
[10:25:36.053]                 ...future.workdir <- getwd()
[10:25:36.053]             }
[10:25:36.053]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:36.053]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:36.053]         }
[10:25:36.053]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:36.053]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:36.053]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:36.053]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:36.053]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:36.053]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:36.053]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:36.053]             base::names(...future.oldOptions))
[10:25:36.053]     }
[10:25:36.053]     if (FALSE) {
[10:25:36.053]     }
[10:25:36.053]     else {
[10:25:36.053]         if (TRUE) {
[10:25:36.053]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:36.053]                 open = "w")
[10:25:36.053]         }
[10:25:36.053]         else {
[10:25:36.053]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:36.053]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:36.053]         }
[10:25:36.053]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:36.053]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:36.053]             base::sink(type = "output", split = FALSE)
[10:25:36.053]             base::close(...future.stdout)
[10:25:36.053]         }, add = TRUE)
[10:25:36.053]     }
[10:25:36.053]     ...future.frame <- base::sys.nframe()
[10:25:36.053]     ...future.conditions <- base::list()
[10:25:36.053]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:36.053]     if (FALSE) {
[10:25:36.053]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:36.053]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:36.053]     }
[10:25:36.053]     ...future.result <- base::tryCatch({
[10:25:36.053]         base::withCallingHandlers({
[10:25:36.053]             ...future.value <- base::withVisible(base::local(sprintf("(%s, %s)", 
[10:25:36.053]                 rr, cc)))
[10:25:36.053]             future::FutureResult(value = ...future.value$value, 
[10:25:36.053]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:36.053]                   ...future.rng), globalenv = if (FALSE) 
[10:25:36.053]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:36.053]                     ...future.globalenv.names))
[10:25:36.053]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:36.053]         }, condition = base::local({
[10:25:36.053]             c <- base::c
[10:25:36.053]             inherits <- base::inherits
[10:25:36.053]             invokeRestart <- base::invokeRestart
[10:25:36.053]             length <- base::length
[10:25:36.053]             list <- base::list
[10:25:36.053]             seq.int <- base::seq.int
[10:25:36.053]             signalCondition <- base::signalCondition
[10:25:36.053]             sys.calls <- base::sys.calls
[10:25:36.053]             `[[` <- base::`[[`
[10:25:36.053]             `+` <- base::`+`
[10:25:36.053]             `<<-` <- base::`<<-`
[10:25:36.053]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:36.053]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:36.053]                   3L)]
[10:25:36.053]             }
[10:25:36.053]             function(cond) {
[10:25:36.053]                 is_error <- inherits(cond, "error")
[10:25:36.053]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:36.053]                   NULL)
[10:25:36.053]                 if (is_error) {
[10:25:36.053]                   sessionInformation <- function() {
[10:25:36.053]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:36.053]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:36.053]                       search = base::search(), system = base::Sys.info())
[10:25:36.053]                   }
[10:25:36.053]                   ...future.conditions[[length(...future.conditions) + 
[10:25:36.053]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:36.053]                     cond$call), session = sessionInformation(), 
[10:25:36.053]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:36.053]                   signalCondition(cond)
[10:25:36.053]                 }
[10:25:36.053]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:36.053]                 "immediateCondition"))) {
[10:25:36.053]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:36.053]                   ...future.conditions[[length(...future.conditions) + 
[10:25:36.053]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:36.053]                   if (TRUE && !signal) {
[10:25:36.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:36.053]                     {
[10:25:36.053]                       inherits <- base::inherits
[10:25:36.053]                       invokeRestart <- base::invokeRestart
[10:25:36.053]                       is.null <- base::is.null
[10:25:36.053]                       muffled <- FALSE
[10:25:36.053]                       if (inherits(cond, "message")) {
[10:25:36.053]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:36.053]                         if (muffled) 
[10:25:36.053]                           invokeRestart("muffleMessage")
[10:25:36.053]                       }
[10:25:36.053]                       else if (inherits(cond, "warning")) {
[10:25:36.053]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:36.053]                         if (muffled) 
[10:25:36.053]                           invokeRestart("muffleWarning")
[10:25:36.053]                       }
[10:25:36.053]                       else if (inherits(cond, "condition")) {
[10:25:36.053]                         if (!is.null(pattern)) {
[10:25:36.053]                           computeRestarts <- base::computeRestarts
[10:25:36.053]                           grepl <- base::grepl
[10:25:36.053]                           restarts <- computeRestarts(cond)
[10:25:36.053]                           for (restart in restarts) {
[10:25:36.053]                             name <- restart$name
[10:25:36.053]                             if (is.null(name)) 
[10:25:36.053]                               next
[10:25:36.053]                             if (!grepl(pattern, name)) 
[10:25:36.053]                               next
[10:25:36.053]                             invokeRestart(restart)
[10:25:36.053]                             muffled <- TRUE
[10:25:36.053]                             break
[10:25:36.053]                           }
[10:25:36.053]                         }
[10:25:36.053]                       }
[10:25:36.053]                       invisible(muffled)
[10:25:36.053]                     }
[10:25:36.053]                     muffleCondition(cond, pattern = "^muffle")
[10:25:36.053]                   }
[10:25:36.053]                 }
[10:25:36.053]                 else {
[10:25:36.053]                   if (TRUE) {
[10:25:36.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:36.053]                     {
[10:25:36.053]                       inherits <- base::inherits
[10:25:36.053]                       invokeRestart <- base::invokeRestart
[10:25:36.053]                       is.null <- base::is.null
[10:25:36.053]                       muffled <- FALSE
[10:25:36.053]                       if (inherits(cond, "message")) {
[10:25:36.053]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:36.053]                         if (muffled) 
[10:25:36.053]                           invokeRestart("muffleMessage")
[10:25:36.053]                       }
[10:25:36.053]                       else if (inherits(cond, "warning")) {
[10:25:36.053]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:36.053]                         if (muffled) 
[10:25:36.053]                           invokeRestart("muffleWarning")
[10:25:36.053]                       }
[10:25:36.053]                       else if (inherits(cond, "condition")) {
[10:25:36.053]                         if (!is.null(pattern)) {
[10:25:36.053]                           computeRestarts <- base::computeRestarts
[10:25:36.053]                           grepl <- base::grepl
[10:25:36.053]                           restarts <- computeRestarts(cond)
[10:25:36.053]                           for (restart in restarts) {
[10:25:36.053]                             name <- restart$name
[10:25:36.053]                             if (is.null(name)) 
[10:25:36.053]                               next
[10:25:36.053]                             if (!grepl(pattern, name)) 
[10:25:36.053]                               next
[10:25:36.053]                             invokeRestart(restart)
[10:25:36.053]                             muffled <- TRUE
[10:25:36.053]                             break
[10:25:36.053]                           }
[10:25:36.053]                         }
[10:25:36.053]                       }
[10:25:36.053]                       invisible(muffled)
[10:25:36.053]                     }
[10:25:36.053]                     muffleCondition(cond, pattern = "^muffle")
[10:25:36.053]                   }
[10:25:36.053]                 }
[10:25:36.053]             }
[10:25:36.053]         }))
[10:25:36.053]     }, error = function(ex) {
[10:25:36.053]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:36.053]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:36.053]                 ...future.rng), started = ...future.startTime, 
[10:25:36.053]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:36.053]             version = "1.8"), class = "FutureResult")
[10:25:36.053]     }, finally = {
[10:25:36.053]         if (!identical(...future.workdir, getwd())) 
[10:25:36.053]             setwd(...future.workdir)
[10:25:36.053]         {
[10:25:36.053]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:36.053]                 ...future.oldOptions$nwarnings <- NULL
[10:25:36.053]             }
[10:25:36.053]             base::options(...future.oldOptions)
[10:25:36.053]             if (.Platform$OS.type == "windows") {
[10:25:36.053]                 old_names <- names(...future.oldEnvVars)
[10:25:36.053]                 envs <- base::Sys.getenv()
[10:25:36.053]                 names <- names(envs)
[10:25:36.053]                 common <- intersect(names, old_names)
[10:25:36.053]                 added <- setdiff(names, old_names)
[10:25:36.053]                 removed <- setdiff(old_names, names)
[10:25:36.053]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:36.053]                   envs[common]]
[10:25:36.053]                 NAMES <- toupper(changed)
[10:25:36.053]                 args <- list()
[10:25:36.053]                 for (kk in seq_along(NAMES)) {
[10:25:36.053]                   name <- changed[[kk]]
[10:25:36.053]                   NAME <- NAMES[[kk]]
[10:25:36.053]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:36.053]                     next
[10:25:36.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:36.053]                 }
[10:25:36.053]                 NAMES <- toupper(added)
[10:25:36.053]                 for (kk in seq_along(NAMES)) {
[10:25:36.053]                   name <- added[[kk]]
[10:25:36.053]                   NAME <- NAMES[[kk]]
[10:25:36.053]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:36.053]                     next
[10:25:36.053]                   args[[name]] <- ""
[10:25:36.053]                 }
[10:25:36.053]                 NAMES <- toupper(removed)
[10:25:36.053]                 for (kk in seq_along(NAMES)) {
[10:25:36.053]                   name <- removed[[kk]]
[10:25:36.053]                   NAME <- NAMES[[kk]]
[10:25:36.053]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:36.053]                     next
[10:25:36.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:36.053]                 }
[10:25:36.053]                 if (length(args) > 0) 
[10:25:36.053]                   base::do.call(base::Sys.setenv, args = args)
[10:25:36.053]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:36.053]             }
[10:25:36.053]             else {
[10:25:36.053]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:36.053]             }
[10:25:36.053]             {
[10:25:36.053]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:36.053]                   0L) {
[10:25:36.053]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:36.053]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:36.053]                   base::options(opts)
[10:25:36.053]                 }
[10:25:36.053]                 {
[10:25:36.053]                   {
[10:25:36.053]                     NULL
[10:25:36.053]                     RNGkind("Mersenne-Twister")
[10:25:36.053]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:36.053]                       inherits = FALSE)
[10:25:36.053]                   }
[10:25:36.053]                   options(future.plan = NULL)
[10:25:36.053]                   if (is.na(NA_character_)) 
[10:25:36.053]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:36.053]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:36.053]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:36.053]                   {
[10:25:36.053]                     future <- SequentialFuture(..., envir = envir)
[10:25:36.053]                     if (!future$lazy) 
[10:25:36.053]                       future <- run(future)
[10:25:36.053]                     invisible(future)
[10:25:36.053]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:36.053]                 }
[10:25:36.053]             }
[10:25:36.053]         }
[10:25:36.053]     })
[10:25:36.053]     if (TRUE) {
[10:25:36.053]         base::sink(type = "output", split = FALSE)
[10:25:36.053]         if (TRUE) {
[10:25:36.053]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:36.053]         }
[10:25:36.053]         else {
[10:25:36.053]             ...future.result["stdout"] <- base::list(NULL)
[10:25:36.053]         }
[10:25:36.053]         base::close(...future.stdout)
[10:25:36.053]         ...future.stdout <- NULL
[10:25:36.053]     }
[10:25:36.053]     ...future.result$conditions <- ...future.conditions
[10:25:36.053]     ...future.result$finished <- base::Sys.time()
[10:25:36.053]     ...future.result
[10:25:36.053] }
[10:25:36.055] assign_globals() ...
[10:25:36.055] List of 2
[10:25:36.055]  $ rr: int 1
[10:25:36.055]  $ cc: int 1
[10:25:36.055]  - attr(*, "where")=List of 2
[10:25:36.055]   ..$ rr:<environment: R_EmptyEnv> 
[10:25:36.055]   ..$ cc:<environment: R_EmptyEnv> 
[10:25:36.055]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:36.055]  - attr(*, "resolved")= logi FALSE
[10:25:36.055]  - attr(*, "total_size")= num 112
[10:25:36.055]  - attr(*, "already-done")= logi TRUE
[10:25:36.058] - copied ‘rr’ to environment
[10:25:36.058] - copied ‘cc’ to environment
[10:25:36.058] assign_globals() ... done
[10:25:36.058] plan(): Setting new future strategy stack:
[10:25:36.058] List of future strategies:
[10:25:36.058] 1. sequential:
[10:25:36.058]    - args: function (..., envir = parent.frame())
[10:25:36.058]    - tweaked: FALSE
[10:25:36.058]    - call: NULL
[10:25:36.058] plan(): nbrOfWorkers() = 1
[10:25:36.059] plan(): Setting new future strategy stack:
[10:25:36.059] List of future strategies:
[10:25:36.059] 1. sequential:
[10:25:36.059]    - args: function (..., envir = parent.frame())
[10:25:36.059]    - tweaked: FALSE
[10:25:36.059]    - call: future::plan("sequential")
[10:25:36.059] plan(): nbrOfWorkers() = 1
[10:25:36.060] SequentialFuture started (and completed)
[10:25:36.060] - Launch lazy future ... done
[10:25:36.060] run() for ‘SequentialFuture’ ... done
[10:25:36.060] run() for ‘Future’ ...
[10:25:36.060] - state: ‘created’
[10:25:36.060] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:36.061] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:36.061] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:36.061]   - Field: ‘label’
[10:25:36.061]   - Field: ‘local’
[10:25:36.061]   - Field: ‘owner’
[10:25:36.061]   - Field: ‘envir’
[10:25:36.061]   - Field: ‘packages’
[10:25:36.061]   - Field: ‘gc’
[10:25:36.061]   - Field: ‘conditions’
[10:25:36.061]   - Field: ‘expr’
[10:25:36.062]   - Field: ‘uuid’
[10:25:36.062]   - Field: ‘seed’
[10:25:36.062]   - Field: ‘version’
[10:25:36.062]   - Field: ‘result’
[10:25:36.062]   - Field: ‘asynchronous’
[10:25:36.062]   - Field: ‘calls’
[10:25:36.062]   - Field: ‘globals’
[10:25:36.062]   - Field: ‘stdout’
[10:25:36.062]   - Field: ‘earlySignal’
[10:25:36.062]   - Field: ‘lazy’
[10:25:36.062]   - Field: ‘state’
[10:25:36.063] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:36.063] - Launch lazy future ...
[10:25:36.063] Packages needed by the future expression (n = 0): <none>
[10:25:36.063] Packages needed by future strategies (n = 0): <none>
[10:25:36.063] {
[10:25:36.063]     {
[10:25:36.063]         {
[10:25:36.063]             ...future.startTime <- base::Sys.time()
[10:25:36.063]             {
[10:25:36.063]                 {
[10:25:36.063]                   {
[10:25:36.063]                     base::local({
[10:25:36.063]                       has_future <- base::requireNamespace("future", 
[10:25:36.063]                         quietly = TRUE)
[10:25:36.063]                       if (has_future) {
[10:25:36.063]                         ns <- base::getNamespace("future")
[10:25:36.063]                         version <- ns[[".package"]][["version"]]
[10:25:36.063]                         if (is.null(version)) 
[10:25:36.063]                           version <- utils::packageVersion("future")
[10:25:36.063]                       }
[10:25:36.063]                       else {
[10:25:36.063]                         version <- NULL
[10:25:36.063]                       }
[10:25:36.063]                       if (!has_future || version < "1.8.0") {
[10:25:36.063]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:36.063]                           "", base::R.version$version.string), 
[10:25:36.063]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:36.063]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:36.063]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:36.063]                             "release", "version")], collapse = " "), 
[10:25:36.063]                           hostname = base::Sys.info()[["nodename"]])
[10:25:36.063]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:36.063]                           info)
[10:25:36.063]                         info <- base::paste(info, collapse = "; ")
[10:25:36.063]                         if (!has_future) {
[10:25:36.063]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:36.063]                             info)
[10:25:36.063]                         }
[10:25:36.063]                         else {
[10:25:36.063]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:36.063]                             info, version)
[10:25:36.063]                         }
[10:25:36.063]                         base::stop(msg)
[10:25:36.063]                       }
[10:25:36.063]                     })
[10:25:36.063]                   }
[10:25:36.063]                   options(future.plan = NULL)
[10:25:36.063]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:36.063]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:36.063]                 }
[10:25:36.063]                 ...future.workdir <- getwd()
[10:25:36.063]             }
[10:25:36.063]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:36.063]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:36.063]         }
[10:25:36.063]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:36.063]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:36.063]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:36.063]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:36.063]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:36.063]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:36.063]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:36.063]             base::names(...future.oldOptions))
[10:25:36.063]     }
[10:25:36.063]     if (FALSE) {
[10:25:36.063]     }
[10:25:36.063]     else {
[10:25:36.063]         if (TRUE) {
[10:25:36.063]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:36.063]                 open = "w")
[10:25:36.063]         }
[10:25:36.063]         else {
[10:25:36.063]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:36.063]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:36.063]         }
[10:25:36.063]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:36.063]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:36.063]             base::sink(type = "output", split = FALSE)
[10:25:36.063]             base::close(...future.stdout)
[10:25:36.063]         }, add = TRUE)
[10:25:36.063]     }
[10:25:36.063]     ...future.frame <- base::sys.nframe()
[10:25:36.063]     ...future.conditions <- base::list()
[10:25:36.063]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:36.063]     if (FALSE) {
[10:25:36.063]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:36.063]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:36.063]     }
[10:25:36.063]     ...future.result <- base::tryCatch({
[10:25:36.063]         base::withCallingHandlers({
[10:25:36.063]             ...future.value <- base::withVisible(base::local(sprintf("(%s, %s)", 
[10:25:36.063]                 rr, cc)))
[10:25:36.063]             future::FutureResult(value = ...future.value$value, 
[10:25:36.063]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:36.063]                   ...future.rng), globalenv = if (FALSE) 
[10:25:36.063]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:36.063]                     ...future.globalenv.names))
[10:25:36.063]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:36.063]         }, condition = base::local({
[10:25:36.063]             c <- base::c
[10:25:36.063]             inherits <- base::inherits
[10:25:36.063]             invokeRestart <- base::invokeRestart
[10:25:36.063]             length <- base::length
[10:25:36.063]             list <- base::list
[10:25:36.063]             seq.int <- base::seq.int
[10:25:36.063]             signalCondition <- base::signalCondition
[10:25:36.063]             sys.calls <- base::sys.calls
[10:25:36.063]             `[[` <- base::`[[`
[10:25:36.063]             `+` <- base::`+`
[10:25:36.063]             `<<-` <- base::`<<-`
[10:25:36.063]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:36.063]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:36.063]                   3L)]
[10:25:36.063]             }
[10:25:36.063]             function(cond) {
[10:25:36.063]                 is_error <- inherits(cond, "error")
[10:25:36.063]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:36.063]                   NULL)
[10:25:36.063]                 if (is_error) {
[10:25:36.063]                   sessionInformation <- function() {
[10:25:36.063]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:36.063]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:36.063]                       search = base::search(), system = base::Sys.info())
[10:25:36.063]                   }
[10:25:36.063]                   ...future.conditions[[length(...future.conditions) + 
[10:25:36.063]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:36.063]                     cond$call), session = sessionInformation(), 
[10:25:36.063]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:36.063]                   signalCondition(cond)
[10:25:36.063]                 }
[10:25:36.063]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:36.063]                 "immediateCondition"))) {
[10:25:36.063]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:36.063]                   ...future.conditions[[length(...future.conditions) + 
[10:25:36.063]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:36.063]                   if (TRUE && !signal) {
[10:25:36.063]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:36.063]                     {
[10:25:36.063]                       inherits <- base::inherits
[10:25:36.063]                       invokeRestart <- base::invokeRestart
[10:25:36.063]                       is.null <- base::is.null
[10:25:36.063]                       muffled <- FALSE
[10:25:36.063]                       if (inherits(cond, "message")) {
[10:25:36.063]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:36.063]                         if (muffled) 
[10:25:36.063]                           invokeRestart("muffleMessage")
[10:25:36.063]                       }
[10:25:36.063]                       else if (inherits(cond, "warning")) {
[10:25:36.063]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:36.063]                         if (muffled) 
[10:25:36.063]                           invokeRestart("muffleWarning")
[10:25:36.063]                       }
[10:25:36.063]                       else if (inherits(cond, "condition")) {
[10:25:36.063]                         if (!is.null(pattern)) {
[10:25:36.063]                           computeRestarts <- base::computeRestarts
[10:25:36.063]                           grepl <- base::grepl
[10:25:36.063]                           restarts <- computeRestarts(cond)
[10:25:36.063]                           for (restart in restarts) {
[10:25:36.063]                             name <- restart$name
[10:25:36.063]                             if (is.null(name)) 
[10:25:36.063]                               next
[10:25:36.063]                             if (!grepl(pattern, name)) 
[10:25:36.063]                               next
[10:25:36.063]                             invokeRestart(restart)
[10:25:36.063]                             muffled <- TRUE
[10:25:36.063]                             break
[10:25:36.063]                           }
[10:25:36.063]                         }
[10:25:36.063]                       }
[10:25:36.063]                       invisible(muffled)
[10:25:36.063]                     }
[10:25:36.063]                     muffleCondition(cond, pattern = "^muffle")
[10:25:36.063]                   }
[10:25:36.063]                 }
[10:25:36.063]                 else {
[10:25:36.063]                   if (TRUE) {
[10:25:36.063]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:36.063]                     {
[10:25:36.063]                       inherits <- base::inherits
[10:25:36.063]                       invokeRestart <- base::invokeRestart
[10:25:36.063]                       is.null <- base::is.null
[10:25:36.063]                       muffled <- FALSE
[10:25:36.063]                       if (inherits(cond, "message")) {
[10:25:36.063]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:36.063]                         if (muffled) 
[10:25:36.063]                           invokeRestart("muffleMessage")
[10:25:36.063]                       }
[10:25:36.063]                       else if (inherits(cond, "warning")) {
[10:25:36.063]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:36.063]                         if (muffled) 
[10:25:36.063]                           invokeRestart("muffleWarning")
[10:25:36.063]                       }
[10:25:36.063]                       else if (inherits(cond, "condition")) {
[10:25:36.063]                         if (!is.null(pattern)) {
[10:25:36.063]                           computeRestarts <- base::computeRestarts
[10:25:36.063]                           grepl <- base::grepl
[10:25:36.063]                           restarts <- computeRestarts(cond)
[10:25:36.063]                           for (restart in restarts) {
[10:25:36.063]                             name <- restart$name
[10:25:36.063]                             if (is.null(name)) 
[10:25:36.063]                               next
[10:25:36.063]                             if (!grepl(pattern, name)) 
[10:25:36.063]                               next
[10:25:36.063]                             invokeRestart(restart)
[10:25:36.063]                             muffled <- TRUE
[10:25:36.063]                             break
[10:25:36.063]                           }
[10:25:36.063]                         }
[10:25:36.063]                       }
[10:25:36.063]                       invisible(muffled)
[10:25:36.063]                     }
[10:25:36.063]                     muffleCondition(cond, pattern = "^muffle")
[10:25:36.063]                   }
[10:25:36.063]                 }
[10:25:36.063]             }
[10:25:36.063]         }))
[10:25:36.063]     }, error = function(ex) {
[10:25:36.063]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:36.063]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:36.063]                 ...future.rng), started = ...future.startTime, 
[10:25:36.063]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:36.063]             version = "1.8"), class = "FutureResult")
[10:25:36.063]     }, finally = {
[10:25:36.063]         if (!identical(...future.workdir, getwd())) 
[10:25:36.063]             setwd(...future.workdir)
[10:25:36.063]         {
[10:25:36.063]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:36.063]                 ...future.oldOptions$nwarnings <- NULL
[10:25:36.063]             }
[10:25:36.063]             base::options(...future.oldOptions)
[10:25:36.063]             if (.Platform$OS.type == "windows") {
[10:25:36.063]                 old_names <- names(...future.oldEnvVars)
[10:25:36.063]                 envs <- base::Sys.getenv()
[10:25:36.063]                 names <- names(envs)
[10:25:36.063]                 common <- intersect(names, old_names)
[10:25:36.063]                 added <- setdiff(names, old_names)
[10:25:36.063]                 removed <- setdiff(old_names, names)
[10:25:36.063]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:36.063]                   envs[common]]
[10:25:36.063]                 NAMES <- toupper(changed)
[10:25:36.063]                 args <- list()
[10:25:36.063]                 for (kk in seq_along(NAMES)) {
[10:25:36.063]                   name <- changed[[kk]]
[10:25:36.063]                   NAME <- NAMES[[kk]]
[10:25:36.063]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:36.063]                     next
[10:25:36.063]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:36.063]                 }
[10:25:36.063]                 NAMES <- toupper(added)
[10:25:36.063]                 for (kk in seq_along(NAMES)) {
[10:25:36.063]                   name <- added[[kk]]
[10:25:36.063]                   NAME <- NAMES[[kk]]
[10:25:36.063]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:36.063]                     next
[10:25:36.063]                   args[[name]] <- ""
[10:25:36.063]                 }
[10:25:36.063]                 NAMES <- toupper(removed)
[10:25:36.063]                 for (kk in seq_along(NAMES)) {
[10:25:36.063]                   name <- removed[[kk]]
[10:25:36.063]                   NAME <- NAMES[[kk]]
[10:25:36.063]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:36.063]                     next
[10:25:36.063]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:36.063]                 }
[10:25:36.063]                 if (length(args) > 0) 
[10:25:36.063]                   base::do.call(base::Sys.setenv, args = args)
[10:25:36.063]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:36.063]             }
[10:25:36.063]             else {
[10:25:36.063]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:36.063]             }
[10:25:36.063]             {
[10:25:36.063]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:36.063]                   0L) {
[10:25:36.063]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:36.063]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:36.063]                   base::options(opts)
[10:25:36.063]                 }
[10:25:36.063]                 {
[10:25:36.063]                   {
[10:25:36.063]                     NULL
[10:25:36.063]                     RNGkind("Mersenne-Twister")
[10:25:36.063]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:36.063]                       inherits = FALSE)
[10:25:36.063]                   }
[10:25:36.063]                   options(future.plan = NULL)
[10:25:36.063]                   if (is.na(NA_character_)) 
[10:25:36.063]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:36.063]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:36.063]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:36.063]                   {
[10:25:36.063]                     future <- SequentialFuture(..., envir = envir)
[10:25:36.063]                     if (!future$lazy) 
[10:25:36.063]                       future <- run(future)
[10:25:36.063]                     invisible(future)
[10:25:36.063]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:36.063]                 }
[10:25:36.063]             }
[10:25:36.063]         }
[10:25:36.063]     })
[10:25:36.063]     if (TRUE) {
[10:25:36.063]         base::sink(type = "output", split = FALSE)
[10:25:36.063]         if (TRUE) {
[10:25:36.063]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:36.063]         }
[10:25:36.063]         else {
[10:25:36.063]             ...future.result["stdout"] <- base::list(NULL)
[10:25:36.063]         }
[10:25:36.063]         base::close(...future.stdout)
[10:25:36.063]         ...future.stdout <- NULL
[10:25:36.063]     }
[10:25:36.063]     ...future.result$conditions <- ...future.conditions
[10:25:36.063]     ...future.result$finished <- base::Sys.time()
[10:25:36.063]     ...future.result
[10:25:36.063] }
[10:25:36.065] assign_globals() ...
[10:25:36.065] List of 2
[10:25:36.065]  $ rr: int 2
[10:25:36.065]  $ cc: int 1
[10:25:36.065]  - attr(*, "where")=List of 2
[10:25:36.065]   ..$ rr:<environment: R_EmptyEnv> 
[10:25:36.065]   ..$ cc:<environment: R_EmptyEnv> 
[10:25:36.065]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:36.065]  - attr(*, "resolved")= logi FALSE
[10:25:36.065]  - attr(*, "total_size")= num 112
[10:25:36.065]  - attr(*, "already-done")= logi TRUE
[10:25:36.070] - copied ‘rr’ to environment
[10:25:36.070] - copied ‘cc’ to environment
[10:25:36.070] assign_globals() ... done
[10:25:36.070] plan(): Setting new future strategy stack:
[10:25:36.070] List of future strategies:
[10:25:36.070] 1. sequential:
[10:25:36.070]    - args: function (..., envir = parent.frame())
[10:25:36.070]    - tweaked: FALSE
[10:25:36.070]    - call: NULL
[10:25:36.071] plan(): nbrOfWorkers() = 1
[10:25:36.071] plan(): Setting new future strategy stack:
[10:25:36.071] List of future strategies:
[10:25:36.071] 1. sequential:
[10:25:36.071]    - args: function (..., envir = parent.frame())
[10:25:36.071]    - tweaked: FALSE
[10:25:36.071]    - call: future::plan("sequential")
[10:25:36.072] plan(): nbrOfWorkers() = 1
[10:25:36.072] SequentialFuture started (and completed)
[10:25:36.072] - Launch lazy future ... done
[10:25:36.072] run() for ‘SequentialFuture’ ... done
[10:25:36.072] run() for ‘Future’ ...
[10:25:36.072] - state: ‘created’
[10:25:36.073] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:36.073] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:36.073] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:36.073]   - Field: ‘label’
[10:25:36.073]   - Field: ‘local’
[10:25:36.073]   - Field: ‘owner’
[10:25:36.073]   - Field: ‘envir’
[10:25:36.074]   - Field: ‘packages’
[10:25:36.074]   - Field: ‘gc’
[10:25:36.074]   - Field: ‘conditions’
[10:25:36.074]   - Field: ‘expr’
[10:25:36.074]   - Field: ‘uuid’
[10:25:36.074]   - Field: ‘seed’
[10:25:36.074]   - Field: ‘version’
[10:25:36.074]   - Field: ‘result’
[10:25:36.074]   - Field: ‘asynchronous’
[10:25:36.074]   - Field: ‘calls’
[10:25:36.075]   - Field: ‘globals’
[10:25:36.075]   - Field: ‘stdout’
[10:25:36.075]   - Field: ‘earlySignal’
[10:25:36.075]   - Field: ‘lazy’
[10:25:36.075]   - Field: ‘state’
[10:25:36.075] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:36.075] - Launch lazy future ...
[10:25:36.075] Packages needed by the future expression (n = 0): <none>
[10:25:36.075] Packages needed by future strategies (n = 0): <none>
[10:25:36.076] {
[10:25:36.076]     {
[10:25:36.076]         {
[10:25:36.076]             ...future.startTime <- base::Sys.time()
[10:25:36.076]             {
[10:25:36.076]                 {
[10:25:36.076]                   {
[10:25:36.076]                     base::local({
[10:25:36.076]                       has_future <- base::requireNamespace("future", 
[10:25:36.076]                         quietly = TRUE)
[10:25:36.076]                       if (has_future) {
[10:25:36.076]                         ns <- base::getNamespace("future")
[10:25:36.076]                         version <- ns[[".package"]][["version"]]
[10:25:36.076]                         if (is.null(version)) 
[10:25:36.076]                           version <- utils::packageVersion("future")
[10:25:36.076]                       }
[10:25:36.076]                       else {
[10:25:36.076]                         version <- NULL
[10:25:36.076]                       }
[10:25:36.076]                       if (!has_future || version < "1.8.0") {
[10:25:36.076]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:36.076]                           "", base::R.version$version.string), 
[10:25:36.076]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:36.076]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:36.076]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:36.076]                             "release", "version")], collapse = " "), 
[10:25:36.076]                           hostname = base::Sys.info()[["nodename"]])
[10:25:36.076]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:36.076]                           info)
[10:25:36.076]                         info <- base::paste(info, collapse = "; ")
[10:25:36.076]                         if (!has_future) {
[10:25:36.076]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:36.076]                             info)
[10:25:36.076]                         }
[10:25:36.076]                         else {
[10:25:36.076]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:36.076]                             info, version)
[10:25:36.076]                         }
[10:25:36.076]                         base::stop(msg)
[10:25:36.076]                       }
[10:25:36.076]                     })
[10:25:36.076]                   }
[10:25:36.076]                   options(future.plan = NULL)
[10:25:36.076]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:36.076]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:36.076]                 }
[10:25:36.076]                 ...future.workdir <- getwd()
[10:25:36.076]             }
[10:25:36.076]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:36.076]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:36.076]         }
[10:25:36.076]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:36.076]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:36.076]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:36.076]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:36.076]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:36.076]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:36.076]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:36.076]             base::names(...future.oldOptions))
[10:25:36.076]     }
[10:25:36.076]     if (FALSE) {
[10:25:36.076]     }
[10:25:36.076]     else {
[10:25:36.076]         if (TRUE) {
[10:25:36.076]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:36.076]                 open = "w")
[10:25:36.076]         }
[10:25:36.076]         else {
[10:25:36.076]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:36.076]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:36.076]         }
[10:25:36.076]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:36.076]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:36.076]             base::sink(type = "output", split = FALSE)
[10:25:36.076]             base::close(...future.stdout)
[10:25:36.076]         }, add = TRUE)
[10:25:36.076]     }
[10:25:36.076]     ...future.frame <- base::sys.nframe()
[10:25:36.076]     ...future.conditions <- base::list()
[10:25:36.076]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:36.076]     if (FALSE) {
[10:25:36.076]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:36.076]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:36.076]     }
[10:25:36.076]     ...future.result <- base::tryCatch({
[10:25:36.076]         base::withCallingHandlers({
[10:25:36.076]             ...future.value <- base::withVisible(base::local(sprintf("(%s, %s)", 
[10:25:36.076]                 rr, cc)))
[10:25:36.076]             future::FutureResult(value = ...future.value$value, 
[10:25:36.076]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:36.076]                   ...future.rng), globalenv = if (FALSE) 
[10:25:36.076]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:36.076]                     ...future.globalenv.names))
[10:25:36.076]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:36.076]         }, condition = base::local({
[10:25:36.076]             c <- base::c
[10:25:36.076]             inherits <- base::inherits
[10:25:36.076]             invokeRestart <- base::invokeRestart
[10:25:36.076]             length <- base::length
[10:25:36.076]             list <- base::list
[10:25:36.076]             seq.int <- base::seq.int
[10:25:36.076]             signalCondition <- base::signalCondition
[10:25:36.076]             sys.calls <- base::sys.calls
[10:25:36.076]             `[[` <- base::`[[`
[10:25:36.076]             `+` <- base::`+`
[10:25:36.076]             `<<-` <- base::`<<-`
[10:25:36.076]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:36.076]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:36.076]                   3L)]
[10:25:36.076]             }
[10:25:36.076]             function(cond) {
[10:25:36.076]                 is_error <- inherits(cond, "error")
[10:25:36.076]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:36.076]                   NULL)
[10:25:36.076]                 if (is_error) {
[10:25:36.076]                   sessionInformation <- function() {
[10:25:36.076]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:36.076]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:36.076]                       search = base::search(), system = base::Sys.info())
[10:25:36.076]                   }
[10:25:36.076]                   ...future.conditions[[length(...future.conditions) + 
[10:25:36.076]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:36.076]                     cond$call), session = sessionInformation(), 
[10:25:36.076]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:36.076]                   signalCondition(cond)
[10:25:36.076]                 }
[10:25:36.076]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:36.076]                 "immediateCondition"))) {
[10:25:36.076]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:36.076]                   ...future.conditions[[length(...future.conditions) + 
[10:25:36.076]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:36.076]                   if (TRUE && !signal) {
[10:25:36.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:36.076]                     {
[10:25:36.076]                       inherits <- base::inherits
[10:25:36.076]                       invokeRestart <- base::invokeRestart
[10:25:36.076]                       is.null <- base::is.null
[10:25:36.076]                       muffled <- FALSE
[10:25:36.076]                       if (inherits(cond, "message")) {
[10:25:36.076]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:36.076]                         if (muffled) 
[10:25:36.076]                           invokeRestart("muffleMessage")
[10:25:36.076]                       }
[10:25:36.076]                       else if (inherits(cond, "warning")) {
[10:25:36.076]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:36.076]                         if (muffled) 
[10:25:36.076]                           invokeRestart("muffleWarning")
[10:25:36.076]                       }
[10:25:36.076]                       else if (inherits(cond, "condition")) {
[10:25:36.076]                         if (!is.null(pattern)) {
[10:25:36.076]                           computeRestarts <- base::computeRestarts
[10:25:36.076]                           grepl <- base::grepl
[10:25:36.076]                           restarts <- computeRestarts(cond)
[10:25:36.076]                           for (restart in restarts) {
[10:25:36.076]                             name <- restart$name
[10:25:36.076]                             if (is.null(name)) 
[10:25:36.076]                               next
[10:25:36.076]                             if (!grepl(pattern, name)) 
[10:25:36.076]                               next
[10:25:36.076]                             invokeRestart(restart)
[10:25:36.076]                             muffled <- TRUE
[10:25:36.076]                             break
[10:25:36.076]                           }
[10:25:36.076]                         }
[10:25:36.076]                       }
[10:25:36.076]                       invisible(muffled)
[10:25:36.076]                     }
[10:25:36.076]                     muffleCondition(cond, pattern = "^muffle")
[10:25:36.076]                   }
[10:25:36.076]                 }
[10:25:36.076]                 else {
[10:25:36.076]                   if (TRUE) {
[10:25:36.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:36.076]                     {
[10:25:36.076]                       inherits <- base::inherits
[10:25:36.076]                       invokeRestart <- base::invokeRestart
[10:25:36.076]                       is.null <- base::is.null
[10:25:36.076]                       muffled <- FALSE
[10:25:36.076]                       if (inherits(cond, "message")) {
[10:25:36.076]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:36.076]                         if (muffled) 
[10:25:36.076]                           invokeRestart("muffleMessage")
[10:25:36.076]                       }
[10:25:36.076]                       else if (inherits(cond, "warning")) {
[10:25:36.076]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:36.076]                         if (muffled) 
[10:25:36.076]                           invokeRestart("muffleWarning")
[10:25:36.076]                       }
[10:25:36.076]                       else if (inherits(cond, "condition")) {
[10:25:36.076]                         if (!is.null(pattern)) {
[10:25:36.076]                           computeRestarts <- base::computeRestarts
[10:25:36.076]                           grepl <- base::grepl
[10:25:36.076]                           restarts <- computeRestarts(cond)
[10:25:36.076]                           for (restart in restarts) {
[10:25:36.076]                             name <- restart$name
[10:25:36.076]                             if (is.null(name)) 
[10:25:36.076]                               next
[10:25:36.076]                             if (!grepl(pattern, name)) 
[10:25:36.076]                               next
[10:25:36.076]                             invokeRestart(restart)
[10:25:36.076]                             muffled <- TRUE
[10:25:36.076]                             break
[10:25:36.076]                           }
[10:25:36.076]                         }
[10:25:36.076]                       }
[10:25:36.076]                       invisible(muffled)
[10:25:36.076]                     }
[10:25:36.076]                     muffleCondition(cond, pattern = "^muffle")
[10:25:36.076]                   }
[10:25:36.076]                 }
[10:25:36.076]             }
[10:25:36.076]         }))
[10:25:36.076]     }, error = function(ex) {
[10:25:36.076]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:36.076]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:36.076]                 ...future.rng), started = ...future.startTime, 
[10:25:36.076]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:36.076]             version = "1.8"), class = "FutureResult")
[10:25:36.076]     }, finally = {
[10:25:36.076]         if (!identical(...future.workdir, getwd())) 
[10:25:36.076]             setwd(...future.workdir)
[10:25:36.076]         {
[10:25:36.076]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:36.076]                 ...future.oldOptions$nwarnings <- NULL
[10:25:36.076]             }
[10:25:36.076]             base::options(...future.oldOptions)
[10:25:36.076]             if (.Platform$OS.type == "windows") {
[10:25:36.076]                 old_names <- names(...future.oldEnvVars)
[10:25:36.076]                 envs <- base::Sys.getenv()
[10:25:36.076]                 names <- names(envs)
[10:25:36.076]                 common <- intersect(names, old_names)
[10:25:36.076]                 added <- setdiff(names, old_names)
[10:25:36.076]                 removed <- setdiff(old_names, names)
[10:25:36.076]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:36.076]                   envs[common]]
[10:25:36.076]                 NAMES <- toupper(changed)
[10:25:36.076]                 args <- list()
[10:25:36.076]                 for (kk in seq_along(NAMES)) {
[10:25:36.076]                   name <- changed[[kk]]
[10:25:36.076]                   NAME <- NAMES[[kk]]
[10:25:36.076]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:36.076]                     next
[10:25:36.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:36.076]                 }
[10:25:36.076]                 NAMES <- toupper(added)
[10:25:36.076]                 for (kk in seq_along(NAMES)) {
[10:25:36.076]                   name <- added[[kk]]
[10:25:36.076]                   NAME <- NAMES[[kk]]
[10:25:36.076]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:36.076]                     next
[10:25:36.076]                   args[[name]] <- ""
[10:25:36.076]                 }
[10:25:36.076]                 NAMES <- toupper(removed)
[10:25:36.076]                 for (kk in seq_along(NAMES)) {
[10:25:36.076]                   name <- removed[[kk]]
[10:25:36.076]                   NAME <- NAMES[[kk]]
[10:25:36.076]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:36.076]                     next
[10:25:36.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:36.076]                 }
[10:25:36.076]                 if (length(args) > 0) 
[10:25:36.076]                   base::do.call(base::Sys.setenv, args = args)
[10:25:36.076]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:36.076]             }
[10:25:36.076]             else {
[10:25:36.076]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:36.076]             }
[10:25:36.076]             {
[10:25:36.076]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:36.076]                   0L) {
[10:25:36.076]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:36.076]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:36.076]                   base::options(opts)
[10:25:36.076]                 }
[10:25:36.076]                 {
[10:25:36.076]                   {
[10:25:36.076]                     NULL
[10:25:36.076]                     RNGkind("Mersenne-Twister")
[10:25:36.076]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:36.076]                       inherits = FALSE)
[10:25:36.076]                   }
[10:25:36.076]                   options(future.plan = NULL)
[10:25:36.076]                   if (is.na(NA_character_)) 
[10:25:36.076]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:36.076]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:36.076]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:36.076]                   {
[10:25:36.076]                     future <- SequentialFuture(..., envir = envir)
[10:25:36.076]                     if (!future$lazy) 
[10:25:36.076]                       future <- run(future)
[10:25:36.076]                     invisible(future)
[10:25:36.076]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:36.076]                 }
[10:25:36.076]             }
[10:25:36.076]         }
[10:25:36.076]     })
[10:25:36.076]     if (TRUE) {
[10:25:36.076]         base::sink(type = "output", split = FALSE)
[10:25:36.076]         if (TRUE) {
[10:25:36.076]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:36.076]         }
[10:25:36.076]         else {
[10:25:36.076]             ...future.result["stdout"] <- base::list(NULL)
[10:25:36.076]         }
[10:25:36.076]         base::close(...future.stdout)
[10:25:36.076]         ...future.stdout <- NULL
[10:25:36.076]     }
[10:25:36.076]     ...future.result$conditions <- ...future.conditions
[10:25:36.076]     ...future.result$finished <- base::Sys.time()
[10:25:36.076]     ...future.result
[10:25:36.076] }
[10:25:36.077] assign_globals() ...
[10:25:36.078] List of 2
[10:25:36.078]  $ rr: int 3
[10:25:36.078]  $ cc: int 1
[10:25:36.078]  - attr(*, "where")=List of 2
[10:25:36.078]   ..$ rr:<environment: R_EmptyEnv> 
[10:25:36.078]   ..$ cc:<environment: R_EmptyEnv> 
[10:25:36.078]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:36.078]  - attr(*, "resolved")= logi FALSE
[10:25:36.078]  - attr(*, "total_size")= num 112
[10:25:36.078]  - attr(*, "already-done")= logi TRUE
[10:25:36.080] - copied ‘rr’ to environment
[10:25:36.081] - copied ‘cc’ to environment
[10:25:36.081] assign_globals() ... done
[10:25:36.081] plan(): Setting new future strategy stack:
[10:25:36.081] List of future strategies:
[10:25:36.081] 1. sequential:
[10:25:36.081]    - args: function (..., envir = parent.frame())
[10:25:36.081]    - tweaked: FALSE
[10:25:36.081]    - call: NULL
[10:25:36.081] plan(): nbrOfWorkers() = 1
[10:25:36.082] plan(): Setting new future strategy stack:
[10:25:36.082] List of future strategies:
[10:25:36.082] 1. sequential:
[10:25:36.082]    - args: function (..., envir = parent.frame())
[10:25:36.082]    - tweaked: FALSE
[10:25:36.082]    - call: future::plan("sequential")
[10:25:36.083] plan(): nbrOfWorkers() = 1
[10:25:36.083] SequentialFuture started (and completed)
[10:25:36.083] - Launch lazy future ... done
[10:25:36.083] run() for ‘SequentialFuture’ ... done
[10:25:36.083] run() for ‘Future’ ...
[10:25:36.083] - state: ‘created’
[10:25:36.083] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:36.084] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:36.084] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:36.084]   - Field: ‘label’
[10:25:36.084]   - Field: ‘local’
[10:25:36.084]   - Field: ‘owner’
[10:25:36.084]   - Field: ‘envir’
[10:25:36.084]   - Field: ‘packages’
[10:25:36.084]   - Field: ‘gc’
[10:25:36.084]   - Field: ‘conditions’
[10:25:36.084]   - Field: ‘expr’
[10:25:36.085]   - Field: ‘uuid’
[10:25:36.085]   - Field: ‘seed’
[10:25:36.085]   - Field: ‘version’
[10:25:36.085]   - Field: ‘result’
[10:25:36.085]   - Field: ‘asynchronous’
[10:25:36.085]   - Field: ‘calls’
[10:25:36.085]   - Field: ‘globals’
[10:25:36.085]   - Field: ‘stdout’
[10:25:36.085]   - Field: ‘earlySignal’
[10:25:36.085]   - Field: ‘lazy’
[10:25:36.085]   - Field: ‘state’
[10:25:36.086] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:36.086] - Launch lazy future ...
[10:25:36.086] Packages needed by the future expression (n = 0): <none>
[10:25:36.086] Packages needed by future strategies (n = 0): <none>
[10:25:36.086] {
[10:25:36.086]     {
[10:25:36.086]         {
[10:25:36.086]             ...future.startTime <- base::Sys.time()
[10:25:36.086]             {
[10:25:36.086]                 {
[10:25:36.086]                   {
[10:25:36.086]                     base::local({
[10:25:36.086]                       has_future <- base::requireNamespace("future", 
[10:25:36.086]                         quietly = TRUE)
[10:25:36.086]                       if (has_future) {
[10:25:36.086]                         ns <- base::getNamespace("future")
[10:25:36.086]                         version <- ns[[".package"]][["version"]]
[10:25:36.086]                         if (is.null(version)) 
[10:25:36.086]                           version <- utils::packageVersion("future")
[10:25:36.086]                       }
[10:25:36.086]                       else {
[10:25:36.086]                         version <- NULL
[10:25:36.086]                       }
[10:25:36.086]                       if (!has_future || version < "1.8.0") {
[10:25:36.086]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:36.086]                           "", base::R.version$version.string), 
[10:25:36.086]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:36.086]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:36.086]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:36.086]                             "release", "version")], collapse = " "), 
[10:25:36.086]                           hostname = base::Sys.info()[["nodename"]])
[10:25:36.086]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:36.086]                           info)
[10:25:36.086]                         info <- base::paste(info, collapse = "; ")
[10:25:36.086]                         if (!has_future) {
[10:25:36.086]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:36.086]                             info)
[10:25:36.086]                         }
[10:25:36.086]                         else {
[10:25:36.086]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:36.086]                             info, version)
[10:25:36.086]                         }
[10:25:36.086]                         base::stop(msg)
[10:25:36.086]                       }
[10:25:36.086]                     })
[10:25:36.086]                   }
[10:25:36.086]                   options(future.plan = NULL)
[10:25:36.086]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:36.086]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:36.086]                 }
[10:25:36.086]                 ...future.workdir <- getwd()
[10:25:36.086]             }
[10:25:36.086]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:36.086]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:36.086]         }
[10:25:36.086]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:36.086]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:36.086]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:36.086]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:36.086]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:36.086]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:36.086]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:36.086]             base::names(...future.oldOptions))
[10:25:36.086]     }
[10:25:36.086]     if (FALSE) {
[10:25:36.086]     }
[10:25:36.086]     else {
[10:25:36.086]         if (TRUE) {
[10:25:36.086]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:36.086]                 open = "w")
[10:25:36.086]         }
[10:25:36.086]         else {
[10:25:36.086]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:36.086]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:36.086]         }
[10:25:36.086]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:36.086]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:36.086]             base::sink(type = "output", split = FALSE)
[10:25:36.086]             base::close(...future.stdout)
[10:25:36.086]         }, add = TRUE)
[10:25:36.086]     }
[10:25:36.086]     ...future.frame <- base::sys.nframe()
[10:25:36.086]     ...future.conditions <- base::list()
[10:25:36.086]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:36.086]     if (FALSE) {
[10:25:36.086]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:36.086]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:36.086]     }
[10:25:36.086]     ...future.result <- base::tryCatch({
[10:25:36.086]         base::withCallingHandlers({
[10:25:36.086]             ...future.value <- base::withVisible(base::local(sprintf("(%s, %s)", 
[10:25:36.086]                 rr, cc)))
[10:25:36.086]             future::FutureResult(value = ...future.value$value, 
[10:25:36.086]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:36.086]                   ...future.rng), globalenv = if (FALSE) 
[10:25:36.086]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:36.086]                     ...future.globalenv.names))
[10:25:36.086]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:36.086]         }, condition = base::local({
[10:25:36.086]             c <- base::c
[10:25:36.086]             inherits <- base::inherits
[10:25:36.086]             invokeRestart <- base::invokeRestart
[10:25:36.086]             length <- base::length
[10:25:36.086]             list <- base::list
[10:25:36.086]             seq.int <- base::seq.int
[10:25:36.086]             signalCondition <- base::signalCondition
[10:25:36.086]             sys.calls <- base::sys.calls
[10:25:36.086]             `[[` <- base::`[[`
[10:25:36.086]             `+` <- base::`+`
[10:25:36.086]             `<<-` <- base::`<<-`
[10:25:36.086]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:36.086]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:36.086]                   3L)]
[10:25:36.086]             }
[10:25:36.086]             function(cond) {
[10:25:36.086]                 is_error <- inherits(cond, "error")
[10:25:36.086]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:36.086]                   NULL)
[10:25:36.086]                 if (is_error) {
[10:25:36.086]                   sessionInformation <- function() {
[10:25:36.086]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:36.086]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:36.086]                       search = base::search(), system = base::Sys.info())
[10:25:36.086]                   }
[10:25:36.086]                   ...future.conditions[[length(...future.conditions) + 
[10:25:36.086]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:36.086]                     cond$call), session = sessionInformation(), 
[10:25:36.086]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:36.086]                   signalCondition(cond)
[10:25:36.086]                 }
[10:25:36.086]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:36.086]                 "immediateCondition"))) {
[10:25:36.086]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:36.086]                   ...future.conditions[[length(...future.conditions) + 
[10:25:36.086]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:36.086]                   if (TRUE && !signal) {
[10:25:36.086]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:36.086]                     {
[10:25:36.086]                       inherits <- base::inherits
[10:25:36.086]                       invokeRestart <- base::invokeRestart
[10:25:36.086]                       is.null <- base::is.null
[10:25:36.086]                       muffled <- FALSE
[10:25:36.086]                       if (inherits(cond, "message")) {
[10:25:36.086]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:36.086]                         if (muffled) 
[10:25:36.086]                           invokeRestart("muffleMessage")
[10:25:36.086]                       }
[10:25:36.086]                       else if (inherits(cond, "warning")) {
[10:25:36.086]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:36.086]                         if (muffled) 
[10:25:36.086]                           invokeRestart("muffleWarning")
[10:25:36.086]                       }
[10:25:36.086]                       else if (inherits(cond, "condition")) {
[10:25:36.086]                         if (!is.null(pattern)) {
[10:25:36.086]                           computeRestarts <- base::computeRestarts
[10:25:36.086]                           grepl <- base::grepl
[10:25:36.086]                           restarts <- computeRestarts(cond)
[10:25:36.086]                           for (restart in restarts) {
[10:25:36.086]                             name <- restart$name
[10:25:36.086]                             if (is.null(name)) 
[10:25:36.086]                               next
[10:25:36.086]                             if (!grepl(pattern, name)) 
[10:25:36.086]                               next
[10:25:36.086]                             invokeRestart(restart)
[10:25:36.086]                             muffled <- TRUE
[10:25:36.086]                             break
[10:25:36.086]                           }
[10:25:36.086]                         }
[10:25:36.086]                       }
[10:25:36.086]                       invisible(muffled)
[10:25:36.086]                     }
[10:25:36.086]                     muffleCondition(cond, pattern = "^muffle")
[10:25:36.086]                   }
[10:25:36.086]                 }
[10:25:36.086]                 else {
[10:25:36.086]                   if (TRUE) {
[10:25:36.086]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:36.086]                     {
[10:25:36.086]                       inherits <- base::inherits
[10:25:36.086]                       invokeRestart <- base::invokeRestart
[10:25:36.086]                       is.null <- base::is.null
[10:25:36.086]                       muffled <- FALSE
[10:25:36.086]                       if (inherits(cond, "message")) {
[10:25:36.086]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:36.086]                         if (muffled) 
[10:25:36.086]                           invokeRestart("muffleMessage")
[10:25:36.086]                       }
[10:25:36.086]                       else if (inherits(cond, "warning")) {
[10:25:36.086]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:36.086]                         if (muffled) 
[10:25:36.086]                           invokeRestart("muffleWarning")
[10:25:36.086]                       }
[10:25:36.086]                       else if (inherits(cond, "condition")) {
[10:25:36.086]                         if (!is.null(pattern)) {
[10:25:36.086]                           computeRestarts <- base::computeRestarts
[10:25:36.086]                           grepl <- base::grepl
[10:25:36.086]                           restarts <- computeRestarts(cond)
[10:25:36.086]                           for (restart in restarts) {
[10:25:36.086]                             name <- restart$name
[10:25:36.086]                             if (is.null(name)) 
[10:25:36.086]                               next
[10:25:36.086]                             if (!grepl(pattern, name)) 
[10:25:36.086]                               next
[10:25:36.086]                             invokeRestart(restart)
[10:25:36.086]                             muffled <- TRUE
[10:25:36.086]                             break
[10:25:36.086]                           }
[10:25:36.086]                         }
[10:25:36.086]                       }
[10:25:36.086]                       invisible(muffled)
[10:25:36.086]                     }
[10:25:36.086]                     muffleCondition(cond, pattern = "^muffle")
[10:25:36.086]                   }
[10:25:36.086]                 }
[10:25:36.086]             }
[10:25:36.086]         }))
[10:25:36.086]     }, error = function(ex) {
[10:25:36.086]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:36.086]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:36.086]                 ...future.rng), started = ...future.startTime, 
[10:25:36.086]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:36.086]             version = "1.8"), class = "FutureResult")
[10:25:36.086]     }, finally = {
[10:25:36.086]         if (!identical(...future.workdir, getwd())) 
[10:25:36.086]             setwd(...future.workdir)
[10:25:36.086]         {
[10:25:36.086]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:36.086]                 ...future.oldOptions$nwarnings <- NULL
[10:25:36.086]             }
[10:25:36.086]             base::options(...future.oldOptions)
[10:25:36.086]             if (.Platform$OS.type == "windows") {
[10:25:36.086]                 old_names <- names(...future.oldEnvVars)
[10:25:36.086]                 envs <- base::Sys.getenv()
[10:25:36.086]                 names <- names(envs)
[10:25:36.086]                 common <- intersect(names, old_names)
[10:25:36.086]                 added <- setdiff(names, old_names)
[10:25:36.086]                 removed <- setdiff(old_names, names)
[10:25:36.086]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:36.086]                   envs[common]]
[10:25:36.086]                 NAMES <- toupper(changed)
[10:25:36.086]                 args <- list()
[10:25:36.086]                 for (kk in seq_along(NAMES)) {
[10:25:36.086]                   name <- changed[[kk]]
[10:25:36.086]                   NAME <- NAMES[[kk]]
[10:25:36.086]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:36.086]                     next
[10:25:36.086]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:36.086]                 }
[10:25:36.086]                 NAMES <- toupper(added)
[10:25:36.086]                 for (kk in seq_along(NAMES)) {
[10:25:36.086]                   name <- added[[kk]]
[10:25:36.086]                   NAME <- NAMES[[kk]]
[10:25:36.086]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:36.086]                     next
[10:25:36.086]                   args[[name]] <- ""
[10:25:36.086]                 }
[10:25:36.086]                 NAMES <- toupper(removed)
[10:25:36.086]                 for (kk in seq_along(NAMES)) {
[10:25:36.086]                   name <- removed[[kk]]
[10:25:36.086]                   NAME <- NAMES[[kk]]
[10:25:36.086]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:36.086]                     next
[10:25:36.086]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:36.086]                 }
[10:25:36.086]                 if (length(args) > 0) 
[10:25:36.086]                   base::do.call(base::Sys.setenv, args = args)
[10:25:36.086]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:36.086]             }
[10:25:36.086]             else {
[10:25:36.086]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:36.086]             }
[10:25:36.086]             {
[10:25:36.086]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:36.086]                   0L) {
[10:25:36.086]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:36.086]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:36.086]                   base::options(opts)
[10:25:36.086]                 }
[10:25:36.086]                 {
[10:25:36.086]                   {
[10:25:36.086]                     NULL
[10:25:36.086]                     RNGkind("Mersenne-Twister")
[10:25:36.086]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:36.086]                       inherits = FALSE)
[10:25:36.086]                   }
[10:25:36.086]                   options(future.plan = NULL)
[10:25:36.086]                   if (is.na(NA_character_)) 
[10:25:36.086]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:36.086]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:36.086]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:36.086]                   {
[10:25:36.086]                     future <- SequentialFuture(..., envir = envir)
[10:25:36.086]                     if (!future$lazy) 
[10:25:36.086]                       future <- run(future)
[10:25:36.086]                     invisible(future)
[10:25:36.086]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:36.086]                 }
[10:25:36.086]             }
[10:25:36.086]         }
[10:25:36.086]     })
[10:25:36.086]     if (TRUE) {
[10:25:36.086]         base::sink(type = "output", split = FALSE)
[10:25:36.086]         if (TRUE) {
[10:25:36.086]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:36.086]         }
[10:25:36.086]         else {
[10:25:36.086]             ...future.result["stdout"] <- base::list(NULL)
[10:25:36.086]         }
[10:25:36.086]         base::close(...future.stdout)
[10:25:36.086]         ...future.stdout <- NULL
[10:25:36.086]     }
[10:25:36.086]     ...future.result$conditions <- ...future.conditions
[10:25:36.086]     ...future.result$finished <- base::Sys.time()
[10:25:36.086]     ...future.result
[10:25:36.086] }
[10:25:36.088] assign_globals() ...
[10:25:36.088] List of 2
[10:25:36.088]  $ rr: int 1
[10:25:36.088]  $ cc: int 2
[10:25:36.088]  - attr(*, "where")=List of 2
[10:25:36.088]   ..$ rr:<environment: R_EmptyEnv> 
[10:25:36.088]   ..$ cc:<environment: R_EmptyEnv> 
[10:25:36.088]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:36.088]  - attr(*, "resolved")= logi FALSE
[10:25:36.088]  - attr(*, "total_size")= num 112
[10:25:36.088]  - attr(*, "already-done")= logi TRUE
[10:25:36.091] - copied ‘rr’ to environment
[10:25:36.091] - copied ‘cc’ to environment
[10:25:36.091] assign_globals() ... done
[10:25:36.091] plan(): Setting new future strategy stack:
[10:25:36.092] List of future strategies:
[10:25:36.092] 1. sequential:
[10:25:36.092]    - args: function (..., envir = parent.frame())
[10:25:36.092]    - tweaked: FALSE
[10:25:36.092]    - call: NULL
[10:25:36.092] plan(): nbrOfWorkers() = 1
[10:25:36.093] plan(): Setting new future strategy stack:
[10:25:36.093] List of future strategies:
[10:25:36.093] 1. sequential:
[10:25:36.093]    - args: function (..., envir = parent.frame())
[10:25:36.093]    - tweaked: FALSE
[10:25:36.093]    - call: future::plan("sequential")
[10:25:36.093] plan(): nbrOfWorkers() = 1
[10:25:36.093] SequentialFuture started (and completed)
[10:25:36.093] - Launch lazy future ... done
[10:25:36.093] run() for ‘SequentialFuture’ ... done
[10:25:36.094] run() for ‘Future’ ...
[10:25:36.094] - state: ‘created’
[10:25:36.094] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:36.094] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:36.094] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:36.094]   - Field: ‘label’
[10:25:36.094]   - Field: ‘local’
[10:25:36.094]   - Field: ‘owner’
[10:25:36.095]   - Field: ‘envir’
[10:25:36.095]   - Field: ‘packages’
[10:25:36.095]   - Field: ‘gc’
[10:25:36.095]   - Field: ‘conditions’
[10:25:36.095]   - Field: ‘expr’
[10:25:36.095]   - Field: ‘uuid’
[10:25:36.095]   - Field: ‘seed’
[10:25:36.095]   - Field: ‘version’
[10:25:36.095]   - Field: ‘result’
[10:25:36.095]   - Field: ‘asynchronous’
[10:25:36.095]   - Field: ‘calls’
[10:25:36.096]   - Field: ‘globals’
[10:25:36.096]   - Field: ‘stdout’
[10:25:36.096]   - Field: ‘earlySignal’
[10:25:36.096]   - Field: ‘lazy’
[10:25:36.096]   - Field: ‘state’
[10:25:36.096] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:36.096] - Launch lazy future ...
[10:25:36.096] Packages needed by the future expression (n = 0): <none>
[10:25:36.096] Packages needed by future strategies (n = 0): <none>
[10:25:36.098] {
[10:25:36.098]     {
[10:25:36.098]         {
[10:25:36.098]             ...future.startTime <- base::Sys.time()
[10:25:36.098]             {
[10:25:36.098]                 {
[10:25:36.098]                   {
[10:25:36.098]                     base::local({
[10:25:36.098]                       has_future <- base::requireNamespace("future", 
[10:25:36.098]                         quietly = TRUE)
[10:25:36.098]                       if (has_future) {
[10:25:36.098]                         ns <- base::getNamespace("future")
[10:25:36.098]                         version <- ns[[".package"]][["version"]]
[10:25:36.098]                         if (is.null(version)) 
[10:25:36.098]                           version <- utils::packageVersion("future")
[10:25:36.098]                       }
[10:25:36.098]                       else {
[10:25:36.098]                         version <- NULL
[10:25:36.098]                       }
[10:25:36.098]                       if (!has_future || version < "1.8.0") {
[10:25:36.098]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:36.098]                           "", base::R.version$version.string), 
[10:25:36.098]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:36.098]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:36.098]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:36.098]                             "release", "version")], collapse = " "), 
[10:25:36.098]                           hostname = base::Sys.info()[["nodename"]])
[10:25:36.098]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:36.098]                           info)
[10:25:36.098]                         info <- base::paste(info, collapse = "; ")
[10:25:36.098]                         if (!has_future) {
[10:25:36.098]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:36.098]                             info)
[10:25:36.098]                         }
[10:25:36.098]                         else {
[10:25:36.098]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:36.098]                             info, version)
[10:25:36.098]                         }
[10:25:36.098]                         base::stop(msg)
[10:25:36.098]                       }
[10:25:36.098]                     })
[10:25:36.098]                   }
[10:25:36.098]                   options(future.plan = NULL)
[10:25:36.098]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:36.098]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:36.098]                 }
[10:25:36.098]                 ...future.workdir <- getwd()
[10:25:36.098]             }
[10:25:36.098]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:36.098]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:36.098]         }
[10:25:36.098]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:36.098]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:36.098]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:36.098]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:36.098]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:36.098]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:36.098]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:36.098]             base::names(...future.oldOptions))
[10:25:36.098]     }
[10:25:36.098]     if (FALSE) {
[10:25:36.098]     }
[10:25:36.098]     else {
[10:25:36.098]         if (TRUE) {
[10:25:36.098]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:36.098]                 open = "w")
[10:25:36.098]         }
[10:25:36.098]         else {
[10:25:36.098]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:36.098]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:36.098]         }
[10:25:36.098]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:36.098]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:36.098]             base::sink(type = "output", split = FALSE)
[10:25:36.098]             base::close(...future.stdout)
[10:25:36.098]         }, add = TRUE)
[10:25:36.098]     }
[10:25:36.098]     ...future.frame <- base::sys.nframe()
[10:25:36.098]     ...future.conditions <- base::list()
[10:25:36.098]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:36.098]     if (FALSE) {
[10:25:36.098]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:36.098]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:36.098]     }
[10:25:36.098]     ...future.result <- base::tryCatch({
[10:25:36.098]         base::withCallingHandlers({
[10:25:36.098]             ...future.value <- base::withVisible(base::local(sprintf("(%s, %s)", 
[10:25:36.098]                 rr, cc)))
[10:25:36.098]             future::FutureResult(value = ...future.value$value, 
[10:25:36.098]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:36.098]                   ...future.rng), globalenv = if (FALSE) 
[10:25:36.098]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:36.098]                     ...future.globalenv.names))
[10:25:36.098]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:36.098]         }, condition = base::local({
[10:25:36.098]             c <- base::c
[10:25:36.098]             inherits <- base::inherits
[10:25:36.098]             invokeRestart <- base::invokeRestart
[10:25:36.098]             length <- base::length
[10:25:36.098]             list <- base::list
[10:25:36.098]             seq.int <- base::seq.int
[10:25:36.098]             signalCondition <- base::signalCondition
[10:25:36.098]             sys.calls <- base::sys.calls
[10:25:36.098]             `[[` <- base::`[[`
[10:25:36.098]             `+` <- base::`+`
[10:25:36.098]             `<<-` <- base::`<<-`
[10:25:36.098]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:36.098]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:36.098]                   3L)]
[10:25:36.098]             }
[10:25:36.098]             function(cond) {
[10:25:36.098]                 is_error <- inherits(cond, "error")
[10:25:36.098]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:36.098]                   NULL)
[10:25:36.098]                 if (is_error) {
[10:25:36.098]                   sessionInformation <- function() {
[10:25:36.098]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:36.098]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:36.098]                       search = base::search(), system = base::Sys.info())
[10:25:36.098]                   }
[10:25:36.098]                   ...future.conditions[[length(...future.conditions) + 
[10:25:36.098]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:36.098]                     cond$call), session = sessionInformation(), 
[10:25:36.098]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:36.098]                   signalCondition(cond)
[10:25:36.098]                 }
[10:25:36.098]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:36.098]                 "immediateCondition"))) {
[10:25:36.098]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:36.098]                   ...future.conditions[[length(...future.conditions) + 
[10:25:36.098]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:36.098]                   if (TRUE && !signal) {
[10:25:36.098]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:36.098]                     {
[10:25:36.098]                       inherits <- base::inherits
[10:25:36.098]                       invokeRestart <- base::invokeRestart
[10:25:36.098]                       is.null <- base::is.null
[10:25:36.098]                       muffled <- FALSE
[10:25:36.098]                       if (inherits(cond, "message")) {
[10:25:36.098]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:36.098]                         if (muffled) 
[10:25:36.098]                           invokeRestart("muffleMessage")
[10:25:36.098]                       }
[10:25:36.098]                       else if (inherits(cond, "warning")) {
[10:25:36.098]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:36.098]                         if (muffled) 
[10:25:36.098]                           invokeRestart("muffleWarning")
[10:25:36.098]                       }
[10:25:36.098]                       else if (inherits(cond, "condition")) {
[10:25:36.098]                         if (!is.null(pattern)) {
[10:25:36.098]                           computeRestarts <- base::computeRestarts
[10:25:36.098]                           grepl <- base::grepl
[10:25:36.098]                           restarts <- computeRestarts(cond)
[10:25:36.098]                           for (restart in restarts) {
[10:25:36.098]                             name <- restart$name
[10:25:36.098]                             if (is.null(name)) 
[10:25:36.098]                               next
[10:25:36.098]                             if (!grepl(pattern, name)) 
[10:25:36.098]                               next
[10:25:36.098]                             invokeRestart(restart)
[10:25:36.098]                             muffled <- TRUE
[10:25:36.098]                             break
[10:25:36.098]                           }
[10:25:36.098]                         }
[10:25:36.098]                       }
[10:25:36.098]                       invisible(muffled)
[10:25:36.098]                     }
[10:25:36.098]                     muffleCondition(cond, pattern = "^muffle")
[10:25:36.098]                   }
[10:25:36.098]                 }
[10:25:36.098]                 else {
[10:25:36.098]                   if (TRUE) {
[10:25:36.098]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:36.098]                     {
[10:25:36.098]                       inherits <- base::inherits
[10:25:36.098]                       invokeRestart <- base::invokeRestart
[10:25:36.098]                       is.null <- base::is.null
[10:25:36.098]                       muffled <- FALSE
[10:25:36.098]                       if (inherits(cond, "message")) {
[10:25:36.098]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:36.098]                         if (muffled) 
[10:25:36.098]                           invokeRestart("muffleMessage")
[10:25:36.098]                       }
[10:25:36.098]                       else if (inherits(cond, "warning")) {
[10:25:36.098]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:36.098]                         if (muffled) 
[10:25:36.098]                           invokeRestart("muffleWarning")
[10:25:36.098]                       }
[10:25:36.098]                       else if (inherits(cond, "condition")) {
[10:25:36.098]                         if (!is.null(pattern)) {
[10:25:36.098]                           computeRestarts <- base::computeRestarts
[10:25:36.098]                           grepl <- base::grepl
[10:25:36.098]                           restarts <- computeRestarts(cond)
[10:25:36.098]                           for (restart in restarts) {
[10:25:36.098]                             name <- restart$name
[10:25:36.098]                             if (is.null(name)) 
[10:25:36.098]                               next
[10:25:36.098]                             if (!grepl(pattern, name)) 
[10:25:36.098]                               next
[10:25:36.098]                             invokeRestart(restart)
[10:25:36.098]                             muffled <- TRUE
[10:25:36.098]                             break
[10:25:36.098]                           }
[10:25:36.098]                         }
[10:25:36.098]                       }
[10:25:36.098]                       invisible(muffled)
[10:25:36.098]                     }
[10:25:36.098]                     muffleCondition(cond, pattern = "^muffle")
[10:25:36.098]                   }
[10:25:36.098]                 }
[10:25:36.098]             }
[10:25:36.098]         }))
[10:25:36.098]     }, error = function(ex) {
[10:25:36.098]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:36.098]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:36.098]                 ...future.rng), started = ...future.startTime, 
[10:25:36.098]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:36.098]             version = "1.8"), class = "FutureResult")
[10:25:36.098]     }, finally = {
[10:25:36.098]         if (!identical(...future.workdir, getwd())) 
[10:25:36.098]             setwd(...future.workdir)
[10:25:36.098]         {
[10:25:36.098]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:36.098]                 ...future.oldOptions$nwarnings <- NULL
[10:25:36.098]             }
[10:25:36.098]             base::options(...future.oldOptions)
[10:25:36.098]             if (.Platform$OS.type == "windows") {
[10:25:36.098]                 old_names <- names(...future.oldEnvVars)
[10:25:36.098]                 envs <- base::Sys.getenv()
[10:25:36.098]                 names <- names(envs)
[10:25:36.098]                 common <- intersect(names, old_names)
[10:25:36.098]                 added <- setdiff(names, old_names)
[10:25:36.098]                 removed <- setdiff(old_names, names)
[10:25:36.098]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:36.098]                   envs[common]]
[10:25:36.098]                 NAMES <- toupper(changed)
[10:25:36.098]                 args <- list()
[10:25:36.098]                 for (kk in seq_along(NAMES)) {
[10:25:36.098]                   name <- changed[[kk]]
[10:25:36.098]                   NAME <- NAMES[[kk]]
[10:25:36.098]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:36.098]                     next
[10:25:36.098]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:36.098]                 }
[10:25:36.098]                 NAMES <- toupper(added)
[10:25:36.098]                 for (kk in seq_along(NAMES)) {
[10:25:36.098]                   name <- added[[kk]]
[10:25:36.098]                   NAME <- NAMES[[kk]]
[10:25:36.098]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:36.098]                     next
[10:25:36.098]                   args[[name]] <- ""
[10:25:36.098]                 }
[10:25:36.098]                 NAMES <- toupper(removed)
[10:25:36.098]                 for (kk in seq_along(NAMES)) {
[10:25:36.098]                   name <- removed[[kk]]
[10:25:36.098]                   NAME <- NAMES[[kk]]
[10:25:36.098]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:36.098]                     next
[10:25:36.098]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:36.098]                 }
[10:25:36.098]                 if (length(args) > 0) 
[10:25:36.098]                   base::do.call(base::Sys.setenv, args = args)
[10:25:36.098]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:36.098]             }
[10:25:36.098]             else {
[10:25:36.098]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:36.098]             }
[10:25:36.098]             {
[10:25:36.098]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:36.098]                   0L) {
[10:25:36.098]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:36.098]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:36.098]                   base::options(opts)
[10:25:36.098]                 }
[10:25:36.098]                 {
[10:25:36.098]                   {
[10:25:36.098]                     NULL
[10:25:36.098]                     RNGkind("Mersenne-Twister")
[10:25:36.098]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:36.098]                       inherits = FALSE)
[10:25:36.098]                   }
[10:25:36.098]                   options(future.plan = NULL)
[10:25:36.098]                   if (is.na(NA_character_)) 
[10:25:36.098]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:36.098]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:36.098]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:36.098]                   {
[10:25:36.098]                     future <- SequentialFuture(..., envir = envir)
[10:25:36.098]                     if (!future$lazy) 
[10:25:36.098]                       future <- run(future)
[10:25:36.098]                     invisible(future)
[10:25:36.098]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:36.098]                 }
[10:25:36.098]             }
[10:25:36.098]         }
[10:25:36.098]     })
[10:25:36.098]     if (TRUE) {
[10:25:36.098]         base::sink(type = "output", split = FALSE)
[10:25:36.098]         if (TRUE) {
[10:25:36.098]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:36.098]         }
[10:25:36.098]         else {
[10:25:36.098]             ...future.result["stdout"] <- base::list(NULL)
[10:25:36.098]         }
[10:25:36.098]         base::close(...future.stdout)
[10:25:36.098]         ...future.stdout <- NULL
[10:25:36.098]     }
[10:25:36.098]     ...future.result$conditions <- ...future.conditions
[10:25:36.098]     ...future.result$finished <- base::Sys.time()
[10:25:36.098]     ...future.result
[10:25:36.098] }
[10:25:36.100] assign_globals() ...
[10:25:36.100] List of 2
[10:25:36.100]  $ rr: int 2
[10:25:36.100]  $ cc: int 2
[10:25:36.100]  - attr(*, "where")=List of 2
[10:25:36.100]   ..$ rr:<environment: R_EmptyEnv> 
[10:25:36.100]   ..$ cc:<environment: R_EmptyEnv> 
[10:25:36.100]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:36.100]  - attr(*, "resolved")= logi FALSE
[10:25:36.100]  - attr(*, "total_size")= num 112
[10:25:36.100]  - attr(*, "already-done")= logi TRUE
[10:25:36.103] - copied ‘rr’ to environment
[10:25:36.103] - copied ‘cc’ to environment
[10:25:36.103] assign_globals() ... done
[10:25:36.103] plan(): Setting new future strategy stack:
[10:25:36.103] List of future strategies:
[10:25:36.103] 1. sequential:
[10:25:36.103]    - args: function (..., envir = parent.frame())
[10:25:36.103]    - tweaked: FALSE
[10:25:36.103]    - call: NULL
[10:25:36.104] plan(): nbrOfWorkers() = 1
[10:25:36.104] plan(): Setting new future strategy stack:
[10:25:36.104] List of future strategies:
[10:25:36.104] 1. sequential:
[10:25:36.104]    - args: function (..., envir = parent.frame())
[10:25:36.104]    - tweaked: FALSE
[10:25:36.104]    - call: future::plan("sequential")
[10:25:36.105] plan(): nbrOfWorkers() = 1
[10:25:36.105] SequentialFuture started (and completed)
[10:25:36.105] - Launch lazy future ... done
[10:25:36.105] run() for ‘SequentialFuture’ ... done
[10:25:36.105] run() for ‘Future’ ...
[10:25:36.105] - state: ‘created’
[10:25:36.106] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:36.106] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:36.106] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:36.106]   - Field: ‘label’
[10:25:36.106]   - Field: ‘local’
[10:25:36.106]   - Field: ‘owner’
[10:25:36.106]   - Field: ‘envir’
[10:25:36.106]   - Field: ‘packages’
[10:25:36.106]   - Field: ‘gc’
[10:25:36.107]   - Field: ‘conditions’
[10:25:36.107]   - Field: ‘expr’
[10:25:36.107]   - Field: ‘uuid’
[10:25:36.107]   - Field: ‘seed’
[10:25:36.107]   - Field: ‘version’
[10:25:36.107]   - Field: ‘result’
[10:25:36.107]   - Field: ‘asynchronous’
[10:25:36.107]   - Field: ‘calls’
[10:25:36.107]   - Field: ‘globals’
[10:25:36.107]   - Field: ‘stdout’
[10:25:36.107]   - Field: ‘earlySignal’
[10:25:36.108]   - Field: ‘lazy’
[10:25:36.108]   - Field: ‘state’
[10:25:36.108] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:36.108] - Launch lazy future ...
[10:25:36.108] Packages needed by the future expression (n = 0): <none>
[10:25:36.108] Packages needed by future strategies (n = 0): <none>
[10:25:36.108] {
[10:25:36.108]     {
[10:25:36.108]         {
[10:25:36.108]             ...future.startTime <- base::Sys.time()
[10:25:36.108]             {
[10:25:36.108]                 {
[10:25:36.108]                   {
[10:25:36.108]                     base::local({
[10:25:36.108]                       has_future <- base::requireNamespace("future", 
[10:25:36.108]                         quietly = TRUE)
[10:25:36.108]                       if (has_future) {
[10:25:36.108]                         ns <- base::getNamespace("future")
[10:25:36.108]                         version <- ns[[".package"]][["version"]]
[10:25:36.108]                         if (is.null(version)) 
[10:25:36.108]                           version <- utils::packageVersion("future")
[10:25:36.108]                       }
[10:25:36.108]                       else {
[10:25:36.108]                         version <- NULL
[10:25:36.108]                       }
[10:25:36.108]                       if (!has_future || version < "1.8.0") {
[10:25:36.108]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:36.108]                           "", base::R.version$version.string), 
[10:25:36.108]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:36.108]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:36.108]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:36.108]                             "release", "version")], collapse = " "), 
[10:25:36.108]                           hostname = base::Sys.info()[["nodename"]])
[10:25:36.108]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:36.108]                           info)
[10:25:36.108]                         info <- base::paste(info, collapse = "; ")
[10:25:36.108]                         if (!has_future) {
[10:25:36.108]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:36.108]                             info)
[10:25:36.108]                         }
[10:25:36.108]                         else {
[10:25:36.108]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:36.108]                             info, version)
[10:25:36.108]                         }
[10:25:36.108]                         base::stop(msg)
[10:25:36.108]                       }
[10:25:36.108]                     })
[10:25:36.108]                   }
[10:25:36.108]                   options(future.plan = NULL)
[10:25:36.108]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:36.108]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:36.108]                 }
[10:25:36.108]                 ...future.workdir <- getwd()
[10:25:36.108]             }
[10:25:36.108]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:36.108]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:36.108]         }
[10:25:36.108]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:36.108]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:36.108]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:36.108]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:36.108]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:36.108]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:36.108]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:36.108]             base::names(...future.oldOptions))
[10:25:36.108]     }
[10:25:36.108]     if (FALSE) {
[10:25:36.108]     }
[10:25:36.108]     else {
[10:25:36.108]         if (TRUE) {
[10:25:36.108]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:36.108]                 open = "w")
[10:25:36.108]         }
[10:25:36.108]         else {
[10:25:36.108]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:36.108]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:36.108]         }
[10:25:36.108]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:36.108]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:36.108]             base::sink(type = "output", split = FALSE)
[10:25:36.108]             base::close(...future.stdout)
[10:25:36.108]         }, add = TRUE)
[10:25:36.108]     }
[10:25:36.108]     ...future.frame <- base::sys.nframe()
[10:25:36.108]     ...future.conditions <- base::list()
[10:25:36.108]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:36.108]     if (FALSE) {
[10:25:36.108]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:36.108]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:36.108]     }
[10:25:36.108]     ...future.result <- base::tryCatch({
[10:25:36.108]         base::withCallingHandlers({
[10:25:36.108]             ...future.value <- base::withVisible(base::local(sprintf("(%s, %s)", 
[10:25:36.108]                 rr, cc)))
[10:25:36.108]             future::FutureResult(value = ...future.value$value, 
[10:25:36.108]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:36.108]                   ...future.rng), globalenv = if (FALSE) 
[10:25:36.108]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:36.108]                     ...future.globalenv.names))
[10:25:36.108]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:36.108]         }, condition = base::local({
[10:25:36.108]             c <- base::c
[10:25:36.108]             inherits <- base::inherits
[10:25:36.108]             invokeRestart <- base::invokeRestart
[10:25:36.108]             length <- base::length
[10:25:36.108]             list <- base::list
[10:25:36.108]             seq.int <- base::seq.int
[10:25:36.108]             signalCondition <- base::signalCondition
[10:25:36.108]             sys.calls <- base::sys.calls
[10:25:36.108]             `[[` <- base::`[[`
[10:25:36.108]             `+` <- base::`+`
[10:25:36.108]             `<<-` <- base::`<<-`
[10:25:36.108]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:36.108]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:36.108]                   3L)]
[10:25:36.108]             }
[10:25:36.108]             function(cond) {
[10:25:36.108]                 is_error <- inherits(cond, "error")
[10:25:36.108]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:36.108]                   NULL)
[10:25:36.108]                 if (is_error) {
[10:25:36.108]                   sessionInformation <- function() {
[10:25:36.108]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:36.108]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:36.108]                       search = base::search(), system = base::Sys.info())
[10:25:36.108]                   }
[10:25:36.108]                   ...future.conditions[[length(...future.conditions) + 
[10:25:36.108]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:36.108]                     cond$call), session = sessionInformation(), 
[10:25:36.108]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:36.108]                   signalCondition(cond)
[10:25:36.108]                 }
[10:25:36.108]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:36.108]                 "immediateCondition"))) {
[10:25:36.108]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:36.108]                   ...future.conditions[[length(...future.conditions) + 
[10:25:36.108]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:36.108]                   if (TRUE && !signal) {
[10:25:36.108]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:36.108]                     {
[10:25:36.108]                       inherits <- base::inherits
[10:25:36.108]                       invokeRestart <- base::invokeRestart
[10:25:36.108]                       is.null <- base::is.null
[10:25:36.108]                       muffled <- FALSE
[10:25:36.108]                       if (inherits(cond, "message")) {
[10:25:36.108]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:36.108]                         if (muffled) 
[10:25:36.108]                           invokeRestart("muffleMessage")
[10:25:36.108]                       }
[10:25:36.108]                       else if (inherits(cond, "warning")) {
[10:25:36.108]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:36.108]                         if (muffled) 
[10:25:36.108]                           invokeRestart("muffleWarning")
[10:25:36.108]                       }
[10:25:36.108]                       else if (inherits(cond, "condition")) {
[10:25:36.108]                         if (!is.null(pattern)) {
[10:25:36.108]                           computeRestarts <- base::computeRestarts
[10:25:36.108]                           grepl <- base::grepl
[10:25:36.108]                           restarts <- computeRestarts(cond)
[10:25:36.108]                           for (restart in restarts) {
[10:25:36.108]                             name <- restart$name
[10:25:36.108]                             if (is.null(name)) 
[10:25:36.108]                               next
[10:25:36.108]                             if (!grepl(pattern, name)) 
[10:25:36.108]                               next
[10:25:36.108]                             invokeRestart(restart)
[10:25:36.108]                             muffled <- TRUE
[10:25:36.108]                             break
[10:25:36.108]                           }
[10:25:36.108]                         }
[10:25:36.108]                       }
[10:25:36.108]                       invisible(muffled)
[10:25:36.108]                     }
[10:25:36.108]                     muffleCondition(cond, pattern = "^muffle")
[10:25:36.108]                   }
[10:25:36.108]                 }
[10:25:36.108]                 else {
[10:25:36.108]                   if (TRUE) {
[10:25:36.108]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:36.108]                     {
[10:25:36.108]                       inherits <- base::inherits
[10:25:36.108]                       invokeRestart <- base::invokeRestart
[10:25:36.108]                       is.null <- base::is.null
[10:25:36.108]                       muffled <- FALSE
[10:25:36.108]                       if (inherits(cond, "message")) {
[10:25:36.108]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:36.108]                         if (muffled) 
[10:25:36.108]                           invokeRestart("muffleMessage")
[10:25:36.108]                       }
[10:25:36.108]                       else if (inherits(cond, "warning")) {
[10:25:36.108]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:36.108]                         if (muffled) 
[10:25:36.108]                           invokeRestart("muffleWarning")
[10:25:36.108]                       }
[10:25:36.108]                       else if (inherits(cond, "condition")) {
[10:25:36.108]                         if (!is.null(pattern)) {
[10:25:36.108]                           computeRestarts <- base::computeRestarts
[10:25:36.108]                           grepl <- base::grepl
[10:25:36.108]                           restarts <- computeRestarts(cond)
[10:25:36.108]                           for (restart in restarts) {
[10:25:36.108]                             name <- restart$name
[10:25:36.108]                             if (is.null(name)) 
[10:25:36.108]                               next
[10:25:36.108]                             if (!grepl(pattern, name)) 
[10:25:36.108]                               next
[10:25:36.108]                             invokeRestart(restart)
[10:25:36.108]                             muffled <- TRUE
[10:25:36.108]                             break
[10:25:36.108]                           }
[10:25:36.108]                         }
[10:25:36.108]                       }
[10:25:36.108]                       invisible(muffled)
[10:25:36.108]                     }
[10:25:36.108]                     muffleCondition(cond, pattern = "^muffle")
[10:25:36.108]                   }
[10:25:36.108]                 }
[10:25:36.108]             }
[10:25:36.108]         }))
[10:25:36.108]     }, error = function(ex) {
[10:25:36.108]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:36.108]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:36.108]                 ...future.rng), started = ...future.startTime, 
[10:25:36.108]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:36.108]             version = "1.8"), class = "FutureResult")
[10:25:36.108]     }, finally = {
[10:25:36.108]         if (!identical(...future.workdir, getwd())) 
[10:25:36.108]             setwd(...future.workdir)
[10:25:36.108]         {
[10:25:36.108]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:36.108]                 ...future.oldOptions$nwarnings <- NULL
[10:25:36.108]             }
[10:25:36.108]             base::options(...future.oldOptions)
[10:25:36.108]             if (.Platform$OS.type == "windows") {
[10:25:36.108]                 old_names <- names(...future.oldEnvVars)
[10:25:36.108]                 envs <- base::Sys.getenv()
[10:25:36.108]                 names <- names(envs)
[10:25:36.108]                 common <- intersect(names, old_names)
[10:25:36.108]                 added <- setdiff(names, old_names)
[10:25:36.108]                 removed <- setdiff(old_names, names)
[10:25:36.108]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:36.108]                   envs[common]]
[10:25:36.108]                 NAMES <- toupper(changed)
[10:25:36.108]                 args <- list()
[10:25:36.108]                 for (kk in seq_along(NAMES)) {
[10:25:36.108]                   name <- changed[[kk]]
[10:25:36.108]                   NAME <- NAMES[[kk]]
[10:25:36.108]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:36.108]                     next
[10:25:36.108]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:36.108]                 }
[10:25:36.108]                 NAMES <- toupper(added)
[10:25:36.108]                 for (kk in seq_along(NAMES)) {
[10:25:36.108]                   name <- added[[kk]]
[10:25:36.108]                   NAME <- NAMES[[kk]]
[10:25:36.108]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:36.108]                     next
[10:25:36.108]                   args[[name]] <- ""
[10:25:36.108]                 }
[10:25:36.108]                 NAMES <- toupper(removed)
[10:25:36.108]                 for (kk in seq_along(NAMES)) {
[10:25:36.108]                   name <- removed[[kk]]
[10:25:36.108]                   NAME <- NAMES[[kk]]
[10:25:36.108]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:36.108]                     next
[10:25:36.108]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:36.108]                 }
[10:25:36.108]                 if (length(args) > 0) 
[10:25:36.108]                   base::do.call(base::Sys.setenv, args = args)
[10:25:36.108]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:36.108]             }
[10:25:36.108]             else {
[10:25:36.108]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:36.108]             }
[10:25:36.108]             {
[10:25:36.108]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:36.108]                   0L) {
[10:25:36.108]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:36.108]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:36.108]                   base::options(opts)
[10:25:36.108]                 }
[10:25:36.108]                 {
[10:25:36.108]                   {
[10:25:36.108]                     NULL
[10:25:36.108]                     RNGkind("Mersenne-Twister")
[10:25:36.108]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:36.108]                       inherits = FALSE)
[10:25:36.108]                   }
[10:25:36.108]                   options(future.plan = NULL)
[10:25:36.108]                   if (is.na(NA_character_)) 
[10:25:36.108]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:36.108]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:36.108]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:36.108]                   {
[10:25:36.108]                     future <- SequentialFuture(..., envir = envir)
[10:25:36.108]                     if (!future$lazy) 
[10:25:36.108]                       future <- run(future)
[10:25:36.108]                     invisible(future)
[10:25:36.108]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:36.108]                 }
[10:25:36.108]             }
[10:25:36.108]         }
[10:25:36.108]     })
[10:25:36.108]     if (TRUE) {
[10:25:36.108]         base::sink(type = "output", split = FALSE)
[10:25:36.108]         if (TRUE) {
[10:25:36.108]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:36.108]         }
[10:25:36.108]         else {
[10:25:36.108]             ...future.result["stdout"] <- base::list(NULL)
[10:25:36.108]         }
[10:25:36.108]         base::close(...future.stdout)
[10:25:36.108]         ...future.stdout <- NULL
[10:25:36.108]     }
[10:25:36.108]     ...future.result$conditions <- ...future.conditions
[10:25:36.108]     ...future.result$finished <- base::Sys.time()
[10:25:36.108]     ...future.result
[10:25:36.108] }
[10:25:36.110] assign_globals() ...
[10:25:36.110] List of 2
[10:25:36.110]  $ rr: int 3
[10:25:36.110]  $ cc: int 2
[10:25:36.110]  - attr(*, "where")=List of 2
[10:25:36.110]   ..$ rr:<environment: R_EmptyEnv> 
[10:25:36.110]   ..$ cc:<environment: R_EmptyEnv> 
[10:25:36.110]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:36.110]  - attr(*, "resolved")= logi FALSE
[10:25:36.110]  - attr(*, "total_size")= num 112
[10:25:36.110]  - attr(*, "already-done")= logi TRUE
[10:25:36.113] - copied ‘rr’ to environment
[10:25:36.113] - copied ‘cc’ to environment
[10:25:36.113] assign_globals() ... done
[10:25:36.113] plan(): Setting new future strategy stack:
[10:25:36.113] List of future strategies:
[10:25:36.113] 1. sequential:
[10:25:36.113]    - args: function (..., envir = parent.frame())
[10:25:36.113]    - tweaked: FALSE
[10:25:36.113]    - call: NULL
[10:25:36.114] plan(): nbrOfWorkers() = 1
[10:25:36.114] plan(): Setting new future strategy stack:
[10:25:36.115] List of future strategies:
[10:25:36.115] 1. sequential:
[10:25:36.115]    - args: function (..., envir = parent.frame())
[10:25:36.115]    - tweaked: FALSE
[10:25:36.115]    - call: future::plan("sequential")
[10:25:36.115] plan(): nbrOfWorkers() = 1
[10:25:36.115] SequentialFuture started (and completed)
[10:25:36.115] - Launch lazy future ... done
[10:25:36.115] run() for ‘SequentialFuture’ ... done
> dim(y) <- dim(x)
> stopifnot(identical(y, x0))
> 
> message("*** %<-% to listenv: multiple dimensions ... DONE")
*** %<-% to listenv: multiple dimensions ... DONE
> 
> message("*** %<-% to listenv ... DONE")
*** %<-% to listenv ... DONE
> 
> source("incl/end.R")
[10:25:36.116] plan(): Setting new future strategy stack:
[10:25:36.116] List of future strategies:
[10:25:36.116] 1. FutureStrategy:
[10:25:36.116]    - args: function (..., envir = parent.frame())
[10:25:36.116]    - tweaked: FALSE
[10:25:36.116]    - call: future::plan(oplan)
[10:25:36.128] plan(): nbrOfWorkers() = 1
> 
