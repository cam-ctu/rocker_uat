
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "xml2"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('xml2')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("as_list")
> ### * as_list
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as_list
> ### Title: Coerce xml nodes to a list.
> ### Aliases: as_list
> 
> ### ** Examples
> 
> as_list(read_xml("<foo> a <b /><c><![CDATA[<d></d>]]></c></foo>"))
$foo
$foo[[1]]
[1] " a "

$foo$b
list()

$foo$c
$foo$c[[1]]
[1] "<d></d>"



> as_list(read_xml("<foo> <bar><baz /></bar> </foo>"))
$foo
$foo$bar
$foo$bar$baz
list()



> as_list(read_xml("<foo id = 'a'></foo>"))
$foo
list()
attr(,"id")
[1] "a"

> as_list(read_xml("<foo><bar id='a'/><bar id='b'/></foo>"))
$foo
$foo$bar
list()
attr(,"id")
[1] "a"

$foo$bar
list()
attr(,"id")
[1] "b"


> 
> 
> 
> cleanEx()
> nameEx("as_xml_document")
> ### * as_xml_document
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as_xml_document
> ### Title: Coerce a R list to xml nodes.
> ### Aliases: as_xml_document
> 
> ### ** Examples
> 
> as_xml_document(list(x = list()))
{xml_document}
<x>
> 
> # Nesting multiple nodes
> as_xml_document(list(foo = list(bar = list(baz = list()))))
{xml_document}
<foo>
[1] <bar>\n  <baz/>\n</bar>
> 
> # attributes are stored as R attributes
> as_xml_document(list(foo = structure(list(), id = "a")))
{xml_document}
<foo id="a">
> as_xml_document(list(foo = list(
+   bar = structure(list(), id = "a"),
+   bar = structure(list(), id = "b")
+ )))
{xml_document}
<foo>
[1] <bar id="a"/>
[2] <bar id="b"/>
> 
> 
> 
> cleanEx()
> nameEx("download_xml")
> ### * download_xml
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: download_xml
> ### Title: Download a HTML or XML file
> ### Aliases: download_xml download_html
> 
> ### ** Examples
> 
> ## Not run: 
> ##D download_html("http://tidyverse.org/index.html")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("read_xml")
> ### * read_xml
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: read_xml
> ### Title: Read HTML or XML.
> ### Aliases: read_xml read_html read_xml.character read_xml.raw
> ###   read_xml.connection
> 
> ### ** Examples
> 
> # Literal xml/html is useful for small examples
> read_xml("<foo><bar /></foo>")
{xml_document}
<foo>
[1] <bar/>
> read_html("<html><title>Hi<title></html>")
{html_document}
<html>
[1] <head>\n<meta http-equiv="Content-Type" content="text/html; charset=UTF-8 ...
> read_html("<html><title>Hi")
{html_document}
<html>
[1] <head>\n<meta http-equiv="Content-Type" content="text/html; charset=UTF-8 ...
> 
> # From a local path
> read_html(system.file("extdata", "r-project.html", package = "xml2"))
{html_document}
<html lang="en">
[1] <head>\n<meta http-equiv="Content-Type" content="text/html; charset=UTF-8 ...
[2] <body>\n    <div class="container page">\n      <div class="row">\n       ...
> 
> ## Not run: 
> ##D # From a url
> ##D cd <- read_xml(xml2_example("cd_catalog.xml"))
> ##D me <- read_html("http://had.co.nz")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("url_absolute")
> ### * url_absolute
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: url_absolute
> ### Title: Convert between relative and absolute urls.
> ### Aliases: url_absolute url_relative
> 
> ### ** Examples
> 
> url_absolute(c(".", "..", "/", "/x"), "http://hadley.nz/a/b/c/d")
[1] "http://hadley.nz/a/b/c/" "http://hadley.nz/a/b/"  
[3] "http://hadley.nz/"       "http://hadley.nz/x"     
> 
> url_relative("http://hadley.nz/a/c", "http://hadley.nz")
[1] "/a/c"
> url_relative("http://hadley.nz/a/c", "http://hadley.nz/")
[1] "a/c"
> url_relative("http://hadley.nz/a/c", "http://hadley.nz/a/b")
[1] "c"
> url_relative("http://hadley.nz/a/c", "http://hadley.nz/a/b/")
[1] "../c"
> 
> 
> 
> cleanEx()
> nameEx("url_escape")
> ### * url_escape
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: url_escape
> ### Title: Escape and unescape urls.
> ### Aliases: url_escape url_unescape
> 
> ### ** Examples
> 
> url_escape("a b c")
[1] "a%20b%20c"
> url_escape("a b c", "")
[1] "a%20b%20c"
> 
> url_unescape("a%20b%2fc")
[1] "a b/c"
> url_unescape("%C2%B5")
[1] "Âµ"
> 
> 
> 
> cleanEx()
> nameEx("url_parse")
> ### * url_parse
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: url_parse
> ### Title: Parse a url into its component pieces.
> ### Aliases: url_parse
> 
> ### ** Examples
> 
> url_parse("http://had.co.nz/")
  scheme    server port user path query fragment
1   http had.co.nz   NA         /               
> url_parse("http://had.co.nz:1234/")
  scheme    server port user path query fragment
1   http had.co.nz 1234         /               
> url_parse("http://had.co.nz:1234/?a=1&b=2")
  scheme    server port user path   query fragment
1   http had.co.nz 1234         / a=1&b=2         
> url_parse("http://had.co.nz:1234/?a=1&b=2#def")
  scheme    server port user path   query fragment
1   http had.co.nz 1234         / a=1&b=2      def
> 
> 
> 
> cleanEx()
> nameEx("write_xml")
> ### * write_xml
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: write_xml
> ### Title: Write XML or HTML to disk.
> ### Aliases: write_xml write_xml.xml_document write_html
> ###   write_html.xml_document
> 
> ### ** Examples
> 
> h <- read_html("<p>Hi!</p>")
> 
> tmp <- tempfile(fileext = ".xml")
> write_xml(h, tmp, options = "format")
> readLines(tmp)
[1] "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"http://www.w3.org/TR/REC-html40/loose.dtd\">"
[2] "<html><body><p>Hi!</p></body></html>"                                                                          
> 
> # write formatted HTML output
> write_html(h, tmp, options = "format")
> readLines(tmp)
[1] "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"http://www.w3.org/TR/REC-html40/loose.dtd\">"
[2] "<html><body><p>Hi!</p></body></html>"                                                                          
> 
> 
> 
> cleanEx()
> nameEx("xml_attr")
> ### * xml_attr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xml_attr
> ### Title: Retrieve an attribute.
> ### Aliases: xml_attr xml_has_attr xml_attrs xml_attr<- xml_set_attr
> ###   xml_attrs<- xml_set_attrs
> 
> ### ** Examples
> 
> x <- read_xml("<root id='1'><child id ='a' /><child id='b' d='b'/></root>")
> xml_attr(x, "id")
[1] "1"
> xml_attr(x, "apple")
[1] NA
> xml_attrs(x)
 id 
"1" 
> 
> kids <- xml_children(x)
> kids
{xml_nodeset (2)}
[1] <child id="a"/>
[2] <child id="b" d="b"/>
> xml_attr(kids, "id")
[1] "a" "b"
> xml_has_attr(kids, "id")
[1] TRUE TRUE
> xml_attrs(kids)
[[1]]
 id 
"a" 

[[2]]
 id   d 
"b" "b" 

> 
> # Missing attributes give missing values
> xml_attr(xml_children(x), "d")
[1] NA  "b"
> xml_has_attr(xml_children(x), "d")
[1] FALSE  TRUE
> 
> # If the document has a namespace, use the ns argument and
> # qualified attribute names
> x <- read_xml('
+  <root xmlns:b="http://bar.com" xmlns:f="http://foo.com">
+    <doc b:id="b" f:id="f" id="" />
+  </root>
+ ')
> doc <- xml_children(x)[[1]]
> ns <- xml_ns(x)
> 
> xml_attrs(doc)
 id  id  id 
"b" "f" "b" 
> xml_attrs(doc, ns)
b:id f:id   id 
 "b"  "f"   "" 
> 
> # If you don't supply a ns spec, you get the first matching attribute
> xml_attr(doc, "id")
[1] "b"
> xml_attr(doc, "b:id", ns)
[1] "b"
> xml_attr(doc, "id", ns)
[1] ""
> 
> # Can set a single attribute with `xml_attr() <-` or `xml_set_attr()`
> xml_attr(doc, "id") <- "one"
> xml_set_attr(doc, "id", "two")
> 
> # Or set multiple attributes with `xml_attrs()` or `xml_set_attrs()`
> xml_attrs(doc) <- c("b:id" = "one", "f:id" = "two", "id" = "three")
> xml_set_attrs(doc, c("b:id" = "one", "f:id" = "two", "id" = "three"))
> 
> 
> 
> cleanEx()
> nameEx("xml_cdata")
> ### * xml_cdata
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xml_cdata
> ### Title: Construct a cdata node
> ### Aliases: xml_cdata
> 
> ### ** Examples
> 
> x <- xml_new_root("root")
> xml_add_child(x, xml_cdata("<d/>"))
> as.character(x)
[1] "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<root><![CDATA[<d/>]]></root>\n"
> 
> 
> 
> cleanEx()
> nameEx("xml_children")
> ### * xml_children
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xml_children
> ### Title: Navigate around the family tree.
> ### Aliases: xml_children xml_child xml_contents xml_parents xml_siblings
> ###   xml_parent xml_length xml_root
> 
> ### ** Examples
> 
> x <- read_xml("<foo> <bar><boo /></bar> <baz/> </foo>")
> xml_children(x)
{xml_nodeset (2)}
[1] <bar>\n  <boo/>\n</bar>
[2] <baz/>
> xml_children(xml_children(x))
{xml_nodeset (1)}
[1] <boo/>
> xml_siblings(xml_children(x)[[1]])
{xml_nodeset (1)}
[1] <baz/>
> 
> # Note the each unique node only appears once in the output
> xml_parent(xml_children(x))
{xml_nodeset (1)}
[1] <foo>\n  <bar>\n    <boo/>\n  </bar>\n  <baz/>\n</foo>
> 
> # Mixed content
> x <- read_xml("<foo> a <b/> c <d>e</d> f</foo>")
> # Childen gets the elements, contents gets all node types
> xml_children(x)
{xml_nodeset (2)}
[1] <b/>
[2] <d>e</d>
> xml_contents(x)
{xml_nodeset (5)}
[1]  a 
[2] <b/>
[3]  c 
[4] <d>e</d>
[5]  f
> 
> xml_length(x)
[1] 2
> xml_length(x, only_elements = FALSE)
[1] 5
> 
> # xml_child makes it easier to select specific children
> xml_child(x)
{xml_node}
<b>
> xml_child(x, 2)
{xml_node}
<d>
> xml_child(x, "baz")
{xml_missing}
<NA>
> 
> 
> 
> cleanEx()
> nameEx("xml_comment")
> ### * xml_comment
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xml_comment
> ### Title: Construct a comment node
> ### Aliases: xml_comment
> 
> ### ** Examples
> 
> x <- xml_new_document()
> r <- xml_add_child(x, "root")
> xml_add_child(r, xml_comment("Hello!"))
> as.character(x)
[1] "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<root>\n  <!--Hello!-->\n</root>\n"
> 
> 
> 
> cleanEx()
> nameEx("xml_dtd")
> ### * xml_dtd
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xml_dtd
> ### Title: Construct a document type definition
> ### Aliases: xml_dtd
> 
> ### ** Examples
> 
> r <- xml_new_root(
+   xml_dtd(
+     "html",
+     "-//W3C//DTD XHTML 1.0 Transitional//EN",
+     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"
+   )
+ )
> 
> # Use read_xml directly for more complicated DTD
> d <- read_xml(
+   '<!DOCTYPE doc [
+ <!ELEMENT doc (#PCDATA)>
+ <!ENTITY foo " test ">
+ ]>
+ <doc>This is a valid document &foo; !</doc>'
+ )
> 
> 
> 
> cleanEx()
> nameEx("xml_find_all")
> ### * xml_find_all
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xml_find_all
> ### Title: Find nodes that match an xpath expression.
> ### Aliases: xml_find_all xml_find_all.xml_nodeset xml_find_first
> ###   xml_find_num xml_find_int xml_find_chr xml_find_lgl xml_find_one
> 
> ### ** Examples
> 
> x <- read_xml("<foo><bar><baz/></bar><baz/></foo>")
> xml_find_all(x, ".//baz")
{xml_nodeset (2)}
[1] <baz/>
[2] <baz/>
> xml_path(xml_find_all(x, ".//baz"))
[1] "/foo/bar/baz" "/foo/baz"    
> 
> # Note the difference between .// and //
> # //  finds anywhere in the document (ignoring the current node)
> # .// finds anywhere beneath the current node
> (bar <- xml_find_all(x, ".//bar"))
{xml_nodeset (1)}
[1] <bar>\n  <baz/>\n</bar>
> xml_find_all(bar, ".//baz")
{xml_nodeset (1)}
[1] <baz/>
> xml_find_all(bar, "//baz")
{xml_nodeset (2)}
[1] <baz/>
[2] <baz/>
> 
> # Find all vs find one -----------------------------------------------------
> x <- read_xml("<body>
+   <p>Some <b>text</b>.</p>
+   <p>Some <b>other</b> <b>text</b>.</p>
+   <p>No bold here!</p>
+ </body>")
> para <- xml_find_all(x, ".//p")
> 
> # By default, if you apply xml_find_all to a nodeset, it finds all matches,
> # de-duplicates them, and returns as a single nodeset. This means you
> # never know how many results you'll get
> xml_find_all(para, ".//b")
{xml_nodeset (3)}
[1] <b>text</b>
[2] <b>other</b>
[3] <b>text</b>
> 
> # If you set flatten to FALSE, though, xml_find_all will return a list of
> # nodesets, where each nodeset contains the matches for the corresponding
> # node in the original nodeset.
> xml_find_all(para, ".//b", flatten = FALSE)
[[1]]
{xml_nodeset (1)}
[1] <b>text</b>

[[2]]
{xml_nodeset (2)}
[1] <b>other</b>
[2] <b>text</b>

[[3]]
{xml_nodeset (0)}

> 
> # xml_find_first only returns the first match per input node. If there are 0
> # matches it will return a missing node
> xml_find_first(para, ".//b")
{xml_nodeset (3)}
[1] <b>text</b>
[2] <b>other</b>
[3] NA
> xml_text(xml_find_first(para, ".//b"))
[1] "text"  "other" NA     
> 
> # Namespaces ---------------------------------------------------------------
> # If the document uses namespaces, you'll need use xml_ns to form
> # a unique mapping between full namespace url and a short prefix
> x <- read_xml('
+  <root xmlns:f = "http://foo.com" xmlns:g = "http://bar.com">
+    <f:doc><g:baz /></f:doc>
+    <f:doc><g:baz /></f:doc>
+  </root>
+ ')
> xml_find_all(x, ".//f:doc")
{xml_nodeset (2)}
[1] <f:doc>\n  <g:baz/>\n</f:doc>
[2] <f:doc>\n  <g:baz/>\n</f:doc>
> xml_find_all(x, ".//f:doc", xml_ns(x))
{xml_nodeset (2)}
[1] <f:doc>\n  <g:baz/>\n</f:doc>
[2] <f:doc>\n  <g:baz/>\n</f:doc>
> 
> 
> 
> cleanEx()
> nameEx("xml_name")
> ### * xml_name
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xml_name
> ### Title: The (tag) name of an xml element.
> ### Aliases: xml_name xml_name<- xml_set_name
> 
> ### ** Examples
> 
> x <- read_xml("<bar>123</bar>")
> xml_name(x)
[1] "bar"
> 
> y <- read_xml("<bar><baz>1</baz>abc<foo /></bar>")
> z <- xml_children(y)
> xml_name(xml_children(y))
[1] "baz" "foo"
> 
> 
> 
> cleanEx()
> nameEx("xml_ns")
> ### * xml_ns
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xml_ns
> ### Title: XML namespaces.
> ### Aliases: xml_ns xml_ns_rename
> 
> ### ** Examples
> 
> x <- read_xml('
+  <root>
+    <doc1 xmlns = "http://foo.com"><baz /></doc1>
+    <doc2 xmlns = "http://bar.com"><baz /></doc2>
+  </root>
+ ')
> xml_ns(x)
d1 <-> http://foo.com
d2 <-> http://bar.com
> 
> # When there are default namespaces, it's a good idea to rename
> # them to give informative names:
> ns <- xml_ns_rename(xml_ns(x), d1 = "foo", d2 = "bar")
> ns
foo <-> http://foo.com
bar <-> http://bar.com
> 
> # Now we can pass ns to other xml function to use fully qualified names
> baz <- xml_children(xml_children(x))
> xml_name(baz)
[1] "baz" "baz"
> xml_name(baz, ns)
[1] "foo:baz" "bar:baz"
> 
> xml_find_all(x, "//baz")
{xml_nodeset (0)}
> xml_find_all(x, "//foo:baz", ns)
{xml_nodeset (1)}
[1] <baz/>
> 
> str(as_list(x))
List of 1
 $ root:List of 2
  ..$ doc1:List of 1
  .. ..$ baz: list()
  .. ..- attr(*, "xmlns")= chr "http://foo.com"
  ..$ doc2:List of 1
  .. ..$ baz: list()
  .. ..- attr(*, "xmlns")= chr "http://bar.com"
> str(as_list(x, ns))
List of 1
 $ root:List of 2
  ..$ foo:doc1:List of 1
  .. ..$ foo:baz: list()
  .. ..- attr(*, "xmlns")= chr "http://foo.com"
  ..$ bar:doc2:List of 1
  .. ..$ bar:baz: list()
  .. ..- attr(*, "xmlns")= chr "http://bar.com"
> 
> 
> 
> cleanEx()
> nameEx("xml_ns_strip")
> ### * xml_ns_strip
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xml_ns_strip
> ### Title: Strip the default namespaces from a document
> ### Aliases: xml_ns_strip
> 
> ### ** Examples
> 
> x <- read_xml(
+   "<foo xmlns = 'http://foo.com'>
+    <baz/>
+    <bar xmlns = 'http://bar.com'>
+      <baz/>
+    </bar>
+   </foo>"
+ )
> # Need to specify the default namespaces to find the baz nodes
> xml_find_all(x, "//d1:baz")
{xml_nodeset (1)}
[1] <baz/>
> xml_find_all(x, "//d2:baz")
{xml_nodeset (1)}
[1] <baz/>
> 
> # After stripping the default namespaces you can find both baz nodes directly
> xml_ns_strip(x)
> xml_find_all(x, "//baz")
{xml_nodeset (2)}
[1] <baz/>
[2] <baz/>
> 
> 
> 
> cleanEx()
> nameEx("xml_path")
> ### * xml_path
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xml_path
> ### Title: Retrieve the xpath to a node
> ### Aliases: xml_path
> 
> ### ** Examples
> 
> x <- read_xml("<foo><bar><baz /></bar><baz /></foo>")
> xml_path(xml_find_all(x, ".//baz"))
[1] "/foo/bar/baz" "/foo/baz"    
> 
> 
> 
> cleanEx()
> nameEx("xml_serialize")
> ### * xml_serialize
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xml_serialize
> ### Title: Serializing XML objects to connections.
> ### Aliases: xml_serialize xml_unserialize
> 
> ### ** Examples
> 
> library(xml2)
> x <- read_xml("<a>
+   <b><c>123</c></b>
+   <b><c>456</c></b>
+ </a>")
> 
> b <- xml_find_all(x, "//b")
> out <- xml_serialize(b, NULL)
> xml_unserialize(out)
{xml_nodeset (2)}
[1] <b>\n  <c>123</c>\n</b>
[2] <b>\n  <c>456</c>\n</b>
> 
> 
> 
> cleanEx()
> nameEx("xml_structure")
> ### * xml_structure
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xml_structure
> ### Title: Show the structure of an html/xml document.
> ### Aliases: xml_structure html_structure
> 
> ### ** Examples
> 
> xml_structure(read_xml("<a><b><c/><c/></b><d/></a>"))
<a>
  <b>
    <c>
    <c>
  <d>
> 
> rproj <- read_html(system.file("extdata", "r-project.html", package = "xml2"))
> xml_structure(rproj)
<html [lang]>
  <head>
    <meta [charset]>
    <meta [http-equiv, content]>
    <meta [name, content]>
    <title>
      {text}
    <link [rel, type, href, sizes]>
    <link [rel, type, href, sizes]>
    {comment}
    <link [href, rel]>
    <link [href, rel]>
    {comment}
    {comment}
    {comment}
  <body>
    {text}
    <div [class]>
      {text}
      <div [class]>
        {text}
        <div [class, role]>
          {text}
          <div [class]>
            {text}
            <div [class]>
              {text}
              <p>
                <a [href]>
                  <img [src, alt]>
              {text}
              <p>
                <small>
                  <a [href]>
                    {text}
              {text}
              <h2>
                {text}
              {text}
              <p>
                <a [href]>
                  {text}
              {text}
              <h2>
                {text}
              {text}
              <ul>
                <li>
                  <a [href]>
                    {text}
                {text}
                <li>
                  <a [href]>
                    {text}
                {text}
                <li>
                  <a [href]>
                    {text}
                {text}
                <li>
                  <a [href]>
                    {text}
                {text}
                <li>
                  <a [href]>
                    {text}
                {text}
                <li>
                  <a [href]>
                    {text}
                {text}
                <li>
                  <a [href]>
                    {text}
                {text}
            {text}
            <div [class]>
              {text}
              <h2>
                {text}
              {text}
              <ul>
                <li>
                  <a [href]>
                    {text}
                {text}
                <li>
                  <a [href]>
                    {text}
                {text}
                <li>
                  <a [href]>
                    {text}
                {text}
                <li>
                  <a [href]>
                    {text}
                {text}
                <li>
                  <a [href]>
                    {text}
                {text}
            {text}
            <div [class]>
              {text}
              <h2>
                {text}
              {text}
              <ul>
                <li>
                  <a [href]>
                    {text}
                {text}
                <li>
                  <a [href]>
                    {text}
                {text}
                <li>
                  <a [href]>
                    {text}
                {text}
                <li>
                  <a [href]>
                    {text}
                {text}
                <li>
                  <a [href]>
                    {text}
                {text}
                <li>
                  <a [href]>
                    {text}
                {text}
            {text}
            <div [class]>
              {text}
              <h2>
                {text}
              {text}
              <ul>
                <li>
                  <a [href]>
                    {text}
                {text}
                <li>
                  <a [href]>
                    {text}
                {text}
            {text}
          {text}
        {text}
        <div [class]>
          {text}
          <h1>
            {text}
          {text}
          <h2 [id]>
            {text}
          {text}
          <p>
            {text}
            <strong>
              <a [href]>
                {text}
            {text}
            <a [href]>
              {text}
            {text}
          {text}
          <p>
            {text}
            <a [href]>
              {text}
            {text}
          {text}
          <h2 [id]>
            {text}
          {text}
          <ul>
            <li>
              <p>
                <a [href]>
                  <strong>
                    {text}
                {text}
            {text}
            <li>
              <p>
                <strong>
                  {text}
                {text}
            {text}
            <li>
              <p>
                <a [href]>
                  <strong>
                    {text}
                {text}
            {text}
            <li>
              <p>
                <strong>
                  {text}
                {text}
            {text}
            <li>
              <p>
                <strong>
                  <a [href]>
                    {text}
                {text}
            {text}
            <li>
              <p>
                <strong>
                  <a [href]>
                    {text}
                {text}
            {text}
          {comment}
        {text}
      {text}
      <div [class]>
        {text}
      {text}
    {text}
    {comment}
    {text}
    <script [src]>
    {comment}
    <script [src]>
> xml_structure(xml_find_all(rproj, ".//p"))
[[1]]
<p>
  <a [href]>
    <img [src, alt]>

[[2]]
<p>
  <small>
    <a [href]>
      {text}

[[3]]
<p>
  <a [href]>
    {text}

[[4]]
<p>
  {text}
  <strong>
    <a [href]>
      {text}
  {text}
  <a [href]>
    {text}
  {text}

[[5]]
<p>
  {text}
  <a [href]>
    {text}
  {text}

[[6]]
<p>
  <a [href]>
    <strong>
      {text}
  {text}

[[7]]
<p>
  <strong>
    {text}
  {text}

[[8]]
<p>
  <a [href]>
    <strong>
      {text}
  {text}

[[9]]
<p>
  <strong>
    {text}
  {text}

[[10]]
<p>
  <strong>
    <a [href]>
      {text}
  {text}

[[11]]
<p>
  <strong>
    <a [href]>
      {text}
  {text}

> 
> h <- read_html("<body><p id = 'a'></p><p class = 'c d'></p></body>")
> html_structure(h)
<html>
  <body>
    <p#a>
    <p.c.d>
> 
> 
> 
> cleanEx()
> nameEx("xml_text")
> ### * xml_text
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xml_text
> ### Title: Extract or modify the text
> ### Aliases: xml_text xml_text<- xml_set_text xml_double xml_integer
> 
> ### ** Examples
> 
> x <- read_xml("<p>This is some text. This is <b>bold!</b></p>")
> xml_text(x)
[1] "This is some text. This is bold!"
> xml_text(xml_children(x))
[1] "bold!"
> 
> x <- read_xml("<x>This is some text. <x>This is some nested text.</x></x>")
> xml_text(x)
[1] "This is some text. This is some nested text."
> xml_text(xml_find_all(x, "//x"))
[1] "This is some text. This is some nested text."
[2] "This is some nested text."                   
> 
> x <- read_xml("<p>   Some text    </p>")
> xml_text(x, trim = TRUE)
[1] "Some text"
> 
> # xml_double() and xml_integer() are useful for extracting numeric attributes
> x <- read_xml("<plot><point x='1' y='2' /><point x='2' y='1' /></plot>")
> xml_integer(xml_find_all(x, "//@x"))
[1] 1 2
> 
> 
> 
> cleanEx()
> nameEx("xml_type")
> ### * xml_type
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xml_type
> ### Title: Determine the type of a node.
> ### Aliases: xml_type
> 
> ### ** Examples
> 
> x <- read_xml("<foo> a <b /> <![CDATA[ blah]]></foo>")
> xml_type(x)
[1] "element"
> xml_type(xml_contents(x))
[1] "text"    "element" "text"    "cdata"  
> 
> 
> 
> cleanEx()
> nameEx("xml_url")
> ### * xml_url
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xml_url
> ### Title: The URL of an XML document
> ### Aliases: xml_url
> 
> ### ** Examples
> 
> catalog <- read_xml(xml2_example("cd_catalog.xml"))
> xml_url(catalog)
[1] "/usr/local/lib/R/site-library/xml2/extdata/cd_catalog.xml"
> 
> x <- read_xml("<foo/>")
> xml_url(x)
[1] NA
> 
> 
> 
> cleanEx()
> nameEx("xml_validate")
> ### * xml_validate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: xml_validate
> ### Title: Validate XML schema
> ### Aliases: xml_validate
> 
> ### ** Examples
> 
> # Example from https://msdn.microsoft.com/en-us/library/ms256129(v=vs.110).aspx
> doc <- read_xml(system.file("extdata/order-doc.xml", package = "xml2"))
> schema <- read_xml(system.file("extdata/order-schema.xml", package = "xml2"))
> xml_validate(doc, schema)
[1] TRUE
attr(,"errors")
character(0)
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.196 0.03 0.226 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
