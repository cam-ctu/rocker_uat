
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "pracma"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('pracma')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("abm3")
> ### * abm3
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: abm3pc
> ### Title: Adams-Bashford-Moulton
> ### Aliases: abm3pc
> ### Keywords: ode
> 
> ### ** Examples
> 
> ##  Attempt on a non-stiff equation
> #   y' = y^2 - y^3, y(0) = d, 0 <= t <= 2/d, d = 0.01
> f <- function(t, y) y^2 - y^3
> d <- 1/250
> abm1 <- abm3pc(f, 0, 2/d, d, n = 1/d)
> abm2 <- abm3pc(f, 0, 2/d, d, n = 2/d)
> ## Not run: 
> ##D plot(abm1$x, abm1$y, type = "l", col = "blue")
> ##D lines(abm2$x, abm2$y, type = "l", col = "red")
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("accumarray")
> ### * accumarray
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: accumarray
> ### Title: Accumulate Vector Elements
> ### Aliases: accumarray uniq
> ### Keywords: array
> 
> ### ** Examples
> 
> ##  Examples for accumarray
> val = 101:105
> subs = as.matrix(c(1, 2, 4, 2, 4))
> accumarray(subs, val)
     [,1]
[1,]  101
[2,]  206
[3,]    0
[4,]  208
> # [101; 206; 0; 208]
> 
> val = 101:105
> subs <- matrix(c(1,2,2,2,2, 1,1,3,1,3, 1,2,2,2,2), ncol = 3)
> accumarray(subs, val)
, , 1

     [,1] [,2] [,3]
[1,]  101    0    0
[2,]    0    0    0

, , 2

     [,1] [,2] [,3]
[1,]    0    0    0
[2,]  206    0  208

> # , , 1
> # [,1] [,2] [,3]
> # [1,]  101    0    0
> # [2,]    0    0    0
> # , , 2
> # [,1] [,2] [,3]
> # [1,]    0    0    0
> # [2,]  206    0  208
> 
> val = 101:106
> subs <- matrix(c(1, 2, 1, 2, 3, 1, 4, 1, 4, 4, 4, 1), ncol = 2, byrow = TRUE)
> accumarray(subs, val, func = function(x) sum(diff(x)))
     [,1] [,2] [,3] [,4]
[1,]    0    1    0    0
[2,]    0    0    0    0
[3,]    0    0    0    0
[4,]    2    0    0    0
> # [,1] [,2] [,3] [,4]
> # [1,]    0    1    0    0
> # [2,]    0    0    0    0
> # [3,]    0    0    0    0
> # [4,]    2    0    0    0
> 
> val = 101:105
> subs = matrix(c(1, 1, 2, 1, 2, 3, 2, 1, 2, 3), ncol = 2, byrow = TRUE)
> accumarray(subs, val, sz = c(3, 3), func = max, fillval = NA)
     [,1] [,2] [,3]
[1,]  101   NA   NA
[2,]  104   NA  105
[3,]   NA   NA   NA
> # [,1] [,2] [,3]
> # [1,]  101   NA   NA
> # [2,]  104   NA  105
> # [3,]   NA   NA   NA
> 
> ##  Examples for uniq
> a <- c(1, 1, 5, 6, 2, 3, 3, 9, 8, 6, 2, 4)
> A <- uniq(a); A
$b
[1] 1 5 6 2 3 9 8 4

$m
[1]  2  3 10 11  7  8  9 12

$n
 [1] 1 1 2 3 4 5 5 6 7 3 4 8

> # A$b  1  5  6  2  3  9  8  4
> # A$m  2  3 10 11  7  8  9 12
> # A$n  1  1  2  3  4  5  5  6  7  3  4  8
> A <- uniq(a, first = TRUE); A
$b
[1] 1 5 6 2 3 9 8 4

$m
[1]  1  3  4  5  6  8  9 12

$n
 [1] 1 1 2 3 4 5 5 6 7 3 4 8

> # A$m  1  3  4  5  6  8  9 12
> 
> ##  Example: Subset sum problem
> # Distribution of unique sums among all combinations of a vectors.
> allsums <- function(a) {
+     S <- c(); C <- c()
+     for (k in 1:length(a)) {
+         U <- uniq(c(S, a[k], S + a[k]))
+         S <- U$b
+         C <- accumarray(U$n, c(C, 1, C))
+     }
+     o <- order(S); S <- S[o]; C <- C[o]
+     return(list(S = S, C = C))
+ }
> A <- allsums(seq(1, 9, by=2)); A
$S
 [1]  1  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 24 25

$C
 [1] 1 1 1 1 1 1 2 2 2 1 2 2 1 2 2 2 1 1 1 1 1 1 1

> # A$S  1  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 24 25
> # A$C  1  1  1  1  1  1  2  2  2  1  2  2  1  2  2  2  1  1  1  1  1  1  1
> 
> 
> 
> cleanEx()
> nameEx("agmean")
> ### * agmean
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: agmean
> ### Title: Arithmetic-geometric Mean
> ### Aliases: agmean
> ### Keywords: arith
> 
> ### ** Examples
> 
> ##  Accuracy test: Gauss constant
> 1/agmean(1, sqrt(2))$agm - 0.834626841674073186  # 1.11e-16 < eps = 2.22e-16
[1] -1.110223e-16
> 
> ## Gauss' AGM-based computation of \pi
> a <- 1.0
> b <- 1.0/sqrt(2)
> s <- 0.5
> d <- 1L
> while (abs(a-b) > eps()) {
+     t <- a
+     a <- (a + b)*0.5
+     b <- sqrt(t*b)
+     c <- (a-t)*(a-t)
+     d <- 2L * d
+     s <- s - d*c
+ }
> approx_pi <- (a+b)^2 / s / 2.0
> abs(approx_pi - pi)             # 8.881784e-16 in 4 iterations
[1] 8.881784e-16
> 
> ##  Example: Approximate elliptic integral
> N <- 20
> m <- seq(0, 1, len = N+1)[1:N]
> E <- numeric(N)
> for (i in 1:N) {
+     f <- function(t) 1/sqrt(1 - m[i]^2 * sin(t)^2)
+     E[i] <- quad(f, 0, pi/2)
+ }
> A <- numeric(2*N-1)
> a <- 1
> b <- a * (1-m) / (m+1)
> 
> ## Not run: 
> ##D plot(m, E, main = "Elliptic Integrals vs. arith.-geom. Mean")
> ##D lines(m, (a+b)*pi / 4 / agmean(a, b)$agm, col="blue")
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("aitken")
> ### * aitken
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aitken
> ### Title: Aitken' Method
> ### Aliases: aitken
> ### Keywords: math
> 
> ### ** Examples
> 
> # Find a zero of    f(x) = cos(x) - x*exp(x)
> # as fixpoint of  phi(x) = x + (cos(x) - x*exp(x))/2
> phi <- function(x) x + (cos(x) - x*exp(x))/2
> aitken(phi, 0)  #=> 0.5177574
[1] 0.5177574
> 
> 
> 
> cleanEx()
> nameEx("akima")
> ### * akima
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: akimaInterp
> ### Title: Univariate Akima Interpolation
> ### Aliases: akimaInterp
> ### Keywords: fitting
> 
> ### ** Examples
> 
> x <- c( 0,  2,  3,  5,  6,  8,  9,   11, 12, 14, 15)
> y <- c(10, 10, 10, 10, 10, 10, 10.5, 15, 50, 60, 85)
> xs <- seq(12, 14, 0.5)          # 12.0 12.5     13.0     13.5     14.0
> ys <- akimaInterp(x, y, xs)     # 50.0 54.57405 54.84360 55.19135 60.0
> xs; ys
[1] 12.0 12.5 13.0 13.5 14.0
[1] 50.00000 54.57405 54.84360 55.19135 60.00000
> 
> ## Not run: 
> ##D plot(x, y, col="blue", main = "Akima Interpolation")
> ##D xi <- linspace(0,15,51)
> ##D yi <- akimaInterp(x, y, xi)
> ##D lines(xi, yi, col = "darkred")
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("andor")
> ### * andor
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: and, or
> ### Title: Logical AND, OR (Matlab Style)
> ### Aliases: and or
> ### Keywords: logic
> 
> ### ** Examples
> 
> A <- matrix(c(0.5,  0.5,  0,    0.75, 0,
+               0.5,  0,    0.75, 0.05, 0.85,
+               0.35, 0,    0,    0,    0.01,
+               0.5,  0.65, 0.65, 0.05, 0), 4, 5, byrow=TRUE)
> B <- matrix(c( 0, 1, 0, 1, 0,
+                1, 1, 1, 0, 1,
+                0, 1, 1, 1, 0,
+                0, 1, 0, 0, 1), 4, 5, byrow=TRUE)
> 
> and(A, B)
     [,1] [,2] [,3] [,4] [,5]
[1,]    0    1    0    1    0
[2,]    1    0    1    0    1
[3,]    0    0    0    0    0
[4,]    0    1    0    0    0
> or(A, B)
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    1    0    1    0
[2,]    1    1    1    1    1
[3,]    1    1    1    1    1
[4,]    1    1    1    1    1
> 
> 
> 
> cleanEx()
> nameEx("andrews")
> ### * andrews
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: andrewsplot
> ### Title: Andrews' Curves
> ### Aliases: andrewsplot
> ### Keywords: graphs
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data(iris)
> ##D s <- sample(1:4, 4)
> ##D A <- as.matrix(iris[, s])
> ##D f <- as.integer(iris[, 5])
> ##D andrewsplot(A, f, style = "pol")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("angle")
> ### * angle
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: angle
> ### Title: Basic Complex Functions
> ### Aliases: Real Imag angle
> ### Keywords: arith
> 
> ### ** Examples
> 
> z <- c(0, 1, 1+1i, 1i)
> Real(z)   # Re(z)
[1] 0 1 1 0
> Imag(z)   # Im(z)
[1] 0 0 1 1
> Conj(z)   # Conj(z)
[1] 0+0i 1+0i 1-1i 0-1i
> abs(z)    # Mod(z)
[1] 0.000000 1.000000 1.414214 1.000000
> angle(z)
[1] 0.0000000 0.0000000 0.7853982 1.5707963
> 
> 
> 
> cleanEx()
> nameEx("anms")
> ### * anms
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: anms
> ### Title: Adaptive Nelder-Mead Minimization
> ### Aliases: anms
> ### Keywords: optimize
> 
> ### ** Examples
> 
> ##  Rosenbrock function
> rosenbrock <- function(x) {
+     n <- length(x)
+     x1 <- x[2:n]
+     x2 <- x[1:(n-1)]
+     sum(100*(x1-x2^2)^2 + (1-x2)^2)
+ }
> 
> anms(rosenbrock, c(0,0,0,0,0))
$xmin
[1] 1 1 1 1 1

$fmin
[1] 8.268732e-21

$nfeval
[1] 1153

> # $xmin
> # [1] 1 1 1 1 1
> # $fmin
> # [1] 8.268732e-21
> # $nfeval
> # [1] 1153
> 
> # To add constraints to the optimization problem, use a slightly 
> # modified objective function. Equality constraints not possible.
> # Warning: Avoid a starting value too near to the boundary !
> 
> ## Not run: 
> ##D # Example: 0.0 <= x <= 0.5
> ##D fun <- function(x) {
> ##D     if (any(x < 0) || any(x > 0.5)) 100
> ##D     else rosenbrock(x)
> ##D }
> ##D x0 <- rep(0.1, 5)
> ##D 
> ##D anms(fun, x0)
> ##D ## $xmin
> ##D ## [1] 0.500000000 0.263051265 0.079972922 0.016228138 0.000267922
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("arclength")
> ### * arclength
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: arclength
> ### Title: Arc Length of a Curve
> ### Aliases: arclength
> ### Keywords: math
> 
> ### ** Examples
> 
> ##  Example: parametrized 3D-curve with t in 0..3*pi
> f <- function(t) c(sin(2*t), cos(t), t)
> arclength(f, 0, 3*pi)
$length
[1] 17.22203

$niter
[1] 8

$rel.err
[1] 1.292881e-06

> # $length:  17.22203            # true length 17.222032...
> 
> ##  Example: length of the sine curve
> f <- function(t) c(t, sin(t))
> arclength(f, 0, pi)             # true length  3.82019...
$length
[1] 3.820198

$niter
[1] 6

$rel.err
[1] 2.780094e-06

> 
> ## Example: Length of an ellipse with axes a = 1 and b = 0.5
> # parametrization x = a*cos(t), y = b*sin(t)
> a <- 1.0; b <- 0.5
> f <- function(t) c(a*cos(t), b*sin(t))
> L <- arclength(f, 0, 2*pi, tol = 1e-10)     #=> 4.84422411027
> # compare with elliptic integral of the second kind
> e <- sqrt(1 - b^2/a^2)                      # ellipticity
> L <- 4 * a * ellipke(e^2)$e                 #=> 4.84422411027
> 
> ## Not run: 
> ##D ##  Example: oscillating 1-dimensional function (from 0 to 5)
> ##D f <- function(x) x * cos(0.1*exp(x)) * sin(0.1*pi*exp(x))
> ##D F <- function(t) c(t, f(t))
> ##D L <- arclength(F, 0, 5, tol = 1e-12, nmax = 25)
> ##D print(L$length, digits = 16)
> ##D # [1] 82.81020372882217         # true length 82.810203728822172...
> ##D 
> ##D # Split this computation in 10 steps (run time drops from 2 to 0.2 secs)
> ##D L <- 0
> ##D for (i in 1:10)
> ##D 	L <- L + arclength(F, (i-1)*0.5, i*0.5, tol = 1e-10)$length
> ##D print(L, digits = 16)
> ##D # [1] 82.81020372882216
> ##D 
> ##D # Alternative calculation of arc length
> ##D f1 <- function(x) sqrt(1 + complexstep(f, x)^2)
> ##D L1 <- quadgk(f1, 0, 5, tol = 1e-14)
> ##D print(L1, digits = 16)
> ##D # [1] 82.81020372882216
> ##D   
> ## End(Not run)
> 
> ## Not run: 
> ##D #-- --------------------------------------------------------------------
> ##D #   Arc-length parametrization of Fermat's spiral
> ##D #-- --------------------------------------------------------------------
> ##D # Fermat's spiral: r = a * sqrt(t) 
> ##D f <- function(t) 0.25 * sqrt(t) * c(cos(t), sin(t))
> ##D 
> ##D t1 <- 0; t2 <- 6*pi
> ##D a  <- 0; b  <- arclength(f, t1, t2)$length
> ##D fParam <- function(w) {
> ##D     fct <- function(u) arclength(f, a, u)$length - w
> ##D     urt <- uniroot(fct, c(a, 6*pi))
> ##D     urt$root
> ##D }
> ##D 
> ##D ts <- linspace(0, 6*pi, 250)
> ##D plot(matrix(f(ts), ncol=2), type='l', col="blue", 
> ##D      asp=1, xlab="", ylab = "",
> ##D      main = "Fermat's Spiral", sub="20 subparts of equal length")
> ##D 
> ##D for (i in seq(0.05, 0.95, by=0.05)) {
> ##D     v <- fParam(i*b); fv <- f(v)
> ##D     points(fv[1], f(v)[2], col="darkred", pch=20)
> ##D } 
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("arnoldi")
> ### * arnoldi
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: arnoldi
> ### Title: Arnoldi Iteration
> ### Aliases: arnoldi
> ### Keywords: math
> 
> ### ** Examples
> 
> A <- matrix(c(-149,   -50,  -154,
+                537,   180,   546,
+                -27,    -9,   -25), nrow = 3, byrow = TRUE)
> a <- arnoldi(A, c(1,0,0))
> a
$Q
     [,1]       [,2]       [,3]
[1,]    1  0.0000000  0.0000000
[2,]    0  0.9987384 -0.0502159
[3,]    0 -0.0502159 -0.9987384

$H
          [,1]         [,2]        [,3]
[1,] -149.0000 -42.20367124  156.316506
[2,]  537.6783 152.55114875 -554.927153
[3,]    0.0000   0.07284727    2.448851

> ## $Q
> ##      [,1]       [,2]       [,3]
> ## [1,]    1  0.0000000  0.0000000
> ## [2,]    0  0.9987384 -0.0502159
> ## [3,]    0 -0.0502159 -0.9987384
> ## 
> ## $H
> ##           [,1]         [,2]        [,3]
> ## [1,] -149.0000 -42.20367124  156.316506
> ## [2,]  537.6783 152.55114875 -554.927153
> ## [3,]    0.0000   0.07284727    2.448851
> 
> a$Q %*% a$H %*% t(a$Q)
     [,1] [,2] [,3]
[1,] -149  -50 -154
[2,]  537  180  546
[3,]  -27   -9  -25
> ##      [,1] [,2] [,3]
> ## [1,] -149  -50 -154
> ## [2,]  537  180  546
> ## [3,]  -27   -9  -25
> 
> 
> 
> cleanEx()
> nameEx("barylag")
> ### * barylag
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: barylag
> ### Title: Barycentric Lagrange Interpolation
> ### Aliases: barylag
> ### Keywords: math
> 
> ### ** Examples
> 
> ##  Generates an example with plot.
> # Input:
> #   fun  ---  function that shall be 'approximated'
> #   a, b ---  interval [a, b] to be used for the example
> #   n    ---  number of supporting nodes
> #   m    ---  number of interpolation points
> # Output
> #   plot of function, interpolation, and nodes
> #   return value is NULL (invisible)
> ## Not run: 
> ##D barycentricExample <- function(fun, a, b, n, m)
> ##D {
> ##D 	xi <- seq(a, b, len=n)
> ##D 	yi <- fun(xi)
> ##D 	x  <- seq(a, b, len=m)
> ##D 
> ##D 	y <- barylag(xi, yi, x)
> ##D 	plot(xi, yi, col="red", xlab="x", ylab="y",
> ##D 		main="Example of barycentric interpolation")
> ##D 
> ##D 	lines(x, fun(x), col="yellow", lwd=2)
> ##D 	lines(x, y, col="darkred")
> ##D 
> ##D 	grid()
> ##D }
> ##D 
> ##D barycentricExample(sin, -pi, pi, 11, 101)  # good interpolation
> ##D barycentricExample(runge, -1, 1, 21, 101)  # bad interpolation
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("barylag2d")
> ### * barylag2d
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: barylag2d
> ### Title: 2-D Barycentric Lagrange Interpolation
> ### Aliases: barylag2d
> ### Keywords: math
> 
> ### ** Examples
> 
> ##  Example from R-help
> xn <- c(4.05, 4.10, 4.15, 4.20, 4.25, 4.30, 4.35)
> yn <- c(60.0, 67.5, 75.0, 82.5, 90.0)
> foo <- matrix(c(
+         -137.8379, -158.8240, -165.4389, -166.4026, -166.2593,
+         -152.1720, -167.3145, -171.1368, -170.9200, -170.4605,
+         -162.2264, -172.5862, -174.1460, -172.9923, -172.2861,
+         -168.7746, -175.2218, -174.9667, -173.0803, -172.1853,
+         -172.4453, -175.7163, -174.0223, -171.5739, -170.5384,
+         -173.7736, -174.4891, -171.6713, -168.8025, -167.6662,
+         -173.2124, -171.8940, -168.2149, -165.0431, -163.8390),
+             nrow = 7, ncol = 5, byrow = TRUE)
> xf <- c(4.075, 4.1)
> yf <- c(63.75, 67.25)
> barylag2d(foo, xn, yn, xf, yf)
          [,1]      [,2]
[1,] -156.7964 -163.1753
[2,] -161.7495 -167.0424
> #  -156.7964 -163.1753
> #  -161.7495 -167.0424
> 
> # Find the minimum of the underlying function
> bar <- function(xy) barylag2d(foo, xn, yn, xy[1], xy[2])
> optim(c(4.25, 67.5), bar)  # "Nelder-Mead"
$par
[1]  4.230547 68.522747

$value
[1] -175.7959

$counts
function gradient 
      57       NA 

$convergence
[1] 0

$message
NULL

> # $par
> # 4.230547 68.522747
> # $value
> # -175.7959
> 
> ## Not run: 
> ##D # Image and contour plots
> ##D image(xn, yn, foo)
> ##D contour(xn, yn, foo, col="white", add = TRUE)
> ##D xs <- seq(4.05, 4.35, length.out = 51)
> ##D ys <- seq(60.0, 90.0, length.out = 51)
> ##D zz <- barylag2d(foo, xn, yn, xs, ys)
> ##D contour(xs, ys, zz, nlevels = 20, add = TRUE)
> ##D contour(xs, ys, zz, levels=c(-175, -175.5), add = TRUE)
> ##D points(4.23, 68.52)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("beep")
> ### * beep
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: disp,beep
> ### Title: Utility functions (Matlab style)
> ### Aliases: disp beep
> ### Keywords: utilities
> 
> ### ** Examples
> 
> disp("Some text, and numbers:", pi, exp(1))
Some text, and numbers: 3.141593 2.718282 
> # beep()
> 
> 
> 
> cleanEx()
> nameEx("bernoulli")
> ### * bernoulli
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bernoulli
> ### Title: Bernoulli Numbers and Polynomials
> ### Aliases: bernoulli
> ### Keywords: specfun
> 
> ### ** Examples
> 
> bernoulli(10)
 [1]  1.00000000 -0.50000000  0.16666667  0.00000000 -0.03333333  0.00000000
 [7]  0.02380952  0.00000000 -0.03333333  0.00000000  0.07575758
> # 1.00000000 -0.50000000  0.16666667  0.00000000 -0.03333333
> # 0.00000000  0.02380952  0.00000000 -0.03333333  0.00000000  0.07575758
>                 #
> ## Not run: 
> ##D x1 <- linspace(0.3, 0.7, 2)
> ##D y1 <- bernoulli(1, x1)
> ##D plot(x1, y1, type='l', col='red', lwd=2,
> ##D      xlim=c(0.0, 1.0), ylim=c(-0.2, 0.2),
> ##D      xlab="", ylab="", main="Bernoulli Polynomials")
> ##D grid()
> ##D xs <- linspace(0, 1, 51)
> ##D lines(xs, bernoulli(2, xs), col="green", lwd=2)
> ##D lines(xs, bernoulli(3, xs), col="blue", lwd=2)
> ##D lines(xs, bernoulli(4, xs), col="cyan", lwd=2)
> ##D lines(xs, bernoulli(5, xs), col="brown", lwd=2)
> ##D lines(xs, bernoulli(6, xs), col="magenta", lwd=2)
> ##D legend(0.75, 0.2, c("B_1", "B_2", "B_3", "B_4", "B_5", "B_6"),
> ##D        col=c("red", "green", "blue", "cyan", "brown", "magenta"),
> ##D        lty=1, lwd=2)
> ##D   
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("bernstein")
> ### * bernstein
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bernstein
> ### Title: Bernstein Polynomials
> ### Aliases: bernstein bernsteinb
> ### Keywords: math
> 
> ### ** Examples
> 
> ## Example
> f <- function(x) sin(2*pi*x)
> xs <- linspace(0, 1)
> ys <- f(xs)
> ## Not run: 
> ##D plot(xs, ys, type='l', col="blue",
> ##D      main="Bernstein Polynomials")
> ##D grid()
> ##D b10  <- bernstein(f,  10, xs)
> ##D b100 <- bernstein(f, 100, xs)
> ##D lines(xs, b10,  col="magenta")
> ##D lines(xs, b100, col="red") 
> ## End(Not run)
> 
> # Bernstein basis polynomials
> ## Not run: 
> ##D xs <- linspace(0, 1)
> ##D plot(c(0,1), c(0,1), type='n',
> ##D      main="Bernstein Basis Polynomials")
> ##D grid()
> ##D n = 10
> ##D for (i in 0:n) {
> ##D     bs <- bernsteinb(i, n, xs)
> ##D     lines(xs, bs, col=i+1)
> ##D } 
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("bisect")
> ### * bisect
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bisect
> ### Title: Rootfinding Through Bisection or Secant Rule
> ### Aliases: bisect secant regulaFalsi
> ### Keywords: math
> 
> ### ** Examples
> 
> bisect(sin, 3.0, 4.0)
$root
[1] 3.141593

$f.root
[1] 1.224647e-16

$iter
[1] 52

$estim.prec
[1] 4.440892e-16

> # $root             $f.root             $iter   $estim.prec
> # 3.1415926536      1.2246467991e-16    52      4.4408920985e-16
> 
> bisect(sin, -1.0, 1.0)
$root
[1] 0

$f.root
[1] 0

$iter
[1] 2

$estim.prec
[1] 0

> # $root             $f.root             $iter   $estim.prec
> # 0                 0                   2       0
> 
> # Legendre polynomial of degree 5
> lp5 <- c(63, 0, -70, 0, 15, 0)/8
> f <- function(x) polyval(lp5, x)
> bisect(f, 0.6, 1)       # 0.9061798453      correct to 15 decimals
$root
[1] 0.9061798

$f.root
[1] 6.661338e-16

$iter
[1] 53

$estim.prec
[1] 1.110223e-16

> secant(f, 0.6, 1)       # 0.5384693         different root
$root
[1] 0.5384693

$f.root
[1] -1.872942e-10

$iter
[1] 7

$estim.prec
[1] 1.016315e-06

> regulaFalsi(f, 0.6, 1)  # 0.9061798459      correct to 10 decimals
$root
[1] 0.9061798

$f.root
[1] -3.996803e-15

$niter
[1] 11

$estim.prec
[1] 8.886614e-09

> 
> 
> 
> cleanEx()
> nameEx("bits")
> ### * bits
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bits
> ### Title: Binary Representation
> ### Aliases: bits
> ### Keywords: arith
> 
> ### ** Examples
> 
> bits(2^10)        # "10000000000"
[1] "10000000000"
> bits(1 + 2^-10)   #  "1.000000000100000000000000000000000000000000000000000000"
[1] "1.000000000100000000000000000000000000000000000000000000"
> bits(pi)          # "11.001001000011111101101010100010001000010110100011000000"
[1] "11.001001000011111101101010100010001000010110100011000000"
> bits(1/3.0)       #  "0.010101010101010101010101010101010101010101010101010101"
[1] "0.010101010101010101010101010101010101010101010101010101"
> bits(1 + eps())   #  "1.000000000000000000000000000000000000000000000000000100"
[1] "1.000000000000000000000000000000000000000000000000000100"
> 
> 
> 
> cleanEx()
> nameEx("blanks")
> ### * blanks
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: blanks
> ### Title: String of Blank Carakters
> ### Aliases: blanks
> ### Keywords: string
> 
> ### ** Examples
> 
> blanks(6)
[1] "      "
> 
> 
> 
> cleanEx()
> nameEx("blkdiag")
> ### * blkdiag
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: blkdiag
> ### Title: Block Diagonal Matrix
> ### Aliases: blkdiag
> ### Keywords: array
> 
> ### ** Examples
> 
> a1 <- matrix(c(1,2), 1)
> a2 <- as.matrix(c(1,2))
> blkdiag(a1, diag(1, 2, 2), a2)
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    2    0    0    0
[2,]    0    0    1    0    0
[3,]    0    0    0    1    0
[4,]    0    0    0    0    1
[5,]    0    0    0    0    2
> 
> 
> 
> cleanEx()
> nameEx("brentdekker")
> ### * brentdekker
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: brentDekker
> ### Title: Brent-Dekker Root Finding Algorithm
> ### Aliases: brentDekker brent
> ### Keywords: math
> 
> ### ** Examples
> 
> # Legendre polynomial of degree 5
> lp5 <- c(63, 0, -70, 0, 15, 0)/8
> f <- function(x) polyval(lp5, x)
> brent(f, 0.6, 1)                # 0.9061798459 correct to 12 places
$root
[1] 0.9061798

$f.root
[1] -4.440892e-16

$f.calls
[1] 14

$estim.prec
[1] 2.306155e-12

> 
> 
> 
> cleanEx()
> nameEx("brown72")
> ### * brown72
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: brown72
> ### Title: Brownian Motion
> ### Aliases: brown72
> ### Keywords: datasets
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data(brown72)
> ##D plot(brown72, type = "l", col = "blue")
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("broyden")
> ### * broyden
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: broyden
> ### Title: Broyden's Method
> ### Aliases: broyden
> ### Keywords: math
> 
> ### ** Examples
> 
> ##  Example from Quarteroni & Saleri
> F1 <- function(x) c(x[1]^2 + x[2]^2 - 1, sin(pi*x[1]/2) + x[2]^3)
> broyden(F1, x0 = c(1, 1))
$zero
[1]  0.4760958 -0.8793934

$fnorm
[1] 9.092626e-09

$niter
[1] 13

> # zero: 0.4760958 -0.8793934; fnorm: 9.092626e-09; niter: 13
> 
> F <- function(x) {
+     x1 <- x[1]; x2 <- x[2]; x3 <- x[3]
+     as.matrix(c(x1^2 + x2^2 + x3^2 - 1,
+                 x1^2 + x3^2 - 0.25,
+                 x1^2 + x2^2 - 4*x3), ncol = 1)
+ }
> x0 <- as.matrix(c(1, 1, 1))
> broyden(F, x0)
$zero
[1] 0.4407629 0.8660254 0.2360680

$fnorm
[1] 1.34325e-08

$niter
[1] 8

> # zero: 0.4407629 0.8660254 0.2360680; fnorm: 1.34325e-08; niter: 8
> 
> ##  Find the roots of the complex function sin(z)^2 + sqrt(z) - log(z)
> F2 <- function(x) {
+     z  <- x[1] + x[2]*1i
+     fz <- sin(z)^2 + sqrt(z) - log(z)
+     c(Re(fz), Im(fz))
+ }
> broyden(F2, c(1, 1))
$zero
[1] 0.2555197 0.8948303

$fnorm
[1] 7.284373e-10

$niter
[1] 13

> # zero   0.2555197 0.8948303 , i.e.  z0 = 0.2555 + 0.8948i
> # fnorm  7.284374e-10
> # niter  13
> 
> ##  Two more problematic examples
> F3 <- function(x)
+         c(2*x[1] - x[2] - exp(-x[1]), -x[1] + 2*x[2] - exp(-x[2]))
> broyden(F3, c(0, 0))
$zero
[1] 0.5671433 0.5671433

$fnorm
[1] 4.677305e-12

$niter
[1] 5

> # $zero   0.5671433 0.5671433   # x = exp(-x)
> 
> F4 <- function(x)   # Dennis Schnabel
+         c(x[1]^2 + x[2]^2 - 2, exp(x[1] - 1) + x[2]^3 - 2)
> broyden(F4, c(2.0, 0.5), maxiter = 100)
$zero
[1] 1 1

$fnorm
[1] 1.188186e-10

$niter
[1] 43

> 
> 
> 
> cleanEx()
> nameEx("bsxfun")
> ### * bsxfun
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bsxfun
> ### Title: Elementwise Function Application (Matlab Style)
> ### Aliases: bsxfun arrayfun
> ### Keywords: math
> 
> ### ** Examples
> 
> X <- matrix(rep(1:10, each = 10), 10, 10)
> Y <- t(X)
> bsxfun("*", X, Y)  # multiplication table
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
 [1,]    1    2    3    4    5    6    7    8    9    10
 [2,]    2    4    6    8   10   12   14   16   18    20
 [3,]    3    6    9   12   15   18   21   24   27    30
 [4,]    4    8   12   16   20   24   28   32   36    40
 [5,]    5   10   15   20   25   30   35   40   45    50
 [6,]    6   12   18   24   30   36   42   48   54    60
 [7,]    7   14   21   28   35   42   49   56   63    70
 [8,]    8   16   24   32   40   48   56   64   72    80
 [9,]    9   18   27   36   45   54   63   72   81    90
[10,]   10   20   30   40   50   60   70   80   90   100
> 
> f <- function(x, y) x[1] * y[1]     # function not vectorized
> A <- matrix(c(2, 3, 5, 7), 2, 2)
> B <- matrix(c(11, 13, 17, 19), 2, 2)
> arrayfun(f, A, B)
     [,1] [,2]
[1,]   22   85
[2,]   39  133
> 
> 
> 
> cleanEx()
> nameEx("bvp")
> ### * bvp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bvp
> ### Title: Boundary Value Problems
> ### Aliases: bvp
> ### Keywords: ode
> 
> ### ** Examples
> 
> ##  Solve y'' = 2*x/(1+x^2)*y' - 2/(1+x^2) * y + 1
> ##  with y(0) = 1.25 and y(4) = -0.95 on the interval [0, 4]:
> f1 <- function(x) 2*x / (1 + x^2)
> f2 <- function(x)  -2 / (1 + x^2)
> f3 <- function(x) rep(1, length(x))     # vectorized constant function 1
> x <- c(0.0,   4.0)
> y <- c(1.25, -0.95)
> sol <- bvp(f1, f2, f3, x, y)
> ## Not run: 
> ##D plot(sol$xs, sol$ys, ylim = c(-2, 2),
> ##D      xlab = "", ylab = "", main = "Boundary Value Problem")
> ##D # The analytic solution is
> ##D sfun <- function(x) 1.25 + 0.4860896526*x - 2.25*x^2 + 
> ##D                     2*x*atan(x) - 1/2 * log(1+x^2) + 1/2 * x^2 * log(1+x^2)
> ##D xx <- linspace(0, 4)
> ##D yy <- sfun(xx)
> ##D lines(xx, yy, col="red")
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("cart2sph")
> ### * cart2sph
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cart2sph
> ### Title: Coordinate Transformations
> ### Aliases: cart2sph sph2cart cart2pol pol2cart
> ### Keywords: math
> 
> ### ** Examples
> 
> x <- 0.5*cos(pi/6); y <- 0.5*sin(pi/6); z <- sqrt(1 - x^2 - y^2)
> (s <-cart2sph(c(x, y, z)))      # 0.5235988 1.0471976 1.0000000
[1] 0.5235988 1.0471976 1.0000000
> sph2cart(s)                     # 0.4330127 0.2500000 0.8660254
[1] 0.4330127 0.2500000 0.8660254
> 
> cart2pol(c(1,1))                # 0.7853982 1.4142136
[1] 0.7853982 1.4142136
> cart2pol(c(1,1,0))              # 0.7853982 1.4142136 0.0000000
[1] 0.7853982 1.4142136 0.0000000
> pol2cart(c(pi/2, 1))            # 6.123234e-17 1.000000e+00
[1] 6.123234e-17 1.000000e+00
> pol2cart(c(pi/4, 1, 1))         # 0.7071068 0.7071068 1.0000000
[1] 0.7071068 0.7071068 1.0000000
> 
> ##  Transform spherical to cylindrical coordinates and vice versa
> #   sph2cyl <- function(th.ph.r) cart2pol(sph2cart(th.ph.r))
> #   cyl2sph <- function(phi.r.z) cart2sph(pol2cart(phi.r.z))
> 
> 
> 
> cleanEx()
> nameEx("cd")
> ### * cd
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cd, pwd, what
> ### Title: Directory Functions (Matlab style)
> ### Aliases: cd pwd what
> ### Keywords: utilities
> 
> ### ** Examples
> 
> # cd()
> # pwd()
> # what()
> 
> 
> 
> cleanEx()
> nameEx("ceil")
> ### * ceil
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ceil
> ### Title: Integer Functions (Matlab Style)
> ### Aliases: ceil Fix
> ### Keywords: arith
> 
> ### ** Examples
> 
> x <- c(-1.2, -0.8, 0, 0.5, 1.1, 2.9)
> ceil(x)
[1] -1  0  0  1  2  3
> Fix(x)
[1] -1  0  0  0  1  2
> 
> 
> 
> cleanEx()
> nameEx("charpoly")
> ### * charpoly
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: charpoly
> ### Title: Characteristic Polynomial
> ### Aliases: charpoly
> ### Keywords: array
> 
> ### ** Examples
> 
> a <- magic(5)
> A <- charpoly(a, info = TRUE)
Error term: 0 
> A$cp
[1]        1      -65     -625    40625    78000 -5070000
> roots(A$cp)
[1]  65.00000 -21.27677  21.27677 -13.12628  13.12628
> A$det
[1] 5070000
> zapsmall(A$inv %*% a)
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    0    0    0    0
[2,]    0    1    0    0    0
[3,]    0    0    1    0    0
[4,]    0    0    0    1    0
[5,]    0    0    0    0    1
> 
> 
> 
> cleanEx()
> nameEx("chebApprox")
> ### * chebApprox
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: chebApprox
> ### Title: Chebyshev Approximation
> ### Aliases: chebApprox
> ### Keywords: math
> 
> ### ** Examples
> 
> # Approximate sin(x) on [-pi, pi] with a polynomial of degree 9 !
> # This polynomial has to be beaten:
> # P(x) = x - 1/6*x^3 + 1/120*x^5 - 1/5040*x^7 + 1/362880*x^9
> 
> # Compare these polynomials
> p1 <- rev(c(0, 1, 0, -1/6, 0, 1/120, 0, -1/5040, 0, 1/362880))
> p2 <- chebCoeff(sin, -pi, pi, 9)
> 
> # Estimate the maximal distance
> x  <- seq(-pi, pi, length.out = 101)
> ys <- sin(x)
> yp <- polyval(p1, x)
> yc <- chebApprox(x, sin, -pi, pi, 9)
> max(abs(ys-yp))                       # 0.006925271
[1] 0.006925271
> max(abs(ys-yc))                       # 1.151207e-05
[1] 1.151207e-05
> 
> ## Not run: 
> ##D # Plot the corresponding curves
> ##D plot(x, ys, type = "l", col = "gray", lwd = 5)
> ##D lines(x, yp, col = "navy")
> ##D lines(x, yc, col = "red")
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("chebCoeff")
> ### * chebCoeff
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: chebCoeff
> ### Title: Chebyshev Polynomials
> ### Aliases: chebCoeff
> ### Keywords: math
> 
> ### ** Examples
> 
> ##  Chebyshev coefficients for x^2 + 1
> n <- 4
> f2 <- function(x) x^2 + 1
> cC <- chebCoeff(f2, -1, 1, n)  #  3.0   0  0.5   0   0
> cC[1] <- cC[1]/2               # correcting the absolute Chebyshev term
>                                # i.e.  1.5*T_0 + 0.5*T_2
> cP <- chebPoly(n)              # summing up the polynomial coefficients
> p <- cC %*% cP                 #  0 0 1 0 1
> 
> 
> 
> cleanEx()
> nameEx("chebPoly")
> ### * chebPoly
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: chebPoly
> ### Title: Chebyshev Polynomials
> ### Aliases: chebPoly
> ### Keywords: math
> 
> ### ** Examples
> 
> chebPoly(6)
     [,1] [,2] [,3] [,4] [,5] [,6] [,7]
[1,]    0    0    0    0    0    0    1
[2,]    0    0    0    0    0    1    0
[3,]    0    0    0    0    2    0   -1
[4,]    0    0    0    4    0   -3    0
[5,]    0    0    8    0   -8    0    1
[6,]    0   16    0  -20    0    5    0
[7,]   32    0  -48    0   18    0   -1
> 
> ## Not run: 
> ##D ##  Plot 6 Chebyshev Polynomials
> ##D plot(0, 0, type="n", xlim=c(-1, 1), ylim=c(-1.2, 1.2),
> ##D     main="Chebyshev Polynomials for n=1..6", xlab="x", ylab="y")
> ##D grid()
> ##D x <- seq(-1, 1, length.out = 101)
> ##D for (i in 1:6) {
> ##D     y <- chebPoly(i, x)
> ##D     lines(x, y, col=i)
> ##D }
> ##D legend(x = 0.55, y = 1.2, c("n=1", "n=2", "n=3", "n=4", "n=5", "n=6"),
> ##D     col = 1:6, lty = 1, bg="whitesmoke", cex = 0.75)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("circlefit")
> ### * circlefit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: circlefit
> ### Title: Fitting a Circle
> ### Aliases: circlefit
> ### Keywords: fitting
> 
> ### ** Examples
> 
> # set.seed(8421)
> n  <- 20
> w  <- 2*pi*runif(n)
> xp <- cos(w) + 1 + 0.25 * (runif(n) - 0.5)
> yp <- sin(w) + 1 + 0.25 * (runif(n) - 0.5)
> 
> circe <- circlefit(xp, yp)  #=> 0.9899628 1.0044920 1.0256633
RMS error: 0.05993561 
>                             # RMS error: 0.07631986 
> ## Not run: 
> ##D x0 <- circe[1]; y0 <- circe[2]; r0 <- circe[3]
> ##D plot(c(-0.2, 2.2), c(-0.2, 2.2), type="n", asp=1)
> ##D grid()
> ##D abline(h=0, col="gray"); abline(v=0, col="gray")
> ##D points(xp, yp, col="darkred")
> ##D 
> ##D w  <- seq(0, 2*pi, len=100)
> ##D xx <- r0 * cos(w) + x0
> ##D yy <- r0 * sin(w) + y0
> ##D lines(xx, yy, col="blue")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("clear")
> ### * clear
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: clear, who(s), ver
> ### Title: Clear function (Matlab style)
> ### Aliases: clear ver who whos
> ### Keywords: utilities
> 
> ### ** Examples
> 
> # clear()  # DON'T
> # who()
> # whos()
> # ver()
> 
> 
> 
> cleanEx()
> nameEx("clenshaw_curtis")
> ### * clenshaw_curtis
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: clenshaw_curtis
> ### Title: Clenshaw-Curtis Quadrature Formula
> ### Aliases: clenshaw_curtis
> ### Keywords: math
> 
> ### ** Examples
> 
> ##  Quadrature with Chebyshev nodes and weights
> f <- function(x) sin(x+cos(10*exp(x))/3)
> ## Not run: ezplot(f, -1, 1, fill = TRUE)
> cc <- clenshaw_curtis(f, n = 64)  #=>  0.0325036517151 , true error > 1.3e-10
> 
> 
> 
> cleanEx()
> nameEx("combs")
> ### * combs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: combs
> ### Title: Generate Combinations
> ### Aliases: combs
> ### Keywords: arith
> 
> ### ** Examples
> 
> combs(seq(2, 10, by=2), m = 3)
      [,1] [,2] [,3]
 [1,]    2    4    6
 [2,]    2    4    8
 [3,]    2    4   10
 [4,]    2    6    8
 [5,]    2    6   10
 [6,]    2    8   10
 [7,]    4    6    8
 [8,]    4    6   10
 [9,]    4    8   10
[10,]    6    8   10
> 
> 
> 
> cleanEx()
> nameEx("compan")
> ### * compan
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: compan
> ### Title: Companion Matrix
> ### Aliases: compan
> ### Keywords: array
> 
> ### ** Examples
> 
>   p <- c(1, 0, -7, 6)
>   compan(p)
     [,1] [,2] [,3]
[1,]    0    7   -6
[2,]    1    0    0
[3,]    0    1    0
>   # 0  7 -6
>   # 1  0  0
>   # 0  1  0
> 
> 
> 
> cleanEx()
> nameEx("complexstep")
> ### * complexstep
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: complexstep
> ### Title: Complex Step Derivatives
> ### Aliases: complexstep grad_csd jacobian_csd hessian_csd laplacian_csd
> ### Keywords: math
> 
> ### ** Examples
> 
> ##  Example from Martins et al.
> f <- function(x) exp(x)/sqrt(sin(x)^3 + cos(x)^3)  # derivative at x0 = 1.5
> # central diff formula    # 4.05342789402801, error 1e-10
> # numDeriv::grad(f, 1.5)  # 4.05342789388197, error 1e-12  Richardson
> # pracma::numderiv        # 4.05342789389868, error 5e-14  Richardson
> complexstep(f, 1.5)       # 4.05342789389862, error 1e-15
[1] 4.053428
> # Symbolic calculation:   # 4.05342789389862
> 
> jacobian_csd(f, 1.5)
         [,1]
[1,] 4.053428
> 
> f1 <- function(x) sum(sin(x))
> grad_csd(f1, rep(2*pi, 3))
[1] 1 1 1
> ## [1] 1 1 1
> 
> laplacian_csd(f1, rep(pi/2, 3))
[1] -3
> ## [1] -3
> 
> f2 <- function(x) c(sin(x[1]) * exp(-x[2]))
> hessian_csd(f2, c(0.1, 0.5, 0.9))
            [,1]        [,2] [,3]
[1,] -0.06055203 -0.60350053    0
[2,] -0.60350053  0.06055203    0
[3,]  0.00000000  0.00000000    0
> ##             [,1]        [,2] [,3]
> ## [1,] -0.06055203 -0.60350053    0
> ## [2,] -0.60350053  0.06055203    0
> ## [3,]  0.00000000  0.00000000    0
> 
> f3 <- function(u) {
+     x <- u[1]; y <- u[2]; z <- u[3]
+     matrix(c(exp(x^+y^2), sin(x+y), sin(x)*cos(y), x^2 - y^2), 2, 2)
+   }
> jacobian_csd(f3, c(1,1,1))
           [,1]       [,2] [,3]
[1,]  2.7182818  0.0000000    0
[2,] -0.4161468 -0.4161468    0
[3,]  0.2919266 -0.7080734    0
[4,]  2.0000000 -2.0000000    0
> ##            [,1]       [,2] [,3]
> ## [1,]  2.7182818  0.0000000    0
> ## [2,] -0.4161468 -0.4161468    0
> ## [3,]  0.2919266 -0.7080734    0
> ## [4,]  2.0000000 -2.0000000    0
> 
> 
> 
> cleanEx()
> nameEx("cond")
> ### * cond
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cond
> ### Title: Matrix Condition
> ### Aliases: cond
> ### Keywords: array
> 
> ### ** Examples
> 
> cond(hilb(8))
[1] 15257575538
> 
> 
> 
> cleanEx()
> nameEx("conv")
> ### * conv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: conv
> ### Title: Polynomial Convolution
> ### Aliases: conv
> ### Keywords: timeseries
> 
> ### ** Examples
> 
> conv(c(1, 1, 1), 1)
[1] 1 1 1
> conv(c(1, 1, 1), c(0, 0, 1))
[1] 3.330669e-17 8.881784e-17 1.000000e+00 1.000000e+00 1.000000e+00
> conv(c(-0.5, 1, -1), c(0.5, 0, 1))
[1] -0.25  0.50 -1.00  1.00 -1.00
> 
> 
> 
> cleanEx()
> nameEx("cotes")
> ### * cotes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cotes
> ### Title: Newton-Cotes Formulas
> ### Aliases: cotes
> ### Keywords: math
> 
> ### ** Examples
> 
> cotes(sin, 0, pi/2, 20, 2)      # 0.999485905248533
[1] 0.9994859
> cotes(sin, 0, pi/2, 20, 3)      # 1.000000211546591
[1] 1
> cotes(sin, 0, pi/2, 20, 4)      # 1.000000391824184
[1] 1
> cotes(sin, 0, pi/2, 20, 5)      # 0.999999999501637
[1] 1
> cotes(sin, 0, pi/2, 20, 6)      # 0.999999998927507
[1] 1
> cotes(sin, 0, pi/2, 20, 7)      # 1.000000000000363  odd degree is better
[1] 1
> cotes(sin, 0, pi/2, 20, 8)      # 1.000000000002231
[1] 1
> 
> 
> 
> cleanEx()
> nameEx("cranknic")
> ### * cranknic
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cranknic
> ### Title: Crank-Nicolson Method
> ### Aliases: cranknic
> ### Keywords: ode
> 
> ### ** Examples
> 
> ##  Newton's example
> f <- function(x, y) 1 - 3*x + y + x^2 + x*y
> sol100  <- cranknic(f, 0, 1, 0, N = 100)
> sol1000 <- cranknic(f, 0, 1, 0, N = 1000)
> 
> ## Not run: 
> ##D # Euler's forward approach
> ##D feuler <- function(f, t0, t1, y0, n) {
> ##D     h <- (t1 - t0)/n;  x <- seq(t0, t1, by = h)
> ##D     y <- numeric(n+1); y[1] <- y0
> ##D     for (i in 1:n) y[i+1] <- y[i] + h * f(x[i], y[i])
> ##D     return(list(x = x, y = y))
> ##D }
> ##D 
> ##D solode <- ode23(f, 0, 1, 0)
> ##D soleul <- feuler(f, 0, 1, 0, 100)
> ##D 
> ##D plot(soleul$x, soleul$y, type = "l", col = "blue", 
> ##D      xlab = "", ylab = "", main = "Newton's example")
> ##D lines(solode$t, solode$y, col = "gray", lwd = 3)
> ##D lines(sol100$t, sol100$y, col = "red")
> ##D lines(sol1000$t, sol1000$y, col = "green")
> ##D grid()
> ##D 
> ##D ##  System of differential equations
> ##D # "Herr und Hund"
> ##D fhh <- function(x, y) {
> ##D     y1 <- y[1]; y2 <- y[2]
> ##D     s <- sqrt(y1^2 + y2^2)
> ##D     dy1 <- 0.5 - 0.5*y1/s
> ##D     dy2 <- -0.5*y2/s
> ##D     return(c(dy1, dy2))
> ##D }
> ##D 
> ##D sol <- cranknic(fhh, 0, 60, c(0, 10))
> ##D plot(sol$y[, 1], sol$y[, 2], type = "l", col = "blue",
> ##D      xlab = "", ylab = "", main = '"Herr und Hund"')
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("cross")
> ### * cross
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cross
> ### Title: Vector Cross Product
> ### Aliases: cross
> ### Keywords: array
> 
> ### ** Examples
> 
>   cross(c(1, 2, 3), c(4, 5, 6))  # -3  6 -3
[1] -3  6 -3
> 
> 
> 
> cleanEx()
> nameEx("crossn")
> ### * crossn
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: crossn
> ### Title: n-dimensional Vector Cross Product
> ### Aliases: crossn
> ### Keywords: array
> 
> ### ** Examples
> 
> A <- matrix(c(1,0,0, 0,1,0), nrow=2, ncol=3, byrow=TRUE)
> crossn(A)  #=> 0 0 1
[1] 0 0 1
> 
> x <- c(1.0, 0.0, 0.0)
> y <- c(1.0, 0.5, 0.0)
> z <- c(0.0, 0.0, 1.0)
> identical(dot(x, crossn(rbind(y, z))), det(rbind(x, y, z)))
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("cubicspline")
> ### * cubicspline
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cubicspline
> ### Title: Interpolating Cubic Spline
> ### Aliases: cubicspline
> ### Keywords: fitting
> 
> ### ** Examples
> 
> ##  Example: Average temperatures at different latitudes
> x <- seq(-55, 65, by = 10)
> y <- c(-3.25, -3.37, -3.35, -3.20, -3.12, -3.02, -3.02,
+        -3.07, -3.17, -3.32, -3.30, -3.22, -3.10)
> xs <- seq(-60, 70, by = 1)
> 
> # Generate a function for this
> pp <- cubicspline(x, y)
> ppfun <- function(xs) ppval(pp, xs)
> 
> ## Not run: 
> ##D # Plot with and without endpoint correction
> ##D plot(x, y, col = "darkblue",
> ##D            xlim = c(-60, 70), ylim = c(-3.5, -2.8),
> ##D            xlab = "Latitude", ylab = "Temp. Difference",
> ##D            main = "Earth Temperatures per Latitude")
> ##D lines(spline(x, y), col = "darkgray")
> ##D grid()
> ##D 
> ##D ys <- cubicspline(x, y, xs, endp2nd = TRUE)     # der = 0 at endpoints
> ##D lines(xs, ys, col = "red")
> ##D ys <- cubicspline(x, y, xs)                     # no endpoint condition
> ##D lines(xs, ys, col = "darkred")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("curvefit")
> ### * curvefit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: curvefit
> ### Title: Parametric Curve Fit
> ### Aliases: curvefit
> ### Keywords: fitting
> 
> ### ** Examples
> 
> ##  Approximating half circle arc with small perturbations
> N <- 50
> u <- linspace(0, pi, N)
> x <- cos(u) + 0.05 * randn(1, N)
> y <- sin(u) + 0.05 * randn(1, N)
> n <- 8
> cfit1 <- curvefit(u, x, y, n)
> ## Not run: 
> ##D plot(x, y, col = "darkgray", pch = 19, asp = 1)
> ##D xp <- cfit1$xp; yp <- cfit1$yp
> ##D lines(xp, yp, col="blue")
> ##D grid()
> ## End(Not run)
> 
> ##  Fix the end points at t = 0 and t = pi
> U <- c(0, pi)
> V <- matrix(c(1, 0, -1, 0), 2, 2, byrow = TRUE)
> cfit2 <- curvefit(u, x, y, n, U, V)
> ## Not run: 
> ##D xp <- cfit2$xp; yp <- cfit2$yp
> ##D lines(xp, yp, col="red")
> ## End(Not run)
> 
> ## Not run: 
> ##D ##  Archimedian spiral
> ##D n <- 8
> ##D u <- linspace(0, 3*pi, 50)
> ##D a <- 1.0
> ##D x <- as.matrix(a*u*cos(u))
> ##D y <- as.matrix(a*u*sin(u))
> ##D plot(x, y, type = "p", pch = 19, col = "darkgray", asp = 1)
> ##D lines(x, y, col = "darkgray", lwd = 3)
> ##D cfit <- curvefit(u, x, y, n)
> ##D px <- c(cfit$px); py <- c(cfit$py)
> ##D v <- linspace(0, 3*pi, 200)
> ##D xs <- polyval(px, v)
> ##D ys <- polyval(py, v)
> ##D lines(xs, ys, col = "navy")
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("cutpoints")
> ### * cutpoints
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cutpoints
> ### Title: Find Cutting Points
> ### Aliases: cutpoints
> ### Keywords: timeseries
> 
> ### ** Examples
> 
> N <- 100; x <- sort(runif(N))
> cp <- cutpoints(x, 6, 0.9)
> n <- length(cp$cutp)
> 
> # Print out
> nocp <- rle(findInterval(x, c(-Inf, cp$cutp, Inf)))$lengths
> cbind(c(-Inf, cp$cutp), c(cp$cutp, Inf), nocp)
                           nocp
[1,]       -Inf 0.04113279    2
[2,] 0.04113279 0.15993057    9
[3,] 0.15993057 0.22588597    6
[4,] 0.22588597 0.28041202    6
[5,] 0.28041202 0.58620959   33
[6,] 0.58620959 0.97626205   43
[7,] 0.97626205        Inf    1
> 
> # Define a factor from the cutting points
> fx <- cut(x, breaks = c(-Inf, cp$cutp, Inf))
> 
> ## Not run: 
> ##D # Plot points and cutting points
> ##D plot(x, rep(0, N), col="gray", ann = FALSE)
> ##D points(cp$cutp, rep(0, n), pch="|", col=2)
> ##D 
> ##D # Compare with k-means clustering
> ##D km <- kmeans(x, n)
> ##D points(x, rep(0, N), col = km$cluster, pch = "+")
> ##D 
> ##D ##  A 2-dimensional example
> ##D x <- y <- c()
> ##D for (i in 1:9) {
> ##D   for (j in 1:9) {
> ##D     x <- c(x, i + rnorm(20, 0, 0.2))
> ##D     y <- c(y, j + rnorm(20, 0, 0.2))
> ##D   }
> ##D }
> ##D cpx <- cutpoints(x, 8, 0)
> ##D cpy <- cutpoints(y, 8, 0)
> ##D 
> ##D plot(x, y, pch = 18, col=rgb(0.5,0.5,0.5), axes=FALSE, ann=FALSE)
> ##D for (xi in cpx$cutp) abline(v=xi, col=2, lty=2)
> ##D for (yi in cpy$cutp) abline(h=yi, col=2, lty=2)
> ##D 
> ##D km <- kmeans(cbind(x, y), 81)
> ##D points(x, y, col=km$cluster)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("dblquad")
> ### * dblquad
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dblquad
> ### Title: Double and Triple Integration
> ### Aliases: dblquad triplequad
> ### Keywords: math
> 
> ### ** Examples
> 
> f1 <- function(x, y) x^2 + y^2
> dblquad(f1, -1, 1, -1, 1)       #   2.666666667 , i.e. 8/3 . err = 0
[1] 2.666667
> 
> f2 <- function(x, y) y*sin(x)+x*cos(y)
> dblquad(f2, pi, 2*pi, 0, pi)    #  -9.869604401 , i.e. -pi^2, err = 0
[1] -9.869604
> 
> # f3 <- function(x, y) sqrt((1 - (x^2 + y^2)) * (x^2 + y^2 <= 1))
> f3 <- function(x, y) sqrt(pmax(0, 1 - (x^2 + y^2)))
> dblquad(f3, -1, 1, -1, 1)       #   2.094395124 , i.e. 2/3*pi , err = 2e-8
[1] 2.094395
> 
> f4 <- function(x, y, z) y*sin(x)+z*cos(x)
> triplequad(f4, 0,pi, 0,1, -1,1) # - 2.0 => -2.220446e-16
[1] 2
> 
> 
> 
> cleanEx()
> nameEx("deconv")
> ### * deconv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: deconv
> ### Title: Deconvolution
> ### Aliases: deconv
> ### Keywords: timeseries
> 
> ### ** Examples
> 
> b <- c(10, 40, 100, 160, 170, 120)
> a <- c(1, 2, 3, 4)
> 
> p <- deconv(b, a)
> p$q                #=> 10 20 30
[1] 10 20 30
> p$r                #=>  0  0  0
[1] 0 0 0
> 
> 
> 
> cleanEx()
> nameEx("deeve")
> ### * deeve
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: deeve
> ### Title: Event Detection in ODE solution
> ### Aliases: deeve
> ### Keywords: ode
> 
> ### ** Examples
> 
> ##  Damped pendulum:  y'' = -0.3 y' - sin(y)
> #   y1 = y, y2 = y':  y1' = y2,  y2' = -0.3*y2 - sin(y1)
> f <- function(t, y) {
+ 	dy1 <- y[2]
+ 	dy2 <- -0.3*y[2] - sin(y[1])
+ 	return(c(dy1, dy2))
+ }
> sol <- rk4sys(f, 0, 10, c(pi/2, 0), 100)
> deeve(sol$x, sol$y[,1])                   # y1 = 0 : elongation in [sec]
[1] 2.073507 5.414753 8.650250
> # [1] 2.073507 5.414753 8.650250
> # matplot(sol$x, sol$y); grid()
> 
> 
> 
> cleanEx()
> nameEx("deg2rad")
> ### * deg2rad
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: deg2rad
> ### Title: Degrees to Radians
> ### Aliases: deg2rad rad2deg
> ### Keywords: math
> 
> ### ** Examples
> 
> deg2rad(c(0, 10, 20, 30, 40, 50, 60, 70, 80, 90))
 [1] 0.0000000 0.1745329 0.3490659 0.5235988 0.6981317 0.8726646 1.0471976
 [8] 1.2217305 1.3962634 1.5707963
> rad2deg(seq(-pi/2, pi/2, length = 19))
 [1] -90 -80 -70 -60 -50 -40 -30 -20 -10   0  10  20  30  40  50  60  70  80  90
> 
> 
> 
> cleanEx()
> nameEx("detrend")
> ### * detrend
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: detrend
> ### Title: Remove Linear Trends
> ### Aliases: detrend
> ### Keywords: math
> 
> ### ** Examples
> 
> t <- 1:9
> x <- c(0, 2, 0, 4, 4, 4, 0, 2, 0)
> x - detrend(x, 'constant')
          [,1]
 [1,] 1.777778
 [2,] 1.777778
 [3,] 1.777778
 [4,] 1.777778
 [5,] 1.777778
 [6,] 1.777778
 [7,] 1.777778
 [8,] 1.777778
 [9,] 1.777778
> x - detrend(x, 'linear')
          [,1]
 [1,] 1.777778
 [2,] 1.777778
 [3,] 1.777778
 [4,] 1.777778
 [5,] 1.777778
 [6,] 1.777778
 [7,] 1.777778
 [8,] 1.777778
 [9,] 1.777778
> 
> y <- detrend(x, 'linear', 5)
> ## Not run: 
> ##D plot(t, x, col="blue")
> ##D lines(t, x - y, col="red")
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("deval")
> ### * deval
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: deval
> ### Title: Evaluate ODE Solution
> ### Aliases: deval
> ### Keywords: ode
> 
> ### ** Examples
> 
> ##  Free fall:  v' = -g - cw abs(v)^1.1,  cw = 1.6 drag coefficien
> f <- function(t, y) -9.81 + 1.6*abs(y)^1.1
> sol <- rk4(f, 0, 10, 0, 100)
> # speed after 0.5, 1, 1.5, 2 seconds
> cbind(c(0.5,1,1.5,2), -deval(sol$x, sol$y, c(0.5, 1, 1.5, 2)))
     [,1]     [,2]
[1,]  0.5 3.272267
[2,]  1.0 4.507677
[3,]  1.5 4.953259
[4,]  2.0 5.112068
> #  0.5  3.272267  m/s
> #  1.0  4.507677
> #  1.5  4.953259
> #  2.0  5.112068
> # plot(sol$x, -sol$y, type="l", col="blue"); grid()
> 
> 
> 
> cleanEx()
> nameEx("diag")
> ### * diag
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Diag
> ### Title: Matrix Diagonal
> ### Aliases: Diag
> ### Keywords: array
> 
> ### ** Examples
> 
> Diag(matrix(1:12,3,4),  1)
[1]  4  8 12
> Diag(matrix(1:12,3,4), -1)
[1] 2 6
> 
> Diag(c(1,5,9), 1)
     [,1] [,2] [,3] [,4]
[1,]    0    1    0    0
[2,]    0    0    5    0
[3,]    0    0    0    9
[4,]    0    0    0    0
> Diag(c(1,5,9), -1)
     [,1] [,2] [,3] [,4]
[1,]    0    0    0    0
[2,]    1    0    0    0
[3,]    0    5    0    0
[4,]    0    0    9    0
> 
> 
> 
> cleanEx()
> nameEx("distmat")
> ### * distmat
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: distmat
> ### Title: Distance Matrix
> ### Aliases: distmat pdist pdist2
> ### Keywords: array
> 
> ### ** Examples
> 
> A <- c(0.0, 0.0)
> B <- matrix(c(
+         0,0, 1,0, 0,1, 1,1), nrow=4, ncol = 2, byrow = TRUE)
> distmat(A, B)  #=> 0 1 1 sqrt(2)
     [,1] [,2] [,3]     [,4]
[1,]    0    1    1 1.414214
> 
> X <- matrix(rep(0.5, 5), nrow=1, ncol=5)
> Y <- matrix(runif(50), nrow=10, ncol=5)
> distmat(X, Y)
          [,1]      [,2]      [,3]      [,4]      [,5]      [,6]      [,7]
[1,] 0.6585844 0.4851493 0.3786591 0.6492663 0.5692546 0.5327267 0.8920051
          [,8]      [,9]     [,10]
[1,] 0.6602172 0.5212961 0.5826777
> 
> # A more vectorized form of distmat:
> distmat2 <- function(x, y) {
+     sqrt(outer(rowSums(x^2), rowSums(y^2), '+') - tcrossprod(x, 2 * y))
+ }
> 
> 
> 
> cleanEx()
> nameEx("dot")
> ### * dot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dot
> ### Title: Scalar Product
> ### Aliases: dot
> ### Keywords: array
> 
> ### ** Examples
> 
>   dot(1:5, 1:5)  #=> 55
[1] 55
>   # Length of space diagonal in 3-dim- cube:
>   sqrt(dot(c(1,1,1), c(1,1,1)))  #=> 1.732051
[1] 1.732051
> 
> 
> 
> cleanEx()
> nameEx("eig")
> ### * eig
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: eig
> ### Title: Eigenvalue Function (Matlab Style)
> ### Aliases: eig
> ### Keywords: array
> 
> ### ** Examples
> 
>   eig(matrix(c(1,-1,-1,1), 2, 2))   #=> 2 0
[1] 2 0
>   eig(matrix(c(1,1,-1,1), 2, 2))    # complex values
[1] 1+1i 1-1i
>   eig(matrix(c(0,1i,-1i,0), 2, 2))  # real values
[1]  1 -1
> 
> 
> 
> cleanEx()
> nameEx("eigjacobi")
> ### * eigjacobi
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: eigjacobi
> ### Title: Jacobi Eigenvalue Method
> ### Aliases: eigjacobi
> ### Keywords: math
> 
> ### ** Examples
> 
> A <- matrix(c( 1.06, -0.73,  0.77, -0.67,
+               -0.73,  2.64,  1.04,  0.72,
+                0.77,  1.04,  3.93, -2.14,
+               -0.67,  0.72, -2.14,  2.04), 4, 4, byrow = TRUE)
> eigjacobi(A)
$V
           [,1]       [,2]       [,3]       [,4]
[1,] 0.87019414 -0.3151209  0.1975473 -0.3231656
[2,] 0.11138094  0.8661855  0.1178032 -0.4726938
[3,] 0.07043799  0.1683401  0.8273261  0.5312548
[4,] 0.47475776  0.3494040 -0.5124734  0.6244140

$D
[1] 0.66335457 3.39813189 5.58753257 0.02098098

> # $V
> #            [,1]       [,2]       [,3]       [,4]
> # [1,] 0.87019414 -0.3151209  0.1975473 -0.3231656
> # [2,] 0.11138094  0.8661855  0.1178032 -0.4726938
> # [3,] 0.07043799  0.1683401  0.8273261  0.5312548
> # [4,] 0.47475776  0.3494040 -0.5124734  0.6244140
> # 
> # $D
> # [1] 0.66335457 3.39813189 5.58753257 0.02098098
> 
> 
> 
> cleanEx()
> nameEx("einsteinF")
> ### * einsteinF
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: einsteinF
> ### Title: Einstein Functions
> ### Aliases: einsteinF
> 
> ### ** Examples
> 
> ## Not run: 
> ##D x1 <- seq(-4, 4, length.out = 101)
> ##D y1 <- einsteinF(1, x1)
> ##D plot(x1, y1, type = "l", col = "red",
> ##D              xlab = "", ylab = "", main = "Einstein Function E1(x)")
> ##D grid()
> ##D 
> ##D y2 <- einsteinF(2, x1)
> ##D plot(x1, y2, type = "l", col = "red",
> ##D              xlab = "", ylab = "", main = "Einstein Function E2(x)")
> ##D grid()
> ##D 
> ##D x3 <- seq(0, 5, length.out = 101)
> ##D y3 <- einsteinF(3, x3)
> ##D plot(x3, y3, type = "l", col = "red",
> ##D              xlab = "", ylab = "", main = "Einstein Function E3(x)")
> ##D grid()
> ##D 
> ##D y4 <- einsteinF(4, x3)
> ##D plot(x3, y4, type = "l", col = "red",
> ##D              xlab = "", ylab = "", main = "Einstein Function E4(x)")
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("ellip")
> ### * ellip
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ellipke,ellipj
> ### Title: Elliptic and Jacobi Elliptic Integrals
> ### Aliases: ellipke ellipj
> ### Keywords: specfun
> 
> ### ** Examples
> 
> x <- linspace(0, 1, 20)
> ke <- ellipke(x)
> 
> ## Not run: 
> ##D plot(x, ke$k, type = "l", col ="darkblue", ylim = c(0, 5),
> ##D      main = "Elliptic Integrals")
> ##D lines(x, ke$e, col = "darkgreen")
> ##D legend( 0.01, 4.5,
> ##D         legend = c("Elliptic integral of first kind",
> ##D                    "Elliptic integral of second kind"),
> ##D         col = c("darkblue", "darkgreen"), lty = 1)
> ##D grid()
> ## End(Not run)
> 
> ## ellipse circumference with axes a, b
> ellipse_cf <- function(a, b) {
+     return(4*a*ellipke(1 - (b^2/a^2))$e)
+ }
> print(ellipse_cf(1.0, 0.8), digits = 10)
[1] 5.672333578
> # [1] 5.672333578
> 
> ## Jacobi elliptic integrals
> u <- c(0, 1, 2, 3, 4, 5)
> m <- seq(0.0, 1.0, by = 0.2)
> je <- ellipj(u, m)
> # $sn       0.0000  0.8265  0.9851  0.7433  0.4771  0.9999
> # $cn       1.0000  0.5630 -0.1720 -0.6690 -0.8789  0.0135
> # $dn       1.0000  0.9292  0.7822  0.8176  0.9044  0.0135
> je$sn^2 + je$cn^2       # 1 1 1 1 1 1
[1] 1 1 1 1 1 1
> je$dn^2 + m * je$sn^2   # 1 1 1 1 1 1
[1] 1 1 1 1 1 1
> 
> 
> 
> cleanEx()
> nameEx("entropy")
> ### * entropy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: approx_entropy
> ### Title: Approximate and Sample Entropy
> ### Aliases: approx_entropy sample_entropy
> ### Keywords: timeseries
> 
> ### ** Examples
> 
> ts <- rep(61:65, 10)
> approx_entropy(ts, edim = 2)                      # -0.0004610253
[1] -0.0004610253
> sample_entropy(ts, edim = 2)                      #  0
[1] 0
> 
> set.seed(8237)
> approx_entropy(rnorm(500), edim = 2)              # 1.351439  high, random
[1] 1.351439
> approx_entropy(sin(seq(1,100,by=0.2)), edim = 2)  # 0.171806  low,  deterministic
[1] 0.1718064
> sample_entropy(sin(seq(1,100,by=0.2)), edim = 2)  # 0.2359326
[1] 0.2359326
> 
> ## Not run: 
> ##D (Careful: This will take several minutes.)
> ##D # generate simulated data
> ##D N <- 1000; t <- 0.001*(1:N)
> ##D sint   <- sin(2*pi*10*t);    sd1 <- sd(sint)    # sine curve
> ##D whitet <- rnorm(N);          sd2 <- sd(whitet)  # white noise
> ##D chirpt <- sint + 0.1*whitet; sd3 <- sd(chirpt)  # chirp signal
> ##D 
> ##D # calculate approximate entropy
> ##D rnum <- 30; result <- zeros(3, rnum)
> ##D for (i in 1:rnum) {
> ##D     r <- 0.02 * i
> ##D     result[1, i] <- approx_entropy(sint,   2, r*sd1)
> ##D     result[2, i] <- approx_entropy(chirpt, 2, r*sd2)
> ##D     result[3, i] <- approx_entropy(whitet, 2, r*sd3)
> ##D }
> ##D 
> ##D # plot curves
> ##D r <- 0.02 * (1:rnum)
> ##D plot(c(0, 0.6), c(0, 2), type="n",
> ##D      xlab = "", ylab = "", main = "Approximate Entropy")
> ##D points(r, result[1, ], col="red");    lines(r, result[1, ], col="red")
> ##D points(r, result[2, ], col="green");  lines(r, result[2, ], col="green")
> ##D points(r, result[3, ], col="blue");   lines(r, result[3, ], col="blue")
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("eps")
> ### * eps
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: eps
> ### Title: Floating Point Relative Accuracy
> ### Aliases: eps
> ### Keywords: arith
> 
> ### ** Examples
> 
> for (i in -5:5) cat(eps(10^i), "\n")
1.694066e-21 
1.355253e-20 
2.168404e-19 
1.734723e-18 
1.387779e-17 
2.220446e-16 
1.776357e-15 
1.421085e-14 
1.136868e-13 
1.818989e-12 
1.455192e-11 
> # 1.694066e-21 
> # 1.355253e-20 
> # 2.168404e-19 
> # 1.734723e-18 
> # 1.387779e-17 
> # 2.220446e-16 
> # 1.776357e-15 
> # 1.421085e-14 
> # 1.136868e-13 
> # 1.818989e-12 
> # 1.455192e-11 
> 
> 
> 
> cleanEx()
> nameEx("erfz")
> ### * erfz
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: erf
> ### Title: Error Functions and Inverses (Matlab Style)
> ### Aliases: erf erfinv erfc erfcinv erfcx erfz erfi
> ### Keywords: stat
> 
> ### ** Examples
> 
>   x <- 1.0
>   erf(x); 2*pnorm(sqrt(2)*x) - 1
[1] 0.8427008
[1] 0.8427008
> # [1] 0.842700792949715
> # [1] 0.842700792949715
>   erfc(x); 1 - erf(x); 2*pnorm(-sqrt(2)*x)
[1] 0.1572992
[1] 0.1572992
[1] 0.1572992
> # [1] 0.157299207050285
> # [1] 0.157299207050285
> # [1] 0.157299207050285
>   erfz(x)
[1] 0.8427008
> # [1] 0.842700792949715
>   erfi(x)
[1] 1.650426
> # [1] 1.650425758797543
> 
> 
> 
> cleanEx()
> nameEx("errorbar")
> ### * errorbar
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: errorbar
> ### Title: Plot Error Bars
> ### Aliases: errorbar
> ### Keywords: graphs
> 
> ### ** Examples
> 
> ## Not run: 
> ##D x <- seq(0, 2*pi, length.out = 20)
> ##D y <- sin(x)
> ##D xe <- 0.1
> ##D ye <- 0.1 * y
> ##D errorbar(x, y, xe, ye, type = "l", with = FALSE)
> ##D 
> ##D cnt <- round(100*randn(20, 3))
> ##D y <- apply(cnt, 1, mean)
> ##D e <- apply(cnt, 1, sd)
> ##D errorbar(1:20, y, yerr = e, bar.col = "blue")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("eta")
> ### * eta
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: eta
> ### Title: Dirichlet Eta Function
> ### Aliases: eta
> ### Keywords: specfun
> 
> ### ** Examples
> 
> z <- 0.5 + (1:5)*1i
> eta(z)
[1] 0.6398619+0.1935145i 0.7595015+0.3816610i 0.9970914+0.5247927i
[4] 1.3606677+0.5208038i 1.7467035+0.2246479i
> z <- c(0, 0.5+1i, 1, 1i, 2+2i, -1, -2, -1-1i)
> eta(z)
[1] 0.5000000+0.0000000i 0.6398619+0.1935145i 0.6931472+0.0000000i
[4] 0.5325932+0.2293849i 0.9230198+0.1764252i 0.2500000+0.0000000i
[7] 0.0000000+0.0000000i 0.2567153-0.2802308i
> 
> 
> 
> cleanEx()
> nameEx("euler_heun")
> ### * euler_heun
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: euler_heun
> ### Title: Euler-Heun ODE Solver
> ### Aliases: euler_heun
> ### Keywords: ode
> 
> ### ** Examples
> 
> ##  Flame-up process
> f <- function(x, y) y^2 - y^3
> s1 <- cranknic(f, 0, 200, 0.01)
> s2 <- euler_heun(f, 0, 200, 0.01)
> ## Not run: 
> ##D plot(s1$t, s1$y, type="l", col="blue")
> ##D lines(s2$t, s2$y, col="red")
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("expint")
> ### * expint
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expint
> ### Title: Exponential and Logarithmic Integral
> ### Aliases: expint expint_E1 expint_Ei li
> ### Keywords: specfun
> 
> ### ** Examples
> 
> expint_E1(1:10)
 [1] 2.193839e-01 4.890051e-02 1.304838e-02 3.779352e-03 1.148296e-03
 [6] 3.600825e-04 1.154817e-04 3.766562e-05 1.244735e-05 4.156969e-06
> #   0.2193839  0.0489005  0.0130484  0.0037794  0.0011483
> #   0.0003601  0.0001155  0.0000377  0.0000124  0.0000042
> expint_Ei(1:10)
 [1]    1.895118    4.954234    9.933833   19.630874   40.185275   85.989762
 [7]  191.504743  440.379900 1037.878291 2492.228976
> 
> ## Not run: 
> ##D estimPi <- function(n) round(Re(li(n) - li(2))) # estimated number of primes
> ##D primesPi <- function(n) length(primes(n))       # true number of primes <= n
> ##D N <- 1e6
> ##D (estimPi(N) - primesPi(N)) / estimPi(N)         # deviation is 0.16 percent!
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("expm")
> ### * expm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expm
> ### Title: Matrix Exponential
> ### Aliases: expm logm
> ### Keywords: math
> 
> ### ** Examples
> 
> ##  The Ward test cases described in the help for expm::expm agree up to
> ##  10 digits with the values here and with results from Matlab's expm !
> A <- matrix(c(-49, -64, 24, 31), 2, 2)
> expm(A)
           [,1]      [,2]
[1,] -0.7357588 0.5518191
[2,] -1.4715176 1.1036382
> # -0.7357588 0.5518191
> # -1.4715176 1.1036382
> 
> A1 <- matrix(c(10,  7,  8,  7,
+                 7,  5,  6,  5,
+                 8,  6, 10,  9,
+                 7,  5,  9, 10), nrow = 4, ncol = 4, byrow = TRUE)
> expm(logm(A1))
     [,1] [,2] [,3] [,4]
[1,]   10    7    8    7
[2,]    7    5    6    5
[3,]    8    6   10    9
[4,]    7    5    9   10
> logm(expm(A1))
         [,1]     [,2]      [,3]      [,4]
[1,] 9.999345 7.073906  7.844712  7.111253
[2,] 7.073906 4.784269  6.225867  4.843167
[3,] 7.844712 6.225867 10.042989  8.947139
[4,] 7.111253 4.843167  8.947139 10.057609
> 
> ##  System of linear differential equations: y' = M y  (y = c(y1, y2, y3))
> M <- matrix(c(2,-1,1, 0,3,-1, 2,1,3), 3, 3, byrow=TRUE)
> M
     [,1] [,2] [,3]
[1,]    2   -1    1
[2,]    0    3   -1
[3,]    2    1    3
> C1 <- 0.5; C2 <- 1.0; C3 <- 1.5
> t  <- 2.0; Mt <- expm(t * M)
> yt <- Mt 
> 
> 
> 
> cleanEx()
> nameEx("eye")
> ### * eye
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: eye
> ### Title: Some Basic Matrices
> ### Aliases: eye ones zeros
> ### Keywords: array
> 
> ### ** Examples
> 
> eye(3)
     [,1] [,2] [,3]
[1,]    1    0    0
[2,]    0    1    0
[3,]    0    0    1
> ones(3, 1)
     [,1]
[1,]    1
[2,]    1
[3,]    1
> zeros(1, 3)
     [,1] [,2] [,3]
[1,]    0    0    0
> 
> 
> 
> cleanEx()
> nameEx("ezcontour")
> ### * ezcontour
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ezcontour,ezsurf,ezmesh
> ### Title: Contour, Surface, and Mesh Plotter
> ### Aliases: ezcontour ezsurf ezmesh
> ### Keywords: graphs
> 
> ### ** Examples
> 
> ## Not run: 
> ##D f <- function(xy) {
> ##D     x <- xy[1]; y <- xy[2]
> ##D     3*(1-x)^2 * exp(-(x^2) - (y+1)^2) -
> ##D         10*(x/5 - x^3 - y^5) * exp(-x^2 - y^2) -
> ##D         1/3 * exp(-(x+1)^2 - y^2)
> ##D     }
> ##D ezcontour(f, col = "navy")
> ##D ezcontour(f, filled = TRUE)
> ##D ezmesh(f)
> ##D ezmesh(f, col="lightblue", theta = -15, phi = 30)
> ##D   
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("ezplot")
> ### * ezplot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ezplot
> ### Title: Easy Function Plot
> ### Aliases: ezplot fplot
> ### Keywords: graphs
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fun <- function(x) x * cos(0.1*exp(x)) * sin(0.1*pi*exp(x))
> ##D ezplot(fun, 0, 5, n = 1001, fill = TRUE)
> ##D   
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("ezpolar")
> ### * ezpolar
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ezpolar
> ### Title: Easy Polar Plot
> ### Aliases: ezpolar
> ### Keywords: graphs
> 
> ### ** Examples
> 
> ## Not run: 
> ##D fun <- function(x) 1 + cos(x)
> ##D ezpolar(fun)
> ##D   
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("fact")
> ### * fact
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fact
> ### Title: Factorial Function
> ### Aliases: fact factorial2
> ### Keywords: math
> 
> ### ** Examples
> 
> fact(c(-1, 0, 1, NA, 171))  #=> NaN   1   1  NA Inf
[1] NaN   1   1  NA Inf
> fact(100)                   #=> 9.332621544394410e+157
[1] 9.332622e+157
> factorial(100)              #=> 9.332621544394225e+157
[1] 9.332622e+157
> # correct value:                9.332621544394415e+157
> # Stirling's approximation:     9.324847625269420e+157
> # n! ~ sqrt(2*pi*n) * (n/e)^n
> 
> factorial2(8);  factorial2(9);  factorial2(10)  # 384   945  3840
[1] 384
[1] 945
[1] 3840
> factorial(10) / factorial2(10)                  # => factorial2(9)
[1] 945
> 
> 
> 
> cleanEx()
> nameEx("factors")
> ### * factors
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: factors
> ### Title: Prime Factors
> ### Aliases: factors
> ### Keywords: math
> 
> ### ** Examples
> 
> ## Not run: 
> ##D   factors(1002001)       # 7  7  11  11  13  13
> ##D   factors(65537)         # is prime
> ##D   # Euler's calculation
> ##D   factors(2^32 + 1)      # 641  6700417
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("fderiv")
> ### * fderiv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fderiv
> ### Title: Numerical Differentiation
> ### Aliases: fderiv
> ### Keywords: math
> 
> ### ** Examples
> 
> ## Not run: 
> ##D f <- sin
> ##D xs <- seq(-pi, pi, length.out = 100)
> ##D ys <- f(xs)
> ##D y1 <- fderiv(f, xs, n = 1, method = "backward")
> ##D y2 <- fderiv(f, xs, n = 2, method = "backward")
> ##D y3 <- fderiv(f, xs, n = 3, method = "backward")
> ##D y4 <- fderiv(f, xs, n = 4, method = "backward")
> ##D plot(xs, ys, type = "l", col = "gray", lwd = 2,
> ##D      xlab = "", ylab = "", main = "Sinus and its Derivatives")
> ##D lines(xs, y1, col=1, lty=2)
> ##D lines(xs, y2, col=2, lty=3)
> ##D lines(xs, y3, col=3, lty=4)
> ##D lines(xs, y4, col=4, lty=5)
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("fibsearch")
> ### * fibsearch
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fibsearch
> ### Title: Fibonacci Search
> ### Aliases: fibsearch
> ### Keywords: optimize
> 
> ### ** Examples
> 
> f <- function(x) x * cos(0.1*exp(x)) * sin(0.1*pi*exp(x))
> fibsearch(f, 0, 4, tol=10^-10)   # $xmin    = 3.24848329403424
$xmin
[1] 3.248483

$fmin
[1] -2.665089

$niter
[1] 51

$estim.prec
[1] 6.955103e-11

> optimize(f, c(0,4), tol=10^-10)  # $minimum = 3.24848328971188
$minimum
[1] 3.248483

$objective
[1] -2.665089

> 
> 
> 
> cleanEx()
> nameEx("figure")
> ### * figure
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: figure
> ### Title: Control Plot Devices (Matlab Style)
> ### Aliases: figure
> ### Keywords: graphs
> 
> ### ** Examples
> 
> ## Not run: 
> ##D figure()
> ##D figure(-2)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("find")
> ### * find
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: finds
> ### Title: find function (Matlab Style)
> ### Aliases: finds
> ### Keywords: logic
> 
> ### ** Examples
> 
> finds(-3:3 >= 0)
[1] 4 5 6 7
> finds(c(0, 1, 0, 2, 3))
[1] 2 4 5
> 
> 
> 
> cleanEx()
> nameEx("findintervals")
> ### * findintervals
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: findintervals
> ### Title: Find Interval Indices
> ### Aliases: findintervals
> ### Keywords: logic
> 
> ### ** Examples
> 
> xs <- zapsmall(sin(seq(0, 10*pi, len=100)))
> findintervals(0, xs)
 [1]   1  10  20  30  40  50  60  70  80  90 100
> #   1  10  20  30  40  50  60  70  80  90 100
> 
> 
> 
> cleanEx()
> nameEx("findmins")
> ### * findmins
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: findmins
> ### Title: Find All Minima
> ### Aliases: findmins
> ### Keywords: optimize
> 
> ### ** Examples
> 
> fun <- function(x) x * cos(0.1*exp(x)) * sin(0.1*pi*exp(x))
> ## Not run: ezplot(fun, 0, 5, n = 1001)
> 
> # If n is smaller, the rightmost minimum will not be found.
> findmins(fun, 0, 5, n= 1000)
 [1] 2.537727 3.248481 3.761840 4.023021 4.295831 4.455115 4.641481 4.756263
 [9] 4.897461 4.987802
> #  2.537727 3.248481 3.761840 4.023021 4.295831
> #  4.455115 4.641481 4.756263 4.897461 4.987802
> 
> 
> 
> cleanEx()
> nameEx("findpeaks")
> ### * findpeaks
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: findpeaks
> ### Title: Find Peaks
> ### Aliases: findpeaks
> ### Keywords: timeseries
> 
> ### ** Examples
> 
> x <- seq(0, 1, len = 1024)
> pos <- c(0.1, 0.13, 0.15, 0.23, 0.25, 0.40, 0.44, 0.65, 0.76, 0.78, 0.81)
> hgt <- c(4, 5, 3, 4, 5, 4.2, 2.1, 4.3, 3.1, 5.1, 4.2)
> wdt <- c(0.005, 0.005, 0.006, 0.01, 0.01, 0.03, 0.01, 0.01, 0.005, 0.008, 0.005)
> 
> pSignal <- numeric(length(x))
> for (i in seq(along=pos)) {
+ 	pSignal <- pSignal + hgt[i]/(1 + abs((x - pos[i])/wdt[i]))^4
+ }
> findpeaks(pSignal, npeaks=3, threshold=4, sortstr=TRUE)
         [,1] [,2] [,3] [,4]
[1,] 4.972146  134  118  144
[2,] 4.960051  799  786  817
[3,] 4.590829  257  246  306
> 
> ## Not run: 
> ##D plot(pSignal, type="l", col="navy")
> ##D grid()
> ##D x <- findpeaks(pSignal, npeaks=3, threshold=4, sortstr=TRUE)
> ##D points(x[, 2], x[, 1], pch=20, col="maroon")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("findzeros")
> ### * findzeros
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: findzeros
> ### Title: Find All Roots
> ### Aliases: findzeros
> ### Keywords: math
> 
> ### ** Examples
> 
> f1 <- function(x) sin(pi/x)
> findzeros(f1, 1/10, 1)
 [1] 0.1000000 0.1111028 0.1250183 0.1428641 0.1666655 0.2000004 0.2499867
 [8] 0.3333441 0.4999794 1.0000000
> #  0.1000000  0.1111028  0.1250183  0.1428641  0.1666655
> #  0.2000004  0.2499867  0.3333441  0.4999794  1.0000000
> 
> f2 <- function(x) 0.5*(1 + sin(10*pi*x))
> findzeros(f2, 0, 1)
[1] 0.15 0.35 0.55 0.75 0.95
> #  0.15  0.35  0.55  0.75  0.95
> 
> f3 <- function(x) sin(pi/x) + 1
> findzeros(f3, 0.1, 0.5)
[1] 0.1052632 0.1333333 0.1818182 0.2857143
> # 0.1052632 0.1333333 0.1818182 0.2857143
> 
> f4 <- function(x) sin(pi/x) - 1
> findzeros(f4, 0.1, 0.5)
[1] 0.1176471 0.1538462 0.2222222 0.4000000
> # 0.1176471 0.1538462 0.2222222 0.4000000
> 
> ## Not run: 
> ##D # Dini function
> ##D Dini <- function(x) x * besselJ(x, 1) + 3 * besselJ(x, 0)
> ##D findzeros(Dini, 0, 100, n = 128)
> ##D ezplot(Dini, 0, 100, n = 512)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("fletcherpowell")
> ### * fletcherpowell
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fletcher_powell
> ### Title: Fletcher-Powell Conjugate Gradient Minimization
> ### Aliases: fletcher_powell
> ### Keywords: optimize
> 
> ### ** Examples
> 
> ##  Rosenbrock function
> rosenbrock <- function(x) {
+     n <- length(x)
+     x1 <- x[2:n]
+     x2 <- x[1:(n-1)]
+     sum(100*(x1-x2^2)^2 + (1-x2)^2)
+ }
> fletcher_powell(c(0, 0), rosenbrock)
$xmin
[1] 1 1

$fmin
[1] 1.553167e-17

$niter
[1] 14

> # $xmin
> # [1] 1 1
> # $fmin
> # [1] 1.774148e-27
> # $niter
> # [1] 14
> 
> 
> 
> cleanEx()
> nameEx("flipdim")
> ### * flipdim
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: flipdim
> ### Title: Matrix Flipping (Matlab Style)
> ### Aliases: flipdim flipud fliplr circshift
> ### Keywords: manip
> 
> ### ** Examples
> 
> a <- matrix(1:12, nrow=3, ncol=4, byrow=TRUE)
> flipud(a)
     [,1] [,2] [,3] [,4]
[1,]    9   10   11   12
[2,]    5    6    7    8
[3,]    1    2    3    4
> fliplr(a)
     [,1] [,2] [,3] [,4]
[1,]    4    3    2    1
[2,]    8    7    6    5
[3,]   12   11   10    9
> 
> circshift(a, c(1, -1))
     [,1] [,2] [,3] [,4]
[1,]   10   11   12    9
[2,]    2    3    4    1
[3,]    6    7    8    5
> v <- 1:10
> circshift(v, 5)
 [1]  6  7  8  9 10  1  2  3  4  5
> 
> 
> 
> cleanEx()
> nameEx("fminbnd")
> ### * fminbnd
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fminbnd
> ### Title: Finding Function Minimum
> ### Aliases: fminbnd
> ### Keywords: optimize
> 
> ### ** Examples
> 
> ##  CHEBFUN example by Trefethen
> f <- function(x) exp(x)*sin(3*x)*tanh(5*cos(30*x))
> fminbnd(f, -1, 1)                   # fourth local minimum (from left)
$xmin
[1] -0.2429114

$fmin
[1] -0.517464

$niter
[1] 17

$estim.prec
[1] 2.429114e-08

> g <- function(x) complexstep(f, x)  # complex-step derivative
> xs <- findzeros(g, -1, 1)           # local minima and maxima
> ys <- f(xs); n0 <- which.min(ys)    # index of global minimum
> fminbnd(f, xs[n0-1], xs[n0+1])      # xmin:0.7036632, fmin: -1.727377
$xmin
[1] 0.7036632

$fmin
[1] -1.727377

$niter
[1] 14

$estim.prec
[1] 7.036632e-08

> 
> ## Not run: 
> ##D ezplot(f, -1, 1, n = 1000, col = "darkblue", lwd = 2)
> ##D ezplot(function(x) g(x)/150, -1, 1, n = 1000, col = "darkred", add = TRUE)
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("fmincon")
> ### * fmincon
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fmincon
> ### Title: Minimize Nonlinear Constrained Multivariable Function.
> ### Aliases: fmincon
> ### Keywords: optimize
> 
> ### ** Examples
> 
> # Classical Rosenbrock function
> n <- 10; x0 <- rep(1/n, n)
> fn <- function(x) {n <- length(x)
+     x1 <- x[2:n]; x2 <- x[1:(n - 1)]
+     sum(100 * (x1 - x2^2)^2 + (1 - x2)^2)
+ }
> # Equality and inequality constraints
> heq1 <- function(x) sum(x)-1.0
> hin1 <- function(x) -1 * x
> hin2 <- function(x) x - 0.5
> ub <- rep(0.5, n)
> 
> # Apply constraint minimization
> res <- fmincon(x0, fn, hin = hin1, heq = heq1)
> res$par; res$value
 [1]  5.570691e-01  3.123574e-01  1.005249e-01  1.336700e-02  3.474736e-03
 [6]  3.307547e-03  3.307079e-03  3.306848e-03  3.285377e-03 -8.879423e-20
[1] 7.426002
> 
> 
> 
> cleanEx()
> nameEx("fminsearch")
> ### * fminsearch
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fminsearch
> ### Title: Derivative-free Nonlinear Function Minimization
> ### Aliases: fminsearch
> ### Keywords: optimize
> 
> ### ** Examples
> 
> # Rosenbrock function
> rosena <- function(x, a) 100*(x[2]-x[1]^2)^2 + (a-x[1])^2  # min: (a, a^2)
> 
> fminsearch(rosena, c(-1.2, 1), a = sqrt(2), method="Nelder-Mead")
$xmin
[1] 1.414292 2.000231

$fmin
[1] 1.478036e-08

$count
[1] 194

$convergence
[1] 0

$info
$info$solver
[1] "Nelder-Mead"

$info$restarts
[1] 0


> ## $xmin                   $fmin
> ## [1] 1.414292 2.000231   [1] 1.478036e-08
> 
> fminsearch(rosena, c(-1.2, 1), a = sqrt(2), method="Hooke-Jeeves")
$xmin
[1] 1.414213 1.999998

$fmin
[1] 3.381044e-13

$count
[1] 1087

$convergence
[1] 0

$info
$info$solver
[1] "Hooke-Jeeves"

$info$iterations
[1] 26


> ## $xmin                   $fmin
> ## [1] 1.414215 2.000004   [1] 1.79078e-12
> 
> 
> 
> cleanEx()
> nameEx("fminunc")
> ### * fminunc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fminunc
> ### Title: Minimize Unconstrained Multivariable Function
> ### Aliases: fminunc
> ### Keywords: optimize
> 
> ### ** Examples
> 
>   fun = function(x) 
+           x[1]*exp(-(x[1]^2 + x[2]^2)) + (x[1]^2 + x[2]^2)/20
>   fminunc(x0 = c(1, 2), fun)
$par
[1] -6.690718e-01  6.687239e-10

$value
[1] -0.4052369

$counts
function gradient 
      42       18 

$convergence
[1] 0

$message
[1] "Rvmminu converged"

>   ## xmin: c(-0.6691, 0.0000); fmin: -0.4052
> 
> 
> 
> cleanEx()
> nameEx("fnorm")
> ### * fnorm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fnorm
> ### Title: Function Norm
> ### Aliases: fnorm
> ### Keywords: math
> 
> ### ** Examples
> 
> xp <- seq(-1, 1, length.out = 6)
> yp <- runge(xp)
> p5 <- polyfit(xp, yp, 5)
> f5 <- function(x) polyval(p5, x)
> fnorm(runge, f5, -1, 1, p = Inf)                  #=> 0.4303246
[1] 0.4303246
> fnorm(runge, f5, -1, 1, p = Inf, npoints = 1000)  #=> 0.4326690
[1] 0.432669
> 
> # Compute mean distance using fnorm:
> fnorm(runge, f5, -1, 1, p = 1, 1000) / 1000       #=> 0.1094193
[1] 0.1094193
> 
> # Compute mean distance by integration:
> fn <- function(x) abs(runge(x) - f5(x))
> integrate(fn, -1, 1)$value / 2                    #=> 0.1095285
[1] 0.1095288
> 
> 
> 
> cleanEx()
> nameEx("fornberg")
> ### * fornberg
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fornberg
> ### Title: Fornberg's Finite Difference Approximation
> ### Aliases: fornberg
> ### Keywords: fitting
> 
> ### ** Examples
> 
> x <- 2 * pi * c(0.0, 0.07, 0.13, 0.2, 0.28, 0.34, 0.47, 0.5, 0.71, 0.95, 1.0)
> y <- sin(0.9*x)
> xs <- linspace(0, 2*pi, 51)
> fornb <- fornberg(x, y, xs, 10)
> ## Not run: 
> ##D matplot(xs, fornb, type="l")
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("fprintf")
> ### * fprintf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fprintf
> ### Title: Formatted Printing (Matlab style)
> ### Aliases: fprintf
> ### Keywords: utilities
> 
> ### ** Examples
> 
> ##  Examples:
> nbytes <- fprintf("Results are:\n", file = "")
Results are:
> for (i in 1:10) {
+     fprintf("%4d  %15.7f\n", i, exp(i), file = "")
+ }
   1        2.7182818
   2        7.3890561
   3       20.0855369
   4       54.5981500
   5      148.4131591
   6      403.4287935
   7     1096.6331584
   8     2980.9579870
   9     8103.0839276
  10    22026.4657948
> 
> 
> 
> cleanEx()
> nameEx("fractalcurve")
> ### * fractalcurve
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fractalcurve
> ### Title: Fractal Curves
> ### Aliases: fractalcurve
> ### Keywords: math
> 
> ### ** Examples
> 
> ## The Hilbert curve transforms a 2-dim. function into a time series.
> z <- fractalcurve(4, which = "hilbert")
> 
> ## Not run: 
> ##D f1 <- function(x, y) x^2 + y^2
> ##D plot(f1(z$x, z$y), type = 'l', col = "darkblue", lwd = 2,
> ##D      ylim = c(-1, 2), main = "Functions transformed by Hilbert curves")
> ##D 
> ##D f2 <- function(x, y) x^2 - y^2
> ##D lines(f2(z$x, z$y), col = "darkgreen", lwd = 2)
> ##D 
> ##D f3 <- function(x, y) x^2 * y^2
> ##D lines(f3(z$x, z$y), col = "darkred", lwd = 2)
> ##D grid()
> ## End(Not run)
> 
> ## Not run: 
> ##D ## Show some more fractal surves
> ##D n <- 8
> ##D opar <- par(mfrow=c(2,2), mar=c(2,2,1,1))
> ##D 
> ##D z <- fractalcurve(n, which="dragon")
> ##D x <- z$x; y <- z$y
> ##D plot(x, y, type='l', col="darkgrey", lwd=2)
> ##D title("Dragon Curve")
> ##D 
> ##D z <- fractalcurve(n, which="molecule")
> ##D x <- z$x; y <- z$y
> ##D plot(x, y, type='l', col="darkblue")
> ##D title("Molecule Curve")
> ##D 
> ##D z <- fractalcurve(n, which="arrowhead")
> ##D x <- z$x; y <- z$y
> ##D plot(x, y, type='l', col="darkgreen")
> ##D title("Arrowhead Curve")
> ##D 
> ##D z <- fractalcurve(n, which="snowflake")
> ##D x <- z$x; y <- z$y
> ##D plot(x, y, type='l', col="darkred", lwd=2)
> ##D title("Snowflake Curve")
> ##D 
> ##D par(opar)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("fresnel")
> ### * fresnel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fresnelS/C
> ### Title: Fresnel Integrals
> ### Aliases: fresnelS fresnelC
> ### Keywords: specfun
> 
> ### ** Examples
> 
> ##  Compute Fresnel integrals through Gauss-Legendre quadrature
> f1 <- function(t) sin(0.5 * pi * t^2)
> f2 <- function(t) cos(0.5 * pi * t^2)
> for (x in seq(0.5, 2.5, by = 0.5)) {
+     cgl <- gaussLegendre(51, 0, x)
+     fs <- sum(cgl$w * f1(cgl$x))
+     fc <- sum(cgl$w * f2(cgl$x))
+     cat(formatC(c(x, fresnelS(x), fs, fresnelC(x), fc),
+         digits = 8, width = 12, flag = " ----"), "\n")
+ }
 0.5          0.064732433  0.064732433  0.49234423   0.49234423  
 1            0.43825915   0.43825915   0.7798934    0.7798934   
 1.5          0.69750496   0.69750496   0.44526118   0.44526118  
 2            0.34341568   0.34341568   0.48825341   0.48825341  
 2.5          0.61918176   0.61918176   0.45741301   0.45741301  
> 
> ## Not run: 
> ##D xs <- seq(0, 7.5, by = 0.025)
> ##D ys <- fresnelS(xs)
> ##D yc <- fresnelC(xs)
> ##D 
> ##D ##  Function plot of the Fresnel integrals
> ##D plot(xs, ys, type = "l", col = "darkgreen",
> ##D     xlim = c(0, 8), ylim = c(0, 1),
> ##D     xlab = "", ylab = "", main = "Fresnel Integrals")
> ##D lines(xs, yc, col = "blue")
> ##D legend(6.25, 0.95, c("S(x)", "C(x)"), col = c("darkgreen", "blue"), lty = 1)
> ##D grid()
> ##D 
> ##D ##  The Cornu (or Euler) spiral
> ##D plot(c(-1, 1), c(-1, 1), type = "n",
> ##D     xlab = "", ylab = "", main = "Cornu Spiral")
> ##D lines(ys, yc, col = "red")
> ##D lines(-ys, -yc, col = "red")
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("fsolve")
> ### * fsolve
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fsolve
> ### Title: Solve System of Nonlinear Equations
> ### Aliases: fsolve
> ### Keywords: optimize
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Find a matrix X such that X * X * X = [1, 2; 3, 4]
> ##D   F <- function(x) {
> ##D     a <- matrix(c(1, 3, 2, 4), nrow = 2, ncol = 2, byrow = TRUE)
> ##D     X <- matrix(x,             nrow = 2, ncol = 2, byrow = TRUE)
> ##D     return(c(X %*% X %*% X - a))
> ##D   }
> ##D   x0 <- matrix(1, 2, 2)
> ##D   X  <- matrix(fsolve(F, x0)$x, 2, 2)
> ##D   X
> ##D   # -0.1291489  0.8602157
> ##D   #  1.2903236  1.1611747
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("fzero")
> ### * fzero
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fzero
> ### Title: Root Finding Algorithm
> ### Aliases: fzero
> ### Keywords: math
> 
> ### ** Examples
> 
> fzero(sin, 3)                    # 3.141593
$x
[1] 3.141593

$fval
[1] -1.401423e-12

> fzero(cos,c(1, 2))               # 1.570796
$x
[1] 1.570796

$fval
[1] -1.400818e-12

> fzero(function(x) x^3-2*x-5, 2)  # 2.094551
$x
[1] 2.094551

$fval
[1] -8.881784e-16

> 
> 
> 
> cleanEx()
> nameEx("fzsolve")
> ### * fzsolve
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fzsolve
> ### Title: Complex Root Finding
> ### Aliases: fzsolve
> ### Keywords: math
> 
> ### ** Examples
> 
> fz <- function(z) sin(z)^2 + sqrt(z) - log(z)
> fzsolve(fz, 1+1i)
[1] 0.2555197+0.8948303i
> # 0.2555197+0.8948303i
> 
> 
> 
> cleanEx()
> nameEx("gammainc")
> ### * gammainc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gammainc
> ### Title: Incomplete Gamma Function
> ### Aliases: gammainc incgam
> ### Keywords: specfun
> 
> ### ** Examples
> 
> gammainc( 1.5, 2)
   lowinc    uppinc    reginc 
0.4421746 0.5578254 0.4421746 
> gammainc(-1.5, 2)
   lowinc    uppinc    reginc 
 3.240845 -2.240845  3.240845 
> 
> incgam(3, 1.2)
[1] 0.06542143
> incgam(3, 0.5); incgam(3, -0.5)
[1] 0.02535651
[1] 0.006776136
> 
> 
> 
> cleanEx()
> nameEx("gammaz")
> ### * gammaz
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gammaz
> ### Title: Complex Gamma Function
> ### Aliases: gammaz
> ### Keywords: specfun
> 
> ### ** Examples
> 
> max(gamma(1:10) - gammaz(1:10))
[1] 9.094947e-13
> gammaz(-1)
[1] Inf
> gammaz(c(-2-2i, -1-1i, 0, 1+1i, 2+2i))
[1]  0.01089768-0.00528297i -0.17153292-0.32648275i         Inf+0.00000000i
[4]  0.49801567-0.15494983i  0.11229424+0.32361289i
> 
> # Euler's reflection formula
> z <- 1+1i
> gammaz(1-z) * gammaz(z)  # == pi/sin(pi*z)
[1] 0+0.2720291i
> 
> 
> 
> cleanEx()
> nameEx("gaussHermite")
> ### * gaussHermite
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gaussHermite
> ### Title: Gauss-Hermite Quadrature Formula
> ### Aliases: gaussHermite
> ### Keywords: math
> 
> ### ** Examples
> 
> cc <- gaussHermite(17)
> # Integrate  exp(-x^2)  from -Inf to Inf
> sum(cc$w)                        #=> 1.77245385090552 == sqrt(pi)
[1] 1.772454
> # Integrate  x^2 exp(-x^2)
> sum(cc$w * cc$x^2)               #=> 0.88622692545276 == sqrt(pi) /2
[1] 0.8862269
> # Integrate  cos(x) * exp(-x^2)
> sum(cc$w * cos(cc$x))            #=> 1.38038844704314 == sqrt(pi)/exp(1)^0.25
[1] 1.380388
> 
> 
> 
> cleanEx()
> nameEx("gaussLaguerre")
> ### * gaussLaguerre
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gaussLaguerre
> ### Title: Gauss-Laguerre Quadrature Formula
> ### Aliases: gaussLaguerre
> ### Keywords: math
> 
> ### ** Examples
> 
> cc <- gaussLaguerre(7)
> # integrate exp(-x) from 0 to Inf
> sum(cc$w)                     # 1
[1] 1
> # integrate x^2 * exp(-x)     # integral x^n * exp(-x) is n!
> sum(cc$w * cc$x^2)            # 2
[1] 2
> # integrate sin(x) * exp(-x)
> cc <- gaussLaguerre(17, 0)    # we need more nodes
> sum(cc$w * sin(cc$x))         #=> 0.499999999994907 , should be 0.5
[1] 0.5
> 
> 
> 
> cleanEx()
> nameEx("gaussLegendre")
> ### * gaussLegendre
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gaussLegendre
> ### Title: Gauss-Legendre Quadrature Formula
> ### Aliases: gaussLegendre
> ### Keywords: math
> 
> ### ** Examples
> 
> ##  Quadrature with Gauss-Legendre nodes and weights
> f <- function(x) sin(x+cos(10*exp(x))/3)
> #\dontrun{ezplot(f, -1, 1, fill = TRUE)}
> cc <- gaussLegendre(51, -1, 1)
> Q <- sum(cc$w * f(cc$x))  #=> 0.0325036515865218 , true error: < 1e-15
> 
> # If f is not vectorized, do an explicit summation:
> Q <- 0; x <- cc$x; w <- cc$w
> for (i in 1:51) Q <- Q + w[i] * f(x[i])
> 
> # If f is infinite at b = 1, set  b <- b - eps  (with, e.g., eps = 1e-15)
> 
> # Use Gauss-Kronrod approach for error estimation
> cc <- gaussLegendre(103, -1, 1)
> abs(Q - sum(cc$w * f(cc$x)))     # rel.error < 1e-10
[1] 9.327597e-11
> 
> # Use Gauss-Hermite for vector-valued functions
> f <- function(x) c(sin(pi*x), exp(x), log(1+x))
> cc <- gaussLegendre(32, 0, 1)
> drop(cc$w %*% matrix(f(cc$x), ncol = 3))  # c(2/pi, exp(1) - 1, 2*log(2) - 1)
[1] 0.6366198 1.7182818 0.3862944
> # absolute error < 1e-15
> 
> 
> 
> cleanEx()
> nameEx("gaussNewton")
> ### * gaussNewton
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gaussNewton
> ### Title: Gauss-Newton Function Minimization
> ### Aliases: gaussNewton
> ### Keywords: math
> 
> ### ** Examples
> 
> f1 <- function(x) c(x[1]^2 + x[2]^2 - 1, x[1] + x[2] - 1)
> gaussNewton(c(4, 4), f1)
$xs
[1] 0.6299606 0.6299606

$fs
[1] 0.1101184

$niter
[1] 5

$relerr
[1] 9.200647e-10

> 
> f2 <- function(x) c( x[1] + 10*x[2], sqrt(5)*(x[] - x[4]),
+                     (x[2] - 2*x[3])^2, 10*(x[1] - x[4])^2)
> gaussNewton(c(-2, -1, 1, 2), f2)
$xs
[1] -5.217195e-26  3.035548e-27 -6.223334e-26 -4.143244e-26

$fs
[1] 1.310304e-50

$niter
[1] 7

$relerr
[1] 3.376084e-17

> 
> f3 <- function(x)
+         c(2*x[1] - x[2] - exp(-x[1]), -x[1] + 2*x[2] - exp(-x[2]))
> gaussNewton(c(0, 0), f3)
$xs
[1] 0.5671433 0.5671433

$fs
[1] 0

$niter
[1] 5

$relerr
[1] 7.721235e-14

> # $xs   0.5671433 0.5671433
> 
> f4 <- function(x)  # Dennis Schnabel
+         c(x[1]^2 + x[2]^2 - 2, exp(x[1] - 1) + x[2]^3 - 2)
> gaussNewton(c(2.0, 0.5), f4)
$xs
[1] 1 1

$fs
[1] 0

$niter
[1] 8

$relerr
[1] 5.104648e-10

> # $xs    1 1
> 
> ##  Examples (from Matlab)
> F1 <- function(x) c(2*x[1]-x[2]-exp(-x[1]), -x[1]+2*x[2]-exp(-x[2]))
> gaussNewton(c(-5, -5), F1)
$xs
[1] 0.5671433 0.5671433

$fs
[1] 0

$niter
[1] 4

$relerr
[1] 7.90904e-16

> 
> # Find a matrix X such that X %*% X %*% X = [1 2; 3 4]
> F2 <- function(x) {
+     X <- matrix(x, 2, 2)
+     D <- X %*% X %*% X - matrix(c(1,3,2,4), 2, 2)
+     return(c(D))
+ }
> sol <- gaussNewton(ones(2,2), F2)
> (X  <- matrix(sol$xs, 2, 2))
           [,1]      [,2]
[1,] -0.1291489 0.8602157
[2,]  1.2903236 1.1611747
> #            [,1]      [,2]
> # [1,] -0.1291489 0.8602157
> # [2,]  1.2903236 1.1611747
> X %*% X %*% X
     [,1] [,2]
[1,]    1    2
[2,]    3    4
> 
> 
> 
> cleanEx()
> nameEx("gauss_kronrod")
> ### * gauss_kronrod
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gauss_kronrod
> ### Title: Gauss-Kronrod Quadrature
> ### Aliases: gauss_kronrod
> ### Keywords: math
> 
> ### ** Examples
> 
> gauss_kronrod(sin, 0, pi)  #  2.000000000000000 , rel.error: 1.14e-12
$value
[1] 2

$rel.error
[1] 1.139977e-12

> gauss_kronrod(exp, 0, 1)   #  1.718281828459045 , rel.error: 0
$value
[1] 1.718282

$rel.error
[1] 0

>                            #  1.718281828459045 , i.e. exp(1) - 1
> 
> 
> 
> cleanEx()
> nameEx("gcd")
> ### * gcd
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gcd, lcm
> ### Title: GCD and LCM Integer Functions
> ### Aliases: gcd Lcm
> ### Keywords: arith
> 
> ### ** Examples
> 
> gcd(12, 1:24)
 [1]  1  2  3  4  1  6  1  4  3  2  1 12  1  2  3  4  1  6  1  4  3  2  1 12
> gcd(46368, 75025)  # Fibonacci numbers are relatively prime to each other
[1] 1
> Lcm(12, 1:24)
 [1]  12  12  12  12  60  12  84  24  36  60 132  12 156  84  60  48 204  36 228
[20]  60  84 132 276  24
> Lcm(46368, 75025)  # = 46368 * 75025
[1] 3478759200
> 
> 
> 
> cleanEx()
> nameEx("geo_median")
> ### * geo_median
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geo_median
> ### Title: Geometric Median
> ### Aliases: geo_median
> ### Keywords: optimize
> 
> ### ** Examples
> 
> # Generate 100 points on the unit sphere in the 10-dim. space
> set.seed(1001)
> P <- rands(n=100, N=9)
> ( sol <- geo_median(P) )
$p
 [1] -0.009481361 -0.007643410 -0.001252910  0.006437703 -0.019982885
 [6] -0.045337987  0.036249563  0.003232175  0.035040592  0.046713023

$d
[1] 99.6638

$reltol
[1] 3.069063e-08

$niter
[1] 10

> # $p
> #  [1] -0.009481361 -0.007643410 -0.001252910  0.006437703 -0.019982885 -0.045337987
> #  [7]  0.036249563  0.003232175  0.035040592  0.046713023
> # $d
> # [1] 99.6638
> # $reltol
> # [1] 3.069063e-08
> # $niter
> # [1] 10
> 
> 
> 
> cleanEx()
> nameEx("givens")
> ### * givens
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: givens
> ### Title: Givens Rotation
> ### Aliases: givens
> ### Keywords: array
> 
> ### ** Examples
> 
> ##  QR decomposition
> A <- matrix(c(0,-4,2, 6,-3,-2, 8,1,-1), 3, 3, byrow=TRUE)
> gv <- givens(A)
> (Q <- gv$Q); (R <- gv$R)
     [,1]  [,2]  [,3]
[1,]  0.0 -0.80  0.60
[2,]  0.6 -0.48 -0.64
[3,]  0.8  0.36  0.48
     [,1] [,2] [,3]
[1,]   10   -1   -2
[2,]    0    5   -1
[3,]    0    0    2
> zapsmall(Q %*% R)
     [,1] [,2] [,3]
[1,]    0   -4    2
[2,]    6   -3   -2
[3,]    8    1   -1
> 
> givens(magic(5))
$Q
          [,1]       [,2]        [,3]        [,4]        [,5]
[1,] 0.5233867  0.5057542 -0.67346976  0.12154153  0.04410384
[2,] 0.7081114 -0.6965734  0.01772741 -0.08154163  0.08000231
[3,] 0.1231498  0.1367418  0.35575062  0.63074410  0.66463461
[4,] 0.3078745  0.1910574  0.41223097  0.42467160 -0.72002083
[5,] 0.3386620  0.4514387  0.49963121 -0.63276736  0.17744103

$R
         [,1]     [,2]     [,3]      [,4]      [,5]
[1,] 32.48076 26.63115 21.39728 23.706339 25.861461
[2,]  0.00000 19.89427 12.32344  1.943926  4.085579
[3,]  0.00000  0.00000 24.39855 11.631551  3.741480
[4,]  0.00000  0.00000  0.00000 20.098200  9.973936
[5,]  0.00000  0.00000  0.00000  0.000000 16.000463

> 
> 
> 
> cleanEx()
> nameEx("gmres")
> ### * gmres
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gmres
> ### Title: Generalized Minimal Residual Method
> ### Aliases: gmres
> ### Keywords: math
> 
> ### ** Examples
> 
> A <- matrix(c(0.46, 0.60, 0.74, 0.61, 0.85,
+               0.56, 0.31, 0.80, 0.94, 0.76,
+               0.41, 0.19, 0.15, 0.33, 0.06,
+               0.03, 0.92, 0.15, 0.56, 0.08,
+               0.09, 0.06, 0.69, 0.42, 0.96), 5, 5)
> x <- c(0.1, 0.3, 0.5, 0.7, 0.9)
> b <- A %*% x
> gmres(A, b)
Warning in hr * v[, j] :
  Recycling array of length 1 in array-vector arithmetic is deprecated.
  Use c() or as.vector() instead.

Warning in hr * v[, j] :
  Recycling array of length 1 in array-vector arithmetic is deprecated.
  Use c() or as.vector() instead.

Warning in hr * v[, j] :
  Recycling array of length 1 in array-vector arithmetic is deprecated.
  Use c() or as.vector() instead.

Warning in hr * v[, j] :
  Recycling array of length 1 in array-vector arithmetic is deprecated.
  Use c() or as.vector() instead.

Warning in hr * v[, j] :
  Recycling array of length 1 in array-vector arithmetic is deprecated.
  Use c() or as.vector() instead.

$x
     [,1]
[1,]  0.1
[2,]  0.3
[3,]  0.5
[4,]  0.7
[5,]  0.9

$error
[1] 2.374455e+00 1.491729e-01 1.221472e-01 1.399005e-02 1.378165e-02
[6] 1.948136e-31

$niter
[1] 5

> # $x
> #      [,1]
> # [1,]  0.1
> # [2,]  0.3
> # [3,]  0.5
> # [4,]  0.7
> # [5,]  0.9
> # 
> # $error
> # [1] 2.37446e+00 1.49173e-01 1.22147e-01 1.39901e-02 1.37817e-02 2.81713e-31
> # 
> # $niter
> # [1] 5
> 
> 
> 
> cleanEx()
> nameEx("golden_ratio")
> ### * golden_ratio
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: golden_ratio
> ### Title: Golden Ratio Search
> ### Aliases: golden_ratio
> ### Keywords: optimize
> 
> ### ** Examples
> 
> f <- function(x) x * cos(0.1*exp(x)) * sin(0.1*pi*exp(x))
> golden_ratio(f, 0, 4, tol=10^-10)  # $xmin    = 3.24848329206212
$xmin
[1] 3.248483

$fmin
[1] -2.665089

$iter
[1] 48

$estim.prec
[1] 8.783951e-11

> optimize(f, c(0,4), tol=10^-10)    # $minimum = 3.24848328971188
$minimum
[1] 3.248483

$objective
[1] -2.665089

> 
> 
> 
> cleanEx()
> nameEx("grad")
> ### * grad
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: grad
> ### Title: Numerical Gradient
> ### Aliases: grad
> ### Keywords: math
> 
> ### ** Examples
> 
> f <- function(u) {
+     x <- u[1]; y <- u[2]; z <- u[3]
+     return(x^3 + y^2 + z^2 +12*x*y + 2*z)
+  }
> x0 <- c(1,1,1)
> grad(f, x0)     # 15 14  4        # direction of steepest descent
[1] 15 14  4
> 
> sum(grad(f, x0) * c(1, -1, 0))    # 1 , directional derivative
[1] 1
> 
> f <- function(x) x[1]^2 + x[2]^2
> grad(f, c(0,0))                   # 0 0 , i.e. a local optimum
[1] 0 0
> 
> 
> 
> cleanEx()
> nameEx("gradient")
> ### * gradient
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gradient
> ### Title: Discrete Gradient (Matlab Style)
> ### Aliases: gradient
> ### Keywords: math
> 
> ### ** Examples
> 
> x <- seq(0, 1, by=0.2)
> y <- c(1, 2, 3)
> (M <- meshgrid(x, y))
$X
     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    0  0.2  0.4  0.6  0.8    1
[2,]    0  0.2  0.4  0.6  0.8    1
[3,]    0  0.2  0.4  0.6  0.8    1

$Y
     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    1    1    1    1    1
[2,]    2    2    2    2    2    2
[3,]    3    3    3    3    3    3

> gradient(M$X^2 + M$Y^2)
$X
     [,1] [,2] [,3] [,4] [,5] [,6]
[1,] 0.04 0.08 0.16 0.24 0.32 0.36
[2,] 0.04 0.08 0.16 0.24 0.32 0.36
[3,] 0.04 0.08 0.16 0.24 0.32 0.36

$Y
     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    3    3    3    3    3    3
[2,]    4    4    4    4    4    4
[3,]    5    5    5    5    5    5

> gradient(M$X^2 + M$Y^2, x, y)
$X
     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]  0.2  0.4  0.8  1.2  1.6  1.8
[2,]  0.2  0.4  0.8  1.2  1.6  1.8
[3,]  0.2  0.4  0.8  1.2  1.6  1.8

$Y
     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    3    3    3    3    3    3
[2,]    4    4    4    4    4    4
[3,]    5    5    5    5    5    5

> 
> ## Not run: 
> ##D # One-dimensional example
> ##D x <- seq(0, 2*pi, length.out = 100)
> ##D y <- sin(x)
> ##D f <- gradient(y, x)
> ##D max(f - cos(x))      #=> 0.00067086
> ##D plot(x, y, type = "l", col = "blue")
> ##D lines(x, cos(x), col = "gray", lwd = 3)
> ##D lines(x, f, col = "red")
> ##D grid()
> ##D 
> ##D # Two-dimensional example
> ##D v <- seq(-2, 2, by=0.2)
> ##D X <- meshgrid(v, v)$X
> ##D Y <- meshgrid(v, v)$Y
> ##D 
> ##D Z <- X * exp(-X^2 - Y^2)
> ##D image(v, v, t(Z))
> ##D contour(v, v, t(Z), col="black", add = TRUE)
> ##D grid(col="white")
> ##D 
> ##D grX <- gradient(Z, v, v)$X
> ##D grY <- gradient(Z, v, v)$Y
> ##D 
> ##D quiver(X, Y, grX, grY, scale = 0.2, col="blue")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("gramschmidt")
> ### * gramschmidt
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gramSchmidt
> ### Title: Gram-Schmidt
> ### Aliases: gramSchmidt
> ### Keywords: array
> 
> ### ** Examples
> 
> ##  QR decomposition
> A <- matrix(c(0,-4,2, 6,-3,-2, 8,1,-1), 3, 3, byrow=TRUE)
> gs <- gramSchmidt(A)
> (Q <- gs$Q); (R <- gs$R)
     [,1]  [,2]  [,3]
[1,]  0.0 -0.80  0.60
[2,]  0.6 -0.48 -0.64
[3,]  0.8  0.36  0.48
     [,1] [,2] [,3]
[1,]   10   -1   -2
[2,]    0    5   -1
[3,]    0    0    2
> Q %*% R  # = A
     [,1] [,2] [,3]
[1,]    0   -4    2
[2,]    6   -3   -2
[3,]    8    1   -1
> 
> 
> 
> cleanEx()
> nameEx("hadamard")
> ### * hadamard
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: hadamard
> ### Title: Hadamard Matrix
> ### Aliases: hadamard
> ### Keywords: specmat
> 
> ### ** Examples
> 
> hadamard(4)
     [,1] [,2] [,3] [,4]
[1,]    1    1    1    1
[2,]    1   -1    1   -1
[3,]    1    1   -1   -1
[4,]    1   -1   -1    1
> H <- hadamard(8)
> t(H) 
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
[1,]    1    1    1    1    1    1    1    1
[2,]    1   -1    1   -1    1   -1    1   -1
[3,]    1    1   -1   -1    1    1   -1   -1
[4,]    1   -1   -1    1    1   -1   -1    1
[5,]    1    1    1    1   -1   -1   -1   -1
[6,]    1   -1    1   -1   -1    1   -1    1
[7,]    1    1   -1   -1   -1   -1    1    1
[8,]    1   -1   -1    1   -1    1    1   -1
> 
> 
> 
> cleanEx()
> nameEx("halley")
> ### * halley
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: halley
> ### Title: Halley's Root Finding Mathod
> ### Aliases: halley
> ### Keywords: math
> 
> ### ** Examples
> 
> halley(sin, 3.0)        # 3.14159265358979 in 3 iterations
$root
[1] 3.141593

$f.root
[1] 1.224647e-16

$iter
[1] 3

$estim.prec
[1] 1.841549e-11

> halley(function(x) x*exp(x) - 1, 1.0)
$root
[1] 0.5671433

$f.root
[1] 0

$iter
[1] 4

$estim.prec
[1] 0

>                         # 0.567143290409784 Gauss' omega constant
> 
> # Legendre polynomial of degree 5
> lp5 <- c(63, 0, -70, 0, 15, 0)/8
> f <- function(x) polyval(lp5, x)
> halley(f, 1.0)          # 0.906179845938664
$root
[1] 0.9061798

$f.root
[1] -4.440892e-16

$iter
[1] 4

$estim.prec
[1] 4.551914e-15

> 
> 
> 
> cleanEx()
> nameEx("hampel")
> ### * hampel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: hampel
> ### Title: Hampel Filter
> ### Aliases: hampel
> ### Keywords: timeseries
> 
> ### ** Examples
> 
> set.seed(8421)
> x <- numeric(1024)
> z <- rnorm(1024)
> x[1] <- z[1]
> for (i in 2:1024) {
+ 	x[i] <- 0.4*x[i-1] + 0.8*x[i-1]*z[i-1] + z[i]
+ }
> omad <- hampel(x, k=20)
> 
> ## Not run: 
> ##D plot(1:1024, x, type="l")
> ##D points(omad$ind, x[omad$ind], pch=21, col="darkred")
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("hankel")
> ### * hankel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: hankel
> ### Title: Hankel Matrix
> ### Aliases: hankel
> ### Keywords: specmat
> 
> ### ** Examples
> 
> hankel(1:5, 5:1)
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    2    3    4    5
[2,]    2    3    4    5    4
[3,]    3    4    5    4    3
[4,]    4    5    4    3    2
[5,]    5    4    3    2    1
> 
> 
> 
> cleanEx()
> nameEx("hausdorff")
> ### * hausdorff
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: hausdorff_dist
> ### Title: Hausdorff Distance
> ### Aliases: hausdorff_dist
> ### Keywords: math
> 
> ### ** Examples
> 
> P <- matrix(c(1,1,2,2, 5,4,5,4), 4, 2)
> Q <- matrix(c(4,4,5,5, 2,1,2,1), 4, 2)
> hausdorff_dist(P, Q)    # 4.242641 = sqrt(sum((c(4,2)-c(1,5))^2))
[1] 4.242641
> 
> 
> 
> cleanEx()
> nameEx("haversine")
> ### * haversine
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: haversine
> ### Title: Haversine Formula
> ### Aliases: haversine
> ### Keywords: geom
> 
> ### ** Examples
> 
> FRA = '50 02 00N, 08 34 14E'  # Frankfurt Airport
> ORD = '41 58 43N, 87 54 17W'  # Chicago O'Hare Interntl. Airport
> fra <- c(50+2/60, 8+34/60+14/3600)
> ord <- c(41+58/60+43/3600, -(87+54/60+17/3600))
> 
> dis <- haversine(FRA, ORD)    # 6971.059 km
> fprintf('Flight distance Frankfurt-Chicago is %8.3f km.\n', dis)
Flight distance Frankfurt-Chicago is 6971.059 km.
> 
> dis <- haversine(fra, ord)
> fprintf('Flight distance Frankfurt-Chicago is %8.3f km.\n', dis)
Flight distance Frankfurt-Chicago is 6971.059 km.
> 
> 
> 
> cleanEx()
> nameEx("hessenberg")
> ### * hessenberg
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: hessenberg
> ### Title: Hessenberg Matrix
> ### Aliases: hessenberg
> ### Keywords: array
> 
> ### ** Examples
> 
> A <- matrix(c(-149,   -50,  -154,
+                537,   180,   546,
+                -27,    -9,   -25), nrow = 3, byrow = TRUE)
> hb  <- hessenberg(A)
> hb
$H
          [,1]         [,2]        [,3]
[1,] -149.0000  42.20367124 -156.316506
[2,] -537.6783 152.55114875 -554.927153
[3,]    0.0000   0.07284727    2.448851

$P
     [,1]       [,2]      [,3]
[1,]    1  0.0000000 0.0000000
[2,]    0 -0.9987384 0.0502159
[3,]    0  0.0502159 0.9987384

> ## $H
> ##           [,1]         [,2]        [,3]
> ## [1,] -149.0000  42.20367124 -156.316506
> ## [2,] -537.6783 152.55114875 -554.927153
> ## [3,]    0.0000   0.07284727    2.448851
> ## 
> ## $P
> ##      [,1]       [,2]      [,3]
> ## [1,]    1  0.0000000 0.0000000
> ## [2,]    0 -0.9987384 0.0502159
> ## [3,]    0  0.0502159 0.9987384
> 
> hb$P %*% hb$H %*% t(hb$P)
     [,1] [,2] [,3]
[1,] -149  -50 -154
[2,]  537  180  546
[3,]  -27   -9  -25
> ##      [,1] [,2] [,3]
> ## [1,] -149  -50 -154
> ## [2,]  537  180  546
> ## [3,]  -27   -9  -25
> 
> 
> 
> cleanEx()
> nameEx("hessian")
> ### * hessian
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: hessian
> ### Title: Hessian Matrix
> ### Aliases: hessian
> ### Keywords: math
> 
> ### ** Examples
> 
> f <- function(x) cos(x[1] + x[2])
> x0 <- c(0, 0)
> hessian(f, x0)
     [,1] [,2]
[1,]   -1   -1
[2,]   -1   -1
> 
> f <- function(u) {
+     x <- u[1]; y <- u[2]; z <- u[3]
+     return(x^3 + y^2 + z^2 +12*x*y + 2*z)
+ }
> x0 <- c(1,1,1)
> hessian(f, x0)
     [,1] [,2] [,3]
[1,]    6   12    0
[2,]   12    2    0
[3,]    0    0    2
> 
> 
> 
> cleanEx()
> nameEx("hessutils")
> ### * hessutils
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Hessian utilities
> ### Title: Hessian utilities
> ### Aliases: hessvec hessdiag
> ### Keywords: math
> 
> ### ** Examples
> 
>   ## Not run: 
> ##D     set.seed(1237); n <- 100
> ##D     a <- runif(n); b <- rnorm(n)
> ##D     fn <- function(x, a, b) sum(exp(-a*x)*sin(b*pi*x))
> ##D     x0 <- rep(1, n)
> ##D     v0 <- rexp(n, rate=0.1)
> ##D     
> ##D     # compute with full hessian
> ##D     h0 <- hessian(fn, x0, a = a, b = b)             # n=100 runtimes
> ##D     v1 <- c(h0 %*% v0)                              # 0.167   sec
> ##D     
> ##D     v2 <- hessvec(fn, x0, v0, a = a, b = b)         # 0.00209 sec
> ##D     v3 <- hessvec(fn, x0, v0, csd=TRUE,a=a, b=b)    # 0.00145 sec
> ##D     v4 <- hessdiag(fn, x0, a = a, b = b) * v0       # 0.00204 sec
> ##D     
> ##D     # compare with exact analytical Hessian
> ##D     hex <- diag((a^2-b^2*pi^2)*exp(-a*x0)*sin(b*pi*x0) - 
> ##D                  2*a*b*pi*exp(-a*x0)*cos(b*pi*x0))
> ##D     vex <- c(hex %*% v0)
> ##D 
> ##D     max(abs(vex - v1))          # 2.48e-05
> ##D     max(abs(vex - v2))          # 7.15e-05
> ##D     max(abs(vex - v3))          # 0.09e-05
> ##D     max(abs(vex - v4))          # 2.46e-05 
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("hilb")
> ### * hilb
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: hilb
> ### Title: Hilbert Matrix
> ### Aliases: hilb
> ### Keywords: specmat
> 
> ### ** Examples
> 
>   hilb(5)
          [,1]      [,2]      [,3]      [,4]      [,5]
[1,] 1.0000000 0.5000000 0.3333333 0.2500000 0.2000000
[2,] 0.5000000 0.3333333 0.2500000 0.2000000 0.1666667
[3,] 0.3333333 0.2500000 0.2000000 0.1666667 0.1428571
[4,] 0.2500000 0.2000000 0.1666667 0.1428571 0.1250000
[5,] 0.2000000 0.1666667 0.1428571 0.1250000 0.1111111
> 
> 
> 
> cleanEx()
> nameEx("histc")
> ### * histc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: histc
> ### Title: Histogram Count (Matlab style)
> ### Aliases: histc
> ### Keywords: manip
> 
> ### ** Examples
> 
> x <- seq(0.0, 1.0, by = 0.05)
> e <- seq(0.1, 0.9, by = 0.10)
> histc(x, e)
$cnt
[1] 2 2 2 2 2 2 2 2 1

$bin
 [1] 0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 0 0

> # $cnt
> # [1] 2 2 2 2 2 2 2 2 1
> # $bin
> # [1] 0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 0 0
> 
> ## Not run: 
> ##D # Compare
> ##D findInterval(x, e)
> ##D # [1] 0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 9
> ##D findInterval(x, e, all.inside = TRUE)
> ##D # [1] 1 1 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 8 8 8
> ##D # cnt[i] <- sum(findInterval(x, e) == i)
> ## End(Not run)
> 
> x <- matrix( c(0.5029, 0.2375, 0.2243, 0.8495,
+                0.0532, 0.1644, 0.4215, 0.4135,
+                0.7854, 0.0879, 0.1221, 0.6170), 3, 4, byrow = TRUE)
> e <- seq(0.0, 1.0, by = 0.2)
> histc(x, e)
$cnt
     [,1] [,2] [,3] [,4]
[1,]    1    2    1    0
[2,]    0    1    1    0
[3,]    1    0    1    1
[4,]    1    0    0    1
[5,]    0    0    0    1
[6,]    0    0    0    0

$bin
     [,1] [,2] [,3] [,4]
[1,]    3    2    2    5
[2,]    1    1    3    3
[3,]    4    1    1    4

> # $cnt
> #      [,1] [,2] [,3] [,4]
> # [1,]    1    2    1    0
> # [2,]    0    1    1    0
> # [3,]    1    0    1    1
> # [4,]    1    0    0    1
> # [5,]    0    0    0    1
> # [6,]    0    0    0    0
> # 
> # $bin
> #      [,1] [,2] [,3] [,4]
> # [1,]    3    2    2    5
> # [2,]    1    1    3    3
> # [3,]    4    1    1    4
> 
> 
> 
> cleanEx()
> nameEx("histss")
> ### * histss
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: histss
> ### Title: Histogram Bin-width Optimization
> ### Aliases: histss
> ### Keywords: timeseries
> 
> ### ** Examples
> 
> x <- sin(seq(0, pi/2, length.out = 200))
> H <- histss(x, n = 50, plotting = FALSE)
> ## Not run: 
> ##D plot(H, col = "gainsboro")  # Compare with hist(x), or
> ##D hist(x, breaks = H$breaks)  # the same 
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("hookejeeves")
> ### * hookejeeves
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: hooke_jeeves
> ### Title: Hooke-Jeeves Function Minimization Method
> ### Aliases: hooke_jeeves
> ### Keywords: optimize
> 
> ### ** Examples
> 
> ##  Rosenbrock function
> rosenbrock <- function(x) {
+     n <- length(x)
+     x1 <- x[2:n]
+     x2 <- x[1:(n-1)]
+     sum(100*(x1-x2^2)^2 + (1-x2)^2)
+ }
> 
> hooke_jeeves(c(0,0,0,0), rosenbrock)
$xmin
[1] 1 1 1 1

$fmin
[1] 0

$count
[1] 2203

$convergence
[1] 0

$info
$info$solver
[1] "Hooke-Jeeves"

$info$iterations
[1] 26


> ## $xmin
> ## [1] 1.000002 1.000003 1.000007 1.000013
> ## $fmin
> ## [1] 5.849188e-11
> ## $count
> ## [1] 1691
> ## $convergence
> ## [1] 0
> ## $info
> ## $info$solver
> ## [1] "Hooke-Jeeves"
> ## $info$iterations
> ## [1] 26
> 
> hooke_jeeves(rep(0,4), lb=rep(-1,4), ub=0.5, rosenbrock)
$xmin
[1] 0.50000000 0.26221320 0.07797599 0.00608024

$fmin
[1] 1.667875

$count
[1] 529

$convergence
[1] 0

$info
$info$solver
[1] "Hooke-Jeeves"

$info$iterations
[1] 26


> ## $xmin
> ## [1] 0.50000000 0.26221320 0.07797602 0.00608027
> ## $fmin
> ## [1] 1.667875
> ## $count
> ## [1] 536
> ## $convergence
> ## [1] 0
> ## $info
> ## $info$solver
> ## [1] "Hooke-Jeeves"
> ## $info$iterations
> ## [1] 26
> 
> 
> 
> cleanEx()
> nameEx("horner")
> ### * horner
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: horner
> ### Title: Horner's Rule
> ### Aliases: horner hornerdefl
> ### Keywords: math
> 
> ### ** Examples
> 
> x <- c(-2, -1, 0, 1, 2)
> p <- c(1, 0, 1)  # polynomial x^2 + x, derivative 2*x
> horner(p, x)$y   #=>  5  2  1  2  5
[1] 5 2 1 2 5
> horner(p, x)$dy  #=> -4 -2  0  2  4
[1] -4 -2  0  2  4
> 
> p <- Poly(c(1, 2, 3))  # roots 1, 2, 3
> hornerdefl(p, 3)          # q = x^2- 3 x + 2  with roots 1, 2
$y
[1] 0

$q
[1]  1 -3  2

> 
> 
> 
> cleanEx()
> nameEx("householder")
> ### * householder
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: householder
> ### Title: Householder Reflections
> ### Aliases: householder
> ### Keywords: array
> 
> ### ** Examples
> 
> ##  QR decomposition
> A <- matrix(c(0,-4,2, 6,-3,-2, 8,1,-1), 3, 3, byrow=TRUE)
> S <- householder(A)
> (Q <- S$Q); (R <- S$R)
     [,1]  [,2]  [,3]
[1,]  0.0 -0.80 -0.60
[2,] -0.6 -0.48  0.64
[3,] -0.8  0.36 -0.48
     [,1]         [,2] [,3]
[1,]  -10 1.000000e+00    2
[2,]    0 5.000000e+00   -1
[3,]    0 4.440892e-16   -2
> Q %*% R  # = A
     [,1] [,2] [,3]
[1,]    0   -4    2
[2,]    6   -3   -2
[3,]    8    1   -1
> 
> ##  Solve an overdetermined linear system of equations
> A <- matrix(c(1:8,7,4,2,3,4,2,2), ncol=3, byrow=TRUE)
> S <- householder(A); Q <- S$Q; R <- S$R
> m <- nrow(A); n <- ncol(A)
> b <- rep(6, 5)
> 
> x <- numeric(n)
> b <- t(Q) %*% b
> x[n] <- b[n] / R[n, n]
> for (k in (n-1):1)
+     x[k] <- (b[k] - R[k, (k+1):n] %*% x[(k+1):n]) / R[k, k]
> qr.solve(A, rep(6, 5)); x
[1]  1.074236 -2.331878  2.436681
[1]  1.074236 -2.331878  2.436681
> 
> 
> 
> cleanEx()
> nameEx("humps")
> ### * humps
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: humps
> ### Title: Matlab Test Functions
> ### Aliases: humps sinc psinc
> 
> ### ** Examples
> 
> ## Not run: 
> ##D plot(humps(), type="l"); grid()
> ##D 
> ##D x <- seq(0, 10, length=101)
> ##D plot(x, sinc(x), type="l"); grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("hurst")
> ### * hurst
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: hurstexp
> ### Title: Hurst Exponent
> ### Aliases: hurstexp
> ### Keywords: timeseries
> 
> ### ** Examples
> 
> ##  Computing the Hurst exponent
> data(brown72)
> x72 <- brown72                          #  H = 0.72
> xgn <- rnorm(1024)                      #  H = 0.50
> xlm <- numeric(1024); xlm[1] <- 0.1     #  H = 0.43
> for (i in 2:1024) xlm[i] <- 4 * xlm[i-1] * (1 - xlm[i-1])
> 
> hurstexp(brown72, d = 128)           # 0.72
Simple R/S Hurst estimation:         0.6628842 
Corrected R over S Hurst exponent:   0.7378703 
Empirical Hurst exponent:            0.7921466 
Corrected empirical Hurst exponent:  0.7675798 
Theoretical Hurst exponent:          0.5268448 
> # Simple R/S Hurst estimation:         0.6590931 
> # Corrected R over S Hurst exponent:   0.7384611 
> # Empirical Hurst exponent:            0.7068613 
> # Corrected empirical Hurst exponent:  0.6838251 
> # Theoretical Hurst exponent:          0.5294909
> 
> hurstexp(xgn)                        # 0.50
Simple R/S Hurst estimation:         0.4922791 
Corrected R over S Hurst exponent:   0.5098239 
Empirical Hurst exponent:            0.5145979 
Corrected empirical Hurst exponent:  0.471644 
Theoretical Hurst exponent:          0.5404756 
> # Simple R/S Hurst estimation:         0.5518143 
> # Corrected R over S Hurst exponent:   0.5982146 
> # Empirical Hurst exponent:            0.6104621 
> # Corrected empirical Hurst exponent:  0.5690305 
> # Theoretical Hurst exponent:          0.5368124 
> 
> hurstexp(xlm)                        # 0.43
Simple R/S Hurst estimation:         0.4762169 
Corrected R over S Hurst exponent:   0.4722421 
Empirical Hurst exponent:            0.4872281 
Corrected empirical Hurst exponent:  0.4460807 
Theoretical Hurst exponent:          0.5404756 
> # Simple R/S Hurst estimation:         0.4825898 
> # Corrected R over S Hurst exponent:   0.5067766 
> # Empirical Hurst exponent:            0.4869625 
> # Corrected empirical Hurst exponent:  0.4485892 
> # Theoretical Hurst exponent:          0.5368124 
> 
> 
> ##  Compare with other implementations
> ## Not run: 
> ##D library(fractal)
> ##D 
> ##D x <- x72
> ##D hurstSpec(x)                    # 0.776   # 0.720
> ##D RoverS(x)                       # 0.717
> ##D hurstBlock(x, method="aggAbs")  # 0.648
> ##D hurstBlock(x, method="aggVar")  # 0.613
> ##D hurstBlock(x, method="diffvar") # 0.714
> ##D hurstBlock(x, method="higuchi") # 1.001
> ##D 
> ##D x <- xgn
> ##D hurstSpec(x)                    # 0.538   # 0.500
> ##D RoverS(x)                       # 0.663
> ##D hurstBlock(x, method="aggAbs")  # 0.463
> ##D hurstBlock(x, method="aggVar")  # 0.430
> ##D hurstBlock(x, method="diffvar") # 0.471
> ##D hurstBlock(x, method="higuchi") # 0.574
> ##D 
> ##D x <- xlm
> ##D hurstSpec(x)                    # 0.478   # 0.430
> ##D RoverS(x)                       # 0.622
> ##D hurstBlock(x, method="aggAbs")  # 0.316
> ##D hurstBlock(x, method="aggVar")  # 0.279
> ##D hurstBlock(x, method="diffvar") # 0.547
> ##D hurstBlock(x, method="higuchi") # 0.998
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("hyperbolic")
> ### * hyperbolic
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: coth,csch,sech, etc.
> ### Title: More Hyperbolic Functions
> ### Aliases: coth csch sech acoth acsch asech
> ### Keywords: math
> 
> ### ** Examples
> 
> coth(1+1i)      # 0.8680 - 0.2176i
[1] 0.8680141-0.2176216i
> csch(1+1i)      # 0.3039 - 0.6215i
[1] 0.303931-0.621518i
> sech(1+1i)      # 0.4983 - 0.5911i
[1] 0.498337-0.5910838i
> acoth(1+1i)     # 0.4024 - 0.5536i
[1] 0.4023595-0.5535744i
> acsch(1+1i)     # 0.5306 - 0.4523i
[1] 0.5306375-0.4522784i
> asech(1+1i)     # 0.5306 - 1.1185i
[1] -0.530638+1.118518i
> 
> 
> 
> cleanEx()
> nameEx("hypot")
> ### * hypot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: hypot
> ### Title: Hypotenuse Function
> ### Aliases: hypot
> ### Keywords: array
> 
> ### ** Examples
> 
> hypot(3,4)
[1] 5
> hypot(1, c(3, 4, 5))
[1] 3.162278 4.123106 5.099020
> hypot(c(0, 0), c(3, 4))
[1] 3 4
> 
> 
> 
> cleanEx()
> nameEx("ifft")
> ### * ifft
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ifft
> ### Title: Inverse Fast Fourier Transformation
> ### Aliases: ifft ifftshift fftshift
> ### Keywords: array
> 
> ### ** Examples
> 
> x <- c(1, 2, 3, 4)
> (y <- fft(x))
[1] 10+0i -2+2i -2+0i -2-2i
> ifft(x)
[1]  2.5+0.0i -0.5-0.5i -0.5+0.0i -0.5+0.5i
> ifft(y)
[1] 1+0i 2+0i 3+0i 4+0i
> 
> ##  Compute the derivative: F(df/dt) = (1i*k) * F(f)
> #   hyperbolic secans f <- sech
> df <- function(x) -sech(x) * tanh(x)
> d2f <- function(x) sech(x) - 2*sech(x)^3
> L <- 20                                 # domain [-L/2, L/2]
> N <- 128                                # number of Fourier nodes
> x <- linspace(-L/2, L/2, N+1)           # domain discretization
> x <- x[1:N]                             # because of periodicity
> dx <- x[2] - x[1]                       # finite difference
> u <- sech(x)                            # hyperbolic secans
> u1d <- df(x); u2d <- d2f(x)             # first and second derivative
> ut <- fft(u)                            # discrete Fourier transform
> k <- (2*pi/L)*fftshift((-N/2):(N/2-1))  # shifted frequencies
> u1 <- Re(ifft((1i*k) * ut))             # inverse transform
> u2 <- Re(ifft(-k^2 * ut))               # first and second derivative
> ## Not run: 
> ##D plot(x, u1d, type = "l", col = "blue")
> ##D points(x, u1)
> ##D grid()
> ##D figure()
> ##D plot(x, u2d, type = "l", col = "darkred")
> ##D points(x, u2)
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("inpolygon")
> ### * inpolygon
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: inpolygon
> ### Title: Polygon Region
> ### Aliases: inpolygon
> ### Keywords: geom
> 
> ### ** Examples
> 
> xp <- c(0.5, 0.75, 0.75, 0.5, 0.5)
> yp <- c(0.5, 0.5, 0.75, 0.75, 0.5)
> x <- c(0.6, 0.75, 0.6, 0.5)
> y <- c(0.5, 0.6, 0.75, 0.6)
> inpolygon(x, y, xp, yp, boundary = FALSE)  # FALSE
[1] FALSE FALSE FALSE FALSE
> inpolygon(x, y, xp, yp, boundary = TRUE)   # TRUE
[1] TRUE TRUE TRUE TRUE
> 
> ## Not run: 
> ##D pg <- matrix(c(0.15, 0.75, 0.25, 0.45, 0.70,
> ##D                0.80, 0.35, 0.55, 0.20, 0.90), 5, 2)
> ##D plot(c(0, 1), c(0, 1), type="n")
> ##D polygon(pg[,1], pg[,2])
> ##D P <- matrix(runif(20000), 10000, 2)
> ##D R <- inpolygon(P[, 1], P[, 2], pg[, 1], pg[,2])
> ##D clrs <- ifelse(R, "red", "blue")
> ##D points(P[, 1], P[, 2], pch = ".", col = clrs)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("integral")
> ### * integral
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: integral
> ### Title: Adaptive Numerical Integration
> ### Aliases: integral
> ### Keywords: math
> 
> ### ** Examples
> 
> ##  Very smooth function
> fun <- function(x) 1/(x^4+x^2+0.9)
> val <- 1.582232963729353
> for (m in c("Kron", "Clen", "Simp")) {
+     Q <- integral(fun, -1, 1, reltol = 1e-12, method = m)
+     cat(m, Q, abs(Q-val), "\n")}
Kron 1.582233 3.197442e-13 
Clen 1.582233 3.199663e-13 
Simp 1.582233 3.241851e-13 
> # Kron 1.582233 3.197442e-13 
> # Rich 1.582233 3.197442e-13  # use quadgr()
> # Clen 1.582233 3.199663e-13 
> # Simp 1.582233 3.241851e-13 
> # Romb 1.582233 2.555733e-13  # use romberg()
> 
> ##  Highly oscillating function
> fun <- function(x) sin(100*pi*x)/(pi*x)
> val <- 0.4989868086930458
> for (m in c("Kron", "Clen", "Simp")) {
+     Q <- integral(fun, 0, 1, reltol = 1e-12, method = m)
+     cat(m, Q, abs(Q-val), "\n")}
Kron 0.4989868 2.220446e-16 
Clen 0.4989868 2.259304e-14 
Simp 0.4989868 6.27276e-15 
> # Kron 0.4989868 2.775558e-16 
> # Rich 0.4989868 4.440892e-16  # use quadgr()
> # Clen 0.4989868 2.231548e-14
> # Simp 0.4989868 6.328271e-15 
> # Romb 0.4989868 1.508793e-13  # use romberg()
> 
> ## Evaluate improper integral
> fun <- function(x) log(x)^2 * exp(-x^2)
> val <- 1.9475221803007815976
> Q <- integral(fun, 0, Inf, reltol = 1e-12)
For infinite domains Gauss integration is applied!
> # For infinite domains Gauss integration is applied!
> cat(m, Q, abs(Q-val), "\n")
Simp 1.947522 2.015876e-11 
> # Kron 1.94752218028062 2.01587635473288e-11 
> 
> ## Example with small function support
> fun <- function(x)
+             ifelse (x <= 0 | x >= pi, 0, sin(x))
> integral(fun, -100, 100, no_intervals = 1)      # 0
[1] 0
> integral(fun, -100, 100, no_intervals = 10)     # 1.99999999723
[1] 2
> integral(fun, -100, 100, random=FALSE)          # 2
[1] 2
> integral(fun, -100, 100, random=TRUE)           # 2 (sometimes 0 !)
[1] 2
> integral(fun, -1000, 10000, random=FALSE)       # 0
[1] 0
> integral(fun, -1000, 10000, random=TRUE)        # 0 (sometimes 2 !)
[1] 0
> 
> 
> 
> cleanEx()
> nameEx("integral2")
> ### * integral2
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: integral2
> ### Title: Numerically Evaluate Double and Triple Integrals
> ### Aliases: integral2 integral3
> ### Keywords: math
> 
> ### ** Examples
> 
> fun <- function(x, y) cos(x) * cos(y)
> integral2(fun, 0, 1, 0, 1, reltol = 1e-10)
$Q
[1] 0.7080734

$error
[1] 4.309141e-19

> # $Q:     0.708073418273571  # 0.70807341827357119350 = sin(1)^2
> # $error: 8.618277e-19       # 1.110223e-16
> 
> ##  Compute the volume of a sphere
> f <- function(x, y) sqrt(1 -x^2 - y^2)
> xmin <- 0; xmax <- 1
> ymin <- 0; ymax <- function(x) sqrt(1 - x^2)
> I <- integral2(f, xmin, xmax, ymin, ymax)
> I$Q                             # 0.5236076 - pi/6 => 8.800354e-06
[1] 0.5236076
> 
> ##  Compute the volume over a sector
> I <- integral2(f, 0,pi/2, 0,1, sector = TRUE)
> I$Q                             # 0.5236308 - pi/6 => 3.203768e-05
[1] 0.5236226
> 
> ##  Integrate 1/( sqrt(x + y)*(1 + x + y)^2 ) over the triangle
> ##   0 <= x <= 1, 0 <= y <= 1 - x.  The integrand is infinite at (0,0).
> f <- function(x,y) 1/( sqrt(x + y) * (1 + x + y)^2 )
> ymax <- function(x) 1 - x
> I <- integral2(f, 0,1, 0,ymax)
> I$Q + 1/2 - pi/4                # -3.247091e-08
[1] -3.247091e-08
> 
> ##  Compute this integral as a sector
> rmax <- function(theta) 1/(sin(theta) + cos(theta))
> I <- integral2(f, 0,pi/2, 0,rmax, sector = TRUE, singular = TRUE)
> I$Q + 1/2 - pi/4                # -4.998646e-11
[1] -4.998646e-11
> 
> ##  Examples of computing triple integrals
> f0 <- function(x, y, z) y*sin(x) + z*cos(x)
> integral3(f0, 0, pi, 0,1, -1,1) # - 2.0 => 0.0
[1] 2
> 
> f1 <- function(x, y, z) exp(x+y+z)
> integral3(f1, 0, 1, 1, 2, 0, 0.5)
[1] 5.206447
> ## [1] 5.206447                         # 5.20644655
> 
> f2 <- function(x, y, z) x^2 + y^2 + z
> a <- 2; b <- 4
> ymin <- function(x) x - 1
> ymax <- function(x) x + 6
> zmin <- -2
> zmax <- function(x, y) 4 + y^2
> integral3(f2, a, b, ymin, ymax, zmin, zmax)
[1] 47416.76
> ## [1] 47416.75556                      # 47416.7555556
> 
> f3 <- function(x, y, z) sqrt(x^2 + y^2)
> a <- -2; b <- 2
> ymin <- function(x) -sqrt(4-x^2)
> ymax <- function(x)  sqrt(4-x^2)
> zmin <- function(x, y)  sqrt(x^2 + y^2)
> zmax <- 2
> integral3(f3, a, b, ymin, ymax, zmin, zmax)
[1] 8.37758
> ## [1] 8.37758                          # 8.377579076269617
> 
> 
> 
> cleanEx()
> nameEx("interp1")
> ### * interp1
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: interp1
> ### Title: One-dimensional Interpolation
> ### Aliases: interp1
> ### Keywords: math
> 
> ### ** Examples
> 
> x <- c(0.8, 0.3, 0.1, 0.6, 0.9, 0.5, 0.2, 0.0, 0.7, 1.0, 0.4)
> y <- x^2
> xi <- seq(0, 1, len = 81)
> yl <- interp1(x, y, xi, method = "linear")
Warning in interp1(x, y, xi, method = "linear") :
  Points in argument in 'x' unsorted; will be sorted.
> yn <- interp1(x, y, xi, method = "nearest")
Warning in interp1(x, y, xi, method = "nearest") :
  Points in argument in 'x' unsorted; will be sorted.
> ys <- interp1(x, y, xi, method = "spline")
Warning in interp1(x, y, xi, method = "spline") :
  Points in argument in 'x' unsorted; will be sorted.
> 
> ## Not run: 
> ##D plot(x, y); grid()
> ##D lines(xi, yl, col="blue", lwd = 2)
> ##D lines(xi, yn, col="black", lty = 2)
> ##D lines(xi, ys, col="red")
> ##D   
> ## End(Not run)
> 
> ## Difference between spline (Matlab) and spline (R).
> x <- 1:6
> y <- c(16, 18, 21, 17, 15, 12)
> xs <- linspace(1, 6, 51)
> ys <- interp1(x, y, xs, method = "spline")
> sp <- spline(x, y, n = 51, method = "fmm")
> 
> ## Not run: 
> ##D plot(x, y, main = "Matlab and R splines")
> ##D grid()
> ##D lines(xs, ys, col = "red")
> ##D lines(sp$x, sp$y, col = "blue")
> ##D legend(4, 20, c("Matlab spline", "R spline"), 
> ##D               col = c("red", "blue"), lty = 1)
> ##D   
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("interp2")
> ### * interp2
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: interp2
> ### Title: Two-dimensional Data Interpolation
> ### Aliases: interp2
> ### Keywords: math
> 
> ### ** Examples
> 
> ## Not run: 
> ##D     x <- linspace(-1, 1, 11)
> ##D     y <- linspace(-1, 1, 11)
> ##D     mgrid <- meshgrid(x, y)
> ##D     Z <- mgrid$X^2 + mgrid$Y^2
> ##D     xp <- yp <- linspace(-1, 1, 101)
> ##D 
> ##D     method <- "linear"
> ##D     zp <- interp2(x, y, Z, xp, yp, method)
> ##D     plot(xp, zp, type = "l", col = "blue")
> ##D 
> ##D     method = "nearest"
> ##D     zp <- interp2(x, y, Z, xp, yp, method)
> ##D     lines(xp, zp, col = "red")
> ##D     grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("inv")
> ### * inv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: inv
> ### Title: Matrix Inverse (Matlab Style)
> ### Aliases: inv
> ### Keywords: array
> 
> ### ** Examples
> 
> A <- hilb(6)
> B <- inv(A)
> B
      [,1]    [,2]     [,3]     [,4]     [,5]     [,6]
[1,]    36    -630     3360    -7560     7560    -2772
[2,]  -630   14700   -88200   211680  -220500    83160
[3,]  3360  -88200   564480 -1411200  1512000  -582120
[4,] -7560  211680 -1411200  3628800 -3969000  1552320
[5,]  7560 -220500  1512000 -3969000  4410000 -1746360
[6,] -2772   83160  -582120  1552320 -1746360   698544
> # Compute the inverse matrix through Cramer's rule:
> n <- nrow(A)
> detA <- det(A) 
> b <- matrix(NA, nrow = n, ncol = n)
> for (i in 1:n) {
+     for (j in 1:n) {
+         b[i, j] <- (-1)^(i+j) * det(A[-j, -i]) / detA
+     }
+ }
> b
      [,1]    [,2]     [,3]     [,4]     [,5]     [,6]
[1,]    36    -630     3360    -7560     7560    -2772
[2,]  -630   14700   -88200   211680  -220500    83160
[3,]  3360  -88200   564480 -1411200  1512000  -582120
[4,] -7560  211680 -1411200  3628800 -3969000  1552320
[5,]  7560 -220500  1512000 -3969000  4410000 -1746360
[6,] -2772   83160  -582120  1552320 -1746360   698544
> 
> 
> 
> cleanEx()
> nameEx("invlap")
> ### * invlap
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: invlap
> ### Title: Inverse Laplacian
> ### Aliases: invlap
> ### Keywords: timeseries
> 
> ### ** Examples
> 
> Fs <- function(s) 1/(s^2 + 1)           # sine function
> Li <- invlap(Fs, 0, 2*pi, 100)
> 
> ## Not run: 
> ##D plot(Li[[1]], Li[[2]], type = "l", col = "blue"); grid()
> ##D 
> ##D Fs <- function(s) tanh(s)/s             # step function
> ##D L1 <- invlap(Fs, 0.01, 20, 1000)
> ##D plot(L1[[1]], L1[[2]], type = "l", col = "blue")
> ##D L2 <- invlap(Fs, 0.01, 20, 2000, 6, 280, 59)
> ##D lines(L2[[1]], L2[[2]], col="darkred"); grid()
> ##D 
> ##D Fs <- function(s) 1/(sqrt(s)*s)
> ##D L1 <- invlap(Fs, 0.01, 5, 200, 6, 40, 20)
> ##D plot(L1[[1]], L1[[2]], type = "l", col = "blue"); grid()
> ##D 
> ##D Fs <- function(s) 1/(s^2 - 1)           # hyperbolic sine function
> ##D Li <- invlap(Fs, 0, 2*pi, 100)
> ##D plot(Li[[1]], Li[[2]], type = "l", col = "blue"); grid()
> ##D 
> ##D Fs <- function(s) 1/s/(s + 1)           # exponential approach
> ##D Li <- invlap(Fs, 0, 2*pi, 100)
> ##D plot(Li[[1]], Li[[2]], type = "l", col = "blue"); grid()
> ##D 
> ##D gamma <- 0.577215664901532              # Euler-Mascheroni constant
> ##D Fs <- function(s) -1/s * (log(s)+gamma) # natural logarithm
> ##D Li <- invlap(Fs, 0, 2*pi, 100)
> ##D plot(Li[[1]], Li[[2]], type = "l", col = "blue"); grid()
> ##D 
> ##D Fs <- function(s) (20.5+3.7343*s^1.15)/(21.5+3.7343*s^1.15+0.8*s^2.2+0.5*s^0.9)/s
> ##D L1 <- invlap(Fs, 0.01, 5, 200, 6, 40, 20)
> ##D plot(L1[[1]], L1[[2]], type = "l", col = "blue")
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("isempty")
> ### * isempty
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: isempty
> ### Title: isempty Property
> ### Aliases: isempty
> ### Keywords: logic
> 
> ### ** Examples
> 
> isempty(c(0))            # FALSE
[1] FALSE
> isempty(matrix(0, 1, 0)) # TRUE
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("isposdef")
> ### * isposdef
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: isposdef
> ### Title: Positive Definiteness
> ### Aliases: isposdef
> ### Keywords: array
> 
> ### ** Examples
> 
> A <- magic(5)
> # isposdef(A)
> ## [1] FALSE
> ## Warning message:
> ## In isposdef(A) : Matrix 'A' is not symmetric.
> ## FALSE
> 
> A <- t(A) %*% A
> isposdef(A)
[1] TRUE
> ## [1] TRUE
> 
> A[5, 5] <- 0
> isposdef(A)
[1] FALSE
> ## [1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("isprime")
> ### * isprime
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: isprime
> ### Title: isprime Property
> ### Aliases: isprime
> ### Keywords: math
> 
> ### ** Examples
> 
>   x <- matrix(1:10, nrow=10, ncol=10, byrow=TRUE)
>   x * isprime(x)
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
 [1,]    0    2    3    0    5    0    7    0    0     0
 [2,]    0    2    3    0    5    0    7    0    0     0
 [3,]    0    2    3    0    5    0    7    0    0     0
 [4,]    0    2    3    0    5    0    7    0    0     0
 [5,]    0    2    3    0    5    0    7    0    0     0
 [6,]    0    2    3    0    5    0    7    0    0     0
 [7,]    0    2    3    0    5    0    7    0    0     0
 [8,]    0    2    3    0    5    0    7    0    0     0
 [9,]    0    2    3    0    5    0    7    0    0     0
[10,]    0    2    3    0    5    0    7    0    0     0
> 
>   # Find first prime number octett:
>   octett <- c(0, 2, 6, 8, 30, 32, 36, 38) - 19
>   while (TRUE) {
+       octett <- octett + 210
+       if (all(as.logical(isprime(octett)))) {
+           cat(octett, "\n", sep="  ")
+           break
+       }
+   }
1006301  1006303  1006307  1006309  1006331  1006333  1006337  1006339  
> 
> 
> 
> cleanEx()
> nameEx("itersolve")
> ### * itersolve
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: itersolve
> ### Title: Iterative Methods
> ### Aliases: itersolve
> ### Keywords: array
> 
> ### ** Examples
> 
> N <- 10
> A <- Diag(rep(3,N)) + Diag(rep(-2, N-1), k=-1) + Diag(rep(-1, N-1), k=1)
> b <- A %*% rep(1, N)
> x0 <- rep(0, N)
> 
> itersolve(A, b, tol = 1e-8, method = "Gauss-Seidel")
$x
 [1] 1 1 1 1 1 1 1 1 1 1

$iter
[1] 87

$method
[1] "Gauss-Seidel"

> # [1]  1  1  1  1  1  1  1  1  1  1
> # [1]  87
> itersolve(A, b, x0 = 1:10, tol = 1e-8, method = "Jacobi")
$x
 [1] 1 1 1 1 1 1 1 1 1 1

$iter
[1] 177

$method
[1] "Jacobi"

> # [1]  1  1  1  1  1  1  1  1  1  1
> # [1]  177
> 
> 
> 
> cleanEx()
> nameEx("jacobian")
> ### * jacobian
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: jacobian
> ### Title: Jacobian Matrix
> ### Aliases: jacobian
> ### Keywords: math
> 
> ### ** Examples
> 
> ##  Example function from Quarteroni & Saleri
> f <- function(x) c(x[1]^2 + x[2]^2 - 1, sin(pi*x[1]/2) + x[2]^3)
> jf <- function(x) 
+           matrix( c(2*x[1], pi/2 * cos(pi*x[1]/2), 2*x[2], 3*x[2]^2), 2, 2)
> all.equal(jf(c(1,1)), jacobian(f, c(1,1)))
[1] TRUE
> # TRUE
> 
> 
> 
> cleanEx()
> nameEx("kriging")
> ### * kriging
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: kriging
> ### Title: Interpolation by Kriging
> ### Aliases: kriging
> ### Keywords: fitting
> 
> ### ** Examples
> 
> ##  Interpolate the Saddle Point function
> f <- function(x) x[1]^2 - x[2]^2       # saddle point function
> 
> set.seed(8237)
> n <- 36
> x <- c(1, 1, -1, -1, runif(n-4, -1, 1)) # add four vertices
> y <- c(1, -1, 1, -1, runif(n-4, -1, 1))
> u <- cbind(x, y)
> v <- numeric(n)
> for (i in 1:n) v[i] <- f(c(x[i], y[i]))
> 
> kriging(u, v, c(0, 0))                      #=>  0.006177183
[1] 0.006177183
> kriging(u, v, c(0, 0), type = "simple")     #=>  0.006229557
[1] 0.006229557
> 
> ## Not run: 
> ##D xs <- linspace(-1, 1, 101)              # interpolation on a diagonal
> ##D u0 <- cbind(xs, xs)
> ##D 
> ##D yo <- kriging(u, v, u0, type = "ordinary")  # ordinary kriging
> ##D ys <- kriging(u, v, u0, type = "simple")    # simple kriging
> ##D plot(xs, ys, type = "l", col = "blue", ylim = c(-0.1, 0.1),
> ##D              main = "Kriging interpolation along the diagonal")
> ##D lines(xs, yo, col = "red")
> ##D legend( -1.0, 0.10, c("simple kriging", "ordinary kriging", "function"),
> ##D         lty = c(1, 1, 1), lwd = c(1, 1, 2), col=c("blue", "red", "black"))
> ##D grid()
> ##D lines(c(-1, 1), c(0, 0), lwd = 2)
> ## End(Not run)
> 
> ##  Find minimum of the sphere function
> f <- function(x, y) x^2 + y^2 + 100
> v <- bsxfun(f, x, y)
> 
> ff <- function(w) kriging(u, v, w)
> ff(c(0, 0))                                 #=>  100.0317
[1] 100.0317
> ## Not run: 
> ##D optim(c(0.0, 0.0), ff)
> ##D # $par:   [1]  0.04490075 0.01970690
> ##D # $value: [1]  100.0291
> ##D ezcontour(ff, c(-1, 1), c(-1, 1))
> ##D points(0.04490075, 0.01970690, col = "red")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("kron")
> ### * kron
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: kron
> ### Title: Kronecker product (Matlab Style)
> ### Aliases: kron
> ### Keywords: array
> 
> ### ** Examples
> 
> a <- diag(1, 2, 2)
> b <- matrix(1:4, 2, 2)
> kron(a, b)
     [,1] [,2] [,3] [,4]
[1,]    1    3    0    0
[2,]    2    4    0    0
[3,]    0    0    1    3
[4,]    0    0    2    4
> kron(b, a)
     [,1] [,2] [,3] [,4]
[1,]    1    0    3    0
[2,]    0    1    0    3
[3,]    2    0    4    0
[4,]    0    2    0    4
> 
> 
> 
> cleanEx()
> nameEx("l1linreg")
> ### * l1linreg
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: L1linreg
> ### Title: L1 Linear Regression
> ### Aliases: L1linreg
> ### Keywords: optimize
> 
> ### ** Examples
> 
> m <- 101; n <- 10       # no. of data points, degree of polynomial
> x <- seq(-1, 1, len=m)
> y <- runge(x)           # Runge's function
> A <- outer(x, n:0, '^') # Vandermonde matrix
> b <- y
> 
> ( sol <- L1linreg(A, b) )
$x
 [1] -2.193242e+01 -3.700879e-13  6.291092e+01  7.205894e-13 -6.784854e+01
 [6] -4.416790e-13  3.414400e+01  9.512378e-14 -8.118989e+00 -5.397284e-15
[11]  8.453273e-01

$reltol
[1] 6.714345e-10

$niter
[1] 81

> # $x
> # [1] -21.93242   0.00000  62.91092   0.00000 -67.84854   0.00000
> # [7]  34.14400   0.00000  -8.11899   0.00000   0.84533
> # 
> # $reltol
> # [1] 6.712355e-10
> # 
> # $niter
> # [1] 81
> 
> # minimum value of polynomial L1 regression
> sum(abs(polyval(sol$x, x) - y))
[1] 3.061811
> # [1] 3.061811
> 
> 
> 
> cleanEx()
> nameEx("laguerre")
> ### * laguerre
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: laguerre
> ### Title: Laguerre's Method
> ### Aliases: laguerre
> ### Keywords: math
> 
> ### ** Examples
> 
> # 1 x^5 - 5.4 x^4 + 14.45 x^3 - 32.292 x^2 + 47.25 x - 26.46
> p <- c(1.0, -5.4, 14.45, -32.292, 47.25, -26.46)
> laguerre(p, 1)   #=> 1.2
[1] 1.2
> laguerre(p, 2)   #=> 2.099987     (should be 2.1)
[1] 2.099987
> laguerre(p, 2i)  #=> 0+2.236068i  (+- 2.2361i, i.e sqrt(-5))
[1] 0+2.236068i
> 
> 
> 
> cleanEx()
> nameEx("lambertW")
> ### * lambertW
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lambertWp
> ### Title: Lambert's W Function
> ### Aliases: lambertWp lambertWn
> ### Keywords: specfun
> 
> ### ** Examples
> 
> ##  Examples
> lambertWp(0)          #=> 0
[1] 0
> lambertWp(1)          #=> 0.5671432904097838...  Omega constant
[1] 0.5671433
> lambertWp(exp(1))     #=> 1
[1] 1
> lambertWp(-log(2)/2)  #=> -log(2)
[1] -0.6931472
> 
> # The solution of  x * a^x = z  is  W(log(a)*z)/log(a)
> # x * 123^(x-1) = 3
> lambertWp(3*123*log(123))/log(123)  #=> 1.19183018...
[1] 1.19183
> 
> x <- seq(-0.35, 0.0, by=0.05)
> w <- lambertWn(x)
> w * exp(w)            # max. error < 3e-16
[1] -0.35 -0.30 -0.25 -0.20 -0.15 -0.10 -0.05   NaN
> # [1] -0.35 -0.30 -0.25 -0.20 -0.15 -0.10 -0.05   NaN
> 
> ## Not run: 
> ##D xs <- c(-1/exp(1), seq(-0.35, 6, by=0.05))
> ##D ys <- lambertWp(xs)
> ##D plot(xs, ys, type="l", col="darkred", lwd=2, ylim=c(-2,2),
> ##D      main="Lambert W0 Function", xlab="", ylab="")
> ##D grid()
> ##D points(c(-1/exp(1), 0, 1, exp(1)), c(-1, 0, lambertWp(1), 1))
> ##D text(1.8, 0.5, "Omega constant")
> ##D   
> ## End(Not run)
> 
> ## Analytic derivative of lambertWp (similar for lambertWn)
> D_lambertWp <- function(x) {
+     xw <- lambertWp(x)
+     1 / (1+xw) / exp(xw)
+ }
> D_lambertWp(c(-1/exp(1), 0, 1, exp(1)))
[1]       Inf 1.0000000 0.3618963 0.1839397
> # [1] Inf 1.0000000 0.3618963 0.1839397
> 
> ## Second branch resp. the complex function lambertWm()
> F <- function(xy, z0) {
+     z <- xy[1] + xy[2]*1i
+     fz <- z * exp(z) - z0
+     return(c(Re(fz), Im(fz)))
+ }
> newtonsys(F, c(-1, -1), z0 = -0.1)   #=> -3.5771520639573
$zero
[1] -3.577152e+00  9.544935e-18

$fnorm
[1] 1.389481e-17

$niter
[1] 6

> newtonsys(F, c(-1, -1), z0 = -pi/2)  #=> -1.5707963267949i = -pi/2 * 1i
$zero
[1] -1.001425e-17 -1.570796e+00

$fnorm
[1] 8.616929e-17

$niter
[1] 8

> 
> 
> 
> cleanEx()
> nameEx("laplacian")
> ### * laplacian
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: laplacian
> ### Title: Laplacian Operator
> ### Aliases: laplacian
> ### Keywords: math
> 
> ### ** Examples
> 
> f <- function(x) x[1]^2 + 2*x[1]*x[2] + x[2]^2
> laplacian(f, c(1,1))
[1] 4
> 
> 
> 
> cleanEx()
> nameEx("lebesgue")
> ### * lebesgue
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lebesgue
> ### Title: Lebesgue Constant
> ### Aliases: lebesgue
> ### Keywords: math
> 
> ### ** Examples
> 
> lebesgue(seq(0, 1, length.out = 6))  #=> 3.100425
[1] 3.100425
> 
> 
> 
> cleanEx()
> nameEx("legendre")
> ### * legendre
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: legendre
> ### Title: Legendre Functions (Matlab Style)
> ### Aliases: legendre
> ### Keywords: math
> 
> ### ** Examples
> 
> x <- c(0.0, 0.1, 0.2)
> legendre(2, x)
     [,1]       [,2]       [,3]
[1,] -0.5 -0.4850000 -0.4400000
[2,]  0.0 -0.2984962 -0.5878775
[3,]  3.0  2.9700000  2.8800000
> #      [,1]       [,2]       [,3]
> # [1,] -0.5 -0.4850000 -0.4400000
> # [2,]  0.0 -0.2984962 -0.5878775
> # [3,]  3.0  2.9700000  2.8800000
> 
> ## Not run: 
> ##D x <- seq(0, 1, len = 50)
> ##D L <- legendre(2, x)
> ##D plot(x, L[1, ], type = "l", col = 1, ylim = c(-2, 3), ylab = "y",
> ##D                 main = "Legendre Functions of degree 2")
> ##D lines(x, L[2, ], col = 2)
> ##D lines(x, L[3, ], col = 3)
> ##D grid()
> ## End(Not run)
> ## Generate Legendre's Polynomial as function
> # legendre_P <- function(n, x) {
> #     L <- legendre(n, x)
> #     return(L[1, ])
> # }
> 
> 
> 
> cleanEx()
> nameEx("line_integral")
> ### * line_integral
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: line_integral
> ### Title: Line integral (in the complex plane)
> ### Aliases: line_integral
> ### Keywords: math
> 
> ### ** Examples
> 
> ##  Complex integration examples
> points <- c(0, 1+1i, 1-1i, 0)           # direction mathematically negative
> f <- function(z) 1 / (2*z -1)
> I <- line_integral(f, points)
> abs(I - (0-pi*1i))                      # 0 ; residuum 2 pi 1i * 1/2
[1] 0
> 
> f <- function(z) 1/z
> points <- c(-1i, 1, 1i, -1, -1i)
> I <- line_integral(f, points)           # along a rectangle around 0+0i
> abs(I - 2*pi*1i)                        #=> 0 ; residuum: 2 pi i * 1
[1] 0
> 
> N <- 100
> x <- linspace(0, 2*pi, N)
> y <- cos(x) + sin(x)*1i
> J <- line_integral(f, waypoints = y)    # along a circle around 0+0i
> abs(I - J)                              #=> 5.015201e-17; same residuum
[1] 5.015201e-17
> 
> 
> 
> cleanEx()
> nameEx("linearproj")
> ### * linearproj
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: linearproj, affineproj
> ### Title: Linear Projection onto a Subspace
> ### Aliases: linearproj affineproj
> ### Keywords: math
> 
> ### ** Examples
> 
> #-- Linear projection --------------------------------------------------
> 
> # Projection onto the line (1,1,1) in R^3
> A <- matrix(c(1,1,1), 3, 1)
> B <- matrix(c(1,0,0, 1,2,3, -1,0,1), 3, 3)
> S <- linearproj(A, B)
> ## S$Q
> ##           [,1] [,2] [,3]
> ## [1,] 0.3333333    2    0
> ## [2,] 0.3333333    2    0
> ## [3,] 0.3333333    2    0
> 
> # Fourier expansion': sum(<x0, a_i> a_i /<a_i, a_i>), a_i = A[ ,i]
> dot(c(1,2,3), A) * A / dot(A, A)    # A has only one column
     [,1]
[1,]    2
[2,]    2
[3,]    2
> 
> #-- Affine projection --------------------------------------------------
> 
> # Projection onto the (hyper-)surface x+y+z = 1 in R^3
> A <- t(A); b <- 1
> x0 <- c(1,2,3)
> affineproj(x0, A, b)            # (-2/3, 1/3, 4/3)
$proj
           [,1]
[1,] -0.6666667
[2,]  0.3333333
[3,]  1.3333333

$dist
[1] 1.527525

$niter
[1] 0

> 
> # Linear translation: Let S be the linear subspace and A the parallel
> # affine subspace of A x = b, a the solution of the linear system, then
> #   proj_A(x) = a + proj_S(x-a)
> a <- qr.solve(A, b)
> A0 <- nullspace(A)
> xp <- c(a + linearproj(A0, x0 - a)$Q)
> ## [1] -0.6666667  0.3333333  1.3333333
> 
> #-- Projection with positivity ----------------------- 24 ms -- 1.3 s --
> s <- affineproj(x0, A, b, unbound = FALSE)
> zapsmall(s$proj)                 # [1] 0 0 1
[1] 0 0 1
> ## $x     : 0.000000e+00 3.833092e-17 1.000000e+00
> ## $niter : 35
> 
> #-- Extended Example ------------------------------------------ 80 ms --
> ## Not run: 
> ##D set.seed(65537)
> ##D n = 1000; m = 100                       # dimension, codimension
> ##D x0 <- rep(0, n)                         # project (0, ..., 0)
> ##D A <- matrix(runif(m*n), nrow = m)       # 100 x 1000
> ##D b <- rep(1, m)                          # A x = b, linear system
> ##D a <- qr.solve(A, b)                     # A a = b, LS solution
> ##D A0 <- nullspace(A)                      # 1000 x 900, base of <A>
> ##D xp <- a+drop(A0 %*% dot(x0-a, A0))      # projection
> ##D Norm(xp - x0)                           # [1] 0.06597077
> ## End(Not run)
> 
> #-- Solution with quadprog ------------------------------------ 40 ms --
> # D <- diag(1, n)             # quadratic form
> # A1 <- rbind(A, diag(1, n))  # A x = b and
> # b1 <- c(b, rep(0, n))       #   x >= 0
> # n <- nrow(A)
> # sol = quadprog::solve.QP(D, x0, t(A1), b1, meq = n)
> # xp <- sol$solution
> 
> #-- Solution with CVXR ---------------------------------------- 50 ms --
> # library(CVXR)
> # x = Variable(n)                             # n decision variables
> # objective = Minimize(p_norm(x0 - x))        # min! || p0 - x ||
> # constraint = list(A %*% x == b, x >= 0)     # A x = b, x >= 0
> # problem = Problem(objective, constraint)
> # solution = solve(problem)                   # Solver: ECOS
> # solution$value                              # 
> # xp <- solution$getValue(x)                  # 
> 
> 
> 
> cleanEx()
> nameEx("linprog")
> ### * linprog
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: linprog
> ### Title: Linear Programming Solver
> ### Aliases: linprog
> ### Keywords: optimize
> 
> ### ** Examples
> 
> ##  Examples from the book "Operations research - A Model-based Approach"
> #-- production planning
> cc <- c(5, 3.5, 4.5)
> Ain <- matrix(c(3, 5, 4,
+                 6, 1, 3), 2, 3, byrow=TRUE)
> bin <- c(540, 480)
> linprog(cc, A = Ain, b = bin, maximize = TRUE)
$x
[1]  20   0 120

$fval
[1] 640

$errno
[1] 1

$message
[1] "Solver LP converged successfully."

> # $x     20   0 120
> # $fval  640
> 
> #-- diet problem
> cc <- c(1.59, 2.19, 2.99)
> Ain <- matrix(c(-250, -380, -257,
+                  250,  380,  257,
+                   13,   31,   28), 3, 3, byrow = TRUE)
> bin <- c(-1800, 2200, 100)
> linprog(cc, A = Ain, b = bin)
$x
[1] 6.334520 0.569395 0.000000

$fval
[1] 11.31886

$errno
[1] 1

$message
[1] "Solver LP converged successfully."

> 
> #-- employee scheduling
> cc <- c(1, 1, 1, 1, 1, 1)
> A <- (-1)*matrix(c(1, 0, 0, 0, 0, 1,
+                    1, 1, 0, 0, 0, 0,
+                    0, 1, 1, 0, 0, 0,
+                    0, 0, 1, 1, 0, 0,
+                    0, 0, 0, 1, 1, 0,
+                    0, 0, 0, 0, 1, 1), 6, 6, byrow = TRUE)
> b <- -c(17, 9, 19, 12, 5, 8)
> linprog(cc, A, b)
$x
[1]  9 12  7  5  0  8

$fval
[1] 41

$errno
[1] 1

$message
[1] "Solver LP converged successfully."

> 
> #-- inventory models
> cc <- c(1, 1.1, 1.2, 1.25, 0.05, 0.15, 0.15)
> Aeq <- matrix(c(1, 0, 0, 0, -1,  0,  0,
+                 0, 1, 0, 0,  1, -1,  0,
+                 0, 0, 1, 0,  0,  1, -1,
+                 0, 0, 0, 1,  0,  0,  1), 4, 7, byrow = TRUE)
> beq <- c(60, 70, 130, 150)
> ub <- c(120, 140, 150, 140, Inf, Inf, Inf)
> linprog(cc, Aeq = Aeq, beq = beq, ub = ub)
$x
[1] 120  10 140 140  60   0  10

$fval
[1] 478.5

$errno
[1] 1

$message
[1] "Solver LP converged successfully."

> 
> #-- allocation problem
> cc <- c(1, 1, 1, 1, 1)
> A <- matrix(c(-5,    0,    0,    0,    0,
+                0, -4.5,    0,    0,    0,
+                0,    0, -5.5,    0,    0,
+                0,    0,    0, -3.5,    0,
+                0,    0,    0,    0, -5.5,
+                5,    0,    0,    0,    0,
+                0,  4.5,    0,    0,    0,
+                0,    0,  5.5,    0,    0,
+                0,    0,    0,  3.5,    0,
+                0,    0,    0,    0,  5.5,
+               -5, -4.5, -5.5, -3.5, -5.5,
+               10, 10.0, 10.0, 10.0, 10.0,
+               0.2, 0.2,  0.2, -1.0,  0.2), 13, 5, byrow = TRUE)
> b <- c(-50, -55, -60, -50, -50, rep(100, 5), -5*64, 700, 0)
> # linprog(cc, A = A, b = b)
> lb <- b[1:5] / diag(A[1:5, ])
> ub <- b[6:10] / diag(A[6:10, ])
> A1 <- A[11:13, ]
> b1 <- b[11:13]
> linprog(cc, A1, b1, lb = lb, ub = ub)
$x
[1] 10.00000 12.22222 11.81818 14.28571 18.18182

$fval
[1] 66.50794

$errno
[1] 1

$message
[1] "Solver LP converged successfully."

> 
> #-- transportation problem
> cc <- c(1, 7, 4, 2, 3, 5)
> Aeq <- matrix(c(1, 1, 1, 0, 0, 0,
+                 0, 0, 0, 1, 1, 1,
+                 1, 0, 0, 1, 0, 0,
+                 0, 1, 0, 0, 1, 0,
+                 0, 0, 1, 0, 0, 1), 5, 6, byrow = TRUE)
> beq <- c(30, 20, 15, 25, 10)
> linprog(cc, Aeq = Aeq, beq = beq)
$x
[1] 15  5 10  0 20  0

$fval
[1] 150

$errno
[1] 1

$message
[1] "Solver LP converged successfully."

> 
> 
> 
> cleanEx()
> nameEx("linspace")
> ### * linspace
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: linspace
> ### Title: Linearly Spaced Sequences
> ### Aliases: linspace
> ### Keywords: manip
> 
> ### ** Examples
> 
> linspace(1, 10, 9)
[1]  1.000  2.125  3.250  4.375  5.500  6.625  7.750  8.875 10.000
> 
> 
> 
> cleanEx()
> nameEx("logspace")
> ### * logspace
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: logspace
> ### Title: Log-linearly Spaced Sequences
> ### Aliases: logspace logseq
> ### Keywords: manip
> 
> ### ** Examples
> 
> logspace(1, pi, 36)
 [1] 10.000000  9.674596  9.359781  9.055211  8.760551  8.475479  8.199684
 [8]  7.932863  7.674725  7.424987  7.183375  6.949625  6.723482  6.504697
[15]  6.293032  6.088255  5.890141  5.698473  5.513043  5.333646  5.160088
[22]  4.992176  4.829729  4.672568  4.520521  4.373422  4.231109  4.093427
[29]  3.960225  3.831358  3.706684  3.586067  3.469376  3.356481  3.247260
[36]  3.141593
> logseq(0.05, 1, 20)
 [1] 0.05000000 0.05853900 0.06853628 0.08024090 0.09394443 0.10998826
 [7] 0.12877204 0.15076372 0.17651114 0.20665569 0.24194833 0.28326825
[13] 0.33164478 0.38828304 0.45459399 0.53222951 0.62312362 0.72954061
[19] 0.85413150 1.00000000
> 
> 
> 
> cleanEx()
> nameEx("lsqlin")
> ### * lsqlin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lsqlin
> ### Title: Linear Least-Squares Fitting
> ### Aliases: lsqlin
> ### Keywords: fitting
> 
> ### ** Examples
> 
> A <- matrix(c(
+     0.8147,    0.1576,    0.6557,
+     0.9058,    0.9706,    0.0357,
+     0.1270,    0.9572,    0.8491,
+     0.9134,    0.4854,    0.9340,
+     0.6324,    0.8003,    0.6787,
+     0.0975,    0.1419,    0.7577,
+     0.2785,    0.4218,    0.7431,
+     0.5469,    0.9157,    0.3922,
+     0.9575,    0.7922,    0.6555,
+     0.9649,    0.9595,    0.1712), 10, 3, byrow = TRUE)
> b <- matrix(c(
+     0.7060,    0.4387,
+     0.0318,    0.3816,
+     0.2769,    0.7655,
+     0.0462,    0.7952,
+     0.0971,    0.1869,
+     0.8235,    0.4898,
+     0.6948,    0.4456,
+     0.3171,    0.6463,
+     0.9502,    0.7094,
+     0.0344,    0.7547), 10, 2, byrow = TRUE)
> C <- matrix(c(
+     1.0000,    1.0000,    1.0000,
+     1.0000,   -1.0000,    0.5000), 2, 3, byrow = TRUE)
> d <- as.matrix(c(1, 0.5))
> 
> # With a full rank constraint system
> (L <- lsqlin(A, b, C, d))
           [,1]      [,2]
[1,] 0.10326838 0.3740381
[2,] 0.03442279 0.1246794
[3,] 0.86230882 0.5012825
> #  0.10326838 0.3740381
> #  0.03442279 0.1246794
> #  0.86230882 0.5012825
> C %*% L
     [,1] [,2]
[1,]  1.0  1.0
[2,]  0.5  0.5
> #  1.0  1.0
> #  0.5  0.5
> 
> ## Not run: 
> ##D # With a rank deficient constraint system
> ##D C <- str2num('[1 1 1;1 1 1]')
> ##D d <- str2num('[1;1]')
> ##D (L <- lsqlin(A, b[, 1], C, d))
> ##D #  0.2583340
> ##D # -0.1464215
> ##D #  0.8880875
> ##D C %*% L         # 1 1  as column vector
> ##D 
> ##D # Where both A and C are rank deficient
> ##D A2 <- repmat(A[, 1:2], 1, 2)
> ##D C <- ones(2, 4) # d as above
> ##D (L <- lsqlin(A2, b[, 2], C, d))
> ##D #  0.2244121
> ##D #  0.2755879
> ##D #  0.2244121
> ##D #  0.2755879
> ##D C %*% L         # 1 1  as column vector
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("lsqlincon")
> ### * lsqlincon
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lsqlincon
> ### Title: Linear Least-Squares Fitting with linear constraints
> ### Aliases: lsqlincon
> ### Keywords: optimize
> 
> ### ** Examples
> 
> ##  MATLABs lsqlin example
> C <- matrix(c(
+     0.9501,   0.7620,   0.6153,   0.4057,
+     0.2311,   0.4564,   0.7919,   0.9354,
+     0.6068,   0.0185,   0.9218,   0.9169,
+     0.4859,   0.8214,   0.7382,   0.4102,
+     0.8912,   0.4447,   0.1762,   0.8936), 5, 4, byrow=TRUE)
> d <- c(0.0578, 0.3528, 0.8131, 0.0098, 0.1388)
> A <- matrix(c(
+     0.2027,   0.2721,   0.7467,   0.4659,
+     0.1987,   0.1988,   0.4450,   0.4186,
+     0.6037,   0.0152,   0.9318,   0.8462), 3, 4, byrow=TRUE)
> b <- c(0.5251, 0.2026, 0.6721)
> Aeq <- matrix(c(3, 5, 7, 9), 1)
> beq <- 4
> lb <- rep(-0.1, 4)   # lower and upper bounds
> ub <- rep( 2.0, 4)
> 
> x <- lsqlincon(C, d, A, b, Aeq, beq, lb, ub)
> # -0.1000000 -0.1000000  0.1599088  0.4089598
> # check A %*% x - b >= 0
> # check Aeq %*% x - beq == 0
> # check sum((C %*% x - d)^2)    # 0.1695104
> 
> 
> 
> cleanEx()
> nameEx("lsqnonlin")
> ### * lsqnonlin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lsqnonlin
> ### Title: Nonlinear Least-Squares Fitting
> ### Aliases: lsqnonlin lsqnonneg lsqcurvefit lsqsep
> ### Keywords: fitting
> 
> ### ** Examples
> 
> ##  Rosenberg function as least-squares problem
> x0  <- c(0, 0)
> fun <- function(x) c(10*(x[2]-x[1]^2), 1-x[1])
> lsqnonlin(fun, x0)
$x
[1] 1 1

$ssq
[1] 3.084607e-19

$ng
[1] 2.247202e-10

$nh
[1] 3.62855e-07

$mu
[1] 0.0002279844

$neval
[1] 18

$errno
[1] 2

$errmess
[1] "Stopped by small gradient."

> 
> ##  Example from R-help
> y <- c(5.5199668,  1.5234525,  3.3557000,  6.7211704,  7.4237955,  1.9703127,
+        4.3939336, -1.4380091,  3.2650180,  3.5760906,  0.2947972,  1.0569417)
> x <- c(1,   0,   0,   4,   3,   5,  12,  10,  12, 100, 100, 100)
> # Define target function as difference
> f <- function(b)
+      b[1] * (exp((b[2] - x)/b[3]) * (1/b[3]))/(1 + exp((b[2] - x)/b[3]))^2 - y
> x0 <- c(21.16322, 8.83669, 2.957765)
> lsqnonlin(f, x0)        # ssq 50.50144 at c(36.133144, 2.572373, 1.079811)
$x
[1] 36.133144  2.572373  1.079811

$ssq
[1] 50.50144

$ng
[1] 6.878399e-07

$nh
[1] 1.710001e-07

$mu
[1] 3.043068e-09

$neval
[1] 29

$errno
[1] 1

$errmess
[1] "Stopped by small x-step."

> 
> # nls() will break down
> # nls(Y ~ a*(exp((b-X)/c)*(1/c))/(1 + exp((b-X)/c))^2,
> #     start=list(a=21.16322, b=8.83669, c=2.957765), algorithm = "plinear")
> # Error: step factor 0.000488281 reduced below 'minFactor' of 0.000976563
> 
> ##  Example: Hougon function
> x1 <- c(470, 285, 470, 470, 470, 100, 100, 470, 100, 100, 100, 285, 285)
> x2 <- c(300,  80, 300,  80,  80, 190,  80, 190, 300, 300,  80, 300, 190)
> x3 <- c( 10,  10, 120, 120,  10,  10,  65,  65,  54, 120, 120,  10, 120)
> rate <- c(8.55,  3.79, 4.82, 0.02,  2.75, 14.39, 2.54,
+           4.35, 13.00, 8.50, 0.05, 11.32,  3.13)
> fun <- function(b)
+         (b[1]*x2 - x3/b[5])/(1 + b[2]*x1 + b[3]*x2 + b[4]*x3) - rate
> lsqnonlin(fun, rep(1, 5))
$x
[1] 1.25258503 0.06277577 0.04004772 0.11241472 1.19137819

$ssq
[1] 0.298901

$ng
[1] 1.487661e-07

$nh
[1] 6.836601e-09

$mu
[1] 0.06537177

$neval
[1] 46

$errno
[1] 1

$errmess
[1] "Stopped by small x-step."

> # $x    [1.25258502 0.06277577 0.04004772 0.11241472 1.19137819]
> # $ssq  0.298901
> 
> ##  Example for lsqnonneg()
> C1 <- matrix( c(0.1210, 0.2319, 0.4398, 0.9342, 0.1370,
+                 0.4508, 0.2393, 0.3400, 0.2644, 0.8188,
+                 0.7159, 0.0498, 0.3142, 0.1603, 0.4302,
+                 0.8928, 0.0784, 0.3651, 0.8729, 0.8903,
+                 0.2731, 0.6408, 0.3932, 0.2379, 0.7349,
+                 0.2548, 0.1909, 0.5915, 0.6458, 0.6873,
+                 0.8656, 0.8439, 0.1197, 0.9669, 0.3461,
+                 0.2324, 0.1739, 0.0381, 0.6649, 0.1660,
+                 0.8049, 0.1708, 0.4586, 0.8704, 0.1556,
+                 0.9084, 0.9943, 0.8699, 0.0099, 0.1911), ncol = 5, byrow = TRUE)
> C2 <- C1 - 0.5
> d <- c(0.4225, 0.8560, 0.4902, 0.8159, 0.4608,
+        0.4574, 0.4507, 0.4122, 0.9016, 0.0056)
> ( sol <- lsqnonneg(C1, d) )     #-> resid.norm   0.3694372
$x
[1] 0.1315785 0.0000000 0.0000000 0.3958168 0.4983909

$resid.norm
[1] 0.3694372

> ( sol <- lsqnonneg(C2, d) )     #-> $resid.norm  2.863979
$x
[1] 0.3884495 0.0000000 0.0000000 0.6056227 0.2583276

$resid.norm
[1] 2.863979

> 
> ##  Example for lsqcurvefit()
> #   Lanczos1 data (artificial data)
> #   f(x) = 0.0951*exp(-x) + 0.8607*exp(-3*x) + 1.5576*exp(-5*x)
> x <- linspace(0, 1.15, 24)
> y <- c(2.51340000, 2.04433337, 1.66840444, 1.36641802, 1.12323249, 0.92688972,
+        0.76793386, 0.63887755, 0.53378353, 0.44793636, 0.37758479, 0.31973932,
+        0.27201308, 0.23249655, 0.19965895, 0.17227041, 0.14934057, 0.13007002,
+        0.11381193, 0.10004156, 0.08833209, 0.07833544, 0.06976694, 0.06239313)
> 
> p0 <- c(1.2, 0.3, 5.6, 5.5, 6.5, 7.6)
> fp <- function(p, x) p[1]*exp(-p[2]*x) + p[3]*exp(-p[4]*x) + p[5]*exp(-p[6]*x)
> lsqcurvefit(fp, p0, x, y)
$x
[1] 0.09510071 1.00000320 0.86070302 3.00000584 1.55759627 5.00000231

$ssq
[1] 1.304071e-16

$ng
[1] 4.430565e-09

$nh
[1] 0.0001409272

$mu
[1] 9.035825e-10

$neval
[1] 127

$errno
[1] 2

$errmess
[1] "Stopped by small gradient."

> 
> ##  Example for lsqsep()
> f <- function(x) 0.5 + x^-0.5 + exp(-0.5*x)
> set.seed(8237); n <- 15
> x <- sort(0.5 + 9*runif(n))
> y <- f(x)                       #y <- f(x) + 0.01*rnorm(n)
> 
> m <- 2
> f1 <- function(b, x) x^b
> f2 <- function(b, x) exp(b*x)
> flist <- list(f1, f2)
> start <- c(-0.25, -0.75)
> 
> sol <- lsqsep(flist, start, x, y, const = TRUE)
> a0 <- sol$a0; a <- sol$a; b <- sol$b
> fsol <- function(x) a0 + a[1]*f1(b[1], x) + a[2]*f2(b[2], x)
> 
> ## Not run: 
> ##D     ezplot(f, 0.5, 9.5, col = "gray")
> ##D     points(x, y, col = "blue")
> ##D     xs <- linspace(0.5, 9.5, 51)
> ##D     ys <- fsol(xs)
> ##D     lines(xs, ys, col = "red")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("lu")
> ### * lu
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lu
> ### Title: LU Matrix Factorization
> ### Aliases: lu lu_crout lufact lusys
> ### Keywords: array
> 
> ### ** Examples
> 
> A <- magic(5)
> D <- lu(A, scheme = "ijk")     # Doolittle scheme
> D$L %*% D$U
     [,1] [,2] [,3] [,4] [,5]
[1,]   17   24    1    8   15
[2,]   23    5    7   14   16
[3,]    4    6   13   20   22
[4,]   10   12   19   21    3
[5,]   11   18   25    2    9
> ##      [,1] [,2] [,3] [,4] [,5]
> ## [1,]   17   24    1    8   15
> ## [2,]   23    5    7   14   16
> ## [3,]    4    6   13   20   22
> ## [4,]   10   12   19   21    3
> ## [5,]   11   18   25    2    9
> 
> H4 <- hilb(4)
> lufact(H4)$det
[1] 1.653439e-07
> ## [1] 0.0000001653439
> 
> x0 <- c(1.0, 4/3, 5/3, 2.0)
> b  <- H4 %*% x0
> lusys(H4, b)
         [,1]
[1,] 1.000000
[2,] 1.333333
[3,] 1.666667
[4,] 2.000000
> ##          [,1]
> ## [1,] 1.000000
> ## [2,] 1.333333
> ## [3,] 1.666667
> ## [4,] 2.000000
> 
> 
> 
> cleanEx()
> nameEx("magic")
> ### * magic
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: magic
> ### Title: Magic Square
> ### Aliases: magic
> ### Keywords: array
> 
> ### ** Examples
> 
> magic(3)
     [,1] [,2] [,3]
[1,]    8    1    6
[2,]    3    5    7
[3,]    4    9    2
> 
> 
> 
> cleanEx()
> nameEx("mean")
> ### * mean
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: geomean, harmmean
> ### Title: Geometric and Harmonic Mean (Matlab Style)
> ### Aliases: geomean harmmean trimmean
> ### Keywords: stat
> 
> ### ** Examples
> 
> A <- matrix(1:12, 3, 4)
> geomean(A, dim = 1)
[1]  1.817121  4.932424  7.958114 10.969613
> ## [1]  1.817121  4.932424  7.958114 10.969613
> harmmean(A, dim = 2)
[1] 2.679426 4.367246 5.760000
> ## [1] 2.679426 4.367246 5.760000
> 
> x <- c(-0.98, -0.90, -0.68, -0.61, -0.61, -0.38, -0.37, -0.32, -0.20, -0.16,
+         0.00,  0.05,  0.12,  0.30,  0.44,  0.77,  1.37,  1.64,  1.72,  2.80)
> trimmean(x); trimmean(x, 20)    # 0.2  0.085
[1] 0.2
[1] 0.085
> mean(x); mean(x, 0.10)          # 0.2  0.085
[1] 0.2
[1] 0.085
> 
> 
> 
> cleanEx()
> nameEx("meshgrid")
> ### * meshgrid
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: meshgrid
> ### Title: Generate a Mesh Grid
> ### Aliases: meshgrid
> ### Keywords: array
> 
> ### ** Examples
> 
> meshgrid(1:5)$X
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    2    3    4    5
[2,]    1    2    3    4    5
[3,]    1    2    3    4    5
[4,]    1    2    3    4    5
[5,]    1    2    3    4    5
> meshgrid(c(1, 2, 3), c(11, 12))
$X
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    1    2    3

$Y
     [,1] [,2] [,3]
[1,]   11   11   11
[2,]   12   12   12

> 
> 
> 
> cleanEx()
> nameEx("mexpfit")
> ### * mexpfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mexpfit
> ### Title: Multi-exponential Fitting
> ### Aliases: mexpfit
> ### Keywords: fitting
> 
> ### ** Examples
> 
> #   Lanczos1 data (artificial data)
> #   f(x) = 0.0951*exp(-x) + 0.8607*exp(-3*x) + 1.5576*exp(-5*x)
> x <- linspace(0, 1.15, 24)
> y <- c(2.51340000, 2.04433337, 1.66840444, 1.36641802, 1.12323249, 0.92688972,
+        0.76793386, 0.63887755, 0.53378353, 0.44793636, 0.37758479, 0.31973932,
+        0.27201308, 0.23249655, 0.19965895, 0.17227041, 0.14934057, 0.13007002,
+        0.11381193, 0.10004156, 0.08833209, 0.07833544, 0.06976694, 0.06239313)
> p0 <- c(-0.3, -5.5, -7.6)
> mexpfit(x, y, p0, const = FALSE)
$a0
[1] 0

$a
[1] 0.09510431 0.86071171 1.55758398

$b
[1] -1.000022 -3.000028 -5.000009

$ssq
[1] 1.936159e-16

$iter
[1] 26

$errmess
[1] "Stopped by small gradient."

> ## $a0
> ## [1] 0
> ## $a
> ## [1] 0.09510431 0.86071171 1.55758398
> ## $b
> ## [1] -1.000022 -3.000028 -5.000009
> ## $ssq
> ## [1] 1.936163e-16
> ## $iter
> ## [1] 26
> ## $errmess
> ## [1] "Stopped by small gradient."
> 
> 
> 
> cleanEx()
> nameEx("midpoint")
> ### * midpoint
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bulirsch-stoer
> ### Title: Bulirsch-Stoer Algorithm
> ### Aliases: bulirsch_stoer midpoint
> ### Keywords: ode
> 
> ### ** Examples
> 
> ## Example: y'' = -y
> f1 <- function(t, y) as.matrix(c(y[2], -y[1]))
> y0 <- as.matrix(c(0.0, 1.0))
> tt <- linspace(0, pi, 13)
> yy <- bulirsch_stoer(f1, tt, c(0.0, 1.0))   # 13 equally-spaced grid points
> yy[nrow(yy), 1]                             # 1.1e-11
[1] 1.15016e-11
> 
> ## Not run: 
> ##D S  <- ode23(f1, 0, pi, c(0.0, 1.0))
> ##D yy <- bulirsch_stoer(f1, S$t, c(0.0, 1.0))  # S$x 13 irregular grid points
> ##D yy[nrow(yy), 1]                             #  2.5e-11
> ##D S$y[nrow(S$y), 1]                           # -7.1e-04
> ##D 
> ##D ## Example: y' = -200 x y^2                 # y(x) = 1 / (1 + 100 x^2)
> ##D f2 <- function(t, y) -200 * t * y^2
> ##D y0 < 1
> ##D tic(); S <- ode23(f2, 0, 1, y0); toc()            # 0.002 sec
> ##D tic(); yy <- bulirsch_stoer(f2, S$t, y0); toc()   # 0.013 sec
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("mldivide")
> ### * mldivide
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mldivide
> ### Title: Matlab backslash operator
> ### Aliases: mldivide mrdivide
> ### Keywords: math
> 
> ### ** Examples
> 
> # Solve a system of linear equations
> A <- matrix(c(8,1,6, 3,5,7, 4,9,2), nrow = 3, ncol = 3, byrow = TRUE)
> b <- c(1, 1, 1)
> mldivide(A, b)  # 0.06666667 0.06666667 0.06666667
           [,1]
[1,] 0.06666667
[2,] 0.06666667
[3,] 0.06666667
> 
> A <- rbind(1:3, 4:6)
> mldivide(A, c(1,1))                 # -0.5  0  0.5 ,i.e. Matlab/Octave result
              [,1]
[1,] -5.000000e-01
[2,]  4.801715e-15
[3,]  5.000000e-01
> mldivide(A, c(1,1), pinv = FALSE)   # -1    1  0         R    qr.solve result
     [,1]
[1,]   -1
[2,]    1
[3,]    0
> 
> 
> 
> cleanEx()
> nameEx("mod")
> ### * mod
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mod, rem
> ### Title: Integer Division
> ### Aliases: mod rem idivide
> ### Keywords: arith
> 
> ### ** Examples
> 
> mod(c(-5:5), 5)
 [1] 0 1 2 3 4 0 1 2 3 4 0
> rem(c(-5:5), 5)
 [1]  0 -4 -3 -2 -1  0  1  2  3  4  0
> 
> idivide(c(-2, 2), 3, "fix")     #  0 0
[1] 0 0
> idivide(c(-2, 2), 3, "floor")   # -1 0
[1] -1  0
> idivide(c(-2, 2), 3, "ceil")    #  0 1
[1] 0 1
> idivide(c(-2, 2), 3, "round")   # -1 1
[1] -1  1
> 
> 
> 
> cleanEx()
> nameEx("mode")
> ### * mode
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Mode
> ### Title: Mode function (Matlab style)
> ### Aliases: Mode
> ### Keywords: manip
> 
> ### ** Examples
> 
> x <- round(rnorm(1000), 2)
> Mode(x)
[1] -0.39
> 
> 
> 
> cleanEx()
> nameEx("moler")
> ### * moler
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: moler
> ### Title: Moler Matrix
> ### Aliases: moler
> ### Keywords: specmat
> 
> ### ** Examples
> 
> (a <- moler(10))
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
 [1,]    1   -1   -1   -1   -1   -1   -1   -1   -1    -1
 [2,]   -1    2    0    0    0    0    0    0    0     0
 [3,]   -1    0    3    1    1    1    1    1    1     1
 [4,]   -1    0    1    4    2    2    2    2    2     2
 [5,]   -1    0    1    2    5    3    3    3    3     3
 [6,]   -1    0    1    2    3    6    4    4    4     4
 [7,]   -1    0    1    2    3    4    7    5    5     5
 [8,]   -1    0    1    2    3    4    5    8    6     6
 [9,]   -1    0    1    2    3    4    5    6    9     7
[10,]   -1    0    1    2    3    4    5    6    7    10
> min(eig(a))
[1] 8.582807e-06
> 
> 
> 
> cleanEx()
> nameEx("movavg")
> ### * movavg
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: movavg
> ### Title: Moving Average Filters
> ### Aliases: movavg
> ### Keywords: timeseries
> 
> ### ** Examples
> 
> ## Not run: 
> ##D abbshares <- scan(file="")
> ##D 25.69 25.89 25.86 26.08 26.41 26.90 26.27 26.45 26.49 26.08 26.11 25.57 26.02
> ##D 25.53 25.27 25.95 25.19 24.78 24.96 24.63 25.68 25.24 24.87 24.71 25.01 25.06
> ##D 25.62 25.95 26.08 26.25 25.91 26.61 26.34 25.55 25.36 26.10 25.63 25.52 24.74
> ##D 25.00 25.38 25.01 24.57 24.95 24.89 24.13 23.83 23.94 23.74 23.12 23.13 21.05
> ##D 21.59 19.59 21.88 20.59 21.59 21.86 22.04 21.48 21.37 19.94 19.49 19.46 20.34
> ##D 20.59 19.96 20.18 20.74 20.83 21.27 21.19 20.27 18.83 19.46 18.90 18.09 17.99
> ##D 18.03 18.50 19.11 18.94 18.21 18.06 17.66 16.77 16.77 17.10 17.62 17.22 17.95
> ##D 17.08 16.42 16.71 17.06 17.75 17.65 18.90 18.80 19.54 19.23 19.48 18.98 19.28
> ##D 18.49 18.49 19.08 19.63 19.40 19.59 20.37 19.95 18.81 18.10 18.32 19.02 18.78
> ##D 18.68 19.12 17.79 18.10 18.64 18.28 18.61 18.20 17.82 17.76 17.26 17.08 16.70
> ##D 16.68 17.68 17.70 18.97 18.68 18.63 18.80 18.81 19.03 18.26 18.78 18.33 17.97
> ##D 17.60 17.72 17.79 17.74 18.37 18.24 18.47 18.75 18.66 18.51 18.71 18.83 19.82
> ##D 19.71 19.64 19.24 19.60 19.77 19.86 20.23 19.93 20.33 20.98 21.40 21.14 21.38
> ##D 20.89 21.08 21.30 21.24 20.55 20.83 21.57 21.67 21.91 21.66 21.53 21.63 21.83
> ##D 21.48 21.71 21.44 21.67 21.10 21.03 20.83 20.76 20.90 20.92 20.80 20.89 20.49
> ##D 20.70 20.60 20.39 19.45 19.82 20.28 20.24 20.30 20.66 20.66 21.00 20.88 20.99
> ##D 20.61 20.45 20.09 20.34 20.61 20.29 20.20 20.00 20.41 20.70 20.43 19.98 19.92
> ##D 19.77 19.23 19.55 19.93 19.35 19.66 20.27 20.10 20.09 20.48 19.86 20.22 19.35
> ##D 19.08 18.81 18.87 18.26 18.27 17.91 17.68 17.73 17.56 17.20 17.14 16.84 16.47
> ##D 16.45 16.25 16.07
> ##D 
> ##D plot(abbshares, type = "l", col = 1, ylim = c(15, 30),
> ##D                 main = "Types of moving averages", sub = "Mid 2011--Mid 2012",
> ##D                 xlab = "Days", ylab = "ABB Shares Price (in USD)")
> ##D y <- movavg(abbshares, 50, "s"); lines(y, col = 2)
> ##D y <- movavg(abbshares, 50, "t"); lines(y, col = 3)
> ##D y <- movavg(abbshares, 50, "w"); lines(y, col = 4)
> ##D y <- movavg(abbshares, 50, "m"); lines(y, col = 5)
> ##D y <- movavg(abbshares, 50, "e"); lines(y, col = 6)
> ##D y <- movavg(abbshares, 50, "r"); lines(y, col = 7)
> ##D grid()
> ##D legend(120, 29, c("original data", "simple", "triangular", "weighted",
> ##D                                    "modified", "exponential", "running"),
> ##D                 col = 1:7, lty = 1, lwd = 1, box.col = "gray", bg = "white")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("muller")
> ### * muller
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: muller
> ### Title: Muller's Method
> ### Aliases: muller
> ### Keywords: math
> 
> ### ** Examples
> 
> muller(function(x) x^10 - 0.5, 0, 1)  # root: 0.9330329915368074
$root
[1] 0.933033

$fval
[1] -5.551115e-17

$niter
[1] 9

$reltol
[1] 5.828663e-11

> 
> f <- function(x) x^4 - 3*x^3 + x^2 + x + 1
> p0 <- 0.5; p1 <- -0.5; p2 <- 0.0
> muller(f, p0, p1, p2)
$root
[1] -0.3390928-0.4466301i

$fval
[1] 2.220446e-16-5.55112e-17i

$niter
[1] 10

$reltol
[1] 4.568803e-16

> ## $root
> ## [1] -0.3390928-0.4466301i
> ## ...
> 
> ##  Roots of complex functions:
> fz <- function(z) sin(z)^2 + sqrt(z) - log(z)
> muller(fz, 1, 1i, 1+1i)
$root
[1] 0.2555197+0.8948303i

$fval
[1] -3.608225e-16+2.220446e-16i

$niter
[1] 8

$reltol
[1] 3.656538e-13

> ## $root
> ## [1] 0.2555197+0.8948303i
> ## $fval
> ## [1] -4.440892e-16+0i
> ## $niter
> ## [1] 8
> ## $reltol
> ## [1] 3.656219e-13
> 
> 
> 
> cleanEx()
> nameEx("nchoosek")
> ### * nchoosek
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nchoosek
> ### Title: Binomial Coefficients
> ### Aliases: nchoosek
> ### Keywords: arith
> 
> ### ** Examples
> 
> S <- sapply(0:6, function(k) nchoosek(6, k))  # 1  6 15 20 15  6  1
> 
> # Catalan numbers
> catalan <- function(n) choose(2*n, n)/(n+1)
> catalan(0:10)
 [1]     1     1     2     5    14    42   132   429  1430  4862 16796
> # 1  1  2  5  14  42  132  429  1430  4862  16796
> 
> # Relations
> n <- 10
> sum((-1)^c(0:n) * sapply(0:n, function(k) nchoosek(n, k)))  # 0
[1] 0
> 
> 
> 
> cleanEx()
> nameEx("ndims")
> ### * ndims
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ndims
> ### Title: Number of Dimensions
> ### Aliases: ndims
> ### Keywords: array
> 
> ### ** Examples
> 
> ndims(c())                      # 0
[1] 0
> ndims(as.numeric(1:8))          # 1
[1] 1
> ndims(list(a=1, b=2, c=3))      # 1
[1] 1
> ndims(matrix(1:12, 3, 4))       # 2
[1] 2
> ndims(array(1:8, c(2,2,2)))     # 3
[1] 3
> 
> 
> 
> cleanEx()
> nameEx("nearest_spd")
> ### * nearest_spd
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nearest_spd
> ### Title: Nearest Symmetric Positive-definite Matrix
> ### Aliases: nearest_spd
> ### Keywords: array
> 
> ### ** Examples
> 
> A <- matrix(1:9, 3, 3)
> B <- nearest_spd(A); B
         [,1]     [,2]     [,3]
[1,] 2.034900 3.202344 4.369788
[2,] 3.202344 5.039562 6.876781
[3,] 4.369788 6.876781 9.383774
> #          [,1]     [,2]     [,3]
> # [1,] 2.034900 3.202344 4.369788
> # [2,] 3.202344 5.039562 6.876781
> # [3,] 4.369788 6.876781 9.383774
> norm(B - A, type = 'F')
[1] 3.758517
> # [1] 3.758517
> 
> 
> 
> cleanEx()
> nameEx("neldermead")
> ### * neldermead
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nelder_mead
> ### Title: Nelder-Mead Function Minimization Method
> ### Aliases: nelder_mead
> ### Keywords: optimize
> 
> ### ** Examples
> 
> ##  Classical tests as in the article by Nelder and Mead
> # Rosenbrock's parabolic valley
> rpv <- function(x) 100*(x[2] - x[1]^2)^2 + (1 - x[1])^2
> x0 <- c(-2, 1)
> nelder_mead(rpv, x0)                     #  1 1
$xmin
[1] 0.9999999 0.9999998

$fmin
[1] 1.157529e-14

$count
[1] 196

$info
$info$solver
[1] "Nelder-Mead"

$info$restarts
[1] 0


> 
> # Fletcher and Powell's helic valley
> fphv <- function(x)
+     100*(x[3] - 10*atan2(x[2], x[1])/(2*pi))^2 + 
+         (sqrt(x[1]^2 + x[2]^2) - 1)^2 +x[3]^2
> x0 <- c(-1, 0, 0)
> nelder_mead(fphv, x0)                    #  1 0 0
$xmin
[1] 1.000050e+00 7.717336e-05 9.456440e-05

$fmin
[1] 9.124543e-08

$count
[1] 187

$info
$info$solver
[1] "Nelder-Mead"

$info$restarts
[1] 0


> 
> # Powell's Singular Function (PSF)
> psf <- function(x)  (x[1] + 10*x[2])^2 + 5*(x[3] - x[4])^2 + 
+                     (x[2] - 2*x[3])^4 + 10*(x[1] - x[4])^4
> x0 <- c(3, -1, 0, 1)
> # needs maximum number of function calls
> nelder_mead(psf, x0, maxfeval=30000)         #  0 0 0 0
$xmin
[1] -2.435467e-05  2.435156e-06 -1.169431e-06 -1.168587e-06

$fmin
[1] 1.611798e-17

$count
[1] 525

$info
$info$solver
[1] "Nelder-Mead"

$info$restarts
[1] 0


> 
> ## Not run: 
> ##D # Can run Rosenbrock's function in 30 dimensions in one and a half minutes:
> ##D nelder_mead(fnRosenbrock, rep(0, 30), tol=1e-20, maxfeval=10^7)
> ##D # $xmin
> ##D #  [1]  0.9999998 1.0000004 1.0000000 1.0000001 1.0000000 1.0000001
> ##D #  [7]  1.0000002 1.0000001 0.9999997 0.9999999 0.9999997 1.0000000
> ##D # [13]  0.9999999 0.9999994 0.9999998 0.9999999 0.9999999 0.9999999
> ##D # [19]  0.9999999 1.0000001 0.9999998 1.0000000 1.0000003 0.9999999
> ##D # [25]  1.0000000 0.9999996 0.9999995 0.9999990 0.9999973 0.9999947
> ##D # $fmin
> ##D # [1] 5.617352e-10
> ##D # $fcount
> ##D # [1] 1426085
> ##D # elapsed time is 96.008000 seconds 
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("neville")
> ### * neville
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: neville
> ### Title: Neville's Method
> ### Aliases: neville
> ### Keywords: math
> 
> ### ** Examples
> 
> p <- Poly(c(1, 2, 3))
> fp <- function(x) polyval(p, x)
> 
> x <- 0:4; y <- fp(x)
> xx <- linspace(0, 4, 51)
> yy <- numeric(51)
> for (i in 1:51) yy[i] <- neville(x, y, xx[i])
> 
> ## Not run: 
> ##D ezplot(fp, 0, 4)
> ##D points(xx, yy)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("newmark")
> ### * newmark
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: newmark
> ### Title: Newmark Method
> ### Aliases: newmark
> ### Keywords: ode
> 
> ### ** Examples
> 
> # Mathematical pendulum  m l y'' + m g sin(y) = 0
> pendel <- function(t, y)  -sin(y[1])
> sol <- newmark(pendel, 0, 4*pi, c(pi/4, 0))
> 
> ## Not run: 
> ##D plot(sol$t, sol$y[, 1], type="l", col="blue",
> ##D      xlab="Time", ylab="Elongation/Speed", main="Mathematical Pendulum")
> ##D lines(sol$t, sol$y[, 2], col="darkgreen")
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("newtonHorner")
> ### * newtonHorner
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: newtonHorner
> ### Title: Newton's Root Finding Method for Polynomials.
> ### Aliases: newtonHorner
> ### Keywords: math
> 
> ### ** Examples
> 
> ##  Example: x^3 - 6 x^2 + 11 x - 6  with roots 1, 2, 3
> p <- c(1, -6, 11, -6)
> x0 <- 0
> while (length(p) > 1) {
+     N <- newtonHorner(p, x0)
+     if (!is.null(N$root)) {
+         cat("x0 =", N$root, "\n")
+         p <- N$deflate
+     } else {
+         break
+     }
+ }
x0 = 1 
x0 = 2 
x0 = 3 
> ##  Try: p <- Poly(c(1:20))
> 
> 
> 
> cleanEx()
> nameEx("newtonInterp")
> ### * newtonInterp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: newtonInterp
> ### Title: Lagrange and Newtons Interpolation
> ### Aliases: newtonInterp lagrangeInterp
> ### Keywords: math
> 
> ### ** Examples
> 
> p <- Poly(c(1, 2, 3))
> fp <- function(x) polyval(p, x)
> 
> x <- 0:4; y <- fp(x)
> xx <- linspace(0, 4, 51)
> yy <- lagrangeInterp(x, y, xx)
> yy <- newtonInterp(x, y, xx)
> ## Not run: 
> ##D ezplot(fp, 0, 4)
> ##D points(xx, yy)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("newtonRaphson")
> ### * newtonRaphson
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: newtonRaphson
> ### Title: Rootfinding through Newton-Raphson or Secant.
> ### Aliases: newtonRaphson newton
> ### Keywords: math
> 
> ### ** Examples
> 
> # Legendre polynomial of degree 5
> lp5 <- c(63, 0, -70, 0, 15, 0)/8
> f <- function(x) polyval(lp5, x)
> newton(f, 1.0)         # 0.9061798459 correct to 10 decimals in 5 iterations
$root
[1] 0.9061798

$f.root
[1] 6.661338e-16

$niter
[1] 6

$estim.prec
[1] 6.78706e-16

> 
> 
> 
> cleanEx()
> nameEx("newtonsys")
> ### * newtonsys
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: newtonsys
> ### Title: Newton Method for Nonlinear Systems
> ### Aliases: newtonsys
> ### Keywords: math
> 
> ### ** Examples
> 
> ##  Example from Quarteroni & Saleri
> F1 <- function(x) c(x[1]^2 + x[2]^2 - 1, sin(pi*x[1]/2) + x[2]^3)
> newtonsys(F1, x0 = c(1, 1))  # zero: 0.4760958 -0.8793934
$zero
[1]  0.4760958 -0.8793934

$fnorm
[1] 1.110223e-16

$niter
[1] 9

> 
> ##  Find the roots of the complex function sin(z)^2 + sqrt(z) - log(z)
> F2 <- function(x) {
+     z  <- x[1] + x[2]*1i
+     fz <- sin(z)^2 + sqrt(z) - log(z)
+     c(Re(fz), Im(fz))
+ }
> newtonsys(F2, c(1, 1))
$zero
[1] 0.2555197 0.8948303

$fnorm
[1] 5.721958e-16

$niter
[1] 8

> # $zero   0.2555197 0.8948303 , i.e.  z0 = 0.2555 + 0.8948i
> # $fnorm  2.220446e-16
> # $niter  8
> 
> ##  Two more problematic examples
> F3 <- function(x)
+         c(2*x[1] - x[2] - exp(-x[1]), -x[1] + 2*x[2] - exp(-x[2]))
> newtonsys(F3, c(0, 0))
$zero
[1] 0.5671433 0.5671433

$fnorm
[1] 1.570092e-16

$niter
[1] 5

> # $zero   0.5671433 0.5671433
> # $fnorm  0
> # $niter  4
> 
> ## Not run: 
> ##D F4 <- function(x)  # Dennis Schnabel
> ##D         c(x[1]^2 + x[2]^2 - 2, exp(x[1] - 1) + x[2]^3 - 2)
> ##D newtonsys(F4, c(2.0, 0.5))
> ##D # will result in an error ``missing value in  ... err<tol && niter<maxiter''
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("nextpow2")
> ### * nextpow2
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nextpow2
> ### Title: Next Power of 2
> ### Aliases: nextpow2
> ### Keywords: arith
> 
> ### ** Examples
> 
>   nextpow2(10)                   #=> 4
[1] 4
>   nextpow2(1:10)                 #=> 0 1 2 2 3 3 3 3 4 4
 [1] 0 1 2 2 3 3 3 3 4 4
>   nextpow2(-2^10)                #=> 10
[1] 10
>   nextpow2(.Machine$double.eps)  #=> -52
[1] -52
> 
> 
> 
> cleanEx()
> nameEx("nnz")
> ### * nnz
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nnz
> ### Title: Nonzero Elements
> ### Aliases: nnz
> ### Keywords: array
> 
> ### ** Examples
> 
> nnz(diag(10))
[1] 10
> 
> 
> 
> cleanEx()
> nameEx("norm")
> ### * norm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Norm
> ### Title: Vector Norm
> ### Aliases: Norm
> ### Keywords: array
> 
> ### ** Examples
> 
> Norm(c(3, 4))          #=> 5  Pythagoras triple
[1] 5
> Norm(c(1, 1, 1), p=2)  #   sqrt(3)
[1] 1.732051
> Norm(1:10, p = 1)      #   sum(1:10)
[1] 55
> Norm(1:10, p = 0)      #   Inf
[1] Inf
> Norm(1:10, p = Inf)    #   max(1:10)
[1] 10
> Norm(1:10, p = -Inf)   #   min(1:10)
[1] 1
> 
> 
> 
> cleanEx()
> nameEx("normest")
> ### * normest
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: normest
> ### Title: Estimated Matrix Norm
> ### Aliases: normest
> ### Keywords: array
> 
> ### ** Examples
> 
> normest(magic(5)) == max(svd(magic(5))$d)  # TRUE
[1] FALSE
> normest(magic(100))                        # 500050
[1] 500050
> 
> 
> 
> cleanEx()
> nameEx("nthroot")
> ### * nthroot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nthroot
> ### Title: Real nth Root
> ### Aliases: nthroot
> ### Keywords: arith
> 
> ### ** Examples
> 
>   nthroot(c(1, -2, 3), 3)  #=> 1.000000 -1.259921  1.442250
[1]  1.000000 -1.259921  1.442250
>   (-2)^(1/3)               #=> NaN
[1] NaN
> 
> 
> 
> cleanEx()
> nameEx("nullspace")
> ### * nullspace
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nullspace
> ### Title: Kernel or Nullspace
> ### Aliases: nullspace null
> ### Keywords: array
> 
> ### ** Examples
> 
> M <- matrix(1:12, 3, 4)
> Rank(M)                 #=> 2
[1] 2
> N <- nullspace(M)
> #           [,1]       [,2]      [,3]
> # [1,] 0.4082483 -0.8164966 0.4082483
> M 
     [,1] [,2] [,3] [,4]
[1,]    1    4    7   10
[2,]    2    5    8   11
[3,]    3    6    9   12
> 
> M1 <- matrix(1:6, 2, 3)  # of rank 2
> M2 <- t(M1)
> nullspace(M1)            # corresponds to 1 -2  1
           [,1]
[1,]  0.4082483
[2,] -0.8164966
[3,]  0.4082483
> nullspace(M2)            # NULL, i.e. 0 0
NULL
> 
> M <- magic(5)
> Rank(M)                 #=> 5
[1] 5
> nullspace(M)             #=> NULL, i.e. 0 0 0 0 0
NULL
> 
> 
> 
> cleanEx()
> nameEx("numderiv")
> ### * numderiv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: numderiv
> ### Title: Richardson's Numerical Derivative
> ### Aliases: numderiv numdiff
> ### Keywords: math
> 
> ### ** Examples
> 
> # Differentiate an anti-derivative function
> f <- function(x) sin(x)*sqrt(1+sin(x))
> F <- function(x)
+         integrate(f, 0, x, rel.tol = 1e-12)$value
> x0 <- 1
> dF0 <- numderiv(F, x0, tol = 6.5e-15)   #=> 1.141882942715462
> f(x0)                                   #   1.141882942715464 true value
[1] 1.141883
> # fderiv(F, x0)                         #   1.141882942704476
> # numDeriv::grad(F, x0)                 #   1.141882942705797
> 
> # Compare over a whole period
> x <- seq(0, 2*pi, length.out = 11)
> max(abs(numdiff(sin, x) - cos(x)))          #=> 3.44e-15
[1] 1.887379e-15
> # max(abs(numDeriv::grad(sin, x) - cos(x))) #   7.70e-12
> 
> # Example from complex step
> f <- function(x) exp(x) / sqrt(sin(x)^3 + cos(x)^3)
> x0 <- 1.5
> numderiv(f, x0)                          #   4.05342789389876, error 0.5e-12
$df
[1] 4.053428

$rel.err
[1] 2.037796e-14

$niter
[1] 8

>                                          #   4.053427893898621... true value
> 
> 
> 
> cleanEx()
> nameEx("numel")
> ### * numel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: numel
> ### Title: Number of Elements
> ### Aliases: numel
> ### Keywords: array
> 
> ### ** Examples
> 
> numel(c(1:12))
[1] 12
> numel(matrix(1:12, 3, 4))
[1] 12
> 
> 
> 
> cleanEx()
> nameEx("ode")
> ### * ode
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ode23
> ### Title: Non-stiff (and stiff) ODE solvers
> ### Aliases: ode23 ode23s ode45 ode78
> ### Keywords: ode
> 
> ### ** Examples
> 
> ##  Example1: Three-body problem
> f <- function(t, y)
+ 		as.matrix(c(y[2]*y[3], -y[1]*y[3], 0.51*y[1]*y[2]))
> y0 <- as.matrix(c(0, 1, 1))
> t0 <- 0; tf <- 20
> sol <- ode23(f, t0, tf, y0, rtol=1e-5, atol=1e-10)
> ## Not run: 
> ##D matplot(sol$t, sol$y, type = "l", lty = 1, lwd = c(2, 1, 1),
> ##D         col = c("darkred", "darkblue", "darkgreen"),
> ##D         xlab = "Time [min]", ylab= "",
> ##D         main = "Three-body Problem")
> ##D grid()
> ## End(Not run)
> 
> ##  Example2: Van der Pol Equation
> #   x'' + (x^2 - 1) x' + x = 0
> f <- function(t, x)
+         as.matrix(c(x[1] * (1 - x[2]^2) -x[2], x[1]))
> t0 <- 0; tf <- 20
> x0 <- as.matrix(c(0, 0.25))
> sol <- ode23(f, t0, tf, x0)
> ## Not run: 
> ##D plot(c(0, 20), c(-3, 3), type = "n",
> ##D      xlab = "Time", ylab = "", main = "Van der Pol Equation")
> ##D lines(sol$t, sol$y[, 1], col = "blue")
> ##D lines(sol$t, sol$y[, 2], col = "darkgreen")
> ##D grid()
> ## End(Not run)
> 
> ##  Example3: Van der Pol as stiff equation
> vdP  <- function(t,y) as.matrix(c(y[2], 10*(1-y[1]^2)*y[2]-y[1]))
> ajax <- function(t, y)
+             matrix(c(0, 1, -20*y[1]*y[2]-1, 10*(1-y[1]^2)), 2,2, byrow = TRUE)
> sol <- ode23s(vdP, t0, tf, c(2, 0), jac = ajax, hmax = 1.0)
> ## Not run: 
> ##D plot(sol$t, sol$y[, 1], col = "blue")
> ##D lines(sol$t, sol$y[, 1], col = "blue")
> ##D lines(sol$t, sol$y[, 2]/8, col = "red", lwd = 2)
> ##D grid()
> ## End(Not run)
> 
> ##  Example4: pendulum
> m = 1.0;  l = 1.0   # [kg] resp. [m]
> g = 9.81; b = 0.7   # [m/s^2] resp. [N s/m]
> fp = function(t, x)
+         c( x[2] , 1/(1/3*m*l^2)*(-b*x[2]-m*g*l/2*sin(x[1])) )
> t0 <- 0.0; tf <- 5.0; hmax = 0.1
> y0 = c(30*pi/180, 0.0)
> sol = ode45(fp, t0, tf, y0, hmax = 0.1)
> ## Not run: 
> ##D matplot(sol$t, sol$y, type = "l", lty = 1)
> ##D grid()
> ## End(Not run)
> 
> ##  Example: enforced pendulum
> g <- 9.81
> L <- 1.0; Y <- 0.25; w <- 2.5
> f <- function(t, y) {
+     as.matrix(c(y[2], -g/L * sin(y[1]) + w^2/L * Y * cos(y[1]) * sin(w*t)))
+ }
> y0 <- as.matrix(c(0, 0))
> sol <- ode78(f, 0.0, 60.0, y0, hmax = 0.05)
> ## Not run: 
> ##D plot(sol$t, sol$y[, 1], type="l", col="blue")
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("odregress")
> ### * odregress
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: odregress
> ### Title: Orthogonal Distance Regression
> ### Aliases: odregress
> ### Keywords: fitting
> 
> ### ** Examples
> 
> # Example in one dimension
> x <- c(1.0, 0.6, 1.2, 1.4, 0.2)
> y <- c(0.5, 0.3, 0.7, 1.0, 0.2)
> odr <- odregress(x, y)
> ( cc <- odr$coeff )
[1]  0.65145762 -0.03328271
> # [1]  0.65145762 -0.03328271
> lm(y ~ x)

Call:
lm(formula = y ~ x)

Coefficients:
(Intercept)            x  
   -0.01379      0.62931  

> # Coefficients:
> # (Intercept)            x 
> #    -0.01379      0.62931 
> 
> # Prediction
> xnew <- seq(0, 1.5, by = 0.25)
> ( ynew <- cbind(xnew, 1) %*% cc )
            [,1]
[1,] -0.03328271
[2,]  0.12958170
[3,]  0.29244610
[4,]  0.45531051
[5,]  0.61817491
[6,]  0.78103932
[7,]  0.94390373
> 
> ## Not run: 
> ##D plot(x, y, xlim=c(0, 1.5), ylim=c(0, 1.2), main="Orthogonal Regression")
> ##D abline(lm(y ~ x), col="blue")
> ##D lines(c(0, 1.5), cc[1]*c(0, 1.5) + cc[2], col="red")
> ##D points(xnew, ynew, col = "red")
> ##D grid()
> ## End(Not run)
> 
> # Example in two dimensions
> x <- cbind(c(0.92, 0.89, 0.85, 0.05, 0.62, 0.55, 0.02, 0.73, 0.77, 0.57),
+            c(0.66, 0.47, 0.40, 0.23, 0.17, 0.09, 0.92, 0.06, 0.09, 0.60))
> y <- x %*% c(0.5, 1.5) + 1
> odr <- odregress(x, y); odr
$coeff
[1] 0.5 1.5 1.0

$ssq
[1] 9.109649e-32

$err
              [,1]
 [1,] 0.000000e+00
 [2,] 8.326673e-17
 [3,] 9.714451e-17
 [4,] 0.000000e+00
 [5,] 1.110223e-16
 [6,] 0.000000e+00
 [7,] 5.551115e-17
 [8,] 5.551115e-17
 [9,] 8.326673e-17
[10,] 2.220446e-16

$fitted
       [,1]
 [1,] 2.450
 [2,] 2.150
 [3,] 2.025
 [4,] 1.370
 [5,] 1.565
 [6,] 1.410
 [7,] 2.390
 [8,] 1.455
 [9,] 1.520
[10,] 2.185

$resid
              [,1]
 [1,] 0.000000e+00
 [2,] 0.000000e+00
 [3,] 0.000000e+00
 [4,] 0.000000e+00
 [5,] 0.000000e+00
 [6,] 0.000000e+00
 [7,] 4.440892e-16
 [8,] 0.000000e+00
 [9,] 0.000000e+00
[10,] 0.000000e+00

$normal
[1]  0.2672612  0.8017837 -0.5345225

> # $coeff
> # [1] 0.5 1.5 1.0
> # $ssq
> # [1] 1.473336e-31
> 
> y <- y + rep(c(0.1, -0.1), 5)
> odr <- odregress(x, y); odr
$coeff
[1] 0.5921823 1.6750269 0.8803822

$ssq
[1] 0.02168174

$err
             [,1]
 [1,] 0.009462925
 [2,] 0.070969459
 [3,] 0.034949336
 [4,] 0.012383994
 [5,] 0.065094720
 [6,] 0.022972669
 [7,] 0.027835729
 [8,] 0.028535956
 [9,] 0.065180464
[10,] 0.067661096

$fitted
          [,1]
 [1,] 2.530708
 [2,] 2.194687
 [3,] 2.053748
 [4,] 1.295248
 [5,] 1.532290
 [6,] 1.356835
 [7,] 2.433251
 [8,] 1.413177
 [9,] 1.487115
[10,] 2.222942

$resid
             [,1]
 [1,]  0.01929229
 [2,] -0.14468713
 [3,]  0.07125205
 [4,] -0.02524754
 [5,]  0.13271016
 [6,] -0.04683493
 [7,]  0.05674936
 [8,] -0.05817693
 [9,]  0.13288497
[10,] -0.13794229

$normal
[1]  0.2904671  0.8216056 -0.4905029

> # $coeff
> # [1] 0.5921823 1.6750269 0.8803822
> # $ssq
> # [1] 0.02168174
> 
> lm(y ~ x)

Call:
lm(formula = y ~ x)

Coefficients:
(Intercept)           x1           x2  
     0.9153       0.5671       1.6209  

> # Coefficients:
> # (Intercept)           x1           x2  
> #      0.9153       0.5671       1.6209  
> 
> 
> 
> cleanEx()
> nameEx("orth")
> ### * orth
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: orth
> ### Title: Range Space
> ### Aliases: orth
> ### Keywords: array
> 
> ### ** Examples
> 
> M <- matrix(1:12, 3, 4)
> Rank(M)                 #=> 2
[1] 2
> orth(M)
          [,1]        [,2]
[1,] 0.5045331  0.76077568
[2,] 0.5745157  0.05714052
[3,] 0.6444983 -0.64649464
> 
> 
> 
> cleanEx()
> nameEx("pade")
> ### * pade
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pade
> ### Title: Pade Approximation
> ### Aliases: pade
> ### Keywords: math
> 
> ### ** Examples
> 
> ##  Exponential function
> p1 <- c(1/24, 1/6, 1/2, 1.0, 1.0)  # Taylor series of exp(x) at x=0
> R  <- pade(p1); r1 <- R$r1; r2 <- R$r2
> f1 <- function(x) polyval(r1, x) / polyval(r2, x)
> ## Not run: 
> ##D xs <- seq(-1, 1, length.out=51); ys1 <- exp(xs); ys2 <- f1(xs)
> ##D plot(xs, ys1, type = "l", col="blue")
> ##D lines(xs, ys2, col = "red")
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("pascal")
> ### * pascal
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pascal
> ### Title: Pascal Triangle
> ### Aliases: pascal
> ### Keywords: specmat
> 
> ### ** Examples
> 
> pascal(5)
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    1    1    1    1
[2,]    1    2    3    4    5
[3,]    1    3    6   10   15
[4,]    1    4   10   20   35
[5,]    1    5   15   35   70
> pascal(5, 1)
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    0    0    0    0
[2,]    1   -1    0    0    0
[3,]    1   -2    1    0    0
[4,]    1   -3    3   -1    0
[5,]    1   -4    6   -4    1
> pascal(5, 2)
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    1    1    1    1
[2,]   -4   -3   -2   -1    0
[3,]    6    3    1    0    0
[4,]   -4   -1    0    0    0
[5,]    1    0    0    0    0
> 
> 
> 
> cleanEx()
> nameEx("pchip")
> ### * pchip
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pchip
> ### Title: Hermitean Interpolation Polynomials
> ### Aliases: pchip pchipfun
> ### Keywords: math
> 
> ### ** Examples
> 
> x <- c(1, 2, 3, 4, 5, 6)
> y <- c(16, 18, 21, 17, 15, 12)
> pchip(x, y, seq(1, 6, by = 0.5))
 [1] 16.00000 16.88750 18.00000 19.80000 21.00000 19.33333 17.00000 15.96667
 [9] 15.00000 13.63750 12.00000
> fp <- pchipfun(x, y)
> fp(seq(1, 6, by = 0.5))
 [1] 16.00000 16.88750 18.00000 19.80000 21.00000 19.33333 17.00000 15.96667
 [9] 15.00000 13.63750 12.00000
> 
> ## Not run: 
> ##D plot(x, y, col="red", xlim=c(0,7), ylim=c(10,22),
> ##D      main = "Spline and 'pchip' Interpolation")
> ##D grid()
> ##D 
> ##D xs <- seq(1, 6, len=51)
> ##D ys <- interp1(x, y, xs, "spline")
> ##D lines(xs, ys, col="cyan")
> ##D yp <- pchip(x, y, xs)
> ##D lines(xs, yp, col = "magenta")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("peaks")
> ### * peaks
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: peaks
> ### Title: Peaks Function (Matlab Style)
> ### Aliases: peaks
> ### Keywords: graphs
> 
> ### ** Examples
> 
> peaks(3)
$X
     [,1] [,2] [,3]
[1,]   -3    0    3
[2,]   -3    0    3
[3,]   -3    0    3

$Y
     [,1] [,2] [,3]
[1,]   -3   -3   -3
[2,]    0    0    0
[3,]    3    3    3

$Z
              [,1]       [,2]          [,3]
[1,]  6.671280e-05 -0.2449540 -5.864188e-06
[2,] -3.650620e-02  0.9810118  3.312495e-02
[3,]  3.223536e-05  0.2998710  4.102973e-05

> ## Not run: 
> ##D P <- peaks()
> ##D x <- P$X[1,]; y <- P$Y[, 1]
> ##D persp(x, y, P$Z)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("perms")
> ### * perms
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: perms
> ### Title: Generate Permutations
> ### Aliases: perms
> ### Keywords: arith
> 
> ### ** Examples
> 
> perms(6)
     [,1]
[1,]    6
> perms(1:6)
       [,1] [,2] [,3] [,4] [,5] [,6]
  [1,]    6    5    4    3    2    1
  [2,]    6    5    4    3    1    2
  [3,]    6    5    4    2    3    1
  [4,]    6    5    4    2    1    3
  [5,]    6    5    4    1    2    3
  [6,]    6    5    4    1    3    2
  [7,]    6    5    3    4    2    1
  [8,]    6    5    3    4    1    2
  [9,]    6    5    3    2    4    1
 [10,]    6    5    3    2    1    4
 [11,]    6    5    3    1    2    4
 [12,]    6    5    3    1    4    2
 [13,]    6    5    2    3    4    1
 [14,]    6    5    2    3    1    4
 [15,]    6    5    2    4    3    1
 [16,]    6    5    2    4    1    3
 [17,]    6    5    2    1    4    3
 [18,]    6    5    2    1    3    4
 [19,]    6    5    1    3    2    4
 [20,]    6    5    1    3    4    2
 [21,]    6    5    1    2    3    4
 [22,]    6    5    1    2    4    3
 [23,]    6    5    1    4    2    3
 [24,]    6    5    1    4    3    2
 [25,]    6    4    5    3    2    1
 [26,]    6    4    5    3    1    2
 [27,]    6    4    5    2    3    1
 [28,]    6    4    5    2    1    3
 [29,]    6    4    5    1    2    3
 [30,]    6    4    5    1    3    2
 [31,]    6    4    3    5    2    1
 [32,]    6    4    3    5    1    2
 [33,]    6    4    3    2    5    1
 [34,]    6    4    3    2    1    5
 [35,]    6    4    3    1    2    5
 [36,]    6    4    3    1    5    2
 [37,]    6    4    2    3    5    1
 [38,]    6    4    2    3    1    5
 [39,]    6    4    2    5    3    1
 [40,]    6    4    2    5    1    3
 [41,]    6    4    2    1    5    3
 [42,]    6    4    2    1    3    5
 [43,]    6    4    1    3    2    5
 [44,]    6    4    1    3    5    2
 [45,]    6    4    1    2    3    5
 [46,]    6    4    1    2    5    3
 [47,]    6    4    1    5    2    3
 [48,]    6    4    1    5    3    2
 [49,]    6    3    4    5    2    1
 [50,]    6    3    4    5    1    2
 [51,]    6    3    4    2    5    1
 [52,]    6    3    4    2    1    5
 [53,]    6    3    4    1    2    5
 [54,]    6    3    4    1    5    2
 [55,]    6    3    5    4    2    1
 [56,]    6    3    5    4    1    2
 [57,]    6    3    5    2    4    1
 [58,]    6    3    5    2    1    4
 [59,]    6    3    5    1    2    4
 [60,]    6    3    5    1    4    2
 [61,]    6    3    2    5    4    1
 [62,]    6    3    2    5    1    4
 [63,]    6    3    2    4    5    1
 [64,]    6    3    2    4    1    5
 [65,]    6    3    2    1    4    5
 [66,]    6    3    2    1    5    4
 [67,]    6    3    1    5    2    4
 [68,]    6    3    1    5    4    2
 [69,]    6    3    1    2    5    4
 [70,]    6    3    1    2    4    5
 [71,]    6    3    1    4    2    5
 [72,]    6    3    1    4    5    2
 [73,]    6    2    4    3    5    1
 [74,]    6    2    4    3    1    5
 [75,]    6    2    4    5    3    1
 [76,]    6    2    4    5    1    3
 [77,]    6    2    4    1    5    3
 [78,]    6    2    4    1    3    5
 [79,]    6    2    3    4    5    1
 [80,]    6    2    3    4    1    5
 [81,]    6    2    3    5    4    1
 [82,]    6    2    3    5    1    4
 [83,]    6    2    3    1    5    4
 [84,]    6    2    3    1    4    5
 [85,]    6    2    5    3    4    1
 [86,]    6    2    5    3    1    4
 [87,]    6    2    5    4    3    1
 [88,]    6    2    5    4    1    3
 [89,]    6    2    5    1    4    3
 [90,]    6    2    5    1    3    4
 [91,]    6    2    1    3    5    4
 [92,]    6    2    1    3    4    5
 [93,]    6    2    1    5    3    4
 [94,]    6    2    1    5    4    3
 [95,]    6    2    1    4    5    3
 [96,]    6    2    1    4    3    5
 [97,]    6    1    4    3    2    5
 [98,]    6    1    4    3    5    2
 [99,]    6    1    4    2    3    5
[100,]    6    1    4    2    5    3
[101,]    6    1    4    5    2    3
[102,]    6    1    4    5    3    2
[103,]    6    1    3    4    2    5
[104,]    6    1    3    4    5    2
[105,]    6    1    3    2    4    5
[106,]    6    1    3    2    5    4
[107,]    6    1    3    5    2    4
[108,]    6    1    3    5    4    2
[109,]    6    1    2    3    4    5
[110,]    6    1    2    3    5    4
[111,]    6    1    2    4    3    5
[112,]    6    1    2    4    5    3
[113,]    6    1    2    5    4    3
[114,]    6    1    2    5    3    4
[115,]    6    1    5    3    2    4
[116,]    6    1    5    3    4    2
[117,]    6    1    5    2    3    4
[118,]    6    1    5    2    4    3
[119,]    6    1    5    4    2    3
[120,]    6    1    5    4    3    2
[121,]    5    6    4    3    2    1
[122,]    5    6    4    3    1    2
[123,]    5    6    4    2    3    1
[124,]    5    6    4    2    1    3
[125,]    5    6    4    1    2    3
[126,]    5    6    4    1    3    2
[127,]    5    6    3    4    2    1
[128,]    5    6    3    4    1    2
[129,]    5    6    3    2    4    1
[130,]    5    6    3    2    1    4
[131,]    5    6    3    1    2    4
[132,]    5    6    3    1    4    2
[133,]    5    6    2    3    4    1
[134,]    5    6    2    3    1    4
[135,]    5    6    2    4    3    1
[136,]    5    6    2    4    1    3
[137,]    5    6    2    1    4    3
[138,]    5    6    2    1    3    4
[139,]    5    6    1    3    2    4
[140,]    5    6    1    3    4    2
[141,]    5    6    1    2    3    4
[142,]    5    6    1    2    4    3
[143,]    5    6    1    4    2    3
[144,]    5    6    1    4    3    2
[145,]    5    4    6    3    2    1
[146,]    5    4    6    3    1    2
[147,]    5    4    6    2    3    1
[148,]    5    4    6    2    1    3
[149,]    5    4    6    1    2    3
[150,]    5    4    6    1    3    2
[151,]    5    4    3    6    2    1
[152,]    5    4    3    6    1    2
[153,]    5    4    3    2    6    1
[154,]    5    4    3    2    1    6
[155,]    5    4    3    1    2    6
[156,]    5    4    3    1    6    2
[157,]    5    4    2    3    6    1
[158,]    5    4    2    3    1    6
[159,]    5    4    2    6    3    1
[160,]    5    4    2    6    1    3
[161,]    5    4    2    1    6    3
[162,]    5    4    2    1    3    6
[163,]    5    4    1    3    2    6
[164,]    5    4    1    3    6    2
[165,]    5    4    1    2    3    6
[166,]    5    4    1    2    6    3
[167,]    5    4    1    6    2    3
[168,]    5    4    1    6    3    2
[169,]    5    3    4    6    2    1
[170,]    5    3    4    6    1    2
[171,]    5    3    4    2    6    1
[172,]    5    3    4    2    1    6
[173,]    5    3    4    1    2    6
[174,]    5    3    4    1    6    2
[175,]    5    3    6    4    2    1
[176,]    5    3    6    4    1    2
[177,]    5    3    6    2    4    1
[178,]    5    3    6    2    1    4
[179,]    5    3    6    1    2    4
[180,]    5    3    6    1    4    2
[181,]    5    3    2    6    4    1
[182,]    5    3    2    6    1    4
[183,]    5    3    2    4    6    1
[184,]    5    3    2    4    1    6
[185,]    5    3    2    1    4    6
[186,]    5    3    2    1    6    4
[187,]    5    3    1    6    2    4
[188,]    5    3    1    6    4    2
[189,]    5    3    1    2    6    4
[190,]    5    3    1    2    4    6
[191,]    5    3    1    4    2    6
[192,]    5    3    1    4    6    2
[193,]    5    2    4    3    6    1
[194,]    5    2    4    3    1    6
[195,]    5    2    4    6    3    1
[196,]    5    2    4    6    1    3
[197,]    5    2    4    1    6    3
[198,]    5    2    4    1    3    6
[199,]    5    2    3    4    6    1
[200,]    5    2    3    4    1    6
[201,]    5    2    3    6    4    1
[202,]    5    2    3    6    1    4
[203,]    5    2    3    1    6    4
[204,]    5    2    3    1    4    6
[205,]    5    2    6    3    4    1
[206,]    5    2    6    3    1    4
[207,]    5    2    6    4    3    1
[208,]    5    2    6    4    1    3
[209,]    5    2    6    1    4    3
[210,]    5    2    6    1    3    4
[211,]    5    2    1    3    6    4
[212,]    5    2    1    3    4    6
[213,]    5    2    1    6    3    4
[214,]    5    2    1    6    4    3
[215,]    5    2    1    4    6    3
[216,]    5    2    1    4    3    6
[217,]    5    1    4    3    2    6
[218,]    5    1    4    3    6    2
[219,]    5    1    4    2    3    6
[220,]    5    1    4    2    6    3
[221,]    5    1    4    6    2    3
[222,]    5    1    4    6    3    2
[223,]    5    1    3    4    2    6
[224,]    5    1    3    4    6    2
[225,]    5    1    3    2    4    6
[226,]    5    1    3    2    6    4
[227,]    5    1    3    6    2    4
[228,]    5    1    3    6    4    2
[229,]    5    1    2    3    4    6
[230,]    5    1    2    3    6    4
[231,]    5    1    2    4    3    6
[232,]    5    1    2    4    6    3
[233,]    5    1    2    6    4    3
[234,]    5    1    2    6    3    4
[235,]    5    1    6    3    2    4
[236,]    5    1    6    3    4    2
[237,]    5    1    6    2    3    4
[238,]    5    1    6    2    4    3
[239,]    5    1    6    4    2    3
[240,]    5    1    6    4    3    2
[241,]    4    5    6    3    2    1
[242,]    4    5    6    3    1    2
[243,]    4    5    6    2    3    1
[244,]    4    5    6    2    1    3
[245,]    4    5    6    1    2    3
[246,]    4    5    6    1    3    2
[247,]    4    5    3    6    2    1
[248,]    4    5    3    6    1    2
[249,]    4    5    3    2    6    1
[250,]    4    5    3    2    1    6
[251,]    4    5    3    1    2    6
[252,]    4    5    3    1    6    2
[253,]    4    5    2    3    6    1
[254,]    4    5    2    3    1    6
[255,]    4    5    2    6    3    1
[256,]    4    5    2    6    1    3
[257,]    4    5    2    1    6    3
[258,]    4    5    2    1    3    6
[259,]    4    5    1    3    2    6
[260,]    4    5    1    3    6    2
[261,]    4    5    1    2    3    6
[262,]    4    5    1    2    6    3
[263,]    4    5    1    6    2    3
[264,]    4    5    1    6    3    2
[265,]    4    6    5    3    2    1
[266,]    4    6    5    3    1    2
[267,]    4    6    5    2    3    1
[268,]    4    6    5    2    1    3
[269,]    4    6    5    1    2    3
[270,]    4    6    5    1    3    2
[271,]    4    6    3    5    2    1
[272,]    4    6    3    5    1    2
[273,]    4    6    3    2    5    1
[274,]    4    6    3    2    1    5
[275,]    4    6    3    1    2    5
[276,]    4    6    3    1    5    2
[277,]    4    6    2    3    5    1
[278,]    4    6    2    3    1    5
[279,]    4    6    2    5    3    1
[280,]    4    6    2    5    1    3
[281,]    4    6    2    1    5    3
[282,]    4    6    2    1    3    5
[283,]    4    6    1    3    2    5
[284,]    4    6    1    3    5    2
[285,]    4    6    1    2    3    5
[286,]    4    6    1    2    5    3
[287,]    4    6    1    5    2    3
[288,]    4    6    1    5    3    2
[289,]    4    3    6    5    2    1
[290,]    4    3    6    5    1    2
[291,]    4    3    6    2    5    1
[292,]    4    3    6    2    1    5
[293,]    4    3    6    1    2    5
[294,]    4    3    6    1    5    2
[295,]    4    3    5    6    2    1
[296,]    4    3    5    6    1    2
[297,]    4    3    5    2    6    1
[298,]    4    3    5    2    1    6
[299,]    4    3    5    1    2    6
[300,]    4    3    5    1    6    2
[301,]    4    3    2    5    6    1
[302,]    4    3    2    5    1    6
[303,]    4    3    2    6    5    1
[304,]    4    3    2    6    1    5
[305,]    4    3    2    1    6    5
[306,]    4    3    2    1    5    6
[307,]    4    3    1    5    2    6
[308,]    4    3    1    5    6    2
[309,]    4    3    1    2    5    6
[310,]    4    3    1    2    6    5
[311,]    4    3    1    6    2    5
[312,]    4    3    1    6    5    2
[313,]    4    2    6    3    5    1
[314,]    4    2    6    3    1    5
[315,]    4    2    6    5    3    1
[316,]    4    2    6    5    1    3
[317,]    4    2    6    1    5    3
[318,]    4    2    6    1    3    5
[319,]    4    2    3    6    5    1
[320,]    4    2    3    6    1    5
[321,]    4    2    3    5    6    1
[322,]    4    2    3    5    1    6
[323,]    4    2    3    1    5    6
[324,]    4    2    3    1    6    5
[325,]    4    2    5    3    6    1
[326,]    4    2    5    3    1    6
[327,]    4    2    5    6    3    1
[328,]    4    2    5    6    1    3
[329,]    4    2    5    1    6    3
[330,]    4    2    5    1    3    6
[331,]    4    2    1    3    5    6
[332,]    4    2    1    3    6    5
[333,]    4    2    1    5    3    6
[334,]    4    2    1    5    6    3
[335,]    4    2    1    6    5    3
[336,]    4    2    1    6    3    5
[337,]    4    1    6    3    2    5
[338,]    4    1    6    3    5    2
[339,]    4    1    6    2    3    5
[340,]    4    1    6    2    5    3
[341,]    4    1    6    5    2    3
[342,]    4    1    6    5    3    2
[343,]    4    1    3    6    2    5
[344,]    4    1    3    6    5    2
[345,]    4    1    3    2    6    5
[346,]    4    1    3    2    5    6
[347,]    4    1    3    5    2    6
[348,]    4    1    3    5    6    2
[349,]    4    1    2    3    6    5
[350,]    4    1    2    3    5    6
[351,]    4    1    2    6    3    5
[352,]    4    1    2    6    5    3
[353,]    4    1    2    5    6    3
[354,]    4    1    2    5    3    6
[355,]    4    1    5    3    2    6
[356,]    4    1    5    3    6    2
[357,]    4    1    5    2    3    6
[358,]    4    1    5    2    6    3
[359,]    4    1    5    6    2    3
[360,]    4    1    5    6    3    2
[361,]    3    5    4    6    2    1
[362,]    3    5    4    6    1    2
[363,]    3    5    4    2    6    1
[364,]    3    5    4    2    1    6
[365,]    3    5    4    1    2    6
[366,]    3    5    4    1    6    2
[367,]    3    5    6    4    2    1
[368,]    3    5    6    4    1    2
[369,]    3    5    6    2    4    1
[370,]    3    5    6    2    1    4
[371,]    3    5    6    1    2    4
[372,]    3    5    6    1    4    2
[373,]    3    5    2    6    4    1
[374,]    3    5    2    6    1    4
[375,]    3    5    2    4    6    1
[376,]    3    5    2    4    1    6
[377,]    3    5    2    1    4    6
[378,]    3    5    2    1    6    4
[379,]    3    5    1    6    2    4
[380,]    3    5    1    6    4    2
[381,]    3    5    1    2    6    4
[382,]    3    5    1    2    4    6
[383,]    3    5    1    4    2    6
[384,]    3    5    1    4    6    2
[385,]    3    4    5    6    2    1
[386,]    3    4    5    6    1    2
[387,]    3    4    5    2    6    1
[388,]    3    4    5    2    1    6
[389,]    3    4    5    1    2    6
[390,]    3    4    5    1    6    2
[391,]    3    4    6    5    2    1
[392,]    3    4    6    5    1    2
[393,]    3    4    6    2    5    1
[394,]    3    4    6    2    1    5
[395,]    3    4    6    1    2    5
[396,]    3    4    6    1    5    2
[397,]    3    4    2    6    5    1
[398,]    3    4    2    6    1    5
[399,]    3    4    2    5    6    1
[400,]    3    4    2    5    1    6
[401,]    3    4    2    1    5    6
[402,]    3    4    2    1    6    5
[403,]    3    4    1    6    2    5
[404,]    3    4    1    6    5    2
[405,]    3    4    1    2    6    5
[406,]    3    4    1    2    5    6
[407,]    3    4    1    5    2    6
[408,]    3    4    1    5    6    2
[409,]    3    6    4    5    2    1
[410,]    3    6    4    5    1    2
[411,]    3    6    4    2    5    1
[412,]    3    6    4    2    1    5
[413,]    3    6    4    1    2    5
[414,]    3    6    4    1    5    2
[415,]    3    6    5    4    2    1
[416,]    3    6    5    4    1    2
[417,]    3    6    5    2    4    1
[418,]    3    6    5    2    1    4
[419,]    3    6    5    1    2    4
[420,]    3    6    5    1    4    2
[421,]    3    6    2    5    4    1
[422,]    3    6    2    5    1    4
[423,]    3    6    2    4    5    1
[424,]    3    6    2    4    1    5
[425,]    3    6    2    1    4    5
[426,]    3    6    2    1    5    4
[427,]    3    6    1    5    2    4
[428,]    3    6    1    5    4    2
[429,]    3    6    1    2    5    4
[430,]    3    6    1    2    4    5
[431,]    3    6    1    4    2    5
[432,]    3    6    1    4    5    2
[433,]    3    2    4    6    5    1
[434,]    3    2    4    6    1    5
[435,]    3    2    4    5    6    1
[436,]    3    2    4    5    1    6
[437,]    3    2    4    1    5    6
[438,]    3    2    4    1    6    5
[439,]    3    2    6    4    5    1
[440,]    3    2    6    4    1    5
[441,]    3    2    6    5    4    1
[442,]    3    2    6    5    1    4
[443,]    3    2    6    1    5    4
[444,]    3    2    6    1    4    5
[445,]    3    2    5    6    4    1
[446,]    3    2    5    6    1    4
[447,]    3    2    5    4    6    1
[448,]    3    2    5    4    1    6
[449,]    3    2    5    1    4    6
[450,]    3    2    5    1    6    4
[451,]    3    2    1    6    5    4
[452,]    3    2    1    6    4    5
[453,]    3    2    1    5    6    4
[454,]    3    2    1    5    4    6
[455,]    3    2    1    4    5    6
[456,]    3    2    1    4    6    5
[457,]    3    1    4    6    2    5
[458,]    3    1    4    6    5    2
[459,]    3    1    4    2    6    5
[460,]    3    1    4    2    5    6
[461,]    3    1    4    5    2    6
[462,]    3    1    4    5    6    2
[463,]    3    1    6    4    2    5
[464,]    3    1    6    4    5    2
[465,]    3    1    6    2    4    5
[466,]    3    1    6    2    5    4
[467,]    3    1    6    5    2    4
[468,]    3    1    6    5    4    2
[469,]    3    1    2    6    4    5
[470,]    3    1    2    6    5    4
[471,]    3    1    2    4    6    5
[472,]    3    1    2    4    5    6
[473,]    3    1    2    5    4    6
[474,]    3    1    2    5    6    4
[475,]    3    1    5    6    2    4
[476,]    3    1    5    6    4    2
[477,]    3    1    5    2    6    4
[478,]    3    1    5    2    4    6
[479,]    3    1    5    4    2    6
[480,]    3    1    5    4    6    2
[481,]    2    5    4    3    6    1
[482,]    2    5    4    3    1    6
[483,]    2    5    4    6    3    1
[484,]    2    5    4    6    1    3
[485,]    2    5    4    1    6    3
[486,]    2    5    4    1    3    6
[487,]    2    5    3    4    6    1
[488,]    2    5    3    4    1    6
[489,]    2    5    3    6    4    1
[490,]    2    5    3    6    1    4
[491,]    2    5    3    1    6    4
[492,]    2    5    3    1    4    6
[493,]    2    5    6    3    4    1
[494,]    2    5    6    3    1    4
[495,]    2    5    6    4    3    1
[496,]    2    5    6    4    1    3
[497,]    2    5    6    1    4    3
[498,]    2    5    6    1    3    4
[499,]    2    5    1    3    6    4
[500,]    2    5    1    3    4    6
[501,]    2    5    1    6    3    4
[502,]    2    5    1    6    4    3
[503,]    2    5    1    4    6    3
[504,]    2    5    1    4    3    6
[505,]    2    4    5    3    6    1
[506,]    2    4    5    3    1    6
[507,]    2    4    5    6    3    1
[508,]    2    4    5    6    1    3
[509,]    2    4    5    1    6    3
[510,]    2    4    5    1    3    6
[511,]    2    4    3    5    6    1
[512,]    2    4    3    5    1    6
[513,]    2    4    3    6    5    1
[514,]    2    4    3    6    1    5
[515,]    2    4    3    1    6    5
[516,]    2    4    3    1    5    6
[517,]    2    4    6    3    5    1
[518,]    2    4    6    3    1    5
[519,]    2    4    6    5    3    1
[520,]    2    4    6    5    1    3
[521,]    2    4    6    1    5    3
[522,]    2    4    6    1    3    5
[523,]    2    4    1    3    6    5
[524,]    2    4    1    3    5    6
[525,]    2    4    1    6    3    5
[526,]    2    4    1    6    5    3
[527,]    2    4    1    5    6    3
[528,]    2    4    1    5    3    6
[529,]    2    3    4    5    6    1
[530,]    2    3    4    5    1    6
[531,]    2    3    4    6    5    1
[532,]    2    3    4    6    1    5
[533,]    2    3    4    1    6    5
[534,]    2    3    4    1    5    6
[535,]    2    3    5    4    6    1
[536,]    2    3    5    4    1    6
[537,]    2    3    5    6    4    1
[538,]    2    3    5    6    1    4
[539,]    2    3    5    1    6    4
[540,]    2    3    5    1    4    6
[541,]    2    3    6    5    4    1
[542,]    2    3    6    5    1    4
[543,]    2    3    6    4    5    1
[544,]    2    3    6    4    1    5
[545,]    2    3    6    1    4    5
[546,]    2    3    6    1    5    4
[547,]    2    3    1    5    6    4
[548,]    2    3    1    5    4    6
[549,]    2    3    1    6    5    4
[550,]    2    3    1    6    4    5
[551,]    2    3    1    4    6    5
[552,]    2    3    1    4    5    6
[553,]    2    6    4    3    5    1
[554,]    2    6    4    3    1    5
[555,]    2    6    4    5    3    1
[556,]    2    6    4    5    1    3
[557,]    2    6    4    1    5    3
[558,]    2    6    4    1    3    5
[559,]    2    6    3    4    5    1
[560,]    2    6    3    4    1    5
[561,]    2    6    3    5    4    1
[562,]    2    6    3    5    1    4
[563,]    2    6    3    1    5    4
[564,]    2    6    3    1    4    5
[565,]    2    6    5    3    4    1
[566,]    2    6    5    3    1    4
[567,]    2    6    5    4    3    1
[568,]    2    6    5    4    1    3
[569,]    2    6    5    1    4    3
[570,]    2    6    5    1    3    4
[571,]    2    6    1    3    5    4
[572,]    2    6    1    3    4    5
[573,]    2    6    1    5    3    4
[574,]    2    6    1    5    4    3
[575,]    2    6    1    4    5    3
[576,]    2    6    1    4    3    5
[577,]    2    1    4    3    6    5
[578,]    2    1    4    3    5    6
[579,]    2    1    4    6    3    5
[580,]    2    1    4    6    5    3
[581,]    2    1    4    5    6    3
[582,]    2    1    4    5    3    6
[583,]    2    1    3    4    6    5
[584,]    2    1    3    4    5    6
[585,]    2    1    3    6    4    5
[586,]    2    1    3    6    5    4
[587,]    2    1    3    5    6    4
[588,]    2    1    3    5    4    6
[589,]    2    1    6    3    4    5
[590,]    2    1    6    3    5    4
[591,]    2    1    6    4    3    5
[592,]    2    1    6    4    5    3
[593,]    2    1    6    5    4    3
[594,]    2    1    6    5    3    4
[595,]    2    1    5    3    6    4
[596,]    2    1    5    3    4    6
[597,]    2    1    5    6    3    4
[598,]    2    1    5    6    4    3
[599,]    2    1    5    4    6    3
[600,]    2    1    5    4    3    6
[601,]    1    5    4    3    2    6
[602,]    1    5    4    3    6    2
[603,]    1    5    4    2    3    6
[604,]    1    5    4    2    6    3
[605,]    1    5    4    6    2    3
[606,]    1    5    4    6    3    2
[607,]    1    5    3    4    2    6
[608,]    1    5    3    4    6    2
[609,]    1    5    3    2    4    6
[610,]    1    5    3    2    6    4
[611,]    1    5    3    6    2    4
[612,]    1    5    3    6    4    2
[613,]    1    5    2    3    4    6
[614,]    1    5    2    3    6    4
[615,]    1    5    2    4    3    6
[616,]    1    5    2    4    6    3
[617,]    1    5    2    6    4    3
[618,]    1    5    2    6    3    4
[619,]    1    5    6    3    2    4
[620,]    1    5    6    3    4    2
[621,]    1    5    6    2    3    4
[622,]    1    5    6    2    4    3
[623,]    1    5    6    4    2    3
[624,]    1    5    6    4    3    2
[625,]    1    4    5    3    2    6
[626,]    1    4    5    3    6    2
[627,]    1    4    5    2    3    6
[628,]    1    4    5    2    6    3
[629,]    1    4    5    6    2    3
[630,]    1    4    5    6    3    2
[631,]    1    4    3    5    2    6
[632,]    1    4    3    5    6    2
[633,]    1    4    3    2    5    6
[634,]    1    4    3    2    6    5
[635,]    1    4    3    6    2    5
[636,]    1    4    3    6    5    2
[637,]    1    4    2    3    5    6
[638,]    1    4    2    3    6    5
[639,]    1    4    2    5    3    6
[640,]    1    4    2    5    6    3
[641,]    1    4    2    6    5    3
[642,]    1    4    2    6    3    5
[643,]    1    4    6    3    2    5
[644,]    1    4    6    3    5    2
[645,]    1    4    6    2    3    5
[646,]    1    4    6    2    5    3
[647,]    1    4    6    5    2    3
[648,]    1    4    6    5    3    2
[649,]    1    3    4    5    2    6
[650,]    1    3    4    5    6    2
[651,]    1    3    4    2    5    6
[652,]    1    3    4    2    6    5
[653,]    1    3    4    6    2    5
[654,]    1    3    4    6    5    2
[655,]    1    3    5    4    2    6
[656,]    1    3    5    4    6    2
[657,]    1    3    5    2    4    6
[658,]    1    3    5    2    6    4
[659,]    1    3    5    6    2    4
[660,]    1    3    5    6    4    2
[661,]    1    3    2    5    4    6
[662,]    1    3    2    5    6    4
[663,]    1    3    2    4    5    6
[664,]    1    3    2    4    6    5
[665,]    1    3    2    6    4    5
[666,]    1    3    2    6    5    4
[667,]    1    3    6    5    2    4
[668,]    1    3    6    5    4    2
[669,]    1    3    6    2    5    4
[670,]    1    3    6    2    4    5
[671,]    1    3    6    4    2    5
[672,]    1    3    6    4    5    2
[673,]    1    2    4    3    5    6
[674,]    1    2    4    3    6    5
[675,]    1    2    4    5    3    6
[676,]    1    2    4    5    6    3
[677,]    1    2    4    6    5    3
[678,]    1    2    4    6    3    5
[679,]    1    2    3    4    5    6
[680,]    1    2    3    4    6    5
[681,]    1    2    3    5    4    6
[682,]    1    2    3    5    6    4
[683,]    1    2    3    6    5    4
[684,]    1    2    3    6    4    5
[685,]    1    2    5    3    4    6
[686,]    1    2    5    3    6    4
[687,]    1    2    5    4    3    6
[688,]    1    2    5    4    6    3
[689,]    1    2    5    6    4    3
[690,]    1    2    5    6    3    4
[691,]    1    2    6    3    5    4
[692,]    1    2    6    3    4    5
[693,]    1    2    6    5    3    4
[694,]    1    2    6    5    4    3
[695,]    1    2    6    4    5    3
[696,]    1    2    6    4    3    5
[697,]    1    6    4    3    2    5
[698,]    1    6    4    3    5    2
[699,]    1    6    4    2    3    5
[700,]    1    6    4    2    5    3
[701,]    1    6    4    5    2    3
[702,]    1    6    4    5    3    2
[703,]    1    6    3    4    2    5
[704,]    1    6    3    4    5    2
[705,]    1    6    3    2    4    5
[706,]    1    6    3    2    5    4
[707,]    1    6    3    5    2    4
[708,]    1    6    3    5    4    2
[709,]    1    6    2    3    4    5
[710,]    1    6    2    3    5    4
[711,]    1    6    2    4    3    5
[712,]    1    6    2    4    5    3
[713,]    1    6    2    5    4    3
[714,]    1    6    2    5    3    4
[715,]    1    6    5    3    2    4
[716,]    1    6    5    3    4    2
[717,]    1    6    5    2    3    4
[718,]    1    6    5    2    4    3
[719,]    1    6    5    4    2    3
[720,]    1    6    5    4    3    2
> perms(c(1, exp(1), pi))
         [,1]     [,2]     [,3]
[1,] 3.141593 2.718282 1.000000
[2,] 3.141593 1.000000 2.718282
[3,] 2.718282 3.141593 1.000000
[4,] 2.718282 1.000000 3.141593
[5,] 1.000000 2.718282 3.141593
[6,] 1.000000 3.141593 2.718282
> 
> 
> 
> cleanEx()
> nameEx("piecewise")
> ### * piecewise
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: piecewise
> ### Title: Piecewise Linear Function
> ### Aliases: piecewise
> ### Keywords: math
> 
> ### ** Examples
> 
> x <- c(0,  2, 3,  4, 5)
> y <- c(2, -2, 0, -2, 0)
> piecewise(x, y)
$area
[1] -3

$zeros
[1] 1 3 5

> piecewise(x, y, abs=TRUE)
$area
[1] 5

$zeros
[1] 1 3 5

> 
> 
> 
> cleanEx()
> nameEx("pinv")
> ### * pinv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pinv
> ### Title: Pseudoinverse or Generalized Inverse
> ### Aliases: pinv
> ### Keywords: array
> 
> ### ** Examples
> 
> A <- matrix(c(7,6,4,8,10,11,12,9,3,5,1,2), 3, 4)
> b <- apply(A, 1, sum)  # 32 16 20  row sum
> x <- pinv(A) %*% b
> A %*% x              #=> 32 16 20  as column vector
     [,1]
[1,]   32
[2,]   26
[3,]   20
> 
> 
> 
> cleanEx()
> nameEx("plotyy")
> ### * plotyy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plotyy
> ### Title: Plotting Two y-Axes
> ### Aliases: plotyy
> ### Keywords: graphs
> 
> ### ** Examples
> 
> ## Not run: 
> ##D x  <- seq(0, 20, by = 0.01)
> ##D y1 <- 200*exp(-0.05*x)*sin(x)
> ##D y2 <- 0.8*exp(-0.5*x)*sin(10*x)
> ##D 
> ##D plotyy(x, y1, x, y2, main = "Two-ordinates Plot")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("poisson2disk")
> ### * poisson2disk
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: poisson2disk
> ### Title: Poisson Disk Sampling
> ### Aliases: poisson2disk
> ### Keywords: stat
> 
> ### ** Examples
> 
> set.seed(1111)
> P <- poisson2disk(n = 20, m = 10)
Minimal Distance between points:  0.1472291 
> head(P)
          [,1]       [,2]
[1,] 0.4655026 0.41292487
[2,] 0.8799599 0.91682805
[3,] 0.9873707 0.35914389
[4,] 0.2361872 0.98742740
[5,] 0.2159309 0.10597633
[6,] 0.7109574 0.06429438
> ##            [,1]       [,2]
> ## [1,] 0.46550264 0.41292487
> ## [2,] 0.13710541 0.98737065
> ## [3,] 0.96028255 0.83222920
> ## [4,] 0.06044078 0.09325431
> ## [5,] 0.78579426 0.09267546
> ## [6,] 0.49670274 0.99852771
> 
> # Plotting points
> # plot(P, pch = 'x', col = "blue")
> 
> 
> 
> cleanEx()
> nameEx("polar")
> ### * polar
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: polar
> ### Title: Polar Coordinate Plot (Matlab Style)
> ### Aliases: polar
> ### Keywords: graphs
> 
> ### ** Examples
> 
> ## Not run: 
> ##D t <- deg2rad(seq(0, 360, by = 2))
> ##D polar(t, cos(2*t), bxcol = "white", main = "Sine and Cosine")
> ##D polar(t, sin(2*t), col = "red", add = TRUE)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("poly")
> ### * poly
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Poly
> ### Title: Define Polynomial by Roots
> ### Aliases: Poly
> ### Keywords: math
> 
> ### ** Examples
> 
>   Poly(c(1, -1, 1i, -1i))  # Solves x^4 -1 = 0
[1]  1  0  0  0 -1
>   # Wilkinson's example:
>   roots(Poly(1:20))
 [1] 19.999874 19.001295 17.993672 17.018542 15.959718 15.059326 13.930186
 [8] 13.062664 11.958874 11.022464  9.991191  9.002713  7.999394  7.000097
[15]  5.999990  5.000001  4.000000  3.000000  2.000000  1.000000
> 
> 
> 
> cleanEx()
> nameEx("poly2str")
> ### * poly2str
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: poly2str
> ### Title: Print Polynomial
> ### Aliases: poly2str
> ### Keywords: array
> 
> ### ** Examples
> 
> poly2str(c(0))
[1] "0"
> poly2str(c(1, -1, 1, -1, 1))
[1] "1*x^4 - 1*x^3 + 1*x^2 - 1*x + 1"
> poly2str(c(0, 1e-6, 1e6), d = 2)
[1] "1e-06*x^1 + 1e+06"
> 
> 
> 
> cleanEx()
> nameEx("polyApprox")
> ### * polyApprox
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: polyApprox
> ### Title: Polynomial Approximation
> ### Aliases: polyApprox
> ### Keywords: math
> 
> ### ** Examples
> 
> ##  Example
> #   Polynomial approximation for sin
> polyApprox(sin, -pi, pi, 9)
$p
 [1]  2.197296e-06  0.000000e+00 -1.937495e-04  0.000000e+00  8.317144e-03
 [6]  0.000000e+00 -1.666468e-01  0.000000e+00  9.999961e-01  0.000000e+00

$f
function (x) 
polyval(p, x)
<bytecode: 0x5654b1a19230>
<environment: 0x5654b1a19ab8>

$cheb.coeff
 [1]  0.06549943  0.00000000 -0.58518036  0.00000000  2.54520983  0.00000000
 [7] -5.16709776  0.00000000  3.14158037  0.00000000

$estim.prec
[1] 1.151207e-05

> # $p
> #  [1]  2.197296e-06  0.000000e+00 -1.937495e-04  0.000000e+00  8.317144e-03
> #  [6]  0.000000e+00 -1.666468e-01  0.000000e+00  9.999961e-01  0.000000e+00
> #
> # $f
> # function (x) 
> # polyval(p, x)
> #
> # $cheb.coeff
> #  [1]  0.06549943  0.00000000 -0.58518036  0.00000000  2.54520983  0.00000000
> #  [7] -5.16709776  0.00000000  3.14158037  0.00000000
> #
> # $estim.prec
> # [1] 1.151207e-05
> 
> ## Not run: 
> ##D f <- polyApprox(sin, -pi, pi, 9)$f
> ##D x <- seq(-pi, pi, length.out = 100)
> ##D y <- sin(x) - f(x)
> ##D plot(x, y, type = "l", col = "blue")
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("polyadd")
> ### * polyadd
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: polyadd
> ### Title: Adding Polynomials
> ### Aliases: polyadd
> ### Keywords: math
> 
> ### ** Examples
> 
> polyadd(c(1, 1, 1), 1)
[1] 1 1 2
> polyadd(c(1, 1, 1), c(0, 0, 1))
[1] 1 1 2
> polyadd(c(-0.5, 1, -1), c(0.5, 0, 1))
[1] 1 0
> 
> 
> 
> cleanEx()
> nameEx("polyarea")
> ### * polyarea
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: polyarea
> ### Title: Area of a Polygon
> ### Aliases: polyarea poly_center poly_length poly_crossings
> ### Keywords: math
> 
> ### ** Examples
> 
>   # Zu Chongzhi's calculation of pi (China, about 480 A.D.),
>   # approximating the circle from inside by a regular 12288-polygon(!):
>   phi <- seq(0, 2*pi, len=3*2^12+1)
>   x <- cos(phi)
>   y <- sin(phi)
>   pi_approx <- polyarea(x, y)
>   print(pi_approx, digits=8)    #=> 3.1415925 or 355/113
[1] 3.1415925
> 
>   poly_length(x, y)              #=> 6.2831852 where 2*pi is 6.2831853
[1] 6.283185
> 
>   x1 <- x + 0.5; y1 <- y + 0.5
>   x2 <- rev(x1); y2 <- rev(y1)
>   poly_center(x1, y1)            #=> 0.5 0.5
[1] 0.5 0.5
>   poly_center(x2, y2)            #=> 0.5 0.5
[1] 0.5 0.5
> 
>   # A simple example
>   L1 <- matrix(c(0, 0.5, 1, 1,   2,
+                 0, 1,   1, 0.5, 0), nrow = 2, byrow = TRUE)
>   L2 <- matrix(c(0.5, 0.75, 1.25, 1.25,
+                 0,   0.75, 0.75, 0   ), nrow = 2, byrow = TRUE)
>   P <- poly_crossings(L1, L2)
>   P
        x     y
[1,] 1.00 0.750
[2,] 1.25 0.375
>   ##         x     y
>   ## [1,] 1.00 0.750
>   ## [2,] 1.25 0.375
> 
> ## Not run: 
> ##D   # Crossings of Logarithmic and Archimedian spirals
> ##D   # Logarithmic spiral
> ##D   a <- 1; b <- 0.1
> ##D   t <- seq(0, 5*pi, length.out = 200)
> ##D   xl <- a*exp(b*t)*cos(t) - 1
> ##D   yl <- a*exp(b*t)*sin(t)
> ##D   plot(xl, yl, type = "l", lwd = 2, col = "blue",
> ##D        xlim = c(-6, 3), ylim = c(-3, 4), xlab = "", ylab = "",
> ##D        main = "Intersecting Logarithmic and Archimedian spirals")
> ##D   grid()
> ##D 
> ##D   # Archimedian spiral
> ##D   a <- 0; b <- 0.25
> ##D   r <- a + b*t
> ##D   xa <- r * cos(t)
> ##D   ya <- r*sin(t)
> ##D   lines(xa, ya, type = "l", lwd = 2, col = "red")
> ##D   legend(-6.2, -1.0, c("Logarithmic", "Archimedian"),
> ##D          lwd = 2, col = c("blue", "red"), bg = "whitesmoke")
> ##D 
> ##D   L1 <- rbind(xl, yl)
> ##D   L2 <- rbind(xa, ya)
> ##D   P <- poly_crossings(L1, L2)
> ##D   points(P)
> ##D   
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("polyder")
> ### * polyder
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: polyder
> ### Title: Derivative of Polynomial
> ### Aliases: polyder
> ### Keywords: math
> 
> ### ** Examples
> 
>   polyder(c(3, 6, 9), c(1, 2, 0))  # 12 36 42 18
[1] 12 36 42 18
> 
> 
> 
> cleanEx()
> nameEx("polyfit")
> ### * polyfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: polyfit,polyfix
> ### Title: Fitting by Polynomial
> ### Aliases: polyfit polyfix
> ### Keywords: math
> 
> ### ** Examples
> 
>   # Fitting the sine function by a polynomial
>   x <- seq(0, pi, length.out=25)
>   y <- sin(x)
>   p <- polyfit(x, y, 6)
>   
> ## Not run: 
> ##D   # Plot sin and fitted polynomial
> ##D   plot(x, y, type="b")
> ##D   yf <- polyval(p, x)
> ##D   lines(x, yf, col="red")
> ##D   grid()
> ## End(Not run)
> 
> ## Not run: 
> ##D   n <- 3
> ##D   N <- 100
> ##D   x <- linspace(0, 2*pi, N); y = sin(x) + 0.1*rnorm(N)
> ##D   xfix <- c(0, 2*pi); yfix = c(0, 0)
> ##D 
> ##D   xs <- linspace(0, 2*pi); ys <- sin(xs)
> ##D   plot(xs, ys, type = 'l', col = "gray",
> ##D 	   main = "Polynom Approximation of Degree 3")
> ##D   grid()
> ##D   points(x, y, pch='o', cex=0.5)
> ##D   points(xfix, yfix, col = "darkred")
> ##D 
> ##D   p0 <- polyfit(x, y, n)
> ##D   lines(xs, polyval(p0, xs), col = "blue")
> ##D 
> ##D   p1 <- polyfix(x, y, n, xfix, yfix)
> ##D   lines(xs, polyval(p1, xs), col = "red")
> ##D 
> ##D   legend(4, 1, c("sin", "polyfit", "polyfix"),
> ##D          col=c("gray", "blue", "red"), lty=c(1,1,1))
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("polyint")
> ### * polyint
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: polyint
> ### Title: Anti-derivative of Polynomial
> ### Aliases: polyint
> ### Keywords: math
> 
> ### ** Examples
> 
>   polyint(c(1, 1, 1, 1, 1), 1)
[1] 0.2000000 0.2500000 0.3333333 0.5000000 1.0000000 1.0000000
> 
> 
> 
> cleanEx()
> nameEx("polylog")
> ### * polylog
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: polylog
> ### Title: Polylogarithm Function
> ### Aliases: polylog
> ### Keywords: math
> 
> ### ** Examples
> 
> polylog(0.5,  1)    # polylog(z, 1) = -log(1-z)
[1] 0.6931472
> polylog(0.5,  2)    # (p1^2 - 6*log(2)^2) / 12
[1] 0.5822405
> polylog(0.5,  3)    # (4*log(2)^3 - 2*pi^2*log(2) + 21*zeta(3)) / 24
[1] 0.5372132
> polylog(0.5,  0)    # polylog(z,  0) = z/(1-z)
[1] 1
> polylog(0.5, -1)    # polylog(z, -1) = z/(1-z)^2
[1] 2
> 
> 
> 
> cleanEx()
> nameEx("polymul")
> ### * polymul
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: polymul, polydiv
> ### Title: Multiplying and Dividing Polynomials
> ### Aliases: polymul polydiv
> ### Keywords: math
> 
> ### ** Examples
> 
> # Multiply x^2 + x + 1 with itself
> polymul(c(1, 1, 1), c(0, 1, 1, 1))  #=> 1 2 3 2 1
[1] 1 2 3 2 1
> 
> polydiv(c(1, 2, 3, 2, 1), c(1, 1, 1))
$d
[1] 1 1 1

$r
[1]  0.000000e+00 -1.110223e-16

> #=> d = c(1,1,1); #=> r = c(0.000000e+00 -1.110223e-16)
> 
> 
> 
> cleanEx()
> nameEx("polypow")
> ### * polypow
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: polypow
> ### Title: Polynomial Powers
> ### Aliases: polypow
> ### Keywords: math
> 
> ### ** Examples
> 
> polypow(c(1, -1), 6)             #=> (x - 1)^6 = (1  -6  15 -20  15  -6   1)
[1]   1  -6  15 -20  15  -6   1
> polypow(c(1, 1, 1, 1, 1, 1), 2)  # 1 2 3 4 5 6 5 4 3 2 1
 [1] 1 2 3 4 5 6 5 4 3 2 1
> 
> 
> 
> cleanEx()
> nameEx("polytrans")
> ### * polytrans
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: polytrans, polygcf
> ### Title: Polynomial Transformations
> ### Aliases: polytrans polygcf
> ### Keywords: math
> 
> ### ** Examples
> 
> # (x+1)^2 + (x+1) + 1
> polytrans(c(1, 1, 1), c(1, 1))    #=> 1 3 3
[1] 1 3 3
> polytrans(c(1, 1, 1), c(-1, -1))  #=> 1 1 1
[1] 1 1 1
> 
> p <- c(1,-1,1,-1,1)         #=>  x^4 - x^3 + x^2 - x + 1
> q <- c(1,1,1)               #=>  x^2 + x + 1
> polygcf(polymul(p, q), q)   #=>  [1] 1 1 1
[1] 1 1 1
> 
> p = polypow(c(1, -1), 6)    #=>  [1] 1  -6  15 -20  15  -6   1
> rootsmult(p, 1)             #=>  [1] 6
[1] 6
> 
> 
> 
> cleanEx()
> nameEx("polyval")
> ### * polyval
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: polyval, polyvalm
> ### Title: Evaluating a Polynomial
> ### Aliases: polyval polyvalm
> ### Keywords: math
> 
> ### ** Examples
> 
>   # Evaluate 3 x^2 + 2 x + 1 at x = 5, 7, and 9
>   p = c(3, 2, 1);
>   polyval(p, c(5, 7, 9))    # 86  162  262
[1]  86 162 262
> 
>   # Apply the characteristic polynomial to its matrix
>   A <- pascal(4)
>   p <- pracma::Poly(A)      # characteristic polynomial of A
>   polyvalm(p, A)            # almost zero 4x4-matrix
             [,1]         [,2]         [,3]         [,4]
[1,] 3.097744e-12 1.071498e-11 2.468425e-11 4.692424e-11
[2,] 1.082157e-11 3.650036e-11 8.358114e-11 1.579323e-10
[3,] 2.411582e-11 8.090240e-11 1.843430e-10 3.478391e-10
[4,] 4.676792e-11 1.560423e-10 3.551008e-10 6.693097e-10
> 
> 
> 
> cleanEx()
> nameEx("pow2")
> ### * pow2
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pow2
> ### Title: Base 2 Power
> ### Aliases: pow2
> ### Keywords: arith
> 
> ### ** Examples
> 
>   pow2(c(0, 1, 2, 3))                   #=> 1 2 4 8
[1] 1 2 4 8
>   pow2(c(0, -1, 2, 3), c(0,1,-2,3))     #=> 0.0 -2.0  0.5 24.0
[1]  0.0 -2.0  0.5 24.0
>   pow2(1i)                              #=> 0.7692389+0.6389613i
[1] 0.7692389+0.6389613i
> 
> 
> 
> cleanEx()
> nameEx("pp")
> ### * pp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ppval
> ### Title: Piecewise Polynomial Structures
> ### Aliases: mkpp ppval
> ### Keywords: fitting
> 
> ### ** Examples
> 
> ##  Example: Linear interpolation of the sine function
> xs <- linspace(0, pi, 10)
> ys <- sin(xs)
> P <- matrix(NA, nrow = 9, ncol = 2)
> for (i in 1:9) {
+     P[i, ] <- c((ys[i+1]-ys[i])/(xs[i+1]-xs[i]), ys[i])
+ }
> ppsin <- mkpp(xs, P)
> 
> ## Not run: 
> ##D plot(xs, ys); grid()
> ##D x100 <- linspace(0, pi, 100)
> ##D lines(x100, sin(x100), col="darkgray")
> ##D ypp <- ppval(ppsin, x100)
> ##D lines(x100, ypp, col="red")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("ppfit")
> ### * ppfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ppfit
> ### Title: Piecewise Polynomial Fit
> ### Aliases: ppfit
> ### Keywords: fitting
> 
> ### ** Examples
> 
> x <- 0:39
> y <- c(  8.8500,  32.0775,  74.7375, 107.6775, 132.0975, 156.6675,
+        169.0650, 187.5375, 202.2575, 198.0750, 225.9600, 204.3550,
+        233.8125, 204.5925, 232.3625, 204.7550, 220.1925, 199.5875,
+        197.3025, 175.3050, 218.6325, 163.0775, 170.6625, 148.2850,
+        154.5950, 135.4050, 138.8600, 125.6750, 118.8450,  99.2675,
+        129.1675,  91.1925,  89.7000,  76.8825,  83.6625,  74.1950,
+         73.9125,  55.8750,  59.8675,  48.1900)
> 
> xi <- linspace(0, 39, 8)
> pplin <- ppfit(x, y, xi)  # method = "linear"
> ppcub <- ppfit(x, y, xi, method = "cubic")
> 
> ## Not run: 
> ##D plot(x, y, type = "b", main = "Piecewise polynomial approximation")
> ##D xs <- linspace(0, 39, 100)
> ##D yslin <- ppval(pplin, xs)
> ##D yscub <- ppval(ppcub, xs)
> ##D lines(xs, yscub, col="red",lwd = 2)
> ##D lines(xs, yslin, col="blue")
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("pracma-package")
> ### * pracma-package
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pracma-package
> ### Title: Practical Numerical Math Routines
> ### Aliases: pracma-package pracma
> ### Keywords: package
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ##  See examples in the help files for all functions.
> ##D     
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("primes")
> ### * primes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: primes
> ### Title: Prime Numbers
> ### Aliases: primes
> ### Keywords: arith
> 
> ### ** Examples
> 
> primes(1000)
  [1]   2   3   5   7  11  13  17  19  23  29  31  37  41  43  47  53  59  61
 [19]  67  71  73  79  83  89  97 101 103 107 109 113 127 131 137 139 149 151
 [37] 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251
 [55] 257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349 353 359
 [73] 367 373 379 383 389 397 401 409 419 421 431 433 439 443 449 457 461 463
 [91] 467 479 487 491 499 503 509 521 523 541 547 557 563 569 571 577 587 593
[109] 599 601 607 613 617 619 631 641 643 647 653 659 661 673 677 683 691 701
[127] 709 719 727 733 739 743 751 757 761 769 773 787 797 809 811 821 823 827
[145] 829 839 853 857 859 863 877 881 883 887 907 911 919 929 937 941 947 953
[163] 967 971 977 983 991 997
> ## Not run: 
> ##D ##  Appendix:  Logarithmic Integrals and Prime Numbers (C.F.Gauss, 1846)
> ##D 
> ##D library('gsl')
> ##D # 'European' form of the logarithmic integral
> ##D Li <- function(x) expint_Ei(log(x)) - expint_Ei(log(2))
> ##D 
> ##D # No. of primes and logarithmic integral for 10^i, i=1..12
> ##D i <- 1:12;  N <- 10^i
> ##D # piN <- numeric(12)
> ##D # for (i in 1:12) piN[i] <- length(primes(10^i))
> ##D piN <- c(4, 25, 168, 1229, 9592, 78498, 664579,
> ##D          5761455, 50847534, 455052511, 4118054813, 37607912018)
> ##D cbind(i, piN, round(Li(N)), round((Li(N)-piN)/piN, 6))
> ##D 
> ##D #  i     pi(10^i)      Li(10^i)  rel.err  
> ##D # --------------------------------------      
> ##D #  1            4            5  0.280109
> ##D #  2           25           29  0.163239
> ##D #  3          168          177  0.050979
> ##D #  4         1229         1245  0.013094
> ##D #  5         9592         9629  0.003833
> ##D #  6        78498        78627  0.001637
> ##D #  7       664579       664917  0.000509
> ##D #  8      5761455      5762208  0.000131
> ##D #  9     50847534     50849234  0.000033
> ##D # 10    455052511    455055614  0.000007
> ##D # 11   4118054813   4118066400  0.000003
> ##D # 12  37607912018  37607950280  0.000001
> ##D # --------------------------------------
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("procrustes")
> ### * procrustes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: procrustes
> ### Title: Solving the Procrustes Problem
> ### Aliases: procrustes kabsch
> ### Keywords: array
> 
> ### ** Examples
> 
> ##  Procrustes
> U <- randortho(5)               # random orthogonal matrix
> P <- procrustes(U, eye(5))
> 
> ##  Kabsch
> P <- matrix(c(0, 1, 0, 0, 1, 1, 0, 1,
+               0, 0, 1, 0, 1, 0, 1, 1,
+               0, 0, 0, 1, 0, 1, 1, 1), nrow = 3, ncol = 8, byrow = TRUE)
> R <- c(1, 1, 1)
> phi <- pi/4
> U <- matrix(c(1, 0, 0,
+               0, cos(phi), -sin(phi),
+               0, sin(phi),  cos(phi)), nrow = 3, ncol = 3, byrow = TRUE)
> 
> Q <- U %*% P + R
> K <- kabsch(P, Q)
> # K$R == R  and  K$U %*% P + c(K$R) == Q
> 
> 
> 
> cleanEx()
> nameEx("psi")
> ### * psi
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: psi
> ### Title: Psi (Polygamma) Function
> ### Aliases: psi
> 
> ### ** Examples
> 
> psi(2) - psi(1)         # 1
[1] 1
> -psi(1)                 # Eulers constant: 0.57721566490153  [or, -psi(0, 1)]
[1] 0.5772157
> psi(1, 2)               # pi^2/6 - 1     : 0.64493406684823
[1] 0.6449341
> psi(10, -11.5-0.577007813568142i)
[1] -4.984032e-06+6.22611e-07i
>                         # is near a root of the decagamma function
> 
> 
> 
> cleanEx()
> nameEx("qpspecial")
> ### * qpspecial
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: qpspecial, qpsolve
> ### Title: Special Quadratic Programming Solver
> ### Aliases: qpspecial qpsolve
> 
> ### ** Examples
> 
> G <- matrix(c(0.31, 0.99, 0.54, 0.20,
+               0.56, 0.97, 0.40, 0.38,
+               0.81, 0.06, 0.44, 0.80), 3, 4, byrow =TRUE)
> qpspecial(G)
$x
             [,1]
[1,] 1.383697e-07
[2,] 5.221698e-09
[3,] 8.648168e-01
[4,] 1.351831e-01

$d
          [,1]
[1,] 0.4940377
[2,] 0.3972964
[3,] 0.4886660

$q
[1] 0.6407121

$niter
[1] 6

$info
[1] 0

> # $x
> #              [,1]
> # [1,] 1.383697e-07
> # [2,] 5.221698e-09
> # [3,] 8.648168e-01
> # [4,] 1.351831e-01
> # $d
> #           [,1]
> # [1,] 0.4940377
> # [2,] 0.3972964
> # [3,] 0.4886660
> # $q
> # [1] 0.6407121
> # $niter
> # [1] 6
> # $info
> # [1] 0
> 
> # Example from quadprog::solve.QP
> d <- c(0,5,0)
> A <- matrix(c(-4,-3,0,2,1,0,0,-2,1),3,3)
> b <- c(-8,2,0)
> qpsolve(d, A, b)
$sol
[1] 0.4761905 1.0476190 2.0952381

$val
[1] -2.380952

$niter
[1] 3

> ## $sol
> ## [1] 0.4761905 1.0476190 2.0952381
> ## $val
> ## [1] -2.380952
> ## $niter
> ## [1] 3
> 
> 
> 
> cleanEx()
> nameEx("qrSolve")
> ### * qrSolve
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: qrSolve
> ### Title: LSE Solution
> ### Aliases: qrSolve
> ### Keywords: array
> 
> ### ** Examples
> 
> A <- matrix(c(0,-4,2, 6,-3,-2, 8,1,-1), 3, 3, byrow=TRUE)
> b <- c(-2, -6, 7)
> qrSolve(A, b)
[1] 1 2 3
> 
> ##  Solve an overdetermined linear system of equations
> A <- matrix(c(1:8,7,4,2,3,4,2,2), ncol=3, byrow=TRUE)
> b <- rep(6, 5)
> x <- qrSolve(A, b)
> qr.solve(A, rep(6, 5)); x
[1]  1.074236 -2.331878  2.436681
[1]  1.074236 -2.331878  2.436681
> 
> 
> 
> cleanEx()
> nameEx("quad")
> ### * quad
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: quad
> ### Title: Adaptive Simpson Quadrature
> ### Aliases: quad
> ### Keywords: math
> 
> ### ** Examples
> 
> # options(digits=15)
> f <- function(x) x * cos(0.1*exp(x)) * sin(0.1*pi*exp(x))
> quad(f, 0, 4)              # 1.2821290747821
[1] 1.282129
> quad(f, 0, 4, tol=10^-15)  # 1.2821290743501
[1] 1.282129
> integrate(f, 0, 4)
1.282129 with absolute error < 4.1e-06
> # 1.28212907435010 with absolute error < 4.1e-06
> 
> ## Not run: 
> ##D xx <- seq(0, 4, length.out = 200)
> ##D yy <- f(xx)
> ##D plot(xx, yy, type = 'l')
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("quad2d")
> ### * quad2d
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: quad2d
> ### Title: 2-d Gaussian Quadrature
> ### Aliases: quad2d
> ### Keywords: math
> 
> ### ** Examples
> 
> ##  Example:  f(x, y) = (y+1)*exp(x)*sin(16*y-4*(x+1)^2)
> f <- function(x, y)
+         (y+1) * exp(x) * sin(16*y-4*(x+1)^2)
> # this is even faster than cubature::adaptIntegral():
> quad2d(f, -1, 1, -1, 1)
[1] 0.01795156
> # 0.0179515583236958  # true value 0.01795155832370
> 
> ##  Volume of the sphere: use polar coordinates
> f0 <- function(x, y) sqrt(1 - x^2 - y^2)  # for x^2 + y^2 <= 1
> fp <- function(x, y) y * f0(y*cos(x), y*sin(x))
> quad2d(fp, 0, 2*pi, 0, 1, n = 101)  # 2.09439597740074
[1] 2.094396
> 2/3 * pi                            # 2.0943951023932
[1] 2.094395
> 
> 
> 
> cleanEx()
> nameEx("quadcc")
> ### * quadcc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: quadcc
> ### Title: Adaptive Clenshaw-Curtis Quadrature
> ### Aliases: quadcc
> ### Keywords: math
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ##  Dilogarithm function
> ##D flog <- function(t) log(1-t)/t
> ##D quadcc(flog, 1, 0, tol = 1e-12)
> ##D # 1.644934066848128 - pi^2/6 < 1e-13
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("quadgk")
> ### * quadgk
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: quadgk
> ### Title: Adaptive Gauss-Kronrod Quadrature
> ### Aliases: quadgk
> ### Keywords: math
> 
> ### ** Examples
> 
> ##  Dilogarithm function
> flog <- function(t) log(1-t)/t
> quadgk(flog, 1, 0, tol = 1e-12)
[1] 1.644934
> # 1.644934066848128 - pi^2/6 < 1e-13
> 
> 
> 
> cleanEx()
> nameEx("quadgr")
> ### * quadgr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: quadgr
> ### Title: Gaussian Quadrature with Richardson Extrapolation
> ### Aliases: quadgr
> ### Keywords: math
> 
> ### ** Examples
> 
> ##  Dilogarithm function
> flog <- function(t) log(1-t)/t
> quadgr(flog, 1, 0, tol = 1e-12)
$value
[1] 1.644934

$rel.err
[1] 2.018385e-13

> # value
> # 1.6449340668482 , is pi^2/6 = 1.64493406684823
> # rel.err
> # 2.07167616395054e-13
> 
> 
> 
> cleanEx()
> nameEx("quadinf")
> ### * quadinf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: quadinf
> ### Title: Infinite Integrals
> ### Aliases: quadinf
> ### Keywords: math
> 
> ### ** Examples
> 
> ##  We will look at the error function exp(-x^2)
> f <- function(x) exp(-x^2)          # sqrt(pi)/2         theory
> quadinf(f, 0, Inf)                  # 0.8862269254527413
$Q
[1] 0.8862269

$relerr
[1] 4.218847e-15

$niter
[1] 6

> quadinf(f, -Inf, 0)                 # 0.8862269254527413
$Q
[1] 0.8862269

$relerr
[1] 4.218847e-15

$niter
[1] 6

> 
> f = function(x) sqrt(x) * exp(-x)   # 0.8862269254527579 exact
> quadinf(f, 0, Inf)                  # 0.8862269254527579
$Q
[1] 0.8862269

$relerr
[1] 4.440892e-16

$niter
[1] 5

> 
> f = function(x) x * exp(-x^2)       # 1/2
> quadinf(f, 0, Inf)                  # 0.5
$Q
[1] 0.5

$relerr
[1] 0

$niter
[1] 6

> 
> f = function(x) 1 / (1+x^2)         # 3.141592653589793 = pi
> quadinf(f, -Inf, Inf)               # 3.141592653589784
$Q
[1] 3.141593

$relerr
[1] 1.239009e-13

$niter
[1] 3

> 
> 
> 
> cleanEx()
> nameEx("quadl")
> ### * quadl
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: quadl
> ### Title: Adaptive Lobatto Quadrature
> ### Aliases: quadl
> ### Keywords: math
> 
> ### ** Examples
> 
> # options(digits=15)
> f <- function(x) x * cos(0.1*exp(x)) * sin(0.1*pi*exp(x))
> quadl(f, 0, 4)              # 1.2821290743501
[1] 1.282129
> integrate(f, 0, 4)
1.282129 with absolute error < 4.1e-06
> # 1.28212907435010 with absolute error < 4.1e-06
> 
> ## Not run: 
> ##D xx <- seq(0, 4, length.out = 200)
> ##D yy <- f(xx)
> ##D plot(xx, yy, type = 'l')
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("quadprog")
> ### * quadprog
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: quadprog
> ### Title: Quadratic Programming
> ### Aliases: quadprog
> ### Keywords: optimize
> 
> ### ** Examples
> 
> ## Example in ?solve.QP
> # Assume we want to minimize: 1/2 x^T x - (0 5 0) %*% x
> # under the constraints:      A x <= b
> # with b = (8,-2, 0)
> # and      ( 4  3  0) 
> #      A = (-2 -1  0)
> #          ( 0  2,-1)
> # and possibly equality constraint  3x1 + 2x2 + x3 = 1
> # or upper bound c(1.5, 1.5, 1.5).
> 
> C <- diag(1, 3); d <- -c(0, 5, 0)
> A <- matrix(c(4,3,0, -2,-1,0, 0,2,-1), 3, 3, byrow=TRUE)
> b <- c(8, -2, 0)
> 
> quadprog(C, d, A, b)
$xmin
[1] 0.4761905 1.0476190 2.0952381

$fval
[1] -2.380952

$eflag
[1] 1

> # $xmin
> # [1] 0.4761905 1.0476190 2.0952381
> # $fval
> # [1] -2.380952
> # $eflag
> # [1] 1
> 
> Aeq <- c(3, 2, 1);  beq <- 1
> quadprog(C, d, A, b, Aeq, beq)
$xmin
[1]  1.4 -0.8 -1.6

$fval
[1] 6.58

$eflag
[1] 1

> # $xmin
> # [1]  1.4 -0.8 -1.6
> # $fval
> # [1] 6.58
> # $eflag
> # [1] 1
> 
> quadprog(C, d, A, b, lb = 0, ub = 1.5)
$xmin
[1] 0.625 0.750 1.500

$fval
[1] -2.148438

$eflag
[1] 1

> # $xmin
> # [1] 0.625 0.750 1.500
> # $fval
> # [1] -2.148438
> # $eflag
> # [1] 1
> 
> ## Example help(quadprog)
> C <- matrix(c(1, -1, -1, 2), 2, 2)
> d <- c(-2, -6)
> A <- matrix(c(1,1, -1,2, 2,1), 3, 2, byrow=TRUE)
> b <- c(2, 2, 3)
> lb <- c(0, 0)
> 
> quadprog(C, d, A, b, lb=lb)
$xmin
[1] 0.6666667 1.3333333

$fval
[1] -8.222222

$eflag
[1] 1

> # $xmin
> # [1] 0.6666667 1.3333333
> # $fval
> # [1] -8.222222
> # $eflag
> # [1] 1
> 
> 
> 
> cleanEx()
> nameEx("quadv")
> ### * quadv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: quadv
> ### Title: Vectorized Integration
> ### Aliases: quadv
> ### Keywords: math
> 
> ### ** Examples
> 
> ##  Examples
> f1 <- function(x) c(sin(x), cos(x))
> quadv(f1, 0, pi)
$Q
[1] 2 0

$fcnt
[1] 65

$estim.prec
[1] 4.321337e-07

> # $Q
> #  [1] 2.000000e+00 1.110223e-16
> # $fcnt
> #  [1] 65
> # $estim.prec
> #  [1] 4.321337e-07
> 
> f2 <- function(x) x^c(1:10)
> quadv(f2, 0, 1, tol = 1e-12)
$Q
 [1] 0.50000000 0.33333333 0.25000000 0.20000000 0.16666667 0.14285714
 [7] 0.12500000 0.11111111 0.10000000 0.09090909

$fcnt
[1] 505

$estim.prec
[1] 2.49e-10

> # $Q
> #  [1] 0.50000000 0.33333333 0.25000000 0.20000000 0.16666667
> #  [6] 0.14285714 0.12500000 0.11111111 0.10000000 0.09090909
> # $fcnt
> #  [1] 505
> # $estim.prec
> #  [1] 2.49e-10
> 
> 
> 
> cleanEx()
> nameEx("rand")
> ### * rand
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rand
> ### Title: Create Random Matrices
> ### Aliases: rand randn randi randsample rands randp
> ### Keywords: stat
> 
> ### ** Examples
> 
> rand(3)
          [,1]      [,2]      [,3]
[1,] 0.2655087 0.9082078 0.9446753
[2,] 0.3721239 0.2016819 0.6607978
[3,] 0.5728534 0.8983897 0.6291140
> randn(1, 5)
         [,1]      [,2]       [,3]         [,4]     [,5]
[1,] -1.53995 -0.928567 -0.2947204 -0.005767173 2.404653
> randi(c(1,6), 1, 10)
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
[1,]    1    5    5    1    1    6    5    5    2     2
> randsample(10, 5, replacement = TRUE, w = c(0,0,0, 1, 1, 1, 1, 0,0,0))
[1] 5 6 7 4 5
> 
> P <- rands(1000, N = 1, r = 2)
> U <- randp(1000, 2)
> ## Not run: 
> ##D plot(U[, 1], U[, 2], pch = "+", asp = 1)
> ##D points(P, pch = ".")
> ## End(Not run)
> 
> #-- v is 2 independent normally distributed elements
> # u <- randp(1); r <- t(u) %*% u
> # v <- sqrt(-2 * log(r)/r) * u
> 
> n <- 5000; U <- randp(n)
> R <- apply(U*U, 1, sum)
> P <- sqrt(-2 * log(R)/R) * U  # rnorm(2*n)
> ## Not run: 
> ##D hist(c(P))
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("randcomb")
> ### * randcomb
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: randcomb
> ### Title: Random Combination
> ### Aliases: randcomb
> ### Keywords: arith
> 
> ### ** Examples
> 
> randcomb(seq(2, 10, by=2), m = 3)
[1] 2 8 6
> 
> 
> 
> cleanEx()
> nameEx("randortho")
> ### * randortho
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: randortho
> ### Title: Generate Random Orthonormal or Unitary Matrix
> ### Aliases: randortho
> ### Keywords: math
> 
> ### ** Examples
> 
> Q <- randortho(5)
> zapsmall(Q %*% t(Q))
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    0    0    0    0
[2,]    0    1    0    0    0
[3,]    0    0    1    0    0
[4,]    0    0    0    1    0
[5,]    0    0    0    0    1
> zapsmall(t(Q) %*% Q)
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    0    0    0    0
[2,]    0    1    0    0    0
[3,]    0    0    1    0    0
[4,]    0    0    0    1    0
[5,]    0    0    0    0    1
> 
> 
> 
> cleanEx()
> nameEx("randperm")
> ### * randperm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: randperm
> ### Title: Random Permutation
> ### Aliases: randperm
> ### Keywords: arith
> 
> ### ** Examples
> 
> randperm(1:6, 3)
[1] 1 4 3
> randperm(6, 6)
[1] 1 2 6 3 4 5
> randperm(11:20, 5)
[1] 12 13 11 15 17
> randperm(seq(2, 10, by=2))
[1]  4 10  8  6  2
> 
> 
> 
> cleanEx()
> nameEx("rank")
> ### * rank
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Rank
> ### Title: Matrix Rank
> ### Aliases: Rank
> ### Keywords: array
> 
> ### ** Examples
> 
> Rank(magic(10))   #=> 7
[1] 7
> Rank(magic(100))  #=> 3 (!)
[1] 3
> Rank(hilb(8))     #=> 8 , but qr(hilb(8))$rank says, rank is 7.
Warning in Rank(hilb(8)) : Rank calculation may be problematic.
[1] 8
> # Warning message:
> # In Rank(hilb(8)) : Rank calculation may be problematic.
> 
> 
> 
> cleanEx()
> nameEx("rat")
> ### * rat
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rat
> ### Title: Continuous Fractions (Matlab Style)
> ### Aliases: rat rats
> ### Keywords: math
> 
> ### ** Examples
> 
> rat(pi)
[1] "[ 3; 7, 15, 1]"
> rats(pi)
355/113 
> rat(sqrt(c(2, 3, 5)),  tol = 1e-15)
[1] "[ 1; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]"                     
[2] "[ 1; 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1]"
[3] "[ 2; 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]"                                             
> rats(sqrt(c(2, 3, 5)), tol = 1e-15)
54608393/38613965 
50843527/29354524 
70711162/31622993 
> 
> 
> 
> cleanEx()
> nameEx("ratinterp")
> ### * ratinterp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ratinterp
> ### Title: Rational Interpolation
> ### Aliases: ratinterp
> ### Keywords: fitting
> 
> ### ** Examples
> 
> ## Rational interpolation of Runge's function
> x <- c(-1, -0.5, 0, 0.5, 1.0)
> y <- runge(x)
> xs <- linspace(-1, 1)
> ys <- runge(xs)
> yy <- ratinterp(x, y, xs)  # returns exactly the Runge function
> 
> ## Not run: 
> ##D plot(xs, ys, type="l", col="blue", lty = 2, lwd = 3)
> ##D points(x, y)
> ##D yy <- ratinterp(x, y, xs)
> ##D lines(xs, yy, col="red")
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("rationalfit")
> ### * rationalfit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rationalfit
> ### Title: Rational Function Approximation
> ### Aliases: rationalfit
> ### Keywords: fitting
> 
> ### ** Examples
> 
> ## Not run: 
> ##D x <- linspace(0, 15, 151); y <- sin(x)/x
> ##D rA <- rationalfit(x, y, 10, 10); p1 <- rA$p1; p2 <- rA$p2
> ##D ys <- polyval(p1,x) / polyval(p2,x)
> ##D plot(x, y, type="l", col="blue", ylim=c(-0.5, 1.0))
> ##D points(x, Re(ys), col="red")  # max(abs(y-ys), na.rm=TRUE) < 1e-6
> ##D grid()
> ##D 
> ##D # Rational approximation of the Zeta function
> ##D x <- seq(-5, 5, by = 1/16)
> ##D y <- zeta(x)
> ##D rA <- rationalfit(x, y, 10, 10); p1 <- rA$p1; p2 <- rA$p2
> ##D ys <- polyval(p1,x) / polyval(p2,x)
> ##D plot(x, y, type="l", col="blue", ylim=c(-5, 5))
> ##D points(x, Re(ys), col="red")
> ##D grid()
> ##D 
> ##D # Rational approximation to the Gamma function
> ##D x <- seq(-5, 5, by = 1/32); y <- gamma(x)
> ##D rA <- rationalfit(x, y, 10, 10); p1 <- rA$p1; p2 <- rA$p2
> ##D ys <- polyval(p1,x) / polyval(p2,x)
> ##D plot(x, y, type="l", col = "blue")
> ##D points(x, Re(ys), col="red")
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("rectint")
> ### * rectint
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rectint
> ### Title: Rectangle Intersection Areas
> ### Aliases: rectint
> ### Keywords: math
> 
> ### ** Examples
> 
> x <- c(0.5, 0.5, 0.25, 1.00)
> y <- c(0.3, 0.3, 0.35, 0.75)
> rectint(x, y)
[1] 0.0825
> # [1] 0.0825
> 
> 
> 
> cleanEx()
> nameEx("refindall")
> ### * refindall
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: refindall
> ### Title: Find overlapping regular expression matches.
> ### Aliases: refindall
> ### Keywords: string
> 
> ### ** Examples
> 
> refindall("ababababa", 'aba')
[1] 1 3 5 7
> gregexpr('a(?=ba)', "ababababa", perl=TRUE)
[[1]]
[1] 1 3 5 7
attr(,"match.length")
[1] 1 1 1 1
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

> 
> refindall("AbababaBa", 'aba')
[1] 3 5
> refindall("AbababaBa", 'aba', ignorecase = TRUE)
[1] 1 3 5 7
> 
> 
> 
> cleanEx()
> nameEx("regexp")
> ### * regexp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: regexp
> ### Title: Match regular expression
> ### Aliases: regexp regexpi
> ### Keywords: string
> 
> ### ** Examples
> 
> s <- "bat cat can car COAT court cut ct CAT-scan"
> pat <-  'c[aeiou]+t'
> regexp(s, pat)
$start
[1]  5 28
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

$end
[1]  7 30
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

$match
[1] "cat" "cut"

$split
NULL

> regexpi(s, pat)
$start
[1]  5 17 28 35
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

$end
[1]  7 20 30 37
attr(,"index.type")
[1] "chars"
attr(,"useBytes")
[1] TRUE

$match
[1] "cat"  "COAT" "cut"  "CAT" 

$split
NULL

> 
> 
> 
> cleanEx()
> nameEx("regexprep")
> ### * regexprep
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: regexprep
> ### Title: Replace string using regular expression
> ### Aliases: regexprep
> ### Keywords: string
> 
> ### ** Examples
> 
> s <- "bat cat can car COAT court cut ct CAT-scan"
> pat <-  'c[aeiou]+t'
> regexprep(s, pat, '---')
[1] "bat --- can car COAT court --- ct CAT-scan"
> regexprep(s, pat, '---', once = TRUE)
[1] "bat --- can car COAT court cut ct CAT-scan"
> regexprep(s, pat, '---', ignorecase = TRUE)
[1] "bat --- can car --- court --- ct ----scan"
> 
> 
> 
> cleanEx()
> nameEx("repmat")
> ### * repmat
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: repmat
> ### Title: Replicate Matrix
> ### Aliases: repmat
> ### Keywords: array
> 
> ### ** Examples
> 
> repmat(1, 3)                  # same as ones(3)
     [,1] [,2] [,3]
[1,]    1    1    1
[2,]    1    1    1
[3,]    1    1    1
> repmat(1, 3, 3)
     [,1] [,2] [,3]
[1,]    1    1    1
[2,]    1    1    1
[3,]    1    1    1
> repmat(matrix(1:4, 2, 2), 3)
     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    3    1    3    1    3
[2,]    2    4    2    4    2    4
[3,]    1    3    1    3    1    3
[4,]    2    4    2    4    2    4
[5,]    1    3    1    3    1    3
[6,]    2    4    2    4    2    4
> 
> 
> 
> cleanEx()
> nameEx("reshape")
> ### * reshape
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Reshape
> ### Title: Reshape Matrix
> ### Aliases: Reshape
> ### Keywords: array
> 
> ### ** Examples
> 
> a <- matrix(1:12, nrow=4, ncol=3)
> Reshape(a, 6, 2)
     [,1] [,2]
[1,]    1    7
[2,]    2    8
[3,]    3    9
[4,]    4   10
[5,]    5   11
[6,]    6   12
> Reshape(a, 6)     # the same
     [,1] [,2]
[1,]    1    7
[2,]    2    8
[3,]    3    9
[4,]    4   10
[5,]    5   11
[6,]    6   12
> Reshape(a, 3, 4)
     [,1] [,2] [,3] [,4]
[1,]    1    4    7   10
[2,]    2    5    8   11
[3,]    3    6    9   12
> 
> 
> 
> cleanEx()
> nameEx("ridders")
> ### * ridders
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ridders
> ### Title: Ridders' Root Finding Method
> ### Aliases: ridders
> ### Keywords: math
> 
> ### ** Examples
> 
> ##  Test functions
> f1  <- function(x)                          # [0, 1.2],     0.399 422 2917
+             x^2 * (x^2/3 + sqrt(2)*sin(x)) - sqrt(3)/18
> f2  <- function(x) 11*x^11 - 1              # [0.4, 1.6],   0.804 133 0975
> f3  <- function(x) 35*x^35 - 1              # [-0.5, 1.9],  0.903 407 6632
> f4  <- function(x)                          # [-0.5, 0.7],  0.077 014 24135
+             2*(x*exp(-9) - exp(-9*x)) + 1 
> f5  <- function(x) x^2 - (1 - x)^9          # [-1.4, 1],    0.259 204 4937
> f6  <- function(x) (x-1)*exp(-9*x) + x^9    # [-0.8, 1.6],  0.536 741 6626
> f7  <- function(x) x^2 + sin(x/9) - 1/4     # [-0.5, 1.9],  0.4475417621
> f8  <- function(x) 1/8 * (9 - 1/x)        # [0.001, 1.201], 0.111 111 1111 
> f9  <- function(x) tan(x) - x - 0.0463025   # [-0.9, 1.5],  0.500 000 0340
> f10 <- function(x)                          # [0.4, 1],     0.679 808 9215
+             x^2 + x*sin(sqrt(75)*x) - 0.2
> f11 <- function(x) x^9 + 0.0001             # [-1.2, 0],   -0.359 381 3664 
> f12 <- function(x)                          # [1, 3.4],     1.648 721 27070
+             log(x) + x^2/(2*exp(1)) - 2 * x/sqrt(exp(1)) + 1
> 
> r <- ridders(f1 , 0, 1.2);       r$root; r$niter # 18
[1] 0.3994223
[1] 18
> r <- ridders(f2 , 0.4, 1.6);     r$root; r$niter # 14
[1] 0.8041331
[1] 14
> r <- ridders(f3 ,-0.5, 1.9);     r$root; r$niter # 20
[1] 0.9034077
[1] 20
> r <- ridders(f4 ,-0.5, 0.7);     r$root; r$niter # 12
[1] 0.07701424
[1] 12
> r <- ridders(f5 ,-1.4, 1);       r$root; r$niter # 16
[1] 0.2592045
[1] 22
> r <- ridders(f6 ,-0.8, 1.6);     r$root; r$niter # 20
[1] 0.5367417
[1] 20
> r <- ridders(f7 ,-0.5, 1.9);     r$root; r$niter # 16
[1] 0.4475418
[1] 16
> r <- ridders(f8 ,0.001, 1.201);  r$root; r$niter # 18
[1] 0.1111111
[1] 18
> r <- ridders(f9 ,-0.9, 1.5);     r$root; r$niter # 20
[1] 0.5
[1] 22
> r <- ridders(f10,0.4, 1);        r$root; r$niter # 14
[1] 0.6798089
[1] 14
> r <- ridders(f11,-1.2, 0);       r$root; r$niter # 12
[1] -0.3593814
[1] 12
> r <- ridders(f12,1, 3.4);        r$root; r$niter # 30, err = 1e-5
[1] 1.648714
[1] 30
> 
> ## Not run: 
> ##D ##  Use ridders() with Rmpfr
> ##D options(digits=16)
> ##D library("Rmpfr") # unirootR
> ##D prec <- 256
> ##D .N <- function(.) mpfr(., precBits = prec)
> ##D 
> ##D f12 <- function(x) {
> ##D     e1 <- exp(.N(1))
> ##D     log(x) + x^2/(2*e1) - 2*x/sqrt(e1) + 1
> ##D }
> ##D sqrte <- sqrt(exp(.N(1)))  # 1.648721270700128...
> ##D f12(sqrte)                 # 0
> ##D 
> ##D unirootR(f12, interval=mpfr(c(1, 3.4), prec), tol=1e-20)
> ##D # $root
> ##D # 1 'mpfr' number of precision  200   bits 
> ##D # [1] 1.648721270700128...
> ##D 
> ##D ridders(f12, .N(1), .N(3.4), maxiter=200, tol=1e-20)
> ##D # $root
> ##D # 1 'mpfr' number of precision  200   bits 
> ##D # [1] 1.648721270700128...
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("rk4")
> ### * rk4
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rk4, rk4sys
> ### Title: Classical Runge-Kutta
> ### Aliases: rk4 rk4sys
> ### Keywords: ode
> 
> ### ** Examples
> 
> ##  Example1: ODE
> # y' = y*(-2*x + 1/x) for x != 0, 1 if x = 0
> # solution is x*exp(-x^2)
> f <- function(x, y) {
+ 	if (x != 0) dy <- y * (- 2*x + 1/x)
+ 	else        dy <- rep(1, length(y))
+ 	return(dy)
+ }
> sol <- rk4(f, 0, 2, 0, 50)
> ## Not run: 
> ##D x <- seq(0, 2, length.out = 51)
> ##D plot(x, x*exp(-x^2), type = "l", col = "red")
> ##D points(sol$x, sol$y, pch = "*")
> ##D grid()
> ## End(Not run)
> 
> ##  Example2: Chemical process
>   f <- function(t, u) {
+     u1 <- u[3] - 0.1 * (t+1) * u[1]
+     u2 <- 0.1 * (t+1) * u[1] - 2 * u[2]
+     u3 <- 2 * u[2] - u[3]
+     return(c(u1, u2, u3))
+   }
> u0 <- c(0.8696, 0.0435, 0.0870)
> a <- 0; b <- 40
> n <- 40
> sol <- rk4sys(f, a, b, u0, n)
> ## Not run: 
> ##D matplot(sol$x, sol$y, type = "l", lty = 1, lwd = c(2, 1, 1),
> ##D         col = c("darkred", "darkblue", "darkgreen"),
> ##D         xlab = "Time [min]", ylab= "Concentration [Prozent]",
> ##D         main = "Chemical composition")
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("rkf54")
> ### * rkf54
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rkf54
> ### Title: Runge-Kutta-Fehlberg
> ### Aliases: rkf54
> ### Keywords: ode
> 
> ### ** Examples
> 
> # Example: y' = 1 + y^2
> f1 <- function(x, y)  1 + y^2
> sol11 <- rkf54(f1, 0, 1.1, 0.5, control = list(hmin = 0.01))
> sol12 <- rkf54(f1, 0, 1.1, 0.5, control = list(jmax =  250))
> 
> # Riccati equation: y' = x^2 + y^2
> f2 <- function(x, y)  x^2 + y^2
> sol21 <- rkf54(f2, 0, 1.5, 0.5, control = list(hmin = 0.01))
> sol22 <- rkf54(f2, 0, 1.5, 0.5, control = list(jmax =  250))
> 
> ## Not run: 
> ##D plot(0, 0, type = "n", xlim = c(0, 1.5), ylim = c(0, 20),
> ##D      main = "Riccati", xlab = "", ylab = "")
> ##D points(sol11$x, sol11$y, pch = "*", col = "darkgreen")
> ##D lines(sol12$x, sol12$y)
> ##D points(sol21$x, sol21$y, pch = "*", col = "blue")
> ##D lines(sol22$x, sol22$y)
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("rmserr")
> ### * rmserr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rmserr
> ### Title: Accuracy Measures
> ### Aliases: rmserr
> ### Keywords: stat
> 
> ### ** Examples
> 
> x <- rep(1, 10)
> y <- rnorm(10, 1, 0.1)
> rmserr(x, y, summary = TRUE)
-- Error Terms --------------------------------------------------
 MAE:   0.0650   	- mean absolute error (in range [ 1 1 ])
 MSE:   0.0057   	- mean squared error (the variance?!)
 RMSE:  0.0752   	- root mean squared error (std. dev.)
 MAPE:  0.0650   	- mean absolute percentage error
 LMSE:    Inf   	- normalized mean squared error
 rSTD:  0.0752   	- relative standard deviation ( 1 )
-----------------------------------------------------------------
> 
> 
> 
> cleanEx()
> nameEx("romberg")
> ### * romberg
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: romberg
> ### Title: Romberg Integration
> ### Aliases: romberg
> ### Keywords: math
> 
> ### ** Examples
> 
> romberg(sin, 0, pi, tol = 1e-15)    #  2                 , rel.error 1e-15
$value
[1] 2

$iter
[1] 6

$rel.error
[1] 0

> romberg(exp, 0, 1,  tol = 1e-15)    #  1.718281828459044 , rel error 1e-15
$value
[1] 1.718282

$iter
[1] 7

$rel.error
[1] 0

>                                     #  1.718281828459045 , i.e. exp(1) - 1
> 
> f <- function(x, p) sin(x) * cos(p*x)
> romberg(f, 0, pi, p = 2)            #  2/3               , abs.err 1.5e-14
$value
[1] -0.6666667

$iter
[1] 7

$rel.error
[1] 5.995204e-15

> # value: -0.6666667, iter: 7, rel.error: 1e-12
> 
> 
> 
> cleanEx()
> nameEx("roots")
> ### * roots
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: roots, polyroots
> ### Title: Polynomial Roots
> ### Aliases: roots rootsmult polyroots
> ### Keywords: math
> 
> ### ** Examples
> 
>   roots(c(1, 0, 1, 0, 0))                     # 0 0 1i -1i
[1] 0+0i 0+0i 0+1i 0-1i
>   p <- Poly(c(-2, -1, 0, 1, 2))               # 1*x^5 - 5*x^3 + 4*x
>   roots(p)                                    # 0 -2  2 -1  1
[1]  0 -2  2 -1  1
> 
>   p <- Poly(c(rep(1, 4), rep(-1, 4), 0, 0))   # 1  0 -4  0  6  0 -4  0  1
>   rootsmult(p, 1.0); rootsmult(p, -1.0)       # 4  4
[1] 4
[1] 4
>   polyroots(p)
  root mult
1    0    2
2    1    4
3   -1    4
>   ##   root mult
>   ## 1    0    2
>   ## 2    1    4
>   ## 3   -1    4
> 
> 
> 
> cleanEx()
> nameEx("rosser")
> ### * rosser
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rosser
> ### Title: Rosser Matrix
> ### Aliases: rosser
> ### Keywords: specmat
> 
> ### ** Examples
> 
> rosser()
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
[1,]  611  196 -192  407   -8  -52  -49   29
[2,]  196  899  113 -192  -71  -43   -8  -44
[3,] -192  113  899  196   61   49    8   52
[4,]  407 -192  196  611    8   44   59  -23
[5,]   -8  -71   61    8  411 -599  208  208
[6,]  -52  -43   49   44 -599  411  208  208
[7,]  -49   -8    8   59  208  208   99 -911
[8,]   29  -44   52  -23  208  208 -911   99
> 
> 
> 
> cleanEx()
> nameEx("rot90")
> ### * rot90
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rot90
> ### Title: Matrix Rotation
> ### Aliases: rot90
> ### Keywords: manip
> 
> ### ** Examples
> 
> a <- matrix(1:12, nrow=3, ncol=4, byrow=TRUE)
> rot90(a)
     [,1] [,2] [,3]
[1,]    4    8   12
[2,]    3    7   11
[3,]    2    6   10
[4,]    1    5    9
> rot90(a, 2)
     [,1] [,2] [,3] [,4]
[1,]   12   11   10    9
[2,]    8    7    6    5
[3,]    4    3    2    1
> rot90(a, -1)
     [,1] [,2] [,3]
[1,]    9    5    1
[2,]   10    6    2
[3,]   11    7    3
[4,]   12    8    4
> 
> 
> 
> cleanEx()
> nameEx("rref")
> ### * rref
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rref
> ### Title: Reduced Row Echelon Form
> ### Aliases: rref
> ### Keywords: math
> 
> ### ** Examples
> 
> A <- matrix(c(1, 2, 3, 1, 3, 2, 3, 2, 1), 3, 3, byrow = TRUE)
> rref(A)       
     [,1] [,2] [,3]
[1,]    1    0    0
[2,]    0    1    0
[3,]    0    0    1
> #      [,1] [,2] [,3]
> # [1,]    1    0    0
> # [2,]    0    1    0
> # [3,]    0    0    1
> 
> A <- matrix(data=c(1, 2, 3, 2, 5, 9, 5, 7, 8,20, 100, 200),
+             nrow=3, ncol=4, byrow=FALSE)  
> rref(A)
     [,1] [,2] [,3] [,4]
[1,]    1    0    0  120
[2,]    0    1    0    0
[3,]    0    0    1  -20
> #   1    0    0  120
> #   0    1    0    0
> #   0    0    1  -20
> 
> # Use rref on a rank-deficient magic square:
> A = magic(4)
> R = rref(A)
> zapsmall(R)
     [,1] [,2] [,3] [,4]
[1,]    1    0    0    1
[2,]    0    1    0    3
[3,]    0    0    1   -3
[4,]    0    0    0    0
> #   1    0    0    1
> #   0    1    0    3
> #   0    0    1   -3
> #   0    0    0    0
> 
> 
> 
> cleanEx()
> nameEx("runge")
> ### * runge
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: runge
> ### Title: Runge Function
> ### Aliases: runge
> ### Keywords: math
> 
> ### ** Examples
> 
> ## Not run: 
> ##D x <- seq(-1, 1, length.out = 101)
> ##D y <- runge(x)
> ##D plot(x, y, type = "l", lwd = 2, col = "navy", ylim = c(-0.2, 1.2))
> ##D grid()
> ##D 
> ##D n <- c(6, 11, 16)
> ##D for (i in seq(along=n)) {
> ##D     xp <- seq(-1, 1, length.out = n[i])
> ##D     yp <- runge(xp)
> ##D     p  <- polyfit(xp, yp, n[i]-1)
> ##D     y  <- polyval(p, x)
> ##D     lines(x, y, lty=i) }
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("savgol")
> ### * savgol
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: savgol
> ### Title: Savitzky-Golay Smoothing
> ### Aliases: savgol
> ### Keywords: timeseries
> 
> ### ** Examples
> 
> # *** Sinosoid test function ***
> ts <- sin(2*pi*(1:1000)/200)
> t1 <- ts + rnorm(1000)/10
> t2 <- savgol(t1, 51)
> ## Not run: 
> ##D plot( 1:1000, t1, col = "grey")
> ##D lines(1:1000, ts, col = "blue")
> ##D lines(1:1000, t2, col = "red")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("segm_distance")
> ### * segm_distance
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: segm_distance
> ### Title: Segment Distance
> ### Aliases: segm_distance
> ### Keywords: geom
> 
> ### ** Examples
> 
> ## Not run: 
> ##D plot(c(0, 1), c(0, 1), type = "n", asp=1, 
> ##D      xlab = "", ylab = "", main = "Segment Distances")
> ##D grid()
> ##D for (i in 1:20) {
> ##D     s1 <- matrix(runif(4), 2, 2)
> ##D     s2 <- matrix(runif(4), 2, 2)
> ##D     lines(s1[, 1], s1[, 2], col = "red")
> ##D     lines(s2[, 1], s2[, 2], col = "darkred")
> ##D     S <- segm_distance(s1[1,], s1[2,], s2[1,], s2[2,])
> ##D     S$d
> ##D     points(c(S$p[1], S$q[1]), c(S$p[2], S$q[2]), pch=20, col="navy")
> ##D     lines(c(S$p[1], S$q[1]), c(S$p[2], S$q[2]), col="gray")
> ##D }
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("segm_intersect")
> ### * segm_intersect
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: segm_intersect
> ### Title: Segment Intersection
> ### Aliases: segm_intersect
> ### Keywords: geom
> 
> ### ** Examples
> 
> ## Not run: 
> ##D plot(c(0, 1), c(0, 1), type="n",
> ##D      xlab = "", ylab = "", main = "Segment Intersection")
> ##D grid()
> ##D for (i in 1:20) {
> ##D s1 <- matrix(runif(4), 2, 2)
> ##D s2 <- matrix(runif(4), 2, 2)
> ##D if (segm_intersect(s1, s2)) {
> ##D     clr <- "red"
> ##D     p1 <- s1[1, ]; p2 <- s1[2, ]; p3 <- s2[1, ]; p4 <- s2[2, ]
> ##D     A <- cbind(p2 - p1, p4 - p3)
> ##D     b <- (p3 - p1)
> ##D     a <- solve(A, b)
> ##D     points((p1 + a[1]*(p2-p1))[1], (p1 + a[1]*(p2-p1))[2], pch = 19, col = "blue")
> ##D } else
> ##D     clr <- "darkred"
> ##D lines(s1[,1], s1[, 2], col = clr)
> ##D lines(s2[,1], s2[, 2], col = clr)
> ##D }
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("semilog")
> ### * semilog
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: semilogx,semilogy
> ### Title: Semi-logarithmic Plots (Matlab Style)
> ### Aliases: semilogx semilogy loglog
> ### Keywords: graphs
> 
> ### ** Examples
> 
> ## Not run: 
> ##D x <- logspace(-1, 2)
> ##D loglog(x, exp(x), type = 'b')
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("shooting")
> ### * shooting
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: shooting
> ### Title: Shooting Method
> ### Aliases: shooting
> ### Keywords: ode
> 
> ### ** Examples
> 
> #-- Example 1
> f <- function(t, y1, y2) -2*y1*y2
> h <- function(u, v) u + v - 0.25
> 
> t0 <- 0; tfinal <- 1
> y0 <- 1
> sol <- shooting(f, t0, tfinal, y0, h, 0, 1)
> ## Not run: 
> ##D plot(sol$t, sol$y[, 1], type='l', ylim=c(-1, 1))
> ##D xs <- linspace(0, 1); ys <- 1/(xs+1)
> ##D lines(xs, ys, col="red")
> ##D lines(sol$t, sol$y[, 2], col="gray")
> ##D grid()
> ## End(Not run)
> 
> #-- Example 2
> f <- function(t, y1, y2) -y2^2 / y1
> h <- function(u, v) u - 2
> t0 <- 0; tfinal <- 1
> y0 <- 1
> sol <- shooting(f, t0, tfinal, y0, h, 0, 1)
> 
> 
> 
> cleanEx()
> nameEx("shubert")
> ### * shubert
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: shubert
> ### Title: Shubert-Piyavskii Method
> ### Aliases: shubert
> ### Keywords: optimize
> 
> ### ** Examples
> 
> # Determine the global minimum of sin(1.2*x)+sin(3.5*x) in [-3, 8].
> f <- function(x) sin(1.2*x) + sin(3.5*x)
> shubert(function(x) -f(x), -3, 8, 5, 1e-04, 1000)
$xopt
[1] 3.216231

$fopt
[1] 1.623964

$nopt
[1] 480

> ## $xopt
> ## [1] 3.216231     # 3.216209
> ## $fopt
> ## [1] 1.623964
> ## $nopt
> ## [1] 481
> 
> 
> 
> cleanEx()
> nameEx("sici")
> ### * sici
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Si, Ci
> ### Title: Sine and Cosine Integral Functions
> ### Aliases: Si Ci
> ### Keywords: specfun
> 
> ### ** Examples
> 
> x <- c(-3:3) * pi
> Si(x); Ci(x)
[1] -1.674762 -1.418152 -1.851937  0.000000  1.851937  1.418152  1.674762
[1]  0.01062020 -0.02256066  0.07366791        -Inf  0.07366791 -0.02256066
[7]  0.01062020
> 
> ## Not run: 
> ##D xs <- linspace(0, 10*pi, 200)
> ##D ysi <- Si(xs); yci <- Ci(xs)
> ##D plot(c(0, 35), c(-1.5, 2.0), type = 'n', xlab = '', ylab = '',
> ##D      main = "Sine and cosine integral functions")
> ##D lines(xs, ysi, col = "darkred",  lwd = 2)
> ##D lines(xs, yci, col = "darkblue", lwd = 2)
> ##D lines(c(0, 10*pi), c(pi/2, pi/2), col = "gray")
> ##D lines(xs, cos(xs), col = "gray")
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("sigmoid")
> ### * sigmoid
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sigmoid
> ### Title: Sigmoid Function
> ### Aliases: sigmoid logit
> 
> ### ** Examples
> 
> x <- seq(-6, 6, length.out = 101)
> y1 <- sigmoid(x)
> y2 <- sigmoid(x, a = 2)
> ## Not run: 
> ##D plot(x, y1, type = "l", col = "darkblue", 
> ##D         xlab = "", ylab = "", main = "Sigmoid Function(s)")
> ##D lines(x, y2, col = "darkgreen")
> ##D grid()
> ## End(Not run)
> 
> # The slope in 0 (in x = b) is a/4
> # sigmf with slope 1 and range [-1, 1].
> sigmf <- function(x) 2 * sigmoid(x, a = 2) - 1
> 
> # logit is the inverse of the sigmoid function
> x <- c(-0.75, -0.25, 0.25, 0.75)
> y <- sigmoid(x)
> logit(y)        #=> -0.75 -0.25  0.25  0.75
[1] -0.75 -0.25  0.25  0.75
> 
> 
> 
> cleanEx()
> nameEx("simpadpt")
> ### * simpadpt
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: simpadpt
> ### Title: Adaptive Simpson Quadrature
> ### Aliases: simpadpt
> ### Keywords: math
> 
> ### ** Examples
> 
> myf <- function(x, n) 1/(x+n)  # 0.0953101798043249 , log((n+1)/n) for n=10
> simpadpt(myf, 0, 1, n = 10)    # 0.095310179804535
[1] 0.09531018
> 
> ##  Dilogarithm function
> flog  <- function(t) log(1-t) / t  # singularity at t=1, almost at t=0
> dilog <- function(x) simpadpt(flog, x, 0, tol = 1e-12)
> dilog(1)  # 1.64493406685615
[1] 1.644934
>           # 1.64493406684823 = pi^2/6
> 
> ## Not run: 
> ##D N <- 51
> ##D xs <- seq(-5, 1, length.out = N)
> ##D ys <- numeric(N)
> ##D for (i in 1:N) ys[i] <- dilog(xs[i])
> ##D plot(xs, ys, type = "l", col = "blue",
> ##D              main = "Dilogarithm function")
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("simpson2d")
> ### * simpson2d
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: simpson2d
> ### Title: Double Simpson Integration
> ### Aliases: simpson2d
> ### Keywords: math
> 
> ### ** Examples
> 
> f1 <- function(x, y) x^2 + y^2
> simpson2d(f1, -1, 1, -1, 1)     #   2.666666667 , i.e. 8/3 . err = 0
[1] 2.666667
> 
> f2 <- function(x, y) y*sin(x)+x*cos(y)
> simpson2d(f2, pi, 2*pi, 0, pi)  #  -9.869604401 , i.e. -pi^2, err = 2e-8
[1] -9.869604
> 
> f3 <- function(x, y) sqrt((1 - (x^2 + y^2)) * (x^2 + y^2 <= 1))
> simpson2d(f3, -1, 1, -1, 1)     #   2.094393912 , i.e. 2/3*pi , err = 1e-6
[1] 2.094394
> 
> 
> 
> cleanEx()
> nameEx("sind")
> ### * sind
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sind,cosd,tand, etc.
> ### Title: Trigonometric Functions in Degrees
> ### Aliases: sind cosd tand cotd asind acosd atand acotd secd cscd asecd
> ###   acscd atan2d
> ### Keywords: math
> 
> ### ** Examples
> 
> # sind(x) and cosd(x) are accurate for x which are multiples
> # of 90 and 180 degrees, while tand(x) is problematic.
> 
> x <- seq(0, 720, by = 90)
> sind(x)                     # 0  1  0 -1  0  1  0 -1  0
[1]  0  1  0 -1  0  1  0 -1  0
> cosd(x)                     # 1  0 -1  0  1  0 -1  0  1
[1]  1  0 -1  0  1  0 -1  0  1
> tand(x)                     # 0  Inf  0  -Inf  0  Inf  0  -Inf  0
[1]    0  Inf    0 -Inf    0  Inf    0 -Inf    0
> cotd(x)                     # Inf  0  -Inf  0  Inf  0  -Inf  0  Inf
[1]  Inf    0 -Inf    0  Inf    0 -Inf    0  Inf
> 
> x <- seq(5, 85, by = 20)
> asind(sind(x))              # 5 25 45 65 85
[1]  5 25 45 65 85
> asecd(sec(x))
[1]  73.521102   7.605512  58.310078 124.225668 169.858741
> tand(x)                     # 0.08748866  0.46630766  1.00000000  ...
[1]  0.08748866  0.46630766  1.00000000  2.14450692 11.43005230
> atan2d(1, 1)                # 45
[1] 45
> 
> 
> 
> cleanEx()
> nameEx("size")
> ### * size
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: size
> ### Title: Size of Matrix
> ### Aliases: size
> ### Keywords: array
> 
> ### ** Examples
> 
> size(1:8)
[1] 1 8
> size(matrix(1:8, 2, 4))		# 2 4
[1] 2 4
> size(matrix(1:8, 2, 4), 2)	# 4
[1] 4
> size(matrix(1:8, 2, 4), 3)	# 1
[1] 1
> 
> 
> 
> cleanEx()
> nameEx("softline")
> ### * softline
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: softline
> ### Title: Soft (Inexact) Line Search
> ### Aliases: softline
> ### Keywords: optimize
> 
> ### ** Examples
> 
> ##  Himmelblau function
>   f_himm <- function(x) (x[1]^2 + x[2] - 11)^2 + (x[1] + x[2]^2 - 7)^2
>   g_himm <- function(x) {
+     w1 <- (x[1]^2 + x[2] - 11); w2 <- (x[1] + x[2]^2 - 7)
+     g1 <- 4*w1*x[1] + 2*w2;     g2 <- 2*w1 + 4*w2*x[2]
+     c(g1, g2)
+   }
>   # Find inexact minimum from [6, 6] in the direction [-1, -1] !
>   softline(c(6, 6), c(-1, -1), f_himm, g_himm)
[1] 3.458463
>   # [1] 3.458463
> 
>   # Find the same minimum by using the numerical gradient
>   softline(c(6, 6), c(-1, -1), f_himm)
[1] 3.458463
>   # [1] 3.458463
> 
> 
> 
> cleanEx()
> nameEx("sorting")
> ### * sorting
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sorting
> ### Title: Sorting Routines
> ### Aliases: bubbleSort insertionSort selectionSort shellSort heapSort
> ###   mergeSort mergeOrdered quickSort quickSortx is.sorted testSort
> ### Keywords: array
> 
> ### ** Examples
> 
> ## Not run: 
> ##D testSort(100)
> ##D 
> ##D a <- sort(runif(1000)); b <- sort(runif(1000))
> ##D system.time(y <- mergeSort(c(a, b)))
> ##D system.time(y <- mergeOrdered(a, b))
> ##D is.sorted(y)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("sortrows")
> ### * sortrows
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sortrows
> ### Title: Sort Rows of a Matrix (Matlab Style)
> ### Aliases: sortrows
> ### Keywords: array
> 
> ### ** Examples
> 
> A <- magic(5)
> sortrows(A)
     [,1] [,2] [,3] [,4] [,5]
[1,]    4    6   13   20   22
[2,]   10   12   19   21    3
[3,]   11   18   25    2    9
[4,]   17   24    1    8   15
[5,]   23    5    7   14   16
> sortrows(A, k = 2)
     [,1] [,2] [,3] [,4] [,5]
[1,]   23    5    7   14   16
[2,]    4    6   13   20   22
[3,]   10   12   19   21    3
[4,]   11   18   25    2    9
[5,]   17   24    1    8   15
> 
> 
> 
> cleanEx()
> nameEx("spinterp")
> ### * spinterp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: spinterp
> ### Title: Monotone (Shape-Preserving) Interpolation
> ### Aliases: spinterp
> ### Keywords: math
> 
> ### ** Examples
> 
> data1 <- list(x = c(1,2,3,5,6,8,9,11,12,14,15),
+               y = c(rep(10,6), 10.5,15,50,60,95))
> data2 <- list(x = c(0,1,4,6.5,9,10),
+               y = c(10,4,2,1,3,10))
> data3 <- list(x = c(7.99,8.09,8.19,8.7,9.2,10,12,15,20),
+               y = c(0,0.000027629,0.00437498,0.169183,0.469428,
+                     0.94374,0.998636,0.999919,0.999994))
> data4 <- list(x = c(22,22.5,22.6,22.7,22.8,22.9,
+                     23,23.1,23.2,23.3,23.4,23.5,24),
+               y = c(523,543,550,557,565,575,
+                     590,620,860,915,944,958,986))
> data5 <- list(x = c(0,1.1,1.31,2.5,3.9,4.4,5.5,6,8,10.1),
+               y = c(10.1,8,4.7,4.0,3.48,3.3,5.8,7,7.7,8.6))
> 
> data6 <- list(x = c(-0.8, -0.75, -0.3, 0.2, 0.5),
+               y = c(-0.9,  0.3,   0.4, 0.5, 0.6))
> data7 <- list(x = c(-1, -0.96, -0.88, -0.62, 0.13, 1),
+               y = c(-1, -0.4,   0.3,   0.78, 0.91, 1))
> 
> data8 <- list(x = c(-1, -2/3, -1/3, 0.0, 1/3, 2/3, 1),
+               y = c(-1, -(2/3)^3, -(1/3)^3, -(1/3)^3, (1/3)^3, (1/3)^3, 1))
> 
> ## Not run: 
> ##D opr <- par(mfrow=c(2,2))
> ##D 
> ##D # These are well-known test cases:
> ##D D <- data1
> ##D plot(D, ylim=c(0, 100)); grid()
> ##D xp <- seq(1, 15, len=51); yp <- spinterp(D$x, D$y, xp)
> ##D lines(spline(D), col="blue")
> ##D lines(xp, yp, col="red")
> ##D 
> ##D D <- data3
> ##D plot(D, ylim=c(0, 1.2)); grid()
> ##D xp <- seq(8, 20, len=51); yp <- spinterp(D$x, D$y, xp)
> ##D lines(spline(D), col="blue")
> ##D lines(xp, yp, col="red")
> ##D 
> ##D D <- data4
> ##D plot(D); grid()
> ##D xp <- seq(22, 24, len=51); yp <- spinterp(D$x, D$y, xp)
> ##D lines(spline(D), col="blue")
> ##D lines(xp, yp, col="red")
> ##D 
> ##D # Fix a horizontal slope at the end points
> ##D D <- data8
> ##D x <- c(-1.05, D$x, 1.05); y <- c(-1, D$y, 1)
> ##D plot(D); grid()
> ##D xp <- seq(-1, 1, len=101); yp <- spinterp(x, y, xp)
> ##D lines(spline(D, n=101), col="blue")
> ##D lines(xp, yp, col="red")
> ##D 
> ##D par(opr)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("sqrtm")
> ### * sqrtm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sqrtm,rootm
> ### Title: Matrix Square and p-th Roots
> ### Aliases: sqrtm signm rootm
> ### Keywords: math
> 
> ### ** Examples
> 
> A1 <- matrix(c(10,  7,  8,  7,
+                 7,  5,  6,  5,
+                 8,  6, 10,  9,
+                 7,  5,  9, 10), nrow = 4, ncol = 4, byrow = TRUE)
> 
> X <- sqrtm(A1)$B    # accuracy: 2.352583e-13
> X 
          [,1]      [,2]      [,3]      [,4]
[1,] 2.3890626 1.5169891 1.0775577 0.9110397
[2,] 1.5169891 1.1817697 0.9913897 0.5650760
[3,] 1.0775577 0.9913897 2.3567457 1.5171571
[4,] 0.9110397 0.5650760 1.5171571 2.5590877
> 
> A2 <- matrix(c(90.81, 8.33, 0.68, 0.06, 0.08, 0.02, 0.01, 0.01,
+                 0.70, 90.65, 7.79, 0.64, 0.06, 0.13, 0.02, 0.01,
+                 0.09, 2.27, 91.05, 5.52, 0.74, 0.26, 0.01, 0.06,
+                 0.02, 0.33, 5.95, 85.93, 5.30, 1.17, 1.12, 0.18,
+                 0.03, 0.14, 0.67, 7.73, 80.53, 8.84, 1.00, 1.06,
+                 0.01, 0.11, 0.24, 0.43, 6.48, 83.46, 4.07, 5.20,
+                 0.21, 0, 0.22, 1.30, 2.38, 11.24, 64.86, 19.79,
+                 0, 0, 0, 0, 0, 0, 0, 100
+               ) / 100, nrow = 8, ncol = 8, byrow = TRUE)
> 
> X <- rootm(A2, 12)  # k = 6, accuracy: 2.208596e-14
> 
> ##  Matrix sign function
> signm(A1)                               # 4x4 identity matrix
              [,1]          [,2]          [,3]          [,4]
[1,]  1.000015e+00 -2.550473e-05  6.405134e-06 -3.799018e-06
[2,] -2.550473e-05  1.000042e+00 -1.060501e-05  6.290052e-06
[3,]  6.405134e-06 -1.060501e-05  1.000003e+00 -1.579653e-06
[4,] -3.799018e-06  6.290053e-06 -1.579653e-06  1.000001e+00
> B <- rbind(cbind(zeros(4,4), A1),
+            cbind(eye(4), zeros(4,4)))
> signm(B)                                # [0, signm(A1)$B; signm(A1)$Binv 0]
           [,1]      [,2]       [,3]       [,4]      [,5]      [,6]      [,7]
[1,]  0.0000000  0.000000  0.0000000  0.0000000 2.3890626 1.5169891 1.0775577
[2,]  0.0000000  0.000000  0.0000000  0.0000000 1.5169891 1.1817697 0.9913897
[3,]  0.0000000  0.000000  0.0000000  0.0000000 1.0775577 0.9913897 2.3567457
[4,]  0.0000000  0.000000  0.0000000  0.0000000 0.9110397 0.5650760 1.5171571
[5,]  2.8393485 -4.004388  0.7564798 -0.5750778 0.0000000 0.0000000 0.0000000
[6,] -4.0043881  6.960920 -1.6584730  0.8717450 0.0000000 0.0000000 0.0000000
[7,]  0.7564798 -1.658473  1.1542095 -0.5873722 0.0000000 0.0000000 0.0000000
[8,] -0.5750778  0.871745 -0.5873722  0.7512257 0.0000000 0.0000000 0.0000000
          [,8]
[1,] 0.9110397
[2,] 0.5650760
[3,] 1.5171571
[4,] 2.5590877
[5,] 0.0000000
[6,] 0.0000000
[7,] 0.0000000
[8,] 0.0000000
> 
> 
> 
> cleanEx()
> nameEx("squareform")
> ### * squareform
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: squareform
> ### Title: Format Distance Matrix (Matlab Style)
> ### Aliases: squareform
> ### Keywords: array
> 
> ### ** Examples
> 
> x <- 1:6
> y <- squareform(x)
> #  0  1  2  3
> #  1  0  4  5
> #  2  4  0  6
> #  3  5  6  0
> all(squareform(y) == x)
[1] TRUE
> # TRUE
> 
> 
> 
> cleanEx()
> nameEx("std")
> ### * std
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: std
> ### Title: Standard Deviation (Matlab Style)
> ### Aliases: std
> ### Keywords: stat
> 
> ### ** Examples
> 
> std(1:10)          # 3.027650
[1] 3.02765
> std(1:10, flag=1)  # 2.872281
[1] 2.872281
> 
> 
> 
> cleanEx()
> nameEx("std_err")
> ### * std_err
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: std_err
> ### Title: Standard Error
> ### Aliases: std_err
> ### Keywords: stat
> 
> ### ** Examples
> 
> std_err(1:10)  #=> 0.9574271
[1] 0.9574271
> 
> 
> 
> cleanEx()
> nameEx("steep_descent")
> ### * steep_descent
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: steep_descent
> ### Title: Steepest Descent Minimization
> ### Aliases: steep_descent
> ### Keywords: optimize
> 
> ### ** Examples
> 
> ##  Rosenbrock function: The flat valley of the Rosenbruck function makes
> ##  it infeasible for a steepest descent approach.
> # rosenbrock <- function(x) {
> #     n <- length(x)
> #     x1 <- x[2:n]
> #     x2 <- x[1:(n-1)]
> #     sum(100*(x1-x2^2)^2 + (1-x2)^2)
> # }
> # steep_descent(c(1, 1), rosenbrock)
> # Warning message:
> # In steep_descent(c(0, 0), rosenbrock) :
> #   Maximum number of iterations reached -- not converged.
> 
> ## Sphere function
> sph <- function(x) sum(x^2)
> steep_descent(rep(1, 10), sph)
$xmin
 [1] -2.220446e-16 -2.220446e-16 -2.220446e-16 -2.220446e-16 -2.220446e-16
 [6] -2.220446e-16 -2.220446e-16 -2.220446e-16 -2.220446e-16 -2.220446e-16

$fmin
[1] 4.930381e-31

$niter
[1] 2

> # $xmin   0 0 0 0 0 0 0 0 0 0
> # $fmin   0
> # $niter  2
> 
> 
> 
> cleanEx()
> nameEx("stereographic")
> ### * stereographic
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stereographic
> ### Title: Stereographic Projection
> ### Aliases: stereographic stereographic_inv
> ### Keywords: manip
> 
> ### ** Examples
> 
> # points in the xy-plane (i.e., z = 0)
> A <- matrix(c(1,0,0, -1,0,0, 0,1,0, 0,-1,0), nrow = 3)
> B <- stereographic(A); B
     [,1] [,2] [,3] [,4]
[1,]    2   -2    0    0
[2,]    0    0    2   -2
[3,]    1    1    1    1
> ##      [,1] [,2] [,3] [,4]
> ## [1,]    2   -2    0    0
> ## [2,]    0    0    2   -2
> ## [3,]    1    1    1    1
> 
> stereographic_inv(B)
     [,1] [,2] [,3] [,4]
[1,]    1   -1    0    0
[2,]    0    0    1   -1
[3,]    0    0    0    0
> ##      [,1] [,2] [,3] [,4]
> ## [1,]    1   -1    0    0
> ## [2,]    0    0    1   -1
> ## [3,]    0    0    0    0
> 
> stereographic_inv(c(2,0,2))     # not correct: z = 2
     [,1]
[1,]  1.0
[2,]  0.0
[3,]  0.5
> ##      [,1]
> ## [1,]  1.0
> ## [2,]  0.0
> ## [3,]  0.5
> 
> ## Not run: 
> ##D # Can be used for optimization with sum(x^2) == 1
> ##D # Imagine to maximize the product x*y*z for x^2 + y^2 + z^2 == 1 !
> ##D   fnObj <- function(x) {                # length(x) = 2
> ##D     x1 <- stereographic_inv(c(x, 1))    # on S^2
> ##D     return( -prod(x1) )                 # Maximize
> ##D   }
> ##D   sol <- optim(c(1, 1), fnObj)
> ##D   -sol$value                            # the maximal product
> ##D   ## [1] 0.1924501                      #   1/3 * sqrt(1/3)
> ##D   stereographic_inv(c(sol$par, 1))      # the solution coordinates
> ##D                [,1]                     #   on S^2
> ##D   ## [1,] 0.5773374                     # by symmetry must be
> ##D   ## [2,] 0.5773756                     # sqrt(1/3) = 0.5773503...
> ##D   ## [3,] 0.5773378
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("str2num")
> ### * str2num
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: str2num
> ### Title: Converting string to number (Matlab style)
> ### Aliases: str2num num2str
> ### Keywords: manip
> 
> ### ** Examples
> 
> str1 <- " [1 2 3; 4, 5, 6; 7,8,9]  "
> str2num(str1)
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    4    5    6
[3,]    7    8    9
> # matrix(1:9, nrow = 3, ncol = 3, byrow = TRUE)
> 
> # str2 <- " [1 2 3; 45, 6; 7,8,9]  "
> # str2num(str2)
> # Error in str2num(str2) : 
> #   All rows in Argument 's' must have the same length.
> 
> A <- matrix(c(pi, 0, exp(1), 1), 2, 2)
> B <- num2str(A, 2); b <- dim(B)
> B <- as.numeric(B); dim(B) <- b
> B
     [,1] [,2]
[1,] 3.14 2.72
[2,] 0.00 1.00
> #      [,1] [,2]
> # [1,] 3.14 2.72
> # [2,] 0.00 1.00
> 
> 
> 
> cleanEx()
> nameEx("strcat")
> ### * strcat
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: strcat
> ### Title: String Concatenation
> ### Aliases: strcat
> ### Keywords: string
> 
> ### ** Examples
> 
> strcat(c("a", "b", "c"))                        #=> "abc"
[1] "abc"
> strcat(c("a", "b"), c("1", "2"), collapse="x")  #=> "ax1" "ax2" "bx1" "bx2"
[1] "ax1" "ax2" "bx1" "bx2"
> 
> 
> 
> cleanEx()
> nameEx("strcmp")
> ### * strcmp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: strcmp
> ### Title: String Comparison
> ### Aliases: strcmp strcmpi
> ### Keywords: string
> 
> ### ** Examples
> 
> strcmp(c("yes", "no"), c("yes", "no"))
[1] TRUE
> strcmpi(c("yes", "no"), c("Yes", "No"))
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("strfind")
> ### * strfind
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: strfind
> ### Title: Find Substrings
> ### Aliases: strfind strfindi findstr
> ### Keywords: string
> 
> ### ** Examples
> 
> S <- c("", "ab", "aba", "aba aba", "abababa")
> s <- "aba"
> strfind(S, s)
[[1]]
NULL

[[2]]
NULL

[[3]]
[1] 1

[[4]]
[1] 1 5

[[5]]
[1] 1 3 5

> strfindi(toupper(S), s)
[[1]]
NULL

[[2]]
NULL

[[3]]
[1] 1

[[4]]
[1] 1 5

[[5]]
[1] 1 3 5

> strfind(S, s, overlap = FALSE)
[[1]]
NULL

[[2]]
NULL

[[3]]
[1] 1

[[4]]
[1] 1 5

[[5]]
[1] 1 5

> 
> 
> 
> cleanEx()
> nameEx("strjust")
> ### * strjust
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: strjust
> ### Title: Justify character vector
> ### Aliases: strjust
> ### Keywords: string
> 
> ### ** Examples
> 
> S <- c("abc", "letters", "1", "2  2")
> strjust(S, "left")
[1] "abc    " "letters" "1      " "2  2   "
> 
> 
> 
> cleanEx()
> nameEx("strrep")
> ### * strrep
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: strRep
> ### Title: Find and replace substring
> ### Aliases: strRep
> ### Keywords: string
> 
> ### ** Examples
> 
> S <- c('This is a good example.', "He has a good character.",
+        'This is good, good food.', "How goodgood this is!")
> strRep(S, 'good', 'great')
[1] "This is a great example."   "He has a great character." 
[3] "This is great, great food." "How greatgreat this is!"   
> 
> 
> 
> cleanEx()
> nameEx("strtrim")
> ### * strtrim
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: strTrim
> ### Title: Remove leading and trailing white space.
> ### Aliases: strTrim deblank
> ### Keywords: string
> 
> ### ** Examples
> 
> s <- c("  abc", "abc   ", " abc ", " a b c ", "abc", "a b c")
> strTrim(s)
[1] "abc"   "abc"   "abc"   "a b c" "abc"   "a b c"
> deblank(s)
[1] "  abc"  "abc"    " abc"   " a b c" "abc"    "a b c" 
> 
> 
> 
> cleanEx()
> nameEx("subspace")
> ### * subspace
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: subspace
> ### Title: Angle between two subspaces
> ### Aliases: subspace
> ### Keywords: array
> 
> ### ** Examples
> 
> 180 * subspace(c(1, 2), c(2, 1)) / pi  #=> 36.87
[1] 36.8699
> 180 * subspace(c(0, 1), c(1, 2)) / pi  #=> 26.565
[1] 26.56505
> 
> H <- hadamard(8)
> A <- H[, 2:4]
> B <- H[, 5:8]
> subspace(A, B)    #=> 1.5708 or pi/2, i.e. A and B are orthogonal
[1] 1.570796
> 
> 
> 
> cleanEx()
> nameEx("sumalt")
> ### * sumalt
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sumalt
> ### Title: Alternating Series Acceleration
> ### Aliases: sumalt
> ### Keywords: math
> 
> ### ** Examples
> 
> # Beispiel: Leibniz-Reihe 1 - 1/3 + 1/5 - 1/7 +- ...
> a_pi4 <- function(k) (-1)^k / (2*k + 1)
> sumalt(a_pi4, 20)  # 0.7853981633974484 = pi/4 + eps()
[1] 0.7853982
> 
> # Beispiel: Van Wijngaarden transform needs 60 terms
> n <- 60; N <- 0:n
> a <- cumsum((-1)^N / (2*N+1))
> for (i in 1:n) {
+     a <- (a[1:(n-i+1)] + a[2:(n-i+2)]) / 2
+ }
> a - pi/4  # 0.7853981633974483
[1] 0
> 
> # Beispiel: 1 - 1/2^2 + 1/3^2 - 1/4^2 +- ...
> b_alt <- function(k) (-1)^k / (k+1)^2
> sumalt(b_alt, 20)  # 0.8224670334241133 = pi^2/12 + eps()
[1] 0.822467
> 
> ## Not run: 
> ##D # Dirichlet eta() function: eta(s) = 1/1^s - 1/2^s + 1/3^s -+ ...
> ##D   eta_ <- function(s) {
> ##D     eta_alt <- function(k) (-1)^k / (k+1)^s
> ##D     sumalt(eta_alt, 30)
> ##D   }
> ##D   eta_(1)                       # 0.6931471805599453 = log(2)
> ##D   abs(eta_(1+1i) - eta(1+1i))   # 1.24e-16
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("taylor")
> ### * taylor
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: taylor
> ### Title: Taylor Series Approximation
> ### Aliases: taylor
> ### Keywords: math
> 
> ### ** Examples
> 
> taylor(sin, 0, 4)  #=> -0.1666666  0.0000000  1.0000000  0.0000000
[1] -0.1666666  0.0000000  1.0000000  0.0000000
> taylor(exp, 1, 4)  #=>  0.04166657 0.16666673 0.50000000 1.00000000 1.00000000
[1]  1.132622e-01 -1.965896e-06  6.795734e-01  9.060919e-01  1.019356e+00
> 
> f <- function(x) log(1+x)
> p <- taylor(f, 0, 4)
> p                     # log(1+x) = 0 + x - 1/2 x^2 + 1/3 x^3 - 1/4 x^4 +- ...
[1] -0.2500044  0.3333339 -0.5000000  1.0000000  0.0000000
>                       # [1] -0.250004  0.333334 -0.500000  1.000000  0.000000
> 
> ## Not run: 
> ##D x <- seq(-1.0, 1.0, length.out=100)
> ##D yf <- f(x)
> ##D yp <- polyval(p, x)
> ##D plot(x, yf, type = "l", col = "gray", lwd = 3)
> ##D lines(x, yp, col = "red")
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("tictoc")
> ### * tictoc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tic,toc
> ### Title: MATLAB timer functions
> ### Aliases: tic toc
> ### Keywords: utilities
> 
> ### ** Examples
> 
> tic()
> for(i in 1:100) mad(runif(1000))	# kill time
> toc()
elapsed time is 0.019000 seconds 
> 
> 
> 
> cleanEx()
> nameEx("titanium")
> ### * titanium
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: titanium
> ### Title: Titanium Test Data
> ### Aliases: titanium
> ### Keywords: datasets
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data(titanium)
> ##D plot(titanium)
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("toeplitz")
> ### * toeplitz
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Toeplitz
> ### Title: Toeplitz Matrix
> ### Aliases: Toeplitz
> ### Keywords: array
> 
> ### ** Examples
> 
> Toeplitz(c(1, 2, 3, 4, 5))
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    2    3    4    5
[2,]    2    1    2    3    4
[3,]    3    2    1    2    3
[4,]    4    3    2    1    2
[5,]    5    4    3    2    1
> Toeplitz(c(1, 2, 3, 4, 5), c(1.5, 2.5, 3.5, 4.5, 5.5))
Warning in Toeplitz(c(1, 2, 3, 4, 5), c(1.5, 2.5, 3.5, 4.5, 5.5)) :
  First elements of vectors 'a', 'b' are not equal.
     [,1] [,2] [,3] [,4] [,5]
[1,]    1  2.5  3.5  4.5  5.5
[2,]    2  1.0  2.5  3.5  4.5
[3,]    3  2.0  1.0  2.5  3.5
[4,]    4  3.0  2.0  1.0  2.5
[5,]    5  4.0  3.0  2.0  1.0
> 
> 
> 
> cleanEx()
> nameEx("trace")
> ### * trace
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Trace
> ### Title: Matrix trace
> ### Aliases: Trace
> ### Keywords: array
> 
> ### ** Examples
> 
> Trace(matrix(1:16, nrow=4, ncol=4))
[1] 34
> 
> 
> 
> cleanEx()
> nameEx("trapz")
> ### * trapz
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: trapz
> ### Title: Trapezoidal Integration
> ### Aliases: trapz cumtrapz trapzfun
> ### Keywords: math
> 
> ### ** Examples
> 
>   # Calculate the area under the sine curve from 0 to pi:
>   n <- 101
>   x <- seq(0, pi, len = n)
>   y <- sin(x)
>   trapz(x, y)                       #=> 1.999835504
[1] 1.999836
> 
>   # Use a correction term at the boundary: -h^2/12*(f'(b)-f'(a))
>   h  <- x[2] - x[1]
>   ca <- (y[2]-y[1]) / h
>   cb <- (y[n]-y[n-1]) / h
>   trapz(x, y) - h^2/12 * (cb - ca)  #=> 1.999999969
[1] 2
> 
>   # Use two complex inputs
>   z  <- exp(1i*pi*(0:100)/100)
>   ct <- cumtrapz(z, 1/z)
>   ct[101]                           #=> 0+3.14107591i
[1] 0+3.141076i
> 
>   f <- function(x) x^(3/2)          # 
>   trapzfun(f, 0, 1)                 #=> 0.4 with 11 iterations
$value
[1] 0.4

$iter
[1] 11

$rel.err
[1] 8.878171e-08

> 
> 
> 
> cleanEx()
> nameEx("tri")
> ### * tri
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tri
> ### Title: Triangular Matrices (Matlab Style)
> ### Aliases: tril triu
> ### Keywords: array
> 
> ### ** Examples
> 
> tril(ones(4,4), +1)
     [,1] [,2] [,3] [,4]
[1,]    1    1    0    0
[2,]    1    1    1    0
[3,]    1    1    1    1
[4,]    1    1    1    1
> #    1  1  0  0
> #    1  1  1  0
> #    1  1  1  1
> #    1  1  1  1
> 
> triu(ones(4,4), -1)
     [,1] [,2] [,3] [,4]
[1,]    1    1    1    1
[2,]    1    1    1    1
[3,]    0    1    1    1
[4,]    0    0    1    1
> #    1  1  1  1
> #    1  1  1  1
> #    0  1  1  1
> #    0  0  1  1
> 
> 
> 
> cleanEx()
> nameEx("trigApprox")
> ### * trigApprox
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: trigApprox
> ### Title: Trigonometric Approximation
> ### Aliases: trigApprox
> ### Keywords: math
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ##  Example: Gauss' Pallas data (1801)
> ##D asc <- seq(0, 330, by = 30)
> ##D dec <- c(408, 89, -66, 10, 338, 807, 1238, 1511, 1583, 1462, 1183, 804)
> ##D plot(2*pi*asc/360, dec, pch = "+", col = "red", xlim = c(0, 2*pi), ylim = c(-500, 2000),
> ##D      xlab = "Ascension [radians]", ylab = "Declination [minutes]",
> ##D      main = "Gauss' Pallas Data")
> ##D grid()
> ##D points(2*pi*asc/360, dec, pch = "o", col = "red")
> ##D ts <- seq(0, 2*pi, len = 100)
> ##D xs <- trigApprox(ts ,dec, 1)
> ##D lines(ts, xs, col = "black")
> ##D xs <- trigApprox(ts ,dec, 2)
> ##D lines(ts, xs, col = "blue")
> ##D legend(3, 0, c("Trig. Regression of degree 1", "Trig. Regression of degree 2",
> ##D                   "Astronomical position"), col = c("black", "blue", "red"),
> ##D                 lty = c(1,1,0), pch = c("", "", "+"))
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("trigPoly")
> ### * trigPoly
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: trigPoly
> ### Title: Trigonometric Polynomial
> ### Aliases: trigPoly
> ### Keywords: math
> 
> ### ** Examples
> 
> # Data available only from 0 to pi/2
> t <- seq(0, pi, len=7)
> x <- 0.5 + 0.25*sin(t) + 1/3*cos(t) - 1/3*sin(2*t) - 0.25*cos(2*t)
> 
> # use standard regression techniques
> A <- cbind(1, cos(t), sin(t), cos(2*t), sin(2*t))
> ab <- qr.solve(A, x)
> ab
[1]  0.5000000  0.3333333  0.2500000 -0.2500000 -0.3333333
> # [1]  0.5000000  0.3333333  0.2500000 -0.2500000 -0.3333333
> ts <- seq(0, 2*pi, length.out = 100)
> xs <- ab[1] + ab[2]*cos(ts) +
+       ab[3]*sin(ts) + ab[4]*cos(2*ts) +ab[5]*sin(2*ts)
> 
> ## Not run: 
> ##D # plot to make sure
> ##D plot(t, x, col = "red", xlim=c(0, 2*pi), ylim=c(-2,2),
> ##D            main = "Trigonometric Regression")
> ##D lines(ts, xs, col="blue")
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("trigonometric")
> ### * trigonometric
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cot,csc,sec, etc.
> ### Title: More Trigonometric Functions
> ### Aliases: cot csc sec acot acsc asec
> ### Keywords: math
> 
> ### ** Examples
> 
> cot(1+1i)       # 0.2176 - 0.8680i
[1] 0.2176216-0.8680141i
> csc(1+1i)       # 0.6215 - 0.3039i
[1] 0.621518-0.303931i
> sec(1+1i)       # 0.4983 + 0.5911i
[1] 0.498337+0.5910838i
> acot(1+1i)      # 0.5536 - 0.4024i
[1] 0.5535744-0.4023595i
> acsc(1+1i)      # 0.4523 - 0.5306i
[1] 0.4522784-0.5306375i
> asec(1+1i)      # 1.1185 + 0.5306i
[1] 1.118518+0.530638i
> 
> 
> 
> cleanEx()
> nameEx("triquad")
> ### * triquad
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: triquad
> ### Title: Gaussian Triangle Quadrature
> ### Aliases: triquad
> ### Keywords: math
> 
> ### ** Examples
> 
> x <- c(-1, 1, 0); y <- c(0, 0, 1)
> f1 <- function(x, y) x^2 + y^2
> (I <- triquad(f1, x, y))                        # 0.3333333333333333
[1] 0.3333333
> 
> # split the unit square
> x1 <- c(0, 1, 1); y1 <- c(0, 0, 1)
> x2 <- c(0, 1, 0); y2 <- c(0, 1, 1)
> f2 <- function(x, y) exp(x + y)
> I <- triquad(f2, x1, y1) + triquad(f2, x2, y2)  # 2.952492442012557
> quad2d(f2, 0, 1, 0, 1)                          # 2.952492442012561
[1] 2.952492
> simpson2d(f2, 0, 1, 0, 1)                       # 2.952492442134769
[1] 2.952492
> dblquad(f2,  0, 1, 0, 1)                        # 2.95249244201256
[1] 2.952492
> 
> 
> 
> cleanEx()
> nameEx("trisolve")
> ### * trisolve
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: trisolve
> ### Title: Tridiagonal Linear System Solver
> ### Aliases: trisolve
> ### Keywords: array
> 
> ### ** Examples
> 
> set.seed(8237)
> a <- rep(1, 100)
> e <- runif(99); f <- rnorm(99)
> x <- rep(seq(0.1, 0.9, by = 0.2), times = 20)
> A <- diag(100) + Diag(e, 1) + Diag(f, -1)
> rhs <- A %*% x
> s <- trisolve(a, e, f, rhs)
> s[1:10]                         #=> 0.1 0.3 0.5 0.7 0.9 0.1 0.3 0.5 0.7 0.9
 [1] 0.1 0.3 0.5 0.7 0.9 0.1 0.3 0.5 0.7 0.9
> s[91:100]                       #=> 0.1 0.3 0.5 0.7 0.9 0.1 0.3 0.5 0.7 0.9
 [1] 0.1 0.3 0.5 0.7 0.9 0.1 0.3 0.5 0.7 0.9
> 
> 
> 
> cleanEx()
> nameEx("vander")
> ### * vander
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: vander
> ### Title: Vandermonde matrix
> ### Aliases: vander
> ### Keywords: specmat
> 
> ### ** Examples
> 
>   vander(c(1:10))
            [,1]      [,2]     [,3]    [,4]   [,5]  [,6] [,7] [,8] [,9] [,10]
 [1,]          1         1        1       1      1     1    1    1    1     1
 [2,]        512       256      128      64     32    16    8    4    2     1
 [3,]      19683      6561     2187     729    243    81   27    9    3     1
 [4,]     262144     65536    16384    4096   1024   256   64   16    4     1
 [5,]    1953125    390625    78125   15625   3125   625  125   25    5     1
 [6,]   10077696   1679616   279936   46656   7776  1296  216   36    6     1
 [7,]   40353607   5764801   823543  117649  16807  2401  343   49    7     1
 [8,]  134217728  16777216  2097152  262144  32768  4096  512   64    8     1
 [9,]  387420489  43046721  4782969  531441  59049  6561  729   81    9     1
[10,] 1000000000 100000000 10000000 1000000 100000 10000 1000  100   10     1
> 
> 
> 
> cleanEx()
> nameEx("vectorfield")
> ### * vectorfield
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: vectorfield
> ### Title: Vector Field Plotting
> ### Aliases: vectorfield
> ### Keywords: graphs
> 
> ### ** Examples
> 
> f <- function(x, y) x^2 - y^2
> xx <- c(-1, 1); yy <- c(-1, 1)
> ## Not run: 
> ##D vectorfield(f, xx, yy, scale = 0.1)
> ##D for (xs in seq(-1, 1, by = 0.25)) {
> ##D     sol <- rk4(f, -1, 1, xs, 100)
> ##D     lines(sol$x, sol$y, col="darkgreen")
> ##D }
> ##D grid()
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("whittaker")
> ### * whittaker
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: whittaker
> ### Title: Whittaker Smoothing
> ### Aliases: whittaker
> ### Keywords: timeseries
> 
> ### ** Examples
> 
> # **Sinosoid test function**
> ts <- sin(2*pi*(1:1000)/200)
> t1 <- ts + rnorm(1000)/10
> t3 <- whittaker(t1, lambda = 1600)
> ## Not run: 
> ##D plot(1:1000, t1, col = "grey")
> ##D lines(1:1000, ts, col="blue")
> ##D lines(1:1000, t3, col="red")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("wilkinson")
> ### * wilkinson
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: wilkinson
> ### Title: wilkinson Matrix
> ### Aliases: wilkinson
> ### Keywords: specmat
> 
> ### ** Examples
> 
> (a <- wilkinson(7))
     [,1] [,2] [,3] [,4] [,5] [,6] [,7]
[1,]    3    1    0    0    0    0    0
[2,]    1    2    1    0    0    0    0
[3,]    0    1    1    1    0    0    0
[4,]    0    0    1    0    1    0    0
[5,]    0    0    0    1    1    1    0
[6,]    0    0    0    0    1    2    1
[7,]    0    0    0    0    0    1    3
> eig(a)
[1]  3.7615572  3.7320508  2.3633282  2.0000000  1.0000000  0.2679492 -1.1248854
> 
> 
> 
> cleanEx()
> nameEx("zeta")
> ### * zeta
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: zeta
> ### Title: Riemann Zeta Function
> ### Aliases: zeta
> ### Keywords: specfun
> 
> ### ** Examples
> 
> ##  First zero on the critical line s = 0.5 + i t
> ## Not run: 
> ##D x <- seq(0, 20, len=1001)
> ##D z <- 0.5 + x*1i
> ##D fr <- Re(zeta(z))
> ##D fi <- Im(zeta(z))
> ##D fa <- abs(zeta(z))
> ##D plot(x, fa, type="n", xlim = c(0, 20), ylim = c(-1.5, 2.5),
> ##D      xlab = "Imaginary part (on critical line)", ylab = "Function value",
> ##D      main = "Riemann's Zeta Function along the critical line")
> ##D lines(x, fr, col="blue")
> ##D lines(x, fi, col="darkgreen")
> ##D lines(x, fa, col = "red", lwd = 2)
> ##D points(14.1347, 0, col = "darkred")
> ##D legend(0, 2.4, c("real part", "imaginary part", "absolute value"),
> ##D        lty = 1, lwd = c(1, 1, 2), col = c("blue", "darkgreen", "red"))
> ##D grid()
> ## End(Not run)
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  5.744 2.99 5.32 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
