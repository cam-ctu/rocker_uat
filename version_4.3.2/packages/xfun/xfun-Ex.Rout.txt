
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "xfun"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('xfun')

Attaching package: ‘xfun’

The following objects are masked from ‘package:base’:

    attr, isFALSE

> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("Rscript")
> ### * Rscript
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Rscript
> ### Title: Run the commands 'Rscript' and 'R CMD'
> ### Aliases: Rscript Rcmd
> 
> ### ** Examples
> 
> library(xfun)
> Rscript(c("-e", "1+1"))
[1] 2
> Rcmd(c("build", "--help"))
Usage: R CMD build [options] pkgdirs

Build R packages from package sources in the directories specified by
‘pkgdirs’

Options:
  -h, --help		print short help message and exit
  -v, --version		print version info and exit

  --force               force removal of INDEX file
  --keep-empty-dirs     do not remove empty dirs
  --no-build-vignettes  do not (re)build package vignettes
  --no-manual           do not build the PDF manual even if \Sexprs are present
  --resave-data=        re-save data files as compactly as possible:
                        "no", "best", "gzip" (default)
  --resave-data         same as --resave-data=best
  --no-resave-data      same as --resave-data=no
  --compact-vignettes=  try to compact PDF files under inst/doc:
                        "no" (default), "qpdf", "gs", "gs+qpdf", "both"
  --compact-vignettes   same as --compact-vignettes=qpdf
  --compression=        type of compression to be used on tarball:
                        "gzip" (default), "none", "bzip2", "xz"
  --md5                 add MD5 sums
  --log                 log to file 'pkg-00build.log' when processing 
                        the pkgdir with basename 'pkg'

Report bugs at <https://bugs.R-project.org>.
> 
> 
> 
> cleanEx()
> nameEx("Rscript_call")
> ### * Rscript_call
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Rscript_call
> ### Title: Call a function in a new R session via 'Rscript()'
> ### Aliases: Rscript_call
> 
> ### ** Examples
> 
> factorial(10)
[1] 3628800
> # should return the same value
> xfun::Rscript_call("factorial", list(10))
[1] 3628800
> 
> # the first argument can be either a character string or a function
> xfun::Rscript_call(factorial, list(10))
[1] 3628800
> 
> # Run Rscript starting a vanilla R session
> xfun::Rscript_call(factorial, list(10), options = c("--vanilla"))
[1] 3628800
> 
> 
> 
> cleanEx()
> nameEx("alnum_id")
> ### * alnum_id
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: alnum_id
> ### Title: Generate ID strings
> ### Aliases: alnum_id
> 
> ### ** Examples
> 
> x = c("Hello world 123!", "a  &b*^##c 456")
> xfun::alnum_id(x)
[1] "hello-world-123" "a-b-c-456"      
> xfun::alnum_id(x, "[^[:alpha:]]+")  # only keep alphabetical chars
[1] "hello-world" "a-b-c"      
> # when text contains HTML tags
> xfun::alnum_id("<h1>Hello <strong>world</strong>!")
[1] "hello-world"
> 
> 
> 
> cleanEx()
> nameEx("attr")
> ### * attr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: attr
> ### Title: Obtain an attribute of an object without partial matching
> ### Aliases: attr
> 
> ### ** Examples
> 
> z = structure(list(a = 1), foo = 2)
> base::attr(z, "f")  # 2
[1] 2
> xfun::attr(z, "f")  # NULL
NULL
> xfun::attr(z, "foo")  # 2
[1] 2
> 
> 
> 
> cleanEx()
> nameEx("base64_encode")
> ### * base64_encode
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: base64_encode
> ### Title: Encode/decode data into/from base64 encoding.
> ### Aliases: base64_encode base64_decode
> 
> ### ** Examples
> 
> xfun::base64_encode(as.raw(1:10))
[1] "AQIDBAUGBwgJCg=="
> logo = xfun:::R_logo()
> xfun::base64_encode(logo)
[1] "PCEtLQpDb3B5cmlnaHQgKEMpIDIwMTUtMjAxNiBUaGUgUiBGb3VuZGF0aW9uCgpZb3UgY2FuIGRpc3RyaWJ1dGUgdGhpcyBsb2dvIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQ3JlYXRpdmUKQ29tbW9ucyBBdHRyaWJ1dGlvbi1TaGFyZUFsaWtlIDQuMCBJbnRlcm5hdGlvbmFsIGxpY2Vuc2UgKENDLUJZLVNBCjQuMCkgb3IgKGF0IHlvdXIgb3B0aW9uKSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyCihHUEwtMikuCgpUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwKYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YKTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgCgpZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZQphbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCBhIGNvcHkgaXMgYXZhaWxhYmxlIGF0Cmh0dHBzOi8vd3d3LlItcHJvamVjdC5vcmcvTGljZW5zZXMvCgpUaGUgdGV4dCBvZiB0aGUgQ0MgQlktU0EgNC4wIGxpY2Vuc2UgaXMgYXZhaWxhYmxlIGF0Cmh0dHBzOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1zYS80LjAvCi0tPgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHByZXNlcnZlQXNwZWN0UmF0aW89InhNaWRZTWlkIiB3aWR0aD0iNzI0IiBoZWlnaHQ9IjU2MSIgdmlld0JveD0iMCAwIDcyNCA1NjEiPgogIDxkZWZzPgogICAgPGxpbmVhckdyYWRpZW50IGlkPSJncmFkaWVudEZpbGwtMSIgeDE9IjAiIHgyPSIxIiB5MT0iMCIgeTI9IjEiIGdyYWRpZW50VW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiBzcHJlYWRNZXRob2Q9InBhZCI+CiAgICAgIDxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0icmdiKDIwMywyMDYsMjA4KSIgc3RvcC1vcGFjaXR5PSIxIi8+CiAgICAgIDxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0icmdiKDEzMiwxMzEsMTM5KSIgc3RvcC1vcGFjaXR5PSIxIi8+CiAgICA8L2xpbmVhckdyYWRpZW50PgogICAgPGxpbmVhckdyYWRpZW50IGlkPSJncmFkaWVudEZpbGwtMiIgeDE9IjAiIHgyPSIxIiB5MT0iMCIgeTI9IjEiIGdyYWRpZW50VW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiBzcHJlYWRNZXRob2Q9InBhZCI+CiAgICAgIDxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0icmdiKDM5LDEwOSwxOTUpIiBzdG9wLW9wYWNpdHk9IjEiLz4KICAgICAgPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSJyZ2IoMjIsOTIsMTcwKSIgc3RvcC1vcGFjaXR5PSIxIi8+CiAgICA8L2xpbmVhckdyYWRpZW50PgogIDwvZGVmcz4KICA8cGF0aCBkPSJNMzYxLjQ1Myw0ODUuOTM3IEMxNjIuMzI5LDQ4NS45MzcgMC45MDYsMzc3LjgyOCAwLjkwNiwyNDQuNDY5IEMwLjkwNiwxMTEuMTA5IDE2Mi4zMjksMy4wMDAgMzYxLjQ1MywzLjAwMCBDNTYwLjU3OCwzLjAwMCA3MjIuMDAwLDExMS4xMDkgNzIyLjAwMCwyNDQuNDY5IEM3MjIuMDAwLDM3Ny44MjggNTYwLjU3OCw0ODUuOTM3IDM2MS40NTMsNDg1LjkzNyBaTTQxNi42NDEsOTcuNDA2IEMyNjUuMjg5LDk3LjQwNiAxNDIuNTk0LDE3MS4zMTQgMTQyLjU5NCwyNjIuNDg0IEMxNDIuNTk0LDM1My42NTQgMjY1LjI4OSw0MjcuNTYyIDQxNi42NDEsNDI3LjU2MiBDNTY3Ljk5Miw0MjcuNTYyIDY3OS42ODcsMzc3LjAzMyA2NzkuNjg3LDI2Mi40ODQgQzY3OS42ODcsMTQ3Ljk3MSA1NjcuOTkyLDk3LjQwNiA0MTYuNjQxLDk3LjQwNiBaIiBmaWxsPSJ1cmwoI2dyYWRpZW50RmlsbC0xKSIgZmlsbC1ydWxlPSJldmVub2RkIi8+CiAgPHBhdGggZD0iTTU1MC4wMDAsMzc3LjAwMCBDNTUwLjAwMCwzNzcuMDAwIDU3MS44MjIsMzgzLjU4NSA1ODQuNTAwLDM5MC4wMDAgQzU4OC44OTksMzkyLjIyNiA1OTYuNTEwLDM5Ni42NjggNjAyLjAwMCw0MDIuNTAwIEM2MDcuMzc4LDQwOC4yMTIgNjEwLjAwMCw0MTQuMDAwIDYxMC4wMDAsNDE0LjAwMCBMNjk2LjAwMCw1NTkuMDAwIEw1NTcuMDAwLDU1OS4wNjIgTDQ5Mi4wMDAsNDM3LjAwMCBDNDkyLjAwMCw0MzcuMDAwIDQ3OC42OTAsNDE0LjEzMSA0NzAuNTAwLDQwNy41MDAgQzQ2My42NjgsNDAxLjk2OSA0NjAuNzU1LDQwMC4wMDAgNDU0LjAwMCw0MDAuMDAwIEM0NDkuMjk4LDQwMC4wMDAgNDIwLjk3NCw0MDAuMDAwIDQyMC45NzQsNDAwLjAwMCBMNDIxLjAwMCw1NTguOTc0IEwyOTguMDAwLDU1OS4wMjYgTDI5OC4wMDAsMTUyLjkzOCBMNTQ1LjAwMCwxNTIuOTM4IEM1NDUuMDAwLDE1Mi45MzggNjU3LjUwMCwxNTQuOTY3IDY1Ny41MDAsMjYyLjAwMCBDNjU3LjUwMCwzNjkuMDMzIDU1MC4wMDAsMzc3LjAwMCA1NTAuMDAwLDM3Ny4wMDAgWk00OTYuNTAwLDI0MS4wMjQgTDQyMi4wMzcsMjQwLjk3NiBMNDIyLjAwMCwzMTAuMDI2IEw0OTYuNTAwLDMxMC4wMDIgQzQ5Ni41MDAsMzEwLjAwMiA1MzEuMDAwLDMwOS44OTUgNTMxLjAwMCwyNzQuODc3IEM1MzEuMDAwLDIzOS4xNTUgNDk2LjUwMCwyNDEuMDI0IDQ5Ni41MDAsMjQxLjAyNCBaIiBmaWxsPSJ1cmwoI2dyYWRpZW50RmlsbC0yKSIgZmlsbC1ydWxlPSJldmVub2RkIi8+Cjwvc3ZnPgo="
> xfun::base64_decode("AQIDBAUGBwgJCg==")
 [1] 01 02 03 04 05 06 07 08 09 0a
> 
> 
> 
> cleanEx()
> nameEx("base64_uri")
> ### * base64_uri
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: base64_uri
> ### Title: Generate the Data URI for a file
> ### Aliases: base64_uri
> 
> ### ** Examples
> 
> logo = xfun:::R_logo()
> img = xfun::html_tag("img", src = xfun::base64_uri(logo), alt = "R logo")
> if (interactive()) xfun::html_view(img)
> 
> 
> 
> cleanEx()
> nameEx("base_pkgs")
> ### * base_pkgs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: base_pkgs
> ### Title: Get base R package names
> ### Aliases: base_pkgs
> 
> ### ** Examples
> 
> xfun::base_pkgs()
 [1] "base"      "compiler"  "datasets"  "graphics"  "grDevices" "grid"     
 [7] "methods"   "parallel"  "splines"   "stats"     "stats4"    "tcltk"    
[13] "tools"     "utils"    
> 
> 
> 
> cleanEx()
> nameEx("bump_version")
> ### * bump_version
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bump_version
> ### Title: Bump version numbers
> ### Aliases: bump_version
> 
> ### ** Examples
> 
> xfun::bump_version(c("0.1", "91.2.14"))
[1] ‘0.2’     ‘91.2.15’
> 
> 
> 
> cleanEx()
> nameEx("cache_exec")
> ### * cache_exec
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cache_exec
> ### Title: Cache the execution of an expression in memory or on disk
> ### Aliases: cache_exec
> 
> ### ** Examples
> 
> # the first run takes about 1 second
> y1 = xfun::cache_exec({
+     x = rnorm(1e+05)
+     Sys.sleep(1)
+     x
+ }, path = ":memory:", id = "sim-norm")
> 
> # the second run takes almost no time
> y2 = xfun::cache_exec({
+     # comments won't affect caching
+     x = rnorm(1e+05)
+     Sys.sleep(1)
+     x
+ }, path = ":memory:", id = "sim-norm")
> 
> # y1, y2, and x should be identical
> stopifnot(identical(y1, y2), identical(y1, x))
> 
> 
> 
> cleanEx()
> nameEx("cache_rds")
> ### * cache_rds
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cache_rds
> ### Title: Cache the value of an R expression to an RDS file
> ### Aliases: cache_rds
> 
> ### ** Examples
> 
> f = tempfile()  # the cache file
> compute = function(...) {
+     res = xfun::cache_rds({
+         Sys.sleep(1)
+         1:10
+     }, file = f, dir = "", ...)
+     res
+ }
> compute()  # takes one second
 [1]  1  2  3  4  5  6  7  8  9 10
> compute()  # returns 1:10 immediately
 [1]  1  2  3  4  5  6  7  8  9 10
> compute()  # fast again
 [1]  1  2  3  4  5  6  7  8  9 10
> compute(rerun = TRUE)  # one second to rerun
 [1]  1  2  3  4  5  6  7  8  9 10
> compute()
 [1]  1  2  3  4  5  6  7  8  9 10
> unlink(paste0(f, "_*.rds"))
> 
> 
> 
> cleanEx()
> nameEx("csv_options")
> ### * csv_options
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: csv_options
> ### Title: Parse comma-separated chunk options
> ### Aliases: csv_options
> 
> ### ** Examples
> 
> xfun::csv_options("foo, eval=TRUE, fig.width=5, echo=if (TRUE) FALSE")
$label
[1] "foo"

$eval
[1] TRUE

$fig.width
[1] 5

$echo
if (TRUE) FALSE

> 
> 
> 
> cleanEx()
> nameEx("decimal_dot")
> ### * decimal_dot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: decimal_dot
> ### Title: Evaluate an expression after forcing the decimal point to be a
> ###   dot
> ### Aliases: decimal_dot
> 
> ### ** Examples
> 
> opts = options(OutDec = ",")
> as.character(1.234)  # using ',' as the decimal separator
[1] "1,234"
> print(1.234)  # same
[1] 1,234
> xfun::decimal_dot(as.character(1.234))  # using dot
[1] "1.234"
> xfun::decimal_dot(print(1.234))  # using dot
[1] 1.234
> options(opts)
> 
> 
> 
> cleanEx()
> nameEx("divide_chunk")
> ### * divide_chunk
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: divide_chunk
> ### Title: Divide chunk options from the code chunk body
> ### Aliases: divide_chunk
> 
> ### ** Examples
> 
> # parse yaml-like items
> yaml_like = c("#| label: mine", "#| echo: true", "#| fig.width: 8", "#| foo: bar",
+     "1 + 1")
> writeLines(yaml_like)
#| label: mine
#| echo: true
#| fig.width: 8
#| foo: bar
1 + 1
> xfun::divide_chunk("r", yaml_like)
$options
$options$label
[1] "mine"

$options$echo
[1] TRUE

$options$fig.width
[1] 8

$options$foo
[1] "bar"


$src
[1] "#| label: mine"  "#| echo: true"   "#| fig.width: 8" "#| foo: bar"    

$code
[1] "1 + 1"

> 
> # parse CSV syntax
> csv_like = c("#| mine, echo = TRUE, fig.width = 8, foo = 'bar'", "1 + 1")
> writeLines(csv_like)
#| mine, echo = TRUE, fig.width = 8, foo = 'bar'
1 + 1
> xfun::divide_chunk("r", csv_like)
$options
$options$label
[1] "mine"

$options$echo
[1] TRUE

$options$fig.width
[1] 8

$options$foo
[1] "bar"


$src
[1] "#| mine, echo = TRUE, fig.width = 8, foo = 'bar'"

$code
[1] "1 + 1"

> 
> 
> 
> cleanEx()
> nameEx("do_once")
> ### * do_once
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: do_once
> ### Title: Perform a task once in an R session
> ### Aliases: do_once
> 
> ### ** Examples
> 
> do_once(message("Today's date is ", Sys.Date()), "xfun.date.reminder")
Today's date is 2025-01-07
You will not see this message again in this R session. If you never want to see this message, you may set options(xfun.date.reminder = FALSE) in your .Rprofile.
> # if you run it again, it will not emit the message again
> do_once(message("Today's date is ", Sys.Date()), "xfun.date.reminder")
> 
> do_once({
+     Sys.sleep(2)
+     1 + 1
+ }, "xfun.task.1plus1")
You will not see this message again in this R session. If you never want to see this message, you may set options(xfun.task.1plus1 = FALSE) in your .Rprofile.
> do_once({
+     Sys.sleep(2)
+     1 + 1
+ }, "xfun.task.1plus1")
> 
> 
> 
> cleanEx()
> nameEx("download_cache")
> ### * download_cache
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: download_cache
> ### Title: Download a file from a URL and cache it on disk
> ### Aliases: download_cache
> ### Keywords: datasets
> 
> ### ** Examples
> ## Don't show: 
> if (interactive()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ # the first time it may take a few seconds
+ x1 = xfun::download_cache$get("https://www.r-project.org/")
+ head(x1)
+ 
+ # now you can get the cached content
+ x2 = xfun::download_cache$get("https://www.r-project.org/")
+ identical(x1, x2)  # TRUE
+ 
+ # a binary file
+ x3 = xfun::download_cache$get("https://yihui.org/images/logo.png", "raw")
+ length(x3)
+ 
+ # show a summary
+ xfun::download_cache$summary()
+ # remove a specific cache file
+ xfun::download_cache$remove("https://yihui.org/images/logo.png", "raw")
+ # remove all cache files
+ xfun::download_cache$purge()
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("embed_file")
> ### * embed_file
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: embed_file
> ### Title: Embed a file, multiple files, or directory on an HTML page
> ### Aliases: embed_file embed_dir embed_files
> 
> ### ** Examples
> 
> logo = xfun:::R_logo()
> link = xfun::embed_file(logo, text = "Download R logo")
> link
[1] "<a href=\"data:image/svg+xml;base64,PCEtLQpDb3B5cmlnaHQgKEMpIDIwMTUtMjAxNiBUaGUgUiBGb3VuZGF0aW9uCgpZb3UgY2FuIGRpc3RyaWJ1dGUgdGhpcyBsb2dvIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQ3JlYXRpdmUKQ29tbW9ucyBBdHRyaWJ1dGlvbi1TaGFyZUFsaWtlIDQuMCBJbnRlcm5hdGlvbmFsIGxpY2Vuc2UgKENDLUJZLVNBCjQuMCkgb3IgKGF0IHlvdXIgb3B0aW9uKSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyCihHUEwtMikuCgpUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwKYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YKTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgCgpZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZQphbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCBhIGNvcHkgaXMgYXZhaWxhYmxlIGF0Cmh0dHBzOi8vd3d3LlItcHJvamVjdC5vcmcvTGljZW5zZXMvCgpUaGUgdGV4dCBvZiB0aGUgQ0MgQlktU0EgNC4wIGxpY2Vuc2UgaXMgYXZhaWxhYmxlIGF0Cmh0dHBzOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1zYS80LjAvCi0tPgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHByZXNlcnZlQXNwZWN0UmF0aW89InhNaWRZTWlkIiB3aWR0aD0iNzI0IiBoZWlnaHQ9IjU2MSIgdmlld0JveD0iMCAwIDcyNCA1NjEiPgogIDxkZWZzPgogICAgPGxpbmVhckdyYWRpZW50IGlkPSJncmFkaWVudEZpbGwtMSIgeDE9IjAiIHgyPSIxIiB5MT0iMCIgeTI9IjEiIGdyYWRpZW50VW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiBzcHJlYWRNZXRob2Q9InBhZCI+CiAgICAgIDxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0icmdiKDIwMywyMDYsMjA4KSIgc3RvcC1vcGFjaXR5PSIxIi8+CiAgICAgIDxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0icmdiKDEzMiwxMzEsMTM5KSIgc3RvcC1vcGFjaXR5PSIxIi8+CiAgICA8L2xpbmVhckdyYWRpZW50PgogICAgPGxpbmVhckdyYWRpZW50IGlkPSJncmFkaWVudEZpbGwtMiIgeDE9IjAiIHgyPSIxIiB5MT0iMCIgeTI9IjEiIGdyYWRpZW50VW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiBzcHJlYWRNZXRob2Q9InBhZCI+CiAgICAgIDxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0icmdiKDM5LDEwOSwxOTUpIiBzdG9wLW9wYWNpdHk9IjEiLz4KICAgICAgPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSJyZ2IoMjIsOTIsMTcwKSIgc3RvcC1vcGFjaXR5PSIxIi8+CiAgICA8L2xpbmVhckdyYWRpZW50PgogIDwvZGVmcz4KICA8cGF0aCBkPSJNMzYxLjQ1Myw0ODUuOTM3IEMxNjIuMzI5LDQ4NS45MzcgMC45MDYsMzc3LjgyOCAwLjkwNiwyNDQuNDY5IEMwLjkwNiwxMTEuMTA5IDE2Mi4zMjksMy4wMDAgMzYxLjQ1MywzLjAwMCBDNTYwLjU3OCwzLjAwMCA3MjIuMDAwLDExMS4xMDkgNzIyLjAwMCwyNDQuNDY5IEM3MjIuMDAwLDM3Ny44MjggNTYwLjU3OCw0ODUuOTM3IDM2MS40NTMsNDg1LjkzNyBaTTQxNi42NDEsOTcuNDA2IEMyNjUuMjg5LDk3LjQwNiAxNDIuNTk0LDE3MS4zMTQgMTQyLjU5NCwyNjIuNDg0IEMxNDIuNTk0LDM1My42NTQgMjY1LjI4OSw0MjcuNTYyIDQxNi42NDEsNDI3LjU2MiBDNTY3Ljk5Miw0MjcuNTYyIDY3OS42ODcsMzc3LjAzMyA2NzkuNjg3LDI2Mi40ODQgQzY3OS42ODcsMTQ3Ljk3MSA1NjcuOTkyLDk3LjQwNiA0MTYuNjQxLDk3LjQwNiBaIiBmaWxsPSJ1cmwoI2dyYWRpZW50RmlsbC0xKSIgZmlsbC1ydWxlPSJldmVub2RkIi8+CiAgPHBhdGggZD0iTTU1MC4wMDAsMzc3LjAwMCBDNTUwLjAwMCwzNzcuMDAwIDU3MS44MjIsMzgzLjU4NSA1ODQuNTAwLDM5MC4wMDAgQzU4OC44OTksMzkyLjIyNiA1OTYuNTEwLDM5Ni42NjggNjAyLjAwMCw0MDIuNTAwIEM2MDcuMzc4LDQwOC4yMTIgNjEwLjAwMCw0MTQuMDAwIDYxMC4wMDAsNDE0LjAwMCBMNjk2LjAwMCw1NTkuMDAwIEw1NTcuMDAwLDU1OS4wNjIgTDQ5Mi4wMDAsNDM3LjAwMCBDNDkyLjAwMCw0MzcuMDAwIDQ3OC42OTAsNDE0LjEzMSA0NzAuNTAwLDQwNy41MDAgQzQ2My42NjgsNDAxLjk2OSA0NjAuNzU1LDQwMC4wMDAgNDU0LjAwMCw0MDAuMDAwIEM0NDkuMjk4LDQwMC4wMDAgNDIwLjk3NCw0MDAuMDAwIDQyMC45NzQsNDAwLjAwMCBMNDIxLjAwMCw1NTguOTc0IEwyOTguMDAwLDU1OS4wMjYgTDI5OC4wMDAsMTUyLjkzOCBMNTQ1LjAwMCwxNTIuOTM4IEM1NDUuMDAwLDE1Mi45MzggNjU3LjUwMCwxNTQuOTY3IDY1Ny41MDAsMjYyLjAwMCBDNjU3LjUwMCwzNjkuMDMzIDU1MC4wMDAsMzc3LjAwMCA1NTAuMDAwLDM3Ny4wMDAgWk00OTYuNTAwLDI0MS4wMjQgTDQyMi4wMzcsMjQwLjk3NiBMNDIyLjAwMCwzMTAuMDI2IEw0OTYuNTAwLDMxMC4wMDIgQzQ5Ni41MDAsMzEwLjAwMiA1MzEuMDAwLDMwOS44OTUgNTMxLjAwMCwyNzQuODc3IEM1MzEuMDAwLDIzOS4xNTUgNDk2LjUwMCwyNDEuMDI0IDQ5Ni41MDAsMjQxLjAyNCBaIiBmaWxsPSJ1cmwoI2dyYWRpZW50RmlsbC0yKSIgZmlsbC1ydWxlPSJldmVub2RkIi8+Cjwvc3ZnPgo=\" download=\"Rlogo.svg\">Download R logo</a>"
attr(,"class")
[1] "xfun_html" "html"     
> if (interactive()) xfun::html_view(link)
> 
> 
> 
> cleanEx()
> nameEx("env_option")
> ### * env_option
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: env_option
> ### Title: Retrieve a global option from both 'options()' and environment
> ###   variables
> ### Aliases: env_option
> 
> ### ** Examples
> 
> xfun::env_option("xfun.test.option")  # NULL
NULL
> 
> Sys.setenv(R_XFUN_TEST_OPTION = "1234")
> xfun::env_option("xfun.test.option")  # 1234
[1] "1234"
> 
> options(xfun.test.option = TRUE)
> xfun::env_option("xfun.test.option")  # TRUE (from options())
[1] TRUE
> options(xfun.test.option = NULL)  # reset the option
> xfun::env_option("xfun.test.option")  # 1234 (from env var)
[1] "1234"
> 
> Sys.unsetenv("R_XFUN_TEST_OPTION")
> xfun::env_option("xfun.test.option")  # NULL again
NULL
> 
> xfun::env_option("xfun.test.option", FALSE)  # use default
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("existing_files")
> ### * existing_files
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: existing_files
> ### Title: Find file paths that exist
> ### Aliases: existing_files
> 
> ### ** Examples
> 
> xfun::existing_files(c("foo.txt", system.file("DESCRIPTION", package = "xfun")))
[1] "/usr/local/lib/R/site-library/xfun/DESCRIPTION"
> 
> 
> 
> cleanEx()
> nameEx("exit_call")
> ### * exit_call
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: exit_call
> ### Title: Call 'on.exit()' in a parent function
> ### Aliases: exit_call
> 
> ### ** Examples
> 
> f = function(x) {
+     print(x)
+     xfun::exit_call(function() print("The parent function is exiting!"))
+ }
> g = function(y) {
+     f(y)
+     print("f() has been called!")
+ }
> g("An argument of g()!")
[1] "An argument of g()!"
[1] "f() has been called!"
[1] "The parent function is exiting!"
> 
> 
> 
> cleanEx()
> nameEx("fenced_block")
> ### * fenced_block
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fenced_block
> ### Title: Create a fenced block in Markdown
> ### Aliases: fenced_block fenced_div make_fence
> 
> ### ** Examples
> 
> # code block with class 'r' and ID 'foo'
> xfun::fenced_block("1+1", c(".r", "#foo"))
[1] ""              "``` {.r #foo}" "1+1"           "```"          
> # fenced Div
> xfun::fenced_block("This is a **Div**.", char = ":")
[1] ""                   ":::"                "This is a **Div**."
[4] ":::"               
> # three backticks by default
> xfun::make_fence("1+1")
[1] "```"
> # needs five backticks for the fences because content has four
> xfun::make_fence(c("````r", "1+1", "````"))
[1] "`````"
> 
> 
> 
> cleanEx()
> nameEx("file_ext")
> ### * file_ext
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: file_ext
> ### Title: Manipulate filename extensions
> ### Aliases: file_ext sans_ext with_ext
> 
> ### ** Examples
> 
> library(xfun)
> p = c("abc.doc", "def123.tex", "path/to/foo.Rmd", "backup.ppt~", "pkg.tar.xz")
> file_ext(p)
[1] "doc"    "tex"    "Rmd"    "ppt~"   "tar.xz"
> sans_ext(p)
[1] "abc"         "def123"      "path/to/foo" "backup"      "pkg"        
> with_ext(p, ".txt")
[1] "abc.txt"         "def123.txt"      "path/to/foo.txt" "backup.txt"     
[5] "pkg.txt"        
> with_ext(p, c(".ppt", ".sty", ".Rnw", "doc", "zip"))
[1] "abc.ppt"         "def123.sty"      "path/to/foo.Rnw" "backup.doc"     
[5] "pkg.zip"        
> with_ext(p, "html")
[1] "abc.html"         "def123.html"      "path/to/foo.html" "backup.html"     
[5] "pkg.html"        
> 
> # allow for more characters in extensions
> p = c("a.c++", "b.c--", "c.e##")
> file_ext(p)  # -/+/# not recognized by default
[1] "" "" ""
> file_ext(p, extra = "-+#")
[1] "c++" "c--" "e##"
> 
> 
> 
> cleanEx()
> nameEx("file_string")
> ### * file_string
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: file_string
> ### Title: Read a text file and concatenate the lines by "\n"
> ### Aliases: file_string
> 
> ### ** Examples
> 
> xfun::file_string(system.file("DESCRIPTION", package = "xfun"))
Package: xfun
Type: Package
Title: Supporting Functions for Packages Maintained by 'Yihui Xie'
Version: 0.49
Authors@R: c(
  person("Yihui", "Xie", role = c("aut", "cre", "cph"), email = "xie@yihui.name", comment = c(ORCID = "0000-0003-0645-5666")),
  person("Wush", "Wu", role = "ctb"),
  person("Daijiang", "Li", role = "ctb"),
  person("Xianying", "Tan", role = "ctb"),
  person("Salim", "Brüggemann", role = "ctb", email = "salim-b@pm.me", comment = c(ORCID = "0000-0002-5329-5987")),
  person("Christophe", "Dervieux", role = "ctb"),
  person()
  )
Description: Miscellaneous functions commonly used in other packages maintained by 'Yihui Xie'.
Depends: R (>= 3.2.0)
Imports: grDevices, stats, tools
Suggests: testit, parallel, codetools, methods, rstudioapi, tinytex (>=
        0.30), mime, litedown, commonmark, knitr (>= 1.47), remotes,
        pak, rhub, renv, curl, xml2, jsonlite, magick, yaml, qs,
        rmarkdown
License: MIT + file LICENSE
URL: https://github.com/yihui/xfun
BugReports: https://github.com/yihui/xfun/issues
Encoding: UTF-8
RoxygenNote: 7.3.2
VignetteBuilder: litedown
NeedsCompilation: yes
Packaged: 2024-10-31 16:27:34 UTC; yihui
Author: Yihui Xie [aut, cre, cph] (<https://orcid.org/0000-0003-0645-5666>),
  Wush Wu [ctb],
  Daijiang Li [ctb],
  Xianying Tan [ctb],
  Salim Brüggemann [ctb] (<https://orcid.org/0000-0002-5329-5987>),
  Christophe Dervieux [ctb]
Maintainer: Yihui Xie <xie@yihui.name>
Repository: CRAN
Date/Publication: 2024-10-31 18:10:02 UTC
Built: R 4.3.2; x86_64-pc-linux-gnu; 2025-01-07 13:11:15 UTC; unix
> 
> 
> 
> cleanEx()
> nameEx("format_bytes")
> ### * format_bytes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: format_bytes
> ### Title: Format numbers of bytes using a specified unit
> ### Aliases: format_bytes
> 
> ### ** Examples
> 
> xfun::format_bytes(c(1, 1024, 2000, 1e+06, 2e+08))
[1] "1 bytes"  "1 Kb"     "2 Kb"     "976.6 Kb" "190.7 Mb"
> xfun::format_bytes(c(1, 1024, 2000, 1e+06, 2e+08), units = "KB")
[1] "0 Kb"        "1 Kb"        "2 Kb"        "976.6 Kb"    "195312.5 Kb"
> 
> 
> 
> cleanEx()
> nameEx("from_root")
> ### * from_root
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: from_root
> ### Title: Get the relative path of a path in a project relative to the
> ###   current working directory
> ### Aliases: from_root
> 
> ### ** Examples
> 
> ## Not run: 
> ##D xfun::from_root("data", "mtcars.csv")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("github_releases")
> ### * github_releases
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: github_releases
> ### Title: Get the tags of GitHub releases of a repository
> ### Aliases: github_releases
> 
> ### ** Examples
> ## Don't show: 
> if (interactive()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ xfun::github_releases("yihui/xfun")
+ xfun::github_releases("gohugoio/hugo")
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("grep_sub")
> ### * grep_sub
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: grep_sub
> ### Title: Perform replacement with 'gsub()' on elements matched from
> ###   'grep()'
> ### Aliases: grep_sub
> 
> ### ** Examples
> 
> # find elements that matches 'a[b]+c' and capitalize 'b' with perl regex
> xfun::grep_sub("a([b]+)c", "a\\U\\1c", c("abc", "abbbc", "addc", "123"), perl = TRUE)
[1] "aBc"   "aBBBc"
> 
> 
> 
> cleanEx()
> nameEx("gsub_file")
> ### * gsub_file
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gsub_file
> ### Title: Search and replace strings in files
> ### Aliases: gsub_file gsub_files gsub_dir gsub_ext
> 
> ### ** Examples
> 
> library(xfun)
> f = tempfile()
> writeLines(c("hello", "world"), f)
> gsub_file(f, "world", "woRld", fixed = TRUE)
> readLines(f)
[1] "hello" "woRld"
> 
> 
> 
> cleanEx()
> nameEx("html_tag")
> ### * html_tag
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: html_tag
> ### Title: Tools for HTML tags
> ### Aliases: html_tag html_value html_escape html_view
> 
> ### ** Examples
> 
> xfun::html_tag("a", "<R Project>", href = "https://www.r-project.org", target = "_blank")
[1] "<a href=\"https://www.r-project.org\" target=\"_blank\">&lt;R Project&gt;</a>"
attr(,"class")
[1] "xfun_html" "html"     
> xfun::html_tag("br")
[1] "<br />"
attr(,"class")
[1] "xfun_html" "html"     
> xfun::html_tag("a", xfun::html_tag("strong", "R Project"), href = "#")
[1] "<a href=\"#\"><strong>R Project</strong></a>"
attr(,"class")
[1] "xfun_html" "html"     
> xfun::html_tag("a", list("<text>", xfun::html_tag("b", "R Project")), href = "#")
[1] "<a href=\"#\">&lt;text&gt;<b>R Project</b></a>"
attr(,"class")
[1] "xfun_html" "html"     
> xfun::html_escape("\" quotes \" & brackets < >")
[1] "\" quotes \" &amp; brackets &lt; &gt;"
> xfun::html_escape("\" & < > \r \n", attr = TRUE)
[1] "&quot; &amp; &lt; &gt; &#13; &#10;"
> 
> 
> 
> cleanEx()
> nameEx("in_dir")
> ### * in_dir
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: in_dir
> ### Title: Evaluate an expression under a specified working directory
> ### Aliases: in_dir
> 
> ### ** Examples
> 
> library(xfun)
> in_dir(tempdir(), {
+     print(getwd())
+     list.files()
+ })
[1] "/tmp/RtmpBfKMzg"
[1] "file244404578733c"
> 
> 
> 
> cleanEx()
> nameEx("is_abs_path")
> ### * is_abs_path
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is_abs_path
> ### Title: Test if paths are relative or absolute
> ### Aliases: is_abs_path is_rel_path
> 
> ### ** Examples
> 
> xfun::is_abs_path(c("C:/foo", "foo.txt", "/Users/john/", tempdir()))
[1] FALSE FALSE  TRUE  TRUE
> xfun::is_rel_path(c("C:/foo", "foo.txt", "/Users/john/", tempdir()))
[1]  TRUE  TRUE FALSE FALSE
> 
> 
> 
> cleanEx()
> nameEx("is_ascii")
> ### * is_ascii
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is_ascii
> ### Title: Check if a character vector consists of entirely ASCII
> ###   characters
> ### Aliases: is_ascii
> 
> ### ** Examples
> 
> library(xfun)
> is_ascii(letters)  # yes
 [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
[16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
> is_ascii(intToUtf8(8212))  # no
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("is_blank")
> ### * is_blank
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is_blank
> ### Title: Test if a character vector consists of blank strings
> ### Aliases: is_blank
> 
> ### ** Examples
> 
> xfun::is_blank("")
[1] TRUE
> xfun::is_blank("abc")
[1] FALSE
> xfun::is_blank(c("", "  ", "\n\t"))
[1] TRUE TRUE TRUE
> xfun::is_blank(c("", " ", "abc"))
[1]  TRUE  TRUE FALSE
> 
> 
> 
> cleanEx()
> nameEx("is_sub_path")
> ### * is_sub_path
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is_sub_path
> ### Title: Test if a path is a subpath of a dir
> ### Aliases: is_sub_path
> 
> ### ** Examples
> 
> xfun::is_sub_path("a/b/c.txt", "a/b")  # TRUE
[1] TRUE
> xfun::is_sub_path("a/b/c.txt", "d/b")  # FALSE
[1] FALSE
> xfun::is_sub_path("a/b/c.txt", "a\\b")  # FALSE (even on Windows)
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("is_web_path")
> ### * is_web_path
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is_web_path
> ### Title: Test if a path is a web path
> ### Aliases: is_web_path
> 
> ### ** Examples
> 
> xfun::is_web_path("https://www.r-project.org")  # TRUE
[1] TRUE
> xfun::is_web_path("www.r-project.org")  # FALSE
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("magic_path")
> ### * magic_path
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: magic_path
> ### Title: Find a file or directory under a root directory
> ### Aliases: magic_path
> 
> ### ** Examples
> 
> ## Not run: 
> ##D xfun::magic_path("mtcars.csv")  # find any file that has the base name mtcars.csv
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("mark_dirs")
> ### * mark_dirs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mark_dirs
> ### Title: Mark some paths as directories
> ### Aliases: mark_dirs
> 
> ### ** Examples
> 
> mark_dirs(list.files(find.package("xfun"), full.names = TRUE))
 [1] "/usr/local/lib/R/site-library/xfun/DESCRIPTION"
 [2] "/usr/local/lib/R/site-library/xfun/doc/"       
 [3] "/usr/local/lib/R/site-library/xfun/help/"      
 [4] "/usr/local/lib/R/site-library/xfun/html/"      
 [5] "/usr/local/lib/R/site-library/xfun/INDEX"      
 [6] "/usr/local/lib/R/site-library/xfun/libs/"      
 [7] "/usr/local/lib/R/site-library/xfun/LICENSE"    
 [8] "/usr/local/lib/R/site-library/xfun/Meta/"      
 [9] "/usr/local/lib/R/site-library/xfun/NAMESPACE"  
[10] "/usr/local/lib/R/site-library/xfun/NEWS.md"    
[11] "/usr/local/lib/R/site-library/xfun/R/"         
[12] "/usr/local/lib/R/site-library/xfun/resources/" 
[13] "/usr/local/lib/R/site-library/xfun/scripts/"   
> 
> 
> 
> cleanEx()
> nameEx("md5")
> ### * md5
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: md5
> ### Title: Calculate the MD5 checksums of R objects
> ### Aliases: md5
> 
> ### ** Examples
> 
> x1 = 1
> x2 = 1:10
> x3 = seq(1, 10)
> x4 = iris
> x5 = paste
> (m = xfun::md5(x1, x2, x3, x4, x5))
[1] "f17801eb638793fa56d7fbaad2ae9c6b" "80e76ade6af799c5b55e6447e7bf0d7b"
[3] "80e76ade6af799c5b55e6447e7bf0d7b" "999d7a900799faebc7d3eedbdf663570"
[5] "e146801e93d742df390caa1a551e1965"
> stopifnot(m[2] == m[3])  # x2 and x3 should be identical
> 
> xfun::md5(x1 = x1, x2 = x2)  # named arguments
                                x1                                 x2 
"f17801eb638793fa56d7fbaad2ae9c6b" "80e76ade6af799c5b55e6447e7bf0d7b" 
> 
> 
> 
> cleanEx()
> nameEx("md_table")
> ### * md_table
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: md_table
> ### Title: Generate a simple Markdown pipe table
> ### Aliases: md_table
> 
> ### ** Examples
> 
> xfun::md_table(head(iris))
[1] "|Sepal.Length|Sepal.Width|Petal.Length|Petal.Width|Species|"
[2] "|--:|--:|--:|--:|---|"                                      
[3] "|5.1|3.5|1.4|0.2|setosa|"                                   
[4] "|4.9|3.0|1.4|0.2|setosa|"                                   
[5] "|4.7|3.2|1.3|0.2|setosa|"                                   
[6] "|4.6|3.1|1.5|0.2|setosa|"                                   
[7] "|5.0|3.6|1.4|0.2|setosa|"                                   
[8] "|5.4|3.9|1.7|0.4|setosa|"                                   
> xfun::md_table(mtcars, limit = c(10, 6))
 [1] "| |mpg|cyl|...|gear|am|vs|"                                 
 [2] "|---|--:|--:|:-:|--:|--:|--:|"                              
 [3] "|Mazda RX4|21.0|6|...|4|1|0|"                               
 [4] "|Mazda RX4 Wag|21.0|6|...|4|1|0|"                           
 [5] "|Datsun 710|22.8|4|...|4|1|1|"                              
 [6] "|Hornet 4 Drive|21.4|6|...|3|0|1|"                          
 [7] "|Hornet Sportabout|18.7|8|...|3|0|0|"                       
 [8] "|&vellip;|&vellip;|&vellip;|...|&vellip;|&vellip;|&vellip;|"
 [9] "|Lotus Europa|30.4|4|...|5|1|1|"                            
[10] "|Ford Pantera L|15.8|8|...|5|1|0|"                          
[11] "|Ferrari Dino|19.7|6|...|5|1|0|"                            
[12] "|Maserati Bora|15.0|8|...|5|1|0|"                           
[13] "|Volvo 142E|21.4|4|...|4|1|1|"                              
> 
> 
> 
> cleanEx()
> nameEx("mime_type")
> ### * mime_type
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mime_type
> ### Title: Get the MIME types of files
> ### Aliases: mime_type
> 
> ### ** Examples
> ## Don't show: 
> if (tolower(Sys.getenv('CI')) == 'true') (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ f = list.files(R.home("doc"), full.names = TRUE)
+ mime_type(f)
+ mime_type(f, FALSE)  # don't use mime
+ mime_type(f, FALSE, NA)  # run command for files without extension
+ ## Don't show: 
+ }) # examplesIf
> f = list.files(R.home("doc"), full.names = TRUE)
> mime_type(f)
 [1] "text/plain"               "text/csv"                
 [3] "text/plain"               "text/plain"              
 [5] "text/csv"                 "text/plain"              
 [7] "text/plain"               "text/plain"              
 [9] "application/octet-stream" "text/plain"              
[11] "text/plain"               "application/octet-stream"
[13] "application/octet-stream" "application/octet-stream"
[15] "application/octet-stream" "application/octet-stream"
[17] "application/octet-stream" "application/pdf"         
[19] "application/octet-stream" "text/plain"              
[21] "text/plain"              
> mime_type(f, FALSE)
 [1] "text/plain"       "text/csv"         "text/plain"       "text/plain"      
 [5] "text/csv"         "text/plain"       "text/plain"       "text/plain"      
 [9] "text/plain"       "text/plain"       "text/plain"       "text/plain"      
[13] "text/plain"       "text/plain"       "application/gzip" "text/plain"      
[17] "application/gzip" "application/pdf"  "application/gzip" "text/plain"      
[21] "text/plain"      
> mime_type(f, FALSE, NA)
 [1] "text/plain"       "text/csv"         "text/plain"       "text/plain"      
 [5] "text/csv"         "text/plain"       "inode/directory"  "text/plain"      
 [9] "text/plain"       "inode/directory"  "text/plain"       "text/plain"      
[13] "text/plain"       "text/plain"       "application/gzip" "text/plain"      
[17] "application/gzip" "application/pdf"  "application/gzip" "text/plain"      
[21] "text/plain"      
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("msg_cat")
> ### * msg_cat
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: msg_cat
> ### Title: Generate a message with 'cat()'
> ### Aliases: msg_cat
> 
> ### ** Examples
> 
> {
+     # a message without a newline at the end
+     xfun::msg_cat("Hello world!")
+     # add a newline at the end
+     xfun::msg_cat(" This message appears right after the previous one.\n")
+ }
Hello world! This message appears right after the previous one.
> suppressMessages(xfun::msg_cat("Hello world!"))
> 
> 
> 
> cleanEx()
> nameEx("native_encode")
> ### * native_encode
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: native_encode
> ### Title: Try to use the system native encoding to represent a character
> ###   vector
> ### Aliases: native_encode
> 
> ### ** Examples
> 
> library(xfun)
> s = intToUtf8(c(20320, 22909))
> Encoding(s)
[1] "UTF-8"
> 
> s2 = native_encode(s)
> Encoding(s2)
[1] "UTF-8"
> 
> 
> 
> cleanEx()
> nameEx("news2md")
> ### * news2md
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: news2md
> ### Title: Convert package news to the Markdown format
> ### Aliases: news2md
> 
> ### ** Examples
> ## Don't show: 
> if (interactive()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ # news for the current version of R
+ xfun::news2md("R", Version == getRversion(), output = NA)
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("normalize_path")
> ### * normalize_path
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: normalize_path
> ### Title: Normalize paths
> ### Aliases: normalize_path
> 
> ### ** Examples
> 
> library(xfun)
> normalize_path("~")
[1] "/github/home"
> 
> 
> 
> cleanEx()
> nameEx("numbers_to_words")
> ### * numbers_to_words
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: numbers_to_words
> ### Title: Convert numbers to English words
> ### Aliases: numbers_to_words n2w
> 
> ### ** Examples
> 
> library(xfun)
> n2w(0, cap = TRUE)
[1] "Zero"
> n2w(0:121, and = TRUE)
  [1] "zero"                       "one"                       
  [3] "two"                        "three"                     
  [5] "four"                       "five"                      
  [7] "six"                        "seven"                     
  [9] "eight"                      "nine"                      
 [11] "ten"                        "eleven"                    
 [13] "twelve"                     "thirteen"                  
 [15] "fourteen"                   "fifteen"                   
 [17] "sixteen"                    "seventeen"                 
 [19] "eighteen"                   "nineteen"                  
 [21] "twenty"                     "twenty-one"                
 [23] "twenty-two"                 "twenty-three"              
 [25] "twenty-four"                "twenty-five"               
 [27] "twenty-six"                 "twenty-seven"              
 [29] "twenty-eight"               "twenty-nine"               
 [31] "thirty"                     "thirty-one"                
 [33] "thirty-two"                 "thirty-three"              
 [35] "thirty-four"                "thirty-five"               
 [37] "thirty-six"                 "thirty-seven"              
 [39] "thirty-eight"               "thirty-nine"               
 [41] "forty"                      "forty-one"                 
 [43] "forty-two"                  "forty-three"               
 [45] "forty-four"                 "forty-five"                
 [47] "forty-six"                  "forty-seven"               
 [49] "forty-eight"                "forty-nine"                
 [51] "fifty"                      "fifty-one"                 
 [53] "fifty-two"                  "fifty-three"               
 [55] "fifty-four"                 "fifty-five"                
 [57] "fifty-six"                  "fifty-seven"               
 [59] "fifty-eight"                "fifty-nine"                
 [61] "sixty"                      "sixty-one"                 
 [63] "sixty-two"                  "sixty-three"               
 [65] "sixty-four"                 "sixty-five"                
 [67] "sixty-six"                  "sixty-seven"               
 [69] "sixty-eight"                "sixty-nine"                
 [71] "seventy"                    "seventy-one"               
 [73] "seventy-two"                "seventy-three"             
 [75] "seventy-four"               "seventy-five"              
 [77] "seventy-six"                "seventy-seven"             
 [79] "seventy-eight"              "seventy-nine"              
 [81] "eighty"                     "eighty-one"                
 [83] "eighty-two"                 "eighty-three"              
 [85] "eighty-four"                "eighty-five"               
 [87] "eighty-six"                 "eighty-seven"              
 [89] "eighty-eight"               "eighty-nine"               
 [91] "ninety"                     "ninety-one"                
 [93] "ninety-two"                 "ninety-three"              
 [95] "ninety-four"                "ninety-five"               
 [97] "ninety-six"                 "ninety-seven"              
 [99] "ninety-eight"               "ninety-nine"               
[101] "one hundred"                "one hundred and one"       
[103] "one hundred and two"        "one hundred and three"     
[105] "one hundred and four"       "one hundred and five"      
[107] "one hundred and six"        "one hundred and seven"     
[109] "one hundred and eight"      "one hundred and nine"      
[111] "one hundred and ten"        "one hundred and eleven"    
[113] "one hundred and twelve"     "one hundred and thirteen"  
[115] "one hundred and fourteen"   "one hundred and fifteen"   
[117] "one hundred and sixteen"    "one hundred and seventeen" 
[119] "one hundred and eighteen"   "one hundred and nineteen"  
[121] "one hundred and twenty"     "one hundred and twenty-one"
> n2w(1e+06)
[1] "one million"
> n2w(1e+11 + 12345678)
[1] "one hundred billion, twelve million, three hundred forty-five thousand, six hundred seventy-eight"
> n2w(-987654321)
[1] "minus nine hundred eighty-seven million, six hundred fifty-four thousand, three hundred twenty-one"
> n2w(1e+15 - 1)
[1] "nine hundred ninety-nine trillion, nine hundred ninety-nine billion, nine hundred ninety-nine million, nine hundred ninety-nine thousand, nine hundred ninety-nine"
> n2w(123.456)
[1] "one hundred twenty-three point four five six"
> n2w(123.45678901)
[1] "one hundred twenty-three point four five six seven eight nine zero one"
> n2w(123.456789098765)
[1] "one hundred twenty-three point four five six seven eight nine zero nine eight seven six five"
> 
> 
> 
> cleanEx()
> nameEx("os")
> ### * os
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is_windows
> ### Title: Test for types of operating systems
> ### Aliases: is_windows is_unix is_macos is_linux is_arm64
> 
> ### ** Examples
> 
> library(xfun)
> # only one of the following statements should be true
> is_windows()
[1] FALSE
> is_unix() && is_macos()
[1] FALSE
> is_linux()
[1] TRUE
> # In newer Macs, CPU can be either Intel or Apple
> is_arm64()  # TRUE on Apple silicone machines
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("parse_only")
> ### * parse_only
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: parse_only
> ### Title: Parse R code and do not keep the source
> ### Aliases: parse_only
> 
> ### ** Examples
> 
> library(xfun)
> parse_only("1+1")
expression(1 + 1)
> parse_only(c("y~x", "1:5 # a comment"))
expression(y ~ x, 1:5)
> parse_only(character(0))
expression()
> 
> 
> 
> cleanEx()
> nameEx("pkg_attach")
> ### * pkg_attach
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pkg_attach
> ### Title: Attach or load packages, and automatically install missing
> ###   packages if requested
> ### Aliases: pkg_attach pkg_load loadable pkg_available pkg_attach2
> ###   pkg_load2
> 
> ### ** Examples
> 
> library(xfun)
> pkg_attach("stats", "graphics")
> # pkg_attach2('servr') # automatically install servr if it is not installed
> 
> (pkg_load("stats", "graphics"))
[1] TRUE TRUE
> 
> 
> 
> cleanEx()
> nameEx("process_file")
> ### * process_file
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: process_file
> ### Title: Read a text file, process the text with a function, and write
> ###   the text back
> ### Aliases: process_file sort_file
> 
> ### ** Examples
> 
> f = tempfile()
> xfun::write_utf8("Hello World", f)
> xfun::process_file(f, function(x) gsub("World", "woRld", x))
> xfun::read_utf8(f)  # see if it has been updated
[1] "Hello woRld"
> file.remove(f)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("prose_index")
> ### * prose_index
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: prose_index
> ### Title: Find the indices of lines in Markdown that are prose (not code
> ###   blocks)
> ### Aliases: prose_index
> 
> ### ** Examples
> 
> library(xfun)
> prose_index(c("a", "```", "b", "```", "c"))
[1] 1 5
> prose_index(c("a", "````", "```r", "1+1", "```", "````", "c"))
[1] 1 7
> 
> 
> 
> cleanEx()
> nameEx("protect_math")
> ### * protect_math
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: protect_math
> ### Title: Protect math expressions in pairs of backticks in Markdown
> ### Aliases: protect_math
> 
> ### ** Examples
> 
> library(xfun)
> protect_math(c("hi $a+b$", "hello $$\\alpha$$", "no math here: $x is $10 dollars"))
[1] "hi `\\(a+b\\)`"                  "hello `$$\\alpha$$`"            
[3] "no math here: $x is $10 dollars"
> protect_math(c("hi $$", "\\begin{equation}", "x + y = z", "\\end{equation}"))
[1] "hi $$"              "`\\begin{equation}" "x + y = z"         
[4] "\\end{equation}`"  
> protect_math("$a+b$", "===")
[1] "`===\\(a+b\\)===`"
> 
> 
> 
> cleanEx()
> nameEx("raw_string")
> ### * raw_string
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: raw_string
> ### Title: Print a character vector in its raw form
> ### Aliases: raw_string print.xfun_raw_string
> 
> ### ** Examples
> 
> library(xfun)
> raw_string(head(LETTERS))
A
B
C
D
E
F
> raw_string(c("a \"b\"", "hello\tworld!"))
a "b"
hello	world!
> 
> 
> 
> cleanEx()
> nameEx("read_all")
> ### * read_all
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: read_all
> ### Title: Read all text files and concatenate their content
> ### Aliases: read_all
> 
> ### ** Examples
> 
> # two files in this package
> fs = system.file("scripts", c("call-fun.R", "child-pids.sh"), package = "xfun")
> xfun::read_all(fs)
# This script is executed via the command line `Rscript call-fun.R arg1 arg2
# arg3`, where arg1 is a path to an .rds file, which contains the function and
# its arguments saved as a list; arg2 is a path to an .rds file to which the
# returned value of the function call is saved; arg3 saves the error message.

local({
  if (length(a <- commandArgs(TRUE)) != 3)
    stop('The number of arguments passed to Rscript should be 3.')
  # save the error message on exit if an error occurred
  on.exit(if (!file.exists(a[2])) saveRDS(geterrmessage(), a[3]))
  x = readRDS(a[1])  # list(fun, args)
  f = x[[1]]
  if (is.character(f)) f = eval(parse(text = f), envir = globalenv())
  r = do.call(f, x[[2]], envir = globalenv())
  saveRDS(r, a[2])
})
# given a PID, output all its child PIDs recursively
list_children() {
  for j in $(pgrep -P $1); do
    echo $j
    echo $(list_children $j)
  done
}

for i in $@; do
  list_children $i
done
> 
> # add file paths before file content and an empty line after content
> xfun::read_all(fs, before = function(f) paste("#-----", f, "-----"), after = "")
#----- /usr/local/lib/R/site-library/xfun/scripts/call-fun.R -----
# This script is executed via the command line `Rscript call-fun.R arg1 arg2
# arg3`, where arg1 is a path to an .rds file, which contains the function and
# its arguments saved as a list; arg2 is a path to an .rds file to which the
# returned value of the function call is saved; arg3 saves the error message.

local({
  if (length(a <- commandArgs(TRUE)) != 3)
    stop('The number of arguments passed to Rscript should be 3.')
  # save the error message on exit if an error occurred
  on.exit(if (!file.exists(a[2])) saveRDS(geterrmessage(), a[3]))
  x = readRDS(a[1])  # list(fun, args)
  f = x[[1]]
  if (is.character(f)) f = eval(parse(text = f), envir = globalenv())
  r = do.call(f, x[[2]], envir = globalenv())
  saveRDS(r, a[2])
})

#----- /usr/local/lib/R/site-library/xfun/scripts/child-pids.sh -----
# given a PID, output all its child PIDs recursively
list_children() {
  for j in $(pgrep -P $1); do
    echo $j
    echo $(list_children $j)
  done
}

for i in $@; do
  list_children $i
done

> 
> # add constants
> xfun::read_all(fs, before = "/*", after = c("*/", ""))
/*
# This script is executed via the command line `Rscript call-fun.R arg1 arg2
# arg3`, where arg1 is a path to an .rds file, which contains the function and
# its arguments saved as a list; arg2 is a path to an .rds file to which the
# returned value of the function call is saved; arg3 saves the error message.

local({
  if (length(a <- commandArgs(TRUE)) != 3)
    stop('The number of arguments passed to Rscript should be 3.')
  # save the error message on exit if an error occurred
  on.exit(if (!file.exists(a[2])) saveRDS(geterrmessage(), a[3]))
  x = readRDS(a[1])  # list(fun, args)
  f = x[[1]]
  if (is.character(f)) f = eval(parse(text = f), envir = globalenv())
  r = do.call(f, x[[2]], envir = globalenv())
  saveRDS(r, a[2])
})
*/

/*
# given a PID, output all its child PIDs recursively
list_children() {
  for j in $(pgrep -P $1); do
    echo $j
    echo $(list_children $j)
  done
}

for i in $@; do
  list_children $i
done
*/

> 
> 
> 
> cleanEx()
> nameEx("read_bin")
> ### * read_bin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: read_bin
> ### Title: Read all records of a binary file as a raw vector by default
> ### Aliases: read_bin
> 
> ### ** Examples
> 
> f = tempfile()
> cat("abc", file = f)
> xfun::read_bin(f)
[1] 61 62 63
> unlink(f)
> 
> 
> 
> cleanEx()
> nameEx("record")
> ### * record
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: record
> ### Title: Run R code and record the results
> ### Aliases: record format.xfun_record_results print.xfun_record_results
> 
> ### ** Examples
> 
> code = c("# a warning test", "1:2 + 1:3", "par(mar = c(4, 4, 1, .2))",
+     "barplot(5:1, col = 2:6, horiz = TRUE)", "head(iris)",
+     "sunflowerplot(iris[, 3:4], seg.col = 'purple')",
+     "if (TRUE) {\n  message('Hello, xfun::record()!')\n}",
+     "# throw an error", "1 + 'a'")
> res = xfun::record(code, dev.args = list(width = 9, height = 6.75),
+     error = TRUE)
> xfun::tree(res)
List of 13
 |-: 'record_source' chr [1:2] "# a warning test" "1:2 + 1:3"
 |  - attr(*, "lines")= int [1:2] 1 2
 |-: 'record_warning' chr "longer object length is not a multiple of shorter object length"
 |-: 'record_output' chr "[1] 2 4 4"
 |-: 'record_source' chr [1:2] "par(mar = c(4, 4, 1, .2))" "barplot(5:1, col = 2:6, horiz = TRUE)"
 |  - attr(*, "lines")= int [1:2] 3 3
 |-: 'record_plot' chr "xfun-record-1.png"
 |-: 'record_source' chr "head(iris)"
 |  - attr(*, "lines")= int [1:2] 5 5
 |-: 'record_output' chr [1:7] "  Sepal.Length Sepal.Width Petal.Length Petal.Width Species" "1          5.1         3.5          1.4         0.2  setosa" "2          4.9         3.0          1.4         0.2  setosa" "3          4.7         3.2          1.3         0.2  setosa" ...
 |-: 'record_source' chr "sunflowerplot(iris[, 3:4], seg.col = 'purple')"
 |  - attr(*, "lines")= int [1:2] 6 6
 |-: 'record_plot' chr "xfun-record-2.png"
 |-: 'record_source' chr [1:3] "if (TRUE) {" "  message('Hello, xfun::record()!')" "}"
 |  - attr(*, "lines")= int [1:2] 7 9
 |-: 'record_message' chr "Hello, xfun::record()!\n"
 |-: 'record_source' chr [1:2] "# throw an error" "1 + 'a'"
 |  - attr(*, "lines")= int [1:2] 10 11
 |-: 'record_error' chr "non-numeric argument to binary operator"
 - attr(*, "class")= chr "xfun_record_results"
> format(res)
# a warning test
1:2 + 1:3

#> longer object length is not a multiple of shorter object length

#> [1] 2 4 4

par(mar = c(4, 4, 1, .2))
barplot(5:1, col = 2:6, horiz = TRUE)

#> xfun-record-1.png

head(iris)

#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
#> 1          5.1         3.5          1.4         0.2  setosa
#> 2          4.9         3.0          1.4         0.2  setosa
#> 3          4.7         3.2          1.3         0.2  setosa
#> 4          4.6         3.1          1.5         0.2  setosa
#> 5          5.0         3.6          1.4         0.2  setosa
#> 6          5.4         3.9          1.7         0.4  setosa

sunflowerplot(iris[, 3:4], seg.col = 'purple')

#> xfun-record-2.png

if (TRUE) {
  message('Hello, xfun::record()!')
}

#> Hello, xfun::record()!

# throw an error
1 + 'a'

#> non-numeric argument to binary operator

> # find and clean up plot files
> plots = Filter(function(x) inherits(x, "record_plot"),
+     res)
> file.remove(unlist(plots))
[1] TRUE TRUE
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("relative_path")
> ### * relative_path
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: relative_path
> ### Title: Get the relative path of a path relative to a directory
> ### Aliases: relative_path
> 
> ### ** Examples
> 
> xfun::relative_path("foo/bar.txt", "foo/")
[1] "bar.txt"
> xfun::relative_path("foo/bar/a.txt", "foo/haha/")
[1] "../bar/a.txt"
> xfun::relative_path(getwd())
[1] "."
> 
> 
> 
> cleanEx()
> nameEx("rename_seq")
> ### * rename_seq
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rename_seq
> ### Title: Rename files with a sequential numeric prefix
> ### Aliases: rename_seq
> 
> ### ** Examples
> 
> xfun::rename_seq()
character(0)
> xfun::rename_seq("[.](jpeg|png)$", format = "%04d")
character(0)
> 
> 
> 
> cleanEx()
> nameEx("rest_api")
> ### * rest_api
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rest_api
> ### Title: Get data from a REST API
> ### Aliases: rest_api rest_api_raw github_api
> 
> ### ** Examples
> ## Don't show: 
> if (interactive()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ # a normal GET request
+ xfun::rest_api("https://httpbin.org", "/get")
+ xfun::rest_api_raw("https://httpbin.org", "/get")
+ 
+ # send the request with an auth header
+ xfun::rest_api("https://httpbin.org", "/headers", "OPEN SESAME!")
+ 
+ # with query parameters
+ xfun::rest_api("https://httpbin.org", "/response-headers", params = list(foo = "bar"))
+ 
+ # get the rate limit info from GitHub
+ xfun::github_api("/rate_limit")
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("retry")
> ### * retry
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: retry
> ### Title: Retry calling a function for a number of times
> ### Aliases: retry
> 
> ### ** Examples
> ## Don't show: 
> if (interactive()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ # read the GitHub releases info of the repo yihui/xfun
+ xfun::retry(xfun::github_releases, "yihui/xfun")
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("rstudio_type")
> ### * rstudio_type
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rstudio_type
> ### Title: Type a character vector into the RStudio source editor
> ### Aliases: rstudio_type
> 
> ### ** Examples
> 
> library(xfun)
> if (loadable("rstudioapi") && rstudioapi::isAvailable()) {
+     rstudio_type("Hello, RStudio! xfun::rstudio_type() looks pretty cool!",
+         pause = function() runif(1, 0, 0.5), mistake = 0.1)
+ }
> 
> 
> 
> cleanEx()
> nameEx("same_path")
> ### * same_path
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: same_path
> ### Title: Test if two paths are the same after they are normalized
> ### Aliases: same_path
> 
> ### ** Examples
> 
> library(xfun)
> same_path("~/foo", file.path(Sys.getenv("HOME"), "foo"))
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("session_info")
> ### * session_info
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: session_info
> ### Title: An alternative to sessionInfo() to print session information
> ### Aliases: session_info
> 
> ### ** Examples
> ## Don't show: 
> if (interactive()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ xfun::session_info()
+ if (xfun::loadable("MASS")) xfun::session_info("MASS")
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("set_envvar")
> ### * set_envvar
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: set_envvar
> ### Title: Set environment variables
> ### Aliases: set_envvar
> 
> ### ** Examples
> 
> vars = xfun::set_envvar(c(FOO = "1234"))
> Sys.getenv("FOO")
[1] "1234"
> xfun::set_envvar(vars)
> Sys.getenv("FOO")
[1] ""
> 
> 
> 
> cleanEx()
> nameEx("shrink_images")
> ### * shrink_images
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: shrink_images
> ### Title: Shrink images to a maximum width
> ### Aliases: shrink_images
> 
> ### ** Examples
> 
> f = xfun:::all_files("[.](png|jpe?g)$", R.home("doc"))
> file.copy(f, tempdir())
 [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
> f = file.path(tempdir(), basename(f))
> magick::image_info(magick::image_read(f))  # some widths are larger than 300
   format width height colorspace matte filesize density
1    JPEG    40     40       sRGB FALSE     1013   72x72
2    JPEG   100     76       sRGB FALSE    15985 300x300
3    JPEG    40     40       sRGB FALSE     1022   72x72
4    JPEG    40     40       sRGB FALSE     1021   72x72
5     PNG   559    432       sRGB  TRUE     5570   72x72
6     PNG   288    288       sRGB  TRUE     3884   72x72
7     PNG   259    331       sRGB  TRUE     3853   72x72
8     PNG   559    432       sRGB  TRUE     9376   72x72
9     PNG   432    432       sRGB  TRUE     2728   72x72
10    PNG   432    432       sRGB  TRUE     7185   72x72
> xfun::shrink_images(300, files = f)
> magick::image_info(magick::image_read(f))  # all widths <= 300 now
   format width height colorspace matte filesize density
1    JPEG    40     40       sRGB FALSE     1013   72x72
2    JPEG   100     76       sRGB FALSE    15985 300x300
3    JPEG    40     40       sRGB FALSE     1022   72x72
4    JPEG    40     40       sRGB FALSE     1021   72x72
5     PNG   300    232       Gray  TRUE     6363   72x72
6     PNG   288    288       sRGB  TRUE     3884   72x72
7     PNG   259    331       sRGB  TRUE     3853   72x72
8     PNG   300    232       Gray  TRUE     9759   72x72
9     PNG   300    300       Gray  TRUE     4466   72x72
10    PNG   300    300       Gray  TRUE     8132   72x72
> file.remove(f)
 [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
> 
> 
> 
> cleanEx()
> nameEx("split_lines")
> ### * split_lines
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: split_lines
> ### Title: Split a character vector by line breaks
> ### Aliases: split_lines
> 
> ### ** Examples
> 
> xfun::split_lines(c("a", "b\nc"))
[1] "a" "b" "c"
> 
> 
> 
> cleanEx()
> nameEx("split_source")
> ### * split_source
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: split_source
> ### Title: Split source lines into complete expressions
> ### Aliases: split_source
> 
> ### ** Examples
> 
> code = c("# comment 1", "# comment 2", "if (TRUE) {", "1 + 1", "}", "print(1:5)")
> xfun::split_source(code)
[[1]]
[1] "# comment 1"

[[2]]
[1] "# comment 2"

[[3]]
[1] "if (TRUE) {" "1 + 1"       "}"          

[[4]]
[1] "print(1:5)"

> xfun::split_source(code, merge_comments = TRUE)
[[1]]
[1] "# comment 1" "# comment 2" "if (TRUE) {" "1 + 1"       "}"          

[[2]]
[1] "print(1:5)"

> 
> 
> 
> cleanEx()
> nameEx("strict_list")
> ### * strict_list
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: strict_list
> ### Title: Strict lists
> ### Aliases: strict_list as_strict_list $.xfun_strict_list
> ###   print.xfun_strict_list
> 
> ### ** Examples
> 
> library(xfun)
> (z = strict_list(aaa = "I am aaa", b = 1:5))
$aaa
[1] "I am aaa"

$b
[1] 1 2 3 4 5

> z$a  # NULL!
NULL
> z$aaa  # I am aaa
[1] "I am aaa"
> z$b
[1] 1 2 3 4 5
> z$c = "create a new element"
> 
> z2 = unclass(z)  # a normal list
> z2$a  # partial matching
[1] "I am aaa"
> 
> z3 = as_strict_list(z2)  # a strict list again
> z3$a  # NULL again!
NULL
> 
> 
> 
> cleanEx()
> nameEx("strip_html")
> ### * strip_html
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: strip_html
> ### Title: Strip HTML tags
> ### Aliases: strip_html
> 
> ### ** Examples
> 
> xfun::strip_html("<a href=\"#\">Hello <!-- comment -->world!</a>")
[1] "Hello world!"
> 
> 
> 
> cleanEx()
> nameEx("system3")
> ### * system3
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: system3
> ### Title: Run 'system2()' and mark its character output as UTF-8 if
> ###   appropriate
> ### Aliases: system3
> 
> ### ** Examples
> ## Don't show: 
> if (interactive()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ a = shQuote(c("-e", "print(intToUtf8(c(20320, 22909)))"))
+ x2 = system2("Rscript", a, stdout = TRUE)
+ Encoding(x2)  # unknown
+ 
+ x3 = xfun::system3("Rscript", a, stdout = TRUE)
+ # encoding of x3 should be UTF-8 if the current locale is UTF-8
+ !l10n_info()[["UTF-8"]] || Encoding(x3) == "UTF-8"  # should be TRUE
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("tinify")
> ### * tinify
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tinify
> ### Title: Use the Tinify API to compress PNG and JPEG images
> ### Aliases: tinify tinify_dir
> 
> ### ** Examples
> ## Don't show: 
> if (interactive()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ f = xfun:::R_logo("jpg$")
+ xfun::tinify(f)  # remember to set the API key before trying this
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("tojson")
> ### * tojson
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tojson
> ### Title: A simple JSON serializer
> ### Aliases: tojson json_vector
> 
> ### ** Examples
> 
> library(xfun)
> tojson(NULL)
[1] "null"
> tojson(1:10)
[1] "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]"
> tojson(TRUE)
[1] "true"
> tojson(FALSE)
[1] "false"
> cat(tojson(list(a = 1, b = list(c = 1:3, d = "abc"))))
{
"a": 1,
"b": {
"c": [1, 2, 3],
"d": "abc"
}
}> cat(tojson(list(c("a", "b"), 1:5, TRUE)))
[["a", "b"], [1, 2, 3, 4, 5], true]> 
> # the class JS_EVAL is originally from htmlwidgets::JS()
> JS = function(x) structure(x, class = "JS_EVAL")
> cat(tojson(list(a = 1:5, b = JS("function() {return true;}"))))
{
"a": [1, 2, 3, 4, 5],
"b": function() {return true;}
}> 
> 
> 
> cleanEx()
> nameEx("tree")
> ### * tree
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tree
> ### Title: Turn the output of 'str()' into a tree diagram
> ### Aliases: tree
> 
> ### ** Examples
> 
> fit = lsfit(1:9, 1:9)
> str(fit)
List of 4
 $ coefficients: Named num [1:2] 1.18e-15 1.00
  ..- attr(*, "names")= chr [1:2] "Intercept" "X"
 $ residuals   : num [1:9] -9.01e-16 1.72e-15 -2.47e-16 -2.25e-16 -2.03e-16 ...
 $ intercept   : logi TRUE
 $ qr          :List of 6
  ..$ qt   : num [1:9] -1.50e+01 7.75 -2.22e-16 0.00 2.22e-16 ...
  ..$ qr   : num [1:9, 1:2] -3 0.333 0.333 0.333 0.333 ...
  .. ..- attr(*, "dimnames")=List of 2
  .. .. ..$ : NULL
  .. .. ..$ : chr [1:2] "Intercept" "X"
  ..$ qraux: num [1:2] 1.33 1.26
  ..$ rank : int 2
  ..$ pivot: int [1:2] 1 2
  ..$ tol  : num 1e-07
  ..- attr(*, "class")= chr "qr"
> xfun::tree(fit)
List of 4
 |-coefficients: Named num [1:2] 1.18e-15 1.00
 |  - attr(*, "names")= chr [1:2] "Intercept" "X"
 |-residuals   : num [1:9] -9.01e-16 1.72e-15 -2.47e-16 -2.25e-16 -2.03e-16 ...
 |-intercept   : logi TRUE
 |-qr          :List of 6
    |-qt   : num [1:9] -1.50e+01 7.75 -2.22e-16 0.00 2.22e-16 ...
    |-qr   : num [1:9, 1:2] -3 0.333 0.333 0.333 0.333 ...
    |  - attr(*, "dimnames")=List of 2
    |     |-: NULL
    |     |-: chr [1:2] "Intercept" "X"
    |-qraux: num [1:2] 1.33 1.26
    |-rank : int 2
    |-pivot: int [1:2] 1 2
    |-tol  : num 1e-07
    - attr(*, "class")= chr "qr"
> 
> fit = lm(dist ~ speed, data = cars)
> str(fit)
List of 12
 $ coefficients : Named num [1:2] -17.58 3.93
  ..- attr(*, "names")= chr [1:2] "(Intercept)" "speed"
 $ residuals    : Named num [1:50] 3.85 11.85 -5.95 12.05 2.12 ...
  ..- attr(*, "names")= chr [1:50] "1" "2" "3" "4" ...
 $ effects      : Named num [1:50] -303.914 145.552 -8.115 9.885 0.194 ...
  ..- attr(*, "names")= chr [1:50] "(Intercept)" "speed" "" "" ...
 $ rank         : int 2
 $ fitted.values: Named num [1:50] -1.85 -1.85 9.95 9.95 13.88 ...
  ..- attr(*, "names")= chr [1:50] "1" "2" "3" "4" ...
 $ assign       : int [1:2] 0 1
 $ qr           :List of 5
  ..$ qr   : num [1:50, 1:2] -7.071 0.141 0.141 0.141 0.141 ...
  .. ..- attr(*, "dimnames")=List of 2
  .. .. ..$ : chr [1:50] "1" "2" "3" "4" ...
  .. .. ..$ : chr [1:2] "(Intercept)" "speed"
  .. ..- attr(*, "assign")= int [1:2] 0 1
  ..$ qraux: num [1:2] 1.14 1.27
  ..$ pivot: int [1:2] 1 2
  ..$ tol  : num 1e-07
  ..$ rank : int 2
  ..- attr(*, "class")= chr "qr"
 $ df.residual  : int 48
 $ xlevels      : Named list()
 $ call         : language lm(formula = dist ~ speed, data = cars)
 $ terms        :Classes 'terms', 'formula'  language dist ~ speed
  .. ..- attr(*, "variables")= language list(dist, speed)
  .. ..- attr(*, "factors")= int [1:2, 1] 0 1
  .. .. ..- attr(*, "dimnames")=List of 2
  .. .. .. ..$ : chr [1:2] "dist" "speed"
  .. .. .. ..$ : chr "speed"
  .. ..- attr(*, "term.labels")= chr "speed"
  .. ..- attr(*, "order")= int 1
  .. ..- attr(*, "intercept")= int 1
  .. ..- attr(*, "response")= int 1
  .. ..- attr(*, ".Environment")=<environment: R_GlobalEnv> 
  .. ..- attr(*, "predvars")= language list(dist, speed)
  .. ..- attr(*, "dataClasses")= Named chr [1:2] "numeric" "numeric"
  .. .. ..- attr(*, "names")= chr [1:2] "dist" "speed"
 $ model        :'data.frame':	50 obs. of  2 variables:
  ..$ dist : num [1:50] 2 10 4 22 16 10 18 26 34 17 ...
  ..$ speed: num [1:50] 4 4 7 7 8 9 10 10 10 11 ...
  ..- attr(*, "terms")=Classes 'terms', 'formula'  language dist ~ speed
  .. .. ..- attr(*, "variables")= language list(dist, speed)
  .. .. ..- attr(*, "factors")= int [1:2, 1] 0 1
  .. .. .. ..- attr(*, "dimnames")=List of 2
  .. .. .. .. ..$ : chr [1:2] "dist" "speed"
  .. .. .. .. ..$ : chr "speed"
  .. .. ..- attr(*, "term.labels")= chr "speed"
  .. .. ..- attr(*, "order")= int 1
  .. .. ..- attr(*, "intercept")= int 1
  .. .. ..- attr(*, "response")= int 1
  .. .. ..- attr(*, ".Environment")=<environment: R_GlobalEnv> 
  .. .. ..- attr(*, "predvars")= language list(dist, speed)
  .. .. ..- attr(*, "dataClasses")= Named chr [1:2] "numeric" "numeric"
  .. .. .. ..- attr(*, "names")= chr [1:2] "dist" "speed"
 - attr(*, "class")= chr "lm"
> xfun::tree(fit)
List of 12
 |-coefficients : Named num [1:2] -17.58 3.93
 |  - attr(*, "names")= chr [1:2] "(Intercept)" "speed"
 |-residuals    : Named num [1:50] 3.85 11.85 -5.95 12.05 2.12 ...
 |  - attr(*, "names")= chr [1:50] "1" "2" "3" "4" ...
 |-effects      : Named num [1:50] -303.914 145.552 -8.115 9.885 0.194 ...
 |  - attr(*, "names")= chr [1:50] "(Intercept)" "speed" "" "" ...
 |-rank         : int 2
 |-fitted.values: Named num [1:50] -1.85 -1.85 9.95 9.95 13.88 ...
 |  - attr(*, "names")= chr [1:50] "1" "2" "3" "4" ...
 |-assign       : int [1:2] 0 1
 |-qr           :List of 5
 |  |-qr   : num [1:50, 1:2] -7.071 0.141 0.141 0.141 0.141 ...
 |  |  - attr(*, "dimnames")=List of 2
 |  |     |-: chr [1:50] "1" "2" "3" "4" ...
 |  |     |-: chr [1:2] "(Intercept)" "speed"
 |  |  - attr(*, "assign")= int [1:2] 0 1
 |  |-qraux: num [1:2] 1.14 1.27
 |  |-pivot: int [1:2] 1 2
 |  |-tol  : num 1e-07
 |  |-rank : int 2
 |  - attr(*, "class")= chr "qr"
 |-df.residual  : int 48
 |-xlevels      : Named list()
 |-call         : language lm(formula = dist ~ speed, data = cars)
 |-terms        :Classes 'terms', 'formula'  language dist ~ speed
 |     - attr(*, "variables")= language list(dist, speed)
 |     - attr(*, "factors")= int [1:2, 1] 0 1
 |        - attr(*, "dimnames")=List of 2
 |           |-: chr [1:2] "dist" "speed"
 |           |-: chr "speed"
 |     - attr(*, "term.labels")= chr "speed"
 |     - attr(*, "order")= int 1
 |     - attr(*, "intercept")= int 1
 |     - attr(*, "response")= int 1
 |     - attr(*, ".Environment")=<environment: R_GlobalEnv> 
 |     - attr(*, "predvars")= language list(dist, speed)
 |     - attr(*, "dataClasses")= Named chr [1:2] "numeric" "numeric"
 |        - attr(*, "names")= chr [1:2] "dist" "speed"
 |-model        :'data.frame':	50 obs. of  2 variables:
    |-dist : num [1:50] 2 10 4 22 16 10 18 26 34 17 ...
    |-speed: num [1:50] 4 4 7 7 8 9 10 10 10 11 ...
    - attr(*, "terms")=Classes 'terms', 'formula'  language dist ~ speed
          - attr(*, "variables")= language list(dist, speed)
          - attr(*, "factors")= int [1:2, 1] 0 1
             - attr(*, "dimnames")=List of 2
                |-: chr [1:2] "dist" "speed"
                |-: chr "speed"
          - attr(*, "term.labels")= chr "speed"
          - attr(*, "order")= int 1
          - attr(*, "intercept")= int 1
          - attr(*, "response")= int 1
          - attr(*, ".Environment")=<environment: R_GlobalEnv> 
          - attr(*, "predvars")= language list(dist, speed)
          - attr(*, "dataClasses")= Named chr [1:2] "numeric" "numeric"
             - attr(*, "names")= chr [1:2] "dist" "speed"
 - attr(*, "class")= chr "lm"
> 
> # some trivial examples
> xfun::tree(1:10)
 int [1:10] 1 2 3 4 5 6 7 8 9 10
> xfun::tree(iris)
'data.frame':	150 obs. of  5 variables:
 |-Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...
 |-Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...
 |-Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...
 |-Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...
 |-Species     : Factor w/ 3 levels "setosa","versicolor",..: 1 1 1 1 1 1 1 1 1 1 ...
> 
> 
> 
> cleanEx()
> nameEx("try_error")
> ### * try_error
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: try_error
> ### Title: Try an expression and see if it throws an error
> ### Aliases: try_error
> 
> ### ** Examples
> 
> xfun::try_error(stop("foo"))  # TRUE
[1] TRUE
> xfun::try_error(1:10)  # FALSE
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("try_silent")
> ### * try_silent
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: try_silent
> ### Title: Try to evaluate an expression silently
> ### Aliases: try_silent
> 
> ### ** Examples
> 
> library(xfun)
> z = try_silent(stop("Wrong!"))
> inherits(z, "try-error")
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("upload_imgur")
> ### * upload_imgur
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: upload_imgur
> ### Title: Upload an image to imgur.com
> ### Aliases: upload_imgur
> 
> ### ** Examples
> 
> ## Not run: 
> ##D f = tempfile(fileext = ".png")
> ##D png(f)
> ##D plot(rnorm(100), main = R.version.string)
> ##D dev.off()
> ##D 
> ##D res = imgur_upload(f, include_xml = TRUE)
> ##D res  # link to original URL of the image
> ##D attr(res, "XML")  # all information
> ##D if (interactive())
> ##D     browseURL(res)
> ##D 
> ##D # to use your own key
> ##D options(xfun.upload_imgur.key = "your imgur key")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("url_accessible")
> ### * url_accessible
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: url_accessible
> ### Title: Test if a URL is accessible
> ### Aliases: url_accessible
> 
> ### ** Examples
> 
> xfun::url_accessible("https://yihui.org")
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("url_filename")
> ### * url_filename
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: url_filename
> ### Title: Extract filenames from a URLs
> ### Aliases: url_filename
> 
> ### ** Examples
> 
> xfun::url_filename("https://yihui.org/images/logo.png")
[1] "logo.png"
> xfun::url_filename("https://yihui.org/index.html")
[1] "index.html"
> xfun::url_filename("https://yihui.org/index.html?foo=bar")
[1] "index.html"
> xfun::url_filename("https://yihui.org/index.html#about")
[1] "index.html"
> xfun::url_filename("https://yihui.org")
[1] "index.html"
> xfun::url_filename("https://yihui.org/")
[1] "index.html"
> 
> 
> 
> cleanEx()
> nameEx("valid_syntax")
> ### * valid_syntax
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: valid_syntax
> ### Title: Check if the syntax of the code is valid
> ### Aliases: valid_syntax
> 
> ### ** Examples
> 
> xfun::valid_syntax("1+1")
[1] TRUE
> xfun::valid_syntax("1+")
[1] FALSE
> xfun::valid_syntax(c("if(T){1+1}", "else {2+2}"), silent = FALSE)
Error in parse(text = code, keep.source = FALSE) : 
  <text>:2:1: unexpected 'else'
1: if(T){1+1}
2: else
   ^
[1] FALSE
> 
> 
> 
> cleanEx()
> nameEx("yaml_body")
> ### * yaml_body
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: yaml_body
> ### Title: Partition the YAML metadata and the body in a document
> ### Aliases: yaml_body
> 
> ### ** Examples
> 
> xfun::yaml_body(c("---", "title: Hello", "output: litedown::html_format", "---",
+     "", "Content."))
$yaml
$yaml$title
[1] "Hello"

$yaml$output
[1] "litedown::html_format"


$body
[1] ""         ""         ""         ""         ""         "Content."

$lines
[1] 1 4

> 
> 
> 
> cleanEx()
> nameEx("yaml_load")
> ### * yaml_load
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: yaml_load
> ### Title: Read YAML data
> ### Aliases: yaml_load
> 
> ### ** Examples
> 
> # test the simple parser without using the yaml package
> read_yaml = function(...) xfun::yaml_load(..., use_yaml = FALSE)
> read_yaml("a: 1")
$a
[1] 1

> read_yaml("a: 1\nb: \"foo\"\nc: null")
$a
[1] 1

$b
[1] "foo"

$c
NULL

> read_yaml("a:\n  b: false\n  c: true\n  d: 1.234\ne: bar")
$a
$a$b
[1] FALSE

$a$c
[1] TRUE

$a$d
[1] 1.234


$e
[1] "bar"

> read_yaml("a: !expr paste(1:10, collapse = \", \")")
$a
[1] "1, 2, 3, 4, 5, 6, 7, 8, 9, 10"

> read_yaml("a: [1, 3, 4, 2]")
$a
[1] 1 3 4 2

> read_yaml("a: [1, \"abc\", 4, 2]")
$a
[1] "1"   "abc" "4"   "2"  

> read_yaml("a: [\"foo\", \"bar\"]")
$a
[1] "foo" "bar"

> read_yaml("a: [true, false, true]")
$a
[1]  TRUE FALSE  TRUE

> # the other form of array is not supported
> read_yaml("a:\n  - b\n  - c")
$a
list()

> # and you must use the yaml package
> if (loadable("yaml")) yaml_load("a:\n  - b\n  - c")
$a
[1] "b" "c"

> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.835 0.068 6.879 1.05 1.637 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
