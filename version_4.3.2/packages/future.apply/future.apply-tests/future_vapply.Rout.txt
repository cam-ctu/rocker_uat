
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[13:21:32.274] plan(): Setting new future strategy stack:
[13:21:32.274] List of future strategies:
[13:21:32.274] 1. sequential:
[13:21:32.274]    - args: function (..., envir = parent.frame())
[13:21:32.274]    - tweaked: FALSE
[13:21:32.274]    - call: future::plan("sequential")
[13:21:32.289] plan(): nbrOfWorkers() = 1
> 
> 
> message("*** future_vapply() ...")
*** future_vapply() ...
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+   
+   x <- NULL
+   fun <- is.factor
+   fun_name <- "is.factor"
+   fun_value <- logical(1L)
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   y2 <- future_vapply(x, FUN = fun_name, FUN.VALUE = fun_value)
+   str(y2)
+   stopifnot(all.equal(y2, y0))
+   
+   x <- list()
+   fun <- is.numeric
+   fun_value <- logical(1L)
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   x <- integer()
+   fun <- identity
+   fun_value <- fun(integer(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   
+   df <- data.frame(x = 1:10, y = letters[1:10], stringsAsFactors=FALSE)
+   fun <- class
+   fun_value <- character(1L)
+   y0 <- vapply(df, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(df, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   x <- 1:10
+   fun <- function(x) double(0L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) integer(0L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- sqrt
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) c(x, x^2)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) matrix(x, nrow = 2L, ncol = 2L)
+   fun_value <- fun(integer(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) matrix(x, nrow = 2L, ncol = 2L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+ 
+   ## Ditto with dimnames on FUN.VALUE
+   fun <- function(x) {
+     matrix(x, nrow = 2L, ncol = 2L, dimnames = list(c("a", "b"), c("A", "B")))
+   }
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   message("- From example(vapply) ...")
+   x <- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE, FALSE, FALSE, TRUE))
+   y0 <- vapply(x, FUN = quantile, FUN.VALUE = double(5L))
+   y1 <- future_vapply(x, FUN = quantile, FUN.VALUE = double(5L))
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   i39 <- sapply(3:9, seq)
+   ys0 <- sapply(i39, fivenum)
+   ys1 <- future_sapply(i39, fivenum)
+   stopifnot(all.equal(ys1, ys0))
+   
+   yv0 <- vapply(i39, fivenum,
+           c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
+   yv1 <- future_vapply(i39, fivenum,
+          c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
+   str(yv1)
+   stopifnot(all.equal(yv1, yv0))
+   
+   v <- structure(10*(5:8), names = LETTERS[1:4])
+   f <- function(x, y) outer(rep(x, length.out = 3L), y)
+   ys0 <- sapply(v, f, y = 2*(1:5), simplify = "array")
+   ys1 <- future_sapply(v, f, y = 2*(1:5), simplify = "array")
+   stopifnot(all.equal(ys1, ys0))
+   
+   fv <- outer(1:3, 1:5)
+   y <- 2*(1:5)
+   yv0 <- vapply(v, f, fv, y = y)
+   yv1 <- future_vapply(v, f, fv, y = y)
+   str(yv1)
+   stopifnot(all.equal(yv1, yv0))
+   
+   y0 <- vapply(mtcars, FUN = is.numeric, FUN.VALUE = logical(1L))
+   y1 <- future_vapply(mtcars, FUN = is.numeric, FUN.VALUE = logical(1L))
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+ 
+   message("- future_vapply(x, ...) where length(x) != length(as.list(x)) ...")
+   x <- structure(list(a = 1, b = 2), class = "Foo")
+   as.list.Foo <- function(x, ...) c(x, c = 3)
+   y0 <- vapply(x, FUN = length, FUN.VALUE = -1L)
+   y1 <- future_vapply(x, FUN = length, FUN.VALUE = -1L)
+   stopifnot(identical(y1, y0))
+ 
+   message("- exceptions ...")
+   res <- tryCatch({
+     y0 <- vapply(1:3, FUN = identity, FUN.VALUE = c(3, 3))
+   }, error = identity)
+   stopifnot(inherits(res, "error"))
+   res <- tryCatch({
+     y1 <- future_vapply(1:3, FUN = identity, FUN.VALUE = c(3, 3))
+   }, error = identity)
+   stopifnot(inherits(res, "error"))
+   
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[13:21:32.398] plan(): Setting new future strategy stack:
[13:21:32.398] List of future strategies:
[13:21:32.398] 1. sequential:
[13:21:32.398]    - args: function (..., envir = parent.frame())
[13:21:32.398]    - tweaked: FALSE
[13:21:32.398]    - call: plan(strategy)
[13:21:32.410] plan(): nbrOfWorkers() = 1
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[13:21:32.417] future_lapply() ...
[13:21:32.423] Number of chunks: 1
[13:21:32.423] getGlobalsAndPackagesXApply() ...
[13:21:32.423]  - future.globals: TRUE
[13:21:32.424] getGlobalsAndPackages() ...
[13:21:32.424] Searching for globals...
[13:21:32.428] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:21:32.429] Searching for globals ... DONE
[13:21:32.429] Resolving globals: FALSE
[13:21:32.430] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[13:21:32.431] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:32.431] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:32.431] - packages: [1] ‘future.apply’
[13:21:32.431] getGlobalsAndPackages() ... DONE
[13:21:32.431]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:32.432]  - needed namespaces: [n=1] ‘future.apply’
[13:21:32.432] Finding globals ... DONE
[13:21:32.432]  - use_args: TRUE
[13:21:32.432]  - Getting '...' globals ...
[13:21:32.433] resolve() on list ...
[13:21:32.433]  recursive: 0
[13:21:32.433]  length: 1
[13:21:32.433]  elements: ‘...’
[13:21:32.433]  length: 0 (resolved future 1)
[13:21:32.433] resolve() on list ... DONE
[13:21:32.434]    - '...' content: [n=0] 
[13:21:32.434] List of 1
[13:21:32.434]  $ ...: list()
[13:21:32.434]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:32.434]  - attr(*, "where")=List of 1
[13:21:32.434]   ..$ ...:<environment: 0x563b6db8bcc0> 
[13:21:32.434]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:32.434]  - attr(*, "resolved")= logi TRUE
[13:21:32.434]  - attr(*, "total_size")= num NA
[13:21:32.436]  - Getting '...' globals ... DONE
[13:21:32.437] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:32.437] List of 8
[13:21:32.437]  $ ...future.FUN:function (x, ...)  
[13:21:32.437]  $ x_FUN        :function (x)  
[13:21:32.437]  $ times        : int 1
[13:21:32.437]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:32.437]  $ stop_if_not  :function (...)  
[13:21:32.437]  $ dim          : NULL
[13:21:32.437]  $ valid_types  : chr "character"
[13:21:32.437]  $ ...          : list()
[13:21:32.437]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:32.437]  - attr(*, "where")=List of 8
[13:21:32.437]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:32.437]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:32.437]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:32.437]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:32.437]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:32.437]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:32.437]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:32.437]   ..$ ...          :<environment: 0x563b6db8bcc0> 
[13:21:32.437]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:32.437]  - attr(*, "resolved")= logi FALSE
[13:21:32.437]  - attr(*, "total_size")= num 94208
[13:21:32.445] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:21:32.445] getGlobalsAndPackagesXApply() ... DONE
[13:21:32.445] Number of futures (= number of chunks): 1
[13:21:32.446] Launching 1 futures (chunks) ...
[13:21:32.446] Chunk #1 of 1 ...
[13:21:32.446]  - Finding globals in 'X' for chunk #1 ...
[13:21:32.446] getGlobalsAndPackages() ...
[13:21:32.446] Searching for globals...
[13:21:32.447] 
[13:21:32.447] Searching for globals ... DONE
[13:21:32.447] - globals: [0] <none>
[13:21:32.447] getGlobalsAndPackages() ... DONE
[13:21:32.447]    + additional globals found: [n=0] 
[13:21:32.447]    + additional namespaces needed: [n=0] 
[13:21:32.447]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:32.447]  - seeds: <none>
[13:21:32.447]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:32.448] getGlobalsAndPackages() ...
[13:21:32.448] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:32.448] Resolving globals: FALSE
[13:21:32.448] Tweak future expression to call with '...' arguments ...
[13:21:32.448] {
[13:21:32.448]     do.call(function(...) {
[13:21:32.448]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:32.448]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:32.448]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:32.448]             on.exit(options(oopts), add = TRUE)
[13:21:32.448]         }
[13:21:32.448]         {
[13:21:32.448]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:32.448]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:32.448]                 ...future.FUN(...future.X_jj, ...)
[13:21:32.448]             })
[13:21:32.448]         }
[13:21:32.448]     }, args = future.call.arguments)
[13:21:32.448] }
[13:21:32.448] Tweak future expression to call with '...' arguments ... DONE
[13:21:32.449] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:32.449] - packages: [1] ‘future.apply’
[13:21:32.449] getGlobalsAndPackages() ... DONE
[13:21:32.450] run() for ‘Future’ ...
[13:21:32.450] - state: ‘created’
[13:21:32.450] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:32.451] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:32.451] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:32.451]   - Field: ‘label’
[13:21:32.451]   - Field: ‘local’
[13:21:32.451]   - Field: ‘owner’
[13:21:32.451]   - Field: ‘envir’
[13:21:32.451]   - Field: ‘packages’
[13:21:32.451]   - Field: ‘gc’
[13:21:32.451]   - Field: ‘conditions’
[13:21:32.451]   - Field: ‘expr’
[13:21:32.452]   - Field: ‘uuid’
[13:21:32.452]   - Field: ‘seed’
[13:21:32.452]   - Field: ‘version’
[13:21:32.452]   - Field: ‘result’
[13:21:32.452]   - Field: ‘asynchronous’
[13:21:32.452]   - Field: ‘calls’
[13:21:32.452]   - Field: ‘globals’
[13:21:32.452]   - Field: ‘stdout’
[13:21:32.452]   - Field: ‘earlySignal’
[13:21:32.452]   - Field: ‘lazy’
[13:21:32.453]   - Field: ‘state’
[13:21:32.453] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:32.453] - Launch lazy future ...
[13:21:32.454] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:32.454] Packages needed by future strategies (n = 0): <none>
[13:21:32.455] {
[13:21:32.455]     {
[13:21:32.455]         {
[13:21:32.455]             ...future.startTime <- base::Sys.time()
[13:21:32.455]             {
[13:21:32.455]                 {
[13:21:32.455]                   {
[13:21:32.455]                     {
[13:21:32.455]                       base::local({
[13:21:32.455]                         has_future <- base::requireNamespace("future", 
[13:21:32.455]                           quietly = TRUE)
[13:21:32.455]                         if (has_future) {
[13:21:32.455]                           ns <- base::getNamespace("future")
[13:21:32.455]                           version <- ns[[".package"]][["version"]]
[13:21:32.455]                           if (is.null(version)) 
[13:21:32.455]                             version <- utils::packageVersion("future")
[13:21:32.455]                         }
[13:21:32.455]                         else {
[13:21:32.455]                           version <- NULL
[13:21:32.455]                         }
[13:21:32.455]                         if (!has_future || version < "1.8.0") {
[13:21:32.455]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:32.455]                             "", base::R.version$version.string), 
[13:21:32.455]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:32.455]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:32.455]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:32.455]                               "release", "version")], collapse = " "), 
[13:21:32.455]                             hostname = base::Sys.info()[["nodename"]])
[13:21:32.455]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:32.455]                             info)
[13:21:32.455]                           info <- base::paste(info, collapse = "; ")
[13:21:32.455]                           if (!has_future) {
[13:21:32.455]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:32.455]                               info)
[13:21:32.455]                           }
[13:21:32.455]                           else {
[13:21:32.455]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:32.455]                               info, version)
[13:21:32.455]                           }
[13:21:32.455]                           base::stop(msg)
[13:21:32.455]                         }
[13:21:32.455]                       })
[13:21:32.455]                     }
[13:21:32.455]                     base::local({
[13:21:32.455]                       for (pkg in "future.apply") {
[13:21:32.455]                         base::loadNamespace(pkg)
[13:21:32.455]                         base::library(pkg, character.only = TRUE)
[13:21:32.455]                       }
[13:21:32.455]                     })
[13:21:32.455]                   }
[13:21:32.455]                   options(future.plan = NULL)
[13:21:32.455]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:32.455]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:32.455]                 }
[13:21:32.455]                 ...future.workdir <- getwd()
[13:21:32.455]             }
[13:21:32.455]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:32.455]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:32.455]         }
[13:21:32.455]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:32.455]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:32.455]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:32.455]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:32.455]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:32.455]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:32.455]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:32.455]             base::names(...future.oldOptions))
[13:21:32.455]     }
[13:21:32.455]     if (FALSE) {
[13:21:32.455]     }
[13:21:32.455]     else {
[13:21:32.455]         if (TRUE) {
[13:21:32.455]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:32.455]                 open = "w")
[13:21:32.455]         }
[13:21:32.455]         else {
[13:21:32.455]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:32.455]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:32.455]         }
[13:21:32.455]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:32.455]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:32.455]             base::sink(type = "output", split = FALSE)
[13:21:32.455]             base::close(...future.stdout)
[13:21:32.455]         }, add = TRUE)
[13:21:32.455]     }
[13:21:32.455]     ...future.frame <- base::sys.nframe()
[13:21:32.455]     ...future.conditions <- base::list()
[13:21:32.455]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:32.455]     if (FALSE) {
[13:21:32.455]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:32.455]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:32.455]     }
[13:21:32.455]     ...future.result <- base::tryCatch({
[13:21:32.455]         base::withCallingHandlers({
[13:21:32.455]             ...future.value <- base::withVisible(base::local({
[13:21:32.455]                 do.call(function(...) {
[13:21:32.455]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:32.455]                   if (!identical(...future.globals.maxSize.org, 
[13:21:32.455]                     ...future.globals.maxSize)) {
[13:21:32.455]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:32.455]                     on.exit(options(oopts), add = TRUE)
[13:21:32.455]                   }
[13:21:32.455]                   {
[13:21:32.455]                     lapply(seq_along(...future.elements_ii), 
[13:21:32.455]                       FUN = function(jj) {
[13:21:32.455]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:32.455]                         ...future.FUN(...future.X_jj, ...)
[13:21:32.455]                       })
[13:21:32.455]                   }
[13:21:32.455]                 }, args = future.call.arguments)
[13:21:32.455]             }))
[13:21:32.455]             future::FutureResult(value = ...future.value$value, 
[13:21:32.455]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:32.455]                   ...future.rng), globalenv = if (FALSE) 
[13:21:32.455]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:32.455]                     ...future.globalenv.names))
[13:21:32.455]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:32.455]         }, condition = base::local({
[13:21:32.455]             c <- base::c
[13:21:32.455]             inherits <- base::inherits
[13:21:32.455]             invokeRestart <- base::invokeRestart
[13:21:32.455]             length <- base::length
[13:21:32.455]             list <- base::list
[13:21:32.455]             seq.int <- base::seq.int
[13:21:32.455]             signalCondition <- base::signalCondition
[13:21:32.455]             sys.calls <- base::sys.calls
[13:21:32.455]             `[[` <- base::`[[`
[13:21:32.455]             `+` <- base::`+`
[13:21:32.455]             `<<-` <- base::`<<-`
[13:21:32.455]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:32.455]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:32.455]                   3L)]
[13:21:32.455]             }
[13:21:32.455]             function(cond) {
[13:21:32.455]                 is_error <- inherits(cond, "error")
[13:21:32.455]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:32.455]                   NULL)
[13:21:32.455]                 if (is_error) {
[13:21:32.455]                   sessionInformation <- function() {
[13:21:32.455]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:32.455]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:32.455]                       search = base::search(), system = base::Sys.info())
[13:21:32.455]                   }
[13:21:32.455]                   ...future.conditions[[length(...future.conditions) + 
[13:21:32.455]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:32.455]                     cond$call), session = sessionInformation(), 
[13:21:32.455]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:32.455]                   signalCondition(cond)
[13:21:32.455]                 }
[13:21:32.455]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:32.455]                 "immediateCondition"))) {
[13:21:32.455]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:32.455]                   ...future.conditions[[length(...future.conditions) + 
[13:21:32.455]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:32.455]                   if (TRUE && !signal) {
[13:21:32.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:32.455]                     {
[13:21:32.455]                       inherits <- base::inherits
[13:21:32.455]                       invokeRestart <- base::invokeRestart
[13:21:32.455]                       is.null <- base::is.null
[13:21:32.455]                       muffled <- FALSE
[13:21:32.455]                       if (inherits(cond, "message")) {
[13:21:32.455]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:32.455]                         if (muffled) 
[13:21:32.455]                           invokeRestart("muffleMessage")
[13:21:32.455]                       }
[13:21:32.455]                       else if (inherits(cond, "warning")) {
[13:21:32.455]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:32.455]                         if (muffled) 
[13:21:32.455]                           invokeRestart("muffleWarning")
[13:21:32.455]                       }
[13:21:32.455]                       else if (inherits(cond, "condition")) {
[13:21:32.455]                         if (!is.null(pattern)) {
[13:21:32.455]                           computeRestarts <- base::computeRestarts
[13:21:32.455]                           grepl <- base::grepl
[13:21:32.455]                           restarts <- computeRestarts(cond)
[13:21:32.455]                           for (restart in restarts) {
[13:21:32.455]                             name <- restart$name
[13:21:32.455]                             if (is.null(name)) 
[13:21:32.455]                               next
[13:21:32.455]                             if (!grepl(pattern, name)) 
[13:21:32.455]                               next
[13:21:32.455]                             invokeRestart(restart)
[13:21:32.455]                             muffled <- TRUE
[13:21:32.455]                             break
[13:21:32.455]                           }
[13:21:32.455]                         }
[13:21:32.455]                       }
[13:21:32.455]                       invisible(muffled)
[13:21:32.455]                     }
[13:21:32.455]                     muffleCondition(cond, pattern = "^muffle")
[13:21:32.455]                   }
[13:21:32.455]                 }
[13:21:32.455]                 else {
[13:21:32.455]                   if (TRUE) {
[13:21:32.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:32.455]                     {
[13:21:32.455]                       inherits <- base::inherits
[13:21:32.455]                       invokeRestart <- base::invokeRestart
[13:21:32.455]                       is.null <- base::is.null
[13:21:32.455]                       muffled <- FALSE
[13:21:32.455]                       if (inherits(cond, "message")) {
[13:21:32.455]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:32.455]                         if (muffled) 
[13:21:32.455]                           invokeRestart("muffleMessage")
[13:21:32.455]                       }
[13:21:32.455]                       else if (inherits(cond, "warning")) {
[13:21:32.455]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:32.455]                         if (muffled) 
[13:21:32.455]                           invokeRestart("muffleWarning")
[13:21:32.455]                       }
[13:21:32.455]                       else if (inherits(cond, "condition")) {
[13:21:32.455]                         if (!is.null(pattern)) {
[13:21:32.455]                           computeRestarts <- base::computeRestarts
[13:21:32.455]                           grepl <- base::grepl
[13:21:32.455]                           restarts <- computeRestarts(cond)
[13:21:32.455]                           for (restart in restarts) {
[13:21:32.455]                             name <- restart$name
[13:21:32.455]                             if (is.null(name)) 
[13:21:32.455]                               next
[13:21:32.455]                             if (!grepl(pattern, name)) 
[13:21:32.455]                               next
[13:21:32.455]                             invokeRestart(restart)
[13:21:32.455]                             muffled <- TRUE
[13:21:32.455]                             break
[13:21:32.455]                           }
[13:21:32.455]                         }
[13:21:32.455]                       }
[13:21:32.455]                       invisible(muffled)
[13:21:32.455]                     }
[13:21:32.455]                     muffleCondition(cond, pattern = "^muffle")
[13:21:32.455]                   }
[13:21:32.455]                 }
[13:21:32.455]             }
[13:21:32.455]         }))
[13:21:32.455]     }, error = function(ex) {
[13:21:32.455]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:32.455]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:32.455]                 ...future.rng), started = ...future.startTime, 
[13:21:32.455]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:32.455]             version = "1.8"), class = "FutureResult")
[13:21:32.455]     }, finally = {
[13:21:32.455]         if (!identical(...future.workdir, getwd())) 
[13:21:32.455]             setwd(...future.workdir)
[13:21:32.455]         {
[13:21:32.455]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:32.455]                 ...future.oldOptions$nwarnings <- NULL
[13:21:32.455]             }
[13:21:32.455]             base::options(...future.oldOptions)
[13:21:32.455]             if (.Platform$OS.type == "windows") {
[13:21:32.455]                 old_names <- names(...future.oldEnvVars)
[13:21:32.455]                 envs <- base::Sys.getenv()
[13:21:32.455]                 names <- names(envs)
[13:21:32.455]                 common <- intersect(names, old_names)
[13:21:32.455]                 added <- setdiff(names, old_names)
[13:21:32.455]                 removed <- setdiff(old_names, names)
[13:21:32.455]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:32.455]                   envs[common]]
[13:21:32.455]                 NAMES <- toupper(changed)
[13:21:32.455]                 args <- list()
[13:21:32.455]                 for (kk in seq_along(NAMES)) {
[13:21:32.455]                   name <- changed[[kk]]
[13:21:32.455]                   NAME <- NAMES[[kk]]
[13:21:32.455]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:32.455]                     next
[13:21:32.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:32.455]                 }
[13:21:32.455]                 NAMES <- toupper(added)
[13:21:32.455]                 for (kk in seq_along(NAMES)) {
[13:21:32.455]                   name <- added[[kk]]
[13:21:32.455]                   NAME <- NAMES[[kk]]
[13:21:32.455]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:32.455]                     next
[13:21:32.455]                   args[[name]] <- ""
[13:21:32.455]                 }
[13:21:32.455]                 NAMES <- toupper(removed)
[13:21:32.455]                 for (kk in seq_along(NAMES)) {
[13:21:32.455]                   name <- removed[[kk]]
[13:21:32.455]                   NAME <- NAMES[[kk]]
[13:21:32.455]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:32.455]                     next
[13:21:32.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:32.455]                 }
[13:21:32.455]                 if (length(args) > 0) 
[13:21:32.455]                   base::do.call(base::Sys.setenv, args = args)
[13:21:32.455]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:32.455]             }
[13:21:32.455]             else {
[13:21:32.455]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:32.455]             }
[13:21:32.455]             {
[13:21:32.455]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:32.455]                   0L) {
[13:21:32.455]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:32.455]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:32.455]                   base::options(opts)
[13:21:32.455]                 }
[13:21:32.455]                 {
[13:21:32.455]                   {
[13:21:32.455]                     NULL
[13:21:32.455]                     RNGkind("Mersenne-Twister")
[13:21:32.455]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:32.455]                       inherits = FALSE)
[13:21:32.455]                   }
[13:21:32.455]                   options(future.plan = NULL)
[13:21:32.455]                   if (is.na(NA_character_)) 
[13:21:32.455]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:32.455]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:32.455]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:32.455]                   {
[13:21:32.455]                     future <- SequentialFuture(..., envir = envir)
[13:21:32.455]                     if (!future$lazy) 
[13:21:32.455]                       future <- run(future)
[13:21:32.455]                     invisible(future)
[13:21:32.455]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:32.455]                 }
[13:21:32.455]             }
[13:21:32.455]         }
[13:21:32.455]     })
[13:21:32.455]     if (TRUE) {
[13:21:32.455]         base::sink(type = "output", split = FALSE)
[13:21:32.455]         if (TRUE) {
[13:21:32.455]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:32.455]         }
[13:21:32.455]         else {
[13:21:32.455]             ...future.result["stdout"] <- base::list(NULL)
[13:21:32.455]         }
[13:21:32.455]         base::close(...future.stdout)
[13:21:32.455]         ...future.stdout <- NULL
[13:21:32.455]     }
[13:21:32.455]     ...future.result$conditions <- ...future.conditions
[13:21:32.455]     ...future.result$finished <- base::Sys.time()
[13:21:32.455]     ...future.result
[13:21:32.455] }
[13:21:32.457] assign_globals() ...
[13:21:32.457] List of 11
[13:21:32.457]  $ ...future.FUN            :function (x, ...)  
[13:21:32.457]  $ x_FUN                    :function (x)  
[13:21:32.457]  $ times                    : int 1
[13:21:32.457]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:32.457]  $ stop_if_not              :function (...)  
[13:21:32.457]  $ dim                      : NULL
[13:21:32.457]  $ valid_types              : chr "character"
[13:21:32.457]  $ future.call.arguments    : list()
[13:21:32.457]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:32.457]  $ ...future.elements_ii    :List of 2
[13:21:32.457]   ..$ x: int [1:10] 1 2 3 4 5 6 7 8 9 10
[13:21:32.457]   ..$ y: chr [1:10] "a" "b" "c" "d" ...
[13:21:32.457]  $ ...future.seeds_ii       : NULL
[13:21:32.457]  $ ...future.globals.maxSize: NULL
[13:21:32.457]  - attr(*, "where")=List of 11
[13:21:32.457]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:32.457]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:32.457]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:32.457]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:32.457]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:32.457]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:32.457]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:32.457]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:32.457]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:32.457]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:32.457]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:32.457]  - attr(*, "resolved")= logi FALSE
[13:21:32.457]  - attr(*, "total_size")= num 94208
[13:21:32.457]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:32.457]  - attr(*, "already-done")= logi TRUE
[13:21:32.465] - copied ‘...future.FUN’ to environment
[13:21:32.465] - copied ‘x_FUN’ to environment
[13:21:32.465] - copied ‘times’ to environment
[13:21:32.465] - copied ‘stopf’ to environment
[13:21:32.465] - copied ‘stop_if_not’ to environment
[13:21:32.465] - copied ‘dim’ to environment
[13:21:32.465] - copied ‘valid_types’ to environment
[13:21:32.465] - copied ‘future.call.arguments’ to environment
[13:21:32.465] - copied ‘...future.elements_ii’ to environment
[13:21:32.466] - copied ‘...future.seeds_ii’ to environment
[13:21:32.466] - copied ‘...future.globals.maxSize’ to environment
[13:21:32.466] assign_globals() ... done
[13:21:32.466] plan(): Setting new future strategy stack:
[13:21:32.466] List of future strategies:
[13:21:32.466] 1. sequential:
[13:21:32.466]    - args: function (..., envir = parent.frame())
[13:21:32.466]    - tweaked: FALSE
[13:21:32.466]    - call: NULL
[13:21:32.467] plan(): nbrOfWorkers() = 1
[13:21:32.468] plan(): Setting new future strategy stack:
[13:21:32.468] List of future strategies:
[13:21:32.468] 1. sequential:
[13:21:32.468]    - args: function (..., envir = parent.frame())
[13:21:32.468]    - tweaked: FALSE
[13:21:32.468]    - call: plan(strategy)
[13:21:32.468] plan(): nbrOfWorkers() = 1
[13:21:32.469] SequentialFuture started (and completed)
[13:21:32.469] - Launch lazy future ... done
[13:21:32.469] run() for ‘SequentialFuture’ ... done
[13:21:32.469] Created future:
[13:21:32.469] SequentialFuture:
[13:21:32.469] Label: ‘future_vapply-1’
[13:21:32.469] Expression:
[13:21:32.469] {
[13:21:32.469]     do.call(function(...) {
[13:21:32.469]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:32.469]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:32.469]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:32.469]             on.exit(options(oopts), add = TRUE)
[13:21:32.469]         }
[13:21:32.469]         {
[13:21:32.469]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:32.469]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:32.469]                 ...future.FUN(...future.X_jj, ...)
[13:21:32.469]             })
[13:21:32.469]         }
[13:21:32.469]     }, args = future.call.arguments)
[13:21:32.469] }
[13:21:32.469] Lazy evaluation: FALSE
[13:21:32.469] Asynchronous evaluation: FALSE
[13:21:32.469] Local evaluation: TRUE
[13:21:32.469] Environment: R_GlobalEnv
[13:21:32.469] Capture standard output: TRUE
[13:21:32.469] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:32.469] Globals: 11 objects totaling 92.81 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:32.469] Packages: 1 packages (‘future.apply’)
[13:21:32.469] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:32.469] Resolved: TRUE
[13:21:32.469] Value: 232 bytes of class ‘list’
[13:21:32.469] Early signaling: FALSE
[13:21:32.469] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:32.469] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:32.471] Chunk #1 of 1 ... DONE
[13:21:32.471] Launching 1 futures (chunks) ... DONE
[13:21:32.471] Resolving 1 futures (chunks) ...
[13:21:32.471] resolve() on list ...
[13:21:32.472]  recursive: 0
[13:21:32.472]  length: 1
[13:21:32.472] 
[13:21:32.472] resolved() for ‘SequentialFuture’ ...
[13:21:32.472] - state: ‘finished’
[13:21:32.472] - run: TRUE
[13:21:32.472] - result: ‘FutureResult’
[13:21:32.472] resolved() for ‘SequentialFuture’ ... done
[13:21:32.472] Future #1
[13:21:32.475] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:21:32.475] - nx: 1
[13:21:32.475] - relay: TRUE
[13:21:32.475] - stdout: TRUE
[13:21:32.475] - signal: TRUE
[13:21:32.475] - resignal: FALSE
[13:21:32.476] - force: TRUE
[13:21:32.476] - relayed: [n=1] FALSE
[13:21:32.476] - queued futures: [n=1] FALSE
[13:21:32.476]  - until=1
[13:21:32.476]  - relaying element #1
[13:21:32.476] - relayed: [n=1] TRUE
[13:21:32.476] - queued futures: [n=1] TRUE
[13:21:32.476] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:21:32.477]  length: 0 (resolved future 1)
[13:21:32.477] Relaying remaining futures
[13:21:32.477] signalConditionsASAP(NULL, pos=0) ...
[13:21:32.477] - nx: 1
[13:21:32.477] - relay: TRUE
[13:21:32.477] - stdout: TRUE
[13:21:32.477] - signal: TRUE
[13:21:32.477] - resignal: FALSE
[13:21:32.477] - force: TRUE
[13:21:32.477] - relayed: [n=1] TRUE
[13:21:32.477] - queued futures: [n=1] TRUE
 - flush all
[13:21:32.478] - relayed: [n=1] TRUE
[13:21:32.478] - queued futures: [n=1] TRUE
[13:21:32.478] signalConditionsASAP(NULL, pos=0) ... done
[13:21:32.478] resolve() on list ... DONE
[13:21:32.478]  - Number of value chunks collected: 1
[13:21:32.478] Resolving 1 futures (chunks) ... DONE
[13:21:32.478] Reducing values from 1 chunks ...
[13:21:32.478]  - Number of values collected after concatenation: 2
[13:21:32.478]  - Number of values expected: 2
[13:21:32.479] Reducing values from 1 chunks ... DONE
[13:21:32.479] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[13:21:32.480] future_lapply() ...
[13:21:32.482] Number of chunks: 1
[13:21:32.482] getGlobalsAndPackagesXApply() ...
[13:21:32.482]  - future.globals: TRUE
[13:21:32.482] getGlobalsAndPackages() ...
[13:21:32.482] Searching for globals...
[13:21:32.486] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[13:21:32.486] Searching for globals ... DONE
[13:21:32.486] Resolving globals: FALSE
[13:21:32.487] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[13:21:32.487] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:32.487] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:32.487] - packages: [1] ‘future.apply’
[13:21:32.488] getGlobalsAndPackages() ... DONE
[13:21:32.488]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:32.488]  - needed namespaces: [n=1] ‘future.apply’
[13:21:32.488] Finding globals ... DONE
[13:21:32.488]  - use_args: TRUE
[13:21:32.488]  - Getting '...' globals ...
[13:21:32.488] resolve() on list ...
[13:21:32.489]  recursive: 0
[13:21:32.489]  length: 1
[13:21:32.489]  elements: ‘...’
[13:21:32.489]  length: 0 (resolved future 1)
[13:21:32.489] resolve() on list ... DONE
[13:21:32.489]    - '...' content: [n=0] 
[13:21:32.489] List of 1
[13:21:32.489]  $ ...: list()
[13:21:32.489]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:32.489]  - attr(*, "where")=List of 1
[13:21:32.489]   ..$ ...:<environment: 0x563b6e44ae30> 
[13:21:32.489]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:32.489]  - attr(*, "resolved")= logi TRUE
[13:21:32.489]  - attr(*, "total_size")= num NA
[13:21:32.492]  - Getting '...' globals ... DONE
[13:21:32.492] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:32.492] List of 8
[13:21:32.492]  $ ...future.FUN:function (x, ...)  
[13:21:32.492]  $ x_FUN        :function (x)  
[13:21:32.492]  $ times        : int 0
[13:21:32.492]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:32.492]  $ stop_if_not  :function (...)  
[13:21:32.492]  $ dim          : NULL
[13:21:32.492]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:21:32.492]  $ ...          : list()
[13:21:32.492]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:32.492]  - attr(*, "where")=List of 8
[13:21:32.492]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:32.492]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:32.492]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:32.492]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:32.492]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:32.492]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:32.492]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:32.492]   ..$ ...          :<environment: 0x563b6e44ae30> 
[13:21:32.492]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:32.492]  - attr(*, "resolved")= logi FALSE
[13:21:32.492]  - attr(*, "total_size")= num 95472
[13:21:32.499] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:21:32.499] getGlobalsAndPackagesXApply() ... DONE
[13:21:32.500] Number of futures (= number of chunks): 1
[13:21:32.500] Launching 1 futures (chunks) ...
[13:21:32.500] Chunk #1 of 1 ...
[13:21:32.500]  - Finding globals in 'X' for chunk #1 ...
[13:21:32.500] getGlobalsAndPackages() ...
[13:21:32.500] Searching for globals...
[13:21:32.500] 
[13:21:32.500] Searching for globals ... DONE
[13:21:32.501] - globals: [0] <none>
[13:21:32.501] getGlobalsAndPackages() ... DONE
[13:21:32.501]    + additional globals found: [n=0] 
[13:21:32.501]    + additional namespaces needed: [n=0] 
[13:21:32.501]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:32.501]  - seeds: <none>
[13:21:32.501]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:32.501] getGlobalsAndPackages() ...
[13:21:32.501] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:32.502] Resolving globals: FALSE
[13:21:32.502] Tweak future expression to call with '...' arguments ...
[13:21:32.502] {
[13:21:32.502]     do.call(function(...) {
[13:21:32.502]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:32.502]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:32.502]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:32.502]             on.exit(options(oopts), add = TRUE)
[13:21:32.502]         }
[13:21:32.502]         {
[13:21:32.502]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:32.502]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:32.502]                 ...future.FUN(...future.X_jj, ...)
[13:21:32.502]             })
[13:21:32.502]         }
[13:21:32.502]     }, args = future.call.arguments)
[13:21:32.502] }
[13:21:32.502] Tweak future expression to call with '...' arguments ... DONE
[13:21:32.503] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:32.503] - packages: [1] ‘future.apply’
[13:21:32.503] getGlobalsAndPackages() ... DONE
[13:21:32.503] run() for ‘Future’ ...
[13:21:32.503] - state: ‘created’
[13:21:32.503] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:32.504] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:32.504] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:32.504]   - Field: ‘label’
[13:21:32.504]   - Field: ‘local’
[13:21:32.504]   - Field: ‘owner’
[13:21:32.504]   - Field: ‘envir’
[13:21:32.504]   - Field: ‘packages’
[13:21:32.504]   - Field: ‘gc’
[13:21:32.504]   - Field: ‘conditions’
[13:21:32.505]   - Field: ‘expr’
[13:21:32.505]   - Field: ‘uuid’
[13:21:32.505]   - Field: ‘seed’
[13:21:32.505]   - Field: ‘version’
[13:21:32.505]   - Field: ‘result’
[13:21:32.505]   - Field: ‘asynchronous’
[13:21:32.505]   - Field: ‘calls’
[13:21:32.505]   - Field: ‘globals’
[13:21:32.505]   - Field: ‘stdout’
[13:21:32.505]   - Field: ‘earlySignal’
[13:21:32.506]   - Field: ‘lazy’
[13:21:32.506]   - Field: ‘state’
[13:21:32.506] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:32.506] - Launch lazy future ...
[13:21:32.506] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:32.506] Packages needed by future strategies (n = 0): <none>
[13:21:32.507] {
[13:21:32.507]     {
[13:21:32.507]         {
[13:21:32.507]             ...future.startTime <- base::Sys.time()
[13:21:32.507]             {
[13:21:32.507]                 {
[13:21:32.507]                   {
[13:21:32.507]                     {
[13:21:32.507]                       base::local({
[13:21:32.507]                         has_future <- base::requireNamespace("future", 
[13:21:32.507]                           quietly = TRUE)
[13:21:32.507]                         if (has_future) {
[13:21:32.507]                           ns <- base::getNamespace("future")
[13:21:32.507]                           version <- ns[[".package"]][["version"]]
[13:21:32.507]                           if (is.null(version)) 
[13:21:32.507]                             version <- utils::packageVersion("future")
[13:21:32.507]                         }
[13:21:32.507]                         else {
[13:21:32.507]                           version <- NULL
[13:21:32.507]                         }
[13:21:32.507]                         if (!has_future || version < "1.8.0") {
[13:21:32.507]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:32.507]                             "", base::R.version$version.string), 
[13:21:32.507]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:32.507]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:32.507]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:32.507]                               "release", "version")], collapse = " "), 
[13:21:32.507]                             hostname = base::Sys.info()[["nodename"]])
[13:21:32.507]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:32.507]                             info)
[13:21:32.507]                           info <- base::paste(info, collapse = "; ")
[13:21:32.507]                           if (!has_future) {
[13:21:32.507]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:32.507]                               info)
[13:21:32.507]                           }
[13:21:32.507]                           else {
[13:21:32.507]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:32.507]                               info, version)
[13:21:32.507]                           }
[13:21:32.507]                           base::stop(msg)
[13:21:32.507]                         }
[13:21:32.507]                       })
[13:21:32.507]                     }
[13:21:32.507]                     base::local({
[13:21:32.507]                       for (pkg in "future.apply") {
[13:21:32.507]                         base::loadNamespace(pkg)
[13:21:32.507]                         base::library(pkg, character.only = TRUE)
[13:21:32.507]                       }
[13:21:32.507]                     })
[13:21:32.507]                   }
[13:21:32.507]                   options(future.plan = NULL)
[13:21:32.507]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:32.507]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:32.507]                 }
[13:21:32.507]                 ...future.workdir <- getwd()
[13:21:32.507]             }
[13:21:32.507]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:32.507]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:32.507]         }
[13:21:32.507]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:32.507]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:32.507]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:32.507]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:32.507]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:32.507]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:32.507]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:32.507]             base::names(...future.oldOptions))
[13:21:32.507]     }
[13:21:32.507]     if (FALSE) {
[13:21:32.507]     }
[13:21:32.507]     else {
[13:21:32.507]         if (TRUE) {
[13:21:32.507]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:32.507]                 open = "w")
[13:21:32.507]         }
[13:21:32.507]         else {
[13:21:32.507]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:32.507]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:32.507]         }
[13:21:32.507]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:32.507]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:32.507]             base::sink(type = "output", split = FALSE)
[13:21:32.507]             base::close(...future.stdout)
[13:21:32.507]         }, add = TRUE)
[13:21:32.507]     }
[13:21:32.507]     ...future.frame <- base::sys.nframe()
[13:21:32.507]     ...future.conditions <- base::list()
[13:21:32.507]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:32.507]     if (FALSE) {
[13:21:32.507]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:32.507]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:32.507]     }
[13:21:32.507]     ...future.result <- base::tryCatch({
[13:21:32.507]         base::withCallingHandlers({
[13:21:32.507]             ...future.value <- base::withVisible(base::local({
[13:21:32.507]                 do.call(function(...) {
[13:21:32.507]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:32.507]                   if (!identical(...future.globals.maxSize.org, 
[13:21:32.507]                     ...future.globals.maxSize)) {
[13:21:32.507]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:32.507]                     on.exit(options(oopts), add = TRUE)
[13:21:32.507]                   }
[13:21:32.507]                   {
[13:21:32.507]                     lapply(seq_along(...future.elements_ii), 
[13:21:32.507]                       FUN = function(jj) {
[13:21:32.507]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:32.507]                         ...future.FUN(...future.X_jj, ...)
[13:21:32.507]                       })
[13:21:32.507]                   }
[13:21:32.507]                 }, args = future.call.arguments)
[13:21:32.507]             }))
[13:21:32.507]             future::FutureResult(value = ...future.value$value, 
[13:21:32.507]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:32.507]                   ...future.rng), globalenv = if (FALSE) 
[13:21:32.507]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:32.507]                     ...future.globalenv.names))
[13:21:32.507]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:32.507]         }, condition = base::local({
[13:21:32.507]             c <- base::c
[13:21:32.507]             inherits <- base::inherits
[13:21:32.507]             invokeRestart <- base::invokeRestart
[13:21:32.507]             length <- base::length
[13:21:32.507]             list <- base::list
[13:21:32.507]             seq.int <- base::seq.int
[13:21:32.507]             signalCondition <- base::signalCondition
[13:21:32.507]             sys.calls <- base::sys.calls
[13:21:32.507]             `[[` <- base::`[[`
[13:21:32.507]             `+` <- base::`+`
[13:21:32.507]             `<<-` <- base::`<<-`
[13:21:32.507]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:32.507]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:32.507]                   3L)]
[13:21:32.507]             }
[13:21:32.507]             function(cond) {
[13:21:32.507]                 is_error <- inherits(cond, "error")
[13:21:32.507]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:32.507]                   NULL)
[13:21:32.507]                 if (is_error) {
[13:21:32.507]                   sessionInformation <- function() {
[13:21:32.507]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:32.507]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:32.507]                       search = base::search(), system = base::Sys.info())
[13:21:32.507]                   }
[13:21:32.507]                   ...future.conditions[[length(...future.conditions) + 
[13:21:32.507]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:32.507]                     cond$call), session = sessionInformation(), 
[13:21:32.507]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:32.507]                   signalCondition(cond)
[13:21:32.507]                 }
[13:21:32.507]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:32.507]                 "immediateCondition"))) {
[13:21:32.507]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:32.507]                   ...future.conditions[[length(...future.conditions) + 
[13:21:32.507]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:32.507]                   if (TRUE && !signal) {
[13:21:32.507]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:32.507]                     {
[13:21:32.507]                       inherits <- base::inherits
[13:21:32.507]                       invokeRestart <- base::invokeRestart
[13:21:32.507]                       is.null <- base::is.null
[13:21:32.507]                       muffled <- FALSE
[13:21:32.507]                       if (inherits(cond, "message")) {
[13:21:32.507]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:32.507]                         if (muffled) 
[13:21:32.507]                           invokeRestart("muffleMessage")
[13:21:32.507]                       }
[13:21:32.507]                       else if (inherits(cond, "warning")) {
[13:21:32.507]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:32.507]                         if (muffled) 
[13:21:32.507]                           invokeRestart("muffleWarning")
[13:21:32.507]                       }
[13:21:32.507]                       else if (inherits(cond, "condition")) {
[13:21:32.507]                         if (!is.null(pattern)) {
[13:21:32.507]                           computeRestarts <- base::computeRestarts
[13:21:32.507]                           grepl <- base::grepl
[13:21:32.507]                           restarts <- computeRestarts(cond)
[13:21:32.507]                           for (restart in restarts) {
[13:21:32.507]                             name <- restart$name
[13:21:32.507]                             if (is.null(name)) 
[13:21:32.507]                               next
[13:21:32.507]                             if (!grepl(pattern, name)) 
[13:21:32.507]                               next
[13:21:32.507]                             invokeRestart(restart)
[13:21:32.507]                             muffled <- TRUE
[13:21:32.507]                             break
[13:21:32.507]                           }
[13:21:32.507]                         }
[13:21:32.507]                       }
[13:21:32.507]                       invisible(muffled)
[13:21:32.507]                     }
[13:21:32.507]                     muffleCondition(cond, pattern = "^muffle")
[13:21:32.507]                   }
[13:21:32.507]                 }
[13:21:32.507]                 else {
[13:21:32.507]                   if (TRUE) {
[13:21:32.507]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:32.507]                     {
[13:21:32.507]                       inherits <- base::inherits
[13:21:32.507]                       invokeRestart <- base::invokeRestart
[13:21:32.507]                       is.null <- base::is.null
[13:21:32.507]                       muffled <- FALSE
[13:21:32.507]                       if (inherits(cond, "message")) {
[13:21:32.507]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:32.507]                         if (muffled) 
[13:21:32.507]                           invokeRestart("muffleMessage")
[13:21:32.507]                       }
[13:21:32.507]                       else if (inherits(cond, "warning")) {
[13:21:32.507]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:32.507]                         if (muffled) 
[13:21:32.507]                           invokeRestart("muffleWarning")
[13:21:32.507]                       }
[13:21:32.507]                       else if (inherits(cond, "condition")) {
[13:21:32.507]                         if (!is.null(pattern)) {
[13:21:32.507]                           computeRestarts <- base::computeRestarts
[13:21:32.507]                           grepl <- base::grepl
[13:21:32.507]                           restarts <- computeRestarts(cond)
[13:21:32.507]                           for (restart in restarts) {
[13:21:32.507]                             name <- restart$name
[13:21:32.507]                             if (is.null(name)) 
[13:21:32.507]                               next
[13:21:32.507]                             if (!grepl(pattern, name)) 
[13:21:32.507]                               next
[13:21:32.507]                             invokeRestart(restart)
[13:21:32.507]                             muffled <- TRUE
[13:21:32.507]                             break
[13:21:32.507]                           }
[13:21:32.507]                         }
[13:21:32.507]                       }
[13:21:32.507]                       invisible(muffled)
[13:21:32.507]                     }
[13:21:32.507]                     muffleCondition(cond, pattern = "^muffle")
[13:21:32.507]                   }
[13:21:32.507]                 }
[13:21:32.507]             }
[13:21:32.507]         }))
[13:21:32.507]     }, error = function(ex) {
[13:21:32.507]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:32.507]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:32.507]                 ...future.rng), started = ...future.startTime, 
[13:21:32.507]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:32.507]             version = "1.8"), class = "FutureResult")
[13:21:32.507]     }, finally = {
[13:21:32.507]         if (!identical(...future.workdir, getwd())) 
[13:21:32.507]             setwd(...future.workdir)
[13:21:32.507]         {
[13:21:32.507]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:32.507]                 ...future.oldOptions$nwarnings <- NULL
[13:21:32.507]             }
[13:21:32.507]             base::options(...future.oldOptions)
[13:21:32.507]             if (.Platform$OS.type == "windows") {
[13:21:32.507]                 old_names <- names(...future.oldEnvVars)
[13:21:32.507]                 envs <- base::Sys.getenv()
[13:21:32.507]                 names <- names(envs)
[13:21:32.507]                 common <- intersect(names, old_names)
[13:21:32.507]                 added <- setdiff(names, old_names)
[13:21:32.507]                 removed <- setdiff(old_names, names)
[13:21:32.507]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:32.507]                   envs[common]]
[13:21:32.507]                 NAMES <- toupper(changed)
[13:21:32.507]                 args <- list()
[13:21:32.507]                 for (kk in seq_along(NAMES)) {
[13:21:32.507]                   name <- changed[[kk]]
[13:21:32.507]                   NAME <- NAMES[[kk]]
[13:21:32.507]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:32.507]                     next
[13:21:32.507]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:32.507]                 }
[13:21:32.507]                 NAMES <- toupper(added)
[13:21:32.507]                 for (kk in seq_along(NAMES)) {
[13:21:32.507]                   name <- added[[kk]]
[13:21:32.507]                   NAME <- NAMES[[kk]]
[13:21:32.507]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:32.507]                     next
[13:21:32.507]                   args[[name]] <- ""
[13:21:32.507]                 }
[13:21:32.507]                 NAMES <- toupper(removed)
[13:21:32.507]                 for (kk in seq_along(NAMES)) {
[13:21:32.507]                   name <- removed[[kk]]
[13:21:32.507]                   NAME <- NAMES[[kk]]
[13:21:32.507]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:32.507]                     next
[13:21:32.507]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:32.507]                 }
[13:21:32.507]                 if (length(args) > 0) 
[13:21:32.507]                   base::do.call(base::Sys.setenv, args = args)
[13:21:32.507]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:32.507]             }
[13:21:32.507]             else {
[13:21:32.507]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:32.507]             }
[13:21:32.507]             {
[13:21:32.507]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:32.507]                   0L) {
[13:21:32.507]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:32.507]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:32.507]                   base::options(opts)
[13:21:32.507]                 }
[13:21:32.507]                 {
[13:21:32.507]                   {
[13:21:32.507]                     NULL
[13:21:32.507]                     RNGkind("Mersenne-Twister")
[13:21:32.507]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:32.507]                       inherits = FALSE)
[13:21:32.507]                   }
[13:21:32.507]                   options(future.plan = NULL)
[13:21:32.507]                   if (is.na(NA_character_)) 
[13:21:32.507]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:32.507]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:32.507]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:32.507]                   {
[13:21:32.507]                     future <- SequentialFuture(..., envir = envir)
[13:21:32.507]                     if (!future$lazy) 
[13:21:32.507]                       future <- run(future)
[13:21:32.507]                     invisible(future)
[13:21:32.507]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:32.507]                 }
[13:21:32.507]             }
[13:21:32.507]         }
[13:21:32.507]     })
[13:21:32.507]     if (TRUE) {
[13:21:32.507]         base::sink(type = "output", split = FALSE)
[13:21:32.507]         if (TRUE) {
[13:21:32.507]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:32.507]         }
[13:21:32.507]         else {
[13:21:32.507]             ...future.result["stdout"] <- base::list(NULL)
[13:21:32.507]         }
[13:21:32.507]         base::close(...future.stdout)
[13:21:32.507]         ...future.stdout <- NULL
[13:21:32.507]     }
[13:21:32.507]     ...future.result$conditions <- ...future.conditions
[13:21:32.507]     ...future.result$finished <- base::Sys.time()
[13:21:32.507]     ...future.result
[13:21:32.507] }
[13:21:32.509] assign_globals() ...
[13:21:32.509] List of 11
[13:21:32.509]  $ ...future.FUN            :function (x, ...)  
[13:21:32.509]  $ x_FUN                    :function (x)  
[13:21:32.509]  $ times                    : int 0
[13:21:32.509]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:32.509]  $ stop_if_not              :function (...)  
[13:21:32.509]  $ dim                      : NULL
[13:21:32.509]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:21:32.509]  $ future.call.arguments    : list()
[13:21:32.509]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:32.509]  $ ...future.elements_ii    :List of 10
[13:21:32.509]   ..$ : int 1
[13:21:32.509]   ..$ : int 2
[13:21:32.509]   ..$ : int 3
[13:21:32.509]   ..$ : int 4
[13:21:32.509]   ..$ : int 5
[13:21:32.509]   ..$ : int 6
[13:21:32.509]   ..$ : int 7
[13:21:32.509]   ..$ : int 8
[13:21:32.509]   ..$ : int 9
[13:21:32.509]   ..$ : int 10
[13:21:32.509]  $ ...future.seeds_ii       : NULL
[13:21:32.509]  $ ...future.globals.maxSize: NULL
[13:21:32.509]  - attr(*, "where")=List of 11
[13:21:32.509]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:32.509]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:32.509]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:32.509]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:32.509]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:32.509]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:32.509]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:32.509]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:32.509]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:32.509]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:32.509]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:32.509]  - attr(*, "resolved")= logi FALSE
[13:21:32.509]  - attr(*, "total_size")= num 95472
[13:21:32.509]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:32.509]  - attr(*, "already-done")= logi TRUE
[13:21:32.519] - copied ‘...future.FUN’ to environment
[13:21:32.519] - reassign environment for ‘x_FUN’
[13:21:32.519] - copied ‘x_FUN’ to environment
[13:21:32.519] - copied ‘times’ to environment
[13:21:32.519] - copied ‘stopf’ to environment
[13:21:32.519] - copied ‘stop_if_not’ to environment
[13:21:32.519] - copied ‘dim’ to environment
[13:21:32.519] - copied ‘valid_types’ to environment
[13:21:32.520] - copied ‘future.call.arguments’ to environment
[13:21:32.520] - copied ‘...future.elements_ii’ to environment
[13:21:32.520] - copied ‘...future.seeds_ii’ to environment
[13:21:32.520] - copied ‘...future.globals.maxSize’ to environment
[13:21:32.520] assign_globals() ... done
[13:21:32.520] plan(): Setting new future strategy stack:
[13:21:32.520] List of future strategies:
[13:21:32.520] 1. sequential:
[13:21:32.520]    - args: function (..., envir = parent.frame())
[13:21:32.520]    - tweaked: FALSE
[13:21:32.520]    - call: NULL
[13:21:32.521] plan(): nbrOfWorkers() = 1
[13:21:32.524] plan(): Setting new future strategy stack:
[13:21:32.524] List of future strategies:
[13:21:32.524] 1. sequential:
[13:21:32.524]    - args: function (..., envir = parent.frame())
[13:21:32.524]    - tweaked: FALSE
[13:21:32.524]    - call: plan(strategy)
[13:21:32.524] plan(): nbrOfWorkers() = 1
[13:21:32.524] SequentialFuture started (and completed)
[13:21:32.524] - Launch lazy future ... done
[13:21:32.525] run() for ‘SequentialFuture’ ... done
[13:21:32.525] Created future:
[13:21:32.525] SequentialFuture:
[13:21:32.525] Label: ‘future_vapply-1’
[13:21:32.525] Expression:
[13:21:32.525] {
[13:21:32.525]     do.call(function(...) {
[13:21:32.525]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:32.525]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:32.525]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:32.525]             on.exit(options(oopts), add = TRUE)
[13:21:32.525]         }
[13:21:32.525]         {
[13:21:32.525]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:32.525]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:32.525]                 ...future.FUN(...future.X_jj, ...)
[13:21:32.525]             })
[13:21:32.525]         }
[13:21:32.525]     }, args = future.call.arguments)
[13:21:32.525] }
[13:21:32.525] Lazy evaluation: FALSE
[13:21:32.525] Asynchronous evaluation: FALSE
[13:21:32.525] Local evaluation: TRUE
[13:21:32.525] Environment: R_GlobalEnv
[13:21:32.525] Capture standard output: TRUE
[13:21:32.525] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:32.525] Globals: 11 objects totaling 93.78 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:32.525] Packages: 1 packages (‘future.apply’)
[13:21:32.525] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:32.525] Resolved: TRUE
[13:21:32.525] Value: 480 bytes of class ‘list’
[13:21:32.525] Early signaling: FALSE
[13:21:32.525] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:32.525] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:32.526] Chunk #1 of 1 ... DONE
[13:21:32.526] Launching 1 futures (chunks) ... DONE
[13:21:32.526] Resolving 1 futures (chunks) ...
[13:21:32.526] resolve() on list ...
[13:21:32.526]  recursive: 0
[13:21:32.527]  length: 1
[13:21:32.527] 
[13:21:32.527] resolved() for ‘SequentialFuture’ ...
[13:21:32.527] - state: ‘finished’
[13:21:32.527] - run: TRUE
[13:21:32.527] - result: ‘FutureResult’
[13:21:32.527] resolved() for ‘SequentialFuture’ ... done
[13:21:32.527] Future #1
[13:21:32.527] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:21:32.527] - nx: 1
[13:21:32.528] - relay: TRUE
[13:21:32.528] - stdout: TRUE
[13:21:32.528] - signal: TRUE
[13:21:32.528] - resignal: FALSE
[13:21:32.528] - force: TRUE
[13:21:32.528] - relayed: [n=1] FALSE
[13:21:32.528] - queued futures: [n=1] FALSE
[13:21:32.528]  - until=1
[13:21:32.528]  - relaying element #1
[13:21:32.529] - relayed: [n=1] TRUE
[13:21:32.529] - queued futures: [n=1] TRUE
[13:21:32.529] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:21:32.529]  length: 0 (resolved future 1)
[13:21:32.529] Relaying remaining futures
[13:21:32.529] signalConditionsASAP(NULL, pos=0) ...
[13:21:32.529] - nx: 1
[13:21:32.529] - relay: TRUE
[13:21:32.529] - stdout: TRUE
[13:21:32.529] - signal: TRUE
[13:21:32.529] - resignal: FALSE
[13:21:32.529] - force: TRUE
[13:21:32.530] - relayed: [n=1] TRUE
[13:21:32.530] - queued futures: [n=1] TRUE
 - flush all
[13:21:32.530] - relayed: [n=1] TRUE
[13:21:32.530] - queued futures: [n=1] TRUE
[13:21:32.530] signalConditionsASAP(NULL, pos=0) ... done
[13:21:32.530] resolve() on list ... DONE
[13:21:32.530]  - Number of value chunks collected: 1
[13:21:32.530] Resolving 1 futures (chunks) ... DONE
[13:21:32.530] Reducing values from 1 chunks ...
[13:21:32.530]  - Number of values collected after concatenation: 10
[13:21:32.531]  - Number of values expected: 10
[13:21:32.531] Reducing values from 1 chunks ... DONE
[13:21:32.531] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[13:21:32.532] future_lapply() ...
[13:21:32.534] Number of chunks: 1
[13:21:32.534] getGlobalsAndPackagesXApply() ...
[13:21:32.534]  - future.globals: TRUE
[13:21:32.534] getGlobalsAndPackages() ...
[13:21:32.534] Searching for globals...
[13:21:32.537] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[13:21:32.538] Searching for globals ... DONE
[13:21:32.538] Resolving globals: FALSE
[13:21:32.539] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[13:21:32.539] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:32.539] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:32.539] - packages: [1] ‘future.apply’
[13:21:32.539] getGlobalsAndPackages() ... DONE
[13:21:32.539]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:32.540]  - needed namespaces: [n=1] ‘future.apply’
[13:21:32.540] Finding globals ... DONE
[13:21:32.540]  - use_args: TRUE
[13:21:32.540]  - Getting '...' globals ...
[13:21:32.540] resolve() on list ...
[13:21:32.540]  recursive: 0
[13:21:32.540]  length: 1
[13:21:32.541]  elements: ‘...’
[13:21:32.541]  length: 0 (resolved future 1)
[13:21:32.541] resolve() on list ... DONE
[13:21:32.541]    - '...' content: [n=0] 
[13:21:32.541] List of 1
[13:21:32.541]  $ ...: list()
[13:21:32.541]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:32.541]  - attr(*, "where")=List of 1
[13:21:32.541]   ..$ ...:<environment: 0x563b6e740390> 
[13:21:32.541]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:32.541]  - attr(*, "resolved")= logi TRUE
[13:21:32.541]  - attr(*, "total_size")= num NA
[13:21:32.544]  - Getting '...' globals ... DONE
[13:21:32.544] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:32.544] List of 8
[13:21:32.544]  $ ...future.FUN:function (x, ...)  
[13:21:32.544]  $ x_FUN        :function (x)  
[13:21:32.544]  $ times        : int 0
[13:21:32.544]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:32.544]  $ stop_if_not  :function (...)  
[13:21:32.544]  $ dim          : NULL
[13:21:32.544]  $ valid_types  : chr [1:2] "logical" "integer"
[13:21:32.544]  $ ...          : list()
[13:21:32.544]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:32.544]  - attr(*, "where")=List of 8
[13:21:32.544]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:32.544]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:32.544]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:32.544]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:32.544]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:32.544]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:32.544]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:32.544]   ..$ ...          :<environment: 0x563b6e740390> 
[13:21:32.544]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:32.544]  - attr(*, "resolved")= logi FALSE
[13:21:32.544]  - attr(*, "total_size")= num 95400
[13:21:32.551] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:21:32.552] getGlobalsAndPackagesXApply() ... DONE
[13:21:32.552] Number of futures (= number of chunks): 1
[13:21:32.552] Launching 1 futures (chunks) ...
[13:21:32.552] Chunk #1 of 1 ...
[13:21:32.552]  - Finding globals in 'X' for chunk #1 ...
[13:21:32.552] getGlobalsAndPackages() ...
[13:21:32.552] Searching for globals...
[13:21:32.553] 
[13:21:32.553] Searching for globals ... DONE
[13:21:32.553] - globals: [0] <none>
[13:21:32.553] getGlobalsAndPackages() ... DONE
[13:21:32.553]    + additional globals found: [n=0] 
[13:21:32.553]    + additional namespaces needed: [n=0] 
[13:21:32.553]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:32.553]  - seeds: <none>
[13:21:32.553]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:32.554] getGlobalsAndPackages() ...
[13:21:32.554] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:32.554] Resolving globals: FALSE
[13:21:32.554] Tweak future expression to call with '...' arguments ...
[13:21:32.554] {
[13:21:32.554]     do.call(function(...) {
[13:21:32.554]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:32.554]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:32.554]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:32.554]             on.exit(options(oopts), add = TRUE)
[13:21:32.554]         }
[13:21:32.554]         {
[13:21:32.554]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:32.554]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:32.554]                 ...future.FUN(...future.X_jj, ...)
[13:21:32.554]             })
[13:21:32.554]         }
[13:21:32.554]     }, args = future.call.arguments)
[13:21:32.554] }
[13:21:32.554] Tweak future expression to call with '...' arguments ... DONE
[13:21:32.555] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:32.555] - packages: [1] ‘future.apply’
[13:21:32.555] getGlobalsAndPackages() ... DONE
[13:21:32.555] run() for ‘Future’ ...
[13:21:32.556] - state: ‘created’
[13:21:32.556] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:32.556] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:32.556] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:32.556]   - Field: ‘label’
[13:21:32.556]   - Field: ‘local’
[13:21:32.556]   - Field: ‘owner’
[13:21:32.557]   - Field: ‘envir’
[13:21:32.557]   - Field: ‘packages’
[13:21:32.557]   - Field: ‘gc’
[13:21:32.557]   - Field: ‘conditions’
[13:21:32.557]   - Field: ‘expr’
[13:21:32.557]   - Field: ‘uuid’
[13:21:32.557]   - Field: ‘seed’
[13:21:32.557]   - Field: ‘version’
[13:21:32.557]   - Field: ‘result’
[13:21:32.557]   - Field: ‘asynchronous’
[13:21:32.557]   - Field: ‘calls’
[13:21:32.558]   - Field: ‘globals’
[13:21:32.558]   - Field: ‘stdout’
[13:21:32.558]   - Field: ‘earlySignal’
[13:21:32.558]   - Field: ‘lazy’
[13:21:32.558]   - Field: ‘state’
[13:21:32.558] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:32.558] - Launch lazy future ...
[13:21:32.558] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:32.558] Packages needed by future strategies (n = 0): <none>
[13:21:32.559] {
[13:21:32.559]     {
[13:21:32.559]         {
[13:21:32.559]             ...future.startTime <- base::Sys.time()
[13:21:32.559]             {
[13:21:32.559]                 {
[13:21:32.559]                   {
[13:21:32.559]                     {
[13:21:32.559]                       base::local({
[13:21:32.559]                         has_future <- base::requireNamespace("future", 
[13:21:32.559]                           quietly = TRUE)
[13:21:32.559]                         if (has_future) {
[13:21:32.559]                           ns <- base::getNamespace("future")
[13:21:32.559]                           version <- ns[[".package"]][["version"]]
[13:21:32.559]                           if (is.null(version)) 
[13:21:32.559]                             version <- utils::packageVersion("future")
[13:21:32.559]                         }
[13:21:32.559]                         else {
[13:21:32.559]                           version <- NULL
[13:21:32.559]                         }
[13:21:32.559]                         if (!has_future || version < "1.8.0") {
[13:21:32.559]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:32.559]                             "", base::R.version$version.string), 
[13:21:32.559]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:32.559]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:32.559]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:32.559]                               "release", "version")], collapse = " "), 
[13:21:32.559]                             hostname = base::Sys.info()[["nodename"]])
[13:21:32.559]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:32.559]                             info)
[13:21:32.559]                           info <- base::paste(info, collapse = "; ")
[13:21:32.559]                           if (!has_future) {
[13:21:32.559]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:32.559]                               info)
[13:21:32.559]                           }
[13:21:32.559]                           else {
[13:21:32.559]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:32.559]                               info, version)
[13:21:32.559]                           }
[13:21:32.559]                           base::stop(msg)
[13:21:32.559]                         }
[13:21:32.559]                       })
[13:21:32.559]                     }
[13:21:32.559]                     base::local({
[13:21:32.559]                       for (pkg in "future.apply") {
[13:21:32.559]                         base::loadNamespace(pkg)
[13:21:32.559]                         base::library(pkg, character.only = TRUE)
[13:21:32.559]                       }
[13:21:32.559]                     })
[13:21:32.559]                   }
[13:21:32.559]                   options(future.plan = NULL)
[13:21:32.559]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:32.559]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:32.559]                 }
[13:21:32.559]                 ...future.workdir <- getwd()
[13:21:32.559]             }
[13:21:32.559]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:32.559]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:32.559]         }
[13:21:32.559]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:32.559]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:32.559]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:32.559]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:32.559]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:32.559]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:32.559]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:32.559]             base::names(...future.oldOptions))
[13:21:32.559]     }
[13:21:32.559]     if (FALSE) {
[13:21:32.559]     }
[13:21:32.559]     else {
[13:21:32.559]         if (TRUE) {
[13:21:32.559]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:32.559]                 open = "w")
[13:21:32.559]         }
[13:21:32.559]         else {
[13:21:32.559]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:32.559]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:32.559]         }
[13:21:32.559]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:32.559]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:32.559]             base::sink(type = "output", split = FALSE)
[13:21:32.559]             base::close(...future.stdout)
[13:21:32.559]         }, add = TRUE)
[13:21:32.559]     }
[13:21:32.559]     ...future.frame <- base::sys.nframe()
[13:21:32.559]     ...future.conditions <- base::list()
[13:21:32.559]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:32.559]     if (FALSE) {
[13:21:32.559]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:32.559]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:32.559]     }
[13:21:32.559]     ...future.result <- base::tryCatch({
[13:21:32.559]         base::withCallingHandlers({
[13:21:32.559]             ...future.value <- base::withVisible(base::local({
[13:21:32.559]                 do.call(function(...) {
[13:21:32.559]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:32.559]                   if (!identical(...future.globals.maxSize.org, 
[13:21:32.559]                     ...future.globals.maxSize)) {
[13:21:32.559]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:32.559]                     on.exit(options(oopts), add = TRUE)
[13:21:32.559]                   }
[13:21:32.559]                   {
[13:21:32.559]                     lapply(seq_along(...future.elements_ii), 
[13:21:32.559]                       FUN = function(jj) {
[13:21:32.559]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:32.559]                         ...future.FUN(...future.X_jj, ...)
[13:21:32.559]                       })
[13:21:32.559]                   }
[13:21:32.559]                 }, args = future.call.arguments)
[13:21:32.559]             }))
[13:21:32.559]             future::FutureResult(value = ...future.value$value, 
[13:21:32.559]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:32.559]                   ...future.rng), globalenv = if (FALSE) 
[13:21:32.559]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:32.559]                     ...future.globalenv.names))
[13:21:32.559]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:32.559]         }, condition = base::local({
[13:21:32.559]             c <- base::c
[13:21:32.559]             inherits <- base::inherits
[13:21:32.559]             invokeRestart <- base::invokeRestart
[13:21:32.559]             length <- base::length
[13:21:32.559]             list <- base::list
[13:21:32.559]             seq.int <- base::seq.int
[13:21:32.559]             signalCondition <- base::signalCondition
[13:21:32.559]             sys.calls <- base::sys.calls
[13:21:32.559]             `[[` <- base::`[[`
[13:21:32.559]             `+` <- base::`+`
[13:21:32.559]             `<<-` <- base::`<<-`
[13:21:32.559]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:32.559]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:32.559]                   3L)]
[13:21:32.559]             }
[13:21:32.559]             function(cond) {
[13:21:32.559]                 is_error <- inherits(cond, "error")
[13:21:32.559]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:32.559]                   NULL)
[13:21:32.559]                 if (is_error) {
[13:21:32.559]                   sessionInformation <- function() {
[13:21:32.559]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:32.559]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:32.559]                       search = base::search(), system = base::Sys.info())
[13:21:32.559]                   }
[13:21:32.559]                   ...future.conditions[[length(...future.conditions) + 
[13:21:32.559]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:32.559]                     cond$call), session = sessionInformation(), 
[13:21:32.559]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:32.559]                   signalCondition(cond)
[13:21:32.559]                 }
[13:21:32.559]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:32.559]                 "immediateCondition"))) {
[13:21:32.559]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:32.559]                   ...future.conditions[[length(...future.conditions) + 
[13:21:32.559]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:32.559]                   if (TRUE && !signal) {
[13:21:32.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:32.559]                     {
[13:21:32.559]                       inherits <- base::inherits
[13:21:32.559]                       invokeRestart <- base::invokeRestart
[13:21:32.559]                       is.null <- base::is.null
[13:21:32.559]                       muffled <- FALSE
[13:21:32.559]                       if (inherits(cond, "message")) {
[13:21:32.559]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:32.559]                         if (muffled) 
[13:21:32.559]                           invokeRestart("muffleMessage")
[13:21:32.559]                       }
[13:21:32.559]                       else if (inherits(cond, "warning")) {
[13:21:32.559]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:32.559]                         if (muffled) 
[13:21:32.559]                           invokeRestart("muffleWarning")
[13:21:32.559]                       }
[13:21:32.559]                       else if (inherits(cond, "condition")) {
[13:21:32.559]                         if (!is.null(pattern)) {
[13:21:32.559]                           computeRestarts <- base::computeRestarts
[13:21:32.559]                           grepl <- base::grepl
[13:21:32.559]                           restarts <- computeRestarts(cond)
[13:21:32.559]                           for (restart in restarts) {
[13:21:32.559]                             name <- restart$name
[13:21:32.559]                             if (is.null(name)) 
[13:21:32.559]                               next
[13:21:32.559]                             if (!grepl(pattern, name)) 
[13:21:32.559]                               next
[13:21:32.559]                             invokeRestart(restart)
[13:21:32.559]                             muffled <- TRUE
[13:21:32.559]                             break
[13:21:32.559]                           }
[13:21:32.559]                         }
[13:21:32.559]                       }
[13:21:32.559]                       invisible(muffled)
[13:21:32.559]                     }
[13:21:32.559]                     muffleCondition(cond, pattern = "^muffle")
[13:21:32.559]                   }
[13:21:32.559]                 }
[13:21:32.559]                 else {
[13:21:32.559]                   if (TRUE) {
[13:21:32.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:32.559]                     {
[13:21:32.559]                       inherits <- base::inherits
[13:21:32.559]                       invokeRestart <- base::invokeRestart
[13:21:32.559]                       is.null <- base::is.null
[13:21:32.559]                       muffled <- FALSE
[13:21:32.559]                       if (inherits(cond, "message")) {
[13:21:32.559]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:32.559]                         if (muffled) 
[13:21:32.559]                           invokeRestart("muffleMessage")
[13:21:32.559]                       }
[13:21:32.559]                       else if (inherits(cond, "warning")) {
[13:21:32.559]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:32.559]                         if (muffled) 
[13:21:32.559]                           invokeRestart("muffleWarning")
[13:21:32.559]                       }
[13:21:32.559]                       else if (inherits(cond, "condition")) {
[13:21:32.559]                         if (!is.null(pattern)) {
[13:21:32.559]                           computeRestarts <- base::computeRestarts
[13:21:32.559]                           grepl <- base::grepl
[13:21:32.559]                           restarts <- computeRestarts(cond)
[13:21:32.559]                           for (restart in restarts) {
[13:21:32.559]                             name <- restart$name
[13:21:32.559]                             if (is.null(name)) 
[13:21:32.559]                               next
[13:21:32.559]                             if (!grepl(pattern, name)) 
[13:21:32.559]                               next
[13:21:32.559]                             invokeRestart(restart)
[13:21:32.559]                             muffled <- TRUE
[13:21:32.559]                             break
[13:21:32.559]                           }
[13:21:32.559]                         }
[13:21:32.559]                       }
[13:21:32.559]                       invisible(muffled)
[13:21:32.559]                     }
[13:21:32.559]                     muffleCondition(cond, pattern = "^muffle")
[13:21:32.559]                   }
[13:21:32.559]                 }
[13:21:32.559]             }
[13:21:32.559]         }))
[13:21:32.559]     }, error = function(ex) {
[13:21:32.559]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:32.559]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:32.559]                 ...future.rng), started = ...future.startTime, 
[13:21:32.559]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:32.559]             version = "1.8"), class = "FutureResult")
[13:21:32.559]     }, finally = {
[13:21:32.559]         if (!identical(...future.workdir, getwd())) 
[13:21:32.559]             setwd(...future.workdir)
[13:21:32.559]         {
[13:21:32.559]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:32.559]                 ...future.oldOptions$nwarnings <- NULL
[13:21:32.559]             }
[13:21:32.559]             base::options(...future.oldOptions)
[13:21:32.559]             if (.Platform$OS.type == "windows") {
[13:21:32.559]                 old_names <- names(...future.oldEnvVars)
[13:21:32.559]                 envs <- base::Sys.getenv()
[13:21:32.559]                 names <- names(envs)
[13:21:32.559]                 common <- intersect(names, old_names)
[13:21:32.559]                 added <- setdiff(names, old_names)
[13:21:32.559]                 removed <- setdiff(old_names, names)
[13:21:32.559]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:32.559]                   envs[common]]
[13:21:32.559]                 NAMES <- toupper(changed)
[13:21:32.559]                 args <- list()
[13:21:32.559]                 for (kk in seq_along(NAMES)) {
[13:21:32.559]                   name <- changed[[kk]]
[13:21:32.559]                   NAME <- NAMES[[kk]]
[13:21:32.559]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:32.559]                     next
[13:21:32.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:32.559]                 }
[13:21:32.559]                 NAMES <- toupper(added)
[13:21:32.559]                 for (kk in seq_along(NAMES)) {
[13:21:32.559]                   name <- added[[kk]]
[13:21:32.559]                   NAME <- NAMES[[kk]]
[13:21:32.559]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:32.559]                     next
[13:21:32.559]                   args[[name]] <- ""
[13:21:32.559]                 }
[13:21:32.559]                 NAMES <- toupper(removed)
[13:21:32.559]                 for (kk in seq_along(NAMES)) {
[13:21:32.559]                   name <- removed[[kk]]
[13:21:32.559]                   NAME <- NAMES[[kk]]
[13:21:32.559]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:32.559]                     next
[13:21:32.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:32.559]                 }
[13:21:32.559]                 if (length(args) > 0) 
[13:21:32.559]                   base::do.call(base::Sys.setenv, args = args)
[13:21:32.559]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:32.559]             }
[13:21:32.559]             else {
[13:21:32.559]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:32.559]             }
[13:21:32.559]             {
[13:21:32.559]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:32.559]                   0L) {
[13:21:32.559]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:32.559]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:32.559]                   base::options(opts)
[13:21:32.559]                 }
[13:21:32.559]                 {
[13:21:32.559]                   {
[13:21:32.559]                     NULL
[13:21:32.559]                     RNGkind("Mersenne-Twister")
[13:21:32.559]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:32.559]                       inherits = FALSE)
[13:21:32.559]                   }
[13:21:32.559]                   options(future.plan = NULL)
[13:21:32.559]                   if (is.na(NA_character_)) 
[13:21:32.559]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:32.559]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:32.559]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:32.559]                   {
[13:21:32.559]                     future <- SequentialFuture(..., envir = envir)
[13:21:32.559]                     if (!future$lazy) 
[13:21:32.559]                       future <- run(future)
[13:21:32.559]                     invisible(future)
[13:21:32.559]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:32.559]                 }
[13:21:32.559]             }
[13:21:32.559]         }
[13:21:32.559]     })
[13:21:32.559]     if (TRUE) {
[13:21:32.559]         base::sink(type = "output", split = FALSE)
[13:21:32.559]         if (TRUE) {
[13:21:32.559]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:32.559]         }
[13:21:32.559]         else {
[13:21:32.559]             ...future.result["stdout"] <- base::list(NULL)
[13:21:32.559]         }
[13:21:32.559]         base::close(...future.stdout)
[13:21:32.559]         ...future.stdout <- NULL
[13:21:32.559]     }
[13:21:32.559]     ...future.result$conditions <- ...future.conditions
[13:21:32.559]     ...future.result$finished <- base::Sys.time()
[13:21:32.559]     ...future.result
[13:21:32.559] }
[13:21:32.561] assign_globals() ...
[13:21:32.561] List of 11
[13:21:32.561]  $ ...future.FUN            :function (x, ...)  
[13:21:32.561]  $ x_FUN                    :function (x)  
[13:21:32.561]  $ times                    : int 0
[13:21:32.561]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:32.561]  $ stop_if_not              :function (...)  
[13:21:32.561]  $ dim                      : NULL
[13:21:32.561]  $ valid_types              : chr [1:2] "logical" "integer"
[13:21:32.561]  $ future.call.arguments    : list()
[13:21:32.561]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:32.561]  $ ...future.elements_ii    :List of 10
[13:21:32.561]   ..$ : int 1
[13:21:32.561]   ..$ : int 2
[13:21:32.561]   ..$ : int 3
[13:21:32.561]   ..$ : int 4
[13:21:32.561]   ..$ : int 5
[13:21:32.561]   ..$ : int 6
[13:21:32.561]   ..$ : int 7
[13:21:32.561]   ..$ : int 8
[13:21:32.561]   ..$ : int 9
[13:21:32.561]   ..$ : int 10
[13:21:32.561]  $ ...future.seeds_ii       : NULL
[13:21:32.561]  $ ...future.globals.maxSize: NULL
[13:21:32.561]  - attr(*, "where")=List of 11
[13:21:32.561]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:32.561]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:32.561]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:32.561]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:32.561]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:32.561]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:32.561]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:32.561]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:32.561]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:32.561]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:32.561]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:32.561]  - attr(*, "resolved")= logi FALSE
[13:21:32.561]  - attr(*, "total_size")= num 95400
[13:21:32.561]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:32.561]  - attr(*, "already-done")= logi TRUE
[13:21:32.573] - copied ‘...future.FUN’ to environment
[13:21:32.573] - reassign environment for ‘x_FUN’
[13:21:32.573] - copied ‘x_FUN’ to environment
[13:21:32.573] - copied ‘times’ to environment
[13:21:32.573] - copied ‘stopf’ to environment
[13:21:32.573] - copied ‘stop_if_not’ to environment
[13:21:32.574] - copied ‘dim’ to environment
[13:21:32.574] - copied ‘valid_types’ to environment
[13:21:32.574] - copied ‘future.call.arguments’ to environment
[13:21:32.574] - copied ‘...future.elements_ii’ to environment
[13:21:32.574] - copied ‘...future.seeds_ii’ to environment
[13:21:32.574] - copied ‘...future.globals.maxSize’ to environment
[13:21:32.574] assign_globals() ... done
[13:21:32.575] plan(): Setting new future strategy stack:
[13:21:32.575] List of future strategies:
[13:21:32.575] 1. sequential:
[13:21:32.575]    - args: function (..., envir = parent.frame())
[13:21:32.575]    - tweaked: FALSE
[13:21:32.575]    - call: NULL
[13:21:32.575] plan(): nbrOfWorkers() = 1
[13:21:32.576] plan(): Setting new future strategy stack:
[13:21:32.576] List of future strategies:
[13:21:32.576] 1. sequential:
[13:21:32.576]    - args: function (..., envir = parent.frame())
[13:21:32.576]    - tweaked: FALSE
[13:21:32.576]    - call: plan(strategy)
[13:21:32.576] plan(): nbrOfWorkers() = 1
[13:21:32.577] SequentialFuture started (and completed)
[13:21:32.577] - Launch lazy future ... done
[13:21:32.577] run() for ‘SequentialFuture’ ... done
[13:21:32.577] Created future:
[13:21:32.577] SequentialFuture:
[13:21:32.577] Label: ‘future_vapply-1’
[13:21:32.577] Expression:
[13:21:32.577] {
[13:21:32.577]     do.call(function(...) {
[13:21:32.577]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:32.577]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:32.577]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:32.577]             on.exit(options(oopts), add = TRUE)
[13:21:32.577]         }
[13:21:32.577]         {
[13:21:32.577]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:32.577]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:32.577]                 ...future.FUN(...future.X_jj, ...)
[13:21:32.577]             })
[13:21:32.577]         }
[13:21:32.577]     }, args = future.call.arguments)
[13:21:32.577] }
[13:21:32.577] Lazy evaluation: FALSE
[13:21:32.577] Asynchronous evaluation: FALSE
[13:21:32.577] Local evaluation: TRUE
[13:21:32.577] Environment: R_GlobalEnv
[13:21:32.577] Capture standard output: TRUE
[13:21:32.577] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:32.577] Globals: 11 objects totaling 93.71 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:32.577] Packages: 1 packages (‘future.apply’)
[13:21:32.577] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:32.577] Resolved: TRUE
[13:21:32.577] Value: 480 bytes of class ‘list’
[13:21:32.577] Early signaling: FALSE
[13:21:32.577] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:32.577] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:32.578] Chunk #1 of 1 ... DONE
[13:21:32.578] Launching 1 futures (chunks) ... DONE
[13:21:32.578] Resolving 1 futures (chunks) ...
[13:21:32.579] resolve() on list ...
[13:21:32.579]  recursive: 0
[13:21:32.579]  length: 1
[13:21:32.579] 
[13:21:32.579] resolved() for ‘SequentialFuture’ ...
[13:21:32.579] - state: ‘finished’
[13:21:32.579] - run: TRUE
[13:21:32.579] - result: ‘FutureResult’
[13:21:32.579] resolved() for ‘SequentialFuture’ ... done
[13:21:32.579] Future #1
[13:21:32.580] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:21:32.580] - nx: 1
[13:21:32.580] - relay: TRUE
[13:21:32.580] - stdout: TRUE
[13:21:32.580] - signal: TRUE
[13:21:32.580] - resignal: FALSE
[13:21:32.580] - force: TRUE
[13:21:32.580] - relayed: [n=1] FALSE
[13:21:32.580] - queued futures: [n=1] FALSE
[13:21:32.580]  - until=1
[13:21:32.580]  - relaying element #1
[13:21:32.581] - relayed: [n=1] TRUE
[13:21:32.581] - queued futures: [n=1] TRUE
[13:21:32.581] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:21:32.581]  length: 0 (resolved future 1)
[13:21:32.581] Relaying remaining futures
[13:21:32.581] signalConditionsASAP(NULL, pos=0) ...
[13:21:32.581] - nx: 1
[13:21:32.581] - relay: TRUE
[13:21:32.581] - stdout: TRUE
[13:21:32.581] - signal: TRUE
[13:21:32.582] - resignal: FALSE
[13:21:32.582] - force: TRUE
[13:21:32.582] - relayed: [n=1] TRUE
[13:21:32.582] - queued futures: [n=1] TRUE
 - flush all
[13:21:32.582] - relayed: [n=1] TRUE
[13:21:32.582] - queued futures: [n=1] TRUE
[13:21:32.582] signalConditionsASAP(NULL, pos=0) ... done
[13:21:32.582] resolve() on list ... DONE
[13:21:32.582]  - Number of value chunks collected: 1
[13:21:32.582] Resolving 1 futures (chunks) ... DONE
[13:21:32.583] Reducing values from 1 chunks ...
[13:21:32.583]  - Number of values collected after concatenation: 10
[13:21:32.583]  - Number of values expected: 10
[13:21:32.583] Reducing values from 1 chunks ... DONE
[13:21:32.583] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[13:21:32.584] future_lapply() ...
[13:21:32.586] Number of chunks: 1
[13:21:32.586] getGlobalsAndPackagesXApply() ...
[13:21:32.586]  - future.globals: TRUE
[13:21:32.586] getGlobalsAndPackages() ...
[13:21:32.586] Searching for globals...
[13:21:32.589] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:21:32.589] Searching for globals ... DONE
[13:21:32.589] Resolving globals: FALSE
[13:21:32.590] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[13:21:32.590] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:32.591] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:32.591] - packages: [1] ‘future.apply’
[13:21:32.591] getGlobalsAndPackages() ... DONE
[13:21:32.591]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:32.591]  - needed namespaces: [n=1] ‘future.apply’
[13:21:32.591] Finding globals ... DONE
[13:21:32.591]  - use_args: TRUE
[13:21:32.591]  - Getting '...' globals ...
[13:21:32.592] resolve() on list ...
[13:21:32.592]  recursive: 0
[13:21:32.592]  length: 1
[13:21:32.592]  elements: ‘...’
[13:21:32.592]  length: 0 (resolved future 1)
[13:21:32.592] resolve() on list ... DONE
[13:21:32.592]    - '...' content: [n=0] 
[13:21:32.592] List of 1
[13:21:32.592]  $ ...: list()
[13:21:32.592]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:32.592]  - attr(*, "where")=List of 1
[13:21:32.592]   ..$ ...:<environment: 0x563b6ee15da0> 
[13:21:32.592]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:32.592]  - attr(*, "resolved")= logi TRUE
[13:21:32.592]  - attr(*, "total_size")= num NA
[13:21:32.597]  - Getting '...' globals ... DONE
[13:21:32.597] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:32.597] List of 8
[13:21:32.597]  $ ...future.FUN:function (x, ...)  
[13:21:32.597]  $ x_FUN        :function (x)  
[13:21:32.597]  $ times        : int 1
[13:21:32.597]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:32.597]  $ stop_if_not  :function (...)  
[13:21:32.597]  $ dim          : NULL
[13:21:32.597]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:21:32.597]  $ ...          : list()
[13:21:32.597]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:32.597]  - attr(*, "where")=List of 8
[13:21:32.597]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:32.597]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:32.597]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:32.597]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:32.597]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:32.597]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:32.597]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:32.597]   ..$ ...          :<environment: 0x563b6ee15da0> 
[13:21:32.597]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:32.597]  - attr(*, "resolved")= logi FALSE
[13:21:32.597]  - attr(*, "total_size")= num 94336
[13:21:32.603] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:21:32.603] getGlobalsAndPackagesXApply() ... DONE
[13:21:32.603] Number of futures (= number of chunks): 1
[13:21:32.603] Launching 1 futures (chunks) ...
[13:21:32.603] Chunk #1 of 1 ...
[13:21:32.603]  - Finding globals in 'X' for chunk #1 ...
[13:21:32.603] getGlobalsAndPackages() ...
[13:21:32.603] Searching for globals...
[13:21:32.604] 
[13:21:32.604] Searching for globals ... DONE
[13:21:32.604] - globals: [0] <none>
[13:21:32.604] getGlobalsAndPackages() ... DONE
[13:21:32.604]    + additional globals found: [n=0] 
[13:21:32.604]    + additional namespaces needed: [n=0] 
[13:21:32.604]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:32.604]  - seeds: <none>
[13:21:32.605]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:32.605] getGlobalsAndPackages() ...
[13:21:32.605] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:32.605] Resolving globals: FALSE
[13:21:32.605] Tweak future expression to call with '...' arguments ...
[13:21:32.605] {
[13:21:32.605]     do.call(function(...) {
[13:21:32.605]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:32.605]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:32.605]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:32.605]             on.exit(options(oopts), add = TRUE)
[13:21:32.605]         }
[13:21:32.605]         {
[13:21:32.605]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:32.605]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:32.605]                 ...future.FUN(...future.X_jj, ...)
[13:21:32.605]             })
[13:21:32.605]         }
[13:21:32.605]     }, args = future.call.arguments)
[13:21:32.605] }
[13:21:32.605] Tweak future expression to call with '...' arguments ... DONE
[13:21:32.606] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:32.606] - packages: [1] ‘future.apply’
[13:21:32.606] getGlobalsAndPackages() ... DONE
[13:21:32.607] run() for ‘Future’ ...
[13:21:32.607] - state: ‘created’
[13:21:32.607] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:32.607] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:32.607] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:32.607]   - Field: ‘label’
[13:21:32.607]   - Field: ‘local’
[13:21:32.608]   - Field: ‘owner’
[13:21:32.608]   - Field: ‘envir’
[13:21:32.608]   - Field: ‘packages’
[13:21:32.608]   - Field: ‘gc’
[13:21:32.608]   - Field: ‘conditions’
[13:21:32.608]   - Field: ‘expr’
[13:21:32.608]   - Field: ‘uuid’
[13:21:32.608]   - Field: ‘seed’
[13:21:32.608]   - Field: ‘version’
[13:21:32.608]   - Field: ‘result’
[13:21:32.608]   - Field: ‘asynchronous’
[13:21:32.609]   - Field: ‘calls’
[13:21:32.609]   - Field: ‘globals’
[13:21:32.609]   - Field: ‘stdout’
[13:21:32.609]   - Field: ‘earlySignal’
[13:21:32.609]   - Field: ‘lazy’
[13:21:32.609]   - Field: ‘state’
[13:21:32.609] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:32.609] - Launch lazy future ...
[13:21:32.609] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:32.610] Packages needed by future strategies (n = 0): <none>
[13:21:32.610] {
[13:21:32.610]     {
[13:21:32.610]         {
[13:21:32.610]             ...future.startTime <- base::Sys.time()
[13:21:32.610]             {
[13:21:32.610]                 {
[13:21:32.610]                   {
[13:21:32.610]                     {
[13:21:32.610]                       base::local({
[13:21:32.610]                         has_future <- base::requireNamespace("future", 
[13:21:32.610]                           quietly = TRUE)
[13:21:32.610]                         if (has_future) {
[13:21:32.610]                           ns <- base::getNamespace("future")
[13:21:32.610]                           version <- ns[[".package"]][["version"]]
[13:21:32.610]                           if (is.null(version)) 
[13:21:32.610]                             version <- utils::packageVersion("future")
[13:21:32.610]                         }
[13:21:32.610]                         else {
[13:21:32.610]                           version <- NULL
[13:21:32.610]                         }
[13:21:32.610]                         if (!has_future || version < "1.8.0") {
[13:21:32.610]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:32.610]                             "", base::R.version$version.string), 
[13:21:32.610]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:32.610]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:32.610]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:32.610]                               "release", "version")], collapse = " "), 
[13:21:32.610]                             hostname = base::Sys.info()[["nodename"]])
[13:21:32.610]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:32.610]                             info)
[13:21:32.610]                           info <- base::paste(info, collapse = "; ")
[13:21:32.610]                           if (!has_future) {
[13:21:32.610]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:32.610]                               info)
[13:21:32.610]                           }
[13:21:32.610]                           else {
[13:21:32.610]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:32.610]                               info, version)
[13:21:32.610]                           }
[13:21:32.610]                           base::stop(msg)
[13:21:32.610]                         }
[13:21:32.610]                       })
[13:21:32.610]                     }
[13:21:32.610]                     base::local({
[13:21:32.610]                       for (pkg in "future.apply") {
[13:21:32.610]                         base::loadNamespace(pkg)
[13:21:32.610]                         base::library(pkg, character.only = TRUE)
[13:21:32.610]                       }
[13:21:32.610]                     })
[13:21:32.610]                   }
[13:21:32.610]                   options(future.plan = NULL)
[13:21:32.610]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:32.610]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:32.610]                 }
[13:21:32.610]                 ...future.workdir <- getwd()
[13:21:32.610]             }
[13:21:32.610]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:32.610]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:32.610]         }
[13:21:32.610]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:32.610]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:32.610]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:32.610]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:32.610]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:32.610]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:32.610]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:32.610]             base::names(...future.oldOptions))
[13:21:32.610]     }
[13:21:32.610]     if (FALSE) {
[13:21:32.610]     }
[13:21:32.610]     else {
[13:21:32.610]         if (TRUE) {
[13:21:32.610]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:32.610]                 open = "w")
[13:21:32.610]         }
[13:21:32.610]         else {
[13:21:32.610]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:32.610]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:32.610]         }
[13:21:32.610]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:32.610]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:32.610]             base::sink(type = "output", split = FALSE)
[13:21:32.610]             base::close(...future.stdout)
[13:21:32.610]         }, add = TRUE)
[13:21:32.610]     }
[13:21:32.610]     ...future.frame <- base::sys.nframe()
[13:21:32.610]     ...future.conditions <- base::list()
[13:21:32.610]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:32.610]     if (FALSE) {
[13:21:32.610]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:32.610]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:32.610]     }
[13:21:32.610]     ...future.result <- base::tryCatch({
[13:21:32.610]         base::withCallingHandlers({
[13:21:32.610]             ...future.value <- base::withVisible(base::local({
[13:21:32.610]                 do.call(function(...) {
[13:21:32.610]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:32.610]                   if (!identical(...future.globals.maxSize.org, 
[13:21:32.610]                     ...future.globals.maxSize)) {
[13:21:32.610]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:32.610]                     on.exit(options(oopts), add = TRUE)
[13:21:32.610]                   }
[13:21:32.610]                   {
[13:21:32.610]                     lapply(seq_along(...future.elements_ii), 
[13:21:32.610]                       FUN = function(jj) {
[13:21:32.610]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:32.610]                         ...future.FUN(...future.X_jj, ...)
[13:21:32.610]                       })
[13:21:32.610]                   }
[13:21:32.610]                 }, args = future.call.arguments)
[13:21:32.610]             }))
[13:21:32.610]             future::FutureResult(value = ...future.value$value, 
[13:21:32.610]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:32.610]                   ...future.rng), globalenv = if (FALSE) 
[13:21:32.610]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:32.610]                     ...future.globalenv.names))
[13:21:32.610]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:32.610]         }, condition = base::local({
[13:21:32.610]             c <- base::c
[13:21:32.610]             inherits <- base::inherits
[13:21:32.610]             invokeRestart <- base::invokeRestart
[13:21:32.610]             length <- base::length
[13:21:32.610]             list <- base::list
[13:21:32.610]             seq.int <- base::seq.int
[13:21:32.610]             signalCondition <- base::signalCondition
[13:21:32.610]             sys.calls <- base::sys.calls
[13:21:32.610]             `[[` <- base::`[[`
[13:21:32.610]             `+` <- base::`+`
[13:21:32.610]             `<<-` <- base::`<<-`
[13:21:32.610]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:32.610]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:32.610]                   3L)]
[13:21:32.610]             }
[13:21:32.610]             function(cond) {
[13:21:32.610]                 is_error <- inherits(cond, "error")
[13:21:32.610]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:32.610]                   NULL)
[13:21:32.610]                 if (is_error) {
[13:21:32.610]                   sessionInformation <- function() {
[13:21:32.610]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:32.610]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:32.610]                       search = base::search(), system = base::Sys.info())
[13:21:32.610]                   }
[13:21:32.610]                   ...future.conditions[[length(...future.conditions) + 
[13:21:32.610]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:32.610]                     cond$call), session = sessionInformation(), 
[13:21:32.610]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:32.610]                   signalCondition(cond)
[13:21:32.610]                 }
[13:21:32.610]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:32.610]                 "immediateCondition"))) {
[13:21:32.610]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:32.610]                   ...future.conditions[[length(...future.conditions) + 
[13:21:32.610]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:32.610]                   if (TRUE && !signal) {
[13:21:32.610]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:32.610]                     {
[13:21:32.610]                       inherits <- base::inherits
[13:21:32.610]                       invokeRestart <- base::invokeRestart
[13:21:32.610]                       is.null <- base::is.null
[13:21:32.610]                       muffled <- FALSE
[13:21:32.610]                       if (inherits(cond, "message")) {
[13:21:32.610]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:32.610]                         if (muffled) 
[13:21:32.610]                           invokeRestart("muffleMessage")
[13:21:32.610]                       }
[13:21:32.610]                       else if (inherits(cond, "warning")) {
[13:21:32.610]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:32.610]                         if (muffled) 
[13:21:32.610]                           invokeRestart("muffleWarning")
[13:21:32.610]                       }
[13:21:32.610]                       else if (inherits(cond, "condition")) {
[13:21:32.610]                         if (!is.null(pattern)) {
[13:21:32.610]                           computeRestarts <- base::computeRestarts
[13:21:32.610]                           grepl <- base::grepl
[13:21:32.610]                           restarts <- computeRestarts(cond)
[13:21:32.610]                           for (restart in restarts) {
[13:21:32.610]                             name <- restart$name
[13:21:32.610]                             if (is.null(name)) 
[13:21:32.610]                               next
[13:21:32.610]                             if (!grepl(pattern, name)) 
[13:21:32.610]                               next
[13:21:32.610]                             invokeRestart(restart)
[13:21:32.610]                             muffled <- TRUE
[13:21:32.610]                             break
[13:21:32.610]                           }
[13:21:32.610]                         }
[13:21:32.610]                       }
[13:21:32.610]                       invisible(muffled)
[13:21:32.610]                     }
[13:21:32.610]                     muffleCondition(cond, pattern = "^muffle")
[13:21:32.610]                   }
[13:21:32.610]                 }
[13:21:32.610]                 else {
[13:21:32.610]                   if (TRUE) {
[13:21:32.610]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:32.610]                     {
[13:21:32.610]                       inherits <- base::inherits
[13:21:32.610]                       invokeRestart <- base::invokeRestart
[13:21:32.610]                       is.null <- base::is.null
[13:21:32.610]                       muffled <- FALSE
[13:21:32.610]                       if (inherits(cond, "message")) {
[13:21:32.610]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:32.610]                         if (muffled) 
[13:21:32.610]                           invokeRestart("muffleMessage")
[13:21:32.610]                       }
[13:21:32.610]                       else if (inherits(cond, "warning")) {
[13:21:32.610]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:32.610]                         if (muffled) 
[13:21:32.610]                           invokeRestart("muffleWarning")
[13:21:32.610]                       }
[13:21:32.610]                       else if (inherits(cond, "condition")) {
[13:21:32.610]                         if (!is.null(pattern)) {
[13:21:32.610]                           computeRestarts <- base::computeRestarts
[13:21:32.610]                           grepl <- base::grepl
[13:21:32.610]                           restarts <- computeRestarts(cond)
[13:21:32.610]                           for (restart in restarts) {
[13:21:32.610]                             name <- restart$name
[13:21:32.610]                             if (is.null(name)) 
[13:21:32.610]                               next
[13:21:32.610]                             if (!grepl(pattern, name)) 
[13:21:32.610]                               next
[13:21:32.610]                             invokeRestart(restart)
[13:21:32.610]                             muffled <- TRUE
[13:21:32.610]                             break
[13:21:32.610]                           }
[13:21:32.610]                         }
[13:21:32.610]                       }
[13:21:32.610]                       invisible(muffled)
[13:21:32.610]                     }
[13:21:32.610]                     muffleCondition(cond, pattern = "^muffle")
[13:21:32.610]                   }
[13:21:32.610]                 }
[13:21:32.610]             }
[13:21:32.610]         }))
[13:21:32.610]     }, error = function(ex) {
[13:21:32.610]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:32.610]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:32.610]                 ...future.rng), started = ...future.startTime, 
[13:21:32.610]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:32.610]             version = "1.8"), class = "FutureResult")
[13:21:32.610]     }, finally = {
[13:21:32.610]         if (!identical(...future.workdir, getwd())) 
[13:21:32.610]             setwd(...future.workdir)
[13:21:32.610]         {
[13:21:32.610]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:32.610]                 ...future.oldOptions$nwarnings <- NULL
[13:21:32.610]             }
[13:21:32.610]             base::options(...future.oldOptions)
[13:21:32.610]             if (.Platform$OS.type == "windows") {
[13:21:32.610]                 old_names <- names(...future.oldEnvVars)
[13:21:32.610]                 envs <- base::Sys.getenv()
[13:21:32.610]                 names <- names(envs)
[13:21:32.610]                 common <- intersect(names, old_names)
[13:21:32.610]                 added <- setdiff(names, old_names)
[13:21:32.610]                 removed <- setdiff(old_names, names)
[13:21:32.610]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:32.610]                   envs[common]]
[13:21:32.610]                 NAMES <- toupper(changed)
[13:21:32.610]                 args <- list()
[13:21:32.610]                 for (kk in seq_along(NAMES)) {
[13:21:32.610]                   name <- changed[[kk]]
[13:21:32.610]                   NAME <- NAMES[[kk]]
[13:21:32.610]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:32.610]                     next
[13:21:32.610]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:32.610]                 }
[13:21:32.610]                 NAMES <- toupper(added)
[13:21:32.610]                 for (kk in seq_along(NAMES)) {
[13:21:32.610]                   name <- added[[kk]]
[13:21:32.610]                   NAME <- NAMES[[kk]]
[13:21:32.610]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:32.610]                     next
[13:21:32.610]                   args[[name]] <- ""
[13:21:32.610]                 }
[13:21:32.610]                 NAMES <- toupper(removed)
[13:21:32.610]                 for (kk in seq_along(NAMES)) {
[13:21:32.610]                   name <- removed[[kk]]
[13:21:32.610]                   NAME <- NAMES[[kk]]
[13:21:32.610]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:32.610]                     next
[13:21:32.610]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:32.610]                 }
[13:21:32.610]                 if (length(args) > 0) 
[13:21:32.610]                   base::do.call(base::Sys.setenv, args = args)
[13:21:32.610]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:32.610]             }
[13:21:32.610]             else {
[13:21:32.610]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:32.610]             }
[13:21:32.610]             {
[13:21:32.610]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:32.610]                   0L) {
[13:21:32.610]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:32.610]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:32.610]                   base::options(opts)
[13:21:32.610]                 }
[13:21:32.610]                 {
[13:21:32.610]                   {
[13:21:32.610]                     NULL
[13:21:32.610]                     RNGkind("Mersenne-Twister")
[13:21:32.610]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:32.610]                       inherits = FALSE)
[13:21:32.610]                   }
[13:21:32.610]                   options(future.plan = NULL)
[13:21:32.610]                   if (is.na(NA_character_)) 
[13:21:32.610]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:32.610]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:32.610]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:32.610]                   {
[13:21:32.610]                     future <- SequentialFuture(..., envir = envir)
[13:21:32.610]                     if (!future$lazy) 
[13:21:32.610]                       future <- run(future)
[13:21:32.610]                     invisible(future)
[13:21:32.610]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:32.610]                 }
[13:21:32.610]             }
[13:21:32.610]         }
[13:21:32.610]     })
[13:21:32.610]     if (TRUE) {
[13:21:32.610]         base::sink(type = "output", split = FALSE)
[13:21:32.610]         if (TRUE) {
[13:21:32.610]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:32.610]         }
[13:21:32.610]         else {
[13:21:32.610]             ...future.result["stdout"] <- base::list(NULL)
[13:21:32.610]         }
[13:21:32.610]         base::close(...future.stdout)
[13:21:32.610]         ...future.stdout <- NULL
[13:21:32.610]     }
[13:21:32.610]     ...future.result$conditions <- ...future.conditions
[13:21:32.610]     ...future.result$finished <- base::Sys.time()
[13:21:32.610]     ...future.result
[13:21:32.610] }
[13:21:32.612] assign_globals() ...
[13:21:32.612] List of 11
[13:21:32.612]  $ ...future.FUN            :function (x, ...)  
[13:21:32.612]  $ x_FUN                    :function (x)  
[13:21:32.612]  $ times                    : int 1
[13:21:32.612]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:32.612]  $ stop_if_not              :function (...)  
[13:21:32.612]  $ dim                      : NULL
[13:21:32.612]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:21:32.612]  $ future.call.arguments    : list()
[13:21:32.612]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:32.612]  $ ...future.elements_ii    :List of 10
[13:21:32.612]   ..$ : int 1
[13:21:32.612]   ..$ : int 2
[13:21:32.612]   ..$ : int 3
[13:21:32.612]   ..$ : int 4
[13:21:32.612]   ..$ : int 5
[13:21:32.612]   ..$ : int 6
[13:21:32.612]   ..$ : int 7
[13:21:32.612]   ..$ : int 8
[13:21:32.612]   ..$ : int 9
[13:21:32.612]   ..$ : int 10
[13:21:32.612]  $ ...future.seeds_ii       : NULL
[13:21:32.612]  $ ...future.globals.maxSize: NULL
[13:21:32.612]  - attr(*, "where")=List of 11
[13:21:32.612]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:32.612]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:32.612]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:32.612]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:32.612]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:32.612]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:32.612]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:32.612]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:32.612]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:32.612]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:32.612]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:32.612]  - attr(*, "resolved")= logi FALSE
[13:21:32.612]  - attr(*, "total_size")= num 94336
[13:21:32.612]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:32.612]  - attr(*, "already-done")= logi TRUE
[13:21:32.624] - copied ‘...future.FUN’ to environment
[13:21:32.624] - copied ‘x_FUN’ to environment
[13:21:32.624] - copied ‘times’ to environment
[13:21:32.624] - copied ‘stopf’ to environment
[13:21:32.625] - copied ‘stop_if_not’ to environment
[13:21:32.625] - copied ‘dim’ to environment
[13:21:32.625] - copied ‘valid_types’ to environment
[13:21:32.625] - copied ‘future.call.arguments’ to environment
[13:21:32.625] - copied ‘...future.elements_ii’ to environment
[13:21:32.625] - copied ‘...future.seeds_ii’ to environment
[13:21:32.625] - copied ‘...future.globals.maxSize’ to environment
[13:21:32.625] assign_globals() ... done
[13:21:32.626] plan(): Setting new future strategy stack:
[13:21:32.626] List of future strategies:
[13:21:32.626] 1. sequential:
[13:21:32.626]    - args: function (..., envir = parent.frame())
[13:21:32.626]    - tweaked: FALSE
[13:21:32.626]    - call: NULL
[13:21:32.626] plan(): nbrOfWorkers() = 1
[13:21:32.627] plan(): Setting new future strategy stack:
[13:21:32.627] List of future strategies:
[13:21:32.627] 1. sequential:
[13:21:32.627]    - args: function (..., envir = parent.frame())
[13:21:32.627]    - tweaked: FALSE
[13:21:32.627]    - call: plan(strategy)
[13:21:32.628] plan(): nbrOfWorkers() = 1
[13:21:32.628] SequentialFuture started (and completed)
[13:21:32.628] - Launch lazy future ... done
[13:21:32.628] run() for ‘SequentialFuture’ ... done
[13:21:32.628] Created future:
[13:21:32.628] SequentialFuture:
[13:21:32.628] Label: ‘future_vapply-1’
[13:21:32.628] Expression:
[13:21:32.628] {
[13:21:32.628]     do.call(function(...) {
[13:21:32.628]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:32.628]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:32.628]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:32.628]             on.exit(options(oopts), add = TRUE)
[13:21:32.628]         }
[13:21:32.628]         {
[13:21:32.628]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:32.628]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:32.628]                 ...future.FUN(...future.X_jj, ...)
[13:21:32.628]             })
[13:21:32.628]         }
[13:21:32.628]     }, args = future.call.arguments)
[13:21:32.628] }
[13:21:32.628] Lazy evaluation: FALSE
[13:21:32.628] Asynchronous evaluation: FALSE
[13:21:32.628] Local evaluation: TRUE
[13:21:32.628] Environment: R_GlobalEnv
[13:21:32.628] Capture standard output: TRUE
[13:21:32.628] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:32.628] Globals: 11 objects totaling 92.67 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:32.628] Packages: 1 packages (‘future.apply’)
[13:21:32.628] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:32.628] Resolved: TRUE
[13:21:32.628] Value: 560 bytes of class ‘list’
[13:21:32.628] Early signaling: FALSE
[13:21:32.628] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:32.628] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:32.629] Chunk #1 of 1 ... DONE
[13:21:32.630] Launching 1 futures (chunks) ... DONE
[13:21:32.630] Resolving 1 futures (chunks) ...
[13:21:32.630] resolve() on list ...
[13:21:32.630]  recursive: 0
[13:21:32.630]  length: 1
[13:21:32.630] 
[13:21:32.630] resolved() for ‘SequentialFuture’ ...
[13:21:32.630] - state: ‘finished’
[13:21:32.630] - run: TRUE
[13:21:32.630] - result: ‘FutureResult’
[13:21:32.631] resolved() for ‘SequentialFuture’ ... done
[13:21:32.631] Future #1
[13:21:32.631] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:21:32.631] - nx: 1
[13:21:32.631] - relay: TRUE
[13:21:32.631] - stdout: TRUE
[13:21:32.631] - signal: TRUE
[13:21:32.631] - resignal: FALSE
[13:21:32.631] - force: TRUE
[13:21:32.631] - relayed: [n=1] FALSE
[13:21:32.631] - queued futures: [n=1] FALSE
[13:21:32.632]  - until=1
[13:21:32.632]  - relaying element #1
[13:21:32.632] - relayed: [n=1] TRUE
[13:21:32.632] - queued futures: [n=1] TRUE
[13:21:32.632] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:21:32.632]  length: 0 (resolved future 1)
[13:21:32.632] Relaying remaining futures
[13:21:32.632] signalConditionsASAP(NULL, pos=0) ...
[13:21:32.632] - nx: 1
[13:21:32.633] - relay: TRUE
[13:21:32.633] - stdout: TRUE
[13:21:32.633] - signal: TRUE
[13:21:32.633] - resignal: FALSE
[13:21:32.633] - force: TRUE
[13:21:32.633] - relayed: [n=1] TRUE
[13:21:32.633] - queued futures: [n=1] TRUE
 - flush all
[13:21:32.633] - relayed: [n=1] TRUE
[13:21:32.633] - queued futures: [n=1] TRUE
[13:21:32.633] signalConditionsASAP(NULL, pos=0) ... done
[13:21:32.633] resolve() on list ... DONE
[13:21:32.634]  - Number of value chunks collected: 1
[13:21:32.634] Resolving 1 futures (chunks) ... DONE
[13:21:32.634] Reducing values from 1 chunks ...
[13:21:32.634]  - Number of values collected after concatenation: 10
[13:21:32.634]  - Number of values expected: 10
[13:21:32.634] Reducing values from 1 chunks ... DONE
[13:21:32.634] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[13:21:32.635] future_lapply() ...
[13:21:32.637] Number of chunks: 1
[13:21:32.637] getGlobalsAndPackagesXApply() ...
[13:21:32.637]  - future.globals: TRUE
[13:21:32.637] getGlobalsAndPackages() ...
[13:21:32.637] Searching for globals...
[13:21:32.643] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[13:21:32.643] Searching for globals ... DONE
[13:21:32.643] Resolving globals: FALSE
[13:21:32.644] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[13:21:32.644] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:32.644] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:32.644] - packages: [1] ‘future.apply’
[13:21:32.645] getGlobalsAndPackages() ... DONE
[13:21:32.645]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:32.645]  - needed namespaces: [n=1] ‘future.apply’
[13:21:32.645] Finding globals ... DONE
[13:21:32.645]  - use_args: TRUE
[13:21:32.645]  - Getting '...' globals ...
[13:21:32.645] resolve() on list ...
[13:21:32.646]  recursive: 0
[13:21:32.646]  length: 1
[13:21:32.646]  elements: ‘...’
[13:21:32.646]  length: 0 (resolved future 1)
[13:21:32.646] resolve() on list ... DONE
[13:21:32.646]    - '...' content: [n=0] 
[13:21:32.646] List of 1
[13:21:32.646]  $ ...: list()
[13:21:32.646]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:32.646]  - attr(*, "where")=List of 1
[13:21:32.646]   ..$ ...:<environment: 0x563b6f07e760> 
[13:21:32.646]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:32.646]  - attr(*, "resolved")= logi TRUE
[13:21:32.646]  - attr(*, "total_size")= num NA
[13:21:32.649]  - Getting '...' globals ... DONE
[13:21:32.649] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:32.649] List of 8
[13:21:32.649]  $ ...future.FUN:function (x, ...)  
[13:21:32.649]  $ x_FUN        :function (x)  
[13:21:32.649]  $ times        : int 2
[13:21:32.649]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:32.649]  $ stop_if_not  :function (...)  
[13:21:32.649]  $ dim          : NULL
[13:21:32.649]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:21:32.649]  $ ...          : list()
[13:21:32.649]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:32.649]  - attr(*, "where")=List of 8
[13:21:32.649]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:32.649]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:32.649]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:32.649]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:32.649]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:32.649]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:32.649]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:32.649]   ..$ ...          :<environment: 0x563b6f07e760> 
[13:21:32.649]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:32.649]  - attr(*, "resolved")= logi FALSE
[13:21:32.649]  - attr(*, "total_size")= num 96456
[13:21:32.654] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:21:32.655] getGlobalsAndPackagesXApply() ... DONE
[13:21:32.655] Number of futures (= number of chunks): 1
[13:21:32.655] Launching 1 futures (chunks) ...
[13:21:32.655] Chunk #1 of 1 ...
[13:21:32.655]  - Finding globals in 'X' for chunk #1 ...
[13:21:32.655] getGlobalsAndPackages() ...
[13:21:32.655] Searching for globals...
[13:21:32.656] 
[13:21:32.656] Searching for globals ... DONE
[13:21:32.656] - globals: [0] <none>
[13:21:32.656] getGlobalsAndPackages() ... DONE
[13:21:32.656]    + additional globals found: [n=0] 
[13:21:32.656]    + additional namespaces needed: [n=0] 
[13:21:32.656]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:32.656]  - seeds: <none>
[13:21:32.656]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:32.656] getGlobalsAndPackages() ...
[13:21:32.657] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:32.657] Resolving globals: FALSE
[13:21:32.657] Tweak future expression to call with '...' arguments ...
[13:21:32.657] {
[13:21:32.657]     do.call(function(...) {
[13:21:32.657]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:32.657]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:32.657]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:32.657]             on.exit(options(oopts), add = TRUE)
[13:21:32.657]         }
[13:21:32.657]         {
[13:21:32.657]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:32.657]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:32.657]                 ...future.FUN(...future.X_jj, ...)
[13:21:32.657]             })
[13:21:32.657]         }
[13:21:32.657]     }, args = future.call.arguments)
[13:21:32.657] }
[13:21:32.657] Tweak future expression to call with '...' arguments ... DONE
[13:21:32.658] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:32.658] - packages: [1] ‘future.apply’
[13:21:32.658] getGlobalsAndPackages() ... DONE
[13:21:32.658] run() for ‘Future’ ...
[13:21:32.658] - state: ‘created’
[13:21:32.658] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:32.659] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:32.659] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:32.659]   - Field: ‘label’
[13:21:32.659]   - Field: ‘local’
[13:21:32.659]   - Field: ‘owner’
[13:21:32.659]   - Field: ‘envir’
[13:21:32.659]   - Field: ‘packages’
[13:21:32.659]   - Field: ‘gc’
[13:21:32.660]   - Field: ‘conditions’
[13:21:32.660]   - Field: ‘expr’
[13:21:32.660]   - Field: ‘uuid’
[13:21:32.660]   - Field: ‘seed’
[13:21:32.660]   - Field: ‘version’
[13:21:32.660]   - Field: ‘result’
[13:21:32.660]   - Field: ‘asynchronous’
[13:21:32.660]   - Field: ‘calls’
[13:21:32.660]   - Field: ‘globals’
[13:21:32.660]   - Field: ‘stdout’
[13:21:32.661]   - Field: ‘earlySignal’
[13:21:32.661]   - Field: ‘lazy’
[13:21:32.661]   - Field: ‘state’
[13:21:32.661] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:32.661] - Launch lazy future ...
[13:21:32.661] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:32.661] Packages needed by future strategies (n = 0): <none>
[13:21:32.662] {
[13:21:32.662]     {
[13:21:32.662]         {
[13:21:32.662]             ...future.startTime <- base::Sys.time()
[13:21:32.662]             {
[13:21:32.662]                 {
[13:21:32.662]                   {
[13:21:32.662]                     {
[13:21:32.662]                       base::local({
[13:21:32.662]                         has_future <- base::requireNamespace("future", 
[13:21:32.662]                           quietly = TRUE)
[13:21:32.662]                         if (has_future) {
[13:21:32.662]                           ns <- base::getNamespace("future")
[13:21:32.662]                           version <- ns[[".package"]][["version"]]
[13:21:32.662]                           if (is.null(version)) 
[13:21:32.662]                             version <- utils::packageVersion("future")
[13:21:32.662]                         }
[13:21:32.662]                         else {
[13:21:32.662]                           version <- NULL
[13:21:32.662]                         }
[13:21:32.662]                         if (!has_future || version < "1.8.0") {
[13:21:32.662]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:32.662]                             "", base::R.version$version.string), 
[13:21:32.662]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:32.662]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:32.662]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:32.662]                               "release", "version")], collapse = " "), 
[13:21:32.662]                             hostname = base::Sys.info()[["nodename"]])
[13:21:32.662]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:32.662]                             info)
[13:21:32.662]                           info <- base::paste(info, collapse = "; ")
[13:21:32.662]                           if (!has_future) {
[13:21:32.662]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:32.662]                               info)
[13:21:32.662]                           }
[13:21:32.662]                           else {
[13:21:32.662]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:32.662]                               info, version)
[13:21:32.662]                           }
[13:21:32.662]                           base::stop(msg)
[13:21:32.662]                         }
[13:21:32.662]                       })
[13:21:32.662]                     }
[13:21:32.662]                     base::local({
[13:21:32.662]                       for (pkg in "future.apply") {
[13:21:32.662]                         base::loadNamespace(pkg)
[13:21:32.662]                         base::library(pkg, character.only = TRUE)
[13:21:32.662]                       }
[13:21:32.662]                     })
[13:21:32.662]                   }
[13:21:32.662]                   options(future.plan = NULL)
[13:21:32.662]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:32.662]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:32.662]                 }
[13:21:32.662]                 ...future.workdir <- getwd()
[13:21:32.662]             }
[13:21:32.662]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:32.662]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:32.662]         }
[13:21:32.662]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:32.662]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:32.662]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:32.662]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:32.662]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:32.662]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:32.662]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:32.662]             base::names(...future.oldOptions))
[13:21:32.662]     }
[13:21:32.662]     if (FALSE) {
[13:21:32.662]     }
[13:21:32.662]     else {
[13:21:32.662]         if (TRUE) {
[13:21:32.662]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:32.662]                 open = "w")
[13:21:32.662]         }
[13:21:32.662]         else {
[13:21:32.662]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:32.662]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:32.662]         }
[13:21:32.662]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:32.662]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:32.662]             base::sink(type = "output", split = FALSE)
[13:21:32.662]             base::close(...future.stdout)
[13:21:32.662]         }, add = TRUE)
[13:21:32.662]     }
[13:21:32.662]     ...future.frame <- base::sys.nframe()
[13:21:32.662]     ...future.conditions <- base::list()
[13:21:32.662]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:32.662]     if (FALSE) {
[13:21:32.662]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:32.662]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:32.662]     }
[13:21:32.662]     ...future.result <- base::tryCatch({
[13:21:32.662]         base::withCallingHandlers({
[13:21:32.662]             ...future.value <- base::withVisible(base::local({
[13:21:32.662]                 do.call(function(...) {
[13:21:32.662]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:32.662]                   if (!identical(...future.globals.maxSize.org, 
[13:21:32.662]                     ...future.globals.maxSize)) {
[13:21:32.662]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:32.662]                     on.exit(options(oopts), add = TRUE)
[13:21:32.662]                   }
[13:21:32.662]                   {
[13:21:32.662]                     lapply(seq_along(...future.elements_ii), 
[13:21:32.662]                       FUN = function(jj) {
[13:21:32.662]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:32.662]                         ...future.FUN(...future.X_jj, ...)
[13:21:32.662]                       })
[13:21:32.662]                   }
[13:21:32.662]                 }, args = future.call.arguments)
[13:21:32.662]             }))
[13:21:32.662]             future::FutureResult(value = ...future.value$value, 
[13:21:32.662]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:32.662]                   ...future.rng), globalenv = if (FALSE) 
[13:21:32.662]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:32.662]                     ...future.globalenv.names))
[13:21:32.662]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:32.662]         }, condition = base::local({
[13:21:32.662]             c <- base::c
[13:21:32.662]             inherits <- base::inherits
[13:21:32.662]             invokeRestart <- base::invokeRestart
[13:21:32.662]             length <- base::length
[13:21:32.662]             list <- base::list
[13:21:32.662]             seq.int <- base::seq.int
[13:21:32.662]             signalCondition <- base::signalCondition
[13:21:32.662]             sys.calls <- base::sys.calls
[13:21:32.662]             `[[` <- base::`[[`
[13:21:32.662]             `+` <- base::`+`
[13:21:32.662]             `<<-` <- base::`<<-`
[13:21:32.662]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:32.662]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:32.662]                   3L)]
[13:21:32.662]             }
[13:21:32.662]             function(cond) {
[13:21:32.662]                 is_error <- inherits(cond, "error")
[13:21:32.662]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:32.662]                   NULL)
[13:21:32.662]                 if (is_error) {
[13:21:32.662]                   sessionInformation <- function() {
[13:21:32.662]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:32.662]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:32.662]                       search = base::search(), system = base::Sys.info())
[13:21:32.662]                   }
[13:21:32.662]                   ...future.conditions[[length(...future.conditions) + 
[13:21:32.662]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:32.662]                     cond$call), session = sessionInformation(), 
[13:21:32.662]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:32.662]                   signalCondition(cond)
[13:21:32.662]                 }
[13:21:32.662]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:32.662]                 "immediateCondition"))) {
[13:21:32.662]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:32.662]                   ...future.conditions[[length(...future.conditions) + 
[13:21:32.662]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:32.662]                   if (TRUE && !signal) {
[13:21:32.662]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:32.662]                     {
[13:21:32.662]                       inherits <- base::inherits
[13:21:32.662]                       invokeRestart <- base::invokeRestart
[13:21:32.662]                       is.null <- base::is.null
[13:21:32.662]                       muffled <- FALSE
[13:21:32.662]                       if (inherits(cond, "message")) {
[13:21:32.662]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:32.662]                         if (muffled) 
[13:21:32.662]                           invokeRestart("muffleMessage")
[13:21:32.662]                       }
[13:21:32.662]                       else if (inherits(cond, "warning")) {
[13:21:32.662]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:32.662]                         if (muffled) 
[13:21:32.662]                           invokeRestart("muffleWarning")
[13:21:32.662]                       }
[13:21:32.662]                       else if (inherits(cond, "condition")) {
[13:21:32.662]                         if (!is.null(pattern)) {
[13:21:32.662]                           computeRestarts <- base::computeRestarts
[13:21:32.662]                           grepl <- base::grepl
[13:21:32.662]                           restarts <- computeRestarts(cond)
[13:21:32.662]                           for (restart in restarts) {
[13:21:32.662]                             name <- restart$name
[13:21:32.662]                             if (is.null(name)) 
[13:21:32.662]                               next
[13:21:32.662]                             if (!grepl(pattern, name)) 
[13:21:32.662]                               next
[13:21:32.662]                             invokeRestart(restart)
[13:21:32.662]                             muffled <- TRUE
[13:21:32.662]                             break
[13:21:32.662]                           }
[13:21:32.662]                         }
[13:21:32.662]                       }
[13:21:32.662]                       invisible(muffled)
[13:21:32.662]                     }
[13:21:32.662]                     muffleCondition(cond, pattern = "^muffle")
[13:21:32.662]                   }
[13:21:32.662]                 }
[13:21:32.662]                 else {
[13:21:32.662]                   if (TRUE) {
[13:21:32.662]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:32.662]                     {
[13:21:32.662]                       inherits <- base::inherits
[13:21:32.662]                       invokeRestart <- base::invokeRestart
[13:21:32.662]                       is.null <- base::is.null
[13:21:32.662]                       muffled <- FALSE
[13:21:32.662]                       if (inherits(cond, "message")) {
[13:21:32.662]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:32.662]                         if (muffled) 
[13:21:32.662]                           invokeRestart("muffleMessage")
[13:21:32.662]                       }
[13:21:32.662]                       else if (inherits(cond, "warning")) {
[13:21:32.662]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:32.662]                         if (muffled) 
[13:21:32.662]                           invokeRestart("muffleWarning")
[13:21:32.662]                       }
[13:21:32.662]                       else if (inherits(cond, "condition")) {
[13:21:32.662]                         if (!is.null(pattern)) {
[13:21:32.662]                           computeRestarts <- base::computeRestarts
[13:21:32.662]                           grepl <- base::grepl
[13:21:32.662]                           restarts <- computeRestarts(cond)
[13:21:32.662]                           for (restart in restarts) {
[13:21:32.662]                             name <- restart$name
[13:21:32.662]                             if (is.null(name)) 
[13:21:32.662]                               next
[13:21:32.662]                             if (!grepl(pattern, name)) 
[13:21:32.662]                               next
[13:21:32.662]                             invokeRestart(restart)
[13:21:32.662]                             muffled <- TRUE
[13:21:32.662]                             break
[13:21:32.662]                           }
[13:21:32.662]                         }
[13:21:32.662]                       }
[13:21:32.662]                       invisible(muffled)
[13:21:32.662]                     }
[13:21:32.662]                     muffleCondition(cond, pattern = "^muffle")
[13:21:32.662]                   }
[13:21:32.662]                 }
[13:21:32.662]             }
[13:21:32.662]         }))
[13:21:32.662]     }, error = function(ex) {
[13:21:32.662]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:32.662]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:32.662]                 ...future.rng), started = ...future.startTime, 
[13:21:32.662]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:32.662]             version = "1.8"), class = "FutureResult")
[13:21:32.662]     }, finally = {
[13:21:32.662]         if (!identical(...future.workdir, getwd())) 
[13:21:32.662]             setwd(...future.workdir)
[13:21:32.662]         {
[13:21:32.662]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:32.662]                 ...future.oldOptions$nwarnings <- NULL
[13:21:32.662]             }
[13:21:32.662]             base::options(...future.oldOptions)
[13:21:32.662]             if (.Platform$OS.type == "windows") {
[13:21:32.662]                 old_names <- names(...future.oldEnvVars)
[13:21:32.662]                 envs <- base::Sys.getenv()
[13:21:32.662]                 names <- names(envs)
[13:21:32.662]                 common <- intersect(names, old_names)
[13:21:32.662]                 added <- setdiff(names, old_names)
[13:21:32.662]                 removed <- setdiff(old_names, names)
[13:21:32.662]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:32.662]                   envs[common]]
[13:21:32.662]                 NAMES <- toupper(changed)
[13:21:32.662]                 args <- list()
[13:21:32.662]                 for (kk in seq_along(NAMES)) {
[13:21:32.662]                   name <- changed[[kk]]
[13:21:32.662]                   NAME <- NAMES[[kk]]
[13:21:32.662]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:32.662]                     next
[13:21:32.662]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:32.662]                 }
[13:21:32.662]                 NAMES <- toupper(added)
[13:21:32.662]                 for (kk in seq_along(NAMES)) {
[13:21:32.662]                   name <- added[[kk]]
[13:21:32.662]                   NAME <- NAMES[[kk]]
[13:21:32.662]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:32.662]                     next
[13:21:32.662]                   args[[name]] <- ""
[13:21:32.662]                 }
[13:21:32.662]                 NAMES <- toupper(removed)
[13:21:32.662]                 for (kk in seq_along(NAMES)) {
[13:21:32.662]                   name <- removed[[kk]]
[13:21:32.662]                   NAME <- NAMES[[kk]]
[13:21:32.662]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:32.662]                     next
[13:21:32.662]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:32.662]                 }
[13:21:32.662]                 if (length(args) > 0) 
[13:21:32.662]                   base::do.call(base::Sys.setenv, args = args)
[13:21:32.662]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:32.662]             }
[13:21:32.662]             else {
[13:21:32.662]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:32.662]             }
[13:21:32.662]             {
[13:21:32.662]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:32.662]                   0L) {
[13:21:32.662]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:32.662]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:32.662]                   base::options(opts)
[13:21:32.662]                 }
[13:21:32.662]                 {
[13:21:32.662]                   {
[13:21:32.662]                     NULL
[13:21:32.662]                     RNGkind("Mersenne-Twister")
[13:21:32.662]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:32.662]                       inherits = FALSE)
[13:21:32.662]                   }
[13:21:32.662]                   options(future.plan = NULL)
[13:21:32.662]                   if (is.na(NA_character_)) 
[13:21:32.662]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:32.662]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:32.662]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:32.662]                   {
[13:21:32.662]                     future <- SequentialFuture(..., envir = envir)
[13:21:32.662]                     if (!future$lazy) 
[13:21:32.662]                       future <- run(future)
[13:21:32.662]                     invisible(future)
[13:21:32.662]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:32.662]                 }
[13:21:32.662]             }
[13:21:32.662]         }
[13:21:32.662]     })
[13:21:32.662]     if (TRUE) {
[13:21:32.662]         base::sink(type = "output", split = FALSE)
[13:21:32.662]         if (TRUE) {
[13:21:32.662]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:32.662]         }
[13:21:32.662]         else {
[13:21:32.662]             ...future.result["stdout"] <- base::list(NULL)
[13:21:32.662]         }
[13:21:32.662]         base::close(...future.stdout)
[13:21:32.662]         ...future.stdout <- NULL
[13:21:32.662]     }
[13:21:32.662]     ...future.result$conditions <- ...future.conditions
[13:21:32.662]     ...future.result$finished <- base::Sys.time()
[13:21:32.662]     ...future.result
[13:21:32.662] }
[13:21:32.664] assign_globals() ...
[13:21:32.664] List of 11
[13:21:32.664]  $ ...future.FUN            :function (x, ...)  
[13:21:32.664]  $ x_FUN                    :function (x)  
[13:21:32.664]  $ times                    : int 2
[13:21:32.664]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:32.664]  $ stop_if_not              :function (...)  
[13:21:32.664]  $ dim                      : NULL
[13:21:32.664]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:21:32.664]  $ future.call.arguments    : list()
[13:21:32.664]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:32.664]  $ ...future.elements_ii    :List of 10
[13:21:32.664]   ..$ : int 1
[13:21:32.664]   ..$ : int 2
[13:21:32.664]   ..$ : int 3
[13:21:32.664]   ..$ : int 4
[13:21:32.664]   ..$ : int 5
[13:21:32.664]   ..$ : int 6
[13:21:32.664]   ..$ : int 7
[13:21:32.664]   ..$ : int 8
[13:21:32.664]   ..$ : int 9
[13:21:32.664]   ..$ : int 10
[13:21:32.664]  $ ...future.seeds_ii       : NULL
[13:21:32.664]  $ ...future.globals.maxSize: NULL
[13:21:32.664]  - attr(*, "where")=List of 11
[13:21:32.664]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:32.664]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:32.664]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:32.664]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:32.664]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:32.664]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:32.664]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:32.664]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:32.664]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:32.664]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:32.664]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:32.664]  - attr(*, "resolved")= logi FALSE
[13:21:32.664]  - attr(*, "total_size")= num 96456
[13:21:32.664]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:32.664]  - attr(*, "already-done")= logi TRUE
[13:21:32.676] - copied ‘...future.FUN’ to environment
[13:21:32.676] - reassign environment for ‘x_FUN’
[13:21:32.676] - copied ‘x_FUN’ to environment
[13:21:32.676] - copied ‘times’ to environment
[13:21:32.676] - copied ‘stopf’ to environment
[13:21:32.676] - copied ‘stop_if_not’ to environment
[13:21:32.676] - copied ‘dim’ to environment
[13:21:32.676] - copied ‘valid_types’ to environment
[13:21:32.676] - copied ‘future.call.arguments’ to environment
[13:21:32.677] - copied ‘...future.elements_ii’ to environment
[13:21:32.677] - copied ‘...future.seeds_ii’ to environment
[13:21:32.677] - copied ‘...future.globals.maxSize’ to environment
[13:21:32.677] assign_globals() ... done
[13:21:32.677] plan(): Setting new future strategy stack:
[13:21:32.677] List of future strategies:
[13:21:32.677] 1. sequential:
[13:21:32.677]    - args: function (..., envir = parent.frame())
[13:21:32.677]    - tweaked: FALSE
[13:21:32.677]    - call: NULL
[13:21:32.678] plan(): nbrOfWorkers() = 1
[13:21:32.679] plan(): Setting new future strategy stack:
[13:21:32.679] List of future strategies:
[13:21:32.679] 1. sequential:
[13:21:32.679]    - args: function (..., envir = parent.frame())
[13:21:32.679]    - tweaked: FALSE
[13:21:32.679]    - call: plan(strategy)
[13:21:32.679] plan(): nbrOfWorkers() = 1
[13:21:32.679] SequentialFuture started (and completed)
[13:21:32.679] - Launch lazy future ... done
[13:21:32.679] run() for ‘SequentialFuture’ ... done
[13:21:32.680] Created future:
[13:21:32.680] SequentialFuture:
[13:21:32.680] Label: ‘future_vapply-1’
[13:21:32.680] Expression:
[13:21:32.680] {
[13:21:32.680]     do.call(function(...) {
[13:21:32.680]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:32.680]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:32.680]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:32.680]             on.exit(options(oopts), add = TRUE)
[13:21:32.680]         }
[13:21:32.680]         {
[13:21:32.680]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:32.680]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:32.680]                 ...future.FUN(...future.X_jj, ...)
[13:21:32.680]             })
[13:21:32.680]         }
[13:21:32.680]     }, args = future.call.arguments)
[13:21:32.680] }
[13:21:32.680] Lazy evaluation: FALSE
[13:21:32.680] Asynchronous evaluation: FALSE
[13:21:32.680] Local evaluation: TRUE
[13:21:32.680] Environment: R_GlobalEnv
[13:21:32.680] Capture standard output: TRUE
[13:21:32.680] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:32.680] Globals: 11 objects totaling 94.74 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:32.680] Packages: 1 packages (‘future.apply’)
[13:21:32.680] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:32.680] Resolved: TRUE
[13:21:32.680] Value: 640 bytes of class ‘list’
[13:21:32.680] Early signaling: FALSE
[13:21:32.680] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:32.680] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:32.681] Chunk #1 of 1 ... DONE
[13:21:32.681] Launching 1 futures (chunks) ... DONE
[13:21:32.681] Resolving 1 futures (chunks) ...
[13:21:32.681] resolve() on list ...
[13:21:32.681]  recursive: 0
[13:21:32.681]  length: 1
[13:21:32.682] 
[13:21:32.682] resolved() for ‘SequentialFuture’ ...
[13:21:32.682] - state: ‘finished’
[13:21:32.682] - run: TRUE
[13:21:32.682] - result: ‘FutureResult’
[13:21:32.682] resolved() for ‘SequentialFuture’ ... done
[13:21:32.682] Future #1
[13:21:32.682] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:21:32.682] - nx: 1
[13:21:32.683] - relay: TRUE
[13:21:32.683] - stdout: TRUE
[13:21:32.683] - signal: TRUE
[13:21:32.683] - resignal: FALSE
[13:21:32.683] - force: TRUE
[13:21:32.683] - relayed: [n=1] FALSE
[13:21:32.683] - queued futures: [n=1] FALSE
[13:21:32.683]  - until=1
[13:21:32.683]  - relaying element #1
[13:21:32.683] - relayed: [n=1] TRUE
[13:21:32.683] - queued futures: [n=1] TRUE
[13:21:32.684] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:21:32.684]  length: 0 (resolved future 1)
[13:21:32.684] Relaying remaining futures
[13:21:32.684] signalConditionsASAP(NULL, pos=0) ...
[13:21:32.684] - nx: 1
[13:21:32.684] - relay: TRUE
[13:21:32.684] - stdout: TRUE
[13:21:32.684] - signal: TRUE
[13:21:32.684] - resignal: FALSE
[13:21:32.684] - force: TRUE
[13:21:32.684] - relayed: [n=1] TRUE
[13:21:32.685] - queued futures: [n=1] TRUE
 - flush all
[13:21:32.685] - relayed: [n=1] TRUE
[13:21:32.685] - queued futures: [n=1] TRUE
[13:21:32.685] signalConditionsASAP(NULL, pos=0) ... done
[13:21:32.685] resolve() on list ... DONE
[13:21:32.685]  - Number of value chunks collected: 1
[13:21:32.685] Resolving 1 futures (chunks) ... DONE
[13:21:32.685] Reducing values from 1 chunks ...
[13:21:32.685]  - Number of values collected after concatenation: 10
[13:21:32.685]  - Number of values expected: 10
[13:21:32.686] Reducing values from 1 chunks ... DONE
[13:21:32.686] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[13:21:32.687] future_lapply() ...
[13:21:32.690] Number of chunks: 1
[13:21:32.690] getGlobalsAndPackagesXApply() ...
[13:21:32.691]  - future.globals: TRUE
[13:21:32.691] getGlobalsAndPackages() ...
[13:21:32.691] Searching for globals...
[13:21:32.694] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[13:21:32.694] Searching for globals ... DONE
[13:21:32.694] Resolving globals: FALSE
[13:21:32.695] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[13:21:32.696] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:32.696] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:32.696] - packages: [1] ‘future.apply’
[13:21:32.696] getGlobalsAndPackages() ... DONE
[13:21:32.696]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:32.696]  - needed namespaces: [n=1] ‘future.apply’
[13:21:32.696] Finding globals ... DONE
[13:21:32.697]  - use_args: TRUE
[13:21:32.697]  - Getting '...' globals ...
[13:21:32.697] resolve() on list ...
[13:21:32.697]  recursive: 0
[13:21:32.697]  length: 1
[13:21:32.697]  elements: ‘...’
[13:21:32.697]  length: 0 (resolved future 1)
[13:21:32.697] resolve() on list ... DONE
[13:21:32.697]    - '...' content: [n=0] 
[13:21:32.698] List of 1
[13:21:32.698]  $ ...: list()
[13:21:32.698]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:32.698]  - attr(*, "where")=List of 1
[13:21:32.698]   ..$ ...:<environment: 0x563b6f4c6a50> 
[13:21:32.698]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:32.698]  - attr(*, "resolved")= logi TRUE
[13:21:32.698]  - attr(*, "total_size")= num NA
[13:21:32.700]  - Getting '...' globals ... DONE
[13:21:32.700] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:32.701] List of 8
[13:21:32.701]  $ ...future.FUN:function (x, ...)  
[13:21:32.701]  $ x_FUN        :function (x)  
[13:21:32.701]  $ times        : int 4
[13:21:32.701]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:32.701]  $ stop_if_not  :function (...)  
[13:21:32.701]  $ dim          : int [1:2] 2 2
[13:21:32.701]  $ valid_types  : chr [1:2] "logical" "integer"
[13:21:32.701]  $ ...          : list()
[13:21:32.701]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:32.701]  - attr(*, "where")=List of 8
[13:21:32.701]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:32.701]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:32.701]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:32.701]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:32.701]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:32.701]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:32.701]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:32.701]   ..$ ...          :<environment: 0x563b6f4c6a50> 
[13:21:32.701]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:32.701]  - attr(*, "resolved")= logi FALSE
[13:21:32.701]  - attr(*, "total_size")= num 97232
[13:21:32.706] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:21:32.706] getGlobalsAndPackagesXApply() ... DONE
[13:21:32.706] Number of futures (= number of chunks): 1
[13:21:32.706] Launching 1 futures (chunks) ...
[13:21:32.706] Chunk #1 of 1 ...
[13:21:32.707]  - Finding globals in 'X' for chunk #1 ...
[13:21:32.707] getGlobalsAndPackages() ...
[13:21:32.707] Searching for globals...
[13:21:32.707] 
[13:21:32.707] Searching for globals ... DONE
[13:21:32.707] - globals: [0] <none>
[13:21:32.707] getGlobalsAndPackages() ... DONE
[13:21:32.707]    + additional globals found: [n=0] 
[13:21:32.708]    + additional namespaces needed: [n=0] 
[13:21:32.708]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:32.708]  - seeds: <none>
[13:21:32.708]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:32.708] getGlobalsAndPackages() ...
[13:21:32.708] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:32.710] Resolving globals: FALSE
[13:21:32.710] Tweak future expression to call with '...' arguments ...
[13:21:32.710] {
[13:21:32.710]     do.call(function(...) {
[13:21:32.710]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:32.710]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:32.710]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:32.710]             on.exit(options(oopts), add = TRUE)
[13:21:32.710]         }
[13:21:32.710]         {
[13:21:32.710]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:32.710]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:32.710]                 ...future.FUN(...future.X_jj, ...)
[13:21:32.710]             })
[13:21:32.710]         }
[13:21:32.710]     }, args = future.call.arguments)
[13:21:32.710] }
[13:21:32.710] Tweak future expression to call with '...' arguments ... DONE
[13:21:32.711] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:32.711] - packages: [1] ‘future.apply’
[13:21:32.711] getGlobalsAndPackages() ... DONE
[13:21:32.712] run() for ‘Future’ ...
[13:21:32.712] - state: ‘created’
[13:21:32.712] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:32.712] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:32.712] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:32.712]   - Field: ‘label’
[13:21:32.712]   - Field: ‘local’
[13:21:32.712]   - Field: ‘owner’
[13:21:32.713]   - Field: ‘envir’
[13:21:32.713]   - Field: ‘packages’
[13:21:32.713]   - Field: ‘gc’
[13:21:32.713]   - Field: ‘conditions’
[13:21:32.713]   - Field: ‘expr’
[13:21:32.713]   - Field: ‘uuid’
[13:21:32.713]   - Field: ‘seed’
[13:21:32.713]   - Field: ‘version’
[13:21:32.713]   - Field: ‘result’
[13:21:32.713]   - Field: ‘asynchronous’
[13:21:32.714]   - Field: ‘calls’
[13:21:32.714]   - Field: ‘globals’
[13:21:32.714]   - Field: ‘stdout’
[13:21:32.714]   - Field: ‘earlySignal’
[13:21:32.714]   - Field: ‘lazy’
[13:21:32.714]   - Field: ‘state’
[13:21:32.714] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:32.714] - Launch lazy future ...
[13:21:32.714] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:32.714] Packages needed by future strategies (n = 0): <none>
[13:21:32.715] {
[13:21:32.715]     {
[13:21:32.715]         {
[13:21:32.715]             ...future.startTime <- base::Sys.time()
[13:21:32.715]             {
[13:21:32.715]                 {
[13:21:32.715]                   {
[13:21:32.715]                     {
[13:21:32.715]                       base::local({
[13:21:32.715]                         has_future <- base::requireNamespace("future", 
[13:21:32.715]                           quietly = TRUE)
[13:21:32.715]                         if (has_future) {
[13:21:32.715]                           ns <- base::getNamespace("future")
[13:21:32.715]                           version <- ns[[".package"]][["version"]]
[13:21:32.715]                           if (is.null(version)) 
[13:21:32.715]                             version <- utils::packageVersion("future")
[13:21:32.715]                         }
[13:21:32.715]                         else {
[13:21:32.715]                           version <- NULL
[13:21:32.715]                         }
[13:21:32.715]                         if (!has_future || version < "1.8.0") {
[13:21:32.715]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:32.715]                             "", base::R.version$version.string), 
[13:21:32.715]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:32.715]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:32.715]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:32.715]                               "release", "version")], collapse = " "), 
[13:21:32.715]                             hostname = base::Sys.info()[["nodename"]])
[13:21:32.715]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:32.715]                             info)
[13:21:32.715]                           info <- base::paste(info, collapse = "; ")
[13:21:32.715]                           if (!has_future) {
[13:21:32.715]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:32.715]                               info)
[13:21:32.715]                           }
[13:21:32.715]                           else {
[13:21:32.715]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:32.715]                               info, version)
[13:21:32.715]                           }
[13:21:32.715]                           base::stop(msg)
[13:21:32.715]                         }
[13:21:32.715]                       })
[13:21:32.715]                     }
[13:21:32.715]                     base::local({
[13:21:32.715]                       for (pkg in "future.apply") {
[13:21:32.715]                         base::loadNamespace(pkg)
[13:21:32.715]                         base::library(pkg, character.only = TRUE)
[13:21:32.715]                       }
[13:21:32.715]                     })
[13:21:32.715]                   }
[13:21:32.715]                   options(future.plan = NULL)
[13:21:32.715]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:32.715]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:32.715]                 }
[13:21:32.715]                 ...future.workdir <- getwd()
[13:21:32.715]             }
[13:21:32.715]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:32.715]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:32.715]         }
[13:21:32.715]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:32.715]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:32.715]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:32.715]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:32.715]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:32.715]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:32.715]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:32.715]             base::names(...future.oldOptions))
[13:21:32.715]     }
[13:21:32.715]     if (FALSE) {
[13:21:32.715]     }
[13:21:32.715]     else {
[13:21:32.715]         if (TRUE) {
[13:21:32.715]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:32.715]                 open = "w")
[13:21:32.715]         }
[13:21:32.715]         else {
[13:21:32.715]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:32.715]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:32.715]         }
[13:21:32.715]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:32.715]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:32.715]             base::sink(type = "output", split = FALSE)
[13:21:32.715]             base::close(...future.stdout)
[13:21:32.715]         }, add = TRUE)
[13:21:32.715]     }
[13:21:32.715]     ...future.frame <- base::sys.nframe()
[13:21:32.715]     ...future.conditions <- base::list()
[13:21:32.715]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:32.715]     if (FALSE) {
[13:21:32.715]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:32.715]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:32.715]     }
[13:21:32.715]     ...future.result <- base::tryCatch({
[13:21:32.715]         base::withCallingHandlers({
[13:21:32.715]             ...future.value <- base::withVisible(base::local({
[13:21:32.715]                 do.call(function(...) {
[13:21:32.715]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:32.715]                   if (!identical(...future.globals.maxSize.org, 
[13:21:32.715]                     ...future.globals.maxSize)) {
[13:21:32.715]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:32.715]                     on.exit(options(oopts), add = TRUE)
[13:21:32.715]                   }
[13:21:32.715]                   {
[13:21:32.715]                     lapply(seq_along(...future.elements_ii), 
[13:21:32.715]                       FUN = function(jj) {
[13:21:32.715]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:32.715]                         ...future.FUN(...future.X_jj, ...)
[13:21:32.715]                       })
[13:21:32.715]                   }
[13:21:32.715]                 }, args = future.call.arguments)
[13:21:32.715]             }))
[13:21:32.715]             future::FutureResult(value = ...future.value$value, 
[13:21:32.715]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:32.715]                   ...future.rng), globalenv = if (FALSE) 
[13:21:32.715]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:32.715]                     ...future.globalenv.names))
[13:21:32.715]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:32.715]         }, condition = base::local({
[13:21:32.715]             c <- base::c
[13:21:32.715]             inherits <- base::inherits
[13:21:32.715]             invokeRestart <- base::invokeRestart
[13:21:32.715]             length <- base::length
[13:21:32.715]             list <- base::list
[13:21:32.715]             seq.int <- base::seq.int
[13:21:32.715]             signalCondition <- base::signalCondition
[13:21:32.715]             sys.calls <- base::sys.calls
[13:21:32.715]             `[[` <- base::`[[`
[13:21:32.715]             `+` <- base::`+`
[13:21:32.715]             `<<-` <- base::`<<-`
[13:21:32.715]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:32.715]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:32.715]                   3L)]
[13:21:32.715]             }
[13:21:32.715]             function(cond) {
[13:21:32.715]                 is_error <- inherits(cond, "error")
[13:21:32.715]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:32.715]                   NULL)
[13:21:32.715]                 if (is_error) {
[13:21:32.715]                   sessionInformation <- function() {
[13:21:32.715]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:32.715]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:32.715]                       search = base::search(), system = base::Sys.info())
[13:21:32.715]                   }
[13:21:32.715]                   ...future.conditions[[length(...future.conditions) + 
[13:21:32.715]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:32.715]                     cond$call), session = sessionInformation(), 
[13:21:32.715]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:32.715]                   signalCondition(cond)
[13:21:32.715]                 }
[13:21:32.715]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:32.715]                 "immediateCondition"))) {
[13:21:32.715]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:32.715]                   ...future.conditions[[length(...future.conditions) + 
[13:21:32.715]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:32.715]                   if (TRUE && !signal) {
[13:21:32.715]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:32.715]                     {
[13:21:32.715]                       inherits <- base::inherits
[13:21:32.715]                       invokeRestart <- base::invokeRestart
[13:21:32.715]                       is.null <- base::is.null
[13:21:32.715]                       muffled <- FALSE
[13:21:32.715]                       if (inherits(cond, "message")) {
[13:21:32.715]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:32.715]                         if (muffled) 
[13:21:32.715]                           invokeRestart("muffleMessage")
[13:21:32.715]                       }
[13:21:32.715]                       else if (inherits(cond, "warning")) {
[13:21:32.715]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:32.715]                         if (muffled) 
[13:21:32.715]                           invokeRestart("muffleWarning")
[13:21:32.715]                       }
[13:21:32.715]                       else if (inherits(cond, "condition")) {
[13:21:32.715]                         if (!is.null(pattern)) {
[13:21:32.715]                           computeRestarts <- base::computeRestarts
[13:21:32.715]                           grepl <- base::grepl
[13:21:32.715]                           restarts <- computeRestarts(cond)
[13:21:32.715]                           for (restart in restarts) {
[13:21:32.715]                             name <- restart$name
[13:21:32.715]                             if (is.null(name)) 
[13:21:32.715]                               next
[13:21:32.715]                             if (!grepl(pattern, name)) 
[13:21:32.715]                               next
[13:21:32.715]                             invokeRestart(restart)
[13:21:32.715]                             muffled <- TRUE
[13:21:32.715]                             break
[13:21:32.715]                           }
[13:21:32.715]                         }
[13:21:32.715]                       }
[13:21:32.715]                       invisible(muffled)
[13:21:32.715]                     }
[13:21:32.715]                     muffleCondition(cond, pattern = "^muffle")
[13:21:32.715]                   }
[13:21:32.715]                 }
[13:21:32.715]                 else {
[13:21:32.715]                   if (TRUE) {
[13:21:32.715]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:32.715]                     {
[13:21:32.715]                       inherits <- base::inherits
[13:21:32.715]                       invokeRestart <- base::invokeRestart
[13:21:32.715]                       is.null <- base::is.null
[13:21:32.715]                       muffled <- FALSE
[13:21:32.715]                       if (inherits(cond, "message")) {
[13:21:32.715]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:32.715]                         if (muffled) 
[13:21:32.715]                           invokeRestart("muffleMessage")
[13:21:32.715]                       }
[13:21:32.715]                       else if (inherits(cond, "warning")) {
[13:21:32.715]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:32.715]                         if (muffled) 
[13:21:32.715]                           invokeRestart("muffleWarning")
[13:21:32.715]                       }
[13:21:32.715]                       else if (inherits(cond, "condition")) {
[13:21:32.715]                         if (!is.null(pattern)) {
[13:21:32.715]                           computeRestarts <- base::computeRestarts
[13:21:32.715]                           grepl <- base::grepl
[13:21:32.715]                           restarts <- computeRestarts(cond)
[13:21:32.715]                           for (restart in restarts) {
[13:21:32.715]                             name <- restart$name
[13:21:32.715]                             if (is.null(name)) 
[13:21:32.715]                               next
[13:21:32.715]                             if (!grepl(pattern, name)) 
[13:21:32.715]                               next
[13:21:32.715]                             invokeRestart(restart)
[13:21:32.715]                             muffled <- TRUE
[13:21:32.715]                             break
[13:21:32.715]                           }
[13:21:32.715]                         }
[13:21:32.715]                       }
[13:21:32.715]                       invisible(muffled)
[13:21:32.715]                     }
[13:21:32.715]                     muffleCondition(cond, pattern = "^muffle")
[13:21:32.715]                   }
[13:21:32.715]                 }
[13:21:32.715]             }
[13:21:32.715]         }))
[13:21:32.715]     }, error = function(ex) {
[13:21:32.715]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:32.715]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:32.715]                 ...future.rng), started = ...future.startTime, 
[13:21:32.715]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:32.715]             version = "1.8"), class = "FutureResult")
[13:21:32.715]     }, finally = {
[13:21:32.715]         if (!identical(...future.workdir, getwd())) 
[13:21:32.715]             setwd(...future.workdir)
[13:21:32.715]         {
[13:21:32.715]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:32.715]                 ...future.oldOptions$nwarnings <- NULL
[13:21:32.715]             }
[13:21:32.715]             base::options(...future.oldOptions)
[13:21:32.715]             if (.Platform$OS.type == "windows") {
[13:21:32.715]                 old_names <- names(...future.oldEnvVars)
[13:21:32.715]                 envs <- base::Sys.getenv()
[13:21:32.715]                 names <- names(envs)
[13:21:32.715]                 common <- intersect(names, old_names)
[13:21:32.715]                 added <- setdiff(names, old_names)
[13:21:32.715]                 removed <- setdiff(old_names, names)
[13:21:32.715]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:32.715]                   envs[common]]
[13:21:32.715]                 NAMES <- toupper(changed)
[13:21:32.715]                 args <- list()
[13:21:32.715]                 for (kk in seq_along(NAMES)) {
[13:21:32.715]                   name <- changed[[kk]]
[13:21:32.715]                   NAME <- NAMES[[kk]]
[13:21:32.715]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:32.715]                     next
[13:21:32.715]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:32.715]                 }
[13:21:32.715]                 NAMES <- toupper(added)
[13:21:32.715]                 for (kk in seq_along(NAMES)) {
[13:21:32.715]                   name <- added[[kk]]
[13:21:32.715]                   NAME <- NAMES[[kk]]
[13:21:32.715]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:32.715]                     next
[13:21:32.715]                   args[[name]] <- ""
[13:21:32.715]                 }
[13:21:32.715]                 NAMES <- toupper(removed)
[13:21:32.715]                 for (kk in seq_along(NAMES)) {
[13:21:32.715]                   name <- removed[[kk]]
[13:21:32.715]                   NAME <- NAMES[[kk]]
[13:21:32.715]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:32.715]                     next
[13:21:32.715]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:32.715]                 }
[13:21:32.715]                 if (length(args) > 0) 
[13:21:32.715]                   base::do.call(base::Sys.setenv, args = args)
[13:21:32.715]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:32.715]             }
[13:21:32.715]             else {
[13:21:32.715]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:32.715]             }
[13:21:32.715]             {
[13:21:32.715]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:32.715]                   0L) {
[13:21:32.715]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:32.715]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:32.715]                   base::options(opts)
[13:21:32.715]                 }
[13:21:32.715]                 {
[13:21:32.715]                   {
[13:21:32.715]                     NULL
[13:21:32.715]                     RNGkind("Mersenne-Twister")
[13:21:32.715]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:32.715]                       inherits = FALSE)
[13:21:32.715]                   }
[13:21:32.715]                   options(future.plan = NULL)
[13:21:32.715]                   if (is.na(NA_character_)) 
[13:21:32.715]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:32.715]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:32.715]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:32.715]                   {
[13:21:32.715]                     future <- SequentialFuture(..., envir = envir)
[13:21:32.715]                     if (!future$lazy) 
[13:21:32.715]                       future <- run(future)
[13:21:32.715]                     invisible(future)
[13:21:32.715]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:32.715]                 }
[13:21:32.715]             }
[13:21:32.715]         }
[13:21:32.715]     })
[13:21:32.715]     if (TRUE) {
[13:21:32.715]         base::sink(type = "output", split = FALSE)
[13:21:32.715]         if (TRUE) {
[13:21:32.715]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:32.715]         }
[13:21:32.715]         else {
[13:21:32.715]             ...future.result["stdout"] <- base::list(NULL)
[13:21:32.715]         }
[13:21:32.715]         base::close(...future.stdout)
[13:21:32.715]         ...future.stdout <- NULL
[13:21:32.715]     }
[13:21:32.715]     ...future.result$conditions <- ...future.conditions
[13:21:32.715]     ...future.result$finished <- base::Sys.time()
[13:21:32.715]     ...future.result
[13:21:32.715] }
[13:21:32.717] assign_globals() ...
[13:21:32.717] List of 11
[13:21:32.717]  $ ...future.FUN            :function (x, ...)  
[13:21:32.717]  $ x_FUN                    :function (x)  
[13:21:32.717]  $ times                    : int 4
[13:21:32.717]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:32.717]  $ stop_if_not              :function (...)  
[13:21:32.717]  $ dim                      : int [1:2] 2 2
[13:21:32.717]  $ valid_types              : chr [1:2] "logical" "integer"
[13:21:32.717]  $ future.call.arguments    : list()
[13:21:32.717]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:32.717]  $ ...future.elements_ii    :List of 10
[13:21:32.717]   ..$ : int 1
[13:21:32.717]   ..$ : int 2
[13:21:32.717]   ..$ : int 3
[13:21:32.717]   ..$ : int 4
[13:21:32.717]   ..$ : int 5
[13:21:32.717]   ..$ : int 6
[13:21:32.717]   ..$ : int 7
[13:21:32.717]   ..$ : int 8
[13:21:32.717]   ..$ : int 9
[13:21:32.717]   ..$ : int 10
[13:21:32.717]  $ ...future.seeds_ii       : NULL
[13:21:32.717]  $ ...future.globals.maxSize: NULL
[13:21:32.717]  - attr(*, "where")=List of 11
[13:21:32.717]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:32.717]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:32.717]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:32.717]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:32.717]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:32.717]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:32.717]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:32.717]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:32.717]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:32.717]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:32.717]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:32.717]  - attr(*, "resolved")= logi FALSE
[13:21:32.717]  - attr(*, "total_size")= num 97232
[13:21:32.717]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:32.717]  - attr(*, "already-done")= logi TRUE
[13:21:32.727] - copied ‘...future.FUN’ to environment
[13:21:32.727] - reassign environment for ‘x_FUN’
[13:21:32.727] - copied ‘x_FUN’ to environment
[13:21:32.727] - copied ‘times’ to environment
[13:21:32.727] - copied ‘stopf’ to environment
[13:21:32.727] - copied ‘stop_if_not’ to environment
[13:21:32.728] - copied ‘dim’ to environment
[13:21:32.728] - copied ‘valid_types’ to environment
[13:21:32.728] - copied ‘future.call.arguments’ to environment
[13:21:32.728] - copied ‘...future.elements_ii’ to environment
[13:21:32.728] - copied ‘...future.seeds_ii’ to environment
[13:21:32.728] - copied ‘...future.globals.maxSize’ to environment
[13:21:32.728] assign_globals() ... done
[13:21:32.729] plan(): Setting new future strategy stack:
[13:21:32.729] List of future strategies:
[13:21:32.729] 1. sequential:
[13:21:32.729]    - args: function (..., envir = parent.frame())
[13:21:32.729]    - tweaked: FALSE
[13:21:32.729]    - call: NULL
[13:21:32.729] plan(): nbrOfWorkers() = 1
[13:21:32.730] plan(): Setting new future strategy stack:
[13:21:32.730] List of future strategies:
[13:21:32.730] 1. sequential:
[13:21:32.730]    - args: function (..., envir = parent.frame())
[13:21:32.730]    - tweaked: FALSE
[13:21:32.730]    - call: plan(strategy)
[13:21:32.730] plan(): nbrOfWorkers() = 1
[13:21:32.730] SequentialFuture started (and completed)
[13:21:32.731] - Launch lazy future ... done
[13:21:32.731] run() for ‘SequentialFuture’ ... done
[13:21:32.731] Created future:
[13:21:32.731] SequentialFuture:
[13:21:32.731] Label: ‘future_vapply-1’
[13:21:32.731] Expression:
[13:21:32.731] {
[13:21:32.731]     do.call(function(...) {
[13:21:32.731]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:32.731]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:32.731]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:32.731]             on.exit(options(oopts), add = TRUE)
[13:21:32.731]         }
[13:21:32.731]         {
[13:21:32.731]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:32.731]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:32.731]                 ...future.FUN(...future.X_jj, ...)
[13:21:32.731]             })
[13:21:32.731]         }
[13:21:32.731]     }, args = future.call.arguments)
[13:21:32.731] }
[13:21:32.731] Lazy evaluation: FALSE
[13:21:32.731] Asynchronous evaluation: FALSE
[13:21:32.731] Local evaluation: TRUE
[13:21:32.731] Environment: R_GlobalEnv
[13:21:32.731] Capture standard output: TRUE
[13:21:32.731] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:32.731] Globals: 11 objects totaling 95.50 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:32.731] Packages: 1 packages (‘future.apply’)
[13:21:32.731] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:32.731] Resolved: TRUE
[13:21:32.731] Value: 2.27 KiB of class ‘list’
[13:21:32.731] Early signaling: FALSE
[13:21:32.731] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:32.731] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:32.734] Chunk #1 of 1 ... DONE
[13:21:32.734] Launching 1 futures (chunks) ... DONE
[13:21:32.734] Resolving 1 futures (chunks) ...
[13:21:32.734] resolve() on list ...
[13:21:32.734]  recursive: 0
[13:21:32.735]  length: 1
[13:21:32.735] 
[13:21:32.735] resolved() for ‘SequentialFuture’ ...
[13:21:32.735] - state: ‘finished’
[13:21:32.735] - run: TRUE
[13:21:32.735] - result: ‘FutureResult’
[13:21:32.735] resolved() for ‘SequentialFuture’ ... done
[13:21:32.735] Future #1
[13:21:32.735] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:21:32.735] - nx: 1
[13:21:32.736] - relay: TRUE
[13:21:32.736] - stdout: TRUE
[13:21:32.736] - signal: TRUE
[13:21:32.736] - resignal: FALSE
[13:21:32.736] - force: TRUE
[13:21:32.736] - relayed: [n=1] FALSE
[13:21:32.736] - queued futures: [n=1] FALSE
[13:21:32.736]  - until=1
[13:21:32.736]  - relaying element #1
[13:21:32.736] - relayed: [n=1] TRUE
[13:21:32.737] - queued futures: [n=1] TRUE
[13:21:32.737] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:21:32.737]  length: 0 (resolved future 1)
[13:21:32.737] Relaying remaining futures
[13:21:32.737] signalConditionsASAP(NULL, pos=0) ...
[13:21:32.737] - nx: 1
[13:21:32.737] - relay: TRUE
[13:21:32.737] - stdout: TRUE
[13:21:32.737] - signal: TRUE
[13:21:32.737] - resignal: FALSE
[13:21:32.737] - force: TRUE
[13:21:32.738] - relayed: [n=1] TRUE
[13:21:32.738] - queued futures: [n=1] TRUE
 - flush all
[13:21:32.738] - relayed: [n=1] TRUE
[13:21:32.738] - queued futures: [n=1] TRUE
[13:21:32.738] signalConditionsASAP(NULL, pos=0) ... done
[13:21:32.738] resolve() on list ... DONE
[13:21:32.738]  - Number of value chunks collected: 1
[13:21:32.738] Resolving 1 futures (chunks) ... DONE
[13:21:32.738] Reducing values from 1 chunks ...
[13:21:32.738]  - Number of values collected after concatenation: 10
[13:21:32.739]  - Number of values expected: 10
[13:21:32.739] Reducing values from 1 chunks ... DONE
[13:21:32.739] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[13:21:32.740] future_lapply() ...
[13:21:32.741] Number of chunks: 1
[13:21:32.742] getGlobalsAndPackagesXApply() ...
[13:21:32.742]  - future.globals: TRUE
[13:21:32.742] getGlobalsAndPackages() ...
[13:21:32.742] Searching for globals...
[13:21:32.745] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[13:21:32.745] Searching for globals ... DONE
[13:21:32.746] Resolving globals: FALSE
[13:21:32.746] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[13:21:32.747] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:32.747] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:32.747] - packages: [1] ‘future.apply’
[13:21:32.747] getGlobalsAndPackages() ... DONE
[13:21:32.747]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:32.747]  - needed namespaces: [n=1] ‘future.apply’
[13:21:32.748] Finding globals ... DONE
[13:21:32.748]  - use_args: TRUE
[13:21:32.748]  - Getting '...' globals ...
[13:21:32.748] resolve() on list ...
[13:21:32.748]  recursive: 0
[13:21:32.748]  length: 1
[13:21:32.748]  elements: ‘...’
[13:21:32.748]  length: 0 (resolved future 1)
[13:21:32.749] resolve() on list ... DONE
[13:21:32.749]    - '...' content: [n=0] 
[13:21:32.749] List of 1
[13:21:32.749]  $ ...: list()
[13:21:32.749]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:32.749]  - attr(*, "where")=List of 1
[13:21:32.749]   ..$ ...:<environment: 0x563b6d8a7e10> 
[13:21:32.749]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:32.749]  - attr(*, "resolved")= logi TRUE
[13:21:32.749]  - attr(*, "total_size")= num NA
[13:21:32.751]  - Getting '...' globals ... DONE
[13:21:32.751] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:32.752] List of 8
[13:21:32.752]  $ ...future.FUN:function (x, ...)  
[13:21:32.752]  $ x_FUN        :function (x)  
[13:21:32.752]  $ times        : int 4
[13:21:32.752]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:32.752]  $ stop_if_not  :function (...)  
[13:21:32.752]  $ dim          : int [1:2] 2 2
[13:21:32.752]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:21:32.752]  $ ...          : list()
[13:21:32.752]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:32.752]  - attr(*, "where")=List of 8
[13:21:32.752]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:32.752]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:32.752]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:32.752]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:32.752]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:32.752]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:32.752]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:32.752]   ..$ ...          :<environment: 0x563b6d8a7e10> 
[13:21:32.752]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:32.752]  - attr(*, "resolved")= logi FALSE
[13:21:32.752]  - attr(*, "total_size")= num 97304
[13:21:32.759] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:21:32.759] getGlobalsAndPackagesXApply() ... DONE
[13:21:32.759] Number of futures (= number of chunks): 1
[13:21:32.759] Launching 1 futures (chunks) ...
[13:21:32.759] Chunk #1 of 1 ...
[13:21:32.760]  - Finding globals in 'X' for chunk #1 ...
[13:21:32.760] getGlobalsAndPackages() ...
[13:21:32.760] Searching for globals...
[13:21:32.760] 
[13:21:32.760] Searching for globals ... DONE
[13:21:32.760] - globals: [0] <none>
[13:21:32.760] getGlobalsAndPackages() ... DONE
[13:21:32.760]    + additional globals found: [n=0] 
[13:21:32.761]    + additional namespaces needed: [n=0] 
[13:21:32.761]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:32.761]  - seeds: <none>
[13:21:32.761]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:32.761] getGlobalsAndPackages() ...
[13:21:32.761] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:32.761] Resolving globals: FALSE
[13:21:32.761] Tweak future expression to call with '...' arguments ...
[13:21:32.761] {
[13:21:32.761]     do.call(function(...) {
[13:21:32.761]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:32.761]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:32.761]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:32.761]             on.exit(options(oopts), add = TRUE)
[13:21:32.761]         }
[13:21:32.761]         {
[13:21:32.761]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:32.761]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:32.761]                 ...future.FUN(...future.X_jj, ...)
[13:21:32.761]             })
[13:21:32.761]         }
[13:21:32.761]     }, args = future.call.arguments)
[13:21:32.761] }
[13:21:32.762] Tweak future expression to call with '...' arguments ... DONE
[13:21:32.762] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:32.762] - packages: [1] ‘future.apply’
[13:21:32.762] getGlobalsAndPackages() ... DONE
[13:21:32.763] run() for ‘Future’ ...
[13:21:32.763] - state: ‘created’
[13:21:32.763] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:32.763] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:32.763] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:32.763]   - Field: ‘label’
[13:21:32.764]   - Field: ‘local’
[13:21:32.764]   - Field: ‘owner’
[13:21:32.764]   - Field: ‘envir’
[13:21:32.764]   - Field: ‘packages’
[13:21:32.764]   - Field: ‘gc’
[13:21:32.764]   - Field: ‘conditions’
[13:21:32.764]   - Field: ‘expr’
[13:21:32.764]   - Field: ‘uuid’
[13:21:32.764]   - Field: ‘seed’
[13:21:32.764]   - Field: ‘version’
[13:21:32.765]   - Field: ‘result’
[13:21:32.765]   - Field: ‘asynchronous’
[13:21:32.765]   - Field: ‘calls’
[13:21:32.765]   - Field: ‘globals’
[13:21:32.765]   - Field: ‘stdout’
[13:21:32.765]   - Field: ‘earlySignal’
[13:21:32.765]   - Field: ‘lazy’
[13:21:32.765]   - Field: ‘state’
[13:21:32.765] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:32.765] - Launch lazy future ...
[13:21:32.766] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:32.766] Packages needed by future strategies (n = 0): <none>
[13:21:32.766] {
[13:21:32.766]     {
[13:21:32.766]         {
[13:21:32.766]             ...future.startTime <- base::Sys.time()
[13:21:32.766]             {
[13:21:32.766]                 {
[13:21:32.766]                   {
[13:21:32.766]                     {
[13:21:32.766]                       base::local({
[13:21:32.766]                         has_future <- base::requireNamespace("future", 
[13:21:32.766]                           quietly = TRUE)
[13:21:32.766]                         if (has_future) {
[13:21:32.766]                           ns <- base::getNamespace("future")
[13:21:32.766]                           version <- ns[[".package"]][["version"]]
[13:21:32.766]                           if (is.null(version)) 
[13:21:32.766]                             version <- utils::packageVersion("future")
[13:21:32.766]                         }
[13:21:32.766]                         else {
[13:21:32.766]                           version <- NULL
[13:21:32.766]                         }
[13:21:32.766]                         if (!has_future || version < "1.8.0") {
[13:21:32.766]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:32.766]                             "", base::R.version$version.string), 
[13:21:32.766]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:32.766]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:32.766]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:32.766]                               "release", "version")], collapse = " "), 
[13:21:32.766]                             hostname = base::Sys.info()[["nodename"]])
[13:21:32.766]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:32.766]                             info)
[13:21:32.766]                           info <- base::paste(info, collapse = "; ")
[13:21:32.766]                           if (!has_future) {
[13:21:32.766]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:32.766]                               info)
[13:21:32.766]                           }
[13:21:32.766]                           else {
[13:21:32.766]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:32.766]                               info, version)
[13:21:32.766]                           }
[13:21:32.766]                           base::stop(msg)
[13:21:32.766]                         }
[13:21:32.766]                       })
[13:21:32.766]                     }
[13:21:32.766]                     base::local({
[13:21:32.766]                       for (pkg in "future.apply") {
[13:21:32.766]                         base::loadNamespace(pkg)
[13:21:32.766]                         base::library(pkg, character.only = TRUE)
[13:21:32.766]                       }
[13:21:32.766]                     })
[13:21:32.766]                   }
[13:21:32.766]                   options(future.plan = NULL)
[13:21:32.766]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:32.766]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:32.766]                 }
[13:21:32.766]                 ...future.workdir <- getwd()
[13:21:32.766]             }
[13:21:32.766]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:32.766]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:32.766]         }
[13:21:32.766]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:32.766]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:32.766]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:32.766]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:32.766]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:32.766]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:32.766]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:32.766]             base::names(...future.oldOptions))
[13:21:32.766]     }
[13:21:32.766]     if (FALSE) {
[13:21:32.766]     }
[13:21:32.766]     else {
[13:21:32.766]         if (TRUE) {
[13:21:32.766]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:32.766]                 open = "w")
[13:21:32.766]         }
[13:21:32.766]         else {
[13:21:32.766]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:32.766]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:32.766]         }
[13:21:32.766]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:32.766]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:32.766]             base::sink(type = "output", split = FALSE)
[13:21:32.766]             base::close(...future.stdout)
[13:21:32.766]         }, add = TRUE)
[13:21:32.766]     }
[13:21:32.766]     ...future.frame <- base::sys.nframe()
[13:21:32.766]     ...future.conditions <- base::list()
[13:21:32.766]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:32.766]     if (FALSE) {
[13:21:32.766]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:32.766]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:32.766]     }
[13:21:32.766]     ...future.result <- base::tryCatch({
[13:21:32.766]         base::withCallingHandlers({
[13:21:32.766]             ...future.value <- base::withVisible(base::local({
[13:21:32.766]                 do.call(function(...) {
[13:21:32.766]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:32.766]                   if (!identical(...future.globals.maxSize.org, 
[13:21:32.766]                     ...future.globals.maxSize)) {
[13:21:32.766]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:32.766]                     on.exit(options(oopts), add = TRUE)
[13:21:32.766]                   }
[13:21:32.766]                   {
[13:21:32.766]                     lapply(seq_along(...future.elements_ii), 
[13:21:32.766]                       FUN = function(jj) {
[13:21:32.766]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:32.766]                         ...future.FUN(...future.X_jj, ...)
[13:21:32.766]                       })
[13:21:32.766]                   }
[13:21:32.766]                 }, args = future.call.arguments)
[13:21:32.766]             }))
[13:21:32.766]             future::FutureResult(value = ...future.value$value, 
[13:21:32.766]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:32.766]                   ...future.rng), globalenv = if (FALSE) 
[13:21:32.766]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:32.766]                     ...future.globalenv.names))
[13:21:32.766]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:32.766]         }, condition = base::local({
[13:21:32.766]             c <- base::c
[13:21:32.766]             inherits <- base::inherits
[13:21:32.766]             invokeRestart <- base::invokeRestart
[13:21:32.766]             length <- base::length
[13:21:32.766]             list <- base::list
[13:21:32.766]             seq.int <- base::seq.int
[13:21:32.766]             signalCondition <- base::signalCondition
[13:21:32.766]             sys.calls <- base::sys.calls
[13:21:32.766]             `[[` <- base::`[[`
[13:21:32.766]             `+` <- base::`+`
[13:21:32.766]             `<<-` <- base::`<<-`
[13:21:32.766]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:32.766]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:32.766]                   3L)]
[13:21:32.766]             }
[13:21:32.766]             function(cond) {
[13:21:32.766]                 is_error <- inherits(cond, "error")
[13:21:32.766]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:32.766]                   NULL)
[13:21:32.766]                 if (is_error) {
[13:21:32.766]                   sessionInformation <- function() {
[13:21:32.766]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:32.766]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:32.766]                       search = base::search(), system = base::Sys.info())
[13:21:32.766]                   }
[13:21:32.766]                   ...future.conditions[[length(...future.conditions) + 
[13:21:32.766]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:32.766]                     cond$call), session = sessionInformation(), 
[13:21:32.766]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:32.766]                   signalCondition(cond)
[13:21:32.766]                 }
[13:21:32.766]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:32.766]                 "immediateCondition"))) {
[13:21:32.766]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:32.766]                   ...future.conditions[[length(...future.conditions) + 
[13:21:32.766]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:32.766]                   if (TRUE && !signal) {
[13:21:32.766]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:32.766]                     {
[13:21:32.766]                       inherits <- base::inherits
[13:21:32.766]                       invokeRestart <- base::invokeRestart
[13:21:32.766]                       is.null <- base::is.null
[13:21:32.766]                       muffled <- FALSE
[13:21:32.766]                       if (inherits(cond, "message")) {
[13:21:32.766]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:32.766]                         if (muffled) 
[13:21:32.766]                           invokeRestart("muffleMessage")
[13:21:32.766]                       }
[13:21:32.766]                       else if (inherits(cond, "warning")) {
[13:21:32.766]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:32.766]                         if (muffled) 
[13:21:32.766]                           invokeRestart("muffleWarning")
[13:21:32.766]                       }
[13:21:32.766]                       else if (inherits(cond, "condition")) {
[13:21:32.766]                         if (!is.null(pattern)) {
[13:21:32.766]                           computeRestarts <- base::computeRestarts
[13:21:32.766]                           grepl <- base::grepl
[13:21:32.766]                           restarts <- computeRestarts(cond)
[13:21:32.766]                           for (restart in restarts) {
[13:21:32.766]                             name <- restart$name
[13:21:32.766]                             if (is.null(name)) 
[13:21:32.766]                               next
[13:21:32.766]                             if (!grepl(pattern, name)) 
[13:21:32.766]                               next
[13:21:32.766]                             invokeRestart(restart)
[13:21:32.766]                             muffled <- TRUE
[13:21:32.766]                             break
[13:21:32.766]                           }
[13:21:32.766]                         }
[13:21:32.766]                       }
[13:21:32.766]                       invisible(muffled)
[13:21:32.766]                     }
[13:21:32.766]                     muffleCondition(cond, pattern = "^muffle")
[13:21:32.766]                   }
[13:21:32.766]                 }
[13:21:32.766]                 else {
[13:21:32.766]                   if (TRUE) {
[13:21:32.766]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:32.766]                     {
[13:21:32.766]                       inherits <- base::inherits
[13:21:32.766]                       invokeRestart <- base::invokeRestart
[13:21:32.766]                       is.null <- base::is.null
[13:21:32.766]                       muffled <- FALSE
[13:21:32.766]                       if (inherits(cond, "message")) {
[13:21:32.766]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:32.766]                         if (muffled) 
[13:21:32.766]                           invokeRestart("muffleMessage")
[13:21:32.766]                       }
[13:21:32.766]                       else if (inherits(cond, "warning")) {
[13:21:32.766]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:32.766]                         if (muffled) 
[13:21:32.766]                           invokeRestart("muffleWarning")
[13:21:32.766]                       }
[13:21:32.766]                       else if (inherits(cond, "condition")) {
[13:21:32.766]                         if (!is.null(pattern)) {
[13:21:32.766]                           computeRestarts <- base::computeRestarts
[13:21:32.766]                           grepl <- base::grepl
[13:21:32.766]                           restarts <- computeRestarts(cond)
[13:21:32.766]                           for (restart in restarts) {
[13:21:32.766]                             name <- restart$name
[13:21:32.766]                             if (is.null(name)) 
[13:21:32.766]                               next
[13:21:32.766]                             if (!grepl(pattern, name)) 
[13:21:32.766]                               next
[13:21:32.766]                             invokeRestart(restart)
[13:21:32.766]                             muffled <- TRUE
[13:21:32.766]                             break
[13:21:32.766]                           }
[13:21:32.766]                         }
[13:21:32.766]                       }
[13:21:32.766]                       invisible(muffled)
[13:21:32.766]                     }
[13:21:32.766]                     muffleCondition(cond, pattern = "^muffle")
[13:21:32.766]                   }
[13:21:32.766]                 }
[13:21:32.766]             }
[13:21:32.766]         }))
[13:21:32.766]     }, error = function(ex) {
[13:21:32.766]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:32.766]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:32.766]                 ...future.rng), started = ...future.startTime, 
[13:21:32.766]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:32.766]             version = "1.8"), class = "FutureResult")
[13:21:32.766]     }, finally = {
[13:21:32.766]         if (!identical(...future.workdir, getwd())) 
[13:21:32.766]             setwd(...future.workdir)
[13:21:32.766]         {
[13:21:32.766]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:32.766]                 ...future.oldOptions$nwarnings <- NULL
[13:21:32.766]             }
[13:21:32.766]             base::options(...future.oldOptions)
[13:21:32.766]             if (.Platform$OS.type == "windows") {
[13:21:32.766]                 old_names <- names(...future.oldEnvVars)
[13:21:32.766]                 envs <- base::Sys.getenv()
[13:21:32.766]                 names <- names(envs)
[13:21:32.766]                 common <- intersect(names, old_names)
[13:21:32.766]                 added <- setdiff(names, old_names)
[13:21:32.766]                 removed <- setdiff(old_names, names)
[13:21:32.766]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:32.766]                   envs[common]]
[13:21:32.766]                 NAMES <- toupper(changed)
[13:21:32.766]                 args <- list()
[13:21:32.766]                 for (kk in seq_along(NAMES)) {
[13:21:32.766]                   name <- changed[[kk]]
[13:21:32.766]                   NAME <- NAMES[[kk]]
[13:21:32.766]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:32.766]                     next
[13:21:32.766]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:32.766]                 }
[13:21:32.766]                 NAMES <- toupper(added)
[13:21:32.766]                 for (kk in seq_along(NAMES)) {
[13:21:32.766]                   name <- added[[kk]]
[13:21:32.766]                   NAME <- NAMES[[kk]]
[13:21:32.766]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:32.766]                     next
[13:21:32.766]                   args[[name]] <- ""
[13:21:32.766]                 }
[13:21:32.766]                 NAMES <- toupper(removed)
[13:21:32.766]                 for (kk in seq_along(NAMES)) {
[13:21:32.766]                   name <- removed[[kk]]
[13:21:32.766]                   NAME <- NAMES[[kk]]
[13:21:32.766]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:32.766]                     next
[13:21:32.766]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:32.766]                 }
[13:21:32.766]                 if (length(args) > 0) 
[13:21:32.766]                   base::do.call(base::Sys.setenv, args = args)
[13:21:32.766]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:32.766]             }
[13:21:32.766]             else {
[13:21:32.766]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:32.766]             }
[13:21:32.766]             {
[13:21:32.766]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:32.766]                   0L) {
[13:21:32.766]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:32.766]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:32.766]                   base::options(opts)
[13:21:32.766]                 }
[13:21:32.766]                 {
[13:21:32.766]                   {
[13:21:32.766]                     NULL
[13:21:32.766]                     RNGkind("Mersenne-Twister")
[13:21:32.766]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:32.766]                       inherits = FALSE)
[13:21:32.766]                   }
[13:21:32.766]                   options(future.plan = NULL)
[13:21:32.766]                   if (is.na(NA_character_)) 
[13:21:32.766]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:32.766]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:32.766]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:32.766]                   {
[13:21:32.766]                     future <- SequentialFuture(..., envir = envir)
[13:21:32.766]                     if (!future$lazy) 
[13:21:32.766]                       future <- run(future)
[13:21:32.766]                     invisible(future)
[13:21:32.766]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:32.766]                 }
[13:21:32.766]             }
[13:21:32.766]         }
[13:21:32.766]     })
[13:21:32.766]     if (TRUE) {
[13:21:32.766]         base::sink(type = "output", split = FALSE)
[13:21:32.766]         if (TRUE) {
[13:21:32.766]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:32.766]         }
[13:21:32.766]         else {
[13:21:32.766]             ...future.result["stdout"] <- base::list(NULL)
[13:21:32.766]         }
[13:21:32.766]         base::close(...future.stdout)
[13:21:32.766]         ...future.stdout <- NULL
[13:21:32.766]     }
[13:21:32.766]     ...future.result$conditions <- ...future.conditions
[13:21:32.766]     ...future.result$finished <- base::Sys.time()
[13:21:32.766]     ...future.result
[13:21:32.766] }
[13:21:32.768] assign_globals() ...
[13:21:32.768] List of 11
[13:21:32.768]  $ ...future.FUN            :function (x, ...)  
[13:21:32.768]  $ x_FUN                    :function (x)  
[13:21:32.768]  $ times                    : int 4
[13:21:32.768]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:32.768]  $ stop_if_not              :function (...)  
[13:21:32.768]  $ dim                      : int [1:2] 2 2
[13:21:32.768]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:21:32.768]  $ future.call.arguments    : list()
[13:21:32.768]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:32.768]  $ ...future.elements_ii    :List of 10
[13:21:32.768]   ..$ : int 1
[13:21:32.768]   ..$ : int 2
[13:21:32.768]   ..$ : int 3
[13:21:32.768]   ..$ : int 4
[13:21:32.768]   ..$ : int 5
[13:21:32.768]   ..$ : int 6
[13:21:32.768]   ..$ : int 7
[13:21:32.768]   ..$ : int 8
[13:21:32.768]   ..$ : int 9
[13:21:32.768]   ..$ : int 10
[13:21:32.768]  $ ...future.seeds_ii       : NULL
[13:21:32.768]  $ ...future.globals.maxSize: NULL
[13:21:32.768]  - attr(*, "where")=List of 11
[13:21:32.768]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:32.768]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:32.768]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:32.768]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:32.768]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:32.768]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:32.768]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:32.768]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:32.768]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:32.768]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:32.768]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:32.768]  - attr(*, "resolved")= logi FALSE
[13:21:32.768]  - attr(*, "total_size")= num 97304
[13:21:32.768]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:32.768]  - attr(*, "already-done")= logi TRUE
[13:21:32.808] - copied ‘...future.FUN’ to environment
[13:21:32.809] - reassign environment for ‘x_FUN’
[13:21:32.809] - copied ‘x_FUN’ to environment
[13:21:32.809] - copied ‘times’ to environment
[13:21:32.809] - copied ‘stopf’ to environment
[13:21:32.809] - copied ‘stop_if_not’ to environment
[13:21:32.809] - copied ‘dim’ to environment
[13:21:32.809] - copied ‘valid_types’ to environment
[13:21:32.809] - copied ‘future.call.arguments’ to environment
[13:21:32.809] - copied ‘...future.elements_ii’ to environment
[13:21:32.809] - copied ‘...future.seeds_ii’ to environment
[13:21:32.810] - copied ‘...future.globals.maxSize’ to environment
[13:21:32.810] assign_globals() ... done
[13:21:32.810] plan(): Setting new future strategy stack:
[13:21:32.810] List of future strategies:
[13:21:32.810] 1. sequential:
[13:21:32.810]    - args: function (..., envir = parent.frame())
[13:21:32.810]    - tweaked: FALSE
[13:21:32.810]    - call: NULL
[13:21:32.811] plan(): nbrOfWorkers() = 1
[13:21:32.811] plan(): Setting new future strategy stack:
[13:21:32.812] List of future strategies:
[13:21:32.812] 1. sequential:
[13:21:32.812]    - args: function (..., envir = parent.frame())
[13:21:32.812]    - tweaked: FALSE
[13:21:32.812]    - call: plan(strategy)
[13:21:32.812] plan(): nbrOfWorkers() = 1
[13:21:32.812] SequentialFuture started (and completed)
[13:21:32.812] - Launch lazy future ... done
[13:21:32.812] run() for ‘SequentialFuture’ ... done
[13:21:32.812] Created future:
[13:21:32.813] SequentialFuture:
[13:21:32.813] Label: ‘future_vapply-1’
[13:21:32.813] Expression:
[13:21:32.813] {
[13:21:32.813]     do.call(function(...) {
[13:21:32.813]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:32.813]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:32.813]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:32.813]             on.exit(options(oopts), add = TRUE)
[13:21:32.813]         }
[13:21:32.813]         {
[13:21:32.813]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:32.813]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:32.813]                 ...future.FUN(...future.X_jj, ...)
[13:21:32.813]             })
[13:21:32.813]         }
[13:21:32.813]     }, args = future.call.arguments)
[13:21:32.813] }
[13:21:32.813] Lazy evaluation: FALSE
[13:21:32.813] Asynchronous evaluation: FALSE
[13:21:32.813] Local evaluation: TRUE
[13:21:32.813] Environment: R_GlobalEnv
[13:21:32.813] Capture standard output: TRUE
[13:21:32.813] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:32.813] Globals: 11 objects totaling 95.57 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:32.813] Packages: 1 packages (‘future.apply’)
[13:21:32.813] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:32.813] Resolved: TRUE
[13:21:32.813] Value: 2.27 KiB of class ‘list’
[13:21:32.813] Early signaling: FALSE
[13:21:32.813] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:32.813] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:32.814] Chunk #1 of 1 ... DONE
[13:21:32.814] Launching 1 futures (chunks) ... DONE
[13:21:32.814] Resolving 1 futures (chunks) ...
[13:21:32.814] resolve() on list ...
[13:21:32.814]  recursive: 0
[13:21:32.814]  length: 1
[13:21:32.814] 
[13:21:32.814] resolved() for ‘SequentialFuture’ ...
[13:21:32.815] - state: ‘finished’
[13:21:32.815] - run: TRUE
[13:21:32.815] - result: ‘FutureResult’
[13:21:32.815] resolved() for ‘SequentialFuture’ ... done
[13:21:32.815] Future #1
[13:21:32.815] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:21:32.815] - nx: 1
[13:21:32.815] - relay: TRUE
[13:21:32.815] - stdout: TRUE
[13:21:32.815] - signal: TRUE
[13:21:32.816] - resignal: FALSE
[13:21:32.816] - force: TRUE
[13:21:32.816] - relayed: [n=1] FALSE
[13:21:32.816] - queued futures: [n=1] FALSE
[13:21:32.816]  - until=1
[13:21:32.816]  - relaying element #1
[13:21:32.816] - relayed: [n=1] TRUE
[13:21:32.816] - queued futures: [n=1] TRUE
[13:21:32.816] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:21:32.817]  length: 0 (resolved future 1)
[13:21:32.817] Relaying remaining futures
[13:21:32.817] signalConditionsASAP(NULL, pos=0) ...
[13:21:32.817] - nx: 1
[13:21:32.817] - relay: TRUE
[13:21:32.817] - stdout: TRUE
[13:21:32.817] - signal: TRUE
[13:21:32.817] - resignal: FALSE
[13:21:32.817] - force: TRUE
[13:21:32.817] - relayed: [n=1] TRUE
[13:21:32.817] - queued futures: [n=1] TRUE
 - flush all
[13:21:32.818] - relayed: [n=1] TRUE
[13:21:32.818] - queued futures: [n=1] TRUE
[13:21:32.818] signalConditionsASAP(NULL, pos=0) ... done
[13:21:32.818] resolve() on list ... DONE
[13:21:32.818]  - Number of value chunks collected: 1
[13:21:32.818] Resolving 1 futures (chunks) ... DONE
[13:21:32.818] Reducing values from 1 chunks ...
[13:21:32.818]  - Number of values collected after concatenation: 10
[13:21:32.818]  - Number of values expected: 10
[13:21:32.818] Reducing values from 1 chunks ... DONE
[13:21:32.818] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[13:21:32.820] future_lapply() ...
[13:21:32.822] Number of chunks: 1
[13:21:32.822] getGlobalsAndPackagesXApply() ...
[13:21:32.822]  - future.globals: TRUE
[13:21:32.823] getGlobalsAndPackages() ...
[13:21:32.823] Searching for globals...
[13:21:32.826] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[13:21:32.827] Searching for globals ... DONE
[13:21:32.827] Resolving globals: FALSE
[13:21:32.828] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[13:21:32.828] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:32.828] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:32.828] - packages: [1] ‘future.apply’
[13:21:32.828] getGlobalsAndPackages() ... DONE
[13:21:32.829]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:32.829]  - needed namespaces: [n=1] ‘future.apply’
[13:21:32.829] Finding globals ... DONE
[13:21:32.829]  - use_args: TRUE
[13:21:32.830]  - Getting '...' globals ...
[13:21:32.831] resolve() on list ...
[13:21:32.831]  recursive: 0
[13:21:32.831]  length: 1
[13:21:32.831]  elements: ‘...’
[13:21:32.831]  length: 0 (resolved future 1)
[13:21:32.832] resolve() on list ... DONE
[13:21:32.832]    - '...' content: [n=0] 
[13:21:32.832] List of 1
[13:21:32.832]  $ ...: list()
[13:21:32.832]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:32.832]  - attr(*, "where")=List of 1
[13:21:32.832]   ..$ ...:<environment: 0x563b6eee8eb8> 
[13:21:32.832]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:32.832]  - attr(*, "resolved")= logi TRUE
[13:21:32.832]  - attr(*, "total_size")= num NA
[13:21:32.835]  - Getting '...' globals ... DONE
[13:21:32.835] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:32.835] List of 8
[13:21:32.835]  $ ...future.FUN:function (x, ...)  
[13:21:32.835]  $ x_FUN        :function (x)  
[13:21:32.835]  $ times        : int 4
[13:21:32.835]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:32.835]  $ stop_if_not  :function (...)  
[13:21:32.835]  $ dim          : int [1:2] 2 2
[13:21:32.835]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:21:32.835]  $ ...          : list()
[13:21:32.835]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:32.835]  - attr(*, "where")=List of 8
[13:21:32.835]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:32.835]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:32.835]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:32.835]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:32.835]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:32.835]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:32.835]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:32.835]   ..$ ...          :<environment: 0x563b6eee8eb8> 
[13:21:32.835]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:32.835]  - attr(*, "resolved")= logi FALSE
[13:21:32.835]  - attr(*, "total_size")= num 105552
[13:21:32.841] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:21:32.841] getGlobalsAndPackagesXApply() ... DONE
[13:21:32.841] Number of futures (= number of chunks): 1
[13:21:32.841] Launching 1 futures (chunks) ...
[13:21:32.841] Chunk #1 of 1 ...
[13:21:32.841]  - Finding globals in 'X' for chunk #1 ...
[13:21:32.841] getGlobalsAndPackages() ...
[13:21:32.842] Searching for globals...
[13:21:32.842] 
[13:21:32.842] Searching for globals ... DONE
[13:21:32.842] - globals: [0] <none>
[13:21:32.842] getGlobalsAndPackages() ... DONE
[13:21:32.842]    + additional globals found: [n=0] 
[13:21:32.842]    + additional namespaces needed: [n=0] 
[13:21:32.842]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:32.842]  - seeds: <none>
[13:21:32.843]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:32.843] getGlobalsAndPackages() ...
[13:21:32.843] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:32.843] Resolving globals: FALSE
[13:21:32.843] Tweak future expression to call with '...' arguments ...
[13:21:32.843] {
[13:21:32.843]     do.call(function(...) {
[13:21:32.843]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:32.843]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:32.843]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:32.843]             on.exit(options(oopts), add = TRUE)
[13:21:32.843]         }
[13:21:32.843]         {
[13:21:32.843]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:32.843]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:32.843]                 ...future.FUN(...future.X_jj, ...)
[13:21:32.843]             })
[13:21:32.843]         }
[13:21:32.843]     }, args = future.call.arguments)
[13:21:32.843] }
[13:21:32.843] Tweak future expression to call with '...' arguments ... DONE
[13:21:32.844] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:32.844] - packages: [1] ‘future.apply’
[13:21:32.844] getGlobalsAndPackages() ... DONE
[13:21:32.844] run() for ‘Future’ ...
[13:21:32.845] - state: ‘created’
[13:21:32.845] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:32.845] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:32.845] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:32.845]   - Field: ‘label’
[13:21:32.845]   - Field: ‘local’
[13:21:32.845]   - Field: ‘owner’
[13:21:32.846]   - Field: ‘envir’
[13:21:32.846]   - Field: ‘packages’
[13:21:32.846]   - Field: ‘gc’
[13:21:32.846]   - Field: ‘conditions’
[13:21:32.846]   - Field: ‘expr’
[13:21:32.846]   - Field: ‘uuid’
[13:21:32.846]   - Field: ‘seed’
[13:21:32.846]   - Field: ‘version’
[13:21:32.846]   - Field: ‘result’
[13:21:32.846]   - Field: ‘asynchronous’
[13:21:32.846]   - Field: ‘calls’
[13:21:32.847]   - Field: ‘globals’
[13:21:32.847]   - Field: ‘stdout’
[13:21:32.847]   - Field: ‘earlySignal’
[13:21:32.847]   - Field: ‘lazy’
[13:21:32.847]   - Field: ‘state’
[13:21:32.847] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:32.847] - Launch lazy future ...
[13:21:32.847] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:32.847] Packages needed by future strategies (n = 0): <none>
[13:21:32.848] {
[13:21:32.848]     {
[13:21:32.848]         {
[13:21:32.848]             ...future.startTime <- base::Sys.time()
[13:21:32.848]             {
[13:21:32.848]                 {
[13:21:32.848]                   {
[13:21:32.848]                     {
[13:21:32.848]                       base::local({
[13:21:32.848]                         has_future <- base::requireNamespace("future", 
[13:21:32.848]                           quietly = TRUE)
[13:21:32.848]                         if (has_future) {
[13:21:32.848]                           ns <- base::getNamespace("future")
[13:21:32.848]                           version <- ns[[".package"]][["version"]]
[13:21:32.848]                           if (is.null(version)) 
[13:21:32.848]                             version <- utils::packageVersion("future")
[13:21:32.848]                         }
[13:21:32.848]                         else {
[13:21:32.848]                           version <- NULL
[13:21:32.848]                         }
[13:21:32.848]                         if (!has_future || version < "1.8.0") {
[13:21:32.848]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:32.848]                             "", base::R.version$version.string), 
[13:21:32.848]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:32.848]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:32.848]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:32.848]                               "release", "version")], collapse = " "), 
[13:21:32.848]                             hostname = base::Sys.info()[["nodename"]])
[13:21:32.848]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:32.848]                             info)
[13:21:32.848]                           info <- base::paste(info, collapse = "; ")
[13:21:32.848]                           if (!has_future) {
[13:21:32.848]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:32.848]                               info)
[13:21:32.848]                           }
[13:21:32.848]                           else {
[13:21:32.848]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:32.848]                               info, version)
[13:21:32.848]                           }
[13:21:32.848]                           base::stop(msg)
[13:21:32.848]                         }
[13:21:32.848]                       })
[13:21:32.848]                     }
[13:21:32.848]                     base::local({
[13:21:32.848]                       for (pkg in "future.apply") {
[13:21:32.848]                         base::loadNamespace(pkg)
[13:21:32.848]                         base::library(pkg, character.only = TRUE)
[13:21:32.848]                       }
[13:21:32.848]                     })
[13:21:32.848]                   }
[13:21:32.848]                   options(future.plan = NULL)
[13:21:32.848]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:32.848]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:32.848]                 }
[13:21:32.848]                 ...future.workdir <- getwd()
[13:21:32.848]             }
[13:21:32.848]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:32.848]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:32.848]         }
[13:21:32.848]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:32.848]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:32.848]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:32.848]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:32.848]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:32.848]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:32.848]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:32.848]             base::names(...future.oldOptions))
[13:21:32.848]     }
[13:21:32.848]     if (FALSE) {
[13:21:32.848]     }
[13:21:32.848]     else {
[13:21:32.848]         if (TRUE) {
[13:21:32.848]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:32.848]                 open = "w")
[13:21:32.848]         }
[13:21:32.848]         else {
[13:21:32.848]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:32.848]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:32.848]         }
[13:21:32.848]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:32.848]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:32.848]             base::sink(type = "output", split = FALSE)
[13:21:32.848]             base::close(...future.stdout)
[13:21:32.848]         }, add = TRUE)
[13:21:32.848]     }
[13:21:32.848]     ...future.frame <- base::sys.nframe()
[13:21:32.848]     ...future.conditions <- base::list()
[13:21:32.848]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:32.848]     if (FALSE) {
[13:21:32.848]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:32.848]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:32.848]     }
[13:21:32.848]     ...future.result <- base::tryCatch({
[13:21:32.848]         base::withCallingHandlers({
[13:21:32.848]             ...future.value <- base::withVisible(base::local({
[13:21:32.848]                 do.call(function(...) {
[13:21:32.848]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:32.848]                   if (!identical(...future.globals.maxSize.org, 
[13:21:32.848]                     ...future.globals.maxSize)) {
[13:21:32.848]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:32.848]                     on.exit(options(oopts), add = TRUE)
[13:21:32.848]                   }
[13:21:32.848]                   {
[13:21:32.848]                     lapply(seq_along(...future.elements_ii), 
[13:21:32.848]                       FUN = function(jj) {
[13:21:32.848]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:32.848]                         ...future.FUN(...future.X_jj, ...)
[13:21:32.848]                       })
[13:21:32.848]                   }
[13:21:32.848]                 }, args = future.call.arguments)
[13:21:32.848]             }))
[13:21:32.848]             future::FutureResult(value = ...future.value$value, 
[13:21:32.848]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:32.848]                   ...future.rng), globalenv = if (FALSE) 
[13:21:32.848]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:32.848]                     ...future.globalenv.names))
[13:21:32.848]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:32.848]         }, condition = base::local({
[13:21:32.848]             c <- base::c
[13:21:32.848]             inherits <- base::inherits
[13:21:32.848]             invokeRestart <- base::invokeRestart
[13:21:32.848]             length <- base::length
[13:21:32.848]             list <- base::list
[13:21:32.848]             seq.int <- base::seq.int
[13:21:32.848]             signalCondition <- base::signalCondition
[13:21:32.848]             sys.calls <- base::sys.calls
[13:21:32.848]             `[[` <- base::`[[`
[13:21:32.848]             `+` <- base::`+`
[13:21:32.848]             `<<-` <- base::`<<-`
[13:21:32.848]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:32.848]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:32.848]                   3L)]
[13:21:32.848]             }
[13:21:32.848]             function(cond) {
[13:21:32.848]                 is_error <- inherits(cond, "error")
[13:21:32.848]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:32.848]                   NULL)
[13:21:32.848]                 if (is_error) {
[13:21:32.848]                   sessionInformation <- function() {
[13:21:32.848]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:32.848]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:32.848]                       search = base::search(), system = base::Sys.info())
[13:21:32.848]                   }
[13:21:32.848]                   ...future.conditions[[length(...future.conditions) + 
[13:21:32.848]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:32.848]                     cond$call), session = sessionInformation(), 
[13:21:32.848]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:32.848]                   signalCondition(cond)
[13:21:32.848]                 }
[13:21:32.848]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:32.848]                 "immediateCondition"))) {
[13:21:32.848]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:32.848]                   ...future.conditions[[length(...future.conditions) + 
[13:21:32.848]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:32.848]                   if (TRUE && !signal) {
[13:21:32.848]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:32.848]                     {
[13:21:32.848]                       inherits <- base::inherits
[13:21:32.848]                       invokeRestart <- base::invokeRestart
[13:21:32.848]                       is.null <- base::is.null
[13:21:32.848]                       muffled <- FALSE
[13:21:32.848]                       if (inherits(cond, "message")) {
[13:21:32.848]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:32.848]                         if (muffled) 
[13:21:32.848]                           invokeRestart("muffleMessage")
[13:21:32.848]                       }
[13:21:32.848]                       else if (inherits(cond, "warning")) {
[13:21:32.848]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:32.848]                         if (muffled) 
[13:21:32.848]                           invokeRestart("muffleWarning")
[13:21:32.848]                       }
[13:21:32.848]                       else if (inherits(cond, "condition")) {
[13:21:32.848]                         if (!is.null(pattern)) {
[13:21:32.848]                           computeRestarts <- base::computeRestarts
[13:21:32.848]                           grepl <- base::grepl
[13:21:32.848]                           restarts <- computeRestarts(cond)
[13:21:32.848]                           for (restart in restarts) {
[13:21:32.848]                             name <- restart$name
[13:21:32.848]                             if (is.null(name)) 
[13:21:32.848]                               next
[13:21:32.848]                             if (!grepl(pattern, name)) 
[13:21:32.848]                               next
[13:21:32.848]                             invokeRestart(restart)
[13:21:32.848]                             muffled <- TRUE
[13:21:32.848]                             break
[13:21:32.848]                           }
[13:21:32.848]                         }
[13:21:32.848]                       }
[13:21:32.848]                       invisible(muffled)
[13:21:32.848]                     }
[13:21:32.848]                     muffleCondition(cond, pattern = "^muffle")
[13:21:32.848]                   }
[13:21:32.848]                 }
[13:21:32.848]                 else {
[13:21:32.848]                   if (TRUE) {
[13:21:32.848]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:32.848]                     {
[13:21:32.848]                       inherits <- base::inherits
[13:21:32.848]                       invokeRestart <- base::invokeRestart
[13:21:32.848]                       is.null <- base::is.null
[13:21:32.848]                       muffled <- FALSE
[13:21:32.848]                       if (inherits(cond, "message")) {
[13:21:32.848]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:32.848]                         if (muffled) 
[13:21:32.848]                           invokeRestart("muffleMessage")
[13:21:32.848]                       }
[13:21:32.848]                       else if (inherits(cond, "warning")) {
[13:21:32.848]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:32.848]                         if (muffled) 
[13:21:32.848]                           invokeRestart("muffleWarning")
[13:21:32.848]                       }
[13:21:32.848]                       else if (inherits(cond, "condition")) {
[13:21:32.848]                         if (!is.null(pattern)) {
[13:21:32.848]                           computeRestarts <- base::computeRestarts
[13:21:32.848]                           grepl <- base::grepl
[13:21:32.848]                           restarts <- computeRestarts(cond)
[13:21:32.848]                           for (restart in restarts) {
[13:21:32.848]                             name <- restart$name
[13:21:32.848]                             if (is.null(name)) 
[13:21:32.848]                               next
[13:21:32.848]                             if (!grepl(pattern, name)) 
[13:21:32.848]                               next
[13:21:32.848]                             invokeRestart(restart)
[13:21:32.848]                             muffled <- TRUE
[13:21:32.848]                             break
[13:21:32.848]                           }
[13:21:32.848]                         }
[13:21:32.848]                       }
[13:21:32.848]                       invisible(muffled)
[13:21:32.848]                     }
[13:21:32.848]                     muffleCondition(cond, pattern = "^muffle")
[13:21:32.848]                   }
[13:21:32.848]                 }
[13:21:32.848]             }
[13:21:32.848]         }))
[13:21:32.848]     }, error = function(ex) {
[13:21:32.848]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:32.848]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:32.848]                 ...future.rng), started = ...future.startTime, 
[13:21:32.848]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:32.848]             version = "1.8"), class = "FutureResult")
[13:21:32.848]     }, finally = {
[13:21:32.848]         if (!identical(...future.workdir, getwd())) 
[13:21:32.848]             setwd(...future.workdir)
[13:21:32.848]         {
[13:21:32.848]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:32.848]                 ...future.oldOptions$nwarnings <- NULL
[13:21:32.848]             }
[13:21:32.848]             base::options(...future.oldOptions)
[13:21:32.848]             if (.Platform$OS.type == "windows") {
[13:21:32.848]                 old_names <- names(...future.oldEnvVars)
[13:21:32.848]                 envs <- base::Sys.getenv()
[13:21:32.848]                 names <- names(envs)
[13:21:32.848]                 common <- intersect(names, old_names)
[13:21:32.848]                 added <- setdiff(names, old_names)
[13:21:32.848]                 removed <- setdiff(old_names, names)
[13:21:32.848]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:32.848]                   envs[common]]
[13:21:32.848]                 NAMES <- toupper(changed)
[13:21:32.848]                 args <- list()
[13:21:32.848]                 for (kk in seq_along(NAMES)) {
[13:21:32.848]                   name <- changed[[kk]]
[13:21:32.848]                   NAME <- NAMES[[kk]]
[13:21:32.848]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:32.848]                     next
[13:21:32.848]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:32.848]                 }
[13:21:32.848]                 NAMES <- toupper(added)
[13:21:32.848]                 for (kk in seq_along(NAMES)) {
[13:21:32.848]                   name <- added[[kk]]
[13:21:32.848]                   NAME <- NAMES[[kk]]
[13:21:32.848]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:32.848]                     next
[13:21:32.848]                   args[[name]] <- ""
[13:21:32.848]                 }
[13:21:32.848]                 NAMES <- toupper(removed)
[13:21:32.848]                 for (kk in seq_along(NAMES)) {
[13:21:32.848]                   name <- removed[[kk]]
[13:21:32.848]                   NAME <- NAMES[[kk]]
[13:21:32.848]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:32.848]                     next
[13:21:32.848]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:32.848]                 }
[13:21:32.848]                 if (length(args) > 0) 
[13:21:32.848]                   base::do.call(base::Sys.setenv, args = args)
[13:21:32.848]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:32.848]             }
[13:21:32.848]             else {
[13:21:32.848]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:32.848]             }
[13:21:32.848]             {
[13:21:32.848]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:32.848]                   0L) {
[13:21:32.848]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:32.848]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:32.848]                   base::options(opts)
[13:21:32.848]                 }
[13:21:32.848]                 {
[13:21:32.848]                   {
[13:21:32.848]                     NULL
[13:21:32.848]                     RNGkind("Mersenne-Twister")
[13:21:32.848]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:32.848]                       inherits = FALSE)
[13:21:32.848]                   }
[13:21:32.848]                   options(future.plan = NULL)
[13:21:32.848]                   if (is.na(NA_character_)) 
[13:21:32.848]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:32.848]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:32.848]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:32.848]                   {
[13:21:32.848]                     future <- SequentialFuture(..., envir = envir)
[13:21:32.848]                     if (!future$lazy) 
[13:21:32.848]                       future <- run(future)
[13:21:32.848]                     invisible(future)
[13:21:32.848]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:32.848]                 }
[13:21:32.848]             }
[13:21:32.848]         }
[13:21:32.848]     })
[13:21:32.848]     if (TRUE) {
[13:21:32.848]         base::sink(type = "output", split = FALSE)
[13:21:32.848]         if (TRUE) {
[13:21:32.848]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:32.848]         }
[13:21:32.848]         else {
[13:21:32.848]             ...future.result["stdout"] <- base::list(NULL)
[13:21:32.848]         }
[13:21:32.848]         base::close(...future.stdout)
[13:21:32.848]         ...future.stdout <- NULL
[13:21:32.848]     }
[13:21:32.848]     ...future.result$conditions <- ...future.conditions
[13:21:32.848]     ...future.result$finished <- base::Sys.time()
[13:21:32.848]     ...future.result
[13:21:32.848] }
[13:21:32.850] assign_globals() ...
[13:21:32.850] List of 11
[13:21:32.850]  $ ...future.FUN            :function (x, ...)  
[13:21:32.850]  $ x_FUN                    :function (x)  
[13:21:32.850]  $ times                    : int 4
[13:21:32.850]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:32.850]  $ stop_if_not              :function (...)  
[13:21:32.850]  $ dim                      : int [1:2] 2 2
[13:21:32.850]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:21:32.850]  $ future.call.arguments    : list()
[13:21:32.850]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:32.850]  $ ...future.elements_ii    :List of 10
[13:21:32.850]   ..$ : int 1
[13:21:32.850]   ..$ : int 2
[13:21:32.850]   ..$ : int 3
[13:21:32.850]   ..$ : int 4
[13:21:32.850]   ..$ : int 5
[13:21:32.850]   ..$ : int 6
[13:21:32.850]   ..$ : int 7
[13:21:32.850]   ..$ : int 8
[13:21:32.850]   ..$ : int 9
[13:21:32.850]   ..$ : int 10
[13:21:32.850]  $ ...future.seeds_ii       : NULL
[13:21:32.850]  $ ...future.globals.maxSize: NULL
[13:21:32.850]  - attr(*, "where")=List of 11
[13:21:32.850]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:32.850]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:32.850]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:32.850]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:32.850]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:32.850]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:32.850]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:32.850]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:32.850]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:32.850]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:32.850]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:32.850]  - attr(*, "resolved")= logi FALSE
[13:21:32.850]  - attr(*, "total_size")= num 105552
[13:21:32.850]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:32.850]  - attr(*, "already-done")= logi TRUE
[13:21:32.862] - copied ‘...future.FUN’ to environment
[13:21:32.862] - reassign environment for ‘x_FUN’
[13:21:32.863] - copied ‘x_FUN’ to environment
[13:21:32.863] - copied ‘times’ to environment
[13:21:32.863] - copied ‘stopf’ to environment
[13:21:32.863] - copied ‘stop_if_not’ to environment
[13:21:32.863] - copied ‘dim’ to environment
[13:21:32.863] - copied ‘valid_types’ to environment
[13:21:32.863] - copied ‘future.call.arguments’ to environment
[13:21:32.863] - copied ‘...future.elements_ii’ to environment
[13:21:32.863] - copied ‘...future.seeds_ii’ to environment
[13:21:32.863] - copied ‘...future.globals.maxSize’ to environment
[13:21:32.864] assign_globals() ... done
[13:21:32.864] plan(): Setting new future strategy stack:
[13:21:32.864] List of future strategies:
[13:21:32.864] 1. sequential:
[13:21:32.864]    - args: function (..., envir = parent.frame())
[13:21:32.864]    - tweaked: FALSE
[13:21:32.864]    - call: NULL
[13:21:32.865] plan(): nbrOfWorkers() = 1
[13:21:32.865] plan(): Setting new future strategy stack:
[13:21:32.866] List of future strategies:
[13:21:32.866] 1. sequential:
[13:21:32.866]    - args: function (..., envir = parent.frame())
[13:21:32.866]    - tweaked: FALSE
[13:21:32.866]    - call: plan(strategy)
[13:21:32.866] plan(): nbrOfWorkers() = 1
[13:21:32.866] SequentialFuture started (and completed)
[13:21:32.866] - Launch lazy future ... done
[13:21:32.866] run() for ‘SequentialFuture’ ... done
[13:21:32.867] Created future:
[13:21:32.867] SequentialFuture:
[13:21:32.867] Label: ‘future_vapply-1’
[13:21:32.867] Expression:
[13:21:32.867] {
[13:21:32.867]     do.call(function(...) {
[13:21:32.867]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:32.867]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:32.867]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:32.867]             on.exit(options(oopts), add = TRUE)
[13:21:32.867]         }
[13:21:32.867]         {
[13:21:32.867]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:32.867]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:32.867]                 ...future.FUN(...future.X_jj, ...)
[13:21:32.867]             })
[13:21:32.867]         }
[13:21:32.867]     }, args = future.call.arguments)
[13:21:32.867] }
[13:21:32.867] Lazy evaluation: FALSE
[13:21:32.867] Asynchronous evaluation: FALSE
[13:21:32.867] Local evaluation: TRUE
[13:21:32.867] Environment: R_GlobalEnv
[13:21:32.867] Capture standard output: TRUE
[13:21:32.867] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:32.867] Globals: 11 objects totaling 103.62 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:32.867] Packages: 1 packages (‘future.apply’)
[13:21:32.867] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:32.867] Resolved: TRUE
[13:21:32.867] Value: 7.42 KiB of class ‘list’
[13:21:32.867] Early signaling: FALSE
[13:21:32.867] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:32.867] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:32.868] Chunk #1 of 1 ... DONE
[13:21:32.868] Launching 1 futures (chunks) ... DONE
[13:21:32.868] Resolving 1 futures (chunks) ...
[13:21:32.868] resolve() on list ...
[13:21:32.868]  recursive: 0
[13:21:32.868]  length: 1
[13:21:32.868] 
[13:21:32.869] resolved() for ‘SequentialFuture’ ...
[13:21:32.869] - state: ‘finished’
[13:21:32.869] - run: TRUE
[13:21:32.869] - result: ‘FutureResult’
[13:21:32.869] resolved() for ‘SequentialFuture’ ... done
[13:21:32.869] Future #1
[13:21:32.869] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:21:32.869] - nx: 1
[13:21:32.869] - relay: TRUE
[13:21:32.869] - stdout: TRUE
[13:21:32.870] - signal: TRUE
[13:21:32.870] - resignal: FALSE
[13:21:32.870] - force: TRUE
[13:21:32.870] - relayed: [n=1] FALSE
[13:21:32.870] - queued futures: [n=1] FALSE
[13:21:32.870]  - until=1
[13:21:32.870]  - relaying element #1
[13:21:32.870] - relayed: [n=1] TRUE
[13:21:32.870] - queued futures: [n=1] TRUE
[13:21:32.870] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:21:32.871]  length: 0 (resolved future 1)
[13:21:32.871] Relaying remaining futures
[13:21:32.871] signalConditionsASAP(NULL, pos=0) ...
[13:21:32.871] - nx: 1
[13:21:32.871] - relay: TRUE
[13:21:32.871] - stdout: TRUE
[13:21:32.871] - signal: TRUE
[13:21:32.871] - resignal: FALSE
[13:21:32.871] - force: TRUE
[13:21:32.871] - relayed: [n=1] TRUE
[13:21:32.871] - queued futures: [n=1] TRUE
 - flush all
[13:21:32.872] - relayed: [n=1] TRUE
[13:21:32.872] - queued futures: [n=1] TRUE
[13:21:32.872] signalConditionsASAP(NULL, pos=0) ... done
[13:21:32.872] resolve() on list ... DONE
[13:21:32.872]  - Number of value chunks collected: 1
[13:21:32.872] Resolving 1 futures (chunks) ... DONE
[13:21:32.872] Reducing values from 1 chunks ...
[13:21:32.872]  - Number of values collected after concatenation: 10
[13:21:32.872]  - Number of values expected: 10
[13:21:32.873] Reducing values from 1 chunks ... DONE
[13:21:32.873] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[13:21:32.877] future_lapply() ...
[13:21:32.879] Number of chunks: 1
[13:21:32.879] getGlobalsAndPackagesXApply() ...
[13:21:32.879]  - future.globals: TRUE
[13:21:32.879] getGlobalsAndPackages() ...
[13:21:32.879] Searching for globals...
[13:21:32.885] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[13:21:32.885] Searching for globals ... DONE
[13:21:32.885] Resolving globals: FALSE
[13:21:32.886] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[13:21:32.887] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:32.887] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:32.887] - packages: [2] ‘stats’, ‘future.apply’
[13:21:32.887] getGlobalsAndPackages() ... DONE
[13:21:32.887]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:32.887]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[13:21:32.887] Finding globals ... DONE
[13:21:32.887]  - use_args: TRUE
[13:21:32.887]  - Getting '...' globals ...
[13:21:32.888] resolve() on list ...
[13:21:32.888]  recursive: 0
[13:21:32.888]  length: 1
[13:21:32.888]  elements: ‘...’
[13:21:32.888]  length: 0 (resolved future 1)
[13:21:32.888] resolve() on list ... DONE
[13:21:32.888]    - '...' content: [n=0] 
[13:21:32.888] List of 1
[13:21:32.888]  $ ...: list()
[13:21:32.888]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:32.888]  - attr(*, "where")=List of 1
[13:21:32.888]   ..$ ...:<environment: 0x563b6f17e9a0> 
[13:21:32.888]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:32.888]  - attr(*, "resolved")= logi TRUE
[13:21:32.888]  - attr(*, "total_size")= num NA
[13:21:32.891]  - Getting '...' globals ... DONE
[13:21:32.891] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:32.891] List of 8
[13:21:32.891]  $ ...future.FUN:function (x, ...)  
[13:21:32.891]  $ x_FUN        :function (x, ...)  
[13:21:32.891]  $ times        : int 5
[13:21:32.891]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:32.891]  $ stop_if_not  :function (...)  
[13:21:32.891]  $ dim          : NULL
[13:21:32.891]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:21:32.891]  $ ...          : list()
[13:21:32.891]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:32.891]  - attr(*, "where")=List of 8
[13:21:32.891]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:32.891]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:32.891]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:32.891]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:32.891]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:32.891]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:32.891]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:32.891]   ..$ ...          :<environment: 0x563b6f17e9a0> 
[13:21:32.891]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:32.891]  - attr(*, "resolved")= logi FALSE
[13:21:32.891]  - attr(*, "total_size")= num 95528
[13:21:32.897] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[13:21:32.897] getGlobalsAndPackagesXApply() ... DONE
[13:21:32.897] Number of futures (= number of chunks): 1
[13:21:32.897] Launching 1 futures (chunks) ...
[13:21:32.897] Chunk #1 of 1 ...
[13:21:32.898]  - Finding globals in 'X' for chunk #1 ...
[13:21:32.898] getGlobalsAndPackages() ...
[13:21:32.898] Searching for globals...
[13:21:32.898] 
[13:21:32.898] Searching for globals ... DONE
[13:21:32.898] - globals: [0] <none>
[13:21:32.898] getGlobalsAndPackages() ... DONE
[13:21:32.898]    + additional globals found: [n=0] 
[13:21:32.899]    + additional namespaces needed: [n=0] 
[13:21:32.899]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:32.899]  - seeds: <none>
[13:21:32.899]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:32.899] getGlobalsAndPackages() ...
[13:21:32.899] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:32.899] Resolving globals: FALSE
[13:21:32.899] Tweak future expression to call with '...' arguments ...
[13:21:32.899] {
[13:21:32.899]     do.call(function(...) {
[13:21:32.899]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:32.899]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:32.899]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:32.899]             on.exit(options(oopts), add = TRUE)
[13:21:32.899]         }
[13:21:32.899]         {
[13:21:32.899]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:32.899]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:32.899]                 ...future.FUN(...future.X_jj, ...)
[13:21:32.899]             })
[13:21:32.899]         }
[13:21:32.899]     }, args = future.call.arguments)
[13:21:32.899] }
[13:21:32.900] Tweak future expression to call with '...' arguments ... DONE
[13:21:32.900] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:32.900] - packages: [2] ‘stats’, ‘future.apply’
[13:21:32.900] getGlobalsAndPackages() ... DONE
[13:21:32.901] run() for ‘Future’ ...
[13:21:32.901] - state: ‘created’
[13:21:32.901] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:32.901] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:32.901] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:32.902]   - Field: ‘label’
[13:21:32.902]   - Field: ‘local’
[13:21:32.902]   - Field: ‘owner’
[13:21:32.902]   - Field: ‘envir’
[13:21:32.902]   - Field: ‘packages’
[13:21:32.902]   - Field: ‘gc’
[13:21:32.902]   - Field: ‘conditions’
[13:21:32.902]   - Field: ‘expr’
[13:21:32.902]   - Field: ‘uuid’
[13:21:32.902]   - Field: ‘seed’
[13:21:32.902]   - Field: ‘version’
[13:21:32.903]   - Field: ‘result’
[13:21:32.903]   - Field: ‘asynchronous’
[13:21:32.903]   - Field: ‘calls’
[13:21:32.903]   - Field: ‘globals’
[13:21:32.903]   - Field: ‘stdout’
[13:21:32.903]   - Field: ‘earlySignal’
[13:21:32.903]   - Field: ‘lazy’
[13:21:32.903]   - Field: ‘state’
[13:21:32.903] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:32.903] - Launch lazy future ...
[13:21:32.904] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[13:21:32.904] Packages needed by future strategies (n = 0): <none>
[13:21:32.904] {
[13:21:32.904]     {
[13:21:32.904]         {
[13:21:32.904]             ...future.startTime <- base::Sys.time()
[13:21:32.904]             {
[13:21:32.904]                 {
[13:21:32.904]                   {
[13:21:32.904]                     {
[13:21:32.904]                       base::local({
[13:21:32.904]                         has_future <- base::requireNamespace("future", 
[13:21:32.904]                           quietly = TRUE)
[13:21:32.904]                         if (has_future) {
[13:21:32.904]                           ns <- base::getNamespace("future")
[13:21:32.904]                           version <- ns[[".package"]][["version"]]
[13:21:32.904]                           if (is.null(version)) 
[13:21:32.904]                             version <- utils::packageVersion("future")
[13:21:32.904]                         }
[13:21:32.904]                         else {
[13:21:32.904]                           version <- NULL
[13:21:32.904]                         }
[13:21:32.904]                         if (!has_future || version < "1.8.0") {
[13:21:32.904]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:32.904]                             "", base::R.version$version.string), 
[13:21:32.904]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:32.904]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:32.904]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:32.904]                               "release", "version")], collapse = " "), 
[13:21:32.904]                             hostname = base::Sys.info()[["nodename"]])
[13:21:32.904]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:32.904]                             info)
[13:21:32.904]                           info <- base::paste(info, collapse = "; ")
[13:21:32.904]                           if (!has_future) {
[13:21:32.904]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:32.904]                               info)
[13:21:32.904]                           }
[13:21:32.904]                           else {
[13:21:32.904]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:32.904]                               info, version)
[13:21:32.904]                           }
[13:21:32.904]                           base::stop(msg)
[13:21:32.904]                         }
[13:21:32.904]                       })
[13:21:32.904]                     }
[13:21:32.904]                     base::local({
[13:21:32.904]                       for (pkg in c("stats", "future.apply")) {
[13:21:32.904]                         base::loadNamespace(pkg)
[13:21:32.904]                         base::library(pkg, character.only = TRUE)
[13:21:32.904]                       }
[13:21:32.904]                     })
[13:21:32.904]                   }
[13:21:32.904]                   options(future.plan = NULL)
[13:21:32.904]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:32.904]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:32.904]                 }
[13:21:32.904]                 ...future.workdir <- getwd()
[13:21:32.904]             }
[13:21:32.904]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:32.904]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:32.904]         }
[13:21:32.904]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:32.904]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:32.904]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:32.904]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:32.904]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:32.904]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:32.904]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:32.904]             base::names(...future.oldOptions))
[13:21:32.904]     }
[13:21:32.904]     if (FALSE) {
[13:21:32.904]     }
[13:21:32.904]     else {
[13:21:32.904]         if (TRUE) {
[13:21:32.904]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:32.904]                 open = "w")
[13:21:32.904]         }
[13:21:32.904]         else {
[13:21:32.904]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:32.904]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:32.904]         }
[13:21:32.904]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:32.904]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:32.904]             base::sink(type = "output", split = FALSE)
[13:21:32.904]             base::close(...future.stdout)
[13:21:32.904]         }, add = TRUE)
[13:21:32.904]     }
[13:21:32.904]     ...future.frame <- base::sys.nframe()
[13:21:32.904]     ...future.conditions <- base::list()
[13:21:32.904]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:32.904]     if (FALSE) {
[13:21:32.904]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:32.904]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:32.904]     }
[13:21:32.904]     ...future.result <- base::tryCatch({
[13:21:32.904]         base::withCallingHandlers({
[13:21:32.904]             ...future.value <- base::withVisible(base::local({
[13:21:32.904]                 do.call(function(...) {
[13:21:32.904]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:32.904]                   if (!identical(...future.globals.maxSize.org, 
[13:21:32.904]                     ...future.globals.maxSize)) {
[13:21:32.904]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:32.904]                     on.exit(options(oopts), add = TRUE)
[13:21:32.904]                   }
[13:21:32.904]                   {
[13:21:32.904]                     lapply(seq_along(...future.elements_ii), 
[13:21:32.904]                       FUN = function(jj) {
[13:21:32.904]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:32.904]                         ...future.FUN(...future.X_jj, ...)
[13:21:32.904]                       })
[13:21:32.904]                   }
[13:21:32.904]                 }, args = future.call.arguments)
[13:21:32.904]             }))
[13:21:32.904]             future::FutureResult(value = ...future.value$value, 
[13:21:32.904]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:32.904]                   ...future.rng), globalenv = if (FALSE) 
[13:21:32.904]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:32.904]                     ...future.globalenv.names))
[13:21:32.904]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:32.904]         }, condition = base::local({
[13:21:32.904]             c <- base::c
[13:21:32.904]             inherits <- base::inherits
[13:21:32.904]             invokeRestart <- base::invokeRestart
[13:21:32.904]             length <- base::length
[13:21:32.904]             list <- base::list
[13:21:32.904]             seq.int <- base::seq.int
[13:21:32.904]             signalCondition <- base::signalCondition
[13:21:32.904]             sys.calls <- base::sys.calls
[13:21:32.904]             `[[` <- base::`[[`
[13:21:32.904]             `+` <- base::`+`
[13:21:32.904]             `<<-` <- base::`<<-`
[13:21:32.904]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:32.904]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:32.904]                   3L)]
[13:21:32.904]             }
[13:21:32.904]             function(cond) {
[13:21:32.904]                 is_error <- inherits(cond, "error")
[13:21:32.904]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:32.904]                   NULL)
[13:21:32.904]                 if (is_error) {
[13:21:32.904]                   sessionInformation <- function() {
[13:21:32.904]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:32.904]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:32.904]                       search = base::search(), system = base::Sys.info())
[13:21:32.904]                   }
[13:21:32.904]                   ...future.conditions[[length(...future.conditions) + 
[13:21:32.904]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:32.904]                     cond$call), session = sessionInformation(), 
[13:21:32.904]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:32.904]                   signalCondition(cond)
[13:21:32.904]                 }
[13:21:32.904]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:32.904]                 "immediateCondition"))) {
[13:21:32.904]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:32.904]                   ...future.conditions[[length(...future.conditions) + 
[13:21:32.904]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:32.904]                   if (TRUE && !signal) {
[13:21:32.904]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:32.904]                     {
[13:21:32.904]                       inherits <- base::inherits
[13:21:32.904]                       invokeRestart <- base::invokeRestart
[13:21:32.904]                       is.null <- base::is.null
[13:21:32.904]                       muffled <- FALSE
[13:21:32.904]                       if (inherits(cond, "message")) {
[13:21:32.904]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:32.904]                         if (muffled) 
[13:21:32.904]                           invokeRestart("muffleMessage")
[13:21:32.904]                       }
[13:21:32.904]                       else if (inherits(cond, "warning")) {
[13:21:32.904]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:32.904]                         if (muffled) 
[13:21:32.904]                           invokeRestart("muffleWarning")
[13:21:32.904]                       }
[13:21:32.904]                       else if (inherits(cond, "condition")) {
[13:21:32.904]                         if (!is.null(pattern)) {
[13:21:32.904]                           computeRestarts <- base::computeRestarts
[13:21:32.904]                           grepl <- base::grepl
[13:21:32.904]                           restarts <- computeRestarts(cond)
[13:21:32.904]                           for (restart in restarts) {
[13:21:32.904]                             name <- restart$name
[13:21:32.904]                             if (is.null(name)) 
[13:21:32.904]                               next
[13:21:32.904]                             if (!grepl(pattern, name)) 
[13:21:32.904]                               next
[13:21:32.904]                             invokeRestart(restart)
[13:21:32.904]                             muffled <- TRUE
[13:21:32.904]                             break
[13:21:32.904]                           }
[13:21:32.904]                         }
[13:21:32.904]                       }
[13:21:32.904]                       invisible(muffled)
[13:21:32.904]                     }
[13:21:32.904]                     muffleCondition(cond, pattern = "^muffle")
[13:21:32.904]                   }
[13:21:32.904]                 }
[13:21:32.904]                 else {
[13:21:32.904]                   if (TRUE) {
[13:21:32.904]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:32.904]                     {
[13:21:32.904]                       inherits <- base::inherits
[13:21:32.904]                       invokeRestart <- base::invokeRestart
[13:21:32.904]                       is.null <- base::is.null
[13:21:32.904]                       muffled <- FALSE
[13:21:32.904]                       if (inherits(cond, "message")) {
[13:21:32.904]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:32.904]                         if (muffled) 
[13:21:32.904]                           invokeRestart("muffleMessage")
[13:21:32.904]                       }
[13:21:32.904]                       else if (inherits(cond, "warning")) {
[13:21:32.904]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:32.904]                         if (muffled) 
[13:21:32.904]                           invokeRestart("muffleWarning")
[13:21:32.904]                       }
[13:21:32.904]                       else if (inherits(cond, "condition")) {
[13:21:32.904]                         if (!is.null(pattern)) {
[13:21:32.904]                           computeRestarts <- base::computeRestarts
[13:21:32.904]                           grepl <- base::grepl
[13:21:32.904]                           restarts <- computeRestarts(cond)
[13:21:32.904]                           for (restart in restarts) {
[13:21:32.904]                             name <- restart$name
[13:21:32.904]                             if (is.null(name)) 
[13:21:32.904]                               next
[13:21:32.904]                             if (!grepl(pattern, name)) 
[13:21:32.904]                               next
[13:21:32.904]                             invokeRestart(restart)
[13:21:32.904]                             muffled <- TRUE
[13:21:32.904]                             break
[13:21:32.904]                           }
[13:21:32.904]                         }
[13:21:32.904]                       }
[13:21:32.904]                       invisible(muffled)
[13:21:32.904]                     }
[13:21:32.904]                     muffleCondition(cond, pattern = "^muffle")
[13:21:32.904]                   }
[13:21:32.904]                 }
[13:21:32.904]             }
[13:21:32.904]         }))
[13:21:32.904]     }, error = function(ex) {
[13:21:32.904]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:32.904]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:32.904]                 ...future.rng), started = ...future.startTime, 
[13:21:32.904]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:32.904]             version = "1.8"), class = "FutureResult")
[13:21:32.904]     }, finally = {
[13:21:32.904]         if (!identical(...future.workdir, getwd())) 
[13:21:32.904]             setwd(...future.workdir)
[13:21:32.904]         {
[13:21:32.904]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:32.904]                 ...future.oldOptions$nwarnings <- NULL
[13:21:32.904]             }
[13:21:32.904]             base::options(...future.oldOptions)
[13:21:32.904]             if (.Platform$OS.type == "windows") {
[13:21:32.904]                 old_names <- names(...future.oldEnvVars)
[13:21:32.904]                 envs <- base::Sys.getenv()
[13:21:32.904]                 names <- names(envs)
[13:21:32.904]                 common <- intersect(names, old_names)
[13:21:32.904]                 added <- setdiff(names, old_names)
[13:21:32.904]                 removed <- setdiff(old_names, names)
[13:21:32.904]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:32.904]                   envs[common]]
[13:21:32.904]                 NAMES <- toupper(changed)
[13:21:32.904]                 args <- list()
[13:21:32.904]                 for (kk in seq_along(NAMES)) {
[13:21:32.904]                   name <- changed[[kk]]
[13:21:32.904]                   NAME <- NAMES[[kk]]
[13:21:32.904]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:32.904]                     next
[13:21:32.904]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:32.904]                 }
[13:21:32.904]                 NAMES <- toupper(added)
[13:21:32.904]                 for (kk in seq_along(NAMES)) {
[13:21:32.904]                   name <- added[[kk]]
[13:21:32.904]                   NAME <- NAMES[[kk]]
[13:21:32.904]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:32.904]                     next
[13:21:32.904]                   args[[name]] <- ""
[13:21:32.904]                 }
[13:21:32.904]                 NAMES <- toupper(removed)
[13:21:32.904]                 for (kk in seq_along(NAMES)) {
[13:21:32.904]                   name <- removed[[kk]]
[13:21:32.904]                   NAME <- NAMES[[kk]]
[13:21:32.904]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:32.904]                     next
[13:21:32.904]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:32.904]                 }
[13:21:32.904]                 if (length(args) > 0) 
[13:21:32.904]                   base::do.call(base::Sys.setenv, args = args)
[13:21:32.904]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:32.904]             }
[13:21:32.904]             else {
[13:21:32.904]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:32.904]             }
[13:21:32.904]             {
[13:21:32.904]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:32.904]                   0L) {
[13:21:32.904]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:32.904]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:32.904]                   base::options(opts)
[13:21:32.904]                 }
[13:21:32.904]                 {
[13:21:32.904]                   {
[13:21:32.904]                     NULL
[13:21:32.904]                     RNGkind("Mersenne-Twister")
[13:21:32.904]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:32.904]                       inherits = FALSE)
[13:21:32.904]                   }
[13:21:32.904]                   options(future.plan = NULL)
[13:21:32.904]                   if (is.na(NA_character_)) 
[13:21:32.904]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:32.904]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:32.904]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:32.904]                   {
[13:21:32.904]                     future <- SequentialFuture(..., envir = envir)
[13:21:32.904]                     if (!future$lazy) 
[13:21:32.904]                       future <- run(future)
[13:21:32.904]                     invisible(future)
[13:21:32.904]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:32.904]                 }
[13:21:32.904]             }
[13:21:32.904]         }
[13:21:32.904]     })
[13:21:32.904]     if (TRUE) {
[13:21:32.904]         base::sink(type = "output", split = FALSE)
[13:21:32.904]         if (TRUE) {
[13:21:32.904]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:32.904]         }
[13:21:32.904]         else {
[13:21:32.904]             ...future.result["stdout"] <- base::list(NULL)
[13:21:32.904]         }
[13:21:32.904]         base::close(...future.stdout)
[13:21:32.904]         ...future.stdout <- NULL
[13:21:32.904]     }
[13:21:32.904]     ...future.result$conditions <- ...future.conditions
[13:21:32.904]     ...future.result$finished <- base::Sys.time()
[13:21:32.904]     ...future.result
[13:21:32.904] }
[13:21:32.906] assign_globals() ...
[13:21:32.906] List of 11
[13:21:32.906]  $ ...future.FUN            :function (x, ...)  
[13:21:32.906]  $ x_FUN                    :function (x, ...)  
[13:21:32.906]  $ times                    : int 5
[13:21:32.906]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:32.906]  $ stop_if_not              :function (...)  
[13:21:32.906]  $ dim                      : NULL
[13:21:32.906]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:21:32.906]  $ future.call.arguments    : list()
[13:21:32.906]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:32.906]  $ ...future.elements_ii    :List of 3
[13:21:32.906]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[13:21:32.906]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[13:21:32.906]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[13:21:32.906]  $ ...future.seeds_ii       : NULL
[13:21:32.906]  $ ...future.globals.maxSize: NULL
[13:21:32.906]  - attr(*, "where")=List of 11
[13:21:32.906]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:32.906]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:32.906]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:32.906]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:32.906]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:32.906]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:32.906]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:32.906]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:32.906]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:32.906]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:32.906]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:32.906]  - attr(*, "resolved")= logi FALSE
[13:21:32.906]  - attr(*, "total_size")= num 95528
[13:21:32.906]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:32.906]  - attr(*, "already-done")= logi TRUE
[13:21:32.917] - copied ‘...future.FUN’ to environment
[13:21:32.917] - copied ‘x_FUN’ to environment
[13:21:32.917] - copied ‘times’ to environment
[13:21:32.917] - copied ‘stopf’ to environment
[13:21:32.917] - copied ‘stop_if_not’ to environment
[13:21:32.917] - copied ‘dim’ to environment
[13:21:32.917] - copied ‘valid_types’ to environment
[13:21:32.917] - copied ‘future.call.arguments’ to environment
[13:21:32.917] - copied ‘...future.elements_ii’ to environment
[13:21:32.918] - copied ‘...future.seeds_ii’ to environment
[13:21:32.918] - copied ‘...future.globals.maxSize’ to environment
[13:21:32.918] assign_globals() ... done
[13:21:32.918] plan(): Setting new future strategy stack:
[13:21:32.918] List of future strategies:
[13:21:32.918] 1. sequential:
[13:21:32.918]    - args: function (..., envir = parent.frame())
[13:21:32.918]    - tweaked: FALSE
[13:21:32.918]    - call: NULL
[13:21:32.919] plan(): nbrOfWorkers() = 1
[13:21:32.920] plan(): Setting new future strategy stack:
[13:21:32.920] List of future strategies:
[13:21:32.920] 1. sequential:
[13:21:32.920]    - args: function (..., envir = parent.frame())
[13:21:32.920]    - tweaked: FALSE
[13:21:32.920]    - call: plan(strategy)
[13:21:32.921] plan(): nbrOfWorkers() = 1
[13:21:32.921] SequentialFuture started (and completed)
[13:21:32.921] - Launch lazy future ... done
[13:21:32.921] run() for ‘SequentialFuture’ ... done
[13:21:32.921] Created future:
[13:21:32.921] SequentialFuture:
[13:21:32.921] Label: ‘future_vapply-1’
[13:21:32.921] Expression:
[13:21:32.921] {
[13:21:32.921]     do.call(function(...) {
[13:21:32.921]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:32.921]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:32.921]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:32.921]             on.exit(options(oopts), add = TRUE)
[13:21:32.921]         }
[13:21:32.921]         {
[13:21:32.921]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:32.921]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:32.921]                 ...future.FUN(...future.X_jj, ...)
[13:21:32.921]             })
[13:21:32.921]         }
[13:21:32.921]     }, args = future.call.arguments)
[13:21:32.921] }
[13:21:32.921] Lazy evaluation: FALSE
[13:21:32.921] Asynchronous evaluation: FALSE
[13:21:32.921] Local evaluation: TRUE
[13:21:32.921] Environment: R_GlobalEnv
[13:21:32.921] Capture standard output: TRUE
[13:21:32.921] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:32.921] Globals: 11 objects totaling 93.55 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:32.921] Packages: 2 packages (‘stats’, ‘future.apply’)
[13:21:32.921] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:32.921] Resolved: TRUE
[13:21:32.921] Value: 1.71 KiB of class ‘list’
[13:21:32.921] Early signaling: FALSE
[13:21:32.921] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:32.921] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:32.922] Chunk #1 of 1 ... DONE
[13:21:32.923] Launching 1 futures (chunks) ... DONE
[13:21:32.923] Resolving 1 futures (chunks) ...
[13:21:32.923] resolve() on list ...
[13:21:32.923]  recursive: 0
[13:21:32.923]  length: 1
[13:21:32.923] 
[13:21:32.923] resolved() for ‘SequentialFuture’ ...
[13:21:32.923] - state: ‘finished’
[13:21:32.923] - run: TRUE
[13:21:32.923] - result: ‘FutureResult’
[13:21:32.924] resolved() for ‘SequentialFuture’ ... done
[13:21:32.924] Future #1
[13:21:32.924] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:21:32.924] - nx: 1
[13:21:32.924] - relay: TRUE
[13:21:32.924] - stdout: TRUE
[13:21:32.924] - signal: TRUE
[13:21:32.924] - resignal: FALSE
[13:21:32.924] - force: TRUE
[13:21:32.924] - relayed: [n=1] FALSE
[13:21:32.925] - queued futures: [n=1] FALSE
[13:21:32.925]  - until=1
[13:21:32.925]  - relaying element #1
[13:21:32.925] - relayed: [n=1] TRUE
[13:21:32.925] - queued futures: [n=1] TRUE
[13:21:32.925] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:21:32.925]  length: 0 (resolved future 1)
[13:21:32.925] Relaying remaining futures
[13:21:32.925] signalConditionsASAP(NULL, pos=0) ...
[13:21:32.925] - nx: 1
[13:21:32.926] - relay: TRUE
[13:21:32.926] - stdout: TRUE
[13:21:32.926] - signal: TRUE
[13:21:32.926] - resignal: FALSE
[13:21:32.926] - force: TRUE
[13:21:32.926] - relayed: [n=1] TRUE
[13:21:32.926] - queued futures: [n=1] TRUE
 - flush all
[13:21:32.926] - relayed: [n=1] TRUE
[13:21:32.926] - queued futures: [n=1] TRUE
[13:21:32.926] signalConditionsASAP(NULL, pos=0) ... done
[13:21:32.926] resolve() on list ... DONE
[13:21:32.927]  - Number of value chunks collected: 1
[13:21:32.927] Resolving 1 futures (chunks) ... DONE
[13:21:32.927] Reducing values from 1 chunks ...
[13:21:32.927]  - Number of values collected after concatenation: 3
[13:21:32.927]  - Number of values expected: 3
[13:21:32.927] Reducing values from 1 chunks ... DONE
[13:21:32.927] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[13:21:32.929] future_lapply() ...
[13:21:32.935] Number of chunks: 1
[13:21:32.935] getGlobalsAndPackagesXApply() ...
[13:21:32.935]  - future.globals: TRUE
[13:21:32.935] getGlobalsAndPackages() ...
[13:21:32.936] Searching for globals...
[13:21:32.940] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[13:21:32.940] Searching for globals ... DONE
[13:21:32.941] Resolving globals: FALSE
[13:21:32.941] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[13:21:32.942] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[13:21:32.942] - globals: [1] ‘FUN’
[13:21:32.942] - packages: [1] ‘stats’
[13:21:32.942] getGlobalsAndPackages() ... DONE
[13:21:32.942]  - globals found/used: [n=1] ‘FUN’
[13:21:32.942]  - needed namespaces: [n=1] ‘stats’
[13:21:32.942] Finding globals ... DONE
[13:21:32.943]  - use_args: TRUE
[13:21:32.943]  - Getting '...' globals ...
[13:21:32.943] resolve() on list ...
[13:21:32.943]  recursive: 0
[13:21:32.943]  length: 1
[13:21:32.943]  elements: ‘...’
[13:21:32.943]  length: 0 (resolved future 1)
[13:21:32.943] resolve() on list ... DONE
[13:21:32.944]    - '...' content: [n=0] 
[13:21:32.944] List of 1
[13:21:32.944]  $ ...: list()
[13:21:32.944]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:32.944]  - attr(*, "where")=List of 1
[13:21:32.944]   ..$ ...:<environment: 0x563b6f41f718> 
[13:21:32.944]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:32.944]  - attr(*, "resolved")= logi TRUE
[13:21:32.944]  - attr(*, "total_size")= num NA
[13:21:32.946]  - Getting '...' globals ... DONE
[13:21:32.946] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:21:32.947] List of 2
[13:21:32.947]  $ ...future.FUN:function (x, na.rm = TRUE)  
[13:21:32.947]  $ ...          : list()
[13:21:32.947]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:32.947]  - attr(*, "where")=List of 2
[13:21:32.947]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:32.947]   ..$ ...          :<environment: 0x563b6f41f718> 
[13:21:32.947]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:32.947]  - attr(*, "resolved")= logi FALSE
[13:21:32.947]  - attr(*, "total_size")= num 46960
[13:21:32.949] Packages to be attached in all futures: [n=1] ‘stats’
[13:21:32.949] getGlobalsAndPackagesXApply() ... DONE
[13:21:32.950] Number of futures (= number of chunks): 1
[13:21:32.950] Launching 1 futures (chunks) ...
[13:21:32.950] Chunk #1 of 1 ...
[13:21:32.950]  - Finding globals in 'X' for chunk #1 ...
[13:21:32.950] getGlobalsAndPackages() ...
[13:21:32.950] Searching for globals...
[13:21:32.950] 
[13:21:32.950] Searching for globals ... DONE
[13:21:32.951] - globals: [0] <none>
[13:21:32.951] getGlobalsAndPackages() ... DONE
[13:21:32.951]    + additional globals found: [n=0] 
[13:21:32.951]    + additional namespaces needed: [n=0] 
[13:21:32.951]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:32.951]  - seeds: <none>
[13:21:32.951]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:32.951] getGlobalsAndPackages() ...
[13:21:32.951] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:32.951] Resolving globals: FALSE
[13:21:32.952] Tweak future expression to call with '...' arguments ...
[13:21:32.952] {
[13:21:32.952]     do.call(function(...) {
[13:21:32.952]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:32.952]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:32.952]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:32.952]             on.exit(options(oopts), add = TRUE)
[13:21:32.952]         }
[13:21:32.952]         {
[13:21:32.952]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:32.952]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:32.952]                 ...future.FUN(...future.X_jj, ...)
[13:21:32.952]             })
[13:21:32.952]         }
[13:21:32.952]     }, args = future.call.arguments)
[13:21:32.952] }
[13:21:32.952] Tweak future expression to call with '...' arguments ... DONE
[13:21:32.954] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:32.954] - packages: [1] ‘stats’
[13:21:32.954] getGlobalsAndPackages() ... DONE
[13:21:32.955] run() for ‘Future’ ...
[13:21:32.955] - state: ‘created’
[13:21:32.955] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:32.955] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:32.955] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:32.955]   - Field: ‘label’
[13:21:32.956]   - Field: ‘local’
[13:21:32.956]   - Field: ‘owner’
[13:21:32.956]   - Field: ‘envir’
[13:21:32.956]   - Field: ‘packages’
[13:21:32.956]   - Field: ‘gc’
[13:21:32.956]   - Field: ‘conditions’
[13:21:32.956]   - Field: ‘expr’
[13:21:32.956]   - Field: ‘uuid’
[13:21:32.956]   - Field: ‘seed’
[13:21:32.957]   - Field: ‘version’
[13:21:32.957]   - Field: ‘result’
[13:21:32.957]   - Field: ‘asynchronous’
[13:21:32.957]   - Field: ‘calls’
[13:21:32.957]   - Field: ‘globals’
[13:21:32.957]   - Field: ‘stdout’
[13:21:32.957]   - Field: ‘earlySignal’
[13:21:32.957]   - Field: ‘lazy’
[13:21:32.957]   - Field: ‘state’
[13:21:32.957] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:32.958] - Launch lazy future ...
[13:21:32.958] Packages needed by the future expression (n = 1): ‘stats’
[13:21:32.958] Packages needed by future strategies (n = 0): <none>
[13:21:32.958] {
[13:21:32.958]     {
[13:21:32.958]         {
[13:21:32.958]             ...future.startTime <- base::Sys.time()
[13:21:32.958]             {
[13:21:32.958]                 {
[13:21:32.958]                   {
[13:21:32.958]                     {
[13:21:32.958]                       base::local({
[13:21:32.958]                         has_future <- base::requireNamespace("future", 
[13:21:32.958]                           quietly = TRUE)
[13:21:32.958]                         if (has_future) {
[13:21:32.958]                           ns <- base::getNamespace("future")
[13:21:32.958]                           version <- ns[[".package"]][["version"]]
[13:21:32.958]                           if (is.null(version)) 
[13:21:32.958]                             version <- utils::packageVersion("future")
[13:21:32.958]                         }
[13:21:32.958]                         else {
[13:21:32.958]                           version <- NULL
[13:21:32.958]                         }
[13:21:32.958]                         if (!has_future || version < "1.8.0") {
[13:21:32.958]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:32.958]                             "", base::R.version$version.string), 
[13:21:32.958]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:32.958]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:32.958]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:32.958]                               "release", "version")], collapse = " "), 
[13:21:32.958]                             hostname = base::Sys.info()[["nodename"]])
[13:21:32.958]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:32.958]                             info)
[13:21:32.958]                           info <- base::paste(info, collapse = "; ")
[13:21:32.958]                           if (!has_future) {
[13:21:32.958]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:32.958]                               info)
[13:21:32.958]                           }
[13:21:32.958]                           else {
[13:21:32.958]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:32.958]                               info, version)
[13:21:32.958]                           }
[13:21:32.958]                           base::stop(msg)
[13:21:32.958]                         }
[13:21:32.958]                       })
[13:21:32.958]                     }
[13:21:32.958]                     base::local({
[13:21:32.958]                       for (pkg in "stats") {
[13:21:32.958]                         base::loadNamespace(pkg)
[13:21:32.958]                         base::library(pkg, character.only = TRUE)
[13:21:32.958]                       }
[13:21:32.958]                     })
[13:21:32.958]                   }
[13:21:32.958]                   options(future.plan = NULL)
[13:21:32.958]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:32.958]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:32.958]                 }
[13:21:32.958]                 ...future.workdir <- getwd()
[13:21:32.958]             }
[13:21:32.958]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:32.958]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:32.958]         }
[13:21:32.958]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:32.958]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:32.958]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:32.958]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:32.958]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:32.958]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:32.958]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:32.958]             base::names(...future.oldOptions))
[13:21:32.958]     }
[13:21:32.958]     if (FALSE) {
[13:21:32.958]     }
[13:21:32.958]     else {
[13:21:32.958]         if (TRUE) {
[13:21:32.958]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:32.958]                 open = "w")
[13:21:32.958]         }
[13:21:32.958]         else {
[13:21:32.958]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:32.958]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:32.958]         }
[13:21:32.958]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:32.958]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:32.958]             base::sink(type = "output", split = FALSE)
[13:21:32.958]             base::close(...future.stdout)
[13:21:32.958]         }, add = TRUE)
[13:21:32.958]     }
[13:21:32.958]     ...future.frame <- base::sys.nframe()
[13:21:32.958]     ...future.conditions <- base::list()
[13:21:32.958]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:32.958]     if (FALSE) {
[13:21:32.958]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:32.958]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:32.958]     }
[13:21:32.958]     ...future.result <- base::tryCatch({
[13:21:32.958]         base::withCallingHandlers({
[13:21:32.958]             ...future.value <- base::withVisible(base::local({
[13:21:32.958]                 do.call(function(...) {
[13:21:32.958]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:32.958]                   if (!identical(...future.globals.maxSize.org, 
[13:21:32.958]                     ...future.globals.maxSize)) {
[13:21:32.958]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:32.958]                     on.exit(options(oopts), add = TRUE)
[13:21:32.958]                   }
[13:21:32.958]                   {
[13:21:32.958]                     lapply(seq_along(...future.elements_ii), 
[13:21:32.958]                       FUN = function(jj) {
[13:21:32.958]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:32.958]                         ...future.FUN(...future.X_jj, ...)
[13:21:32.958]                       })
[13:21:32.958]                   }
[13:21:32.958]                 }, args = future.call.arguments)
[13:21:32.958]             }))
[13:21:32.958]             future::FutureResult(value = ...future.value$value, 
[13:21:32.958]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:32.958]                   ...future.rng), globalenv = if (FALSE) 
[13:21:32.958]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:32.958]                     ...future.globalenv.names))
[13:21:32.958]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:32.958]         }, condition = base::local({
[13:21:32.958]             c <- base::c
[13:21:32.958]             inherits <- base::inherits
[13:21:32.958]             invokeRestart <- base::invokeRestart
[13:21:32.958]             length <- base::length
[13:21:32.958]             list <- base::list
[13:21:32.958]             seq.int <- base::seq.int
[13:21:32.958]             signalCondition <- base::signalCondition
[13:21:32.958]             sys.calls <- base::sys.calls
[13:21:32.958]             `[[` <- base::`[[`
[13:21:32.958]             `+` <- base::`+`
[13:21:32.958]             `<<-` <- base::`<<-`
[13:21:32.958]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:32.958]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:32.958]                   3L)]
[13:21:32.958]             }
[13:21:32.958]             function(cond) {
[13:21:32.958]                 is_error <- inherits(cond, "error")
[13:21:32.958]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:32.958]                   NULL)
[13:21:32.958]                 if (is_error) {
[13:21:32.958]                   sessionInformation <- function() {
[13:21:32.958]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:32.958]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:32.958]                       search = base::search(), system = base::Sys.info())
[13:21:32.958]                   }
[13:21:32.958]                   ...future.conditions[[length(...future.conditions) + 
[13:21:32.958]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:32.958]                     cond$call), session = sessionInformation(), 
[13:21:32.958]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:32.958]                   signalCondition(cond)
[13:21:32.958]                 }
[13:21:32.958]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:32.958]                 "immediateCondition"))) {
[13:21:32.958]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:32.958]                   ...future.conditions[[length(...future.conditions) + 
[13:21:32.958]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:32.958]                   if (TRUE && !signal) {
[13:21:32.958]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:32.958]                     {
[13:21:32.958]                       inherits <- base::inherits
[13:21:32.958]                       invokeRestart <- base::invokeRestart
[13:21:32.958]                       is.null <- base::is.null
[13:21:32.958]                       muffled <- FALSE
[13:21:32.958]                       if (inherits(cond, "message")) {
[13:21:32.958]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:32.958]                         if (muffled) 
[13:21:32.958]                           invokeRestart("muffleMessage")
[13:21:32.958]                       }
[13:21:32.958]                       else if (inherits(cond, "warning")) {
[13:21:32.958]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:32.958]                         if (muffled) 
[13:21:32.958]                           invokeRestart("muffleWarning")
[13:21:32.958]                       }
[13:21:32.958]                       else if (inherits(cond, "condition")) {
[13:21:32.958]                         if (!is.null(pattern)) {
[13:21:32.958]                           computeRestarts <- base::computeRestarts
[13:21:32.958]                           grepl <- base::grepl
[13:21:32.958]                           restarts <- computeRestarts(cond)
[13:21:32.958]                           for (restart in restarts) {
[13:21:32.958]                             name <- restart$name
[13:21:32.958]                             if (is.null(name)) 
[13:21:32.958]                               next
[13:21:32.958]                             if (!grepl(pattern, name)) 
[13:21:32.958]                               next
[13:21:32.958]                             invokeRestart(restart)
[13:21:32.958]                             muffled <- TRUE
[13:21:32.958]                             break
[13:21:32.958]                           }
[13:21:32.958]                         }
[13:21:32.958]                       }
[13:21:32.958]                       invisible(muffled)
[13:21:32.958]                     }
[13:21:32.958]                     muffleCondition(cond, pattern = "^muffle")
[13:21:32.958]                   }
[13:21:32.958]                 }
[13:21:32.958]                 else {
[13:21:32.958]                   if (TRUE) {
[13:21:32.958]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:32.958]                     {
[13:21:32.958]                       inherits <- base::inherits
[13:21:32.958]                       invokeRestart <- base::invokeRestart
[13:21:32.958]                       is.null <- base::is.null
[13:21:32.958]                       muffled <- FALSE
[13:21:32.958]                       if (inherits(cond, "message")) {
[13:21:32.958]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:32.958]                         if (muffled) 
[13:21:32.958]                           invokeRestart("muffleMessage")
[13:21:32.958]                       }
[13:21:32.958]                       else if (inherits(cond, "warning")) {
[13:21:32.958]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:32.958]                         if (muffled) 
[13:21:32.958]                           invokeRestart("muffleWarning")
[13:21:32.958]                       }
[13:21:32.958]                       else if (inherits(cond, "condition")) {
[13:21:32.958]                         if (!is.null(pattern)) {
[13:21:32.958]                           computeRestarts <- base::computeRestarts
[13:21:32.958]                           grepl <- base::grepl
[13:21:32.958]                           restarts <- computeRestarts(cond)
[13:21:32.958]                           for (restart in restarts) {
[13:21:32.958]                             name <- restart$name
[13:21:32.958]                             if (is.null(name)) 
[13:21:32.958]                               next
[13:21:32.958]                             if (!grepl(pattern, name)) 
[13:21:32.958]                               next
[13:21:32.958]                             invokeRestart(restart)
[13:21:32.958]                             muffled <- TRUE
[13:21:32.958]                             break
[13:21:32.958]                           }
[13:21:32.958]                         }
[13:21:32.958]                       }
[13:21:32.958]                       invisible(muffled)
[13:21:32.958]                     }
[13:21:32.958]                     muffleCondition(cond, pattern = "^muffle")
[13:21:32.958]                   }
[13:21:32.958]                 }
[13:21:32.958]             }
[13:21:32.958]         }))
[13:21:32.958]     }, error = function(ex) {
[13:21:32.958]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:32.958]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:32.958]                 ...future.rng), started = ...future.startTime, 
[13:21:32.958]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:32.958]             version = "1.8"), class = "FutureResult")
[13:21:32.958]     }, finally = {
[13:21:32.958]         if (!identical(...future.workdir, getwd())) 
[13:21:32.958]             setwd(...future.workdir)
[13:21:32.958]         {
[13:21:32.958]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:32.958]                 ...future.oldOptions$nwarnings <- NULL
[13:21:32.958]             }
[13:21:32.958]             base::options(...future.oldOptions)
[13:21:32.958]             if (.Platform$OS.type == "windows") {
[13:21:32.958]                 old_names <- names(...future.oldEnvVars)
[13:21:32.958]                 envs <- base::Sys.getenv()
[13:21:32.958]                 names <- names(envs)
[13:21:32.958]                 common <- intersect(names, old_names)
[13:21:32.958]                 added <- setdiff(names, old_names)
[13:21:32.958]                 removed <- setdiff(old_names, names)
[13:21:32.958]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:32.958]                   envs[common]]
[13:21:32.958]                 NAMES <- toupper(changed)
[13:21:32.958]                 args <- list()
[13:21:32.958]                 for (kk in seq_along(NAMES)) {
[13:21:32.958]                   name <- changed[[kk]]
[13:21:32.958]                   NAME <- NAMES[[kk]]
[13:21:32.958]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:32.958]                     next
[13:21:32.958]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:32.958]                 }
[13:21:32.958]                 NAMES <- toupper(added)
[13:21:32.958]                 for (kk in seq_along(NAMES)) {
[13:21:32.958]                   name <- added[[kk]]
[13:21:32.958]                   NAME <- NAMES[[kk]]
[13:21:32.958]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:32.958]                     next
[13:21:32.958]                   args[[name]] <- ""
[13:21:32.958]                 }
[13:21:32.958]                 NAMES <- toupper(removed)
[13:21:32.958]                 for (kk in seq_along(NAMES)) {
[13:21:32.958]                   name <- removed[[kk]]
[13:21:32.958]                   NAME <- NAMES[[kk]]
[13:21:32.958]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:32.958]                     next
[13:21:32.958]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:32.958]                 }
[13:21:32.958]                 if (length(args) > 0) 
[13:21:32.958]                   base::do.call(base::Sys.setenv, args = args)
[13:21:32.958]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:32.958]             }
[13:21:32.958]             else {
[13:21:32.958]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:32.958]             }
[13:21:32.958]             {
[13:21:32.958]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:32.958]                   0L) {
[13:21:32.958]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:32.958]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:32.958]                   base::options(opts)
[13:21:32.958]                 }
[13:21:32.958]                 {
[13:21:32.958]                   {
[13:21:32.958]                     NULL
[13:21:32.958]                     RNGkind("Mersenne-Twister")
[13:21:32.958]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:32.958]                       inherits = FALSE)
[13:21:32.958]                   }
[13:21:32.958]                   options(future.plan = NULL)
[13:21:32.958]                   if (is.na(NA_character_)) 
[13:21:32.958]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:32.958]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:32.958]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:32.958]                   {
[13:21:32.958]                     future <- SequentialFuture(..., envir = envir)
[13:21:32.958]                     if (!future$lazy) 
[13:21:32.958]                       future <- run(future)
[13:21:32.958]                     invisible(future)
[13:21:32.958]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:32.958]                 }
[13:21:32.958]             }
[13:21:32.958]         }
[13:21:32.958]     })
[13:21:32.958]     if (TRUE) {
[13:21:32.958]         base::sink(type = "output", split = FALSE)
[13:21:32.958]         if (TRUE) {
[13:21:32.958]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:32.958]         }
[13:21:32.958]         else {
[13:21:32.958]             ...future.result["stdout"] <- base::list(NULL)
[13:21:32.958]         }
[13:21:32.958]         base::close(...future.stdout)
[13:21:32.958]         ...future.stdout <- NULL
[13:21:32.958]     }
[13:21:32.958]     ...future.result$conditions <- ...future.conditions
[13:21:32.958]     ...future.result$finished <- base::Sys.time()
[13:21:32.958]     ...future.result
[13:21:32.958] }
[13:21:32.960] assign_globals() ...
[13:21:32.960] List of 5
[13:21:32.960]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[13:21:32.960]  $ future.call.arguments    : list()
[13:21:32.960]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:32.960]  $ ...future.elements_ii    :List of 7
[13:21:32.960]   ..$ : int [1:3] 1 2 3
[13:21:32.960]   ..$ : int [1:4] 1 2 3 4
[13:21:32.960]   ..$ : int [1:5] 1 2 3 4 5
[13:21:32.960]   ..$ : int [1:6] 1 2 3 4 5 6
[13:21:32.960]   ..$ : int [1:7] 1 2 3 4 5 6 7
[13:21:32.960]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[13:21:32.960]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[13:21:32.960]  $ ...future.seeds_ii       : NULL
[13:21:32.960]  $ ...future.globals.maxSize: NULL
[13:21:32.960]  - attr(*, "where")=List of 5
[13:21:32.960]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:32.960]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:32.960]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:32.960]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:32.960]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:32.960]  - attr(*, "resolved")= logi FALSE
[13:21:32.960]  - attr(*, "total_size")= num 46960
[13:21:32.960]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:32.960]  - attr(*, "already-done")= logi TRUE
[13:21:32.967] - copied ‘...future.FUN’ to environment
[13:21:32.967] - copied ‘future.call.arguments’ to environment
[13:21:32.967] - copied ‘...future.elements_ii’ to environment
[13:21:32.967] - copied ‘...future.seeds_ii’ to environment
[13:21:32.967] - copied ‘...future.globals.maxSize’ to environment
[13:21:32.968] assign_globals() ... done
[13:21:32.968] plan(): Setting new future strategy stack:
[13:21:32.968] List of future strategies:
[13:21:32.968] 1. sequential:
[13:21:32.968]    - args: function (..., envir = parent.frame())
[13:21:32.968]    - tweaked: FALSE
[13:21:32.968]    - call: NULL
[13:21:32.968] plan(): nbrOfWorkers() = 1
[13:21:32.969] plan(): Setting new future strategy stack:
[13:21:32.969] List of future strategies:
[13:21:32.969] 1. sequential:
[13:21:32.969]    - args: function (..., envir = parent.frame())
[13:21:32.969]    - tweaked: FALSE
[13:21:32.969]    - call: plan(strategy)
[13:21:32.970] plan(): nbrOfWorkers() = 1
[13:21:32.970] SequentialFuture started (and completed)
[13:21:32.970] - Launch lazy future ... done
[13:21:32.970] run() for ‘SequentialFuture’ ... done
[13:21:32.970] Created future:
[13:21:32.970] SequentialFuture:
[13:21:32.970] Label: ‘future_sapply-1’
[13:21:32.970] Expression:
[13:21:32.970] {
[13:21:32.970]     do.call(function(...) {
[13:21:32.970]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:32.970]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:32.970]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:32.970]             on.exit(options(oopts), add = TRUE)
[13:21:32.970]         }
[13:21:32.970]         {
[13:21:32.970]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:32.970]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:32.970]                 ...future.FUN(...future.X_jj, ...)
[13:21:32.970]             })
[13:21:32.970]         }
[13:21:32.970]     }, args = future.call.arguments)
[13:21:32.970] }
[13:21:32.970] Lazy evaluation: FALSE
[13:21:32.970] Asynchronous evaluation: FALSE
[13:21:32.970] Local evaluation: TRUE
[13:21:32.970] Environment: R_GlobalEnv
[13:21:32.970] Capture standard output: TRUE
[13:21:32.970] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:32.970] Globals: 5 objects totaling 46.39 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 544 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:21:32.970] Packages: 1 packages (‘stats’)
[13:21:32.970] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:32.970] Resolved: TRUE
[13:21:32.970] Value: 672 bytes of class ‘list’
[13:21:32.970] Early signaling: FALSE
[13:21:32.970] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:32.970] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:32.972] Chunk #1 of 1 ... DONE
[13:21:32.972] Launching 1 futures (chunks) ... DONE
[13:21:32.972] Resolving 1 futures (chunks) ...
[13:21:32.972] resolve() on list ...
[13:21:32.972]  recursive: 0
[13:21:32.972]  length: 1
[13:21:32.972] 
[13:21:32.972] resolved() for ‘SequentialFuture’ ...
[13:21:32.972] - state: ‘finished’
[13:21:32.973] - run: TRUE
[13:21:32.973] - result: ‘FutureResult’
[13:21:32.973] resolved() for ‘SequentialFuture’ ... done
[13:21:32.973] Future #1
[13:21:32.973] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:21:32.973] - nx: 1
[13:21:32.973] - relay: TRUE
[13:21:32.973] - stdout: TRUE
[13:21:32.973] - signal: TRUE
[13:21:32.973] - resignal: FALSE
[13:21:32.974] - force: TRUE
[13:21:32.974] - relayed: [n=1] FALSE
[13:21:32.974] - queued futures: [n=1] FALSE
[13:21:32.974]  - until=1
[13:21:32.974]  - relaying element #1
[13:21:32.974] - relayed: [n=1] TRUE
[13:21:32.974] - queued futures: [n=1] TRUE
[13:21:32.974] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:21:32.974]  length: 0 (resolved future 1)
[13:21:32.974] Relaying remaining futures
[13:21:32.975] signalConditionsASAP(NULL, pos=0) ...
[13:21:32.975] - nx: 1
[13:21:32.975] - relay: TRUE
[13:21:32.975] - stdout: TRUE
[13:21:32.975] - signal: TRUE
[13:21:32.975] - resignal: FALSE
[13:21:32.975] - force: TRUE
[13:21:32.975] - relayed: [n=1] TRUE
[13:21:32.975] - queued futures: [n=1] TRUE
 - flush all
[13:21:32.975] - relayed: [n=1] TRUE
[13:21:32.975] - queued futures: [n=1] TRUE
[13:21:32.976] signalConditionsASAP(NULL, pos=0) ... done
[13:21:32.976] resolve() on list ... DONE
[13:21:32.976]  - Number of value chunks collected: 1
[13:21:32.976] Resolving 1 futures (chunks) ... DONE
[13:21:32.976] Reducing values from 1 chunks ...
[13:21:32.976]  - Number of values collected after concatenation: 7
[13:21:32.976]  - Number of values expected: 7
[13:21:32.976] Reducing values from 1 chunks ... DONE
[13:21:32.976] future_lapply() ... DONE
[13:21:32.977] future_lapply() ...
[13:21:32.981] Number of chunks: 1
[13:21:32.981] getGlobalsAndPackagesXApply() ...
[13:21:32.981]  - future.globals: TRUE
[13:21:32.981] getGlobalsAndPackages() ...
[13:21:32.981] Searching for globals...
[13:21:32.988] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[13:21:32.989] Searching for globals ... DONE
[13:21:32.989] Resolving globals: FALSE
[13:21:32.990] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[13:21:32.990] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[13:21:32.991] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:32.991] - packages: [2] ‘stats’, ‘future.apply’
[13:21:32.991] getGlobalsAndPackages() ... DONE
[13:21:32.991]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:32.991]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[13:21:32.991] Finding globals ... DONE
[13:21:32.991]  - use_args: TRUE
[13:21:32.991]  - Getting '...' globals ...
[13:21:32.992] resolve() on list ...
[13:21:32.992]  recursive: 0
[13:21:32.992]  length: 1
[13:21:32.992]  elements: ‘...’
[13:21:32.992]  length: 0 (resolved future 1)
[13:21:32.992] resolve() on list ... DONE
[13:21:32.992]    - '...' content: [n=0] 
[13:21:32.992] List of 1
[13:21:32.992]  $ ...: list()
[13:21:32.992]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:32.992]  - attr(*, "where")=List of 1
[13:21:32.992]   ..$ ...:<environment: 0x563b6f4286b0> 
[13:21:32.992]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:32.992]  - attr(*, "resolved")= logi TRUE
[13:21:32.992]  - attr(*, "total_size")= num NA
[13:21:32.995]  - Getting '...' globals ... DONE
[13:21:32.995] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:32.995] List of 8
[13:21:32.995]  $ ...future.FUN:function (x, ...)  
[13:21:32.995]  $ x_FUN        :function (x, na.rm = TRUE)  
[13:21:32.995]  $ times        : int 5
[13:21:32.995]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:32.995]  $ stop_if_not  :function (...)  
[13:21:32.995]  $ dim          : NULL
[13:21:32.995]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:21:32.995]  $ ...          : list()
[13:21:32.995]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:32.995]  - attr(*, "where")=List of 8
[13:21:32.995]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:32.995]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:32.995]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:32.995]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:32.995]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:32.995]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:32.995]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:32.995]   ..$ ...          :<environment: 0x563b6f4286b0> 
[13:21:32.995]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:32.995]  - attr(*, "resolved")= logi FALSE
[13:21:32.995]  - attr(*, "total_size")= num 141240
[13:21:33.002] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[13:21:33.003] getGlobalsAndPackagesXApply() ... DONE
[13:21:33.003] Number of futures (= number of chunks): 1
[13:21:33.003] Launching 1 futures (chunks) ...
[13:21:33.003] Chunk #1 of 1 ...
[13:21:33.003]  - Finding globals in 'X' for chunk #1 ...
[13:21:33.003] getGlobalsAndPackages() ...
[13:21:33.003] Searching for globals...
[13:21:33.004] 
[13:21:33.004] Searching for globals ... DONE
[13:21:33.004] - globals: [0] <none>
[13:21:33.004] getGlobalsAndPackages() ... DONE
[13:21:33.004]    + additional globals found: [n=0] 
[13:21:33.004]    + additional namespaces needed: [n=0] 
[13:21:33.004]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:33.004]  - seeds: <none>
[13:21:33.004]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.005] getGlobalsAndPackages() ...
[13:21:33.005] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.005] Resolving globals: FALSE
[13:21:33.005] Tweak future expression to call with '...' arguments ...
[13:21:33.005] {
[13:21:33.005]     do.call(function(...) {
[13:21:33.005]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.005]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:33.005]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.005]             on.exit(options(oopts), add = TRUE)
[13:21:33.005]         }
[13:21:33.005]         {
[13:21:33.005]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:33.005]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.005]                 ...future.FUN(...future.X_jj, ...)
[13:21:33.005]             })
[13:21:33.005]         }
[13:21:33.005]     }, args = future.call.arguments)
[13:21:33.005] }
[13:21:33.005] Tweak future expression to call with '...' arguments ... DONE
[13:21:33.006] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.006] - packages: [2] ‘stats’, ‘future.apply’
[13:21:33.006] getGlobalsAndPackages() ... DONE
[13:21:33.006] run() for ‘Future’ ...
[13:21:33.006] - state: ‘created’
[13:21:33.007] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:33.007] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:33.007] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:33.007]   - Field: ‘label’
[13:21:33.007]   - Field: ‘local’
[13:21:33.007]   - Field: ‘owner’
[13:21:33.007]   - Field: ‘envir’
[13:21:33.007]   - Field: ‘packages’
[13:21:33.008]   - Field: ‘gc’
[13:21:33.008]   - Field: ‘conditions’
[13:21:33.008]   - Field: ‘expr’
[13:21:33.008]   - Field: ‘uuid’
[13:21:33.008]   - Field: ‘seed’
[13:21:33.008]   - Field: ‘version’
[13:21:33.008]   - Field: ‘result’
[13:21:33.008]   - Field: ‘asynchronous’
[13:21:33.008]   - Field: ‘calls’
[13:21:33.008]   - Field: ‘globals’
[13:21:33.009]   - Field: ‘stdout’
[13:21:33.009]   - Field: ‘earlySignal’
[13:21:33.009]   - Field: ‘lazy’
[13:21:33.009]   - Field: ‘state’
[13:21:33.009] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:33.009] - Launch lazy future ...
[13:21:33.009] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[13:21:33.009] Packages needed by future strategies (n = 0): <none>
[13:21:33.010] {
[13:21:33.010]     {
[13:21:33.010]         {
[13:21:33.010]             ...future.startTime <- base::Sys.time()
[13:21:33.010]             {
[13:21:33.010]                 {
[13:21:33.010]                   {
[13:21:33.010]                     {
[13:21:33.010]                       base::local({
[13:21:33.010]                         has_future <- base::requireNamespace("future", 
[13:21:33.010]                           quietly = TRUE)
[13:21:33.010]                         if (has_future) {
[13:21:33.010]                           ns <- base::getNamespace("future")
[13:21:33.010]                           version <- ns[[".package"]][["version"]]
[13:21:33.010]                           if (is.null(version)) 
[13:21:33.010]                             version <- utils::packageVersion("future")
[13:21:33.010]                         }
[13:21:33.010]                         else {
[13:21:33.010]                           version <- NULL
[13:21:33.010]                         }
[13:21:33.010]                         if (!has_future || version < "1.8.0") {
[13:21:33.010]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:33.010]                             "", base::R.version$version.string), 
[13:21:33.010]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:33.010]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:33.010]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:33.010]                               "release", "version")], collapse = " "), 
[13:21:33.010]                             hostname = base::Sys.info()[["nodename"]])
[13:21:33.010]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:33.010]                             info)
[13:21:33.010]                           info <- base::paste(info, collapse = "; ")
[13:21:33.010]                           if (!has_future) {
[13:21:33.010]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:33.010]                               info)
[13:21:33.010]                           }
[13:21:33.010]                           else {
[13:21:33.010]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:33.010]                               info, version)
[13:21:33.010]                           }
[13:21:33.010]                           base::stop(msg)
[13:21:33.010]                         }
[13:21:33.010]                       })
[13:21:33.010]                     }
[13:21:33.010]                     base::local({
[13:21:33.010]                       for (pkg in c("stats", "future.apply")) {
[13:21:33.010]                         base::loadNamespace(pkg)
[13:21:33.010]                         base::library(pkg, character.only = TRUE)
[13:21:33.010]                       }
[13:21:33.010]                     })
[13:21:33.010]                   }
[13:21:33.010]                   options(future.plan = NULL)
[13:21:33.010]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:33.010]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:33.010]                 }
[13:21:33.010]                 ...future.workdir <- getwd()
[13:21:33.010]             }
[13:21:33.010]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:33.010]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:33.010]         }
[13:21:33.010]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:33.010]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:33.010]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:33.010]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:33.010]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:33.010]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:33.010]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:33.010]             base::names(...future.oldOptions))
[13:21:33.010]     }
[13:21:33.010]     if (FALSE) {
[13:21:33.010]     }
[13:21:33.010]     else {
[13:21:33.010]         if (TRUE) {
[13:21:33.010]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:33.010]                 open = "w")
[13:21:33.010]         }
[13:21:33.010]         else {
[13:21:33.010]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:33.010]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:33.010]         }
[13:21:33.010]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:33.010]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:33.010]             base::sink(type = "output", split = FALSE)
[13:21:33.010]             base::close(...future.stdout)
[13:21:33.010]         }, add = TRUE)
[13:21:33.010]     }
[13:21:33.010]     ...future.frame <- base::sys.nframe()
[13:21:33.010]     ...future.conditions <- base::list()
[13:21:33.010]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:33.010]     if (FALSE) {
[13:21:33.010]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:33.010]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:33.010]     }
[13:21:33.010]     ...future.result <- base::tryCatch({
[13:21:33.010]         base::withCallingHandlers({
[13:21:33.010]             ...future.value <- base::withVisible(base::local({
[13:21:33.010]                 do.call(function(...) {
[13:21:33.010]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.010]                   if (!identical(...future.globals.maxSize.org, 
[13:21:33.010]                     ...future.globals.maxSize)) {
[13:21:33.010]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.010]                     on.exit(options(oopts), add = TRUE)
[13:21:33.010]                   }
[13:21:33.010]                   {
[13:21:33.010]                     lapply(seq_along(...future.elements_ii), 
[13:21:33.010]                       FUN = function(jj) {
[13:21:33.010]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.010]                         ...future.FUN(...future.X_jj, ...)
[13:21:33.010]                       })
[13:21:33.010]                   }
[13:21:33.010]                 }, args = future.call.arguments)
[13:21:33.010]             }))
[13:21:33.010]             future::FutureResult(value = ...future.value$value, 
[13:21:33.010]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:33.010]                   ...future.rng), globalenv = if (FALSE) 
[13:21:33.010]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:33.010]                     ...future.globalenv.names))
[13:21:33.010]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:33.010]         }, condition = base::local({
[13:21:33.010]             c <- base::c
[13:21:33.010]             inherits <- base::inherits
[13:21:33.010]             invokeRestart <- base::invokeRestart
[13:21:33.010]             length <- base::length
[13:21:33.010]             list <- base::list
[13:21:33.010]             seq.int <- base::seq.int
[13:21:33.010]             signalCondition <- base::signalCondition
[13:21:33.010]             sys.calls <- base::sys.calls
[13:21:33.010]             `[[` <- base::`[[`
[13:21:33.010]             `+` <- base::`+`
[13:21:33.010]             `<<-` <- base::`<<-`
[13:21:33.010]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:33.010]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:33.010]                   3L)]
[13:21:33.010]             }
[13:21:33.010]             function(cond) {
[13:21:33.010]                 is_error <- inherits(cond, "error")
[13:21:33.010]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:33.010]                   NULL)
[13:21:33.010]                 if (is_error) {
[13:21:33.010]                   sessionInformation <- function() {
[13:21:33.010]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:33.010]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:33.010]                       search = base::search(), system = base::Sys.info())
[13:21:33.010]                   }
[13:21:33.010]                   ...future.conditions[[length(...future.conditions) + 
[13:21:33.010]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:33.010]                     cond$call), session = sessionInformation(), 
[13:21:33.010]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:33.010]                   signalCondition(cond)
[13:21:33.010]                 }
[13:21:33.010]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:33.010]                 "immediateCondition"))) {
[13:21:33.010]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:33.010]                   ...future.conditions[[length(...future.conditions) + 
[13:21:33.010]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:33.010]                   if (TRUE && !signal) {
[13:21:33.010]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.010]                     {
[13:21:33.010]                       inherits <- base::inherits
[13:21:33.010]                       invokeRestart <- base::invokeRestart
[13:21:33.010]                       is.null <- base::is.null
[13:21:33.010]                       muffled <- FALSE
[13:21:33.010]                       if (inherits(cond, "message")) {
[13:21:33.010]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:33.010]                         if (muffled) 
[13:21:33.010]                           invokeRestart("muffleMessage")
[13:21:33.010]                       }
[13:21:33.010]                       else if (inherits(cond, "warning")) {
[13:21:33.010]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:33.010]                         if (muffled) 
[13:21:33.010]                           invokeRestart("muffleWarning")
[13:21:33.010]                       }
[13:21:33.010]                       else if (inherits(cond, "condition")) {
[13:21:33.010]                         if (!is.null(pattern)) {
[13:21:33.010]                           computeRestarts <- base::computeRestarts
[13:21:33.010]                           grepl <- base::grepl
[13:21:33.010]                           restarts <- computeRestarts(cond)
[13:21:33.010]                           for (restart in restarts) {
[13:21:33.010]                             name <- restart$name
[13:21:33.010]                             if (is.null(name)) 
[13:21:33.010]                               next
[13:21:33.010]                             if (!grepl(pattern, name)) 
[13:21:33.010]                               next
[13:21:33.010]                             invokeRestart(restart)
[13:21:33.010]                             muffled <- TRUE
[13:21:33.010]                             break
[13:21:33.010]                           }
[13:21:33.010]                         }
[13:21:33.010]                       }
[13:21:33.010]                       invisible(muffled)
[13:21:33.010]                     }
[13:21:33.010]                     muffleCondition(cond, pattern = "^muffle")
[13:21:33.010]                   }
[13:21:33.010]                 }
[13:21:33.010]                 else {
[13:21:33.010]                   if (TRUE) {
[13:21:33.010]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.010]                     {
[13:21:33.010]                       inherits <- base::inherits
[13:21:33.010]                       invokeRestart <- base::invokeRestart
[13:21:33.010]                       is.null <- base::is.null
[13:21:33.010]                       muffled <- FALSE
[13:21:33.010]                       if (inherits(cond, "message")) {
[13:21:33.010]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:33.010]                         if (muffled) 
[13:21:33.010]                           invokeRestart("muffleMessage")
[13:21:33.010]                       }
[13:21:33.010]                       else if (inherits(cond, "warning")) {
[13:21:33.010]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:33.010]                         if (muffled) 
[13:21:33.010]                           invokeRestart("muffleWarning")
[13:21:33.010]                       }
[13:21:33.010]                       else if (inherits(cond, "condition")) {
[13:21:33.010]                         if (!is.null(pattern)) {
[13:21:33.010]                           computeRestarts <- base::computeRestarts
[13:21:33.010]                           grepl <- base::grepl
[13:21:33.010]                           restarts <- computeRestarts(cond)
[13:21:33.010]                           for (restart in restarts) {
[13:21:33.010]                             name <- restart$name
[13:21:33.010]                             if (is.null(name)) 
[13:21:33.010]                               next
[13:21:33.010]                             if (!grepl(pattern, name)) 
[13:21:33.010]                               next
[13:21:33.010]                             invokeRestart(restart)
[13:21:33.010]                             muffled <- TRUE
[13:21:33.010]                             break
[13:21:33.010]                           }
[13:21:33.010]                         }
[13:21:33.010]                       }
[13:21:33.010]                       invisible(muffled)
[13:21:33.010]                     }
[13:21:33.010]                     muffleCondition(cond, pattern = "^muffle")
[13:21:33.010]                   }
[13:21:33.010]                 }
[13:21:33.010]             }
[13:21:33.010]         }))
[13:21:33.010]     }, error = function(ex) {
[13:21:33.010]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:33.010]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:33.010]                 ...future.rng), started = ...future.startTime, 
[13:21:33.010]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:33.010]             version = "1.8"), class = "FutureResult")
[13:21:33.010]     }, finally = {
[13:21:33.010]         if (!identical(...future.workdir, getwd())) 
[13:21:33.010]             setwd(...future.workdir)
[13:21:33.010]         {
[13:21:33.010]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:33.010]                 ...future.oldOptions$nwarnings <- NULL
[13:21:33.010]             }
[13:21:33.010]             base::options(...future.oldOptions)
[13:21:33.010]             if (.Platform$OS.type == "windows") {
[13:21:33.010]                 old_names <- names(...future.oldEnvVars)
[13:21:33.010]                 envs <- base::Sys.getenv()
[13:21:33.010]                 names <- names(envs)
[13:21:33.010]                 common <- intersect(names, old_names)
[13:21:33.010]                 added <- setdiff(names, old_names)
[13:21:33.010]                 removed <- setdiff(old_names, names)
[13:21:33.010]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:33.010]                   envs[common]]
[13:21:33.010]                 NAMES <- toupper(changed)
[13:21:33.010]                 args <- list()
[13:21:33.010]                 for (kk in seq_along(NAMES)) {
[13:21:33.010]                   name <- changed[[kk]]
[13:21:33.010]                   NAME <- NAMES[[kk]]
[13:21:33.010]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.010]                     next
[13:21:33.010]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:33.010]                 }
[13:21:33.010]                 NAMES <- toupper(added)
[13:21:33.010]                 for (kk in seq_along(NAMES)) {
[13:21:33.010]                   name <- added[[kk]]
[13:21:33.010]                   NAME <- NAMES[[kk]]
[13:21:33.010]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.010]                     next
[13:21:33.010]                   args[[name]] <- ""
[13:21:33.010]                 }
[13:21:33.010]                 NAMES <- toupper(removed)
[13:21:33.010]                 for (kk in seq_along(NAMES)) {
[13:21:33.010]                   name <- removed[[kk]]
[13:21:33.010]                   NAME <- NAMES[[kk]]
[13:21:33.010]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.010]                     next
[13:21:33.010]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:33.010]                 }
[13:21:33.010]                 if (length(args) > 0) 
[13:21:33.010]                   base::do.call(base::Sys.setenv, args = args)
[13:21:33.010]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:33.010]             }
[13:21:33.010]             else {
[13:21:33.010]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:33.010]             }
[13:21:33.010]             {
[13:21:33.010]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:33.010]                   0L) {
[13:21:33.010]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:33.010]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:33.010]                   base::options(opts)
[13:21:33.010]                 }
[13:21:33.010]                 {
[13:21:33.010]                   {
[13:21:33.010]                     NULL
[13:21:33.010]                     RNGkind("Mersenne-Twister")
[13:21:33.010]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:33.010]                       inherits = FALSE)
[13:21:33.010]                   }
[13:21:33.010]                   options(future.plan = NULL)
[13:21:33.010]                   if (is.na(NA_character_)) 
[13:21:33.010]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:33.010]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:33.010]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:33.010]                   {
[13:21:33.010]                     future <- SequentialFuture(..., envir = envir)
[13:21:33.010]                     if (!future$lazy) 
[13:21:33.010]                       future <- run(future)
[13:21:33.010]                     invisible(future)
[13:21:33.010]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:33.010]                 }
[13:21:33.010]             }
[13:21:33.010]         }
[13:21:33.010]     })
[13:21:33.010]     if (TRUE) {
[13:21:33.010]         base::sink(type = "output", split = FALSE)
[13:21:33.010]         if (TRUE) {
[13:21:33.010]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:33.010]         }
[13:21:33.010]         else {
[13:21:33.010]             ...future.result["stdout"] <- base::list(NULL)
[13:21:33.010]         }
[13:21:33.010]         base::close(...future.stdout)
[13:21:33.010]         ...future.stdout <- NULL
[13:21:33.010]     }
[13:21:33.010]     ...future.result$conditions <- ...future.conditions
[13:21:33.010]     ...future.result$finished <- base::Sys.time()
[13:21:33.010]     ...future.result
[13:21:33.010] }
[13:21:33.012] assign_globals() ...
[13:21:33.012] List of 11
[13:21:33.012]  $ ...future.FUN            :function (x, ...)  
[13:21:33.012]  $ x_FUN                    :function (x, na.rm = TRUE)  
[13:21:33.012]  $ times                    : int 5
[13:21:33.012]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:33.012]  $ stop_if_not              :function (...)  
[13:21:33.012]  $ dim                      : NULL
[13:21:33.012]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:21:33.012]  $ future.call.arguments    : list()
[13:21:33.012]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:33.012]  $ ...future.elements_ii    :List of 7
[13:21:33.012]   ..$ : int [1:3] 1 2 3
[13:21:33.012]   ..$ : int [1:4] 1 2 3 4
[13:21:33.012]   ..$ : int [1:5] 1 2 3 4 5
[13:21:33.012]   ..$ : int [1:6] 1 2 3 4 5 6
[13:21:33.012]   ..$ : int [1:7] 1 2 3 4 5 6 7
[13:21:33.012]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[13:21:33.012]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[13:21:33.012]  $ ...future.seeds_ii       : NULL
[13:21:33.012]  $ ...future.globals.maxSize: NULL
[13:21:33.012]  - attr(*, "where")=List of 11
[13:21:33.012]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:33.012]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:33.012]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:33.012]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:33.012]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:33.012]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:33.012]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:33.012]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:33.012]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:33.012]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:33.012]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:33.012]  - attr(*, "resolved")= logi FALSE
[13:21:33.012]  - attr(*, "total_size")= num 141240
[13:21:33.012]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:33.012]  - attr(*, "already-done")= logi TRUE
[13:21:33.021] - copied ‘...future.FUN’ to environment
[13:21:33.021] - copied ‘x_FUN’ to environment
[13:21:33.021] - copied ‘times’ to environment
[13:21:33.022] - copied ‘stopf’ to environment
[13:21:33.022] - copied ‘stop_if_not’ to environment
[13:21:33.022] - copied ‘dim’ to environment
[13:21:33.022] - copied ‘valid_types’ to environment
[13:21:33.022] - copied ‘future.call.arguments’ to environment
[13:21:33.022] - copied ‘...future.elements_ii’ to environment
[13:21:33.022] - copied ‘...future.seeds_ii’ to environment
[13:21:33.022] - copied ‘...future.globals.maxSize’ to environment
[13:21:33.022] assign_globals() ... done
[13:21:33.023] plan(): Setting new future strategy stack:
[13:21:33.023] List of future strategies:
[13:21:33.023] 1. sequential:
[13:21:33.023]    - args: function (..., envir = parent.frame())
[13:21:33.023]    - tweaked: FALSE
[13:21:33.023]    - call: NULL
[13:21:33.025] plan(): nbrOfWorkers() = 1
[13:21:33.026] plan(): Setting new future strategy stack:
[13:21:33.026] List of future strategies:
[13:21:33.026] 1. sequential:
[13:21:33.026]    - args: function (..., envir = parent.frame())
[13:21:33.026]    - tweaked: FALSE
[13:21:33.026]    - call: plan(strategy)
[13:21:33.027] plan(): nbrOfWorkers() = 1
[13:21:33.027] SequentialFuture started (and completed)
[13:21:33.027] - Launch lazy future ... done
[13:21:33.027] run() for ‘SequentialFuture’ ... done
[13:21:33.027] Created future:
[13:21:33.027] SequentialFuture:
[13:21:33.027] Label: ‘future_vapply-1’
[13:21:33.027] Expression:
[13:21:33.027] {
[13:21:33.027]     do.call(function(...) {
[13:21:33.027]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.027]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:33.027]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.027]             on.exit(options(oopts), add = TRUE)
[13:21:33.027]         }
[13:21:33.027]         {
[13:21:33.027]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:33.027]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.027]                 ...future.FUN(...future.X_jj, ...)
[13:21:33.027]             })
[13:21:33.027]         }
[13:21:33.027]     }, args = future.call.arguments)
[13:21:33.027] }
[13:21:33.027] Lazy evaluation: FALSE
[13:21:33.027] Asynchronous evaluation: FALSE
[13:21:33.027] Local evaluation: TRUE
[13:21:33.027] Environment: R_GlobalEnv
[13:21:33.027] Capture standard output: TRUE
[13:21:33.027] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:33.027] Globals: 11 objects totaling 138.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:33.027] Packages: 2 packages (‘stats’, ‘future.apply’)
[13:21:33.027] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:33.027] Resolved: TRUE
[13:21:33.027] Value: 672 bytes of class ‘list’
[13:21:33.027] Early signaling: FALSE
[13:21:33.027] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:33.027] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:33.029] Chunk #1 of 1 ... DONE
[13:21:33.029] Launching 1 futures (chunks) ... DONE
[13:21:33.029] Resolving 1 futures (chunks) ...
[13:21:33.029] resolve() on list ...
[13:21:33.029]  recursive: 0
[13:21:33.029]  length: 1
[13:21:33.029] 
[13:21:33.029] resolved() for ‘SequentialFuture’ ...
[13:21:33.029] - state: ‘finished’
[13:21:33.030] - run: TRUE
[13:21:33.030] - result: ‘FutureResult’
[13:21:33.030] resolved() for ‘SequentialFuture’ ... done
[13:21:33.030] Future #1
[13:21:33.030] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:21:33.030] - nx: 1
[13:21:33.030] - relay: TRUE
[13:21:33.030] - stdout: TRUE
[13:21:33.030] - signal: TRUE
[13:21:33.030] - resignal: FALSE
[13:21:33.031] - force: TRUE
[13:21:33.031] - relayed: [n=1] FALSE
[13:21:33.031] - queued futures: [n=1] FALSE
[13:21:33.031]  - until=1
[13:21:33.031]  - relaying element #1
[13:21:33.031] - relayed: [n=1] TRUE
[13:21:33.031] - queued futures: [n=1] TRUE
[13:21:33.031] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:21:33.031]  length: 0 (resolved future 1)
[13:21:33.032] Relaying remaining futures
[13:21:33.032] signalConditionsASAP(NULL, pos=0) ...
[13:21:33.032] - nx: 1
[13:21:33.032] - relay: TRUE
[13:21:33.032] - stdout: TRUE
[13:21:33.032] - signal: TRUE
[13:21:33.032] - resignal: FALSE
[13:21:33.032] - force: TRUE
[13:21:33.032] - relayed: [n=1] TRUE
[13:21:33.032] - queued futures: [n=1] TRUE
 - flush all
[13:21:33.033] - relayed: [n=1] TRUE
[13:21:33.033] - queued futures: [n=1] TRUE
[13:21:33.033] signalConditionsASAP(NULL, pos=0) ... done
[13:21:33.033] resolve() on list ... DONE
[13:21:33.033]  - Number of value chunks collected: 1
[13:21:33.033] Resolving 1 futures (chunks) ... DONE
[13:21:33.033] Reducing values from 1 chunks ...
[13:21:33.033]  - Number of values collected after concatenation: 7
[13:21:33.033]  - Number of values expected: 7
[13:21:33.033] Reducing values from 1 chunks ... DONE
[13:21:33.034] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[13:21:33.035] future_lapply() ...
[13:21:33.036] Number of chunks: 1
[13:21:33.036] getGlobalsAndPackagesXApply() ...
[13:21:33.036]  - future.globals: TRUE
[13:21:33.036] getGlobalsAndPackages() ...
[13:21:33.037] Searching for globals...
[13:21:33.038] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[13:21:33.038] Searching for globals ... DONE
[13:21:33.038] Resolving globals: FALSE
[13:21:33.038] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[13:21:33.039] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[13:21:33.039] - globals: [1] ‘FUN’
[13:21:33.039] 
[13:21:33.039] getGlobalsAndPackages() ... DONE
[13:21:33.039]  - globals found/used: [n=1] ‘FUN’
[13:21:33.039]  - needed namespaces: [n=0] 
[13:21:33.039] Finding globals ... DONE
[13:21:33.039]  - use_args: TRUE
[13:21:33.039]  - Getting '...' globals ...
[13:21:33.040] resolve() on list ...
[13:21:33.040]  recursive: 0
[13:21:33.040]  length: 1
[13:21:33.040]  elements: ‘...’
[13:21:33.040]  length: 0 (resolved future 1)
[13:21:33.040] resolve() on list ... DONE
[13:21:33.040]    - '...' content: [n=1] ‘y’
[13:21:33.041] List of 1
[13:21:33.041]  $ ...:List of 1
[13:21:33.041]   ..$ y: num [1:5] 2 4 6 8 10
[13:21:33.041]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:33.041]  - attr(*, "where")=List of 1
[13:21:33.041]   ..$ ...:<environment: 0x563b6e70ed90> 
[13:21:33.041]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:33.041]  - attr(*, "resolved")= logi TRUE
[13:21:33.041]  - attr(*, "total_size")= num NA
[13:21:33.043]  - Getting '...' globals ... DONE
[13:21:33.044] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:21:33.044] List of 2
[13:21:33.044]  $ ...future.FUN:function (x, y)  
[13:21:33.044]  $ ...          :List of 1
[13:21:33.044]   ..$ y: num [1:5] 2 4 6 8 10
[13:21:33.044]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:33.044]  - attr(*, "where")=List of 2
[13:21:33.044]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:33.044]   ..$ ...          :<environment: 0x563b6e70ed90> 
[13:21:33.044]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:33.044]  - attr(*, "resolved")= logi FALSE
[13:21:33.044]  - attr(*, "total_size")= num 4264
[13:21:33.047] Packages to be attached in all futures: [n=0] 
[13:21:33.047] getGlobalsAndPackagesXApply() ... DONE
[13:21:33.049] Number of futures (= number of chunks): 1
[13:21:33.049] Launching 1 futures (chunks) ...
[13:21:33.049] Chunk #1 of 1 ...
[13:21:33.049]  - Finding globals in 'X' for chunk #1 ...
[13:21:33.050] getGlobalsAndPackages() ...
[13:21:33.050] Searching for globals...
[13:21:33.050] 
[13:21:33.050] Searching for globals ... DONE
[13:21:33.050] - globals: [0] <none>
[13:21:33.050] getGlobalsAndPackages() ... DONE
[13:21:33.050]    + additional globals found: [n=0] 
[13:21:33.051]    + additional namespaces needed: [n=0] 
[13:21:33.051]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:33.051]  - seeds: <none>
[13:21:33.051]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.051] getGlobalsAndPackages() ...
[13:21:33.051] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.051] Resolving globals: FALSE
[13:21:33.051] Tweak future expression to call with '...' arguments ...
[13:21:33.052] {
[13:21:33.052]     do.call(function(...) {
[13:21:33.052]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.052]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:33.052]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.052]             on.exit(options(oopts), add = TRUE)
[13:21:33.052]         }
[13:21:33.052]         {
[13:21:33.052]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:33.052]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.052]                 ...future.FUN(...future.X_jj, ...)
[13:21:33.052]             })
[13:21:33.052]         }
[13:21:33.052]     }, args = future.call.arguments)
[13:21:33.052] }
[13:21:33.052] Tweak future expression to call with '...' arguments ... DONE
[13:21:33.052] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.052] 
[13:21:33.053] getGlobalsAndPackages() ... DONE
[13:21:33.053] run() for ‘Future’ ...
[13:21:33.053] - state: ‘created’
[13:21:33.053] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:33.053] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:33.054] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:33.054]   - Field: ‘label’
[13:21:33.054]   - Field: ‘local’
[13:21:33.054]   - Field: ‘owner’
[13:21:33.054]   - Field: ‘envir’
[13:21:33.054]   - Field: ‘packages’
[13:21:33.054]   - Field: ‘gc’
[13:21:33.054]   - Field: ‘conditions’
[13:21:33.054]   - Field: ‘expr’
[13:21:33.054]   - Field: ‘uuid’
[13:21:33.055]   - Field: ‘seed’
[13:21:33.055]   - Field: ‘version’
[13:21:33.055]   - Field: ‘result’
[13:21:33.055]   - Field: ‘asynchronous’
[13:21:33.055]   - Field: ‘calls’
[13:21:33.055]   - Field: ‘globals’
[13:21:33.055]   - Field: ‘stdout’
[13:21:33.055]   - Field: ‘earlySignal’
[13:21:33.055]   - Field: ‘lazy’
[13:21:33.055]   - Field: ‘state’
[13:21:33.056] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:33.056] - Launch lazy future ...
[13:21:33.056] Packages needed by the future expression (n = 0): <none>
[13:21:33.056] Packages needed by future strategies (n = 0): <none>
[13:21:33.056] {
[13:21:33.056]     {
[13:21:33.056]         {
[13:21:33.056]             ...future.startTime <- base::Sys.time()
[13:21:33.056]             {
[13:21:33.056]                 {
[13:21:33.056]                   {
[13:21:33.056]                     base::local({
[13:21:33.056]                       has_future <- base::requireNamespace("future", 
[13:21:33.056]                         quietly = TRUE)
[13:21:33.056]                       if (has_future) {
[13:21:33.056]                         ns <- base::getNamespace("future")
[13:21:33.056]                         version <- ns[[".package"]][["version"]]
[13:21:33.056]                         if (is.null(version)) 
[13:21:33.056]                           version <- utils::packageVersion("future")
[13:21:33.056]                       }
[13:21:33.056]                       else {
[13:21:33.056]                         version <- NULL
[13:21:33.056]                       }
[13:21:33.056]                       if (!has_future || version < "1.8.0") {
[13:21:33.056]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:33.056]                           "", base::R.version$version.string), 
[13:21:33.056]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:33.056]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:33.056]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:33.056]                             "release", "version")], collapse = " "), 
[13:21:33.056]                           hostname = base::Sys.info()[["nodename"]])
[13:21:33.056]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:33.056]                           info)
[13:21:33.056]                         info <- base::paste(info, collapse = "; ")
[13:21:33.056]                         if (!has_future) {
[13:21:33.056]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:33.056]                             info)
[13:21:33.056]                         }
[13:21:33.056]                         else {
[13:21:33.056]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:33.056]                             info, version)
[13:21:33.056]                         }
[13:21:33.056]                         base::stop(msg)
[13:21:33.056]                       }
[13:21:33.056]                     })
[13:21:33.056]                   }
[13:21:33.056]                   options(future.plan = NULL)
[13:21:33.056]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:33.056]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:33.056]                 }
[13:21:33.056]                 ...future.workdir <- getwd()
[13:21:33.056]             }
[13:21:33.056]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:33.056]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:33.056]         }
[13:21:33.056]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:33.056]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:33.056]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:33.056]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:33.056]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:33.056]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:33.056]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:33.056]             base::names(...future.oldOptions))
[13:21:33.056]     }
[13:21:33.056]     if (FALSE) {
[13:21:33.056]     }
[13:21:33.056]     else {
[13:21:33.056]         if (TRUE) {
[13:21:33.056]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:33.056]                 open = "w")
[13:21:33.056]         }
[13:21:33.056]         else {
[13:21:33.056]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:33.056]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:33.056]         }
[13:21:33.056]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:33.056]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:33.056]             base::sink(type = "output", split = FALSE)
[13:21:33.056]             base::close(...future.stdout)
[13:21:33.056]         }, add = TRUE)
[13:21:33.056]     }
[13:21:33.056]     ...future.frame <- base::sys.nframe()
[13:21:33.056]     ...future.conditions <- base::list()
[13:21:33.056]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:33.056]     if (FALSE) {
[13:21:33.056]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:33.056]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:33.056]     }
[13:21:33.056]     ...future.result <- base::tryCatch({
[13:21:33.056]         base::withCallingHandlers({
[13:21:33.056]             ...future.value <- base::withVisible(base::local({
[13:21:33.056]                 do.call(function(...) {
[13:21:33.056]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.056]                   if (!identical(...future.globals.maxSize.org, 
[13:21:33.056]                     ...future.globals.maxSize)) {
[13:21:33.056]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.056]                     on.exit(options(oopts), add = TRUE)
[13:21:33.056]                   }
[13:21:33.056]                   {
[13:21:33.056]                     lapply(seq_along(...future.elements_ii), 
[13:21:33.056]                       FUN = function(jj) {
[13:21:33.056]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.056]                         ...future.FUN(...future.X_jj, ...)
[13:21:33.056]                       })
[13:21:33.056]                   }
[13:21:33.056]                 }, args = future.call.arguments)
[13:21:33.056]             }))
[13:21:33.056]             future::FutureResult(value = ...future.value$value, 
[13:21:33.056]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:33.056]                   ...future.rng), globalenv = if (FALSE) 
[13:21:33.056]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:33.056]                     ...future.globalenv.names))
[13:21:33.056]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:33.056]         }, condition = base::local({
[13:21:33.056]             c <- base::c
[13:21:33.056]             inherits <- base::inherits
[13:21:33.056]             invokeRestart <- base::invokeRestart
[13:21:33.056]             length <- base::length
[13:21:33.056]             list <- base::list
[13:21:33.056]             seq.int <- base::seq.int
[13:21:33.056]             signalCondition <- base::signalCondition
[13:21:33.056]             sys.calls <- base::sys.calls
[13:21:33.056]             `[[` <- base::`[[`
[13:21:33.056]             `+` <- base::`+`
[13:21:33.056]             `<<-` <- base::`<<-`
[13:21:33.056]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:33.056]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:33.056]                   3L)]
[13:21:33.056]             }
[13:21:33.056]             function(cond) {
[13:21:33.056]                 is_error <- inherits(cond, "error")
[13:21:33.056]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:33.056]                   NULL)
[13:21:33.056]                 if (is_error) {
[13:21:33.056]                   sessionInformation <- function() {
[13:21:33.056]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:33.056]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:33.056]                       search = base::search(), system = base::Sys.info())
[13:21:33.056]                   }
[13:21:33.056]                   ...future.conditions[[length(...future.conditions) + 
[13:21:33.056]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:33.056]                     cond$call), session = sessionInformation(), 
[13:21:33.056]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:33.056]                   signalCondition(cond)
[13:21:33.056]                 }
[13:21:33.056]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:33.056]                 "immediateCondition"))) {
[13:21:33.056]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:33.056]                   ...future.conditions[[length(...future.conditions) + 
[13:21:33.056]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:33.056]                   if (TRUE && !signal) {
[13:21:33.056]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.056]                     {
[13:21:33.056]                       inherits <- base::inherits
[13:21:33.056]                       invokeRestart <- base::invokeRestart
[13:21:33.056]                       is.null <- base::is.null
[13:21:33.056]                       muffled <- FALSE
[13:21:33.056]                       if (inherits(cond, "message")) {
[13:21:33.056]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:33.056]                         if (muffled) 
[13:21:33.056]                           invokeRestart("muffleMessage")
[13:21:33.056]                       }
[13:21:33.056]                       else if (inherits(cond, "warning")) {
[13:21:33.056]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:33.056]                         if (muffled) 
[13:21:33.056]                           invokeRestart("muffleWarning")
[13:21:33.056]                       }
[13:21:33.056]                       else if (inherits(cond, "condition")) {
[13:21:33.056]                         if (!is.null(pattern)) {
[13:21:33.056]                           computeRestarts <- base::computeRestarts
[13:21:33.056]                           grepl <- base::grepl
[13:21:33.056]                           restarts <- computeRestarts(cond)
[13:21:33.056]                           for (restart in restarts) {
[13:21:33.056]                             name <- restart$name
[13:21:33.056]                             if (is.null(name)) 
[13:21:33.056]                               next
[13:21:33.056]                             if (!grepl(pattern, name)) 
[13:21:33.056]                               next
[13:21:33.056]                             invokeRestart(restart)
[13:21:33.056]                             muffled <- TRUE
[13:21:33.056]                             break
[13:21:33.056]                           }
[13:21:33.056]                         }
[13:21:33.056]                       }
[13:21:33.056]                       invisible(muffled)
[13:21:33.056]                     }
[13:21:33.056]                     muffleCondition(cond, pattern = "^muffle")
[13:21:33.056]                   }
[13:21:33.056]                 }
[13:21:33.056]                 else {
[13:21:33.056]                   if (TRUE) {
[13:21:33.056]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.056]                     {
[13:21:33.056]                       inherits <- base::inherits
[13:21:33.056]                       invokeRestart <- base::invokeRestart
[13:21:33.056]                       is.null <- base::is.null
[13:21:33.056]                       muffled <- FALSE
[13:21:33.056]                       if (inherits(cond, "message")) {
[13:21:33.056]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:33.056]                         if (muffled) 
[13:21:33.056]                           invokeRestart("muffleMessage")
[13:21:33.056]                       }
[13:21:33.056]                       else if (inherits(cond, "warning")) {
[13:21:33.056]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:33.056]                         if (muffled) 
[13:21:33.056]                           invokeRestart("muffleWarning")
[13:21:33.056]                       }
[13:21:33.056]                       else if (inherits(cond, "condition")) {
[13:21:33.056]                         if (!is.null(pattern)) {
[13:21:33.056]                           computeRestarts <- base::computeRestarts
[13:21:33.056]                           grepl <- base::grepl
[13:21:33.056]                           restarts <- computeRestarts(cond)
[13:21:33.056]                           for (restart in restarts) {
[13:21:33.056]                             name <- restart$name
[13:21:33.056]                             if (is.null(name)) 
[13:21:33.056]                               next
[13:21:33.056]                             if (!grepl(pattern, name)) 
[13:21:33.056]                               next
[13:21:33.056]                             invokeRestart(restart)
[13:21:33.056]                             muffled <- TRUE
[13:21:33.056]                             break
[13:21:33.056]                           }
[13:21:33.056]                         }
[13:21:33.056]                       }
[13:21:33.056]                       invisible(muffled)
[13:21:33.056]                     }
[13:21:33.056]                     muffleCondition(cond, pattern = "^muffle")
[13:21:33.056]                   }
[13:21:33.056]                 }
[13:21:33.056]             }
[13:21:33.056]         }))
[13:21:33.056]     }, error = function(ex) {
[13:21:33.056]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:33.056]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:33.056]                 ...future.rng), started = ...future.startTime, 
[13:21:33.056]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:33.056]             version = "1.8"), class = "FutureResult")
[13:21:33.056]     }, finally = {
[13:21:33.056]         if (!identical(...future.workdir, getwd())) 
[13:21:33.056]             setwd(...future.workdir)
[13:21:33.056]         {
[13:21:33.056]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:33.056]                 ...future.oldOptions$nwarnings <- NULL
[13:21:33.056]             }
[13:21:33.056]             base::options(...future.oldOptions)
[13:21:33.056]             if (.Platform$OS.type == "windows") {
[13:21:33.056]                 old_names <- names(...future.oldEnvVars)
[13:21:33.056]                 envs <- base::Sys.getenv()
[13:21:33.056]                 names <- names(envs)
[13:21:33.056]                 common <- intersect(names, old_names)
[13:21:33.056]                 added <- setdiff(names, old_names)
[13:21:33.056]                 removed <- setdiff(old_names, names)
[13:21:33.056]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:33.056]                   envs[common]]
[13:21:33.056]                 NAMES <- toupper(changed)
[13:21:33.056]                 args <- list()
[13:21:33.056]                 for (kk in seq_along(NAMES)) {
[13:21:33.056]                   name <- changed[[kk]]
[13:21:33.056]                   NAME <- NAMES[[kk]]
[13:21:33.056]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.056]                     next
[13:21:33.056]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:33.056]                 }
[13:21:33.056]                 NAMES <- toupper(added)
[13:21:33.056]                 for (kk in seq_along(NAMES)) {
[13:21:33.056]                   name <- added[[kk]]
[13:21:33.056]                   NAME <- NAMES[[kk]]
[13:21:33.056]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.056]                     next
[13:21:33.056]                   args[[name]] <- ""
[13:21:33.056]                 }
[13:21:33.056]                 NAMES <- toupper(removed)
[13:21:33.056]                 for (kk in seq_along(NAMES)) {
[13:21:33.056]                   name <- removed[[kk]]
[13:21:33.056]                   NAME <- NAMES[[kk]]
[13:21:33.056]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.056]                     next
[13:21:33.056]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:33.056]                 }
[13:21:33.056]                 if (length(args) > 0) 
[13:21:33.056]                   base::do.call(base::Sys.setenv, args = args)
[13:21:33.056]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:33.056]             }
[13:21:33.056]             else {
[13:21:33.056]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:33.056]             }
[13:21:33.056]             {
[13:21:33.056]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:33.056]                   0L) {
[13:21:33.056]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:33.056]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:33.056]                   base::options(opts)
[13:21:33.056]                 }
[13:21:33.056]                 {
[13:21:33.056]                   {
[13:21:33.056]                     NULL
[13:21:33.056]                     RNGkind("Mersenne-Twister")
[13:21:33.056]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:33.056]                       inherits = FALSE)
[13:21:33.056]                   }
[13:21:33.056]                   options(future.plan = NULL)
[13:21:33.056]                   if (is.na(NA_character_)) 
[13:21:33.056]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:33.056]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:33.056]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:33.056]                   {
[13:21:33.056]                     future <- SequentialFuture(..., envir = envir)
[13:21:33.056]                     if (!future$lazy) 
[13:21:33.056]                       future <- run(future)
[13:21:33.056]                     invisible(future)
[13:21:33.056]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:33.056]                 }
[13:21:33.056]             }
[13:21:33.056]         }
[13:21:33.056]     })
[13:21:33.056]     if (TRUE) {
[13:21:33.056]         base::sink(type = "output", split = FALSE)
[13:21:33.056]         if (TRUE) {
[13:21:33.056]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:33.056]         }
[13:21:33.056]         else {
[13:21:33.056]             ...future.result["stdout"] <- base::list(NULL)
[13:21:33.056]         }
[13:21:33.056]         base::close(...future.stdout)
[13:21:33.056]         ...future.stdout <- NULL
[13:21:33.056]     }
[13:21:33.056]     ...future.result$conditions <- ...future.conditions
[13:21:33.056]     ...future.result$finished <- base::Sys.time()
[13:21:33.056]     ...future.result
[13:21:33.056] }
[13:21:33.058] assign_globals() ...
[13:21:33.058] List of 5
[13:21:33.058]  $ ...future.FUN            :function (x, y)  
[13:21:33.058]  $ future.call.arguments    :List of 1
[13:21:33.058]   ..$ y: num [1:5] 2 4 6 8 10
[13:21:33.058]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:33.058]  $ ...future.elements_ii    :List of 4
[13:21:33.058]   ..$ A: num 50
[13:21:33.058]   ..$ B: num 60
[13:21:33.058]   ..$ C: num 70
[13:21:33.058]   ..$ D: num 80
[13:21:33.058]  $ ...future.seeds_ii       : NULL
[13:21:33.058]  $ ...future.globals.maxSize: NULL
[13:21:33.058]  - attr(*, "where")=List of 5
[13:21:33.058]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:33.058]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:33.058]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:33.058]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:33.058]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:33.058]  - attr(*, "resolved")= logi FALSE
[13:21:33.058]  - attr(*, "total_size")= num 4264
[13:21:33.058]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:33.058]  - attr(*, "already-done")= logi TRUE
[13:21:33.064] - reassign environment for ‘...future.FUN’
[13:21:33.065] - copied ‘...future.FUN’ to environment
[13:21:33.065] - copied ‘future.call.arguments’ to environment
[13:21:33.065] - copied ‘...future.elements_ii’ to environment
[13:21:33.065] - copied ‘...future.seeds_ii’ to environment
[13:21:33.065] - copied ‘...future.globals.maxSize’ to environment
[13:21:33.065] assign_globals() ... done
[13:21:33.065] plan(): Setting new future strategy stack:
[13:21:33.066] List of future strategies:
[13:21:33.066] 1. sequential:
[13:21:33.066]    - args: function (..., envir = parent.frame())
[13:21:33.066]    - tweaked: FALSE
[13:21:33.066]    - call: NULL
[13:21:33.066] plan(): nbrOfWorkers() = 1
[13:21:33.067] plan(): Setting new future strategy stack:
[13:21:33.067] List of future strategies:
[13:21:33.067] 1. sequential:
[13:21:33.067]    - args: function (..., envir = parent.frame())
[13:21:33.067]    - tweaked: FALSE
[13:21:33.067]    - call: plan(strategy)
[13:21:33.067] plan(): nbrOfWorkers() = 1
[13:21:33.067] SequentialFuture started (and completed)
[13:21:33.067] - Launch lazy future ... done
[13:21:33.068] run() for ‘SequentialFuture’ ... done
[13:21:33.068] Created future:
[13:21:33.068] SequentialFuture:
[13:21:33.068] Label: ‘future_sapply-1’
[13:21:33.068] Expression:
[13:21:33.068] {
[13:21:33.068]     do.call(function(...) {
[13:21:33.068]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.068]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:33.068]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.068]             on.exit(options(oopts), add = TRUE)
[13:21:33.068]         }
[13:21:33.068]         {
[13:21:33.068]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:33.068]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.068]                 ...future.FUN(...future.X_jj, ...)
[13:21:33.068]             })
[13:21:33.068]         }
[13:21:33.068]     }, args = future.call.arguments)
[13:21:33.068] }
[13:21:33.068] Lazy evaluation: FALSE
[13:21:33.068] Asynchronous evaluation: FALSE
[13:21:33.068] Local evaluation: TRUE
[13:21:33.068] Environment: R_GlobalEnv
[13:21:33.068] Capture standard output: TRUE
[13:21:33.068] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:33.068] Globals: 5 objects totaling 4.38 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:21:33.068] Packages: <none>
[13:21:33.068] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:33.068] Resolved: TRUE
[13:21:33.068] Value: 1.34 KiB of class ‘list’
[13:21:33.068] Early signaling: FALSE
[13:21:33.068] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:33.068] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:33.069] Chunk #1 of 1 ... DONE
[13:21:33.069] Launching 1 futures (chunks) ... DONE
[13:21:33.069] Resolving 1 futures (chunks) ...
[13:21:33.069] resolve() on list ...
[13:21:33.069]  recursive: 0
[13:21:33.069]  length: 1
[13:21:33.070] 
[13:21:33.070] resolved() for ‘SequentialFuture’ ...
[13:21:33.070] - state: ‘finished’
[13:21:33.070] - run: TRUE
[13:21:33.070] - result: ‘FutureResult’
[13:21:33.070] resolved() for ‘SequentialFuture’ ... done
[13:21:33.070] Future #1
[13:21:33.070] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:21:33.070] - nx: 1
[13:21:33.070] - relay: TRUE
[13:21:33.071] - stdout: TRUE
[13:21:33.071] - signal: TRUE
[13:21:33.071] - resignal: FALSE
[13:21:33.071] - force: TRUE
[13:21:33.071] - relayed: [n=1] FALSE
[13:21:33.071] - queued futures: [n=1] FALSE
[13:21:33.071]  - until=1
[13:21:33.071]  - relaying element #1
[13:21:33.071] - relayed: [n=1] TRUE
[13:21:33.071] - queued futures: [n=1] TRUE
[13:21:33.072] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:21:33.072]  length: 0 (resolved future 1)
[13:21:33.072] Relaying remaining futures
[13:21:33.072] signalConditionsASAP(NULL, pos=0) ...
[13:21:33.072] - nx: 1
[13:21:33.072] - relay: TRUE
[13:21:33.072] - stdout: TRUE
[13:21:33.072] - signal: TRUE
[13:21:33.072] - resignal: FALSE
[13:21:33.072] - force: TRUE
[13:21:33.073] - relayed: [n=1] TRUE
[13:21:33.073] - queued futures: [n=1] TRUE
 - flush all
[13:21:33.073] - relayed: [n=1] TRUE
[13:21:33.073] - queued futures: [n=1] TRUE
[13:21:33.073] signalConditionsASAP(NULL, pos=0) ... done
[13:21:33.075] resolve() on list ... DONE
[13:21:33.075]  - Number of value chunks collected: 1
[13:21:33.075] Resolving 1 futures (chunks) ... DONE
[13:21:33.075] Reducing values from 1 chunks ...
[13:21:33.075]  - Number of values collected after concatenation: 4
[13:21:33.075]  - Number of values expected: 4
[13:21:33.075] Reducing values from 1 chunks ... DONE
[13:21:33.076] future_lapply() ... DONE
[13:21:33.076] future_lapply() ...
[13:21:33.078] Number of chunks: 1
[13:21:33.078] getGlobalsAndPackagesXApply() ...
[13:21:33.078]  - future.globals: TRUE
[13:21:33.078] getGlobalsAndPackages() ...
[13:21:33.079] Searching for globals...
[13:21:33.082] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[13:21:33.082] Searching for globals ... DONE
[13:21:33.082] Resolving globals: FALSE
[13:21:33.083] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[13:21:33.084] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:33.084] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:33.084] - packages: [1] ‘future.apply’
[13:21:33.084] getGlobalsAndPackages() ... DONE
[13:21:33.084]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:33.084]  - needed namespaces: [n=1] ‘future.apply’
[13:21:33.085] Finding globals ... DONE
[13:21:33.085]  - use_args: TRUE
[13:21:33.085]  - Getting '...' globals ...
[13:21:33.085] resolve() on list ...
[13:21:33.085]  recursive: 0
[13:21:33.085]  length: 1
[13:21:33.085]  elements: ‘...’
[13:21:33.085]  length: 0 (resolved future 1)
[13:21:33.086] resolve() on list ... DONE
[13:21:33.086]    - '...' content: [n=1] ‘y’
[13:21:33.086] List of 1
[13:21:33.086]  $ ...:List of 1
[13:21:33.086]   ..$ y: num [1:5] 2 4 6 8 10
[13:21:33.086]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:33.086]  - attr(*, "where")=List of 1
[13:21:33.086]   ..$ ...:<environment: 0x563b6ef88c98> 
[13:21:33.086]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:33.086]  - attr(*, "resolved")= logi TRUE
[13:21:33.086]  - attr(*, "total_size")= num NA
[13:21:33.089]  - Getting '...' globals ... DONE
[13:21:33.089] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:33.089] List of 8
[13:21:33.089]  $ ...future.FUN:function (x, ...)  
[13:21:33.089]  $ x_FUN        :function (x, y)  
[13:21:33.089]  $ times        : int 15
[13:21:33.089]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:33.089]  $ stop_if_not  :function (...)  
[13:21:33.089]  $ dim          : int [1:2] 3 5
[13:21:33.089]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:21:33.089]  $ ...          :List of 1
[13:21:33.089]   ..$ y: num [1:5] 2 4 6 8 10
[13:21:33.089]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:33.089]  - attr(*, "where")=List of 8
[13:21:33.089]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:33.089]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:33.089]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:33.089]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:33.089]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:33.089]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:33.089]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:33.089]   ..$ ...          :<environment: 0x563b6ef88c98> 
[13:21:33.089]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:33.089]  - attr(*, "resolved")= logi FALSE
[13:21:33.089]  - attr(*, "total_size")= num 98600
[13:21:33.097] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:21:33.097] getGlobalsAndPackagesXApply() ... DONE
[13:21:33.097] Number of futures (= number of chunks): 1
[13:21:33.097] Launching 1 futures (chunks) ...
[13:21:33.097] Chunk #1 of 1 ...
[13:21:33.097]  - Finding globals in 'X' for chunk #1 ...
[13:21:33.097] getGlobalsAndPackages() ...
[13:21:33.098] Searching for globals...
[13:21:33.098] 
[13:21:33.098] Searching for globals ... DONE
[13:21:33.098] - globals: [0] <none>
[13:21:33.098] getGlobalsAndPackages() ... DONE
[13:21:33.098]    + additional globals found: [n=0] 
[13:21:33.098]    + additional namespaces needed: [n=0] 
[13:21:33.099]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:33.099]  - seeds: <none>
[13:21:33.099]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.099] getGlobalsAndPackages() ...
[13:21:33.099] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.099] Resolving globals: FALSE
[13:21:33.099] Tweak future expression to call with '...' arguments ...
[13:21:33.099] {
[13:21:33.099]     do.call(function(...) {
[13:21:33.099]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.099]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:33.099]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.099]             on.exit(options(oopts), add = TRUE)
[13:21:33.099]         }
[13:21:33.099]         {
[13:21:33.099]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:33.099]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.099]                 ...future.FUN(...future.X_jj, ...)
[13:21:33.099]             })
[13:21:33.099]         }
[13:21:33.099]     }, args = future.call.arguments)
[13:21:33.099] }
[13:21:33.100] Tweak future expression to call with '...' arguments ... DONE
[13:21:33.100] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.100] - packages: [1] ‘future.apply’
[13:21:33.100] getGlobalsAndPackages() ... DONE
[13:21:33.101] run() for ‘Future’ ...
[13:21:33.101] - state: ‘created’
[13:21:33.101] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:33.101] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:33.101] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:33.101]   - Field: ‘label’
[13:21:33.101]   - Field: ‘local’
[13:21:33.102]   - Field: ‘owner’
[13:21:33.102]   - Field: ‘envir’
[13:21:33.102]   - Field: ‘packages’
[13:21:33.102]   - Field: ‘gc’
[13:21:33.102]   - Field: ‘conditions’
[13:21:33.102]   - Field: ‘expr’
[13:21:33.102]   - Field: ‘uuid’
[13:21:33.102]   - Field: ‘seed’
[13:21:33.102]   - Field: ‘version’
[13:21:33.102]   - Field: ‘result’
[13:21:33.102]   - Field: ‘asynchronous’
[13:21:33.103]   - Field: ‘calls’
[13:21:33.103]   - Field: ‘globals’
[13:21:33.103]   - Field: ‘stdout’
[13:21:33.103]   - Field: ‘earlySignal’
[13:21:33.103]   - Field: ‘lazy’
[13:21:33.103]   - Field: ‘state’
[13:21:33.103] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:33.103] - Launch lazy future ...
[13:21:33.103] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:33.104] Packages needed by future strategies (n = 0): <none>
[13:21:33.104] {
[13:21:33.104]     {
[13:21:33.104]         {
[13:21:33.104]             ...future.startTime <- base::Sys.time()
[13:21:33.104]             {
[13:21:33.104]                 {
[13:21:33.104]                   {
[13:21:33.104]                     {
[13:21:33.104]                       base::local({
[13:21:33.104]                         has_future <- base::requireNamespace("future", 
[13:21:33.104]                           quietly = TRUE)
[13:21:33.104]                         if (has_future) {
[13:21:33.104]                           ns <- base::getNamespace("future")
[13:21:33.104]                           version <- ns[[".package"]][["version"]]
[13:21:33.104]                           if (is.null(version)) 
[13:21:33.104]                             version <- utils::packageVersion("future")
[13:21:33.104]                         }
[13:21:33.104]                         else {
[13:21:33.104]                           version <- NULL
[13:21:33.104]                         }
[13:21:33.104]                         if (!has_future || version < "1.8.0") {
[13:21:33.104]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:33.104]                             "", base::R.version$version.string), 
[13:21:33.104]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:33.104]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:33.104]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:33.104]                               "release", "version")], collapse = " "), 
[13:21:33.104]                             hostname = base::Sys.info()[["nodename"]])
[13:21:33.104]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:33.104]                             info)
[13:21:33.104]                           info <- base::paste(info, collapse = "; ")
[13:21:33.104]                           if (!has_future) {
[13:21:33.104]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:33.104]                               info)
[13:21:33.104]                           }
[13:21:33.104]                           else {
[13:21:33.104]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:33.104]                               info, version)
[13:21:33.104]                           }
[13:21:33.104]                           base::stop(msg)
[13:21:33.104]                         }
[13:21:33.104]                       })
[13:21:33.104]                     }
[13:21:33.104]                     base::local({
[13:21:33.104]                       for (pkg in "future.apply") {
[13:21:33.104]                         base::loadNamespace(pkg)
[13:21:33.104]                         base::library(pkg, character.only = TRUE)
[13:21:33.104]                       }
[13:21:33.104]                     })
[13:21:33.104]                   }
[13:21:33.104]                   options(future.plan = NULL)
[13:21:33.104]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:33.104]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:33.104]                 }
[13:21:33.104]                 ...future.workdir <- getwd()
[13:21:33.104]             }
[13:21:33.104]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:33.104]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:33.104]         }
[13:21:33.104]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:33.104]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:33.104]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:33.104]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:33.104]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:33.104]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:33.104]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:33.104]             base::names(...future.oldOptions))
[13:21:33.104]     }
[13:21:33.104]     if (FALSE) {
[13:21:33.104]     }
[13:21:33.104]     else {
[13:21:33.104]         if (TRUE) {
[13:21:33.104]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:33.104]                 open = "w")
[13:21:33.104]         }
[13:21:33.104]         else {
[13:21:33.104]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:33.104]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:33.104]         }
[13:21:33.104]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:33.104]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:33.104]             base::sink(type = "output", split = FALSE)
[13:21:33.104]             base::close(...future.stdout)
[13:21:33.104]         }, add = TRUE)
[13:21:33.104]     }
[13:21:33.104]     ...future.frame <- base::sys.nframe()
[13:21:33.104]     ...future.conditions <- base::list()
[13:21:33.104]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:33.104]     if (FALSE) {
[13:21:33.104]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:33.104]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:33.104]     }
[13:21:33.104]     ...future.result <- base::tryCatch({
[13:21:33.104]         base::withCallingHandlers({
[13:21:33.104]             ...future.value <- base::withVisible(base::local({
[13:21:33.104]                 do.call(function(...) {
[13:21:33.104]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.104]                   if (!identical(...future.globals.maxSize.org, 
[13:21:33.104]                     ...future.globals.maxSize)) {
[13:21:33.104]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.104]                     on.exit(options(oopts), add = TRUE)
[13:21:33.104]                   }
[13:21:33.104]                   {
[13:21:33.104]                     lapply(seq_along(...future.elements_ii), 
[13:21:33.104]                       FUN = function(jj) {
[13:21:33.104]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.104]                         ...future.FUN(...future.X_jj, ...)
[13:21:33.104]                       })
[13:21:33.104]                   }
[13:21:33.104]                 }, args = future.call.arguments)
[13:21:33.104]             }))
[13:21:33.104]             future::FutureResult(value = ...future.value$value, 
[13:21:33.104]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:33.104]                   ...future.rng), globalenv = if (FALSE) 
[13:21:33.104]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:33.104]                     ...future.globalenv.names))
[13:21:33.104]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:33.104]         }, condition = base::local({
[13:21:33.104]             c <- base::c
[13:21:33.104]             inherits <- base::inherits
[13:21:33.104]             invokeRestart <- base::invokeRestart
[13:21:33.104]             length <- base::length
[13:21:33.104]             list <- base::list
[13:21:33.104]             seq.int <- base::seq.int
[13:21:33.104]             signalCondition <- base::signalCondition
[13:21:33.104]             sys.calls <- base::sys.calls
[13:21:33.104]             `[[` <- base::`[[`
[13:21:33.104]             `+` <- base::`+`
[13:21:33.104]             `<<-` <- base::`<<-`
[13:21:33.104]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:33.104]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:33.104]                   3L)]
[13:21:33.104]             }
[13:21:33.104]             function(cond) {
[13:21:33.104]                 is_error <- inherits(cond, "error")
[13:21:33.104]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:33.104]                   NULL)
[13:21:33.104]                 if (is_error) {
[13:21:33.104]                   sessionInformation <- function() {
[13:21:33.104]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:33.104]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:33.104]                       search = base::search(), system = base::Sys.info())
[13:21:33.104]                   }
[13:21:33.104]                   ...future.conditions[[length(...future.conditions) + 
[13:21:33.104]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:33.104]                     cond$call), session = sessionInformation(), 
[13:21:33.104]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:33.104]                   signalCondition(cond)
[13:21:33.104]                 }
[13:21:33.104]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:33.104]                 "immediateCondition"))) {
[13:21:33.104]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:33.104]                   ...future.conditions[[length(...future.conditions) + 
[13:21:33.104]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:33.104]                   if (TRUE && !signal) {
[13:21:33.104]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.104]                     {
[13:21:33.104]                       inherits <- base::inherits
[13:21:33.104]                       invokeRestart <- base::invokeRestart
[13:21:33.104]                       is.null <- base::is.null
[13:21:33.104]                       muffled <- FALSE
[13:21:33.104]                       if (inherits(cond, "message")) {
[13:21:33.104]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:33.104]                         if (muffled) 
[13:21:33.104]                           invokeRestart("muffleMessage")
[13:21:33.104]                       }
[13:21:33.104]                       else if (inherits(cond, "warning")) {
[13:21:33.104]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:33.104]                         if (muffled) 
[13:21:33.104]                           invokeRestart("muffleWarning")
[13:21:33.104]                       }
[13:21:33.104]                       else if (inherits(cond, "condition")) {
[13:21:33.104]                         if (!is.null(pattern)) {
[13:21:33.104]                           computeRestarts <- base::computeRestarts
[13:21:33.104]                           grepl <- base::grepl
[13:21:33.104]                           restarts <- computeRestarts(cond)
[13:21:33.104]                           for (restart in restarts) {
[13:21:33.104]                             name <- restart$name
[13:21:33.104]                             if (is.null(name)) 
[13:21:33.104]                               next
[13:21:33.104]                             if (!grepl(pattern, name)) 
[13:21:33.104]                               next
[13:21:33.104]                             invokeRestart(restart)
[13:21:33.104]                             muffled <- TRUE
[13:21:33.104]                             break
[13:21:33.104]                           }
[13:21:33.104]                         }
[13:21:33.104]                       }
[13:21:33.104]                       invisible(muffled)
[13:21:33.104]                     }
[13:21:33.104]                     muffleCondition(cond, pattern = "^muffle")
[13:21:33.104]                   }
[13:21:33.104]                 }
[13:21:33.104]                 else {
[13:21:33.104]                   if (TRUE) {
[13:21:33.104]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.104]                     {
[13:21:33.104]                       inherits <- base::inherits
[13:21:33.104]                       invokeRestart <- base::invokeRestart
[13:21:33.104]                       is.null <- base::is.null
[13:21:33.104]                       muffled <- FALSE
[13:21:33.104]                       if (inherits(cond, "message")) {
[13:21:33.104]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:33.104]                         if (muffled) 
[13:21:33.104]                           invokeRestart("muffleMessage")
[13:21:33.104]                       }
[13:21:33.104]                       else if (inherits(cond, "warning")) {
[13:21:33.104]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:33.104]                         if (muffled) 
[13:21:33.104]                           invokeRestart("muffleWarning")
[13:21:33.104]                       }
[13:21:33.104]                       else if (inherits(cond, "condition")) {
[13:21:33.104]                         if (!is.null(pattern)) {
[13:21:33.104]                           computeRestarts <- base::computeRestarts
[13:21:33.104]                           grepl <- base::grepl
[13:21:33.104]                           restarts <- computeRestarts(cond)
[13:21:33.104]                           for (restart in restarts) {
[13:21:33.104]                             name <- restart$name
[13:21:33.104]                             if (is.null(name)) 
[13:21:33.104]                               next
[13:21:33.104]                             if (!grepl(pattern, name)) 
[13:21:33.104]                               next
[13:21:33.104]                             invokeRestart(restart)
[13:21:33.104]                             muffled <- TRUE
[13:21:33.104]                             break
[13:21:33.104]                           }
[13:21:33.104]                         }
[13:21:33.104]                       }
[13:21:33.104]                       invisible(muffled)
[13:21:33.104]                     }
[13:21:33.104]                     muffleCondition(cond, pattern = "^muffle")
[13:21:33.104]                   }
[13:21:33.104]                 }
[13:21:33.104]             }
[13:21:33.104]         }))
[13:21:33.104]     }, error = function(ex) {
[13:21:33.104]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:33.104]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:33.104]                 ...future.rng), started = ...future.startTime, 
[13:21:33.104]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:33.104]             version = "1.8"), class = "FutureResult")
[13:21:33.104]     }, finally = {
[13:21:33.104]         if (!identical(...future.workdir, getwd())) 
[13:21:33.104]             setwd(...future.workdir)
[13:21:33.104]         {
[13:21:33.104]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:33.104]                 ...future.oldOptions$nwarnings <- NULL
[13:21:33.104]             }
[13:21:33.104]             base::options(...future.oldOptions)
[13:21:33.104]             if (.Platform$OS.type == "windows") {
[13:21:33.104]                 old_names <- names(...future.oldEnvVars)
[13:21:33.104]                 envs <- base::Sys.getenv()
[13:21:33.104]                 names <- names(envs)
[13:21:33.104]                 common <- intersect(names, old_names)
[13:21:33.104]                 added <- setdiff(names, old_names)
[13:21:33.104]                 removed <- setdiff(old_names, names)
[13:21:33.104]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:33.104]                   envs[common]]
[13:21:33.104]                 NAMES <- toupper(changed)
[13:21:33.104]                 args <- list()
[13:21:33.104]                 for (kk in seq_along(NAMES)) {
[13:21:33.104]                   name <- changed[[kk]]
[13:21:33.104]                   NAME <- NAMES[[kk]]
[13:21:33.104]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.104]                     next
[13:21:33.104]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:33.104]                 }
[13:21:33.104]                 NAMES <- toupper(added)
[13:21:33.104]                 for (kk in seq_along(NAMES)) {
[13:21:33.104]                   name <- added[[kk]]
[13:21:33.104]                   NAME <- NAMES[[kk]]
[13:21:33.104]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.104]                     next
[13:21:33.104]                   args[[name]] <- ""
[13:21:33.104]                 }
[13:21:33.104]                 NAMES <- toupper(removed)
[13:21:33.104]                 for (kk in seq_along(NAMES)) {
[13:21:33.104]                   name <- removed[[kk]]
[13:21:33.104]                   NAME <- NAMES[[kk]]
[13:21:33.104]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.104]                     next
[13:21:33.104]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:33.104]                 }
[13:21:33.104]                 if (length(args) > 0) 
[13:21:33.104]                   base::do.call(base::Sys.setenv, args = args)
[13:21:33.104]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:33.104]             }
[13:21:33.104]             else {
[13:21:33.104]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:33.104]             }
[13:21:33.104]             {
[13:21:33.104]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:33.104]                   0L) {
[13:21:33.104]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:33.104]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:33.104]                   base::options(opts)
[13:21:33.104]                 }
[13:21:33.104]                 {
[13:21:33.104]                   {
[13:21:33.104]                     NULL
[13:21:33.104]                     RNGkind("Mersenne-Twister")
[13:21:33.104]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:33.104]                       inherits = FALSE)
[13:21:33.104]                   }
[13:21:33.104]                   options(future.plan = NULL)
[13:21:33.104]                   if (is.na(NA_character_)) 
[13:21:33.104]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:33.104]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:33.104]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:33.104]                   {
[13:21:33.104]                     future <- SequentialFuture(..., envir = envir)
[13:21:33.104]                     if (!future$lazy) 
[13:21:33.104]                       future <- run(future)
[13:21:33.104]                     invisible(future)
[13:21:33.104]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:33.104]                 }
[13:21:33.104]             }
[13:21:33.104]         }
[13:21:33.104]     })
[13:21:33.104]     if (TRUE) {
[13:21:33.104]         base::sink(type = "output", split = FALSE)
[13:21:33.104]         if (TRUE) {
[13:21:33.104]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:33.104]         }
[13:21:33.104]         else {
[13:21:33.104]             ...future.result["stdout"] <- base::list(NULL)
[13:21:33.104]         }
[13:21:33.104]         base::close(...future.stdout)
[13:21:33.104]         ...future.stdout <- NULL
[13:21:33.104]     }
[13:21:33.104]     ...future.result$conditions <- ...future.conditions
[13:21:33.104]     ...future.result$finished <- base::Sys.time()
[13:21:33.104]     ...future.result
[13:21:33.104] }
[13:21:33.106] assign_globals() ...
[13:21:33.106] List of 11
[13:21:33.106]  $ ...future.FUN            :function (x, ...)  
[13:21:33.106]  $ x_FUN                    :function (x, y)  
[13:21:33.106]  $ times                    : int 15
[13:21:33.106]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:33.106]  $ stop_if_not              :function (...)  
[13:21:33.106]  $ dim                      : int [1:2] 3 5
[13:21:33.106]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:21:33.106]  $ future.call.arguments    :List of 1
[13:21:33.106]   ..$ y: num [1:5] 2 4 6 8 10
[13:21:33.106]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:33.106]  $ ...future.elements_ii    :List of 4
[13:21:33.106]   ..$ A: num 50
[13:21:33.106]   ..$ B: num 60
[13:21:33.106]   ..$ C: num 70
[13:21:33.106]   ..$ D: num 80
[13:21:33.106]  $ ...future.seeds_ii       : NULL
[13:21:33.106]  $ ...future.globals.maxSize: NULL
[13:21:33.106]  - attr(*, "where")=List of 11
[13:21:33.106]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:33.106]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:33.106]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:33.106]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:33.106]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:33.106]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:33.106]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:33.106]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:33.106]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:33.106]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:33.106]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:33.106]  - attr(*, "resolved")= logi FALSE
[13:21:33.106]  - attr(*, "total_size")= num 98600
[13:21:33.106]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:33.106]  - attr(*, "already-done")= logi TRUE
[13:21:33.115] - copied ‘...future.FUN’ to environment
[13:21:33.115] - reassign environment for ‘x_FUN’
[13:21:33.115] - copied ‘x_FUN’ to environment
[13:21:33.116] - copied ‘times’ to environment
[13:21:33.116] - copied ‘stopf’ to environment
[13:21:33.116] - copied ‘stop_if_not’ to environment
[13:21:33.116] - copied ‘dim’ to environment
[13:21:33.116] - copied ‘valid_types’ to environment
[13:21:33.116] - copied ‘future.call.arguments’ to environment
[13:21:33.116] - copied ‘...future.elements_ii’ to environment
[13:21:33.116] - copied ‘...future.seeds_ii’ to environment
[13:21:33.116] - copied ‘...future.globals.maxSize’ to environment
[13:21:33.116] assign_globals() ... done
[13:21:33.117] plan(): Setting new future strategy stack:
[13:21:33.117] List of future strategies:
[13:21:33.117] 1. sequential:
[13:21:33.117]    - args: function (..., envir = parent.frame())
[13:21:33.117]    - tweaked: FALSE
[13:21:33.117]    - call: NULL
[13:21:33.117] plan(): nbrOfWorkers() = 1
[13:21:33.118] plan(): Setting new future strategy stack:
[13:21:33.118] List of future strategies:
[13:21:33.118] 1. sequential:
[13:21:33.118]    - args: function (..., envir = parent.frame())
[13:21:33.118]    - tweaked: FALSE
[13:21:33.118]    - call: plan(strategy)
[13:21:33.119] plan(): nbrOfWorkers() = 1
[13:21:33.119] SequentialFuture started (and completed)
[13:21:33.119] - Launch lazy future ... done
[13:21:33.121] run() for ‘SequentialFuture’ ... done
[13:21:33.121] Created future:
[13:21:33.121] SequentialFuture:
[13:21:33.121] Label: ‘future_vapply-1’
[13:21:33.121] Expression:
[13:21:33.121] {
[13:21:33.121]     do.call(function(...) {
[13:21:33.121]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.121]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:33.121]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.121]             on.exit(options(oopts), add = TRUE)
[13:21:33.121]         }
[13:21:33.121]         {
[13:21:33.121]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:33.121]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.121]                 ...future.FUN(...future.X_jj, ...)
[13:21:33.121]             })
[13:21:33.121]         }
[13:21:33.121]     }, args = future.call.arguments)
[13:21:33.121] }
[13:21:33.121] Lazy evaluation: FALSE
[13:21:33.121] Asynchronous evaluation: FALSE
[13:21:33.121] Local evaluation: TRUE
[13:21:33.121] Environment: R_GlobalEnv
[13:21:33.121] Capture standard output: TRUE
[13:21:33.121] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:33.121] Globals: 11 objects totaling 96.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:33.121] Packages: 1 packages (‘future.apply’)
[13:21:33.121] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:33.121] Resolved: TRUE
[13:21:33.121] Value: 1.34 KiB of class ‘list’
[13:21:33.121] Early signaling: FALSE
[13:21:33.121] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:33.121] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:33.123] Chunk #1 of 1 ... DONE
[13:21:33.123] Launching 1 futures (chunks) ... DONE
[13:21:33.123] Resolving 1 futures (chunks) ...
[13:21:33.123] resolve() on list ...
[13:21:33.123]  recursive: 0
[13:21:33.123]  length: 1
[13:21:33.123] 
[13:21:33.123] resolved() for ‘SequentialFuture’ ...
[13:21:33.123] - state: ‘finished’
[13:21:33.124] - run: TRUE
[13:21:33.124] - result: ‘FutureResult’
[13:21:33.124] resolved() for ‘SequentialFuture’ ... done
[13:21:33.124] Future #1
[13:21:33.124] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:21:33.124] - nx: 1
[13:21:33.124] - relay: TRUE
[13:21:33.124] - stdout: TRUE
[13:21:33.124] - signal: TRUE
[13:21:33.125] - resignal: FALSE
[13:21:33.125] - force: TRUE
[13:21:33.125] - relayed: [n=1] FALSE
[13:21:33.125] - queued futures: [n=1] FALSE
[13:21:33.125]  - until=1
[13:21:33.125]  - relaying element #1
[13:21:33.125] - relayed: [n=1] TRUE
[13:21:33.125] - queued futures: [n=1] TRUE
[13:21:33.125] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:21:33.126]  length: 0 (resolved future 1)
[13:21:33.126] Relaying remaining futures
[13:21:33.126] signalConditionsASAP(NULL, pos=0) ...
[13:21:33.126] - nx: 1
[13:21:33.126] - relay: TRUE
[13:21:33.126] - stdout: TRUE
[13:21:33.126] - signal: TRUE
[13:21:33.126] - resignal: FALSE
[13:21:33.126] - force: TRUE
[13:21:33.126] - relayed: [n=1] TRUE
[13:21:33.126] - queued futures: [n=1] TRUE
 - flush all
[13:21:33.127] - relayed: [n=1] TRUE
[13:21:33.127] - queued futures: [n=1] TRUE
[13:21:33.127] signalConditionsASAP(NULL, pos=0) ... done
[13:21:33.127] resolve() on list ... DONE
[13:21:33.127]  - Number of value chunks collected: 1
[13:21:33.127] Resolving 1 futures (chunks) ... DONE
[13:21:33.127] Reducing values from 1 chunks ...
[13:21:33.127]  - Number of values collected after concatenation: 4
[13:21:33.127]  - Number of values expected: 4
[13:21:33.127] Reducing values from 1 chunks ... DONE
[13:21:33.128] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[13:21:33.130] future_lapply() ...
[13:21:33.131] Number of chunks: 1
[13:21:33.132] getGlobalsAndPackagesXApply() ...
[13:21:33.132]  - future.globals: TRUE
[13:21:33.132] getGlobalsAndPackages() ...
[13:21:33.132] Searching for globals...
[13:21:33.135] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:21:33.135] Searching for globals ... DONE
[13:21:33.135] Resolving globals: FALSE
[13:21:33.136] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[13:21:33.136] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:33.137] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:33.137] - packages: [1] ‘future.apply’
[13:21:33.137] getGlobalsAndPackages() ... DONE
[13:21:33.137]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:33.137]  - needed namespaces: [n=1] ‘future.apply’
[13:21:33.137] Finding globals ... DONE
[13:21:33.137]  - use_args: TRUE
[13:21:33.137]  - Getting '...' globals ...
[13:21:33.138] resolve() on list ...
[13:21:33.138]  recursive: 0
[13:21:33.138]  length: 1
[13:21:33.138]  elements: ‘...’
[13:21:33.138]  length: 0 (resolved future 1)
[13:21:33.138] resolve() on list ... DONE
[13:21:33.138]    - '...' content: [n=0] 
[13:21:33.138] List of 1
[13:21:33.138]  $ ...: list()
[13:21:33.138]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:33.138]  - attr(*, "where")=List of 1
[13:21:33.138]   ..$ ...:<environment: 0x563b6d983cb0> 
[13:21:33.138]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:33.138]  - attr(*, "resolved")= logi TRUE
[13:21:33.138]  - attr(*, "total_size")= num NA
[13:21:33.141]  - Getting '...' globals ... DONE
[13:21:33.141] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:33.141] List of 8
[13:21:33.141]  $ ...future.FUN:function (x, ...)  
[13:21:33.141]  $ x_FUN        :function (x)  
[13:21:33.141]  $ times        : int 1
[13:21:33.141]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:33.141]  $ stop_if_not  :function (...)  
[13:21:33.141]  $ dim          : NULL
[13:21:33.141]  $ valid_types  : chr "logical"
[13:21:33.141]  $ ...          : list()
[13:21:33.141]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:33.141]  - attr(*, "where")=List of 8
[13:21:33.141]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:33.141]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:33.141]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:33.141]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:33.141]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:33.141]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:33.141]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:33.141]   ..$ ...          :<environment: 0x563b6d983cb0> 
[13:21:33.141]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:33.141]  - attr(*, "resolved")= logi FALSE
[13:21:33.141]  - attr(*, "total_size")= num 94200
[13:21:33.149] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:21:33.149] getGlobalsAndPackagesXApply() ... DONE
[13:21:33.149] Number of futures (= number of chunks): 1
[13:21:33.149] Launching 1 futures (chunks) ...
[13:21:33.149] Chunk #1 of 1 ...
[13:21:33.149]  - Finding globals in 'X' for chunk #1 ...
[13:21:33.149] getGlobalsAndPackages() ...
[13:21:33.150] Searching for globals...
[13:21:33.150] 
[13:21:33.150] Searching for globals ... DONE
[13:21:33.150] - globals: [0] <none>
[13:21:33.150] getGlobalsAndPackages() ... DONE
[13:21:33.150]    + additional globals found: [n=0] 
[13:21:33.150]    + additional namespaces needed: [n=0] 
[13:21:33.150]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:33.150]  - seeds: <none>
[13:21:33.151]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.151] getGlobalsAndPackages() ...
[13:21:33.151] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.151] Resolving globals: FALSE
[13:21:33.151] Tweak future expression to call with '...' arguments ...
[13:21:33.151] {
[13:21:33.151]     do.call(function(...) {
[13:21:33.151]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.151]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:33.151]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.151]             on.exit(options(oopts), add = TRUE)
[13:21:33.151]         }
[13:21:33.151]         {
[13:21:33.151]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:33.151]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.151]                 ...future.FUN(...future.X_jj, ...)
[13:21:33.151]             })
[13:21:33.151]         }
[13:21:33.151]     }, args = future.call.arguments)
[13:21:33.151] }
[13:21:33.151] Tweak future expression to call with '...' arguments ... DONE
[13:21:33.152] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.152] - packages: [1] ‘future.apply’
[13:21:33.152] getGlobalsAndPackages() ... DONE
[13:21:33.152] run() for ‘Future’ ...
[13:21:33.153] - state: ‘created’
[13:21:33.153] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:33.153] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:33.153] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:33.153]   - Field: ‘label’
[13:21:33.153]   - Field: ‘local’
[13:21:33.154]   - Field: ‘owner’
[13:21:33.154]   - Field: ‘envir’
[13:21:33.154]   - Field: ‘packages’
[13:21:33.154]   - Field: ‘gc’
[13:21:33.154]   - Field: ‘conditions’
[13:21:33.154]   - Field: ‘expr’
[13:21:33.154]   - Field: ‘uuid’
[13:21:33.154]   - Field: ‘seed’
[13:21:33.154]   - Field: ‘version’
[13:21:33.154]   - Field: ‘result’
[13:21:33.154]   - Field: ‘asynchronous’
[13:21:33.155]   - Field: ‘calls’
[13:21:33.155]   - Field: ‘globals’
[13:21:33.155]   - Field: ‘stdout’
[13:21:33.155]   - Field: ‘earlySignal’
[13:21:33.155]   - Field: ‘lazy’
[13:21:33.155]   - Field: ‘state’
[13:21:33.155] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:33.155] - Launch lazy future ...
[13:21:33.155] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:33.156] Packages needed by future strategies (n = 0): <none>
[13:21:33.156] {
[13:21:33.156]     {
[13:21:33.156]         {
[13:21:33.156]             ...future.startTime <- base::Sys.time()
[13:21:33.156]             {
[13:21:33.156]                 {
[13:21:33.156]                   {
[13:21:33.156]                     {
[13:21:33.156]                       base::local({
[13:21:33.156]                         has_future <- base::requireNamespace("future", 
[13:21:33.156]                           quietly = TRUE)
[13:21:33.156]                         if (has_future) {
[13:21:33.156]                           ns <- base::getNamespace("future")
[13:21:33.156]                           version <- ns[[".package"]][["version"]]
[13:21:33.156]                           if (is.null(version)) 
[13:21:33.156]                             version <- utils::packageVersion("future")
[13:21:33.156]                         }
[13:21:33.156]                         else {
[13:21:33.156]                           version <- NULL
[13:21:33.156]                         }
[13:21:33.156]                         if (!has_future || version < "1.8.0") {
[13:21:33.156]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:33.156]                             "", base::R.version$version.string), 
[13:21:33.156]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:33.156]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:33.156]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:33.156]                               "release", "version")], collapse = " "), 
[13:21:33.156]                             hostname = base::Sys.info()[["nodename"]])
[13:21:33.156]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:33.156]                             info)
[13:21:33.156]                           info <- base::paste(info, collapse = "; ")
[13:21:33.156]                           if (!has_future) {
[13:21:33.156]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:33.156]                               info)
[13:21:33.156]                           }
[13:21:33.156]                           else {
[13:21:33.156]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:33.156]                               info, version)
[13:21:33.156]                           }
[13:21:33.156]                           base::stop(msg)
[13:21:33.156]                         }
[13:21:33.156]                       })
[13:21:33.156]                     }
[13:21:33.156]                     base::local({
[13:21:33.156]                       for (pkg in "future.apply") {
[13:21:33.156]                         base::loadNamespace(pkg)
[13:21:33.156]                         base::library(pkg, character.only = TRUE)
[13:21:33.156]                       }
[13:21:33.156]                     })
[13:21:33.156]                   }
[13:21:33.156]                   options(future.plan = NULL)
[13:21:33.156]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:33.156]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:33.156]                 }
[13:21:33.156]                 ...future.workdir <- getwd()
[13:21:33.156]             }
[13:21:33.156]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:33.156]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:33.156]         }
[13:21:33.156]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:33.156]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:33.156]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:33.156]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:33.156]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:33.156]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:33.156]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:33.156]             base::names(...future.oldOptions))
[13:21:33.156]     }
[13:21:33.156]     if (FALSE) {
[13:21:33.156]     }
[13:21:33.156]     else {
[13:21:33.156]         if (TRUE) {
[13:21:33.156]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:33.156]                 open = "w")
[13:21:33.156]         }
[13:21:33.156]         else {
[13:21:33.156]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:33.156]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:33.156]         }
[13:21:33.156]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:33.156]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:33.156]             base::sink(type = "output", split = FALSE)
[13:21:33.156]             base::close(...future.stdout)
[13:21:33.156]         }, add = TRUE)
[13:21:33.156]     }
[13:21:33.156]     ...future.frame <- base::sys.nframe()
[13:21:33.156]     ...future.conditions <- base::list()
[13:21:33.156]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:33.156]     if (FALSE) {
[13:21:33.156]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:33.156]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:33.156]     }
[13:21:33.156]     ...future.result <- base::tryCatch({
[13:21:33.156]         base::withCallingHandlers({
[13:21:33.156]             ...future.value <- base::withVisible(base::local({
[13:21:33.156]                 do.call(function(...) {
[13:21:33.156]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.156]                   if (!identical(...future.globals.maxSize.org, 
[13:21:33.156]                     ...future.globals.maxSize)) {
[13:21:33.156]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.156]                     on.exit(options(oopts), add = TRUE)
[13:21:33.156]                   }
[13:21:33.156]                   {
[13:21:33.156]                     lapply(seq_along(...future.elements_ii), 
[13:21:33.156]                       FUN = function(jj) {
[13:21:33.156]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.156]                         ...future.FUN(...future.X_jj, ...)
[13:21:33.156]                       })
[13:21:33.156]                   }
[13:21:33.156]                 }, args = future.call.arguments)
[13:21:33.156]             }))
[13:21:33.156]             future::FutureResult(value = ...future.value$value, 
[13:21:33.156]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:33.156]                   ...future.rng), globalenv = if (FALSE) 
[13:21:33.156]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:33.156]                     ...future.globalenv.names))
[13:21:33.156]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:33.156]         }, condition = base::local({
[13:21:33.156]             c <- base::c
[13:21:33.156]             inherits <- base::inherits
[13:21:33.156]             invokeRestart <- base::invokeRestart
[13:21:33.156]             length <- base::length
[13:21:33.156]             list <- base::list
[13:21:33.156]             seq.int <- base::seq.int
[13:21:33.156]             signalCondition <- base::signalCondition
[13:21:33.156]             sys.calls <- base::sys.calls
[13:21:33.156]             `[[` <- base::`[[`
[13:21:33.156]             `+` <- base::`+`
[13:21:33.156]             `<<-` <- base::`<<-`
[13:21:33.156]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:33.156]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:33.156]                   3L)]
[13:21:33.156]             }
[13:21:33.156]             function(cond) {
[13:21:33.156]                 is_error <- inherits(cond, "error")
[13:21:33.156]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:33.156]                   NULL)
[13:21:33.156]                 if (is_error) {
[13:21:33.156]                   sessionInformation <- function() {
[13:21:33.156]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:33.156]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:33.156]                       search = base::search(), system = base::Sys.info())
[13:21:33.156]                   }
[13:21:33.156]                   ...future.conditions[[length(...future.conditions) + 
[13:21:33.156]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:33.156]                     cond$call), session = sessionInformation(), 
[13:21:33.156]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:33.156]                   signalCondition(cond)
[13:21:33.156]                 }
[13:21:33.156]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:33.156]                 "immediateCondition"))) {
[13:21:33.156]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:33.156]                   ...future.conditions[[length(...future.conditions) + 
[13:21:33.156]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:33.156]                   if (TRUE && !signal) {
[13:21:33.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.156]                     {
[13:21:33.156]                       inherits <- base::inherits
[13:21:33.156]                       invokeRestart <- base::invokeRestart
[13:21:33.156]                       is.null <- base::is.null
[13:21:33.156]                       muffled <- FALSE
[13:21:33.156]                       if (inherits(cond, "message")) {
[13:21:33.156]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:33.156]                         if (muffled) 
[13:21:33.156]                           invokeRestart("muffleMessage")
[13:21:33.156]                       }
[13:21:33.156]                       else if (inherits(cond, "warning")) {
[13:21:33.156]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:33.156]                         if (muffled) 
[13:21:33.156]                           invokeRestart("muffleWarning")
[13:21:33.156]                       }
[13:21:33.156]                       else if (inherits(cond, "condition")) {
[13:21:33.156]                         if (!is.null(pattern)) {
[13:21:33.156]                           computeRestarts <- base::computeRestarts
[13:21:33.156]                           grepl <- base::grepl
[13:21:33.156]                           restarts <- computeRestarts(cond)
[13:21:33.156]                           for (restart in restarts) {
[13:21:33.156]                             name <- restart$name
[13:21:33.156]                             if (is.null(name)) 
[13:21:33.156]                               next
[13:21:33.156]                             if (!grepl(pattern, name)) 
[13:21:33.156]                               next
[13:21:33.156]                             invokeRestart(restart)
[13:21:33.156]                             muffled <- TRUE
[13:21:33.156]                             break
[13:21:33.156]                           }
[13:21:33.156]                         }
[13:21:33.156]                       }
[13:21:33.156]                       invisible(muffled)
[13:21:33.156]                     }
[13:21:33.156]                     muffleCondition(cond, pattern = "^muffle")
[13:21:33.156]                   }
[13:21:33.156]                 }
[13:21:33.156]                 else {
[13:21:33.156]                   if (TRUE) {
[13:21:33.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.156]                     {
[13:21:33.156]                       inherits <- base::inherits
[13:21:33.156]                       invokeRestart <- base::invokeRestart
[13:21:33.156]                       is.null <- base::is.null
[13:21:33.156]                       muffled <- FALSE
[13:21:33.156]                       if (inherits(cond, "message")) {
[13:21:33.156]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:33.156]                         if (muffled) 
[13:21:33.156]                           invokeRestart("muffleMessage")
[13:21:33.156]                       }
[13:21:33.156]                       else if (inherits(cond, "warning")) {
[13:21:33.156]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:33.156]                         if (muffled) 
[13:21:33.156]                           invokeRestart("muffleWarning")
[13:21:33.156]                       }
[13:21:33.156]                       else if (inherits(cond, "condition")) {
[13:21:33.156]                         if (!is.null(pattern)) {
[13:21:33.156]                           computeRestarts <- base::computeRestarts
[13:21:33.156]                           grepl <- base::grepl
[13:21:33.156]                           restarts <- computeRestarts(cond)
[13:21:33.156]                           for (restart in restarts) {
[13:21:33.156]                             name <- restart$name
[13:21:33.156]                             if (is.null(name)) 
[13:21:33.156]                               next
[13:21:33.156]                             if (!grepl(pattern, name)) 
[13:21:33.156]                               next
[13:21:33.156]                             invokeRestart(restart)
[13:21:33.156]                             muffled <- TRUE
[13:21:33.156]                             break
[13:21:33.156]                           }
[13:21:33.156]                         }
[13:21:33.156]                       }
[13:21:33.156]                       invisible(muffled)
[13:21:33.156]                     }
[13:21:33.156]                     muffleCondition(cond, pattern = "^muffle")
[13:21:33.156]                   }
[13:21:33.156]                 }
[13:21:33.156]             }
[13:21:33.156]         }))
[13:21:33.156]     }, error = function(ex) {
[13:21:33.156]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:33.156]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:33.156]                 ...future.rng), started = ...future.startTime, 
[13:21:33.156]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:33.156]             version = "1.8"), class = "FutureResult")
[13:21:33.156]     }, finally = {
[13:21:33.156]         if (!identical(...future.workdir, getwd())) 
[13:21:33.156]             setwd(...future.workdir)
[13:21:33.156]         {
[13:21:33.156]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:33.156]                 ...future.oldOptions$nwarnings <- NULL
[13:21:33.156]             }
[13:21:33.156]             base::options(...future.oldOptions)
[13:21:33.156]             if (.Platform$OS.type == "windows") {
[13:21:33.156]                 old_names <- names(...future.oldEnvVars)
[13:21:33.156]                 envs <- base::Sys.getenv()
[13:21:33.156]                 names <- names(envs)
[13:21:33.156]                 common <- intersect(names, old_names)
[13:21:33.156]                 added <- setdiff(names, old_names)
[13:21:33.156]                 removed <- setdiff(old_names, names)
[13:21:33.156]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:33.156]                   envs[common]]
[13:21:33.156]                 NAMES <- toupper(changed)
[13:21:33.156]                 args <- list()
[13:21:33.156]                 for (kk in seq_along(NAMES)) {
[13:21:33.156]                   name <- changed[[kk]]
[13:21:33.156]                   NAME <- NAMES[[kk]]
[13:21:33.156]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.156]                     next
[13:21:33.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:33.156]                 }
[13:21:33.156]                 NAMES <- toupper(added)
[13:21:33.156]                 for (kk in seq_along(NAMES)) {
[13:21:33.156]                   name <- added[[kk]]
[13:21:33.156]                   NAME <- NAMES[[kk]]
[13:21:33.156]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.156]                     next
[13:21:33.156]                   args[[name]] <- ""
[13:21:33.156]                 }
[13:21:33.156]                 NAMES <- toupper(removed)
[13:21:33.156]                 for (kk in seq_along(NAMES)) {
[13:21:33.156]                   name <- removed[[kk]]
[13:21:33.156]                   NAME <- NAMES[[kk]]
[13:21:33.156]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.156]                     next
[13:21:33.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:33.156]                 }
[13:21:33.156]                 if (length(args) > 0) 
[13:21:33.156]                   base::do.call(base::Sys.setenv, args = args)
[13:21:33.156]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:33.156]             }
[13:21:33.156]             else {
[13:21:33.156]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:33.156]             }
[13:21:33.156]             {
[13:21:33.156]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:33.156]                   0L) {
[13:21:33.156]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:33.156]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:33.156]                   base::options(opts)
[13:21:33.156]                 }
[13:21:33.156]                 {
[13:21:33.156]                   {
[13:21:33.156]                     NULL
[13:21:33.156]                     RNGkind("Mersenne-Twister")
[13:21:33.156]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:33.156]                       inherits = FALSE)
[13:21:33.156]                   }
[13:21:33.156]                   options(future.plan = NULL)
[13:21:33.156]                   if (is.na(NA_character_)) 
[13:21:33.156]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:33.156]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:33.156]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:33.156]                   {
[13:21:33.156]                     future <- SequentialFuture(..., envir = envir)
[13:21:33.156]                     if (!future$lazy) 
[13:21:33.156]                       future <- run(future)
[13:21:33.156]                     invisible(future)
[13:21:33.156]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:33.156]                 }
[13:21:33.156]             }
[13:21:33.156]         }
[13:21:33.156]     })
[13:21:33.156]     if (TRUE) {
[13:21:33.156]         base::sink(type = "output", split = FALSE)
[13:21:33.156]         if (TRUE) {
[13:21:33.156]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:33.156]         }
[13:21:33.156]         else {
[13:21:33.156]             ...future.result["stdout"] <- base::list(NULL)
[13:21:33.156]         }
[13:21:33.156]         base::close(...future.stdout)
[13:21:33.156]         ...future.stdout <- NULL
[13:21:33.156]     }
[13:21:33.156]     ...future.result$conditions <- ...future.conditions
[13:21:33.156]     ...future.result$finished <- base::Sys.time()
[13:21:33.156]     ...future.result
[13:21:33.156] }
[13:21:33.158] assign_globals() ...
[13:21:33.158] List of 11
[13:21:33.158]  $ ...future.FUN            :function (x, ...)  
[13:21:33.158]  $ x_FUN                    :function (x)  
[13:21:33.158]  $ times                    : int 1
[13:21:33.158]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:33.158]  $ stop_if_not              :function (...)  
[13:21:33.158]  $ dim                      : NULL
[13:21:33.158]  $ valid_types              : chr "logical"
[13:21:33.158]  $ future.call.arguments    : list()
[13:21:33.158]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:33.158]  $ ...future.elements_ii    :List of 11
[13:21:33.158]   ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
[13:21:33.158]   ..$ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ...
[13:21:33.158]   ..$ disp: num [1:32] 160 160 108 258 360 ...
[13:21:33.158]   ..$ hp  : num [1:32] 110 110 93 110 175 105 245 62 95 123 ...
[13:21:33.158]   ..$ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
[13:21:33.158]   ..$ wt  : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...
[13:21:33.158]   ..$ qsec: num [1:32] 16.5 17 18.6 19.4 17 ...
[13:21:33.158]   ..$ vs  : num [1:32] 0 0 1 1 0 1 0 1 1 1 ...
[13:21:33.158]   ..$ am  : num [1:32] 1 1 1 0 0 0 0 0 0 0 ...
[13:21:33.158]   ..$ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ...
[13:21:33.158]   ..$ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ...
[13:21:33.158]  $ ...future.seeds_ii       : NULL
[13:21:33.158]  $ ...future.globals.maxSize: NULL
[13:21:33.158]  - attr(*, "where")=List of 11
[13:21:33.158]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:33.158]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:33.158]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:33.158]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:33.158]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:33.158]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:33.158]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:33.158]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:33.158]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:33.158]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:33.158]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:33.158]  - attr(*, "resolved")= logi FALSE
[13:21:33.158]  - attr(*, "total_size")= num 94200
[13:21:33.158]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:33.158]  - attr(*, "already-done")= logi TRUE
[13:21:33.171] - copied ‘...future.FUN’ to environment
[13:21:33.171] - copied ‘x_FUN’ to environment
[13:21:33.171] - copied ‘times’ to environment
[13:21:33.171] - copied ‘stopf’ to environment
[13:21:33.171] - copied ‘stop_if_not’ to environment
[13:21:33.172] - copied ‘dim’ to environment
[13:21:33.172] - copied ‘valid_types’ to environment
[13:21:33.172] - copied ‘future.call.arguments’ to environment
[13:21:33.172] - copied ‘...future.elements_ii’ to environment
[13:21:33.172] - copied ‘...future.seeds_ii’ to environment
[13:21:33.172] - copied ‘...future.globals.maxSize’ to environment
[13:21:33.172] assign_globals() ... done
[13:21:33.173] plan(): Setting new future strategy stack:
[13:21:33.173] List of future strategies:
[13:21:33.173] 1. sequential:
[13:21:33.173]    - args: function (..., envir = parent.frame())
[13:21:33.173]    - tweaked: FALSE
[13:21:33.173]    - call: NULL
[13:21:33.173] plan(): nbrOfWorkers() = 1
[13:21:33.174] plan(): Setting new future strategy stack:
[13:21:33.174] List of future strategies:
[13:21:33.174] 1. sequential:
[13:21:33.174]    - args: function (..., envir = parent.frame())
[13:21:33.174]    - tweaked: FALSE
[13:21:33.174]    - call: plan(strategy)
[13:21:33.174] plan(): nbrOfWorkers() = 1
[13:21:33.175] SequentialFuture started (and completed)
[13:21:33.175] - Launch lazy future ... done
[13:21:33.175] run() for ‘SequentialFuture’ ... done
[13:21:33.175] Created future:
[13:21:33.175] SequentialFuture:
[13:21:33.175] Label: ‘future_vapply-1’
[13:21:33.175] Expression:
[13:21:33.175] {
[13:21:33.175]     do.call(function(...) {
[13:21:33.175]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.175]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:33.175]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.175]             on.exit(options(oopts), add = TRUE)
[13:21:33.175]         }
[13:21:33.175]         {
[13:21:33.175]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:33.175]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.175]                 ...future.FUN(...future.X_jj, ...)
[13:21:33.175]             })
[13:21:33.175]         }
[13:21:33.175]     }, args = future.call.arguments)
[13:21:33.175] }
[13:21:33.175] Lazy evaluation: FALSE
[13:21:33.175] Asynchronous evaluation: FALSE
[13:21:33.175] Local evaluation: TRUE
[13:21:33.175] Environment: R_GlobalEnv
[13:21:33.175] Capture standard output: TRUE
[13:21:33.175] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:33.175] Globals: 11 objects totaling 95.26 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:33.175] Packages: 1 packages (‘future.apply’)
[13:21:33.175] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:33.175] Resolved: TRUE
[13:21:33.175] Value: 616 bytes of class ‘list’
[13:21:33.175] Early signaling: FALSE
[13:21:33.175] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:33.175] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:33.176] Chunk #1 of 1 ... DONE
[13:21:33.176] Launching 1 futures (chunks) ... DONE
[13:21:33.176] Resolving 1 futures (chunks) ...
[13:21:33.177] resolve() on list ...
[13:21:33.177]  recursive: 0
[13:21:33.177]  length: 1
[13:21:33.177] 
[13:21:33.177] resolved() for ‘SequentialFuture’ ...
[13:21:33.177] - state: ‘finished’
[13:21:33.177] - run: TRUE
[13:21:33.177] - result: ‘FutureResult’
[13:21:33.177] resolved() for ‘SequentialFuture’ ... done
[13:21:33.177] Future #1
[13:21:33.178] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:21:33.178] - nx: 1
[13:21:33.178] - relay: TRUE
[13:21:33.178] - stdout: TRUE
[13:21:33.178] - signal: TRUE
[13:21:33.178] - resignal: FALSE
[13:21:33.178] - force: TRUE
[13:21:33.178] - relayed: [n=1] FALSE
[13:21:33.178] - queued futures: [n=1] FALSE
[13:21:33.178]  - until=1
[13:21:33.178]  - relaying element #1
[13:21:33.179] - relayed: [n=1] TRUE
[13:21:33.179] - queued futures: [n=1] TRUE
[13:21:33.179] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:21:33.179]  length: 0 (resolved future 1)
[13:21:33.179] Relaying remaining futures
[13:21:33.179] signalConditionsASAP(NULL, pos=0) ...
[13:21:33.179] - nx: 1
[13:21:33.179] - relay: TRUE
[13:21:33.179] - stdout: TRUE
[13:21:33.179] - signal: TRUE
[13:21:33.180] - resignal: FALSE
[13:21:33.180] - force: TRUE
[13:21:33.180] - relayed: [n=1] TRUE
[13:21:33.180] - queued futures: [n=1] TRUE
 - flush all
[13:21:33.180] - relayed: [n=1] TRUE
[13:21:33.180] - queued futures: [n=1] TRUE
[13:21:33.180] signalConditionsASAP(NULL, pos=0) ... done
[13:21:33.180] resolve() on list ... DONE
[13:21:33.180]  - Number of value chunks collected: 1
[13:21:33.180] Resolving 1 futures (chunks) ... DONE
[13:21:33.181] Reducing values from 1 chunks ...
[13:21:33.181]  - Number of values collected after concatenation: 11
[13:21:33.181]  - Number of values expected: 11
[13:21:33.181] Reducing values from 1 chunks ... DONE
[13:21:33.181] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[13:21:33.182] future_lapply() ...
[13:21:33.184] Number of chunks: 1
[13:21:33.184] getGlobalsAndPackagesXApply() ...
[13:21:33.184]  - future.globals: TRUE
[13:21:33.184] getGlobalsAndPackages() ...
[13:21:33.184] Searching for globals...
[13:21:33.187] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:21:33.187] Searching for globals ... DONE
[13:21:33.187] Resolving globals: FALSE
[13:21:33.190] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[13:21:33.190] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:33.190] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:33.191] - packages: [1] ‘future.apply’
[13:21:33.191] getGlobalsAndPackages() ... DONE
[13:21:33.191]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:33.191]  - needed namespaces: [n=1] ‘future.apply’
[13:21:33.191] Finding globals ... DONE
[13:21:33.191]  - use_args: TRUE
[13:21:33.191]  - Getting '...' globals ...
[13:21:33.192] resolve() on list ...
[13:21:33.192]  recursive: 0
[13:21:33.192]  length: 1
[13:21:33.192]  elements: ‘...’
[13:21:33.192]  length: 0 (resolved future 1)
[13:21:33.192] resolve() on list ... DONE
[13:21:33.192]    - '...' content: [n=0] 
[13:21:33.192] List of 1
[13:21:33.192]  $ ...: list()
[13:21:33.192]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:33.192]  - attr(*, "where")=List of 1
[13:21:33.192]   ..$ ...:<environment: 0x563b6ef383d8> 
[13:21:33.192]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:33.192]  - attr(*, "resolved")= logi TRUE
[13:21:33.192]  - attr(*, "total_size")= num NA
[13:21:33.195]  - Getting '...' globals ... DONE
[13:21:33.195] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:33.195] List of 8
[13:21:33.195]  $ ...future.FUN:function (x, ...)  
[13:21:33.195]  $ x_FUN        :function (x)  
[13:21:33.195]  $ times        : int 1
[13:21:33.195]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:33.195]  $ stop_if_not  :function (...)  
[13:21:33.195]  $ dim          : NULL
[13:21:33.195]  $ valid_types  : chr [1:2] "logical" "integer"
[13:21:33.195]  $ ...          : list()
[13:21:33.195]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:33.195]  - attr(*, "where")=List of 8
[13:21:33.195]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:33.195]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:33.195]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:33.195]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:33.195]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:33.195]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:33.195]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:33.195]   ..$ ...          :<environment: 0x563b6ef383d8> 
[13:21:33.195]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:33.195]  - attr(*, "resolved")= logi FALSE
[13:21:33.195]  - attr(*, "total_size")= num 94264
[13:21:33.201] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:21:33.201] getGlobalsAndPackagesXApply() ... DONE
[13:21:33.201] Number of futures (= number of chunks): 1
[13:21:33.201] Launching 1 futures (chunks) ...
[13:21:33.201] Chunk #1 of 1 ...
[13:21:33.201]  - Finding globals in 'X' for chunk #1 ...
[13:21:33.202] getGlobalsAndPackages() ...
[13:21:33.202] Searching for globals...
[13:21:33.202] 
[13:21:33.202] Searching for globals ... DONE
[13:21:33.202] - globals: [0] <none>
[13:21:33.202] getGlobalsAndPackages() ... DONE
[13:21:33.202]    + additional globals found: [n=0] 
[13:21:33.202]    + additional namespaces needed: [n=0] 
[13:21:33.203]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:33.203]  - seeds: <none>
[13:21:33.203]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.203] getGlobalsAndPackages() ...
[13:21:33.203] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.203] Resolving globals: FALSE
[13:21:33.203] Tweak future expression to call with '...' arguments ...
[13:21:33.203] {
[13:21:33.203]     do.call(function(...) {
[13:21:33.203]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.203]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:33.203]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.203]             on.exit(options(oopts), add = TRUE)
[13:21:33.203]         }
[13:21:33.203]         {
[13:21:33.203]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:33.203]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.203]                 ...future.FUN(...future.X_jj, ...)
[13:21:33.203]             })
[13:21:33.203]         }
[13:21:33.203]     }, args = future.call.arguments)
[13:21:33.203] }
[13:21:33.204] Tweak future expression to call with '...' arguments ... DONE
[13:21:33.204] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.204] - packages: [1] ‘future.apply’
[13:21:33.204] getGlobalsAndPackages() ... DONE
[13:21:33.205] run() for ‘Future’ ...
[13:21:33.205] - state: ‘created’
[13:21:33.205] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:33.205] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:33.205] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:33.205]   - Field: ‘label’
[13:21:33.206]   - Field: ‘local’
[13:21:33.206]   - Field: ‘owner’
[13:21:33.206]   - Field: ‘envir’
[13:21:33.206]   - Field: ‘packages’
[13:21:33.206]   - Field: ‘gc’
[13:21:33.206]   - Field: ‘conditions’
[13:21:33.206]   - Field: ‘expr’
[13:21:33.206]   - Field: ‘uuid’
[13:21:33.206]   - Field: ‘seed’
[13:21:33.206]   - Field: ‘version’
[13:21:33.206]   - Field: ‘result’
[13:21:33.207]   - Field: ‘asynchronous’
[13:21:33.207]   - Field: ‘calls’
[13:21:33.207]   - Field: ‘globals’
[13:21:33.207]   - Field: ‘stdout’
[13:21:33.207]   - Field: ‘earlySignal’
[13:21:33.207]   - Field: ‘lazy’
[13:21:33.207]   - Field: ‘state’
[13:21:33.207] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:33.207] - Launch lazy future ...
[13:21:33.208] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:33.208] Packages needed by future strategies (n = 0): <none>
[13:21:33.208] {
[13:21:33.208]     {
[13:21:33.208]         {
[13:21:33.208]             ...future.startTime <- base::Sys.time()
[13:21:33.208]             {
[13:21:33.208]                 {
[13:21:33.208]                   {
[13:21:33.208]                     {
[13:21:33.208]                       base::local({
[13:21:33.208]                         has_future <- base::requireNamespace("future", 
[13:21:33.208]                           quietly = TRUE)
[13:21:33.208]                         if (has_future) {
[13:21:33.208]                           ns <- base::getNamespace("future")
[13:21:33.208]                           version <- ns[[".package"]][["version"]]
[13:21:33.208]                           if (is.null(version)) 
[13:21:33.208]                             version <- utils::packageVersion("future")
[13:21:33.208]                         }
[13:21:33.208]                         else {
[13:21:33.208]                           version <- NULL
[13:21:33.208]                         }
[13:21:33.208]                         if (!has_future || version < "1.8.0") {
[13:21:33.208]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:33.208]                             "", base::R.version$version.string), 
[13:21:33.208]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:33.208]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:33.208]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:33.208]                               "release", "version")], collapse = " "), 
[13:21:33.208]                             hostname = base::Sys.info()[["nodename"]])
[13:21:33.208]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:33.208]                             info)
[13:21:33.208]                           info <- base::paste(info, collapse = "; ")
[13:21:33.208]                           if (!has_future) {
[13:21:33.208]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:33.208]                               info)
[13:21:33.208]                           }
[13:21:33.208]                           else {
[13:21:33.208]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:33.208]                               info, version)
[13:21:33.208]                           }
[13:21:33.208]                           base::stop(msg)
[13:21:33.208]                         }
[13:21:33.208]                       })
[13:21:33.208]                     }
[13:21:33.208]                     base::local({
[13:21:33.208]                       for (pkg in "future.apply") {
[13:21:33.208]                         base::loadNamespace(pkg)
[13:21:33.208]                         base::library(pkg, character.only = TRUE)
[13:21:33.208]                       }
[13:21:33.208]                     })
[13:21:33.208]                   }
[13:21:33.208]                   options(future.plan = NULL)
[13:21:33.208]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:33.208]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:33.208]                 }
[13:21:33.208]                 ...future.workdir <- getwd()
[13:21:33.208]             }
[13:21:33.208]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:33.208]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:33.208]         }
[13:21:33.208]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:33.208]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:33.208]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:33.208]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:33.208]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:33.208]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:33.208]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:33.208]             base::names(...future.oldOptions))
[13:21:33.208]     }
[13:21:33.208]     if (FALSE) {
[13:21:33.208]     }
[13:21:33.208]     else {
[13:21:33.208]         if (TRUE) {
[13:21:33.208]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:33.208]                 open = "w")
[13:21:33.208]         }
[13:21:33.208]         else {
[13:21:33.208]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:33.208]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:33.208]         }
[13:21:33.208]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:33.208]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:33.208]             base::sink(type = "output", split = FALSE)
[13:21:33.208]             base::close(...future.stdout)
[13:21:33.208]         }, add = TRUE)
[13:21:33.208]     }
[13:21:33.208]     ...future.frame <- base::sys.nframe()
[13:21:33.208]     ...future.conditions <- base::list()
[13:21:33.208]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:33.208]     if (FALSE) {
[13:21:33.208]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:33.208]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:33.208]     }
[13:21:33.208]     ...future.result <- base::tryCatch({
[13:21:33.208]         base::withCallingHandlers({
[13:21:33.208]             ...future.value <- base::withVisible(base::local({
[13:21:33.208]                 do.call(function(...) {
[13:21:33.208]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.208]                   if (!identical(...future.globals.maxSize.org, 
[13:21:33.208]                     ...future.globals.maxSize)) {
[13:21:33.208]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.208]                     on.exit(options(oopts), add = TRUE)
[13:21:33.208]                   }
[13:21:33.208]                   {
[13:21:33.208]                     lapply(seq_along(...future.elements_ii), 
[13:21:33.208]                       FUN = function(jj) {
[13:21:33.208]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.208]                         ...future.FUN(...future.X_jj, ...)
[13:21:33.208]                       })
[13:21:33.208]                   }
[13:21:33.208]                 }, args = future.call.arguments)
[13:21:33.208]             }))
[13:21:33.208]             future::FutureResult(value = ...future.value$value, 
[13:21:33.208]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:33.208]                   ...future.rng), globalenv = if (FALSE) 
[13:21:33.208]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:33.208]                     ...future.globalenv.names))
[13:21:33.208]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:33.208]         }, condition = base::local({
[13:21:33.208]             c <- base::c
[13:21:33.208]             inherits <- base::inherits
[13:21:33.208]             invokeRestart <- base::invokeRestart
[13:21:33.208]             length <- base::length
[13:21:33.208]             list <- base::list
[13:21:33.208]             seq.int <- base::seq.int
[13:21:33.208]             signalCondition <- base::signalCondition
[13:21:33.208]             sys.calls <- base::sys.calls
[13:21:33.208]             `[[` <- base::`[[`
[13:21:33.208]             `+` <- base::`+`
[13:21:33.208]             `<<-` <- base::`<<-`
[13:21:33.208]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:33.208]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:33.208]                   3L)]
[13:21:33.208]             }
[13:21:33.208]             function(cond) {
[13:21:33.208]                 is_error <- inherits(cond, "error")
[13:21:33.208]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:33.208]                   NULL)
[13:21:33.208]                 if (is_error) {
[13:21:33.208]                   sessionInformation <- function() {
[13:21:33.208]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:33.208]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:33.208]                       search = base::search(), system = base::Sys.info())
[13:21:33.208]                   }
[13:21:33.208]                   ...future.conditions[[length(...future.conditions) + 
[13:21:33.208]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:33.208]                     cond$call), session = sessionInformation(), 
[13:21:33.208]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:33.208]                   signalCondition(cond)
[13:21:33.208]                 }
[13:21:33.208]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:33.208]                 "immediateCondition"))) {
[13:21:33.208]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:33.208]                   ...future.conditions[[length(...future.conditions) + 
[13:21:33.208]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:33.208]                   if (TRUE && !signal) {
[13:21:33.208]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.208]                     {
[13:21:33.208]                       inherits <- base::inherits
[13:21:33.208]                       invokeRestart <- base::invokeRestart
[13:21:33.208]                       is.null <- base::is.null
[13:21:33.208]                       muffled <- FALSE
[13:21:33.208]                       if (inherits(cond, "message")) {
[13:21:33.208]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:33.208]                         if (muffled) 
[13:21:33.208]                           invokeRestart("muffleMessage")
[13:21:33.208]                       }
[13:21:33.208]                       else if (inherits(cond, "warning")) {
[13:21:33.208]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:33.208]                         if (muffled) 
[13:21:33.208]                           invokeRestart("muffleWarning")
[13:21:33.208]                       }
[13:21:33.208]                       else if (inherits(cond, "condition")) {
[13:21:33.208]                         if (!is.null(pattern)) {
[13:21:33.208]                           computeRestarts <- base::computeRestarts
[13:21:33.208]                           grepl <- base::grepl
[13:21:33.208]                           restarts <- computeRestarts(cond)
[13:21:33.208]                           for (restart in restarts) {
[13:21:33.208]                             name <- restart$name
[13:21:33.208]                             if (is.null(name)) 
[13:21:33.208]                               next
[13:21:33.208]                             if (!grepl(pattern, name)) 
[13:21:33.208]                               next
[13:21:33.208]                             invokeRestart(restart)
[13:21:33.208]                             muffled <- TRUE
[13:21:33.208]                             break
[13:21:33.208]                           }
[13:21:33.208]                         }
[13:21:33.208]                       }
[13:21:33.208]                       invisible(muffled)
[13:21:33.208]                     }
[13:21:33.208]                     muffleCondition(cond, pattern = "^muffle")
[13:21:33.208]                   }
[13:21:33.208]                 }
[13:21:33.208]                 else {
[13:21:33.208]                   if (TRUE) {
[13:21:33.208]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.208]                     {
[13:21:33.208]                       inherits <- base::inherits
[13:21:33.208]                       invokeRestart <- base::invokeRestart
[13:21:33.208]                       is.null <- base::is.null
[13:21:33.208]                       muffled <- FALSE
[13:21:33.208]                       if (inherits(cond, "message")) {
[13:21:33.208]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:33.208]                         if (muffled) 
[13:21:33.208]                           invokeRestart("muffleMessage")
[13:21:33.208]                       }
[13:21:33.208]                       else if (inherits(cond, "warning")) {
[13:21:33.208]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:33.208]                         if (muffled) 
[13:21:33.208]                           invokeRestart("muffleWarning")
[13:21:33.208]                       }
[13:21:33.208]                       else if (inherits(cond, "condition")) {
[13:21:33.208]                         if (!is.null(pattern)) {
[13:21:33.208]                           computeRestarts <- base::computeRestarts
[13:21:33.208]                           grepl <- base::grepl
[13:21:33.208]                           restarts <- computeRestarts(cond)
[13:21:33.208]                           for (restart in restarts) {
[13:21:33.208]                             name <- restart$name
[13:21:33.208]                             if (is.null(name)) 
[13:21:33.208]                               next
[13:21:33.208]                             if (!grepl(pattern, name)) 
[13:21:33.208]                               next
[13:21:33.208]                             invokeRestart(restart)
[13:21:33.208]                             muffled <- TRUE
[13:21:33.208]                             break
[13:21:33.208]                           }
[13:21:33.208]                         }
[13:21:33.208]                       }
[13:21:33.208]                       invisible(muffled)
[13:21:33.208]                     }
[13:21:33.208]                     muffleCondition(cond, pattern = "^muffle")
[13:21:33.208]                   }
[13:21:33.208]                 }
[13:21:33.208]             }
[13:21:33.208]         }))
[13:21:33.208]     }, error = function(ex) {
[13:21:33.208]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:33.208]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:33.208]                 ...future.rng), started = ...future.startTime, 
[13:21:33.208]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:33.208]             version = "1.8"), class = "FutureResult")
[13:21:33.208]     }, finally = {
[13:21:33.208]         if (!identical(...future.workdir, getwd())) 
[13:21:33.208]             setwd(...future.workdir)
[13:21:33.208]         {
[13:21:33.208]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:33.208]                 ...future.oldOptions$nwarnings <- NULL
[13:21:33.208]             }
[13:21:33.208]             base::options(...future.oldOptions)
[13:21:33.208]             if (.Platform$OS.type == "windows") {
[13:21:33.208]                 old_names <- names(...future.oldEnvVars)
[13:21:33.208]                 envs <- base::Sys.getenv()
[13:21:33.208]                 names <- names(envs)
[13:21:33.208]                 common <- intersect(names, old_names)
[13:21:33.208]                 added <- setdiff(names, old_names)
[13:21:33.208]                 removed <- setdiff(old_names, names)
[13:21:33.208]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:33.208]                   envs[common]]
[13:21:33.208]                 NAMES <- toupper(changed)
[13:21:33.208]                 args <- list()
[13:21:33.208]                 for (kk in seq_along(NAMES)) {
[13:21:33.208]                   name <- changed[[kk]]
[13:21:33.208]                   NAME <- NAMES[[kk]]
[13:21:33.208]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.208]                     next
[13:21:33.208]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:33.208]                 }
[13:21:33.208]                 NAMES <- toupper(added)
[13:21:33.208]                 for (kk in seq_along(NAMES)) {
[13:21:33.208]                   name <- added[[kk]]
[13:21:33.208]                   NAME <- NAMES[[kk]]
[13:21:33.208]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.208]                     next
[13:21:33.208]                   args[[name]] <- ""
[13:21:33.208]                 }
[13:21:33.208]                 NAMES <- toupper(removed)
[13:21:33.208]                 for (kk in seq_along(NAMES)) {
[13:21:33.208]                   name <- removed[[kk]]
[13:21:33.208]                   NAME <- NAMES[[kk]]
[13:21:33.208]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.208]                     next
[13:21:33.208]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:33.208]                 }
[13:21:33.208]                 if (length(args) > 0) 
[13:21:33.208]                   base::do.call(base::Sys.setenv, args = args)
[13:21:33.208]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:33.208]             }
[13:21:33.208]             else {
[13:21:33.208]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:33.208]             }
[13:21:33.208]             {
[13:21:33.208]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:33.208]                   0L) {
[13:21:33.208]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:33.208]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:33.208]                   base::options(opts)
[13:21:33.208]                 }
[13:21:33.208]                 {
[13:21:33.208]                   {
[13:21:33.208]                     NULL
[13:21:33.208]                     RNGkind("Mersenne-Twister")
[13:21:33.208]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:33.208]                       inherits = FALSE)
[13:21:33.208]                   }
[13:21:33.208]                   options(future.plan = NULL)
[13:21:33.208]                   if (is.na(NA_character_)) 
[13:21:33.208]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:33.208]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:33.208]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:33.208]                   {
[13:21:33.208]                     future <- SequentialFuture(..., envir = envir)
[13:21:33.208]                     if (!future$lazy) 
[13:21:33.208]                       future <- run(future)
[13:21:33.208]                     invisible(future)
[13:21:33.208]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:33.208]                 }
[13:21:33.208]             }
[13:21:33.208]         }
[13:21:33.208]     })
[13:21:33.208]     if (TRUE) {
[13:21:33.208]         base::sink(type = "output", split = FALSE)
[13:21:33.208]         if (TRUE) {
[13:21:33.208]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:33.208]         }
[13:21:33.208]         else {
[13:21:33.208]             ...future.result["stdout"] <- base::list(NULL)
[13:21:33.208]         }
[13:21:33.208]         base::close(...future.stdout)
[13:21:33.208]         ...future.stdout <- NULL
[13:21:33.208]     }
[13:21:33.208]     ...future.result$conditions <- ...future.conditions
[13:21:33.208]     ...future.result$finished <- base::Sys.time()
[13:21:33.208]     ...future.result
[13:21:33.208] }
[13:21:33.210] assign_globals() ...
[13:21:33.210] List of 11
[13:21:33.210]  $ ...future.FUN            :function (x, ...)  
[13:21:33.210]  $ x_FUN                    :function (x)  
[13:21:33.210]  $ times                    : int 1
[13:21:33.210]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:33.210]  $ stop_if_not              :function (...)  
[13:21:33.210]  $ dim                      : NULL
[13:21:33.210]  $ valid_types              : chr [1:2] "logical" "integer"
[13:21:33.210]  $ future.call.arguments    : list()
[13:21:33.210]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:33.210]  $ ...future.elements_ii    :List of 3
[13:21:33.210]   ..$ a: num 1
[13:21:33.210]   ..$ b: num 2
[13:21:33.210]   ..$ c: num 3
[13:21:33.210]  $ ...future.seeds_ii       : NULL
[13:21:33.210]  $ ...future.globals.maxSize: NULL
[13:21:33.210]  - attr(*, "where")=List of 11
[13:21:33.210]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:33.210]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:33.210]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:33.210]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:33.210]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:33.210]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:33.210]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:33.210]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:33.210]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:33.210]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:33.210]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:33.210]  - attr(*, "resolved")= logi FALSE
[13:21:33.210]  - attr(*, "total_size")= num 94264
[13:21:33.210]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:33.210]  - attr(*, "already-done")= logi TRUE
[13:21:33.221] - copied ‘...future.FUN’ to environment
[13:21:33.221] - copied ‘x_FUN’ to environment
[13:21:33.221] - copied ‘times’ to environment
[13:21:33.221] - copied ‘stopf’ to environment
[13:21:33.221] - copied ‘stop_if_not’ to environment
[13:21:33.221] - copied ‘dim’ to environment
[13:21:33.221] - copied ‘valid_types’ to environment
[13:21:33.221] - copied ‘future.call.arguments’ to environment
[13:21:33.221] - copied ‘...future.elements_ii’ to environment
[13:21:33.222] - copied ‘...future.seeds_ii’ to environment
[13:21:33.222] - copied ‘...future.globals.maxSize’ to environment
[13:21:33.222] assign_globals() ... done
[13:21:33.222] plan(): Setting new future strategy stack:
[13:21:33.222] List of future strategies:
[13:21:33.222] 1. sequential:
[13:21:33.222]    - args: function (..., envir = parent.frame())
[13:21:33.222]    - tweaked: FALSE
[13:21:33.222]    - call: NULL
[13:21:33.223] plan(): nbrOfWorkers() = 1
[13:21:33.223] plan(): Setting new future strategy stack:
[13:21:33.224] List of future strategies:
[13:21:33.224] 1. sequential:
[13:21:33.224]    - args: function (..., envir = parent.frame())
[13:21:33.224]    - tweaked: FALSE
[13:21:33.224]    - call: plan(strategy)
[13:21:33.224] plan(): nbrOfWorkers() = 1
[13:21:33.224] SequentialFuture started (and completed)
[13:21:33.224] - Launch lazy future ... done
[13:21:33.224] run() for ‘SequentialFuture’ ... done
[13:21:33.225] Created future:
[13:21:33.225] SequentialFuture:
[13:21:33.225] Label: ‘future_vapply-1’
[13:21:33.225] Expression:
[13:21:33.225] {
[13:21:33.225]     do.call(function(...) {
[13:21:33.225]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.225]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:33.225]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.225]             on.exit(options(oopts), add = TRUE)
[13:21:33.225]         }
[13:21:33.225]         {
[13:21:33.225]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:33.225]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.225]                 ...future.FUN(...future.X_jj, ...)
[13:21:33.225]             })
[13:21:33.225]         }
[13:21:33.225]     }, args = future.call.arguments)
[13:21:33.225] }
[13:21:33.225] Lazy evaluation: FALSE
[13:21:33.225] Asynchronous evaluation: FALSE
[13:21:33.225] Local evaluation: TRUE
[13:21:33.225] Environment: R_GlobalEnv
[13:21:33.225] Capture standard output: TRUE
[13:21:33.225] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:33.225] Globals: 11 objects totaling 92.22 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:33.225] Packages: 1 packages (‘future.apply’)
[13:21:33.225] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:33.225] Resolved: TRUE
[13:21:33.225] Value: 168 bytes of class ‘list’
[13:21:33.225] Early signaling: FALSE
[13:21:33.225] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:33.225] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:33.226] Chunk #1 of 1 ... DONE
[13:21:33.226] Launching 1 futures (chunks) ... DONE
[13:21:33.226] Resolving 1 futures (chunks) ...
[13:21:33.226] resolve() on list ...
[13:21:33.226]  recursive: 0
[13:21:33.226]  length: 1
[13:21:33.226] 
[13:21:33.226] resolved() for ‘SequentialFuture’ ...
[13:21:33.227] - state: ‘finished’
[13:21:33.227] - run: TRUE
[13:21:33.227] - result: ‘FutureResult’
[13:21:33.227] resolved() for ‘SequentialFuture’ ... done
[13:21:33.227] Future #1
[13:21:33.227] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:21:33.227] - nx: 1
[13:21:33.227] - relay: TRUE
[13:21:33.227] - stdout: TRUE
[13:21:33.227] - signal: TRUE
[13:21:33.228] - resignal: FALSE
[13:21:33.228] - force: TRUE
[13:21:33.228] - relayed: [n=1] FALSE
[13:21:33.228] - queued futures: [n=1] FALSE
[13:21:33.228]  - until=1
[13:21:33.228]  - relaying element #1
[13:21:33.228] - relayed: [n=1] TRUE
[13:21:33.228] - queued futures: [n=1] TRUE
[13:21:33.228] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:21:33.228]  length: 0 (resolved future 1)
[13:21:33.229] Relaying remaining futures
[13:21:33.229] signalConditionsASAP(NULL, pos=0) ...
[13:21:33.229] - nx: 1
[13:21:33.229] - relay: TRUE
[13:21:33.229] - stdout: TRUE
[13:21:33.229] - signal: TRUE
[13:21:33.229] - resignal: FALSE
[13:21:33.229] - force: TRUE
[13:21:33.229] - relayed: [n=1] TRUE
[13:21:33.229] - queued futures: [n=1] TRUE
 - flush all
[13:21:33.229] - relayed: [n=1] TRUE
[13:21:33.230] - queued futures: [n=1] TRUE
[13:21:33.230] signalConditionsASAP(NULL, pos=0) ... done
[13:21:33.230] resolve() on list ... DONE
[13:21:33.230]  - Number of value chunks collected: 1
[13:21:33.230] Resolving 1 futures (chunks) ... DONE
[13:21:33.230] Reducing values from 1 chunks ...
[13:21:33.230]  - Number of values collected after concatenation: 3
[13:21:33.230]  - Number of values expected: 3
[13:21:33.230] Reducing values from 1 chunks ... DONE
[13:21:33.230] future_lapply() ... DONE
- exceptions ...
[13:21:33.231] future_lapply() ...
[13:21:33.233] Number of chunks: 1
[13:21:33.233] getGlobalsAndPackagesXApply() ...
[13:21:33.233]  - future.globals: TRUE
[13:21:33.233] getGlobalsAndPackages() ...
[13:21:33.233] Searching for globals...
[13:21:33.239] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:21:33.239] Searching for globals ... DONE
[13:21:33.239] Resolving globals: FALSE
[13:21:33.240] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[13:21:33.240] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:33.240] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:33.240] - packages: [1] ‘future.apply’
[13:21:33.241] getGlobalsAndPackages() ... DONE
[13:21:33.241]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:33.241]  - needed namespaces: [n=1] ‘future.apply’
[13:21:33.241] Finding globals ... DONE
[13:21:33.241]  - use_args: TRUE
[13:21:33.241]  - Getting '...' globals ...
[13:21:33.241] resolve() on list ...
[13:21:33.241]  recursive: 0
[13:21:33.242]  length: 1
[13:21:33.242]  elements: ‘...’
[13:21:33.242]  length: 0 (resolved future 1)
[13:21:33.242] resolve() on list ... DONE
[13:21:33.242]    - '...' content: [n=0] 
[13:21:33.242] List of 1
[13:21:33.242]  $ ...: list()
[13:21:33.242]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:33.242]  - attr(*, "where")=List of 1
[13:21:33.242]   ..$ ...:<environment: 0x563b6f1f7340> 
[13:21:33.242]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:33.242]  - attr(*, "resolved")= logi TRUE
[13:21:33.242]  - attr(*, "total_size")= num NA
[13:21:33.245]  - Getting '...' globals ... DONE
[13:21:33.245] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:33.245] List of 8
[13:21:33.245]  $ ...future.FUN:function (x, ...)  
[13:21:33.245]  $ x_FUN        :function (x)  
[13:21:33.245]  $ times        : int 2
[13:21:33.245]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:33.245]  $ stop_if_not  :function (...)  
[13:21:33.245]  $ dim          : NULL
[13:21:33.245]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:21:33.245]  $ ...          : list()
[13:21:33.245]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:33.245]  - attr(*, "where")=List of 8
[13:21:33.245]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:33.245]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:33.245]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:33.245]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:33.245]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:33.245]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:33.245]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:33.245]   ..$ ...          :<environment: 0x563b6f1f7340> 
[13:21:33.245]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:33.245]  - attr(*, "resolved")= logi FALSE
[13:21:33.245]  - attr(*, "total_size")= num 95128
[13:21:33.250] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:21:33.251] getGlobalsAndPackagesXApply() ... DONE
[13:21:33.251] Number of futures (= number of chunks): 1
[13:21:33.251] Launching 1 futures (chunks) ...
[13:21:33.251] Chunk #1 of 1 ...
[13:21:33.251]  - Finding globals in 'X' for chunk #1 ...
[13:21:33.251] getGlobalsAndPackages() ...
[13:21:33.251] Searching for globals...
[13:21:33.252] 
[13:21:33.252] Searching for globals ... DONE
[13:21:33.252] - globals: [0] <none>
[13:21:33.252] getGlobalsAndPackages() ... DONE
[13:21:33.252]    + additional globals found: [n=0] 
[13:21:33.252]    + additional namespaces needed: [n=0] 
[13:21:33.252]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:33.252]  - seeds: <none>
[13:21:33.252]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.253] getGlobalsAndPackages() ...
[13:21:33.253] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.253] Resolving globals: FALSE
[13:21:33.253] Tweak future expression to call with '...' arguments ...
[13:21:33.253] {
[13:21:33.253]     do.call(function(...) {
[13:21:33.253]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.253]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:33.253]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.253]             on.exit(options(oopts), add = TRUE)
[13:21:33.253]         }
[13:21:33.253]         {
[13:21:33.253]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:33.253]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.253]                 ...future.FUN(...future.X_jj, ...)
[13:21:33.253]             })
[13:21:33.253]         }
[13:21:33.253]     }, args = future.call.arguments)
[13:21:33.253] }
[13:21:33.253] Tweak future expression to call with '...' arguments ... DONE
[13:21:33.254] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.254] - packages: [1] ‘future.apply’
[13:21:33.254] getGlobalsAndPackages() ... DONE
[13:21:33.254] run() for ‘Future’ ...
[13:21:33.254] - state: ‘created’
[13:21:33.255] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:33.257] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:33.257] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:33.257]   - Field: ‘label’
[13:21:33.257]   - Field: ‘local’
[13:21:33.257]   - Field: ‘owner’
[13:21:33.257]   - Field: ‘envir’
[13:21:33.258]   - Field: ‘packages’
[13:21:33.258]   - Field: ‘gc’
[13:21:33.258]   - Field: ‘conditions’
[13:21:33.258]   - Field: ‘expr’
[13:21:33.258]   - Field: ‘uuid’
[13:21:33.258]   - Field: ‘seed’
[13:21:33.258]   - Field: ‘version’
[13:21:33.258]   - Field: ‘result’
[13:21:33.258]   - Field: ‘asynchronous’
[13:21:33.259]   - Field: ‘calls’
[13:21:33.259]   - Field: ‘globals’
[13:21:33.259]   - Field: ‘stdout’
[13:21:33.259]   - Field: ‘earlySignal’
[13:21:33.259]   - Field: ‘lazy’
[13:21:33.259]   - Field: ‘state’
[13:21:33.259] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:33.259] - Launch lazy future ...
[13:21:33.260] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:33.260] Packages needed by future strategies (n = 0): <none>
[13:21:33.260] {
[13:21:33.260]     {
[13:21:33.260]         {
[13:21:33.260]             ...future.startTime <- base::Sys.time()
[13:21:33.260]             {
[13:21:33.260]                 {
[13:21:33.260]                   {
[13:21:33.260]                     {
[13:21:33.260]                       base::local({
[13:21:33.260]                         has_future <- base::requireNamespace("future", 
[13:21:33.260]                           quietly = TRUE)
[13:21:33.260]                         if (has_future) {
[13:21:33.260]                           ns <- base::getNamespace("future")
[13:21:33.260]                           version <- ns[[".package"]][["version"]]
[13:21:33.260]                           if (is.null(version)) 
[13:21:33.260]                             version <- utils::packageVersion("future")
[13:21:33.260]                         }
[13:21:33.260]                         else {
[13:21:33.260]                           version <- NULL
[13:21:33.260]                         }
[13:21:33.260]                         if (!has_future || version < "1.8.0") {
[13:21:33.260]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:33.260]                             "", base::R.version$version.string), 
[13:21:33.260]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:33.260]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:33.260]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:33.260]                               "release", "version")], collapse = " "), 
[13:21:33.260]                             hostname = base::Sys.info()[["nodename"]])
[13:21:33.260]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:33.260]                             info)
[13:21:33.260]                           info <- base::paste(info, collapse = "; ")
[13:21:33.260]                           if (!has_future) {
[13:21:33.260]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:33.260]                               info)
[13:21:33.260]                           }
[13:21:33.260]                           else {
[13:21:33.260]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:33.260]                               info, version)
[13:21:33.260]                           }
[13:21:33.260]                           base::stop(msg)
[13:21:33.260]                         }
[13:21:33.260]                       })
[13:21:33.260]                     }
[13:21:33.260]                     base::local({
[13:21:33.260]                       for (pkg in "future.apply") {
[13:21:33.260]                         base::loadNamespace(pkg)
[13:21:33.260]                         base::library(pkg, character.only = TRUE)
[13:21:33.260]                       }
[13:21:33.260]                     })
[13:21:33.260]                   }
[13:21:33.260]                   options(future.plan = NULL)
[13:21:33.260]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:33.260]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:33.260]                 }
[13:21:33.260]                 ...future.workdir <- getwd()
[13:21:33.260]             }
[13:21:33.260]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:33.260]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:33.260]         }
[13:21:33.260]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:33.260]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:33.260]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:33.260]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:33.260]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:33.260]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:33.260]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:33.260]             base::names(...future.oldOptions))
[13:21:33.260]     }
[13:21:33.260]     if (FALSE) {
[13:21:33.260]     }
[13:21:33.260]     else {
[13:21:33.260]         if (TRUE) {
[13:21:33.260]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:33.260]                 open = "w")
[13:21:33.260]         }
[13:21:33.260]         else {
[13:21:33.260]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:33.260]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:33.260]         }
[13:21:33.260]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:33.260]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:33.260]             base::sink(type = "output", split = FALSE)
[13:21:33.260]             base::close(...future.stdout)
[13:21:33.260]         }, add = TRUE)
[13:21:33.260]     }
[13:21:33.260]     ...future.frame <- base::sys.nframe()
[13:21:33.260]     ...future.conditions <- base::list()
[13:21:33.260]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:33.260]     if (FALSE) {
[13:21:33.260]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:33.260]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:33.260]     }
[13:21:33.260]     ...future.result <- base::tryCatch({
[13:21:33.260]         base::withCallingHandlers({
[13:21:33.260]             ...future.value <- base::withVisible(base::local({
[13:21:33.260]                 do.call(function(...) {
[13:21:33.260]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.260]                   if (!identical(...future.globals.maxSize.org, 
[13:21:33.260]                     ...future.globals.maxSize)) {
[13:21:33.260]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.260]                     on.exit(options(oopts), add = TRUE)
[13:21:33.260]                   }
[13:21:33.260]                   {
[13:21:33.260]                     lapply(seq_along(...future.elements_ii), 
[13:21:33.260]                       FUN = function(jj) {
[13:21:33.260]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.260]                         ...future.FUN(...future.X_jj, ...)
[13:21:33.260]                       })
[13:21:33.260]                   }
[13:21:33.260]                 }, args = future.call.arguments)
[13:21:33.260]             }))
[13:21:33.260]             future::FutureResult(value = ...future.value$value, 
[13:21:33.260]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:33.260]                   ...future.rng), globalenv = if (FALSE) 
[13:21:33.260]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:33.260]                     ...future.globalenv.names))
[13:21:33.260]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:33.260]         }, condition = base::local({
[13:21:33.260]             c <- base::c
[13:21:33.260]             inherits <- base::inherits
[13:21:33.260]             invokeRestart <- base::invokeRestart
[13:21:33.260]             length <- base::length
[13:21:33.260]             list <- base::list
[13:21:33.260]             seq.int <- base::seq.int
[13:21:33.260]             signalCondition <- base::signalCondition
[13:21:33.260]             sys.calls <- base::sys.calls
[13:21:33.260]             `[[` <- base::`[[`
[13:21:33.260]             `+` <- base::`+`
[13:21:33.260]             `<<-` <- base::`<<-`
[13:21:33.260]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:33.260]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:33.260]                   3L)]
[13:21:33.260]             }
[13:21:33.260]             function(cond) {
[13:21:33.260]                 is_error <- inherits(cond, "error")
[13:21:33.260]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:33.260]                   NULL)
[13:21:33.260]                 if (is_error) {
[13:21:33.260]                   sessionInformation <- function() {
[13:21:33.260]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:33.260]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:33.260]                       search = base::search(), system = base::Sys.info())
[13:21:33.260]                   }
[13:21:33.260]                   ...future.conditions[[length(...future.conditions) + 
[13:21:33.260]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:33.260]                     cond$call), session = sessionInformation(), 
[13:21:33.260]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:33.260]                   signalCondition(cond)
[13:21:33.260]                 }
[13:21:33.260]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:33.260]                 "immediateCondition"))) {
[13:21:33.260]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:33.260]                   ...future.conditions[[length(...future.conditions) + 
[13:21:33.260]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:33.260]                   if (TRUE && !signal) {
[13:21:33.260]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.260]                     {
[13:21:33.260]                       inherits <- base::inherits
[13:21:33.260]                       invokeRestart <- base::invokeRestart
[13:21:33.260]                       is.null <- base::is.null
[13:21:33.260]                       muffled <- FALSE
[13:21:33.260]                       if (inherits(cond, "message")) {
[13:21:33.260]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:33.260]                         if (muffled) 
[13:21:33.260]                           invokeRestart("muffleMessage")
[13:21:33.260]                       }
[13:21:33.260]                       else if (inherits(cond, "warning")) {
[13:21:33.260]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:33.260]                         if (muffled) 
[13:21:33.260]                           invokeRestart("muffleWarning")
[13:21:33.260]                       }
[13:21:33.260]                       else if (inherits(cond, "condition")) {
[13:21:33.260]                         if (!is.null(pattern)) {
[13:21:33.260]                           computeRestarts <- base::computeRestarts
[13:21:33.260]                           grepl <- base::grepl
[13:21:33.260]                           restarts <- computeRestarts(cond)
[13:21:33.260]                           for (restart in restarts) {
[13:21:33.260]                             name <- restart$name
[13:21:33.260]                             if (is.null(name)) 
[13:21:33.260]                               next
[13:21:33.260]                             if (!grepl(pattern, name)) 
[13:21:33.260]                               next
[13:21:33.260]                             invokeRestart(restart)
[13:21:33.260]                             muffled <- TRUE
[13:21:33.260]                             break
[13:21:33.260]                           }
[13:21:33.260]                         }
[13:21:33.260]                       }
[13:21:33.260]                       invisible(muffled)
[13:21:33.260]                     }
[13:21:33.260]                     muffleCondition(cond, pattern = "^muffle")
[13:21:33.260]                   }
[13:21:33.260]                 }
[13:21:33.260]                 else {
[13:21:33.260]                   if (TRUE) {
[13:21:33.260]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.260]                     {
[13:21:33.260]                       inherits <- base::inherits
[13:21:33.260]                       invokeRestart <- base::invokeRestart
[13:21:33.260]                       is.null <- base::is.null
[13:21:33.260]                       muffled <- FALSE
[13:21:33.260]                       if (inherits(cond, "message")) {
[13:21:33.260]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:33.260]                         if (muffled) 
[13:21:33.260]                           invokeRestart("muffleMessage")
[13:21:33.260]                       }
[13:21:33.260]                       else if (inherits(cond, "warning")) {
[13:21:33.260]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:33.260]                         if (muffled) 
[13:21:33.260]                           invokeRestart("muffleWarning")
[13:21:33.260]                       }
[13:21:33.260]                       else if (inherits(cond, "condition")) {
[13:21:33.260]                         if (!is.null(pattern)) {
[13:21:33.260]                           computeRestarts <- base::computeRestarts
[13:21:33.260]                           grepl <- base::grepl
[13:21:33.260]                           restarts <- computeRestarts(cond)
[13:21:33.260]                           for (restart in restarts) {
[13:21:33.260]                             name <- restart$name
[13:21:33.260]                             if (is.null(name)) 
[13:21:33.260]                               next
[13:21:33.260]                             if (!grepl(pattern, name)) 
[13:21:33.260]                               next
[13:21:33.260]                             invokeRestart(restart)
[13:21:33.260]                             muffled <- TRUE
[13:21:33.260]                             break
[13:21:33.260]                           }
[13:21:33.260]                         }
[13:21:33.260]                       }
[13:21:33.260]                       invisible(muffled)
[13:21:33.260]                     }
[13:21:33.260]                     muffleCondition(cond, pattern = "^muffle")
[13:21:33.260]                   }
[13:21:33.260]                 }
[13:21:33.260]             }
[13:21:33.260]         }))
[13:21:33.260]     }, error = function(ex) {
[13:21:33.260]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:33.260]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:33.260]                 ...future.rng), started = ...future.startTime, 
[13:21:33.260]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:33.260]             version = "1.8"), class = "FutureResult")
[13:21:33.260]     }, finally = {
[13:21:33.260]         if (!identical(...future.workdir, getwd())) 
[13:21:33.260]             setwd(...future.workdir)
[13:21:33.260]         {
[13:21:33.260]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:33.260]                 ...future.oldOptions$nwarnings <- NULL
[13:21:33.260]             }
[13:21:33.260]             base::options(...future.oldOptions)
[13:21:33.260]             if (.Platform$OS.type == "windows") {
[13:21:33.260]                 old_names <- names(...future.oldEnvVars)
[13:21:33.260]                 envs <- base::Sys.getenv()
[13:21:33.260]                 names <- names(envs)
[13:21:33.260]                 common <- intersect(names, old_names)
[13:21:33.260]                 added <- setdiff(names, old_names)
[13:21:33.260]                 removed <- setdiff(old_names, names)
[13:21:33.260]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:33.260]                   envs[common]]
[13:21:33.260]                 NAMES <- toupper(changed)
[13:21:33.260]                 args <- list()
[13:21:33.260]                 for (kk in seq_along(NAMES)) {
[13:21:33.260]                   name <- changed[[kk]]
[13:21:33.260]                   NAME <- NAMES[[kk]]
[13:21:33.260]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.260]                     next
[13:21:33.260]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:33.260]                 }
[13:21:33.260]                 NAMES <- toupper(added)
[13:21:33.260]                 for (kk in seq_along(NAMES)) {
[13:21:33.260]                   name <- added[[kk]]
[13:21:33.260]                   NAME <- NAMES[[kk]]
[13:21:33.260]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.260]                     next
[13:21:33.260]                   args[[name]] <- ""
[13:21:33.260]                 }
[13:21:33.260]                 NAMES <- toupper(removed)
[13:21:33.260]                 for (kk in seq_along(NAMES)) {
[13:21:33.260]                   name <- removed[[kk]]
[13:21:33.260]                   NAME <- NAMES[[kk]]
[13:21:33.260]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.260]                     next
[13:21:33.260]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:33.260]                 }
[13:21:33.260]                 if (length(args) > 0) 
[13:21:33.260]                   base::do.call(base::Sys.setenv, args = args)
[13:21:33.260]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:33.260]             }
[13:21:33.260]             else {
[13:21:33.260]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:33.260]             }
[13:21:33.260]             {
[13:21:33.260]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:33.260]                   0L) {
[13:21:33.260]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:33.260]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:33.260]                   base::options(opts)
[13:21:33.260]                 }
[13:21:33.260]                 {
[13:21:33.260]                   {
[13:21:33.260]                     NULL
[13:21:33.260]                     RNGkind("Mersenne-Twister")
[13:21:33.260]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:33.260]                       inherits = FALSE)
[13:21:33.260]                   }
[13:21:33.260]                   options(future.plan = NULL)
[13:21:33.260]                   if (is.na(NA_character_)) 
[13:21:33.260]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:33.260]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:33.260]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:33.260]                   {
[13:21:33.260]                     future <- SequentialFuture(..., envir = envir)
[13:21:33.260]                     if (!future$lazy) 
[13:21:33.260]                       future <- run(future)
[13:21:33.260]                     invisible(future)
[13:21:33.260]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:33.260]                 }
[13:21:33.260]             }
[13:21:33.260]         }
[13:21:33.260]     })
[13:21:33.260]     if (TRUE) {
[13:21:33.260]         base::sink(type = "output", split = FALSE)
[13:21:33.260]         if (TRUE) {
[13:21:33.260]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:33.260]         }
[13:21:33.260]         else {
[13:21:33.260]             ...future.result["stdout"] <- base::list(NULL)
[13:21:33.260]         }
[13:21:33.260]         base::close(...future.stdout)
[13:21:33.260]         ...future.stdout <- NULL
[13:21:33.260]     }
[13:21:33.260]     ...future.result$conditions <- ...future.conditions
[13:21:33.260]     ...future.result$finished <- base::Sys.time()
[13:21:33.260]     ...future.result
[13:21:33.260] }
[13:21:33.262] assign_globals() ...
[13:21:33.262] List of 11
[13:21:33.262]  $ ...future.FUN            :function (x, ...)  
[13:21:33.262]  $ x_FUN                    :function (x)  
[13:21:33.262]  $ times                    : int 2
[13:21:33.262]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:33.262]  $ stop_if_not              :function (...)  
[13:21:33.262]  $ dim                      : NULL
[13:21:33.262]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:21:33.262]  $ future.call.arguments    : list()
[13:21:33.262]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:33.262]  $ ...future.elements_ii    :List of 3
[13:21:33.262]   ..$ : int 1
[13:21:33.262]   ..$ : int 2
[13:21:33.262]   ..$ : int 3
[13:21:33.262]  $ ...future.seeds_ii       : NULL
[13:21:33.262]  $ ...future.globals.maxSize: NULL
[13:21:33.262]  - attr(*, "where")=List of 11
[13:21:33.262]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:33.262]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:33.262]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:33.262]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:33.262]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:33.262]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:33.262]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:33.262]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:33.262]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:33.262]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:33.262]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:33.262]  - attr(*, "resolved")= logi FALSE
[13:21:33.262]  - attr(*, "total_size")= num 95128
[13:21:33.262]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:33.262]  - attr(*, "already-done")= logi TRUE
[13:21:33.270] - copied ‘...future.FUN’ to environment
[13:21:33.271] - copied ‘x_FUN’ to environment
[13:21:33.271] - copied ‘times’ to environment
[13:21:33.271] - copied ‘stopf’ to environment
[13:21:33.271] - copied ‘stop_if_not’ to environment
[13:21:33.271] - copied ‘dim’ to environment
[13:21:33.271] - copied ‘valid_types’ to environment
[13:21:33.271] - copied ‘future.call.arguments’ to environment
[13:21:33.271] - copied ‘...future.elements_ii’ to environment
[13:21:33.271] - copied ‘...future.seeds_ii’ to environment
[13:21:33.271] - copied ‘...future.globals.maxSize’ to environment
[13:21:33.272] assign_globals() ... done
[13:21:33.272] plan(): Setting new future strategy stack:
[13:21:33.272] List of future strategies:
[13:21:33.272] 1. sequential:
[13:21:33.272]    - args: function (..., envir = parent.frame())
[13:21:33.272]    - tweaked: FALSE
[13:21:33.272]    - call: NULL
[13:21:33.273] plan(): nbrOfWorkers() = 1
[13:21:33.274] plan(): Setting new future strategy stack:
[13:21:33.274] List of future strategies:
[13:21:33.274] 1. sequential:
[13:21:33.274]    - args: function (..., envir = parent.frame())
[13:21:33.274]    - tweaked: FALSE
[13:21:33.274]    - call: plan(strategy)
[13:21:33.274] plan(): nbrOfWorkers() = 1
[13:21:33.274] SequentialFuture started (and completed)
[13:21:33.274] signalConditions() ...
[13:21:33.274]  - include = ‘immediateCondition’
[13:21:33.274]  - exclude = 
[13:21:33.275]  - resignal = FALSE
[13:21:33.275]  - Number of conditions: 1
[13:21:33.275] signalConditions() ... done
[13:21:33.275] - Launch lazy future ... done
[13:21:33.275] run() for ‘SequentialFuture’ ... done
[13:21:33.275] Created future:
[13:21:33.275] SequentialFuture:
[13:21:33.275] Label: ‘future_vapply-1’
[13:21:33.275] Expression:
[13:21:33.275] {
[13:21:33.275]     do.call(function(...) {
[13:21:33.275]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.275]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:33.275]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.275]             on.exit(options(oopts), add = TRUE)
[13:21:33.275]         }
[13:21:33.275]         {
[13:21:33.275]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:33.275]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.275]                 ...future.FUN(...future.X_jj, ...)
[13:21:33.275]             })
[13:21:33.275]         }
[13:21:33.275]     }, args = future.call.arguments)
[13:21:33.275] }
[13:21:33.275] Lazy evaluation: FALSE
[13:21:33.275] Asynchronous evaluation: FALSE
[13:21:33.275] Local evaluation: TRUE
[13:21:33.275] Environment: R_GlobalEnv
[13:21:33.275] Capture standard output: TRUE
[13:21:33.275] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:33.275] Globals: 11 objects totaling 93.06 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:33.275] Packages: 1 packages (‘future.apply’)
[13:21:33.275] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:33.275] Resolved: TRUE
[13:21:33.275] Value: 0 bytes of class ‘NULL’
[13:21:33.275] Conditions captured: [n=1] ‘simpleError’
[13:21:33.275] Early signaling: FALSE
[13:21:33.275] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:33.275] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:33.276] Chunk #1 of 1 ... DONE
[13:21:33.277] Launching 1 futures (chunks) ... DONE
[13:21:33.277] Resolving 1 futures (chunks) ...
[13:21:33.277] resolve() on list ...
[13:21:33.277]  recursive: 0
[13:21:33.277]  length: 1
[13:21:33.277] 
[13:21:33.277] resolved() for ‘SequentialFuture’ ...
[13:21:33.277] - state: ‘finished’
[13:21:33.277] - run: TRUE
[13:21:33.277] - result: ‘FutureResult’
[13:21:33.278] resolved() for ‘SequentialFuture’ ... done
[13:21:33.278] Future #1
[13:21:33.278] signalConditions() ...
[13:21:33.278]  - include = ‘immediateCondition’
[13:21:33.278]  - exclude = 
[13:21:33.278]  - resignal = FALSE
[13:21:33.278]  - Number of conditions: 1
[13:21:33.278] signalConditions() ... done
[13:21:33.278] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:21:33.278] - nx: 1
[13:21:33.278] - relay: TRUE
[13:21:33.279] - stdout: TRUE
[13:21:33.279] - signal: TRUE
[13:21:33.281] - resignal: FALSE
[13:21:33.281] - force: TRUE
[13:21:33.281] - relayed: [n=1] FALSE
[13:21:33.281] - queued futures: [n=1] FALSE
[13:21:33.281]  - until=1
[13:21:33.281]  - relaying element #1
[13:21:33.281] signalConditions() ...
[13:21:33.281]  - include = ‘immediateCondition’
[13:21:33.281]  - exclude = 
[13:21:33.282]  - resignal = FALSE
[13:21:33.282]  - Number of conditions: 1
[13:21:33.282] signalConditions() ... done
[13:21:33.282] signalConditions() ...
[13:21:33.282]  - include = ‘immediateCondition’
[13:21:33.282]  - exclude = 
[13:21:33.282]  - resignal = FALSE
[13:21:33.282]  - Number of conditions: 1
[13:21:33.283] signalConditions() ... done
[13:21:33.283] signalConditions() ...
[13:21:33.283]  - include = ‘condition’
[13:21:33.283]  - exclude = ‘immediateCondition’
[13:21:33.283]  - resignal = TRUE
[13:21:33.283]  - Number of conditions: 1
[13:21:33.283]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:21:33.283] signalConditions() ... done
[13:21:33.283] - relayed: [n=1] FALSE
[13:21:33.283] - queued futures: [n=1] TRUE
[13:21:33.284] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:21:33.284] plan(): Setting new future strategy stack:
[13:21:33.284] List of future strategies:
[13:21:33.284] 1. sequential:
[13:21:33.284]    - args: function (..., envir = parent.frame())
[13:21:33.284]    - tweaked: FALSE
[13:21:33.284]    - call: plan(sequential)
[13:21:33.284] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[13:21:33.285] plan(): Setting new future strategy stack:
[13:21:33.285] List of future strategies:
[13:21:33.285] 1. multicore:
[13:21:33.285]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:33.285]    - tweaked: FALSE
[13:21:33.285]    - call: plan(strategy)
[13:21:33.289] plan(): nbrOfWorkers() = 2
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[13:21:33.292] future_lapply() ...
[13:21:33.297] Number of chunks: 2
[13:21:33.298] getGlobalsAndPackagesXApply() ...
[13:21:33.298]  - future.globals: TRUE
[13:21:33.298] getGlobalsAndPackages() ...
[13:21:33.298] Searching for globals...
[13:21:33.301] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:21:33.301] Searching for globals ... DONE
[13:21:33.301] Resolving globals: FALSE
[13:21:33.302] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[13:21:33.302] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:33.303] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:33.303] - packages: [1] ‘future.apply’
[13:21:33.303] getGlobalsAndPackages() ... DONE
[13:21:33.303]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:33.303]  - needed namespaces: [n=1] ‘future.apply’
[13:21:33.303] Finding globals ... DONE
[13:21:33.303]  - use_args: TRUE
[13:21:33.303]  - Getting '...' globals ...
[13:21:33.304] resolve() on list ...
[13:21:33.304]  recursive: 0
[13:21:33.304]  length: 1
[13:21:33.304]  elements: ‘...’
[13:21:33.304]  length: 0 (resolved future 1)
[13:21:33.304] resolve() on list ... DONE
[13:21:33.304]    - '...' content: [n=0] 
[13:21:33.304] List of 1
[13:21:33.304]  $ ...: list()
[13:21:33.304]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:33.304]  - attr(*, "where")=List of 1
[13:21:33.304]   ..$ ...:<environment: 0x563b6daaefc0> 
[13:21:33.304]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:33.304]  - attr(*, "resolved")= logi TRUE
[13:21:33.304]  - attr(*, "total_size")= num NA
[13:21:33.311]  - Getting '...' globals ... DONE
[13:21:33.311] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:33.311] List of 8
[13:21:33.311]  $ ...future.FUN:function (x, ...)  
[13:21:33.311]  $ x_FUN        :function (x)  
[13:21:33.311]  $ times        : int 1
[13:21:33.311]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:33.311]  $ stop_if_not  :function (...)  
[13:21:33.311]  $ dim          : NULL
[13:21:33.311]  $ valid_types  : chr "character"
[13:21:33.311]  $ ...          : list()
[13:21:33.311]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:33.311]  - attr(*, "where")=List of 8
[13:21:33.311]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:33.311]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:33.311]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:33.311]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:33.311]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:33.311]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:33.311]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:33.311]   ..$ ...          :<environment: 0x563b6daaefc0> 
[13:21:33.311]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:33.311]  - attr(*, "resolved")= logi FALSE
[13:21:33.311]  - attr(*, "total_size")= num 94208
[13:21:33.317] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:21:33.317] getGlobalsAndPackagesXApply() ... DONE
[13:21:33.317] Number of futures (= number of chunks): 2
[13:21:33.318] Launching 2 futures (chunks) ...
[13:21:33.318] Chunk #1 of 2 ...
[13:21:33.318]  - Finding globals in 'X' for chunk #1 ...
[13:21:33.318] getGlobalsAndPackages() ...
[13:21:33.318] Searching for globals...
[13:21:33.318] 
[13:21:33.318] Searching for globals ... DONE
[13:21:33.319] - globals: [0] <none>
[13:21:33.319] getGlobalsAndPackages() ... DONE
[13:21:33.319]    + additional globals found: [n=0] 
[13:21:33.319]    + additional namespaces needed: [n=0] 
[13:21:33.319]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:33.319]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:33.319]  - seeds: <none>
[13:21:33.319]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.319] getGlobalsAndPackages() ...
[13:21:33.319] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.319] Resolving globals: FALSE
[13:21:33.320] Tweak future expression to call with '...' arguments ...
[13:21:33.320] {
[13:21:33.320]     do.call(function(...) {
[13:21:33.320]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.320]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:33.320]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.320]             on.exit(options(oopts), add = TRUE)
[13:21:33.320]         }
[13:21:33.320]         {
[13:21:33.320]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:33.320]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.320]                 ...future.FUN(...future.X_jj, ...)
[13:21:33.320]             })
[13:21:33.320]         }
[13:21:33.320]     }, args = future.call.arguments)
[13:21:33.320] }
[13:21:33.320] Tweak future expression to call with '...' arguments ... DONE
[13:21:33.321] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.321] - packages: [1] ‘future.apply’
[13:21:33.321] getGlobalsAndPackages() ... DONE
[13:21:33.321] run() for ‘Future’ ...
[13:21:33.321] - state: ‘created’
[13:21:33.321] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:33.326] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:33.326] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:33.326]   - Field: ‘label’
[13:21:33.326]   - Field: ‘local’
[13:21:33.326]   - Field: ‘owner’
[13:21:33.327]   - Field: ‘envir’
[13:21:33.327]   - Field: ‘workers’
[13:21:33.327]   - Field: ‘packages’
[13:21:33.327]   - Field: ‘gc’
[13:21:33.327]   - Field: ‘job’
[13:21:33.327]   - Field: ‘conditions’
[13:21:33.327]   - Field: ‘expr’
[13:21:33.327]   - Field: ‘uuid’
[13:21:33.327]   - Field: ‘seed’
[13:21:33.327]   - Field: ‘version’
[13:21:33.328]   - Field: ‘result’
[13:21:33.328]   - Field: ‘asynchronous’
[13:21:33.328]   - Field: ‘calls’
[13:21:33.328]   - Field: ‘globals’
[13:21:33.328]   - Field: ‘stdout’
[13:21:33.328]   - Field: ‘earlySignal’
[13:21:33.328]   - Field: ‘lazy’
[13:21:33.328]   - Field: ‘state’
[13:21:33.328] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:33.328] - Launch lazy future ...
[13:21:33.330] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:33.330] Packages needed by future strategies (n = 0): <none>
[13:21:33.330] {
[13:21:33.330]     {
[13:21:33.330]         {
[13:21:33.330]             ...future.startTime <- base::Sys.time()
[13:21:33.330]             {
[13:21:33.330]                 {
[13:21:33.330]                   {
[13:21:33.330]                     {
[13:21:33.330]                       {
[13:21:33.330]                         base::local({
[13:21:33.330]                           has_future <- base::requireNamespace("future", 
[13:21:33.330]                             quietly = TRUE)
[13:21:33.330]                           if (has_future) {
[13:21:33.330]                             ns <- base::getNamespace("future")
[13:21:33.330]                             version <- ns[[".package"]][["version"]]
[13:21:33.330]                             if (is.null(version)) 
[13:21:33.330]                               version <- utils::packageVersion("future")
[13:21:33.330]                           }
[13:21:33.330]                           else {
[13:21:33.330]                             version <- NULL
[13:21:33.330]                           }
[13:21:33.330]                           if (!has_future || version < "1.8.0") {
[13:21:33.330]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:33.330]                               "", base::R.version$version.string), 
[13:21:33.330]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:33.330]                                 base::R.version$platform, 8 * 
[13:21:33.330]                                   base::.Machine$sizeof.pointer), 
[13:21:33.330]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:33.330]                                 "release", "version")], collapse = " "), 
[13:21:33.330]                               hostname = base::Sys.info()[["nodename"]])
[13:21:33.330]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:33.330]                               info)
[13:21:33.330]                             info <- base::paste(info, collapse = "; ")
[13:21:33.330]                             if (!has_future) {
[13:21:33.330]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:33.330]                                 info)
[13:21:33.330]                             }
[13:21:33.330]                             else {
[13:21:33.330]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:33.330]                                 info, version)
[13:21:33.330]                             }
[13:21:33.330]                             base::stop(msg)
[13:21:33.330]                           }
[13:21:33.330]                         })
[13:21:33.330]                       }
[13:21:33.330]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:33.330]                       base::options(mc.cores = 1L)
[13:21:33.330]                     }
[13:21:33.330]                     base::local({
[13:21:33.330]                       for (pkg in "future.apply") {
[13:21:33.330]                         base::loadNamespace(pkg)
[13:21:33.330]                         base::library(pkg, character.only = TRUE)
[13:21:33.330]                       }
[13:21:33.330]                     })
[13:21:33.330]                   }
[13:21:33.330]                   options(future.plan = NULL)
[13:21:33.330]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:33.330]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:33.330]                 }
[13:21:33.330]                 ...future.workdir <- getwd()
[13:21:33.330]             }
[13:21:33.330]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:33.330]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:33.330]         }
[13:21:33.330]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:33.330]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:33.330]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:33.330]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:33.330]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:33.330]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:33.330]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:33.330]             base::names(...future.oldOptions))
[13:21:33.330]     }
[13:21:33.330]     if (FALSE) {
[13:21:33.330]     }
[13:21:33.330]     else {
[13:21:33.330]         if (TRUE) {
[13:21:33.330]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:33.330]                 open = "w")
[13:21:33.330]         }
[13:21:33.330]         else {
[13:21:33.330]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:33.330]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:33.330]         }
[13:21:33.330]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:33.330]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:33.330]             base::sink(type = "output", split = FALSE)
[13:21:33.330]             base::close(...future.stdout)
[13:21:33.330]         }, add = TRUE)
[13:21:33.330]     }
[13:21:33.330]     ...future.frame <- base::sys.nframe()
[13:21:33.330]     ...future.conditions <- base::list()
[13:21:33.330]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:33.330]     if (FALSE) {
[13:21:33.330]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:33.330]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:33.330]     }
[13:21:33.330]     ...future.result <- base::tryCatch({
[13:21:33.330]         base::withCallingHandlers({
[13:21:33.330]             ...future.value <- base::withVisible(base::local({
[13:21:33.330]                 withCallingHandlers({
[13:21:33.330]                   {
[13:21:33.330]                     do.call(function(...) {
[13:21:33.330]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.330]                       if (!identical(...future.globals.maxSize.org, 
[13:21:33.330]                         ...future.globals.maxSize)) {
[13:21:33.330]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.330]                         on.exit(options(oopts), add = TRUE)
[13:21:33.330]                       }
[13:21:33.330]                       {
[13:21:33.330]                         lapply(seq_along(...future.elements_ii), 
[13:21:33.330]                           FUN = function(jj) {
[13:21:33.330]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.330]                             ...future.FUN(...future.X_jj, ...)
[13:21:33.330]                           })
[13:21:33.330]                       }
[13:21:33.330]                     }, args = future.call.arguments)
[13:21:33.330]                   }
[13:21:33.330]                 }, immediateCondition = function(cond) {
[13:21:33.330]                   save_rds <- function (object, pathname, ...) 
[13:21:33.330]                   {
[13:21:33.330]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:33.330]                     if (file_test("-f", pathname_tmp)) {
[13:21:33.330]                       fi_tmp <- file.info(pathname_tmp)
[13:21:33.330]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:33.330]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:33.330]                         fi_tmp[["mtime"]])
[13:21:33.330]                     }
[13:21:33.330]                     tryCatch({
[13:21:33.330]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:33.330]                     }, error = function(ex) {
[13:21:33.330]                       msg <- conditionMessage(ex)
[13:21:33.330]                       fi_tmp <- file.info(pathname_tmp)
[13:21:33.330]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:33.330]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:33.330]                         fi_tmp[["mtime"]], msg)
[13:21:33.330]                       ex$message <- msg
[13:21:33.330]                       stop(ex)
[13:21:33.330]                     })
[13:21:33.330]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:33.330]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:33.330]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:33.330]                       fi_tmp <- file.info(pathname_tmp)
[13:21:33.330]                       fi <- file.info(pathname)
[13:21:33.330]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:33.330]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:33.330]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:33.330]                         fi[["size"]], fi[["mtime"]])
[13:21:33.330]                       stop(msg)
[13:21:33.330]                     }
[13:21:33.330]                     invisible(pathname)
[13:21:33.330]                   }
[13:21:33.330]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:33.330]                     rootPath = tempdir()) 
[13:21:33.330]                   {
[13:21:33.330]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:33.330]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:33.330]                       tmpdir = path, fileext = ".rds")
[13:21:33.330]                     save_rds(obj, file)
[13:21:33.330]                   }
[13:21:33.330]                   saveImmediateCondition(cond, path = "/tmp/RtmpbpFWGO/.future/immediateConditions")
[13:21:33.330]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.330]                   {
[13:21:33.330]                     inherits <- base::inherits
[13:21:33.330]                     invokeRestart <- base::invokeRestart
[13:21:33.330]                     is.null <- base::is.null
[13:21:33.330]                     muffled <- FALSE
[13:21:33.330]                     if (inherits(cond, "message")) {
[13:21:33.330]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:33.330]                       if (muffled) 
[13:21:33.330]                         invokeRestart("muffleMessage")
[13:21:33.330]                     }
[13:21:33.330]                     else if (inherits(cond, "warning")) {
[13:21:33.330]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:33.330]                       if (muffled) 
[13:21:33.330]                         invokeRestart("muffleWarning")
[13:21:33.330]                     }
[13:21:33.330]                     else if (inherits(cond, "condition")) {
[13:21:33.330]                       if (!is.null(pattern)) {
[13:21:33.330]                         computeRestarts <- base::computeRestarts
[13:21:33.330]                         grepl <- base::grepl
[13:21:33.330]                         restarts <- computeRestarts(cond)
[13:21:33.330]                         for (restart in restarts) {
[13:21:33.330]                           name <- restart$name
[13:21:33.330]                           if (is.null(name)) 
[13:21:33.330]                             next
[13:21:33.330]                           if (!grepl(pattern, name)) 
[13:21:33.330]                             next
[13:21:33.330]                           invokeRestart(restart)
[13:21:33.330]                           muffled <- TRUE
[13:21:33.330]                           break
[13:21:33.330]                         }
[13:21:33.330]                       }
[13:21:33.330]                     }
[13:21:33.330]                     invisible(muffled)
[13:21:33.330]                   }
[13:21:33.330]                   muffleCondition(cond)
[13:21:33.330]                 })
[13:21:33.330]             }))
[13:21:33.330]             future::FutureResult(value = ...future.value$value, 
[13:21:33.330]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:33.330]                   ...future.rng), globalenv = if (FALSE) 
[13:21:33.330]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:33.330]                     ...future.globalenv.names))
[13:21:33.330]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:33.330]         }, condition = base::local({
[13:21:33.330]             c <- base::c
[13:21:33.330]             inherits <- base::inherits
[13:21:33.330]             invokeRestart <- base::invokeRestart
[13:21:33.330]             length <- base::length
[13:21:33.330]             list <- base::list
[13:21:33.330]             seq.int <- base::seq.int
[13:21:33.330]             signalCondition <- base::signalCondition
[13:21:33.330]             sys.calls <- base::sys.calls
[13:21:33.330]             `[[` <- base::`[[`
[13:21:33.330]             `+` <- base::`+`
[13:21:33.330]             `<<-` <- base::`<<-`
[13:21:33.330]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:33.330]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:33.330]                   3L)]
[13:21:33.330]             }
[13:21:33.330]             function(cond) {
[13:21:33.330]                 is_error <- inherits(cond, "error")
[13:21:33.330]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:33.330]                   NULL)
[13:21:33.330]                 if (is_error) {
[13:21:33.330]                   sessionInformation <- function() {
[13:21:33.330]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:33.330]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:33.330]                       search = base::search(), system = base::Sys.info())
[13:21:33.330]                   }
[13:21:33.330]                   ...future.conditions[[length(...future.conditions) + 
[13:21:33.330]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:33.330]                     cond$call), session = sessionInformation(), 
[13:21:33.330]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:33.330]                   signalCondition(cond)
[13:21:33.330]                 }
[13:21:33.330]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:33.330]                 "immediateCondition"))) {
[13:21:33.330]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:33.330]                   ...future.conditions[[length(...future.conditions) + 
[13:21:33.330]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:33.330]                   if (TRUE && !signal) {
[13:21:33.330]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.330]                     {
[13:21:33.330]                       inherits <- base::inherits
[13:21:33.330]                       invokeRestart <- base::invokeRestart
[13:21:33.330]                       is.null <- base::is.null
[13:21:33.330]                       muffled <- FALSE
[13:21:33.330]                       if (inherits(cond, "message")) {
[13:21:33.330]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:33.330]                         if (muffled) 
[13:21:33.330]                           invokeRestart("muffleMessage")
[13:21:33.330]                       }
[13:21:33.330]                       else if (inherits(cond, "warning")) {
[13:21:33.330]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:33.330]                         if (muffled) 
[13:21:33.330]                           invokeRestart("muffleWarning")
[13:21:33.330]                       }
[13:21:33.330]                       else if (inherits(cond, "condition")) {
[13:21:33.330]                         if (!is.null(pattern)) {
[13:21:33.330]                           computeRestarts <- base::computeRestarts
[13:21:33.330]                           grepl <- base::grepl
[13:21:33.330]                           restarts <- computeRestarts(cond)
[13:21:33.330]                           for (restart in restarts) {
[13:21:33.330]                             name <- restart$name
[13:21:33.330]                             if (is.null(name)) 
[13:21:33.330]                               next
[13:21:33.330]                             if (!grepl(pattern, name)) 
[13:21:33.330]                               next
[13:21:33.330]                             invokeRestart(restart)
[13:21:33.330]                             muffled <- TRUE
[13:21:33.330]                             break
[13:21:33.330]                           }
[13:21:33.330]                         }
[13:21:33.330]                       }
[13:21:33.330]                       invisible(muffled)
[13:21:33.330]                     }
[13:21:33.330]                     muffleCondition(cond, pattern = "^muffle")
[13:21:33.330]                   }
[13:21:33.330]                 }
[13:21:33.330]                 else {
[13:21:33.330]                   if (TRUE) {
[13:21:33.330]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.330]                     {
[13:21:33.330]                       inherits <- base::inherits
[13:21:33.330]                       invokeRestart <- base::invokeRestart
[13:21:33.330]                       is.null <- base::is.null
[13:21:33.330]                       muffled <- FALSE
[13:21:33.330]                       if (inherits(cond, "message")) {
[13:21:33.330]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:33.330]                         if (muffled) 
[13:21:33.330]                           invokeRestart("muffleMessage")
[13:21:33.330]                       }
[13:21:33.330]                       else if (inherits(cond, "warning")) {
[13:21:33.330]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:33.330]                         if (muffled) 
[13:21:33.330]                           invokeRestart("muffleWarning")
[13:21:33.330]                       }
[13:21:33.330]                       else if (inherits(cond, "condition")) {
[13:21:33.330]                         if (!is.null(pattern)) {
[13:21:33.330]                           computeRestarts <- base::computeRestarts
[13:21:33.330]                           grepl <- base::grepl
[13:21:33.330]                           restarts <- computeRestarts(cond)
[13:21:33.330]                           for (restart in restarts) {
[13:21:33.330]                             name <- restart$name
[13:21:33.330]                             if (is.null(name)) 
[13:21:33.330]                               next
[13:21:33.330]                             if (!grepl(pattern, name)) 
[13:21:33.330]                               next
[13:21:33.330]                             invokeRestart(restart)
[13:21:33.330]                             muffled <- TRUE
[13:21:33.330]                             break
[13:21:33.330]                           }
[13:21:33.330]                         }
[13:21:33.330]                       }
[13:21:33.330]                       invisible(muffled)
[13:21:33.330]                     }
[13:21:33.330]                     muffleCondition(cond, pattern = "^muffle")
[13:21:33.330]                   }
[13:21:33.330]                 }
[13:21:33.330]             }
[13:21:33.330]         }))
[13:21:33.330]     }, error = function(ex) {
[13:21:33.330]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:33.330]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:33.330]                 ...future.rng), started = ...future.startTime, 
[13:21:33.330]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:33.330]             version = "1.8"), class = "FutureResult")
[13:21:33.330]     }, finally = {
[13:21:33.330]         if (!identical(...future.workdir, getwd())) 
[13:21:33.330]             setwd(...future.workdir)
[13:21:33.330]         {
[13:21:33.330]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:33.330]                 ...future.oldOptions$nwarnings <- NULL
[13:21:33.330]             }
[13:21:33.330]             base::options(...future.oldOptions)
[13:21:33.330]             if (.Platform$OS.type == "windows") {
[13:21:33.330]                 old_names <- names(...future.oldEnvVars)
[13:21:33.330]                 envs <- base::Sys.getenv()
[13:21:33.330]                 names <- names(envs)
[13:21:33.330]                 common <- intersect(names, old_names)
[13:21:33.330]                 added <- setdiff(names, old_names)
[13:21:33.330]                 removed <- setdiff(old_names, names)
[13:21:33.330]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:33.330]                   envs[common]]
[13:21:33.330]                 NAMES <- toupper(changed)
[13:21:33.330]                 args <- list()
[13:21:33.330]                 for (kk in seq_along(NAMES)) {
[13:21:33.330]                   name <- changed[[kk]]
[13:21:33.330]                   NAME <- NAMES[[kk]]
[13:21:33.330]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.330]                     next
[13:21:33.330]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:33.330]                 }
[13:21:33.330]                 NAMES <- toupper(added)
[13:21:33.330]                 for (kk in seq_along(NAMES)) {
[13:21:33.330]                   name <- added[[kk]]
[13:21:33.330]                   NAME <- NAMES[[kk]]
[13:21:33.330]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.330]                     next
[13:21:33.330]                   args[[name]] <- ""
[13:21:33.330]                 }
[13:21:33.330]                 NAMES <- toupper(removed)
[13:21:33.330]                 for (kk in seq_along(NAMES)) {
[13:21:33.330]                   name <- removed[[kk]]
[13:21:33.330]                   NAME <- NAMES[[kk]]
[13:21:33.330]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.330]                     next
[13:21:33.330]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:33.330]                 }
[13:21:33.330]                 if (length(args) > 0) 
[13:21:33.330]                   base::do.call(base::Sys.setenv, args = args)
[13:21:33.330]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:33.330]             }
[13:21:33.330]             else {
[13:21:33.330]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:33.330]             }
[13:21:33.330]             {
[13:21:33.330]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:33.330]                   0L) {
[13:21:33.330]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:33.330]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:33.330]                   base::options(opts)
[13:21:33.330]                 }
[13:21:33.330]                 {
[13:21:33.330]                   {
[13:21:33.330]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:33.330]                     NULL
[13:21:33.330]                   }
[13:21:33.330]                   options(future.plan = NULL)
[13:21:33.330]                   if (is.na(NA_character_)) 
[13:21:33.330]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:33.330]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:33.330]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:33.330]                     envir = parent.frame()) 
[13:21:33.330]                   {
[13:21:33.330]                     default_workers <- missing(workers)
[13:21:33.330]                     if (is.function(workers)) 
[13:21:33.330]                       workers <- workers()
[13:21:33.330]                     workers <- structure(as.integer(workers), 
[13:21:33.330]                       class = class(workers))
[13:21:33.330]                     stop_if_not(is.finite(workers), workers >= 
[13:21:33.330]                       1L)
[13:21:33.330]                     if ((workers == 1L && !inherits(workers, 
[13:21:33.330]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:33.330]                       if (default_workers) 
[13:21:33.330]                         supportsMulticore(warn = TRUE)
[13:21:33.330]                       return(sequential(..., envir = envir))
[13:21:33.330]                     }
[13:21:33.330]                     oopts <- options(mc.cores = workers)
[13:21:33.330]                     on.exit(options(oopts))
[13:21:33.330]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:33.330]                       envir = envir)
[13:21:33.330]                     if (!future$lazy) 
[13:21:33.330]                       future <- run(future)
[13:21:33.330]                     invisible(future)
[13:21:33.330]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:33.330]                 }
[13:21:33.330]             }
[13:21:33.330]         }
[13:21:33.330]     })
[13:21:33.330]     if (TRUE) {
[13:21:33.330]         base::sink(type = "output", split = FALSE)
[13:21:33.330]         if (TRUE) {
[13:21:33.330]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:33.330]         }
[13:21:33.330]         else {
[13:21:33.330]             ...future.result["stdout"] <- base::list(NULL)
[13:21:33.330]         }
[13:21:33.330]         base::close(...future.stdout)
[13:21:33.330]         ...future.stdout <- NULL
[13:21:33.330]     }
[13:21:33.330]     ...future.result$conditions <- ...future.conditions
[13:21:33.330]     ...future.result$finished <- base::Sys.time()
[13:21:33.330]     ...future.result
[13:21:33.330] }
[13:21:33.333] assign_globals() ...
[13:21:33.333] List of 11
[13:21:33.333]  $ ...future.FUN            :function (x, ...)  
[13:21:33.333]  $ x_FUN                    :function (x)  
[13:21:33.333]  $ times                    : int 1
[13:21:33.333]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:33.333]  $ stop_if_not              :function (...)  
[13:21:33.333]  $ dim                      : NULL
[13:21:33.333]  $ valid_types              : chr "character"
[13:21:33.333]  $ future.call.arguments    : list()
[13:21:33.333]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:33.333]  $ ...future.elements_ii    :List of 1
[13:21:33.333]   ..$ x: int [1:10] 1 2 3 4 5 6 7 8 9 10
[13:21:33.333]  $ ...future.seeds_ii       : NULL
[13:21:33.333]  $ ...future.globals.maxSize: NULL
[13:21:33.333]  - attr(*, "where")=List of 11
[13:21:33.333]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:33.333]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:33.333]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:33.333]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:33.333]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:33.333]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:33.333]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:33.333]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:33.333]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:33.333]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:33.333]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:33.333]  - attr(*, "resolved")= logi FALSE
[13:21:33.333]  - attr(*, "total_size")= num 94208
[13:21:33.333]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:33.333]  - attr(*, "already-done")= logi TRUE
[13:21:33.344] - copied ‘...future.FUN’ to environment
[13:21:33.344] - copied ‘x_FUN’ to environment
[13:21:33.344] - copied ‘times’ to environment
[13:21:33.344] - copied ‘stopf’ to environment
[13:21:33.344] - copied ‘stop_if_not’ to environment
[13:21:33.344] - copied ‘dim’ to environment
[13:21:33.344] - copied ‘valid_types’ to environment
[13:21:33.345] - copied ‘future.call.arguments’ to environment
[13:21:33.345] - copied ‘...future.elements_ii’ to environment
[13:21:33.345] - copied ‘...future.seeds_ii’ to environment
[13:21:33.345] - copied ‘...future.globals.maxSize’ to environment
[13:21:33.345] assign_globals() ... done
[13:21:33.345] requestCore(): workers = 2
[13:21:33.349] MulticoreFuture started
[13:21:33.349] - Launch lazy future ... done
[13:21:33.350] run() for ‘MulticoreFuture’ ... done
[13:21:33.350] plan(): Setting new future strategy stack:
[13:21:33.350] Created future:
[13:21:33.350] List of future strategies:
[13:21:33.350] 1. sequential:
[13:21:33.350]    - args: function (..., envir = parent.frame())
[13:21:33.350]    - tweaked: FALSE
[13:21:33.350]    - call: NULL
[13:21:33.351] plan(): nbrOfWorkers() = 1
[13:21:33.354] plan(): Setting new future strategy stack:
[13:21:33.354] List of future strategies:
[13:21:33.354] 1. multicore:
[13:21:33.354]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:33.354]    - tweaked: FALSE
[13:21:33.354]    - call: plan(strategy)
[13:21:33.360] plan(): nbrOfWorkers() = 2
[13:21:33.350] MulticoreFuture:
[13:21:33.350] Label: ‘future_vapply-1’
[13:21:33.350] Expression:
[13:21:33.350] {
[13:21:33.350]     do.call(function(...) {
[13:21:33.350]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.350]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:33.350]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.350]             on.exit(options(oopts), add = TRUE)
[13:21:33.350]         }
[13:21:33.350]         {
[13:21:33.350]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:33.350]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.350]                 ...future.FUN(...future.X_jj, ...)
[13:21:33.350]             })
[13:21:33.350]         }
[13:21:33.350]     }, args = future.call.arguments)
[13:21:33.350] }
[13:21:33.350] Lazy evaluation: FALSE
[13:21:33.350] Asynchronous evaluation: TRUE
[13:21:33.350] Local evaluation: TRUE
[13:21:33.350] Environment: R_GlobalEnv
[13:21:33.350] Capture standard output: TRUE
[13:21:33.350] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:33.350] Globals: 11 objects totaling 92.09 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:33.350] Packages: 1 packages (‘future.apply’)
[13:21:33.350] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:33.350] Resolved: TRUE
[13:21:33.350] Value: <not collected>
[13:21:33.350] Conditions captured: <none>
[13:21:33.350] Early signaling: FALSE
[13:21:33.350] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:33.350] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:33.361] Chunk #1 of 2 ... DONE
[13:21:33.361] Chunk #2 of 2 ...
[13:21:33.362]  - Finding globals in 'X' for chunk #2 ...
[13:21:33.362] getGlobalsAndPackages() ...
[13:21:33.362] Searching for globals...
[13:21:33.363] 
[13:21:33.363] Searching for globals ... DONE
[13:21:33.363] - globals: [0] <none>
[13:21:33.363] getGlobalsAndPackages() ... DONE
[13:21:33.363]    + additional globals found: [n=0] 
[13:21:33.363]    + additional namespaces needed: [n=0] 
[13:21:33.364]  - Finding globals in 'X' for chunk #2 ... DONE
[13:21:33.364]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:33.364]  - seeds: <none>
[13:21:33.364]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.364] getGlobalsAndPackages() ...
[13:21:33.364] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.365] Resolving globals: FALSE
[13:21:33.365] Tweak future expression to call with '...' arguments ...
[13:21:33.365] {
[13:21:33.365]     do.call(function(...) {
[13:21:33.365]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.365]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:33.365]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.365]             on.exit(options(oopts), add = TRUE)
[13:21:33.365]         }
[13:21:33.365]         {
[13:21:33.365]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:33.365]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.365]                 ...future.FUN(...future.X_jj, ...)
[13:21:33.365]             })
[13:21:33.365]         }
[13:21:33.365]     }, args = future.call.arguments)
[13:21:33.365] }
[13:21:33.365] Tweak future expression to call with '...' arguments ... DONE
[13:21:33.366] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.367] - packages: [1] ‘future.apply’
[13:21:33.367] getGlobalsAndPackages() ... DONE
[13:21:33.367] run() for ‘Future’ ...
[13:21:33.368] - state: ‘created’
[13:21:33.368] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:33.373] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:33.373] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:33.373]   - Field: ‘label’
[13:21:33.373]   - Field: ‘local’
[13:21:33.373]   - Field: ‘owner’
[13:21:33.374]   - Field: ‘envir’
[13:21:33.374]   - Field: ‘workers’
[13:21:33.374]   - Field: ‘packages’
[13:21:33.374]   - Field: ‘gc’
[13:21:33.374]   - Field: ‘job’
[13:21:33.374]   - Field: ‘conditions’
[13:21:33.374]   - Field: ‘expr’
[13:21:33.375]   - Field: ‘uuid’
[13:21:33.375]   - Field: ‘seed’
[13:21:33.375]   - Field: ‘version’
[13:21:33.375]   - Field: ‘result’
[13:21:33.375]   - Field: ‘asynchronous’
[13:21:33.375]   - Field: ‘calls’
[13:21:33.375]   - Field: ‘globals’
[13:21:33.376]   - Field: ‘stdout’
[13:21:33.376]   - Field: ‘earlySignal’
[13:21:33.376]   - Field: ‘lazy’
[13:21:33.376]   - Field: ‘state’
[13:21:33.376] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:33.376] - Launch lazy future ...
[13:21:33.377] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:33.377] Packages needed by future strategies (n = 0): <none>
[13:21:33.378] {
[13:21:33.378]     {
[13:21:33.378]         {
[13:21:33.378]             ...future.startTime <- base::Sys.time()
[13:21:33.378]             {
[13:21:33.378]                 {
[13:21:33.378]                   {
[13:21:33.378]                     {
[13:21:33.378]                       {
[13:21:33.378]                         base::local({
[13:21:33.378]                           has_future <- base::requireNamespace("future", 
[13:21:33.378]                             quietly = TRUE)
[13:21:33.378]                           if (has_future) {
[13:21:33.378]                             ns <- base::getNamespace("future")
[13:21:33.378]                             version <- ns[[".package"]][["version"]]
[13:21:33.378]                             if (is.null(version)) 
[13:21:33.378]                               version <- utils::packageVersion("future")
[13:21:33.378]                           }
[13:21:33.378]                           else {
[13:21:33.378]                             version <- NULL
[13:21:33.378]                           }
[13:21:33.378]                           if (!has_future || version < "1.8.0") {
[13:21:33.378]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:33.378]                               "", base::R.version$version.string), 
[13:21:33.378]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:33.378]                                 base::R.version$platform, 8 * 
[13:21:33.378]                                   base::.Machine$sizeof.pointer), 
[13:21:33.378]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:33.378]                                 "release", "version")], collapse = " "), 
[13:21:33.378]                               hostname = base::Sys.info()[["nodename"]])
[13:21:33.378]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:33.378]                               info)
[13:21:33.378]                             info <- base::paste(info, collapse = "; ")
[13:21:33.378]                             if (!has_future) {
[13:21:33.378]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:33.378]                                 info)
[13:21:33.378]                             }
[13:21:33.378]                             else {
[13:21:33.378]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:33.378]                                 info, version)
[13:21:33.378]                             }
[13:21:33.378]                             base::stop(msg)
[13:21:33.378]                           }
[13:21:33.378]                         })
[13:21:33.378]                       }
[13:21:33.378]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:33.378]                       base::options(mc.cores = 1L)
[13:21:33.378]                     }
[13:21:33.378]                     base::local({
[13:21:33.378]                       for (pkg in "future.apply") {
[13:21:33.378]                         base::loadNamespace(pkg)
[13:21:33.378]                         base::library(pkg, character.only = TRUE)
[13:21:33.378]                       }
[13:21:33.378]                     })
[13:21:33.378]                   }
[13:21:33.378]                   options(future.plan = NULL)
[13:21:33.378]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:33.378]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:33.378]                 }
[13:21:33.378]                 ...future.workdir <- getwd()
[13:21:33.378]             }
[13:21:33.378]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:33.378]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:33.378]         }
[13:21:33.378]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:33.378]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:33.378]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:33.378]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:33.378]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:33.378]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:33.378]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:33.378]             base::names(...future.oldOptions))
[13:21:33.378]     }
[13:21:33.378]     if (FALSE) {
[13:21:33.378]     }
[13:21:33.378]     else {
[13:21:33.378]         if (TRUE) {
[13:21:33.378]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:33.378]                 open = "w")
[13:21:33.378]         }
[13:21:33.378]         else {
[13:21:33.378]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:33.378]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:33.378]         }
[13:21:33.378]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:33.378]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:33.378]             base::sink(type = "output", split = FALSE)
[13:21:33.378]             base::close(...future.stdout)
[13:21:33.378]         }, add = TRUE)
[13:21:33.378]     }
[13:21:33.378]     ...future.frame <- base::sys.nframe()
[13:21:33.378]     ...future.conditions <- base::list()
[13:21:33.378]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:33.378]     if (FALSE) {
[13:21:33.378]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:33.378]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:33.378]     }
[13:21:33.378]     ...future.result <- base::tryCatch({
[13:21:33.378]         base::withCallingHandlers({
[13:21:33.378]             ...future.value <- base::withVisible(base::local({
[13:21:33.378]                 withCallingHandlers({
[13:21:33.378]                   {
[13:21:33.378]                     do.call(function(...) {
[13:21:33.378]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.378]                       if (!identical(...future.globals.maxSize.org, 
[13:21:33.378]                         ...future.globals.maxSize)) {
[13:21:33.378]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.378]                         on.exit(options(oopts), add = TRUE)
[13:21:33.378]                       }
[13:21:33.378]                       {
[13:21:33.378]                         lapply(seq_along(...future.elements_ii), 
[13:21:33.378]                           FUN = function(jj) {
[13:21:33.378]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.378]                             ...future.FUN(...future.X_jj, ...)
[13:21:33.378]                           })
[13:21:33.378]                       }
[13:21:33.378]                     }, args = future.call.arguments)
[13:21:33.378]                   }
[13:21:33.378]                 }, immediateCondition = function(cond) {
[13:21:33.378]                   save_rds <- function (object, pathname, ...) 
[13:21:33.378]                   {
[13:21:33.378]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:33.378]                     if (file_test("-f", pathname_tmp)) {
[13:21:33.378]                       fi_tmp <- file.info(pathname_tmp)
[13:21:33.378]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:33.378]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:33.378]                         fi_tmp[["mtime"]])
[13:21:33.378]                     }
[13:21:33.378]                     tryCatch({
[13:21:33.378]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:33.378]                     }, error = function(ex) {
[13:21:33.378]                       msg <- conditionMessage(ex)
[13:21:33.378]                       fi_tmp <- file.info(pathname_tmp)
[13:21:33.378]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:33.378]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:33.378]                         fi_tmp[["mtime"]], msg)
[13:21:33.378]                       ex$message <- msg
[13:21:33.378]                       stop(ex)
[13:21:33.378]                     })
[13:21:33.378]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:33.378]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:33.378]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:33.378]                       fi_tmp <- file.info(pathname_tmp)
[13:21:33.378]                       fi <- file.info(pathname)
[13:21:33.378]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:33.378]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:33.378]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:33.378]                         fi[["size"]], fi[["mtime"]])
[13:21:33.378]                       stop(msg)
[13:21:33.378]                     }
[13:21:33.378]                     invisible(pathname)
[13:21:33.378]                   }
[13:21:33.378]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:33.378]                     rootPath = tempdir()) 
[13:21:33.378]                   {
[13:21:33.378]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:33.378]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:33.378]                       tmpdir = path, fileext = ".rds")
[13:21:33.378]                     save_rds(obj, file)
[13:21:33.378]                   }
[13:21:33.378]                   saveImmediateCondition(cond, path = "/tmp/RtmpbpFWGO/.future/immediateConditions")
[13:21:33.378]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.378]                   {
[13:21:33.378]                     inherits <- base::inherits
[13:21:33.378]                     invokeRestart <- base::invokeRestart
[13:21:33.378]                     is.null <- base::is.null
[13:21:33.378]                     muffled <- FALSE
[13:21:33.378]                     if (inherits(cond, "message")) {
[13:21:33.378]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:33.378]                       if (muffled) 
[13:21:33.378]                         invokeRestart("muffleMessage")
[13:21:33.378]                     }
[13:21:33.378]                     else if (inherits(cond, "warning")) {
[13:21:33.378]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:33.378]                       if (muffled) 
[13:21:33.378]                         invokeRestart("muffleWarning")
[13:21:33.378]                     }
[13:21:33.378]                     else if (inherits(cond, "condition")) {
[13:21:33.378]                       if (!is.null(pattern)) {
[13:21:33.378]                         computeRestarts <- base::computeRestarts
[13:21:33.378]                         grepl <- base::grepl
[13:21:33.378]                         restarts <- computeRestarts(cond)
[13:21:33.378]                         for (restart in restarts) {
[13:21:33.378]                           name <- restart$name
[13:21:33.378]                           if (is.null(name)) 
[13:21:33.378]                             next
[13:21:33.378]                           if (!grepl(pattern, name)) 
[13:21:33.378]                             next
[13:21:33.378]                           invokeRestart(restart)
[13:21:33.378]                           muffled <- TRUE
[13:21:33.378]                           break
[13:21:33.378]                         }
[13:21:33.378]                       }
[13:21:33.378]                     }
[13:21:33.378]                     invisible(muffled)
[13:21:33.378]                   }
[13:21:33.378]                   muffleCondition(cond)
[13:21:33.378]                 })
[13:21:33.378]             }))
[13:21:33.378]             future::FutureResult(value = ...future.value$value, 
[13:21:33.378]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:33.378]                   ...future.rng), globalenv = if (FALSE) 
[13:21:33.378]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:33.378]                     ...future.globalenv.names))
[13:21:33.378]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:33.378]         }, condition = base::local({
[13:21:33.378]             c <- base::c
[13:21:33.378]             inherits <- base::inherits
[13:21:33.378]             invokeRestart <- base::invokeRestart
[13:21:33.378]             length <- base::length
[13:21:33.378]             list <- base::list
[13:21:33.378]             seq.int <- base::seq.int
[13:21:33.378]             signalCondition <- base::signalCondition
[13:21:33.378]             sys.calls <- base::sys.calls
[13:21:33.378]             `[[` <- base::`[[`
[13:21:33.378]             `+` <- base::`+`
[13:21:33.378]             `<<-` <- base::`<<-`
[13:21:33.378]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:33.378]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:33.378]                   3L)]
[13:21:33.378]             }
[13:21:33.378]             function(cond) {
[13:21:33.378]                 is_error <- inherits(cond, "error")
[13:21:33.378]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:33.378]                   NULL)
[13:21:33.378]                 if (is_error) {
[13:21:33.378]                   sessionInformation <- function() {
[13:21:33.378]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:33.378]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:33.378]                       search = base::search(), system = base::Sys.info())
[13:21:33.378]                   }
[13:21:33.378]                   ...future.conditions[[length(...future.conditions) + 
[13:21:33.378]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:33.378]                     cond$call), session = sessionInformation(), 
[13:21:33.378]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:33.378]                   signalCondition(cond)
[13:21:33.378]                 }
[13:21:33.378]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:33.378]                 "immediateCondition"))) {
[13:21:33.378]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:33.378]                   ...future.conditions[[length(...future.conditions) + 
[13:21:33.378]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:33.378]                   if (TRUE && !signal) {
[13:21:33.378]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.378]                     {
[13:21:33.378]                       inherits <- base::inherits
[13:21:33.378]                       invokeRestart <- base::invokeRestart
[13:21:33.378]                       is.null <- base::is.null
[13:21:33.378]                       muffled <- FALSE
[13:21:33.378]                       if (inherits(cond, "message")) {
[13:21:33.378]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:33.378]                         if (muffled) 
[13:21:33.378]                           invokeRestart("muffleMessage")
[13:21:33.378]                       }
[13:21:33.378]                       else if (inherits(cond, "warning")) {
[13:21:33.378]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:33.378]                         if (muffled) 
[13:21:33.378]                           invokeRestart("muffleWarning")
[13:21:33.378]                       }
[13:21:33.378]                       else if (inherits(cond, "condition")) {
[13:21:33.378]                         if (!is.null(pattern)) {
[13:21:33.378]                           computeRestarts <- base::computeRestarts
[13:21:33.378]                           grepl <- base::grepl
[13:21:33.378]                           restarts <- computeRestarts(cond)
[13:21:33.378]                           for (restart in restarts) {
[13:21:33.378]                             name <- restart$name
[13:21:33.378]                             if (is.null(name)) 
[13:21:33.378]                               next
[13:21:33.378]                             if (!grepl(pattern, name)) 
[13:21:33.378]                               next
[13:21:33.378]                             invokeRestart(restart)
[13:21:33.378]                             muffled <- TRUE
[13:21:33.378]                             break
[13:21:33.378]                           }
[13:21:33.378]                         }
[13:21:33.378]                       }
[13:21:33.378]                       invisible(muffled)
[13:21:33.378]                     }
[13:21:33.378]                     muffleCondition(cond, pattern = "^muffle")
[13:21:33.378]                   }
[13:21:33.378]                 }
[13:21:33.378]                 else {
[13:21:33.378]                   if (TRUE) {
[13:21:33.378]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.378]                     {
[13:21:33.378]                       inherits <- base::inherits
[13:21:33.378]                       invokeRestart <- base::invokeRestart
[13:21:33.378]                       is.null <- base::is.null
[13:21:33.378]                       muffled <- FALSE
[13:21:33.378]                       if (inherits(cond, "message")) {
[13:21:33.378]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:33.378]                         if (muffled) 
[13:21:33.378]                           invokeRestart("muffleMessage")
[13:21:33.378]                       }
[13:21:33.378]                       else if (inherits(cond, "warning")) {
[13:21:33.378]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:33.378]                         if (muffled) 
[13:21:33.378]                           invokeRestart("muffleWarning")
[13:21:33.378]                       }
[13:21:33.378]                       else if (inherits(cond, "condition")) {
[13:21:33.378]                         if (!is.null(pattern)) {
[13:21:33.378]                           computeRestarts <- base::computeRestarts
[13:21:33.378]                           grepl <- base::grepl
[13:21:33.378]                           restarts <- computeRestarts(cond)
[13:21:33.378]                           for (restart in restarts) {
[13:21:33.378]                             name <- restart$name
[13:21:33.378]                             if (is.null(name)) 
[13:21:33.378]                               next
[13:21:33.378]                             if (!grepl(pattern, name)) 
[13:21:33.378]                               next
[13:21:33.378]                             invokeRestart(restart)
[13:21:33.378]                             muffled <- TRUE
[13:21:33.378]                             break
[13:21:33.378]                           }
[13:21:33.378]                         }
[13:21:33.378]                       }
[13:21:33.378]                       invisible(muffled)
[13:21:33.378]                     }
[13:21:33.378]                     muffleCondition(cond, pattern = "^muffle")
[13:21:33.378]                   }
[13:21:33.378]                 }
[13:21:33.378]             }
[13:21:33.378]         }))
[13:21:33.378]     }, error = function(ex) {
[13:21:33.378]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:33.378]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:33.378]                 ...future.rng), started = ...future.startTime, 
[13:21:33.378]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:33.378]             version = "1.8"), class = "FutureResult")
[13:21:33.378]     }, finally = {
[13:21:33.378]         if (!identical(...future.workdir, getwd())) 
[13:21:33.378]             setwd(...future.workdir)
[13:21:33.378]         {
[13:21:33.378]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:33.378]                 ...future.oldOptions$nwarnings <- NULL
[13:21:33.378]             }
[13:21:33.378]             base::options(...future.oldOptions)
[13:21:33.378]             if (.Platform$OS.type == "windows") {
[13:21:33.378]                 old_names <- names(...future.oldEnvVars)
[13:21:33.378]                 envs <- base::Sys.getenv()
[13:21:33.378]                 names <- names(envs)
[13:21:33.378]                 common <- intersect(names, old_names)
[13:21:33.378]                 added <- setdiff(names, old_names)
[13:21:33.378]                 removed <- setdiff(old_names, names)
[13:21:33.378]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:33.378]                   envs[common]]
[13:21:33.378]                 NAMES <- toupper(changed)
[13:21:33.378]                 args <- list()
[13:21:33.378]                 for (kk in seq_along(NAMES)) {
[13:21:33.378]                   name <- changed[[kk]]
[13:21:33.378]                   NAME <- NAMES[[kk]]
[13:21:33.378]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.378]                     next
[13:21:33.378]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:33.378]                 }
[13:21:33.378]                 NAMES <- toupper(added)
[13:21:33.378]                 for (kk in seq_along(NAMES)) {
[13:21:33.378]                   name <- added[[kk]]
[13:21:33.378]                   NAME <- NAMES[[kk]]
[13:21:33.378]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.378]                     next
[13:21:33.378]                   args[[name]] <- ""
[13:21:33.378]                 }
[13:21:33.378]                 NAMES <- toupper(removed)
[13:21:33.378]                 for (kk in seq_along(NAMES)) {
[13:21:33.378]                   name <- removed[[kk]]
[13:21:33.378]                   NAME <- NAMES[[kk]]
[13:21:33.378]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.378]                     next
[13:21:33.378]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:33.378]                 }
[13:21:33.378]                 if (length(args) > 0) 
[13:21:33.378]                   base::do.call(base::Sys.setenv, args = args)
[13:21:33.378]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:33.378]             }
[13:21:33.378]             else {
[13:21:33.378]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:33.378]             }
[13:21:33.378]             {
[13:21:33.378]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:33.378]                   0L) {
[13:21:33.378]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:33.378]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:33.378]                   base::options(opts)
[13:21:33.378]                 }
[13:21:33.378]                 {
[13:21:33.378]                   {
[13:21:33.378]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:33.378]                     NULL
[13:21:33.378]                   }
[13:21:33.378]                   options(future.plan = NULL)
[13:21:33.378]                   if (is.na(NA_character_)) 
[13:21:33.378]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:33.378]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:33.378]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:33.378]                     envir = parent.frame()) 
[13:21:33.378]                   {
[13:21:33.378]                     default_workers <- missing(workers)
[13:21:33.378]                     if (is.function(workers)) 
[13:21:33.378]                       workers <- workers()
[13:21:33.378]                     workers <- structure(as.integer(workers), 
[13:21:33.378]                       class = class(workers))
[13:21:33.378]                     stop_if_not(is.finite(workers), workers >= 
[13:21:33.378]                       1L)
[13:21:33.378]                     if ((workers == 1L && !inherits(workers, 
[13:21:33.378]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:33.378]                       if (default_workers) 
[13:21:33.378]                         supportsMulticore(warn = TRUE)
[13:21:33.378]                       return(sequential(..., envir = envir))
[13:21:33.378]                     }
[13:21:33.378]                     oopts <- options(mc.cores = workers)
[13:21:33.378]                     on.exit(options(oopts))
[13:21:33.378]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:33.378]                       envir = envir)
[13:21:33.378]                     if (!future$lazy) 
[13:21:33.378]                       future <- run(future)
[13:21:33.378]                     invisible(future)
[13:21:33.378]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:33.378]                 }
[13:21:33.378]             }
[13:21:33.378]         }
[13:21:33.378]     })
[13:21:33.378]     if (TRUE) {
[13:21:33.378]         base::sink(type = "output", split = FALSE)
[13:21:33.378]         if (TRUE) {
[13:21:33.378]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:33.378]         }
[13:21:33.378]         else {
[13:21:33.378]             ...future.result["stdout"] <- base::list(NULL)
[13:21:33.378]         }
[13:21:33.378]         base::close(...future.stdout)
[13:21:33.378]         ...future.stdout <- NULL
[13:21:33.378]     }
[13:21:33.378]     ...future.result$conditions <- ...future.conditions
[13:21:33.378]     ...future.result$finished <- base::Sys.time()
[13:21:33.378]     ...future.result
[13:21:33.378] }
[13:21:33.381] assign_globals() ...
[13:21:33.381] List of 11
[13:21:33.381]  $ ...future.FUN            :function (x, ...)  
[13:21:33.381]  $ x_FUN                    :function (x)  
[13:21:33.381]  $ times                    : int 1
[13:21:33.381]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:33.381]  $ stop_if_not              :function (...)  
[13:21:33.381]  $ dim                      : NULL
[13:21:33.381]  $ valid_types              : chr "character"
[13:21:33.381]  $ future.call.arguments    : list()
[13:21:33.381]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:33.381]  $ ...future.elements_ii    :List of 1
[13:21:33.381]   ..$ y: chr [1:10] "a" "b" "c" "d" ...
[13:21:33.381]  $ ...future.seeds_ii       : NULL
[13:21:33.381]  $ ...future.globals.maxSize: NULL
[13:21:33.381]  - attr(*, "where")=List of 11
[13:21:33.381]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:33.381]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:33.381]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:33.381]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:33.381]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:33.381]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:33.381]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:33.381]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:33.381]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:33.381]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:33.381]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:33.381]  - attr(*, "resolved")= logi FALSE
[13:21:33.381]  - attr(*, "total_size")= num 94208
[13:21:33.381]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:33.381]  - attr(*, "already-done")= logi TRUE
[13:21:33.396] - copied ‘...future.FUN’ to environment
[13:21:33.396] - copied ‘x_FUN’ to environment
[13:21:33.396] - copied ‘times’ to environment
[13:21:33.396] - copied ‘stopf’ to environment
[13:21:33.397] - copied ‘stop_if_not’ to environment
[13:21:33.397] - copied ‘dim’ to environment
[13:21:33.397] - copied ‘valid_types’ to environment
[13:21:33.397] - copied ‘future.call.arguments’ to environment
[13:21:33.397] - copied ‘...future.elements_ii’ to environment
[13:21:33.397] - copied ‘...future.seeds_ii’ to environment
[13:21:33.397] - copied ‘...future.globals.maxSize’ to environment
[13:21:33.397] assign_globals() ... done
[13:21:33.398] requestCore(): workers = 2
[13:21:33.403] MulticoreFuture started
[13:21:33.403] - Launch lazy future ... done
[13:21:33.403] run() for ‘MulticoreFuture’ ... done
[13:21:33.404] Created future:
[13:21:33.404] plan(): Setting new future strategy stack:
[13:21:33.405] List of future strategies:
[13:21:33.405] 1. sequential:
[13:21:33.405]    - args: function (..., envir = parent.frame())
[13:21:33.405]    - tweaked: FALSE
[13:21:33.405]    - call: NULL
[13:21:33.405] plan(): nbrOfWorkers() = 1
[13:21:33.407] plan(): Setting new future strategy stack:
[13:21:33.408] List of future strategies:
[13:21:33.408] 1. multicore:
[13:21:33.408]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:33.408]    - tweaked: FALSE
[13:21:33.408]    - call: plan(strategy)
[13:21:33.413] plan(): nbrOfWorkers() = 2
[13:21:33.404] MulticoreFuture:
[13:21:33.404] Label: ‘future_vapply-2’
[13:21:33.404] Expression:
[13:21:33.404] {
[13:21:33.404]     do.call(function(...) {
[13:21:33.404]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.404]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:33.404]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.404]             on.exit(options(oopts), add = TRUE)
[13:21:33.404]         }
[13:21:33.404]         {
[13:21:33.404]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:33.404]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.404]                 ...future.FUN(...future.X_jj, ...)
[13:21:33.404]             })
[13:21:33.404]         }
[13:21:33.404]     }, args = future.call.arguments)
[13:21:33.404] }
[13:21:33.404] Lazy evaluation: FALSE
[13:21:33.404] Asynchronous evaluation: TRUE
[13:21:33.404] Local evaluation: TRUE
[13:21:33.404] Environment: R_GlobalEnv
[13:21:33.404] Capture standard output: TRUE
[13:21:33.404] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:33.404] Globals: 11 objects totaling 92.72 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:33.404] Packages: 1 packages (‘future.apply’)
[13:21:33.404] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:33.404] Resolved: TRUE
[13:21:33.404] Value: <not collected>
[13:21:33.404] Conditions captured: <none>
[13:21:33.404] Early signaling: FALSE
[13:21:33.404] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:33.404] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:33.414] Chunk #2 of 2 ... DONE
[13:21:33.415] Launching 2 futures (chunks) ... DONE
[13:21:33.415] Resolving 2 futures (chunks) ...
[13:21:33.415] resolve() on list ...
[13:21:33.415]  recursive: 0
[13:21:33.415]  length: 2
[13:21:33.415] 
[13:21:33.416] Future #1
[13:21:33.417] result() for MulticoreFuture ...
[13:21:33.418] result() for MulticoreFuture ...
[13:21:33.419] result() for MulticoreFuture ... done
[13:21:33.419] result() for MulticoreFuture ... done
[13:21:33.419] result() for MulticoreFuture ...
[13:21:33.419] result() for MulticoreFuture ... done
[13:21:33.419] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:21:33.419] - nx: 2
[13:21:33.420] - relay: TRUE
[13:21:33.420] - stdout: TRUE
[13:21:33.420] - signal: TRUE
[13:21:33.420] - resignal: FALSE
[13:21:33.420] - force: TRUE
[13:21:33.420] - relayed: [n=2] FALSE, FALSE
[13:21:33.420] - queued futures: [n=2] FALSE, FALSE
[13:21:33.421]  - until=1
[13:21:33.421]  - relaying element #1
[13:21:33.421] result() for MulticoreFuture ...
[13:21:33.421] result() for MulticoreFuture ... done
[13:21:33.421] result() for MulticoreFuture ...
[13:21:33.421] result() for MulticoreFuture ... done
[13:21:33.422] result() for MulticoreFuture ...
[13:21:33.422] result() for MulticoreFuture ... done
[13:21:33.422] result() for MulticoreFuture ...
[13:21:33.422] result() for MulticoreFuture ... done
[13:21:33.422] - relayed: [n=2] TRUE, FALSE
[13:21:33.422] - queued futures: [n=2] TRUE, FALSE
[13:21:33.423] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:21:33.423]  length: 1 (resolved future 1)
[13:21:33.423] Future #2
[13:21:33.423] result() for MulticoreFuture ...
[13:21:33.424] result() for MulticoreFuture ...
[13:21:33.424] result() for MulticoreFuture ... done
[13:21:33.424] result() for MulticoreFuture ... done
[13:21:33.424] result() for MulticoreFuture ...
[13:21:33.424] result() for MulticoreFuture ... done
[13:21:33.425] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:21:33.425] - nx: 2
[13:21:33.425] - relay: TRUE
[13:21:33.425] - stdout: TRUE
[13:21:33.425] - signal: TRUE
[13:21:33.425] - resignal: FALSE
[13:21:33.425] - force: TRUE
[13:21:33.426] - relayed: [n=2] TRUE, FALSE
[13:21:33.426] - queued futures: [n=2] TRUE, FALSE
[13:21:33.426]  - until=2
[13:21:33.426]  - relaying element #2
[13:21:33.426] result() for MulticoreFuture ...
[13:21:33.426] result() for MulticoreFuture ... done
[13:21:33.426] result() for MulticoreFuture ...
[13:21:33.426] result() for MulticoreFuture ... done
[13:21:33.427] result() for MulticoreFuture ...
[13:21:33.427] result() for MulticoreFuture ... done
[13:21:33.427] result() for MulticoreFuture ...
[13:21:33.427] result() for MulticoreFuture ... done
[13:21:33.427] - relayed: [n=2] TRUE, TRUE
[13:21:33.427] - queued futures: [n=2] TRUE, TRUE
[13:21:33.427] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:21:33.427]  length: 0 (resolved future 2)
[13:21:33.427] Relaying remaining futures
[13:21:33.428] signalConditionsASAP(NULL, pos=0) ...
[13:21:33.428] - nx: 2
[13:21:33.428] - relay: TRUE
[13:21:33.428] - stdout: TRUE
[13:21:33.428] - signal: TRUE
[13:21:33.428] - resignal: FALSE
[13:21:33.428] - force: TRUE
[13:21:33.428] - relayed: [n=2] TRUE, TRUE
[13:21:33.428] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:21:33.429] - relayed: [n=2] TRUE, TRUE
[13:21:33.429] - queued futures: [n=2] TRUE, TRUE
[13:21:33.429] signalConditionsASAP(NULL, pos=0) ... done
[13:21:33.429] resolve() on list ... DONE
[13:21:33.429] result() for MulticoreFuture ...
[13:21:33.429] result() for MulticoreFuture ... done
[13:21:33.429] result() for MulticoreFuture ...
[13:21:33.429] result() for MulticoreFuture ... done
[13:21:33.430] result() for MulticoreFuture ...
[13:21:33.430] result() for MulticoreFuture ... done
[13:21:33.430] result() for MulticoreFuture ...
[13:21:33.430] result() for MulticoreFuture ... done
[13:21:33.430]  - Number of value chunks collected: 2
[13:21:33.430] Resolving 2 futures (chunks) ... DONE
[13:21:33.430] Reducing values from 2 chunks ...
[13:21:33.430]  - Number of values collected after concatenation: 2
[13:21:33.430]  - Number of values expected: 2
[13:21:33.431] Reducing values from 2 chunks ... DONE
[13:21:33.431] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[13:21:33.432] future_lapply() ...
[13:21:33.442] Number of chunks: 2
[13:21:33.442] getGlobalsAndPackagesXApply() ...
[13:21:33.442]  - future.globals: TRUE
[13:21:33.442] getGlobalsAndPackages() ...
[13:21:33.442] Searching for globals...
[13:21:33.447] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[13:21:33.447] Searching for globals ... DONE
[13:21:33.447] Resolving globals: FALSE
[13:21:33.448] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[13:21:33.448] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:33.448] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:33.449] - packages: [1] ‘future.apply’
[13:21:33.449] getGlobalsAndPackages() ... DONE
[13:21:33.449]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:33.449]  - needed namespaces: [n=1] ‘future.apply’
[13:21:33.449] Finding globals ... DONE
[13:21:33.449]  - use_args: TRUE
[13:21:33.449]  - Getting '...' globals ...
[13:21:33.449] resolve() on list ...
[13:21:33.450]  recursive: 0
[13:21:33.450]  length: 1
[13:21:33.450]  elements: ‘...’
[13:21:33.450]  length: 0 (resolved future 1)
[13:21:33.450] resolve() on list ... DONE
[13:21:33.450]    - '...' content: [n=0] 
[13:21:33.450] List of 1
[13:21:33.450]  $ ...: list()
[13:21:33.450]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:33.450]  - attr(*, "where")=List of 1
[13:21:33.450]   ..$ ...:<environment: 0x563b6f30a8a0> 
[13:21:33.450]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:33.450]  - attr(*, "resolved")= logi TRUE
[13:21:33.450]  - attr(*, "total_size")= num NA
[13:21:33.453]  - Getting '...' globals ... DONE
[13:21:33.453] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:33.453] List of 8
[13:21:33.453]  $ ...future.FUN:function (x, ...)  
[13:21:33.453]  $ x_FUN        :function (x)  
[13:21:33.453]  $ times        : int 0
[13:21:33.453]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:33.453]  $ stop_if_not  :function (...)  
[13:21:33.453]  $ dim          : NULL
[13:21:33.453]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:21:33.453]  $ ...          : list()
[13:21:33.453]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:33.453]  - attr(*, "where")=List of 8
[13:21:33.453]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:33.453]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:33.453]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:33.453]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:33.453]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:33.453]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:33.453]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:33.453]   ..$ ...          :<environment: 0x563b6f30a8a0> 
[13:21:33.453]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:33.453]  - attr(*, "resolved")= logi FALSE
[13:21:33.453]  - attr(*, "total_size")= num 95472
[13:21:33.459] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:21:33.459] getGlobalsAndPackagesXApply() ... DONE
[13:21:33.461] Number of futures (= number of chunks): 2
[13:21:33.461] Launching 2 futures (chunks) ...
[13:21:33.461] Chunk #1 of 2 ...
[13:21:33.461]  - Finding globals in 'X' for chunk #1 ...
[13:21:33.461] getGlobalsAndPackages() ...
[13:21:33.461] Searching for globals...
[13:21:33.462] 
[13:21:33.462] Searching for globals ... DONE
[13:21:33.462] - globals: [0] <none>
[13:21:33.462] getGlobalsAndPackages() ... DONE
[13:21:33.462]    + additional globals found: [n=0] 
[13:21:33.462]    + additional namespaces needed: [n=0] 
[13:21:33.462]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:33.463]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:33.463]  - seeds: <none>
[13:21:33.463]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.463] getGlobalsAndPackages() ...
[13:21:33.463] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.463] Resolving globals: FALSE
[13:21:33.463] Tweak future expression to call with '...' arguments ...
[13:21:33.463] {
[13:21:33.463]     do.call(function(...) {
[13:21:33.463]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.463]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:33.463]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.463]             on.exit(options(oopts), add = TRUE)
[13:21:33.463]         }
[13:21:33.463]         {
[13:21:33.463]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:33.463]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.463]                 ...future.FUN(...future.X_jj, ...)
[13:21:33.463]             })
[13:21:33.463]         }
[13:21:33.463]     }, args = future.call.arguments)
[13:21:33.463] }
[13:21:33.464] Tweak future expression to call with '...' arguments ... DONE
[13:21:33.464] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.465] - packages: [1] ‘future.apply’
[13:21:33.465] getGlobalsAndPackages() ... DONE
[13:21:33.465] run() for ‘Future’ ...
[13:21:33.465] - state: ‘created’
[13:21:33.465] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:33.469] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:33.469] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:33.469]   - Field: ‘label’
[13:21:33.469]   - Field: ‘local’
[13:21:33.470]   - Field: ‘owner’
[13:21:33.470]   - Field: ‘envir’
[13:21:33.470]   - Field: ‘workers’
[13:21:33.470]   - Field: ‘packages’
[13:21:33.470]   - Field: ‘gc’
[13:21:33.470]   - Field: ‘job’
[13:21:33.470]   - Field: ‘conditions’
[13:21:33.470]   - Field: ‘expr’
[13:21:33.470]   - Field: ‘uuid’
[13:21:33.470]   - Field: ‘seed’
[13:21:33.471]   - Field: ‘version’
[13:21:33.471]   - Field: ‘result’
[13:21:33.471]   - Field: ‘asynchronous’
[13:21:33.471]   - Field: ‘calls’
[13:21:33.471]   - Field: ‘globals’
[13:21:33.471]   - Field: ‘stdout’
[13:21:33.471]   - Field: ‘earlySignal’
[13:21:33.471]   - Field: ‘lazy’
[13:21:33.471]   - Field: ‘state’
[13:21:33.471] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:33.472] - Launch lazy future ...
[13:21:33.472] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:33.472] Packages needed by future strategies (n = 0): <none>
[13:21:33.473] {
[13:21:33.473]     {
[13:21:33.473]         {
[13:21:33.473]             ...future.startTime <- base::Sys.time()
[13:21:33.473]             {
[13:21:33.473]                 {
[13:21:33.473]                   {
[13:21:33.473]                     {
[13:21:33.473]                       {
[13:21:33.473]                         base::local({
[13:21:33.473]                           has_future <- base::requireNamespace("future", 
[13:21:33.473]                             quietly = TRUE)
[13:21:33.473]                           if (has_future) {
[13:21:33.473]                             ns <- base::getNamespace("future")
[13:21:33.473]                             version <- ns[[".package"]][["version"]]
[13:21:33.473]                             if (is.null(version)) 
[13:21:33.473]                               version <- utils::packageVersion("future")
[13:21:33.473]                           }
[13:21:33.473]                           else {
[13:21:33.473]                             version <- NULL
[13:21:33.473]                           }
[13:21:33.473]                           if (!has_future || version < "1.8.0") {
[13:21:33.473]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:33.473]                               "", base::R.version$version.string), 
[13:21:33.473]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:33.473]                                 base::R.version$platform, 8 * 
[13:21:33.473]                                   base::.Machine$sizeof.pointer), 
[13:21:33.473]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:33.473]                                 "release", "version")], collapse = " "), 
[13:21:33.473]                               hostname = base::Sys.info()[["nodename"]])
[13:21:33.473]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:33.473]                               info)
[13:21:33.473]                             info <- base::paste(info, collapse = "; ")
[13:21:33.473]                             if (!has_future) {
[13:21:33.473]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:33.473]                                 info)
[13:21:33.473]                             }
[13:21:33.473]                             else {
[13:21:33.473]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:33.473]                                 info, version)
[13:21:33.473]                             }
[13:21:33.473]                             base::stop(msg)
[13:21:33.473]                           }
[13:21:33.473]                         })
[13:21:33.473]                       }
[13:21:33.473]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:33.473]                       base::options(mc.cores = 1L)
[13:21:33.473]                     }
[13:21:33.473]                     base::local({
[13:21:33.473]                       for (pkg in "future.apply") {
[13:21:33.473]                         base::loadNamespace(pkg)
[13:21:33.473]                         base::library(pkg, character.only = TRUE)
[13:21:33.473]                       }
[13:21:33.473]                     })
[13:21:33.473]                   }
[13:21:33.473]                   options(future.plan = NULL)
[13:21:33.473]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:33.473]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:33.473]                 }
[13:21:33.473]                 ...future.workdir <- getwd()
[13:21:33.473]             }
[13:21:33.473]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:33.473]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:33.473]         }
[13:21:33.473]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:33.473]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:33.473]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:33.473]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:33.473]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:33.473]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:33.473]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:33.473]             base::names(...future.oldOptions))
[13:21:33.473]     }
[13:21:33.473]     if (FALSE) {
[13:21:33.473]     }
[13:21:33.473]     else {
[13:21:33.473]         if (TRUE) {
[13:21:33.473]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:33.473]                 open = "w")
[13:21:33.473]         }
[13:21:33.473]         else {
[13:21:33.473]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:33.473]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:33.473]         }
[13:21:33.473]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:33.473]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:33.473]             base::sink(type = "output", split = FALSE)
[13:21:33.473]             base::close(...future.stdout)
[13:21:33.473]         }, add = TRUE)
[13:21:33.473]     }
[13:21:33.473]     ...future.frame <- base::sys.nframe()
[13:21:33.473]     ...future.conditions <- base::list()
[13:21:33.473]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:33.473]     if (FALSE) {
[13:21:33.473]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:33.473]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:33.473]     }
[13:21:33.473]     ...future.result <- base::tryCatch({
[13:21:33.473]         base::withCallingHandlers({
[13:21:33.473]             ...future.value <- base::withVisible(base::local({
[13:21:33.473]                 withCallingHandlers({
[13:21:33.473]                   {
[13:21:33.473]                     do.call(function(...) {
[13:21:33.473]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.473]                       if (!identical(...future.globals.maxSize.org, 
[13:21:33.473]                         ...future.globals.maxSize)) {
[13:21:33.473]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.473]                         on.exit(options(oopts), add = TRUE)
[13:21:33.473]                       }
[13:21:33.473]                       {
[13:21:33.473]                         lapply(seq_along(...future.elements_ii), 
[13:21:33.473]                           FUN = function(jj) {
[13:21:33.473]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.473]                             ...future.FUN(...future.X_jj, ...)
[13:21:33.473]                           })
[13:21:33.473]                       }
[13:21:33.473]                     }, args = future.call.arguments)
[13:21:33.473]                   }
[13:21:33.473]                 }, immediateCondition = function(cond) {
[13:21:33.473]                   save_rds <- function (object, pathname, ...) 
[13:21:33.473]                   {
[13:21:33.473]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:33.473]                     if (file_test("-f", pathname_tmp)) {
[13:21:33.473]                       fi_tmp <- file.info(pathname_tmp)
[13:21:33.473]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:33.473]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:33.473]                         fi_tmp[["mtime"]])
[13:21:33.473]                     }
[13:21:33.473]                     tryCatch({
[13:21:33.473]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:33.473]                     }, error = function(ex) {
[13:21:33.473]                       msg <- conditionMessage(ex)
[13:21:33.473]                       fi_tmp <- file.info(pathname_tmp)
[13:21:33.473]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:33.473]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:33.473]                         fi_tmp[["mtime"]], msg)
[13:21:33.473]                       ex$message <- msg
[13:21:33.473]                       stop(ex)
[13:21:33.473]                     })
[13:21:33.473]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:33.473]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:33.473]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:33.473]                       fi_tmp <- file.info(pathname_tmp)
[13:21:33.473]                       fi <- file.info(pathname)
[13:21:33.473]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:33.473]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:33.473]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:33.473]                         fi[["size"]], fi[["mtime"]])
[13:21:33.473]                       stop(msg)
[13:21:33.473]                     }
[13:21:33.473]                     invisible(pathname)
[13:21:33.473]                   }
[13:21:33.473]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:33.473]                     rootPath = tempdir()) 
[13:21:33.473]                   {
[13:21:33.473]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:33.473]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:33.473]                       tmpdir = path, fileext = ".rds")
[13:21:33.473]                     save_rds(obj, file)
[13:21:33.473]                   }
[13:21:33.473]                   saveImmediateCondition(cond, path = "/tmp/RtmpbpFWGO/.future/immediateConditions")
[13:21:33.473]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.473]                   {
[13:21:33.473]                     inherits <- base::inherits
[13:21:33.473]                     invokeRestart <- base::invokeRestart
[13:21:33.473]                     is.null <- base::is.null
[13:21:33.473]                     muffled <- FALSE
[13:21:33.473]                     if (inherits(cond, "message")) {
[13:21:33.473]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:33.473]                       if (muffled) 
[13:21:33.473]                         invokeRestart("muffleMessage")
[13:21:33.473]                     }
[13:21:33.473]                     else if (inherits(cond, "warning")) {
[13:21:33.473]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:33.473]                       if (muffled) 
[13:21:33.473]                         invokeRestart("muffleWarning")
[13:21:33.473]                     }
[13:21:33.473]                     else if (inherits(cond, "condition")) {
[13:21:33.473]                       if (!is.null(pattern)) {
[13:21:33.473]                         computeRestarts <- base::computeRestarts
[13:21:33.473]                         grepl <- base::grepl
[13:21:33.473]                         restarts <- computeRestarts(cond)
[13:21:33.473]                         for (restart in restarts) {
[13:21:33.473]                           name <- restart$name
[13:21:33.473]                           if (is.null(name)) 
[13:21:33.473]                             next
[13:21:33.473]                           if (!grepl(pattern, name)) 
[13:21:33.473]                             next
[13:21:33.473]                           invokeRestart(restart)
[13:21:33.473]                           muffled <- TRUE
[13:21:33.473]                           break
[13:21:33.473]                         }
[13:21:33.473]                       }
[13:21:33.473]                     }
[13:21:33.473]                     invisible(muffled)
[13:21:33.473]                   }
[13:21:33.473]                   muffleCondition(cond)
[13:21:33.473]                 })
[13:21:33.473]             }))
[13:21:33.473]             future::FutureResult(value = ...future.value$value, 
[13:21:33.473]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:33.473]                   ...future.rng), globalenv = if (FALSE) 
[13:21:33.473]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:33.473]                     ...future.globalenv.names))
[13:21:33.473]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:33.473]         }, condition = base::local({
[13:21:33.473]             c <- base::c
[13:21:33.473]             inherits <- base::inherits
[13:21:33.473]             invokeRestart <- base::invokeRestart
[13:21:33.473]             length <- base::length
[13:21:33.473]             list <- base::list
[13:21:33.473]             seq.int <- base::seq.int
[13:21:33.473]             signalCondition <- base::signalCondition
[13:21:33.473]             sys.calls <- base::sys.calls
[13:21:33.473]             `[[` <- base::`[[`
[13:21:33.473]             `+` <- base::`+`
[13:21:33.473]             `<<-` <- base::`<<-`
[13:21:33.473]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:33.473]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:33.473]                   3L)]
[13:21:33.473]             }
[13:21:33.473]             function(cond) {
[13:21:33.473]                 is_error <- inherits(cond, "error")
[13:21:33.473]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:33.473]                   NULL)
[13:21:33.473]                 if (is_error) {
[13:21:33.473]                   sessionInformation <- function() {
[13:21:33.473]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:33.473]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:33.473]                       search = base::search(), system = base::Sys.info())
[13:21:33.473]                   }
[13:21:33.473]                   ...future.conditions[[length(...future.conditions) + 
[13:21:33.473]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:33.473]                     cond$call), session = sessionInformation(), 
[13:21:33.473]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:33.473]                   signalCondition(cond)
[13:21:33.473]                 }
[13:21:33.473]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:33.473]                 "immediateCondition"))) {
[13:21:33.473]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:33.473]                   ...future.conditions[[length(...future.conditions) + 
[13:21:33.473]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:33.473]                   if (TRUE && !signal) {
[13:21:33.473]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.473]                     {
[13:21:33.473]                       inherits <- base::inherits
[13:21:33.473]                       invokeRestart <- base::invokeRestart
[13:21:33.473]                       is.null <- base::is.null
[13:21:33.473]                       muffled <- FALSE
[13:21:33.473]                       if (inherits(cond, "message")) {
[13:21:33.473]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:33.473]                         if (muffled) 
[13:21:33.473]                           invokeRestart("muffleMessage")
[13:21:33.473]                       }
[13:21:33.473]                       else if (inherits(cond, "warning")) {
[13:21:33.473]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:33.473]                         if (muffled) 
[13:21:33.473]                           invokeRestart("muffleWarning")
[13:21:33.473]                       }
[13:21:33.473]                       else if (inherits(cond, "condition")) {
[13:21:33.473]                         if (!is.null(pattern)) {
[13:21:33.473]                           computeRestarts <- base::computeRestarts
[13:21:33.473]                           grepl <- base::grepl
[13:21:33.473]                           restarts <- computeRestarts(cond)
[13:21:33.473]                           for (restart in restarts) {
[13:21:33.473]                             name <- restart$name
[13:21:33.473]                             if (is.null(name)) 
[13:21:33.473]                               next
[13:21:33.473]                             if (!grepl(pattern, name)) 
[13:21:33.473]                               next
[13:21:33.473]                             invokeRestart(restart)
[13:21:33.473]                             muffled <- TRUE
[13:21:33.473]                             break
[13:21:33.473]                           }
[13:21:33.473]                         }
[13:21:33.473]                       }
[13:21:33.473]                       invisible(muffled)
[13:21:33.473]                     }
[13:21:33.473]                     muffleCondition(cond, pattern = "^muffle")
[13:21:33.473]                   }
[13:21:33.473]                 }
[13:21:33.473]                 else {
[13:21:33.473]                   if (TRUE) {
[13:21:33.473]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.473]                     {
[13:21:33.473]                       inherits <- base::inherits
[13:21:33.473]                       invokeRestart <- base::invokeRestart
[13:21:33.473]                       is.null <- base::is.null
[13:21:33.473]                       muffled <- FALSE
[13:21:33.473]                       if (inherits(cond, "message")) {
[13:21:33.473]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:33.473]                         if (muffled) 
[13:21:33.473]                           invokeRestart("muffleMessage")
[13:21:33.473]                       }
[13:21:33.473]                       else if (inherits(cond, "warning")) {
[13:21:33.473]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:33.473]                         if (muffled) 
[13:21:33.473]                           invokeRestart("muffleWarning")
[13:21:33.473]                       }
[13:21:33.473]                       else if (inherits(cond, "condition")) {
[13:21:33.473]                         if (!is.null(pattern)) {
[13:21:33.473]                           computeRestarts <- base::computeRestarts
[13:21:33.473]                           grepl <- base::grepl
[13:21:33.473]                           restarts <- computeRestarts(cond)
[13:21:33.473]                           for (restart in restarts) {
[13:21:33.473]                             name <- restart$name
[13:21:33.473]                             if (is.null(name)) 
[13:21:33.473]                               next
[13:21:33.473]                             if (!grepl(pattern, name)) 
[13:21:33.473]                               next
[13:21:33.473]                             invokeRestart(restart)
[13:21:33.473]                             muffled <- TRUE
[13:21:33.473]                             break
[13:21:33.473]                           }
[13:21:33.473]                         }
[13:21:33.473]                       }
[13:21:33.473]                       invisible(muffled)
[13:21:33.473]                     }
[13:21:33.473]                     muffleCondition(cond, pattern = "^muffle")
[13:21:33.473]                   }
[13:21:33.473]                 }
[13:21:33.473]             }
[13:21:33.473]         }))
[13:21:33.473]     }, error = function(ex) {
[13:21:33.473]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:33.473]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:33.473]                 ...future.rng), started = ...future.startTime, 
[13:21:33.473]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:33.473]             version = "1.8"), class = "FutureResult")
[13:21:33.473]     }, finally = {
[13:21:33.473]         if (!identical(...future.workdir, getwd())) 
[13:21:33.473]             setwd(...future.workdir)
[13:21:33.473]         {
[13:21:33.473]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:33.473]                 ...future.oldOptions$nwarnings <- NULL
[13:21:33.473]             }
[13:21:33.473]             base::options(...future.oldOptions)
[13:21:33.473]             if (.Platform$OS.type == "windows") {
[13:21:33.473]                 old_names <- names(...future.oldEnvVars)
[13:21:33.473]                 envs <- base::Sys.getenv()
[13:21:33.473]                 names <- names(envs)
[13:21:33.473]                 common <- intersect(names, old_names)
[13:21:33.473]                 added <- setdiff(names, old_names)
[13:21:33.473]                 removed <- setdiff(old_names, names)
[13:21:33.473]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:33.473]                   envs[common]]
[13:21:33.473]                 NAMES <- toupper(changed)
[13:21:33.473]                 args <- list()
[13:21:33.473]                 for (kk in seq_along(NAMES)) {
[13:21:33.473]                   name <- changed[[kk]]
[13:21:33.473]                   NAME <- NAMES[[kk]]
[13:21:33.473]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.473]                     next
[13:21:33.473]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:33.473]                 }
[13:21:33.473]                 NAMES <- toupper(added)
[13:21:33.473]                 for (kk in seq_along(NAMES)) {
[13:21:33.473]                   name <- added[[kk]]
[13:21:33.473]                   NAME <- NAMES[[kk]]
[13:21:33.473]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.473]                     next
[13:21:33.473]                   args[[name]] <- ""
[13:21:33.473]                 }
[13:21:33.473]                 NAMES <- toupper(removed)
[13:21:33.473]                 for (kk in seq_along(NAMES)) {
[13:21:33.473]                   name <- removed[[kk]]
[13:21:33.473]                   NAME <- NAMES[[kk]]
[13:21:33.473]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.473]                     next
[13:21:33.473]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:33.473]                 }
[13:21:33.473]                 if (length(args) > 0) 
[13:21:33.473]                   base::do.call(base::Sys.setenv, args = args)
[13:21:33.473]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:33.473]             }
[13:21:33.473]             else {
[13:21:33.473]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:33.473]             }
[13:21:33.473]             {
[13:21:33.473]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:33.473]                   0L) {
[13:21:33.473]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:33.473]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:33.473]                   base::options(opts)
[13:21:33.473]                 }
[13:21:33.473]                 {
[13:21:33.473]                   {
[13:21:33.473]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:33.473]                     NULL
[13:21:33.473]                   }
[13:21:33.473]                   options(future.plan = NULL)
[13:21:33.473]                   if (is.na(NA_character_)) 
[13:21:33.473]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:33.473]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:33.473]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:33.473]                     envir = parent.frame()) 
[13:21:33.473]                   {
[13:21:33.473]                     default_workers <- missing(workers)
[13:21:33.473]                     if (is.function(workers)) 
[13:21:33.473]                       workers <- workers()
[13:21:33.473]                     workers <- structure(as.integer(workers), 
[13:21:33.473]                       class = class(workers))
[13:21:33.473]                     stop_if_not(is.finite(workers), workers >= 
[13:21:33.473]                       1L)
[13:21:33.473]                     if ((workers == 1L && !inherits(workers, 
[13:21:33.473]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:33.473]                       if (default_workers) 
[13:21:33.473]                         supportsMulticore(warn = TRUE)
[13:21:33.473]                       return(sequential(..., envir = envir))
[13:21:33.473]                     }
[13:21:33.473]                     oopts <- options(mc.cores = workers)
[13:21:33.473]                     on.exit(options(oopts))
[13:21:33.473]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:33.473]                       envir = envir)
[13:21:33.473]                     if (!future$lazy) 
[13:21:33.473]                       future <- run(future)
[13:21:33.473]                     invisible(future)
[13:21:33.473]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:33.473]                 }
[13:21:33.473]             }
[13:21:33.473]         }
[13:21:33.473]     })
[13:21:33.473]     if (TRUE) {
[13:21:33.473]         base::sink(type = "output", split = FALSE)
[13:21:33.473]         if (TRUE) {
[13:21:33.473]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:33.473]         }
[13:21:33.473]         else {
[13:21:33.473]             ...future.result["stdout"] <- base::list(NULL)
[13:21:33.473]         }
[13:21:33.473]         base::close(...future.stdout)
[13:21:33.473]         ...future.stdout <- NULL
[13:21:33.473]     }
[13:21:33.473]     ...future.result$conditions <- ...future.conditions
[13:21:33.473]     ...future.result$finished <- base::Sys.time()
[13:21:33.473]     ...future.result
[13:21:33.473] }
[13:21:33.475] assign_globals() ...
[13:21:33.475] List of 11
[13:21:33.475]  $ ...future.FUN            :function (x, ...)  
[13:21:33.475]  $ x_FUN                    :function (x)  
[13:21:33.475]  $ times                    : int 0
[13:21:33.475]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:33.475]  $ stop_if_not              :function (...)  
[13:21:33.475]  $ dim                      : NULL
[13:21:33.475]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:21:33.475]  $ future.call.arguments    : list()
[13:21:33.475]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:33.475]  $ ...future.elements_ii    :List of 5
[13:21:33.475]   ..$ : int 1
[13:21:33.475]   ..$ : int 2
[13:21:33.475]   ..$ : int 3
[13:21:33.475]   ..$ : int 4
[13:21:33.475]   ..$ : int 5
[13:21:33.475]  $ ...future.seeds_ii       : NULL
[13:21:33.475]  $ ...future.globals.maxSize: NULL
[13:21:33.475]  - attr(*, "where")=List of 11
[13:21:33.475]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:33.475]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:33.475]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:33.475]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:33.475]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:33.475]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:33.475]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:33.475]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:33.475]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:33.475]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:33.475]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:33.475]  - attr(*, "resolved")= logi FALSE
[13:21:33.475]  - attr(*, "total_size")= num 95472
[13:21:33.475]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:33.475]  - attr(*, "already-done")= logi TRUE
[13:21:33.484] - copied ‘...future.FUN’ to environment
[13:21:33.484] - reassign environment for ‘x_FUN’
[13:21:33.484] - copied ‘x_FUN’ to environment
[13:21:33.484] - copied ‘times’ to environment
[13:21:33.484] - copied ‘stopf’ to environment
[13:21:33.484] - copied ‘stop_if_not’ to environment
[13:21:33.484] - copied ‘dim’ to environment
[13:21:33.485] - copied ‘valid_types’ to environment
[13:21:33.485] - copied ‘future.call.arguments’ to environment
[13:21:33.485] - copied ‘...future.elements_ii’ to environment
[13:21:33.485] - copied ‘...future.seeds_ii’ to environment
[13:21:33.485] - copied ‘...future.globals.maxSize’ to environment
[13:21:33.485] assign_globals() ... done
[13:21:33.485] requestCore(): workers = 2
[13:21:33.489] MulticoreFuture started
[13:21:33.490] - Launch lazy future ... done
[13:21:33.490] run() for ‘MulticoreFuture’ ... done
[13:21:33.491] Created future:
[13:21:33.491] plan(): Setting new future strategy stack:
[13:21:33.492] List of future strategies:
[13:21:33.492] 1. sequential:
[13:21:33.492]    - args: function (..., envir = parent.frame())
[13:21:33.492]    - tweaked: FALSE
[13:21:33.492]    - call: NULL
[13:21:33.493] plan(): nbrOfWorkers() = 1
[13:21:33.496] plan(): Setting new future strategy stack:
[13:21:33.496] List of future strategies:
[13:21:33.496] 1. multicore:
[13:21:33.496]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:33.496]    - tweaked: FALSE
[13:21:33.496]    - call: plan(strategy)
[13:21:33.503] plan(): nbrOfWorkers() = 2
[13:21:33.491] MulticoreFuture:
[13:21:33.491] Label: ‘future_vapply-1’
[13:21:33.491] Expression:
[13:21:33.491] {
[13:21:33.491]     do.call(function(...) {
[13:21:33.491]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.491]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:33.491]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.491]             on.exit(options(oopts), add = TRUE)
[13:21:33.491]         }
[13:21:33.491]         {
[13:21:33.491]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:33.491]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.491]                 ...future.FUN(...future.X_jj, ...)
[13:21:33.491]             })
[13:21:33.491]         }
[13:21:33.491]     }, args = future.call.arguments)
[13:21:33.491] }
[13:21:33.491] Lazy evaluation: FALSE
[13:21:33.491] Asynchronous evaluation: TRUE
[13:21:33.491] Local evaluation: TRUE
[13:21:33.491] Environment: R_GlobalEnv
[13:21:33.491] Capture standard output: TRUE
[13:21:33.491] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:33.491] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:33.491] Packages: 1 packages (‘future.apply’)
[13:21:33.491] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:33.491] Resolved: TRUE
[13:21:33.491] Value: <not collected>
[13:21:33.491] Conditions captured: <none>
[13:21:33.491] Early signaling: FALSE
[13:21:33.491] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:33.491] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:33.504] Chunk #1 of 2 ... DONE
[13:21:33.504] Chunk #2 of 2 ...
[13:21:33.505]  - Finding globals in 'X' for chunk #2 ...
[13:21:33.505] getGlobalsAndPackages() ...
[13:21:33.505] Searching for globals...
[13:21:33.506] 
[13:21:33.506] Searching for globals ... DONE
[13:21:33.506] - globals: [0] <none>
[13:21:33.506] getGlobalsAndPackages() ... DONE
[13:21:33.506]    + additional globals found: [n=0] 
[13:21:33.507]    + additional namespaces needed: [n=0] 
[13:21:33.507]  - Finding globals in 'X' for chunk #2 ... DONE
[13:21:33.507]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:33.507]  - seeds: <none>
[13:21:33.507]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.508] getGlobalsAndPackages() ...
[13:21:33.508] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.508] Resolving globals: FALSE
[13:21:33.509] Tweak future expression to call with '...' arguments ...
[13:21:33.509] {
[13:21:33.509]     do.call(function(...) {
[13:21:33.509]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.509]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:33.509]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.509]             on.exit(options(oopts), add = TRUE)
[13:21:33.509]         }
[13:21:33.509]         {
[13:21:33.509]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:33.509]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.509]                 ...future.FUN(...future.X_jj, ...)
[13:21:33.509]             })
[13:21:33.509]         }
[13:21:33.509]     }, args = future.call.arguments)
[13:21:33.509] }
[13:21:33.509] Tweak future expression to call with '...' arguments ... DONE
[13:21:33.510] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.510] - packages: [1] ‘future.apply’
[13:21:33.510] getGlobalsAndPackages() ... DONE
[13:21:33.511] run() for ‘Future’ ...
[13:21:33.511] - state: ‘created’
[13:21:33.511] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:33.516] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:33.517] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:33.517]   - Field: ‘label’
[13:21:33.517]   - Field: ‘local’
[13:21:33.517]   - Field: ‘owner’
[13:21:33.517]   - Field: ‘envir’
[13:21:33.517]   - Field: ‘workers’
[13:21:33.518]   - Field: ‘packages’
[13:21:33.518]   - Field: ‘gc’
[13:21:33.518]   - Field: ‘job’
[13:21:33.518]   - Field: ‘conditions’
[13:21:33.518]   - Field: ‘expr’
[13:21:33.518]   - Field: ‘uuid’
[13:21:33.518]   - Field: ‘seed’
[13:21:33.519]   - Field: ‘version’
[13:21:33.519]   - Field: ‘result’
[13:21:33.519]   - Field: ‘asynchronous’
[13:21:33.519]   - Field: ‘calls’
[13:21:33.519]   - Field: ‘globals’
[13:21:33.519]   - Field: ‘stdout’
[13:21:33.519]   - Field: ‘earlySignal’
[13:21:33.519]   - Field: ‘lazy’
[13:21:33.520]   - Field: ‘state’
[13:21:33.520] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:33.520] - Launch lazy future ...
[13:21:33.520] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:33.521] Packages needed by future strategies (n = 0): <none>
[13:21:33.521] {
[13:21:33.521]     {
[13:21:33.521]         {
[13:21:33.521]             ...future.startTime <- base::Sys.time()
[13:21:33.521]             {
[13:21:33.521]                 {
[13:21:33.521]                   {
[13:21:33.521]                     {
[13:21:33.521]                       {
[13:21:33.521]                         base::local({
[13:21:33.521]                           has_future <- base::requireNamespace("future", 
[13:21:33.521]                             quietly = TRUE)
[13:21:33.521]                           if (has_future) {
[13:21:33.521]                             ns <- base::getNamespace("future")
[13:21:33.521]                             version <- ns[[".package"]][["version"]]
[13:21:33.521]                             if (is.null(version)) 
[13:21:33.521]                               version <- utils::packageVersion("future")
[13:21:33.521]                           }
[13:21:33.521]                           else {
[13:21:33.521]                             version <- NULL
[13:21:33.521]                           }
[13:21:33.521]                           if (!has_future || version < "1.8.0") {
[13:21:33.521]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:33.521]                               "", base::R.version$version.string), 
[13:21:33.521]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:33.521]                                 base::R.version$platform, 8 * 
[13:21:33.521]                                   base::.Machine$sizeof.pointer), 
[13:21:33.521]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:33.521]                                 "release", "version")], collapse = " "), 
[13:21:33.521]                               hostname = base::Sys.info()[["nodename"]])
[13:21:33.521]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:33.521]                               info)
[13:21:33.521]                             info <- base::paste(info, collapse = "; ")
[13:21:33.521]                             if (!has_future) {
[13:21:33.521]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:33.521]                                 info)
[13:21:33.521]                             }
[13:21:33.521]                             else {
[13:21:33.521]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:33.521]                                 info, version)
[13:21:33.521]                             }
[13:21:33.521]                             base::stop(msg)
[13:21:33.521]                           }
[13:21:33.521]                         })
[13:21:33.521]                       }
[13:21:33.521]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:33.521]                       base::options(mc.cores = 1L)
[13:21:33.521]                     }
[13:21:33.521]                     base::local({
[13:21:33.521]                       for (pkg in "future.apply") {
[13:21:33.521]                         base::loadNamespace(pkg)
[13:21:33.521]                         base::library(pkg, character.only = TRUE)
[13:21:33.521]                       }
[13:21:33.521]                     })
[13:21:33.521]                   }
[13:21:33.521]                   options(future.plan = NULL)
[13:21:33.521]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:33.521]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:33.521]                 }
[13:21:33.521]                 ...future.workdir <- getwd()
[13:21:33.521]             }
[13:21:33.521]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:33.521]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:33.521]         }
[13:21:33.521]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:33.521]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:33.521]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:33.521]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:33.521]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:33.521]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:33.521]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:33.521]             base::names(...future.oldOptions))
[13:21:33.521]     }
[13:21:33.521]     if (FALSE) {
[13:21:33.521]     }
[13:21:33.521]     else {
[13:21:33.521]         if (TRUE) {
[13:21:33.521]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:33.521]                 open = "w")
[13:21:33.521]         }
[13:21:33.521]         else {
[13:21:33.521]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:33.521]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:33.521]         }
[13:21:33.521]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:33.521]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:33.521]             base::sink(type = "output", split = FALSE)
[13:21:33.521]             base::close(...future.stdout)
[13:21:33.521]         }, add = TRUE)
[13:21:33.521]     }
[13:21:33.521]     ...future.frame <- base::sys.nframe()
[13:21:33.521]     ...future.conditions <- base::list()
[13:21:33.521]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:33.521]     if (FALSE) {
[13:21:33.521]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:33.521]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:33.521]     }
[13:21:33.521]     ...future.result <- base::tryCatch({
[13:21:33.521]         base::withCallingHandlers({
[13:21:33.521]             ...future.value <- base::withVisible(base::local({
[13:21:33.521]                 withCallingHandlers({
[13:21:33.521]                   {
[13:21:33.521]                     do.call(function(...) {
[13:21:33.521]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.521]                       if (!identical(...future.globals.maxSize.org, 
[13:21:33.521]                         ...future.globals.maxSize)) {
[13:21:33.521]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.521]                         on.exit(options(oopts), add = TRUE)
[13:21:33.521]                       }
[13:21:33.521]                       {
[13:21:33.521]                         lapply(seq_along(...future.elements_ii), 
[13:21:33.521]                           FUN = function(jj) {
[13:21:33.521]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.521]                             ...future.FUN(...future.X_jj, ...)
[13:21:33.521]                           })
[13:21:33.521]                       }
[13:21:33.521]                     }, args = future.call.arguments)
[13:21:33.521]                   }
[13:21:33.521]                 }, immediateCondition = function(cond) {
[13:21:33.521]                   save_rds <- function (object, pathname, ...) 
[13:21:33.521]                   {
[13:21:33.521]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:33.521]                     if (file_test("-f", pathname_tmp)) {
[13:21:33.521]                       fi_tmp <- file.info(pathname_tmp)
[13:21:33.521]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:33.521]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:33.521]                         fi_tmp[["mtime"]])
[13:21:33.521]                     }
[13:21:33.521]                     tryCatch({
[13:21:33.521]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:33.521]                     }, error = function(ex) {
[13:21:33.521]                       msg <- conditionMessage(ex)
[13:21:33.521]                       fi_tmp <- file.info(pathname_tmp)
[13:21:33.521]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:33.521]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:33.521]                         fi_tmp[["mtime"]], msg)
[13:21:33.521]                       ex$message <- msg
[13:21:33.521]                       stop(ex)
[13:21:33.521]                     })
[13:21:33.521]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:33.521]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:33.521]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:33.521]                       fi_tmp <- file.info(pathname_tmp)
[13:21:33.521]                       fi <- file.info(pathname)
[13:21:33.521]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:33.521]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:33.521]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:33.521]                         fi[["size"]], fi[["mtime"]])
[13:21:33.521]                       stop(msg)
[13:21:33.521]                     }
[13:21:33.521]                     invisible(pathname)
[13:21:33.521]                   }
[13:21:33.521]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:33.521]                     rootPath = tempdir()) 
[13:21:33.521]                   {
[13:21:33.521]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:33.521]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:33.521]                       tmpdir = path, fileext = ".rds")
[13:21:33.521]                     save_rds(obj, file)
[13:21:33.521]                   }
[13:21:33.521]                   saveImmediateCondition(cond, path = "/tmp/RtmpbpFWGO/.future/immediateConditions")
[13:21:33.521]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.521]                   {
[13:21:33.521]                     inherits <- base::inherits
[13:21:33.521]                     invokeRestart <- base::invokeRestart
[13:21:33.521]                     is.null <- base::is.null
[13:21:33.521]                     muffled <- FALSE
[13:21:33.521]                     if (inherits(cond, "message")) {
[13:21:33.521]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:33.521]                       if (muffled) 
[13:21:33.521]                         invokeRestart("muffleMessage")
[13:21:33.521]                     }
[13:21:33.521]                     else if (inherits(cond, "warning")) {
[13:21:33.521]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:33.521]                       if (muffled) 
[13:21:33.521]                         invokeRestart("muffleWarning")
[13:21:33.521]                     }
[13:21:33.521]                     else if (inherits(cond, "condition")) {
[13:21:33.521]                       if (!is.null(pattern)) {
[13:21:33.521]                         computeRestarts <- base::computeRestarts
[13:21:33.521]                         grepl <- base::grepl
[13:21:33.521]                         restarts <- computeRestarts(cond)
[13:21:33.521]                         for (restart in restarts) {
[13:21:33.521]                           name <- restart$name
[13:21:33.521]                           if (is.null(name)) 
[13:21:33.521]                             next
[13:21:33.521]                           if (!grepl(pattern, name)) 
[13:21:33.521]                             next
[13:21:33.521]                           invokeRestart(restart)
[13:21:33.521]                           muffled <- TRUE
[13:21:33.521]                           break
[13:21:33.521]                         }
[13:21:33.521]                       }
[13:21:33.521]                     }
[13:21:33.521]                     invisible(muffled)
[13:21:33.521]                   }
[13:21:33.521]                   muffleCondition(cond)
[13:21:33.521]                 })
[13:21:33.521]             }))
[13:21:33.521]             future::FutureResult(value = ...future.value$value, 
[13:21:33.521]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:33.521]                   ...future.rng), globalenv = if (FALSE) 
[13:21:33.521]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:33.521]                     ...future.globalenv.names))
[13:21:33.521]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:33.521]         }, condition = base::local({
[13:21:33.521]             c <- base::c
[13:21:33.521]             inherits <- base::inherits
[13:21:33.521]             invokeRestart <- base::invokeRestart
[13:21:33.521]             length <- base::length
[13:21:33.521]             list <- base::list
[13:21:33.521]             seq.int <- base::seq.int
[13:21:33.521]             signalCondition <- base::signalCondition
[13:21:33.521]             sys.calls <- base::sys.calls
[13:21:33.521]             `[[` <- base::`[[`
[13:21:33.521]             `+` <- base::`+`
[13:21:33.521]             `<<-` <- base::`<<-`
[13:21:33.521]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:33.521]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:33.521]                   3L)]
[13:21:33.521]             }
[13:21:33.521]             function(cond) {
[13:21:33.521]                 is_error <- inherits(cond, "error")
[13:21:33.521]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:33.521]                   NULL)
[13:21:33.521]                 if (is_error) {
[13:21:33.521]                   sessionInformation <- function() {
[13:21:33.521]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:33.521]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:33.521]                       search = base::search(), system = base::Sys.info())
[13:21:33.521]                   }
[13:21:33.521]                   ...future.conditions[[length(...future.conditions) + 
[13:21:33.521]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:33.521]                     cond$call), session = sessionInformation(), 
[13:21:33.521]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:33.521]                   signalCondition(cond)
[13:21:33.521]                 }
[13:21:33.521]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:33.521]                 "immediateCondition"))) {
[13:21:33.521]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:33.521]                   ...future.conditions[[length(...future.conditions) + 
[13:21:33.521]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:33.521]                   if (TRUE && !signal) {
[13:21:33.521]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.521]                     {
[13:21:33.521]                       inherits <- base::inherits
[13:21:33.521]                       invokeRestart <- base::invokeRestart
[13:21:33.521]                       is.null <- base::is.null
[13:21:33.521]                       muffled <- FALSE
[13:21:33.521]                       if (inherits(cond, "message")) {
[13:21:33.521]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:33.521]                         if (muffled) 
[13:21:33.521]                           invokeRestart("muffleMessage")
[13:21:33.521]                       }
[13:21:33.521]                       else if (inherits(cond, "warning")) {
[13:21:33.521]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:33.521]                         if (muffled) 
[13:21:33.521]                           invokeRestart("muffleWarning")
[13:21:33.521]                       }
[13:21:33.521]                       else if (inherits(cond, "condition")) {
[13:21:33.521]                         if (!is.null(pattern)) {
[13:21:33.521]                           computeRestarts <- base::computeRestarts
[13:21:33.521]                           grepl <- base::grepl
[13:21:33.521]                           restarts <- computeRestarts(cond)
[13:21:33.521]                           for (restart in restarts) {
[13:21:33.521]                             name <- restart$name
[13:21:33.521]                             if (is.null(name)) 
[13:21:33.521]                               next
[13:21:33.521]                             if (!grepl(pattern, name)) 
[13:21:33.521]                               next
[13:21:33.521]                             invokeRestart(restart)
[13:21:33.521]                             muffled <- TRUE
[13:21:33.521]                             break
[13:21:33.521]                           }
[13:21:33.521]                         }
[13:21:33.521]                       }
[13:21:33.521]                       invisible(muffled)
[13:21:33.521]                     }
[13:21:33.521]                     muffleCondition(cond, pattern = "^muffle")
[13:21:33.521]                   }
[13:21:33.521]                 }
[13:21:33.521]                 else {
[13:21:33.521]                   if (TRUE) {
[13:21:33.521]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.521]                     {
[13:21:33.521]                       inherits <- base::inherits
[13:21:33.521]                       invokeRestart <- base::invokeRestart
[13:21:33.521]                       is.null <- base::is.null
[13:21:33.521]                       muffled <- FALSE
[13:21:33.521]                       if (inherits(cond, "message")) {
[13:21:33.521]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:33.521]                         if (muffled) 
[13:21:33.521]                           invokeRestart("muffleMessage")
[13:21:33.521]                       }
[13:21:33.521]                       else if (inherits(cond, "warning")) {
[13:21:33.521]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:33.521]                         if (muffled) 
[13:21:33.521]                           invokeRestart("muffleWarning")
[13:21:33.521]                       }
[13:21:33.521]                       else if (inherits(cond, "condition")) {
[13:21:33.521]                         if (!is.null(pattern)) {
[13:21:33.521]                           computeRestarts <- base::computeRestarts
[13:21:33.521]                           grepl <- base::grepl
[13:21:33.521]                           restarts <- computeRestarts(cond)
[13:21:33.521]                           for (restart in restarts) {
[13:21:33.521]                             name <- restart$name
[13:21:33.521]                             if (is.null(name)) 
[13:21:33.521]                               next
[13:21:33.521]                             if (!grepl(pattern, name)) 
[13:21:33.521]                               next
[13:21:33.521]                             invokeRestart(restart)
[13:21:33.521]                             muffled <- TRUE
[13:21:33.521]                             break
[13:21:33.521]                           }
[13:21:33.521]                         }
[13:21:33.521]                       }
[13:21:33.521]                       invisible(muffled)
[13:21:33.521]                     }
[13:21:33.521]                     muffleCondition(cond, pattern = "^muffle")
[13:21:33.521]                   }
[13:21:33.521]                 }
[13:21:33.521]             }
[13:21:33.521]         }))
[13:21:33.521]     }, error = function(ex) {
[13:21:33.521]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:33.521]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:33.521]                 ...future.rng), started = ...future.startTime, 
[13:21:33.521]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:33.521]             version = "1.8"), class = "FutureResult")
[13:21:33.521]     }, finally = {
[13:21:33.521]         if (!identical(...future.workdir, getwd())) 
[13:21:33.521]             setwd(...future.workdir)
[13:21:33.521]         {
[13:21:33.521]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:33.521]                 ...future.oldOptions$nwarnings <- NULL
[13:21:33.521]             }
[13:21:33.521]             base::options(...future.oldOptions)
[13:21:33.521]             if (.Platform$OS.type == "windows") {
[13:21:33.521]                 old_names <- names(...future.oldEnvVars)
[13:21:33.521]                 envs <- base::Sys.getenv()
[13:21:33.521]                 names <- names(envs)
[13:21:33.521]                 common <- intersect(names, old_names)
[13:21:33.521]                 added <- setdiff(names, old_names)
[13:21:33.521]                 removed <- setdiff(old_names, names)
[13:21:33.521]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:33.521]                   envs[common]]
[13:21:33.521]                 NAMES <- toupper(changed)
[13:21:33.521]                 args <- list()
[13:21:33.521]                 for (kk in seq_along(NAMES)) {
[13:21:33.521]                   name <- changed[[kk]]
[13:21:33.521]                   NAME <- NAMES[[kk]]
[13:21:33.521]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.521]                     next
[13:21:33.521]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:33.521]                 }
[13:21:33.521]                 NAMES <- toupper(added)
[13:21:33.521]                 for (kk in seq_along(NAMES)) {
[13:21:33.521]                   name <- added[[kk]]
[13:21:33.521]                   NAME <- NAMES[[kk]]
[13:21:33.521]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.521]                     next
[13:21:33.521]                   args[[name]] <- ""
[13:21:33.521]                 }
[13:21:33.521]                 NAMES <- toupper(removed)
[13:21:33.521]                 for (kk in seq_along(NAMES)) {
[13:21:33.521]                   name <- removed[[kk]]
[13:21:33.521]                   NAME <- NAMES[[kk]]
[13:21:33.521]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.521]                     next
[13:21:33.521]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:33.521]                 }
[13:21:33.521]                 if (length(args) > 0) 
[13:21:33.521]                   base::do.call(base::Sys.setenv, args = args)
[13:21:33.521]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:33.521]             }
[13:21:33.521]             else {
[13:21:33.521]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:33.521]             }
[13:21:33.521]             {
[13:21:33.521]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:33.521]                   0L) {
[13:21:33.521]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:33.521]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:33.521]                   base::options(opts)
[13:21:33.521]                 }
[13:21:33.521]                 {
[13:21:33.521]                   {
[13:21:33.521]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:33.521]                     NULL
[13:21:33.521]                   }
[13:21:33.521]                   options(future.plan = NULL)
[13:21:33.521]                   if (is.na(NA_character_)) 
[13:21:33.521]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:33.521]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:33.521]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:33.521]                     envir = parent.frame()) 
[13:21:33.521]                   {
[13:21:33.521]                     default_workers <- missing(workers)
[13:21:33.521]                     if (is.function(workers)) 
[13:21:33.521]                       workers <- workers()
[13:21:33.521]                     workers <- structure(as.integer(workers), 
[13:21:33.521]                       class = class(workers))
[13:21:33.521]                     stop_if_not(is.finite(workers), workers >= 
[13:21:33.521]                       1L)
[13:21:33.521]                     if ((workers == 1L && !inherits(workers, 
[13:21:33.521]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:33.521]                       if (default_workers) 
[13:21:33.521]                         supportsMulticore(warn = TRUE)
[13:21:33.521]                       return(sequential(..., envir = envir))
[13:21:33.521]                     }
[13:21:33.521]                     oopts <- options(mc.cores = workers)
[13:21:33.521]                     on.exit(options(oopts))
[13:21:33.521]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:33.521]                       envir = envir)
[13:21:33.521]                     if (!future$lazy) 
[13:21:33.521]                       future <- run(future)
[13:21:33.521]                     invisible(future)
[13:21:33.521]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:33.521]                 }
[13:21:33.521]             }
[13:21:33.521]         }
[13:21:33.521]     })
[13:21:33.521]     if (TRUE) {
[13:21:33.521]         base::sink(type = "output", split = FALSE)
[13:21:33.521]         if (TRUE) {
[13:21:33.521]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:33.521]         }
[13:21:33.521]         else {
[13:21:33.521]             ...future.result["stdout"] <- base::list(NULL)
[13:21:33.521]         }
[13:21:33.521]         base::close(...future.stdout)
[13:21:33.521]         ...future.stdout <- NULL
[13:21:33.521]     }
[13:21:33.521]     ...future.result$conditions <- ...future.conditions
[13:21:33.521]     ...future.result$finished <- base::Sys.time()
[13:21:33.521]     ...future.result
[13:21:33.521] }
[13:21:33.525] assign_globals() ...
[13:21:33.525] List of 11
[13:21:33.525]  $ ...future.FUN            :function (x, ...)  
[13:21:33.525]  $ x_FUN                    :function (x)  
[13:21:33.525]  $ times                    : int 0
[13:21:33.525]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:33.525]  $ stop_if_not              :function (...)  
[13:21:33.525]  $ dim                      : NULL
[13:21:33.525]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:21:33.525]  $ future.call.arguments    : list()
[13:21:33.525]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:33.525]  $ ...future.elements_ii    :List of 5
[13:21:33.525]   ..$ : int 6
[13:21:33.525]   ..$ : int 7
[13:21:33.525]   ..$ : int 8
[13:21:33.525]   ..$ : int 9
[13:21:33.525]   ..$ : int 10
[13:21:33.525]  $ ...future.seeds_ii       : NULL
[13:21:33.525]  $ ...future.globals.maxSize: NULL
[13:21:33.525]  - attr(*, "where")=List of 11
[13:21:33.525]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:33.525]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:33.525]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:33.525]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:33.525]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:33.525]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:33.525]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:33.525]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:33.525]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:33.525]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:33.525]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:33.525]  - attr(*, "resolved")= logi FALSE
[13:21:33.525]  - attr(*, "total_size")= num 95472
[13:21:33.525]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:33.525]  - attr(*, "already-done")= logi TRUE
[13:21:33.537] - copied ‘...future.FUN’ to environment
[13:21:33.538] - reassign environment for ‘x_FUN’
[13:21:33.538] - copied ‘x_FUN’ to environment
[13:21:33.538] - copied ‘times’ to environment
[13:21:33.538] - copied ‘stopf’ to environment
[13:21:33.538] - copied ‘stop_if_not’ to environment
[13:21:33.538] - copied ‘dim’ to environment
[13:21:33.538] - copied ‘valid_types’ to environment
[13:21:33.538] - copied ‘future.call.arguments’ to environment
[13:21:33.539] - copied ‘...future.elements_ii’ to environment
[13:21:33.539] - copied ‘...future.seeds_ii’ to environment
[13:21:33.539] - copied ‘...future.globals.maxSize’ to environment
[13:21:33.539] assign_globals() ... done
[13:21:33.539] requestCore(): workers = 2
[13:21:33.542] MulticoreFuture started
[13:21:33.542] - Launch lazy future ... done
[13:21:33.543] run() for ‘MulticoreFuture’ ... done
[13:21:33.544] Created future:
[13:21:33.544] plan(): Setting new future strategy stack:
[13:21:33.544] List of future strategies:
[13:21:33.544] 1. sequential:
[13:21:33.544]    - args: function (..., envir = parent.frame())
[13:21:33.544]    - tweaked: FALSE
[13:21:33.544]    - call: NULL
[13:21:33.545] plan(): nbrOfWorkers() = 1
[13:21:33.548] plan(): Setting new future strategy stack:
[13:21:33.549] List of future strategies:
[13:21:33.549] 1. multicore:
[13:21:33.549]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:33.549]    - tweaked: FALSE
[13:21:33.549]    - call: plan(strategy)
[13:21:33.555] plan(): nbrOfWorkers() = 2
[13:21:33.544] MulticoreFuture:
[13:21:33.544] Label: ‘future_vapply-2’
[13:21:33.544] Expression:
[13:21:33.544] {
[13:21:33.544]     do.call(function(...) {
[13:21:33.544]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.544]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:33.544]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.544]             on.exit(options(oopts), add = TRUE)
[13:21:33.544]         }
[13:21:33.544]         {
[13:21:33.544]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:33.544]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.544]                 ...future.FUN(...future.X_jj, ...)
[13:21:33.544]             })
[13:21:33.544]         }
[13:21:33.544]     }, args = future.call.arguments)
[13:21:33.544] }
[13:21:33.544] Lazy evaluation: FALSE
[13:21:33.544] Asynchronous evaluation: TRUE
[13:21:33.544] Local evaluation: TRUE
[13:21:33.544] Environment: R_GlobalEnv
[13:21:33.544] Capture standard output: TRUE
[13:21:33.544] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:33.544] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:33.544] Packages: 1 packages (‘future.apply’)
[13:21:33.544] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:33.544] Resolved: TRUE
[13:21:33.544] Value: <not collected>
[13:21:33.544] Conditions captured: <none>
[13:21:33.544] Early signaling: FALSE
[13:21:33.544] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:33.544] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:33.556] Chunk #2 of 2 ... DONE
[13:21:33.556] Launching 2 futures (chunks) ... DONE
[13:21:33.556] Resolving 2 futures (chunks) ...
[13:21:33.557] resolve() on list ...
[13:21:33.557]  recursive: 0
[13:21:33.557]  length: 2
[13:21:33.557] 
[13:21:33.558] Future #1
[13:21:33.558] result() for MulticoreFuture ...
[13:21:33.559] result() for MulticoreFuture ...
[13:21:33.559] result() for MulticoreFuture ... done
[13:21:33.559] result() for MulticoreFuture ... done
[13:21:33.559] result() for MulticoreFuture ...
[13:21:33.560] result() for MulticoreFuture ... done
[13:21:33.560] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:21:33.560] - nx: 2
[13:21:33.560] - relay: TRUE
[13:21:33.561] - stdout: TRUE
[13:21:33.561] - signal: TRUE
[13:21:33.561] - resignal: FALSE
[13:21:33.562] - force: TRUE
[13:21:33.562] - relayed: [n=2] FALSE, FALSE
[13:21:33.562] - queued futures: [n=2] FALSE, FALSE
[13:21:33.562]  - until=1
[13:21:33.562]  - relaying element #1
[13:21:33.563] result() for MulticoreFuture ...
[13:21:33.563] result() for MulticoreFuture ... done
[13:21:33.563] result() for MulticoreFuture ...
[13:21:33.563] result() for MulticoreFuture ... done
[13:21:33.564] result() for MulticoreFuture ...
[13:21:33.564] result() for MulticoreFuture ... done
[13:21:33.564] result() for MulticoreFuture ...
[13:21:33.564] result() for MulticoreFuture ... done
[13:21:33.564] - relayed: [n=2] TRUE, FALSE
[13:21:33.565] - queued futures: [n=2] TRUE, FALSE
[13:21:33.565] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:21:33.565]  length: 1 (resolved future 1)
[13:21:33.565] Future #2
[13:21:33.566] result() for MulticoreFuture ...
[13:21:33.566] result() for MulticoreFuture ...
[13:21:33.566] result() for MulticoreFuture ... done
[13:21:33.567] result() for MulticoreFuture ... done
[13:21:33.567] result() for MulticoreFuture ...
[13:21:33.567] result() for MulticoreFuture ... done
[13:21:33.567] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:21:33.567] - nx: 2
[13:21:33.567] - relay: TRUE
[13:21:33.567] - stdout: TRUE
[13:21:33.568] - signal: TRUE
[13:21:33.568] - resignal: FALSE
[13:21:33.568] - force: TRUE
[13:21:33.568] - relayed: [n=2] TRUE, FALSE
[13:21:33.568] - queued futures: [n=2] TRUE, FALSE
[13:21:33.568]  - until=2
[13:21:33.568]  - relaying element #2
[13:21:33.568] result() for MulticoreFuture ...
[13:21:33.568] result() for MulticoreFuture ... done
[13:21:33.569] result() for MulticoreFuture ...
[13:21:33.569] result() for MulticoreFuture ... done
[13:21:33.569] result() for MulticoreFuture ...
[13:21:33.569] result() for MulticoreFuture ... done
[13:21:33.569] result() for MulticoreFuture ...
[13:21:33.569] result() for MulticoreFuture ... done
[13:21:33.569] - relayed: [n=2] TRUE, TRUE
[13:21:33.569] - queued futures: [n=2] TRUE, TRUE
[13:21:33.570] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:21:33.570]  length: 0 (resolved future 2)
[13:21:33.570] Relaying remaining futures
[13:21:33.570] signalConditionsASAP(NULL, pos=0) ...
[13:21:33.570] - nx: 2
[13:21:33.570] - relay: TRUE
[13:21:33.570] - stdout: TRUE
[13:21:33.570] - signal: TRUE
[13:21:33.570] - resignal: FALSE
[13:21:33.570] - force: TRUE
[13:21:33.571] - relayed: [n=2] TRUE, TRUE
[13:21:33.571] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:21:33.571] - relayed: [n=2] TRUE, TRUE
[13:21:33.571] - queued futures: [n=2] TRUE, TRUE
[13:21:33.571] signalConditionsASAP(NULL, pos=0) ... done
[13:21:33.571] resolve() on list ... DONE
[13:21:33.571] result() for MulticoreFuture ...
[13:21:33.571] result() for MulticoreFuture ... done
[13:21:33.571] result() for MulticoreFuture ...
[13:21:33.572] result() for MulticoreFuture ... done
[13:21:33.572] result() for MulticoreFuture ...
[13:21:33.572] result() for MulticoreFuture ... done
[13:21:33.572] result() for MulticoreFuture ...
[13:21:33.572] result() for MulticoreFuture ... done
[13:21:33.572]  - Number of value chunks collected: 2
[13:21:33.572] Resolving 2 futures (chunks) ... DONE
[13:21:33.573] Reducing values from 2 chunks ...
[13:21:33.573]  - Number of values collected after concatenation: 10
[13:21:33.573]  - Number of values expected: 10
[13:21:33.573] Reducing values from 2 chunks ... DONE
[13:21:33.573] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[13:21:33.574] future_lapply() ...
[13:21:33.580] Number of chunks: 2
[13:21:33.580] getGlobalsAndPackagesXApply() ...
[13:21:33.580]  - future.globals: TRUE
[13:21:33.581] getGlobalsAndPackages() ...
[13:21:33.581] Searching for globals...
[13:21:33.587] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[13:21:33.587] Searching for globals ... DONE
[13:21:33.587] Resolving globals: FALSE
[13:21:33.589] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[13:21:33.589] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:33.589] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:33.589] - packages: [1] ‘future.apply’
[13:21:33.589] getGlobalsAndPackages() ... DONE
[13:21:33.590]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:33.590]  - needed namespaces: [n=1] ‘future.apply’
[13:21:33.590] Finding globals ... DONE
[13:21:33.590]  - use_args: TRUE
[13:21:33.590]  - Getting '...' globals ...
[13:21:33.590] resolve() on list ...
[13:21:33.590]  recursive: 0
[13:21:33.591]  length: 1
[13:21:33.591]  elements: ‘...’
[13:21:33.591]  length: 0 (resolved future 1)
[13:21:33.591] resolve() on list ... DONE
[13:21:33.591]    - '...' content: [n=0] 
[13:21:33.591] List of 1
[13:21:33.591]  $ ...: list()
[13:21:33.591]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:33.591]  - attr(*, "where")=List of 1
[13:21:33.591]   ..$ ...:<environment: 0x563b6ee36e70> 
[13:21:33.591]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:33.591]  - attr(*, "resolved")= logi TRUE
[13:21:33.591]  - attr(*, "total_size")= num NA
[13:21:33.594]  - Getting '...' globals ... DONE
[13:21:33.594] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:33.594] List of 8
[13:21:33.594]  $ ...future.FUN:function (x, ...)  
[13:21:33.594]  $ x_FUN        :function (x)  
[13:21:33.594]  $ times        : int 0
[13:21:33.594]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:33.594]  $ stop_if_not  :function (...)  
[13:21:33.594]  $ dim          : NULL
[13:21:33.594]  $ valid_types  : chr [1:2] "logical" "integer"
[13:21:33.594]  $ ...          : list()
[13:21:33.594]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:33.594]  - attr(*, "where")=List of 8
[13:21:33.594]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:33.594]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:33.594]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:33.594]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:33.594]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:33.594]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:33.594]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:33.594]   ..$ ...          :<environment: 0x563b6ee36e70> 
[13:21:33.594]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:33.594]  - attr(*, "resolved")= logi FALSE
[13:21:33.594]  - attr(*, "total_size")= num 95400
[13:21:33.600] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:21:33.600] getGlobalsAndPackagesXApply() ... DONE
[13:21:33.600] Number of futures (= number of chunks): 2
[13:21:33.600] Launching 2 futures (chunks) ...
[13:21:33.600] Chunk #1 of 2 ...
[13:21:33.600]  - Finding globals in 'X' for chunk #1 ...
[13:21:33.600] getGlobalsAndPackages() ...
[13:21:33.601] Searching for globals...
[13:21:33.601] 
[13:21:33.601] Searching for globals ... DONE
[13:21:33.601] - globals: [0] <none>
[13:21:33.601] getGlobalsAndPackages() ... DONE
[13:21:33.601]    + additional globals found: [n=0] 
[13:21:33.601]    + additional namespaces needed: [n=0] 
[13:21:33.601]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:33.601]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:33.602]  - seeds: <none>
[13:21:33.602]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.602] getGlobalsAndPackages() ...
[13:21:33.602] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.602] Resolving globals: FALSE
[13:21:33.602] Tweak future expression to call with '...' arguments ...
[13:21:33.602] {
[13:21:33.602]     do.call(function(...) {
[13:21:33.602]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.602]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:33.602]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.602]             on.exit(options(oopts), add = TRUE)
[13:21:33.602]         }
[13:21:33.602]         {
[13:21:33.602]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:33.602]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.602]                 ...future.FUN(...future.X_jj, ...)
[13:21:33.602]             })
[13:21:33.602]         }
[13:21:33.602]     }, args = future.call.arguments)
[13:21:33.602] }
[13:21:33.603] Tweak future expression to call with '...' arguments ... DONE
[13:21:33.603] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.603] - packages: [1] ‘future.apply’
[13:21:33.603] getGlobalsAndPackages() ... DONE
[13:21:33.604] run() for ‘Future’ ...
[13:21:33.604] - state: ‘created’
[13:21:33.604] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:33.608] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:33.610] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:33.610]   - Field: ‘label’
[13:21:33.610]   - Field: ‘local’
[13:21:33.610]   - Field: ‘owner’
[13:21:33.611]   - Field: ‘envir’
[13:21:33.611]   - Field: ‘workers’
[13:21:33.611]   - Field: ‘packages’
[13:21:33.611]   - Field: ‘gc’
[13:21:33.611]   - Field: ‘job’
[13:21:33.611]   - Field: ‘conditions’
[13:21:33.611]   - Field: ‘expr’
[13:21:33.611]   - Field: ‘uuid’
[13:21:33.612]   - Field: ‘seed’
[13:21:33.612]   - Field: ‘version’
[13:21:33.612]   - Field: ‘result’
[13:21:33.612]   - Field: ‘asynchronous’
[13:21:33.612]   - Field: ‘calls’
[13:21:33.612]   - Field: ‘globals’
[13:21:33.612]   - Field: ‘stdout’
[13:21:33.613]   - Field: ‘earlySignal’
[13:21:33.613]   - Field: ‘lazy’
[13:21:33.613]   - Field: ‘state’
[13:21:33.613] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:33.613] - Launch lazy future ...
[13:21:33.613] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:33.614] Packages needed by future strategies (n = 0): <none>
[13:21:33.614] {
[13:21:33.614]     {
[13:21:33.614]         {
[13:21:33.614]             ...future.startTime <- base::Sys.time()
[13:21:33.614]             {
[13:21:33.614]                 {
[13:21:33.614]                   {
[13:21:33.614]                     {
[13:21:33.614]                       {
[13:21:33.614]                         base::local({
[13:21:33.614]                           has_future <- base::requireNamespace("future", 
[13:21:33.614]                             quietly = TRUE)
[13:21:33.614]                           if (has_future) {
[13:21:33.614]                             ns <- base::getNamespace("future")
[13:21:33.614]                             version <- ns[[".package"]][["version"]]
[13:21:33.614]                             if (is.null(version)) 
[13:21:33.614]                               version <- utils::packageVersion("future")
[13:21:33.614]                           }
[13:21:33.614]                           else {
[13:21:33.614]                             version <- NULL
[13:21:33.614]                           }
[13:21:33.614]                           if (!has_future || version < "1.8.0") {
[13:21:33.614]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:33.614]                               "", base::R.version$version.string), 
[13:21:33.614]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:33.614]                                 base::R.version$platform, 8 * 
[13:21:33.614]                                   base::.Machine$sizeof.pointer), 
[13:21:33.614]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:33.614]                                 "release", "version")], collapse = " "), 
[13:21:33.614]                               hostname = base::Sys.info()[["nodename"]])
[13:21:33.614]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:33.614]                               info)
[13:21:33.614]                             info <- base::paste(info, collapse = "; ")
[13:21:33.614]                             if (!has_future) {
[13:21:33.614]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:33.614]                                 info)
[13:21:33.614]                             }
[13:21:33.614]                             else {
[13:21:33.614]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:33.614]                                 info, version)
[13:21:33.614]                             }
[13:21:33.614]                             base::stop(msg)
[13:21:33.614]                           }
[13:21:33.614]                         })
[13:21:33.614]                       }
[13:21:33.614]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:33.614]                       base::options(mc.cores = 1L)
[13:21:33.614]                     }
[13:21:33.614]                     base::local({
[13:21:33.614]                       for (pkg in "future.apply") {
[13:21:33.614]                         base::loadNamespace(pkg)
[13:21:33.614]                         base::library(pkg, character.only = TRUE)
[13:21:33.614]                       }
[13:21:33.614]                     })
[13:21:33.614]                   }
[13:21:33.614]                   options(future.plan = NULL)
[13:21:33.614]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:33.614]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:33.614]                 }
[13:21:33.614]                 ...future.workdir <- getwd()
[13:21:33.614]             }
[13:21:33.614]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:33.614]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:33.614]         }
[13:21:33.614]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:33.614]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:33.614]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:33.614]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:33.614]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:33.614]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:33.614]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:33.614]             base::names(...future.oldOptions))
[13:21:33.614]     }
[13:21:33.614]     if (FALSE) {
[13:21:33.614]     }
[13:21:33.614]     else {
[13:21:33.614]         if (TRUE) {
[13:21:33.614]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:33.614]                 open = "w")
[13:21:33.614]         }
[13:21:33.614]         else {
[13:21:33.614]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:33.614]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:33.614]         }
[13:21:33.614]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:33.614]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:33.614]             base::sink(type = "output", split = FALSE)
[13:21:33.614]             base::close(...future.stdout)
[13:21:33.614]         }, add = TRUE)
[13:21:33.614]     }
[13:21:33.614]     ...future.frame <- base::sys.nframe()
[13:21:33.614]     ...future.conditions <- base::list()
[13:21:33.614]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:33.614]     if (FALSE) {
[13:21:33.614]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:33.614]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:33.614]     }
[13:21:33.614]     ...future.result <- base::tryCatch({
[13:21:33.614]         base::withCallingHandlers({
[13:21:33.614]             ...future.value <- base::withVisible(base::local({
[13:21:33.614]                 withCallingHandlers({
[13:21:33.614]                   {
[13:21:33.614]                     do.call(function(...) {
[13:21:33.614]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.614]                       if (!identical(...future.globals.maxSize.org, 
[13:21:33.614]                         ...future.globals.maxSize)) {
[13:21:33.614]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.614]                         on.exit(options(oopts), add = TRUE)
[13:21:33.614]                       }
[13:21:33.614]                       {
[13:21:33.614]                         lapply(seq_along(...future.elements_ii), 
[13:21:33.614]                           FUN = function(jj) {
[13:21:33.614]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.614]                             ...future.FUN(...future.X_jj, ...)
[13:21:33.614]                           })
[13:21:33.614]                       }
[13:21:33.614]                     }, args = future.call.arguments)
[13:21:33.614]                   }
[13:21:33.614]                 }, immediateCondition = function(cond) {
[13:21:33.614]                   save_rds <- function (object, pathname, ...) 
[13:21:33.614]                   {
[13:21:33.614]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:33.614]                     if (file_test("-f", pathname_tmp)) {
[13:21:33.614]                       fi_tmp <- file.info(pathname_tmp)
[13:21:33.614]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:33.614]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:33.614]                         fi_tmp[["mtime"]])
[13:21:33.614]                     }
[13:21:33.614]                     tryCatch({
[13:21:33.614]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:33.614]                     }, error = function(ex) {
[13:21:33.614]                       msg <- conditionMessage(ex)
[13:21:33.614]                       fi_tmp <- file.info(pathname_tmp)
[13:21:33.614]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:33.614]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:33.614]                         fi_tmp[["mtime"]], msg)
[13:21:33.614]                       ex$message <- msg
[13:21:33.614]                       stop(ex)
[13:21:33.614]                     })
[13:21:33.614]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:33.614]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:33.614]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:33.614]                       fi_tmp <- file.info(pathname_tmp)
[13:21:33.614]                       fi <- file.info(pathname)
[13:21:33.614]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:33.614]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:33.614]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:33.614]                         fi[["size"]], fi[["mtime"]])
[13:21:33.614]                       stop(msg)
[13:21:33.614]                     }
[13:21:33.614]                     invisible(pathname)
[13:21:33.614]                   }
[13:21:33.614]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:33.614]                     rootPath = tempdir()) 
[13:21:33.614]                   {
[13:21:33.614]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:33.614]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:33.614]                       tmpdir = path, fileext = ".rds")
[13:21:33.614]                     save_rds(obj, file)
[13:21:33.614]                   }
[13:21:33.614]                   saveImmediateCondition(cond, path = "/tmp/RtmpbpFWGO/.future/immediateConditions")
[13:21:33.614]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.614]                   {
[13:21:33.614]                     inherits <- base::inherits
[13:21:33.614]                     invokeRestart <- base::invokeRestart
[13:21:33.614]                     is.null <- base::is.null
[13:21:33.614]                     muffled <- FALSE
[13:21:33.614]                     if (inherits(cond, "message")) {
[13:21:33.614]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:33.614]                       if (muffled) 
[13:21:33.614]                         invokeRestart("muffleMessage")
[13:21:33.614]                     }
[13:21:33.614]                     else if (inherits(cond, "warning")) {
[13:21:33.614]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:33.614]                       if (muffled) 
[13:21:33.614]                         invokeRestart("muffleWarning")
[13:21:33.614]                     }
[13:21:33.614]                     else if (inherits(cond, "condition")) {
[13:21:33.614]                       if (!is.null(pattern)) {
[13:21:33.614]                         computeRestarts <- base::computeRestarts
[13:21:33.614]                         grepl <- base::grepl
[13:21:33.614]                         restarts <- computeRestarts(cond)
[13:21:33.614]                         for (restart in restarts) {
[13:21:33.614]                           name <- restart$name
[13:21:33.614]                           if (is.null(name)) 
[13:21:33.614]                             next
[13:21:33.614]                           if (!grepl(pattern, name)) 
[13:21:33.614]                             next
[13:21:33.614]                           invokeRestart(restart)
[13:21:33.614]                           muffled <- TRUE
[13:21:33.614]                           break
[13:21:33.614]                         }
[13:21:33.614]                       }
[13:21:33.614]                     }
[13:21:33.614]                     invisible(muffled)
[13:21:33.614]                   }
[13:21:33.614]                   muffleCondition(cond)
[13:21:33.614]                 })
[13:21:33.614]             }))
[13:21:33.614]             future::FutureResult(value = ...future.value$value, 
[13:21:33.614]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:33.614]                   ...future.rng), globalenv = if (FALSE) 
[13:21:33.614]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:33.614]                     ...future.globalenv.names))
[13:21:33.614]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:33.614]         }, condition = base::local({
[13:21:33.614]             c <- base::c
[13:21:33.614]             inherits <- base::inherits
[13:21:33.614]             invokeRestart <- base::invokeRestart
[13:21:33.614]             length <- base::length
[13:21:33.614]             list <- base::list
[13:21:33.614]             seq.int <- base::seq.int
[13:21:33.614]             signalCondition <- base::signalCondition
[13:21:33.614]             sys.calls <- base::sys.calls
[13:21:33.614]             `[[` <- base::`[[`
[13:21:33.614]             `+` <- base::`+`
[13:21:33.614]             `<<-` <- base::`<<-`
[13:21:33.614]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:33.614]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:33.614]                   3L)]
[13:21:33.614]             }
[13:21:33.614]             function(cond) {
[13:21:33.614]                 is_error <- inherits(cond, "error")
[13:21:33.614]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:33.614]                   NULL)
[13:21:33.614]                 if (is_error) {
[13:21:33.614]                   sessionInformation <- function() {
[13:21:33.614]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:33.614]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:33.614]                       search = base::search(), system = base::Sys.info())
[13:21:33.614]                   }
[13:21:33.614]                   ...future.conditions[[length(...future.conditions) + 
[13:21:33.614]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:33.614]                     cond$call), session = sessionInformation(), 
[13:21:33.614]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:33.614]                   signalCondition(cond)
[13:21:33.614]                 }
[13:21:33.614]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:33.614]                 "immediateCondition"))) {
[13:21:33.614]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:33.614]                   ...future.conditions[[length(...future.conditions) + 
[13:21:33.614]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:33.614]                   if (TRUE && !signal) {
[13:21:33.614]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.614]                     {
[13:21:33.614]                       inherits <- base::inherits
[13:21:33.614]                       invokeRestart <- base::invokeRestart
[13:21:33.614]                       is.null <- base::is.null
[13:21:33.614]                       muffled <- FALSE
[13:21:33.614]                       if (inherits(cond, "message")) {
[13:21:33.614]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:33.614]                         if (muffled) 
[13:21:33.614]                           invokeRestart("muffleMessage")
[13:21:33.614]                       }
[13:21:33.614]                       else if (inherits(cond, "warning")) {
[13:21:33.614]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:33.614]                         if (muffled) 
[13:21:33.614]                           invokeRestart("muffleWarning")
[13:21:33.614]                       }
[13:21:33.614]                       else if (inherits(cond, "condition")) {
[13:21:33.614]                         if (!is.null(pattern)) {
[13:21:33.614]                           computeRestarts <- base::computeRestarts
[13:21:33.614]                           grepl <- base::grepl
[13:21:33.614]                           restarts <- computeRestarts(cond)
[13:21:33.614]                           for (restart in restarts) {
[13:21:33.614]                             name <- restart$name
[13:21:33.614]                             if (is.null(name)) 
[13:21:33.614]                               next
[13:21:33.614]                             if (!grepl(pattern, name)) 
[13:21:33.614]                               next
[13:21:33.614]                             invokeRestart(restart)
[13:21:33.614]                             muffled <- TRUE
[13:21:33.614]                             break
[13:21:33.614]                           }
[13:21:33.614]                         }
[13:21:33.614]                       }
[13:21:33.614]                       invisible(muffled)
[13:21:33.614]                     }
[13:21:33.614]                     muffleCondition(cond, pattern = "^muffle")
[13:21:33.614]                   }
[13:21:33.614]                 }
[13:21:33.614]                 else {
[13:21:33.614]                   if (TRUE) {
[13:21:33.614]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.614]                     {
[13:21:33.614]                       inherits <- base::inherits
[13:21:33.614]                       invokeRestart <- base::invokeRestart
[13:21:33.614]                       is.null <- base::is.null
[13:21:33.614]                       muffled <- FALSE
[13:21:33.614]                       if (inherits(cond, "message")) {
[13:21:33.614]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:33.614]                         if (muffled) 
[13:21:33.614]                           invokeRestart("muffleMessage")
[13:21:33.614]                       }
[13:21:33.614]                       else if (inherits(cond, "warning")) {
[13:21:33.614]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:33.614]                         if (muffled) 
[13:21:33.614]                           invokeRestart("muffleWarning")
[13:21:33.614]                       }
[13:21:33.614]                       else if (inherits(cond, "condition")) {
[13:21:33.614]                         if (!is.null(pattern)) {
[13:21:33.614]                           computeRestarts <- base::computeRestarts
[13:21:33.614]                           grepl <- base::grepl
[13:21:33.614]                           restarts <- computeRestarts(cond)
[13:21:33.614]                           for (restart in restarts) {
[13:21:33.614]                             name <- restart$name
[13:21:33.614]                             if (is.null(name)) 
[13:21:33.614]                               next
[13:21:33.614]                             if (!grepl(pattern, name)) 
[13:21:33.614]                               next
[13:21:33.614]                             invokeRestart(restart)
[13:21:33.614]                             muffled <- TRUE
[13:21:33.614]                             break
[13:21:33.614]                           }
[13:21:33.614]                         }
[13:21:33.614]                       }
[13:21:33.614]                       invisible(muffled)
[13:21:33.614]                     }
[13:21:33.614]                     muffleCondition(cond, pattern = "^muffle")
[13:21:33.614]                   }
[13:21:33.614]                 }
[13:21:33.614]             }
[13:21:33.614]         }))
[13:21:33.614]     }, error = function(ex) {
[13:21:33.614]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:33.614]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:33.614]                 ...future.rng), started = ...future.startTime, 
[13:21:33.614]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:33.614]             version = "1.8"), class = "FutureResult")
[13:21:33.614]     }, finally = {
[13:21:33.614]         if (!identical(...future.workdir, getwd())) 
[13:21:33.614]             setwd(...future.workdir)
[13:21:33.614]         {
[13:21:33.614]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:33.614]                 ...future.oldOptions$nwarnings <- NULL
[13:21:33.614]             }
[13:21:33.614]             base::options(...future.oldOptions)
[13:21:33.614]             if (.Platform$OS.type == "windows") {
[13:21:33.614]                 old_names <- names(...future.oldEnvVars)
[13:21:33.614]                 envs <- base::Sys.getenv()
[13:21:33.614]                 names <- names(envs)
[13:21:33.614]                 common <- intersect(names, old_names)
[13:21:33.614]                 added <- setdiff(names, old_names)
[13:21:33.614]                 removed <- setdiff(old_names, names)
[13:21:33.614]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:33.614]                   envs[common]]
[13:21:33.614]                 NAMES <- toupper(changed)
[13:21:33.614]                 args <- list()
[13:21:33.614]                 for (kk in seq_along(NAMES)) {
[13:21:33.614]                   name <- changed[[kk]]
[13:21:33.614]                   NAME <- NAMES[[kk]]
[13:21:33.614]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.614]                     next
[13:21:33.614]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:33.614]                 }
[13:21:33.614]                 NAMES <- toupper(added)
[13:21:33.614]                 for (kk in seq_along(NAMES)) {
[13:21:33.614]                   name <- added[[kk]]
[13:21:33.614]                   NAME <- NAMES[[kk]]
[13:21:33.614]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.614]                     next
[13:21:33.614]                   args[[name]] <- ""
[13:21:33.614]                 }
[13:21:33.614]                 NAMES <- toupper(removed)
[13:21:33.614]                 for (kk in seq_along(NAMES)) {
[13:21:33.614]                   name <- removed[[kk]]
[13:21:33.614]                   NAME <- NAMES[[kk]]
[13:21:33.614]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.614]                     next
[13:21:33.614]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:33.614]                 }
[13:21:33.614]                 if (length(args) > 0) 
[13:21:33.614]                   base::do.call(base::Sys.setenv, args = args)
[13:21:33.614]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:33.614]             }
[13:21:33.614]             else {
[13:21:33.614]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:33.614]             }
[13:21:33.614]             {
[13:21:33.614]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:33.614]                   0L) {
[13:21:33.614]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:33.614]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:33.614]                   base::options(opts)
[13:21:33.614]                 }
[13:21:33.614]                 {
[13:21:33.614]                   {
[13:21:33.614]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:33.614]                     NULL
[13:21:33.614]                   }
[13:21:33.614]                   options(future.plan = NULL)
[13:21:33.614]                   if (is.na(NA_character_)) 
[13:21:33.614]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:33.614]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:33.614]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:33.614]                     envir = parent.frame()) 
[13:21:33.614]                   {
[13:21:33.614]                     default_workers <- missing(workers)
[13:21:33.614]                     if (is.function(workers)) 
[13:21:33.614]                       workers <- workers()
[13:21:33.614]                     workers <- structure(as.integer(workers), 
[13:21:33.614]                       class = class(workers))
[13:21:33.614]                     stop_if_not(is.finite(workers), workers >= 
[13:21:33.614]                       1L)
[13:21:33.614]                     if ((workers == 1L && !inherits(workers, 
[13:21:33.614]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:33.614]                       if (default_workers) 
[13:21:33.614]                         supportsMulticore(warn = TRUE)
[13:21:33.614]                       return(sequential(..., envir = envir))
[13:21:33.614]                     }
[13:21:33.614]                     oopts <- options(mc.cores = workers)
[13:21:33.614]                     on.exit(options(oopts))
[13:21:33.614]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:33.614]                       envir = envir)
[13:21:33.614]                     if (!future$lazy) 
[13:21:33.614]                       future <- run(future)
[13:21:33.614]                     invisible(future)
[13:21:33.614]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:33.614]                 }
[13:21:33.614]             }
[13:21:33.614]         }
[13:21:33.614]     })
[13:21:33.614]     if (TRUE) {
[13:21:33.614]         base::sink(type = "output", split = FALSE)
[13:21:33.614]         if (TRUE) {
[13:21:33.614]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:33.614]         }
[13:21:33.614]         else {
[13:21:33.614]             ...future.result["stdout"] <- base::list(NULL)
[13:21:33.614]         }
[13:21:33.614]         base::close(...future.stdout)
[13:21:33.614]         ...future.stdout <- NULL
[13:21:33.614]     }
[13:21:33.614]     ...future.result$conditions <- ...future.conditions
[13:21:33.614]     ...future.result$finished <- base::Sys.time()
[13:21:33.614]     ...future.result
[13:21:33.614] }
[13:21:33.617] assign_globals() ...
[13:21:33.617] List of 11
[13:21:33.617]  $ ...future.FUN            :function (x, ...)  
[13:21:33.617]  $ x_FUN                    :function (x)  
[13:21:33.617]  $ times                    : int 0
[13:21:33.617]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:33.617]  $ stop_if_not              :function (...)  
[13:21:33.617]  $ dim                      : NULL
[13:21:33.617]  $ valid_types              : chr [1:2] "logical" "integer"
[13:21:33.617]  $ future.call.arguments    : list()
[13:21:33.617]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:33.617]  $ ...future.elements_ii    :List of 5
[13:21:33.617]   ..$ : int 1
[13:21:33.617]   ..$ : int 2
[13:21:33.617]   ..$ : int 3
[13:21:33.617]   ..$ : int 4
[13:21:33.617]   ..$ : int 5
[13:21:33.617]  $ ...future.seeds_ii       : NULL
[13:21:33.617]  $ ...future.globals.maxSize: NULL
[13:21:33.617]  - attr(*, "where")=List of 11
[13:21:33.617]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:33.617]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:33.617]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:33.617]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:33.617]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:33.617]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:33.617]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:33.617]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:33.617]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:33.617]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:33.617]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:33.617]  - attr(*, "resolved")= logi FALSE
[13:21:33.617]  - attr(*, "total_size")= num 95400
[13:21:33.617]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:33.617]  - attr(*, "already-done")= logi TRUE
[13:21:33.626] - copied ‘...future.FUN’ to environment
[13:21:33.627] - reassign environment for ‘x_FUN’
[13:21:33.627] - copied ‘x_FUN’ to environment
[13:21:33.627] - copied ‘times’ to environment
[13:21:33.627] - copied ‘stopf’ to environment
[13:21:33.627] - copied ‘stop_if_not’ to environment
[13:21:33.627] - copied ‘dim’ to environment
[13:21:33.627] - copied ‘valid_types’ to environment
[13:21:33.627] - copied ‘future.call.arguments’ to environment
[13:21:33.627] - copied ‘...future.elements_ii’ to environment
[13:21:33.628] - copied ‘...future.seeds_ii’ to environment
[13:21:33.628] - copied ‘...future.globals.maxSize’ to environment
[13:21:33.628] assign_globals() ... done
[13:21:33.628] requestCore(): workers = 2
[13:21:33.630] MulticoreFuture started
[13:21:33.631] - Launch lazy future ... done
[13:21:33.631] run() for ‘MulticoreFuture’ ... done
[13:21:33.631] Created future:
[13:21:33.632] plan(): Setting new future strategy stack:
[13:21:33.632] List of future strategies:
[13:21:33.632] 1. sequential:
[13:21:33.632]    - args: function (..., envir = parent.frame())
[13:21:33.632]    - tweaked: FALSE
[13:21:33.632]    - call: NULL
[13:21:33.633] plan(): nbrOfWorkers() = 1
[13:21:33.635] plan(): Setting new future strategy stack:
[13:21:33.636] List of future strategies:
[13:21:33.636] 1. multicore:
[13:21:33.636]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:33.636]    - tweaked: FALSE
[13:21:33.636]    - call: plan(strategy)
[13:21:33.642] plan(): nbrOfWorkers() = 2
[13:21:33.632] MulticoreFuture:
[13:21:33.632] Label: ‘future_vapply-1’
[13:21:33.632] Expression:
[13:21:33.632] {
[13:21:33.632]     do.call(function(...) {
[13:21:33.632]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.632]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:33.632]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.632]             on.exit(options(oopts), add = TRUE)
[13:21:33.632]         }
[13:21:33.632]         {
[13:21:33.632]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:33.632]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.632]                 ...future.FUN(...future.X_jj, ...)
[13:21:33.632]             })
[13:21:33.632]         }
[13:21:33.632]     }, args = future.call.arguments)
[13:21:33.632] }
[13:21:33.632] Lazy evaluation: FALSE
[13:21:33.632] Asynchronous evaluation: TRUE
[13:21:33.632] Local evaluation: TRUE
[13:21:33.632] Environment: R_GlobalEnv
[13:21:33.632] Capture standard output: TRUE
[13:21:33.632] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:33.632] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:33.632] Packages: 1 packages (‘future.apply’)
[13:21:33.632] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:33.632] Resolved: TRUE
[13:21:33.632] Value: <not collected>
[13:21:33.632] Conditions captured: <none>
[13:21:33.632] Early signaling: FALSE
[13:21:33.632] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:33.632] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:33.643] Chunk #1 of 2 ... DONE
[13:21:33.643] Chunk #2 of 2 ...
[13:21:33.643]  - Finding globals in 'X' for chunk #2 ...
[13:21:33.644] getGlobalsAndPackages() ...
[13:21:33.644] Searching for globals...
[13:21:33.644] 
[13:21:33.644] Searching for globals ... DONE
[13:21:33.645] - globals: [0] <none>
[13:21:33.645] getGlobalsAndPackages() ... DONE
[13:21:33.645]    + additional globals found: [n=0] 
[13:21:33.645]    + additional namespaces needed: [n=0] 
[13:21:33.645]  - Finding globals in 'X' for chunk #2 ... DONE
[13:21:33.645]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:33.645]  - seeds: <none>
[13:21:33.645]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.646] getGlobalsAndPackages() ...
[13:21:33.646] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.646] Resolving globals: FALSE
[13:21:33.646] Tweak future expression to call with '...' arguments ...
[13:21:33.646] {
[13:21:33.646]     do.call(function(...) {
[13:21:33.646]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.646]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:33.646]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.646]             on.exit(options(oopts), add = TRUE)
[13:21:33.646]         }
[13:21:33.646]         {
[13:21:33.646]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:33.646]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.646]                 ...future.FUN(...future.X_jj, ...)
[13:21:33.646]             })
[13:21:33.646]         }
[13:21:33.646]     }, args = future.call.arguments)
[13:21:33.646] }
[13:21:33.647] Tweak future expression to call with '...' arguments ... DONE
[13:21:33.648] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.648] - packages: [1] ‘future.apply’
[13:21:33.652] getGlobalsAndPackages() ... DONE
[13:21:33.653] run() for ‘Future’ ...
[13:21:33.653] - state: ‘created’
[13:21:33.654] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:33.661] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:33.661] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:33.662]   - Field: ‘label’
[13:21:33.662]   - Field: ‘local’
[13:21:33.662]   - Field: ‘owner’
[13:21:33.663]   - Field: ‘envir’
[13:21:33.663]   - Field: ‘workers’
[13:21:33.663]   - Field: ‘packages’
[13:21:33.663]   - Field: ‘gc’
[13:21:33.664]   - Field: ‘job’
[13:21:33.664]   - Field: ‘conditions’
[13:21:33.664]   - Field: ‘expr’
[13:21:33.664]   - Field: ‘uuid’
[13:21:33.664]   - Field: ‘seed’
[13:21:33.665]   - Field: ‘version’
[13:21:33.665]   - Field: ‘result’
[13:21:33.665]   - Field: ‘asynchronous’
[13:21:33.665]   - Field: ‘calls’
[13:21:33.665]   - Field: ‘globals’
[13:21:33.666]   - Field: ‘stdout’
[13:21:33.666]   - Field: ‘earlySignal’
[13:21:33.666]   - Field: ‘lazy’
[13:21:33.666]   - Field: ‘state’
[13:21:33.666] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:33.666] - Launch lazy future ...
[13:21:33.667] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:33.667] Packages needed by future strategies (n = 0): <none>
[13:21:33.668] {
[13:21:33.668]     {
[13:21:33.668]         {
[13:21:33.668]             ...future.startTime <- base::Sys.time()
[13:21:33.668]             {
[13:21:33.668]                 {
[13:21:33.668]                   {
[13:21:33.668]                     {
[13:21:33.668]                       {
[13:21:33.668]                         base::local({
[13:21:33.668]                           has_future <- base::requireNamespace("future", 
[13:21:33.668]                             quietly = TRUE)
[13:21:33.668]                           if (has_future) {
[13:21:33.668]                             ns <- base::getNamespace("future")
[13:21:33.668]                             version <- ns[[".package"]][["version"]]
[13:21:33.668]                             if (is.null(version)) 
[13:21:33.668]                               version <- utils::packageVersion("future")
[13:21:33.668]                           }
[13:21:33.668]                           else {
[13:21:33.668]                             version <- NULL
[13:21:33.668]                           }
[13:21:33.668]                           if (!has_future || version < "1.8.0") {
[13:21:33.668]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:33.668]                               "", base::R.version$version.string), 
[13:21:33.668]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:33.668]                                 base::R.version$platform, 8 * 
[13:21:33.668]                                   base::.Machine$sizeof.pointer), 
[13:21:33.668]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:33.668]                                 "release", "version")], collapse = " "), 
[13:21:33.668]                               hostname = base::Sys.info()[["nodename"]])
[13:21:33.668]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:33.668]                               info)
[13:21:33.668]                             info <- base::paste(info, collapse = "; ")
[13:21:33.668]                             if (!has_future) {
[13:21:33.668]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:33.668]                                 info)
[13:21:33.668]                             }
[13:21:33.668]                             else {
[13:21:33.668]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:33.668]                                 info, version)
[13:21:33.668]                             }
[13:21:33.668]                             base::stop(msg)
[13:21:33.668]                           }
[13:21:33.668]                         })
[13:21:33.668]                       }
[13:21:33.668]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:33.668]                       base::options(mc.cores = 1L)
[13:21:33.668]                     }
[13:21:33.668]                     base::local({
[13:21:33.668]                       for (pkg in "future.apply") {
[13:21:33.668]                         base::loadNamespace(pkg)
[13:21:33.668]                         base::library(pkg, character.only = TRUE)
[13:21:33.668]                       }
[13:21:33.668]                     })
[13:21:33.668]                   }
[13:21:33.668]                   options(future.plan = NULL)
[13:21:33.668]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:33.668]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:33.668]                 }
[13:21:33.668]                 ...future.workdir <- getwd()
[13:21:33.668]             }
[13:21:33.668]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:33.668]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:33.668]         }
[13:21:33.668]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:33.668]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:33.668]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:33.668]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:33.668]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:33.668]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:33.668]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:33.668]             base::names(...future.oldOptions))
[13:21:33.668]     }
[13:21:33.668]     if (FALSE) {
[13:21:33.668]     }
[13:21:33.668]     else {
[13:21:33.668]         if (TRUE) {
[13:21:33.668]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:33.668]                 open = "w")
[13:21:33.668]         }
[13:21:33.668]         else {
[13:21:33.668]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:33.668]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:33.668]         }
[13:21:33.668]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:33.668]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:33.668]             base::sink(type = "output", split = FALSE)
[13:21:33.668]             base::close(...future.stdout)
[13:21:33.668]         }, add = TRUE)
[13:21:33.668]     }
[13:21:33.668]     ...future.frame <- base::sys.nframe()
[13:21:33.668]     ...future.conditions <- base::list()
[13:21:33.668]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:33.668]     if (FALSE) {
[13:21:33.668]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:33.668]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:33.668]     }
[13:21:33.668]     ...future.result <- base::tryCatch({
[13:21:33.668]         base::withCallingHandlers({
[13:21:33.668]             ...future.value <- base::withVisible(base::local({
[13:21:33.668]                 withCallingHandlers({
[13:21:33.668]                   {
[13:21:33.668]                     do.call(function(...) {
[13:21:33.668]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.668]                       if (!identical(...future.globals.maxSize.org, 
[13:21:33.668]                         ...future.globals.maxSize)) {
[13:21:33.668]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.668]                         on.exit(options(oopts), add = TRUE)
[13:21:33.668]                       }
[13:21:33.668]                       {
[13:21:33.668]                         lapply(seq_along(...future.elements_ii), 
[13:21:33.668]                           FUN = function(jj) {
[13:21:33.668]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.668]                             ...future.FUN(...future.X_jj, ...)
[13:21:33.668]                           })
[13:21:33.668]                       }
[13:21:33.668]                     }, args = future.call.arguments)
[13:21:33.668]                   }
[13:21:33.668]                 }, immediateCondition = function(cond) {
[13:21:33.668]                   save_rds <- function (object, pathname, ...) 
[13:21:33.668]                   {
[13:21:33.668]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:33.668]                     if (file_test("-f", pathname_tmp)) {
[13:21:33.668]                       fi_tmp <- file.info(pathname_tmp)
[13:21:33.668]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:33.668]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:33.668]                         fi_tmp[["mtime"]])
[13:21:33.668]                     }
[13:21:33.668]                     tryCatch({
[13:21:33.668]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:33.668]                     }, error = function(ex) {
[13:21:33.668]                       msg <- conditionMessage(ex)
[13:21:33.668]                       fi_tmp <- file.info(pathname_tmp)
[13:21:33.668]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:33.668]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:33.668]                         fi_tmp[["mtime"]], msg)
[13:21:33.668]                       ex$message <- msg
[13:21:33.668]                       stop(ex)
[13:21:33.668]                     })
[13:21:33.668]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:33.668]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:33.668]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:33.668]                       fi_tmp <- file.info(pathname_tmp)
[13:21:33.668]                       fi <- file.info(pathname)
[13:21:33.668]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:33.668]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:33.668]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:33.668]                         fi[["size"]], fi[["mtime"]])
[13:21:33.668]                       stop(msg)
[13:21:33.668]                     }
[13:21:33.668]                     invisible(pathname)
[13:21:33.668]                   }
[13:21:33.668]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:33.668]                     rootPath = tempdir()) 
[13:21:33.668]                   {
[13:21:33.668]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:33.668]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:33.668]                       tmpdir = path, fileext = ".rds")
[13:21:33.668]                     save_rds(obj, file)
[13:21:33.668]                   }
[13:21:33.668]                   saveImmediateCondition(cond, path = "/tmp/RtmpbpFWGO/.future/immediateConditions")
[13:21:33.668]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.668]                   {
[13:21:33.668]                     inherits <- base::inherits
[13:21:33.668]                     invokeRestart <- base::invokeRestart
[13:21:33.668]                     is.null <- base::is.null
[13:21:33.668]                     muffled <- FALSE
[13:21:33.668]                     if (inherits(cond, "message")) {
[13:21:33.668]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:33.668]                       if (muffled) 
[13:21:33.668]                         invokeRestart("muffleMessage")
[13:21:33.668]                     }
[13:21:33.668]                     else if (inherits(cond, "warning")) {
[13:21:33.668]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:33.668]                       if (muffled) 
[13:21:33.668]                         invokeRestart("muffleWarning")
[13:21:33.668]                     }
[13:21:33.668]                     else if (inherits(cond, "condition")) {
[13:21:33.668]                       if (!is.null(pattern)) {
[13:21:33.668]                         computeRestarts <- base::computeRestarts
[13:21:33.668]                         grepl <- base::grepl
[13:21:33.668]                         restarts <- computeRestarts(cond)
[13:21:33.668]                         for (restart in restarts) {
[13:21:33.668]                           name <- restart$name
[13:21:33.668]                           if (is.null(name)) 
[13:21:33.668]                             next
[13:21:33.668]                           if (!grepl(pattern, name)) 
[13:21:33.668]                             next
[13:21:33.668]                           invokeRestart(restart)
[13:21:33.668]                           muffled <- TRUE
[13:21:33.668]                           break
[13:21:33.668]                         }
[13:21:33.668]                       }
[13:21:33.668]                     }
[13:21:33.668]                     invisible(muffled)
[13:21:33.668]                   }
[13:21:33.668]                   muffleCondition(cond)
[13:21:33.668]                 })
[13:21:33.668]             }))
[13:21:33.668]             future::FutureResult(value = ...future.value$value, 
[13:21:33.668]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:33.668]                   ...future.rng), globalenv = if (FALSE) 
[13:21:33.668]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:33.668]                     ...future.globalenv.names))
[13:21:33.668]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:33.668]         }, condition = base::local({
[13:21:33.668]             c <- base::c
[13:21:33.668]             inherits <- base::inherits
[13:21:33.668]             invokeRestart <- base::invokeRestart
[13:21:33.668]             length <- base::length
[13:21:33.668]             list <- base::list
[13:21:33.668]             seq.int <- base::seq.int
[13:21:33.668]             signalCondition <- base::signalCondition
[13:21:33.668]             sys.calls <- base::sys.calls
[13:21:33.668]             `[[` <- base::`[[`
[13:21:33.668]             `+` <- base::`+`
[13:21:33.668]             `<<-` <- base::`<<-`
[13:21:33.668]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:33.668]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:33.668]                   3L)]
[13:21:33.668]             }
[13:21:33.668]             function(cond) {
[13:21:33.668]                 is_error <- inherits(cond, "error")
[13:21:33.668]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:33.668]                   NULL)
[13:21:33.668]                 if (is_error) {
[13:21:33.668]                   sessionInformation <- function() {
[13:21:33.668]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:33.668]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:33.668]                       search = base::search(), system = base::Sys.info())
[13:21:33.668]                   }
[13:21:33.668]                   ...future.conditions[[length(...future.conditions) + 
[13:21:33.668]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:33.668]                     cond$call), session = sessionInformation(), 
[13:21:33.668]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:33.668]                   signalCondition(cond)
[13:21:33.668]                 }
[13:21:33.668]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:33.668]                 "immediateCondition"))) {
[13:21:33.668]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:33.668]                   ...future.conditions[[length(...future.conditions) + 
[13:21:33.668]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:33.668]                   if (TRUE && !signal) {
[13:21:33.668]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.668]                     {
[13:21:33.668]                       inherits <- base::inherits
[13:21:33.668]                       invokeRestart <- base::invokeRestart
[13:21:33.668]                       is.null <- base::is.null
[13:21:33.668]                       muffled <- FALSE
[13:21:33.668]                       if (inherits(cond, "message")) {
[13:21:33.668]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:33.668]                         if (muffled) 
[13:21:33.668]                           invokeRestart("muffleMessage")
[13:21:33.668]                       }
[13:21:33.668]                       else if (inherits(cond, "warning")) {
[13:21:33.668]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:33.668]                         if (muffled) 
[13:21:33.668]                           invokeRestart("muffleWarning")
[13:21:33.668]                       }
[13:21:33.668]                       else if (inherits(cond, "condition")) {
[13:21:33.668]                         if (!is.null(pattern)) {
[13:21:33.668]                           computeRestarts <- base::computeRestarts
[13:21:33.668]                           grepl <- base::grepl
[13:21:33.668]                           restarts <- computeRestarts(cond)
[13:21:33.668]                           for (restart in restarts) {
[13:21:33.668]                             name <- restart$name
[13:21:33.668]                             if (is.null(name)) 
[13:21:33.668]                               next
[13:21:33.668]                             if (!grepl(pattern, name)) 
[13:21:33.668]                               next
[13:21:33.668]                             invokeRestart(restart)
[13:21:33.668]                             muffled <- TRUE
[13:21:33.668]                             break
[13:21:33.668]                           }
[13:21:33.668]                         }
[13:21:33.668]                       }
[13:21:33.668]                       invisible(muffled)
[13:21:33.668]                     }
[13:21:33.668]                     muffleCondition(cond, pattern = "^muffle")
[13:21:33.668]                   }
[13:21:33.668]                 }
[13:21:33.668]                 else {
[13:21:33.668]                   if (TRUE) {
[13:21:33.668]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.668]                     {
[13:21:33.668]                       inherits <- base::inherits
[13:21:33.668]                       invokeRestart <- base::invokeRestart
[13:21:33.668]                       is.null <- base::is.null
[13:21:33.668]                       muffled <- FALSE
[13:21:33.668]                       if (inherits(cond, "message")) {
[13:21:33.668]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:33.668]                         if (muffled) 
[13:21:33.668]                           invokeRestart("muffleMessage")
[13:21:33.668]                       }
[13:21:33.668]                       else if (inherits(cond, "warning")) {
[13:21:33.668]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:33.668]                         if (muffled) 
[13:21:33.668]                           invokeRestart("muffleWarning")
[13:21:33.668]                       }
[13:21:33.668]                       else if (inherits(cond, "condition")) {
[13:21:33.668]                         if (!is.null(pattern)) {
[13:21:33.668]                           computeRestarts <- base::computeRestarts
[13:21:33.668]                           grepl <- base::grepl
[13:21:33.668]                           restarts <- computeRestarts(cond)
[13:21:33.668]                           for (restart in restarts) {
[13:21:33.668]                             name <- restart$name
[13:21:33.668]                             if (is.null(name)) 
[13:21:33.668]                               next
[13:21:33.668]                             if (!grepl(pattern, name)) 
[13:21:33.668]                               next
[13:21:33.668]                             invokeRestart(restart)
[13:21:33.668]                             muffled <- TRUE
[13:21:33.668]                             break
[13:21:33.668]                           }
[13:21:33.668]                         }
[13:21:33.668]                       }
[13:21:33.668]                       invisible(muffled)
[13:21:33.668]                     }
[13:21:33.668]                     muffleCondition(cond, pattern = "^muffle")
[13:21:33.668]                   }
[13:21:33.668]                 }
[13:21:33.668]             }
[13:21:33.668]         }))
[13:21:33.668]     }, error = function(ex) {
[13:21:33.668]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:33.668]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:33.668]                 ...future.rng), started = ...future.startTime, 
[13:21:33.668]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:33.668]             version = "1.8"), class = "FutureResult")
[13:21:33.668]     }, finally = {
[13:21:33.668]         if (!identical(...future.workdir, getwd())) 
[13:21:33.668]             setwd(...future.workdir)
[13:21:33.668]         {
[13:21:33.668]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:33.668]                 ...future.oldOptions$nwarnings <- NULL
[13:21:33.668]             }
[13:21:33.668]             base::options(...future.oldOptions)
[13:21:33.668]             if (.Platform$OS.type == "windows") {
[13:21:33.668]                 old_names <- names(...future.oldEnvVars)
[13:21:33.668]                 envs <- base::Sys.getenv()
[13:21:33.668]                 names <- names(envs)
[13:21:33.668]                 common <- intersect(names, old_names)
[13:21:33.668]                 added <- setdiff(names, old_names)
[13:21:33.668]                 removed <- setdiff(old_names, names)
[13:21:33.668]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:33.668]                   envs[common]]
[13:21:33.668]                 NAMES <- toupper(changed)
[13:21:33.668]                 args <- list()
[13:21:33.668]                 for (kk in seq_along(NAMES)) {
[13:21:33.668]                   name <- changed[[kk]]
[13:21:33.668]                   NAME <- NAMES[[kk]]
[13:21:33.668]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.668]                     next
[13:21:33.668]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:33.668]                 }
[13:21:33.668]                 NAMES <- toupper(added)
[13:21:33.668]                 for (kk in seq_along(NAMES)) {
[13:21:33.668]                   name <- added[[kk]]
[13:21:33.668]                   NAME <- NAMES[[kk]]
[13:21:33.668]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.668]                     next
[13:21:33.668]                   args[[name]] <- ""
[13:21:33.668]                 }
[13:21:33.668]                 NAMES <- toupper(removed)
[13:21:33.668]                 for (kk in seq_along(NAMES)) {
[13:21:33.668]                   name <- removed[[kk]]
[13:21:33.668]                   NAME <- NAMES[[kk]]
[13:21:33.668]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.668]                     next
[13:21:33.668]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:33.668]                 }
[13:21:33.668]                 if (length(args) > 0) 
[13:21:33.668]                   base::do.call(base::Sys.setenv, args = args)
[13:21:33.668]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:33.668]             }
[13:21:33.668]             else {
[13:21:33.668]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:33.668]             }
[13:21:33.668]             {
[13:21:33.668]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:33.668]                   0L) {
[13:21:33.668]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:33.668]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:33.668]                   base::options(opts)
[13:21:33.668]                 }
[13:21:33.668]                 {
[13:21:33.668]                   {
[13:21:33.668]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:33.668]                     NULL
[13:21:33.668]                   }
[13:21:33.668]                   options(future.plan = NULL)
[13:21:33.668]                   if (is.na(NA_character_)) 
[13:21:33.668]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:33.668]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:33.668]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:33.668]                     envir = parent.frame()) 
[13:21:33.668]                   {
[13:21:33.668]                     default_workers <- missing(workers)
[13:21:33.668]                     if (is.function(workers)) 
[13:21:33.668]                       workers <- workers()
[13:21:33.668]                     workers <- structure(as.integer(workers), 
[13:21:33.668]                       class = class(workers))
[13:21:33.668]                     stop_if_not(is.finite(workers), workers >= 
[13:21:33.668]                       1L)
[13:21:33.668]                     if ((workers == 1L && !inherits(workers, 
[13:21:33.668]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:33.668]                       if (default_workers) 
[13:21:33.668]                         supportsMulticore(warn = TRUE)
[13:21:33.668]                       return(sequential(..., envir = envir))
[13:21:33.668]                     }
[13:21:33.668]                     oopts <- options(mc.cores = workers)
[13:21:33.668]                     on.exit(options(oopts))
[13:21:33.668]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:33.668]                       envir = envir)
[13:21:33.668]                     if (!future$lazy) 
[13:21:33.668]                       future <- run(future)
[13:21:33.668]                     invisible(future)
[13:21:33.668]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:33.668]                 }
[13:21:33.668]             }
[13:21:33.668]         }
[13:21:33.668]     })
[13:21:33.668]     if (TRUE) {
[13:21:33.668]         base::sink(type = "output", split = FALSE)
[13:21:33.668]         if (TRUE) {
[13:21:33.668]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:33.668]         }
[13:21:33.668]         else {
[13:21:33.668]             ...future.result["stdout"] <- base::list(NULL)
[13:21:33.668]         }
[13:21:33.668]         base::close(...future.stdout)
[13:21:33.668]         ...future.stdout <- NULL
[13:21:33.668]     }
[13:21:33.668]     ...future.result$conditions <- ...future.conditions
[13:21:33.668]     ...future.result$finished <- base::Sys.time()
[13:21:33.668]     ...future.result
[13:21:33.668] }
[13:21:33.671] assign_globals() ...
[13:21:33.671] List of 11
[13:21:33.671]  $ ...future.FUN            :function (x, ...)  
[13:21:33.671]  $ x_FUN                    :function (x)  
[13:21:33.671]  $ times                    : int 0
[13:21:33.671]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:33.671]  $ stop_if_not              :function (...)  
[13:21:33.671]  $ dim                      : NULL
[13:21:33.671]  $ valid_types              : chr [1:2] "logical" "integer"
[13:21:33.671]  $ future.call.arguments    : list()
[13:21:33.671]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:33.671]  $ ...future.elements_ii    :List of 5
[13:21:33.671]   ..$ : int 6
[13:21:33.671]   ..$ : int 7
[13:21:33.671]   ..$ : int 8
[13:21:33.671]   ..$ : int 9
[13:21:33.671]   ..$ : int 10
[13:21:33.671]  $ ...future.seeds_ii       : NULL
[13:21:33.671]  $ ...future.globals.maxSize: NULL
[13:21:33.671]  - attr(*, "where")=List of 11
[13:21:33.671]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:33.671]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:33.671]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:33.671]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:33.671]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:33.671]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:33.671]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:33.671]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:33.671]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:33.671]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:33.671]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:33.671]  - attr(*, "resolved")= logi FALSE
[13:21:33.671]  - attr(*, "total_size")= num 95400
[13:21:33.671]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:33.671]  - attr(*, "already-done")= logi TRUE
[13:21:33.683] - copied ‘...future.FUN’ to environment
[13:21:33.683] - reassign environment for ‘x_FUN’
[13:21:33.683] - copied ‘x_FUN’ to environment
[13:21:33.683] - copied ‘times’ to environment
[13:21:33.683] - copied ‘stopf’ to environment
[13:21:33.683] - copied ‘stop_if_not’ to environment
[13:21:33.683] - copied ‘dim’ to environment
[13:21:33.683] - copied ‘valid_types’ to environment
[13:21:33.684] - copied ‘future.call.arguments’ to environment
[13:21:33.684] - copied ‘...future.elements_ii’ to environment
[13:21:33.684] - copied ‘...future.seeds_ii’ to environment
[13:21:33.684] - copied ‘...future.globals.maxSize’ to environment
[13:21:33.684] assign_globals() ... done
[13:21:33.684] requestCore(): workers = 2
[13:21:33.687] MulticoreFuture started
[13:21:33.687] - Launch lazy future ... done
[13:21:33.687] run() for ‘MulticoreFuture’ ... done
[13:21:33.687] Created future:
[13:21:33.688] plan(): Setting new future strategy stack:
[13:21:33.688] List of future strategies:
[13:21:33.688] 1. sequential:
[13:21:33.688]    - args: function (..., envir = parent.frame())
[13:21:33.688]    - tweaked: FALSE
[13:21:33.688]    - call: NULL
[13:21:33.689] plan(): nbrOfWorkers() = 1
[13:21:33.691] plan(): Setting new future strategy stack:
[13:21:33.691] List of future strategies:
[13:21:33.691] 1. multicore:
[13:21:33.691]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:33.691]    - tweaked: FALSE
[13:21:33.691]    - call: plan(strategy)
[13:21:33.688] MulticoreFuture:
[13:21:33.688] Label: ‘future_vapply-2’
[13:21:33.688] Expression:
[13:21:33.688] {
[13:21:33.688]     do.call(function(...) {
[13:21:33.688]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.688]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:33.688]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.688]             on.exit(options(oopts), add = TRUE)
[13:21:33.688]         }
[13:21:33.688]         {
[13:21:33.688]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:33.688]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.688]                 ...future.FUN(...future.X_jj, ...)
[13:21:33.688]             })
[13:21:33.688]         }
[13:21:33.688]     }, args = future.call.arguments)
[13:21:33.688] }
[13:21:33.688] Lazy evaluation: FALSE
[13:21:33.688] Asynchronous evaluation: TRUE
[13:21:33.688] Local evaluation: TRUE
[13:21:33.688] Environment: R_GlobalEnv
[13:21:33.688] Capture standard output: TRUE
[13:21:33.688] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:33.688] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:33.688] Packages: 1 packages (‘future.apply’)
[13:21:33.688] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:33.688] Resolved: FALSE
[13:21:33.688] Value: <not collected>
[13:21:33.688] Conditions captured: <none>
[13:21:33.688] Early signaling: FALSE
[13:21:33.688] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:33.688] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:33.701] Chunk #2 of 2 ... DONE
[13:21:33.701] Launching 2 futures (chunks) ... DONE
[13:21:33.701] Resolving 2 futures (chunks) ...
[13:21:33.701] resolve() on list ...
[13:21:33.701]  recursive: 0
[13:21:33.702]  length: 2
[13:21:33.701] plan(): nbrOfWorkers() = 2
[13:21:33.702] 
[13:21:33.702] Future #1
[13:21:33.702] result() for MulticoreFuture ...
[13:21:33.706] result() for MulticoreFuture ...
[13:21:33.706] result() for MulticoreFuture ... done
[13:21:33.706] result() for MulticoreFuture ... done
[13:21:33.707] result() for MulticoreFuture ...
[13:21:33.707] result() for MulticoreFuture ... done
[13:21:33.708] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:21:33.708] - nx: 2
[13:21:33.708] - relay: TRUE
[13:21:33.709] - stdout: TRUE
[13:21:33.709] - signal: TRUE
[13:21:33.709] - resignal: FALSE
[13:21:33.709] - force: TRUE
[13:21:33.710] - relayed: [n=2] FALSE, FALSE
[13:21:33.710] - queued futures: [n=2] FALSE, FALSE
[13:21:33.710]  - until=1
[13:21:33.710]  - relaying element #1
[13:21:33.711] result() for MulticoreFuture ...
[13:21:33.711] result() for MulticoreFuture ... done
[13:21:33.711] result() for MulticoreFuture ...
[13:21:33.711] result() for MulticoreFuture ... done
[13:21:33.712] result() for MulticoreFuture ...
[13:21:33.712] result() for MulticoreFuture ... done
[13:21:33.712] result() for MulticoreFuture ...
[13:21:33.712] result() for MulticoreFuture ... done
[13:21:33.713] - relayed: [n=2] TRUE, FALSE
[13:21:33.713] - queued futures: [n=2] TRUE, FALSE
[13:21:33.713] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:21:33.713]  length: 1 (resolved future 1)
[13:21:33.714] Future #2
[13:21:33.714] result() for MulticoreFuture ...
[13:21:33.715] result() for MulticoreFuture ...
[13:21:33.715] result() for MulticoreFuture ... done
[13:21:33.715] result() for MulticoreFuture ... done
[13:21:33.715] result() for MulticoreFuture ...
[13:21:33.715] result() for MulticoreFuture ... done
[13:21:33.716] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:21:33.716] - nx: 2
[13:21:33.716] - relay: TRUE
[13:21:33.716] - stdout: TRUE
[13:21:33.716] - signal: TRUE
[13:21:33.716] - resignal: FALSE
[13:21:33.716] - force: TRUE
[13:21:33.717] - relayed: [n=2] TRUE, FALSE
[13:21:33.717] - queued futures: [n=2] TRUE, FALSE
[13:21:33.717]  - until=2
[13:21:33.717]  - relaying element #2
[13:21:33.717] result() for MulticoreFuture ...
[13:21:33.717] result() for MulticoreFuture ... done
[13:21:33.717] result() for MulticoreFuture ...
[13:21:33.717] result() for MulticoreFuture ... done
[13:21:33.718] result() for MulticoreFuture ...
[13:21:33.718] result() for MulticoreFuture ... done
[13:21:33.718] result() for MulticoreFuture ...
[13:21:33.718] result() for MulticoreFuture ... done
[13:21:33.718] - relayed: [n=2] TRUE, TRUE
[13:21:33.718] - queued futures: [n=2] TRUE, TRUE
[13:21:33.718] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:21:33.718]  length: 0 (resolved future 2)
[13:21:33.719] Relaying remaining futures
[13:21:33.719] signalConditionsASAP(NULL, pos=0) ...
[13:21:33.719] - nx: 2
[13:21:33.719] - relay: TRUE
[13:21:33.719] - stdout: TRUE
[13:21:33.719] - signal: TRUE
[13:21:33.719] - resignal: FALSE
[13:21:33.719] - force: TRUE
[13:21:33.719] - relayed: [n=2] TRUE, TRUE
[13:21:33.719] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:21:33.720] - relayed: [n=2] TRUE, TRUE
[13:21:33.720] - queued futures: [n=2] TRUE, TRUE
[13:21:33.720] signalConditionsASAP(NULL, pos=0) ... done
[13:21:33.720] resolve() on list ... DONE
[13:21:33.720] result() for MulticoreFuture ...
[13:21:33.720] result() for MulticoreFuture ... done
[13:21:33.720] result() for MulticoreFuture ...
[13:21:33.720] result() for MulticoreFuture ... done
[13:21:33.721] result() for MulticoreFuture ...
[13:21:33.721] result() for MulticoreFuture ... done
[13:21:33.721] result() for MulticoreFuture ...
[13:21:33.721] result() for MulticoreFuture ... done
[13:21:33.721]  - Number of value chunks collected: 2
[13:21:33.721] Resolving 2 futures (chunks) ... DONE
[13:21:33.721] Reducing values from 2 chunks ...
[13:21:33.721]  - Number of values collected after concatenation: 10
[13:21:33.721]  - Number of values expected: 10
[13:21:33.722] Reducing values from 2 chunks ... DONE
[13:21:33.722] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[13:21:33.723] future_lapply() ...
[13:21:33.729] Number of chunks: 2
[13:21:33.729] getGlobalsAndPackagesXApply() ...
[13:21:33.729]  - future.globals: TRUE
[13:21:33.729] getGlobalsAndPackages() ...
[13:21:33.730] Searching for globals...
[13:21:33.733] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:21:33.733] Searching for globals ... DONE
[13:21:33.733] Resolving globals: FALSE
[13:21:33.734] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[13:21:33.735] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:33.735] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:33.735] - packages: [1] ‘future.apply’
[13:21:33.735] getGlobalsAndPackages() ... DONE
[13:21:33.735]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:33.735]  - needed namespaces: [n=1] ‘future.apply’
[13:21:33.735] Finding globals ... DONE
[13:21:33.735]  - use_args: TRUE
[13:21:33.735]  - Getting '...' globals ...
[13:21:33.738] resolve() on list ...
[13:21:33.738]  recursive: 0
[13:21:33.738]  length: 1
[13:21:33.738]  elements: ‘...’
[13:21:33.738]  length: 0 (resolved future 1)
[13:21:33.738] resolve() on list ... DONE
[13:21:33.739]    - '...' content: [n=0] 
[13:21:33.739] List of 1
[13:21:33.739]  $ ...: list()
[13:21:33.739]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:33.739]  - attr(*, "where")=List of 1
[13:21:33.739]   ..$ ...:<environment: 0x563b6e6d3458> 
[13:21:33.739]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:33.739]  - attr(*, "resolved")= logi TRUE
[13:21:33.739]  - attr(*, "total_size")= num NA
[13:21:33.742]  - Getting '...' globals ... DONE
[13:21:33.742] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:33.742] List of 8
[13:21:33.742]  $ ...future.FUN:function (x, ...)  
[13:21:33.742]  $ x_FUN        :function (x)  
[13:21:33.742]  $ times        : int 1
[13:21:33.742]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:33.742]  $ stop_if_not  :function (...)  
[13:21:33.742]  $ dim          : NULL
[13:21:33.742]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:21:33.742]  $ ...          : list()
[13:21:33.742]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:33.742]  - attr(*, "where")=List of 8
[13:21:33.742]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:33.742]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:33.742]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:33.742]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:33.742]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:33.742]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:33.742]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:33.742]   ..$ ...          :<environment: 0x563b6e6d3458> 
[13:21:33.742]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:33.742]  - attr(*, "resolved")= logi FALSE
[13:21:33.742]  - attr(*, "total_size")= num 94336
[13:21:33.748] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:21:33.748] getGlobalsAndPackagesXApply() ... DONE
[13:21:33.748] Number of futures (= number of chunks): 2
[13:21:33.748] Launching 2 futures (chunks) ...
[13:21:33.748] Chunk #1 of 2 ...
[13:21:33.749]  - Finding globals in 'X' for chunk #1 ...
[13:21:33.749] getGlobalsAndPackages() ...
[13:21:33.749] Searching for globals...
[13:21:33.749] 
[13:21:33.749] Searching for globals ... DONE
[13:21:33.749] - globals: [0] <none>
[13:21:33.749] getGlobalsAndPackages() ... DONE
[13:21:33.749]    + additional globals found: [n=0] 
[13:21:33.749]    + additional namespaces needed: [n=0] 
[13:21:33.750]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:33.750]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:33.750]  - seeds: <none>
[13:21:33.750]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.750] getGlobalsAndPackages() ...
[13:21:33.750] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.750] Resolving globals: FALSE
[13:21:33.750] Tweak future expression to call with '...' arguments ...
[13:21:33.750] {
[13:21:33.750]     do.call(function(...) {
[13:21:33.750]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.750]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:33.750]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.750]             on.exit(options(oopts), add = TRUE)
[13:21:33.750]         }
[13:21:33.750]         {
[13:21:33.750]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:33.750]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.750]                 ...future.FUN(...future.X_jj, ...)
[13:21:33.750]             })
[13:21:33.750]         }
[13:21:33.750]     }, args = future.call.arguments)
[13:21:33.750] }
[13:21:33.751] Tweak future expression to call with '...' arguments ... DONE
[13:21:33.751] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.751] - packages: [1] ‘future.apply’
[13:21:33.752] getGlobalsAndPackages() ... DONE
[13:21:33.752] run() for ‘Future’ ...
[13:21:33.752] - state: ‘created’
[13:21:33.752] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:33.756] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:33.756] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:33.756]   - Field: ‘label’
[13:21:33.756]   - Field: ‘local’
[13:21:33.756]   - Field: ‘owner’
[13:21:33.757]   - Field: ‘envir’
[13:21:33.757]   - Field: ‘workers’
[13:21:33.757]   - Field: ‘packages’
[13:21:33.757]   - Field: ‘gc’
[13:21:33.757]   - Field: ‘job’
[13:21:33.757]   - Field: ‘conditions’
[13:21:33.757]   - Field: ‘expr’
[13:21:33.757]   - Field: ‘uuid’
[13:21:33.757]   - Field: ‘seed’
[13:21:33.757]   - Field: ‘version’
[13:21:33.757]   - Field: ‘result’
[13:21:33.758]   - Field: ‘asynchronous’
[13:21:33.758]   - Field: ‘calls’
[13:21:33.758]   - Field: ‘globals’
[13:21:33.758]   - Field: ‘stdout’
[13:21:33.758]   - Field: ‘earlySignal’
[13:21:33.758]   - Field: ‘lazy’
[13:21:33.758]   - Field: ‘state’
[13:21:33.758] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:33.758] - Launch lazy future ...
[13:21:33.759] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:33.759] Packages needed by future strategies (n = 0): <none>
[13:21:33.759] {
[13:21:33.759]     {
[13:21:33.759]         {
[13:21:33.759]             ...future.startTime <- base::Sys.time()
[13:21:33.759]             {
[13:21:33.759]                 {
[13:21:33.759]                   {
[13:21:33.759]                     {
[13:21:33.759]                       {
[13:21:33.759]                         base::local({
[13:21:33.759]                           has_future <- base::requireNamespace("future", 
[13:21:33.759]                             quietly = TRUE)
[13:21:33.759]                           if (has_future) {
[13:21:33.759]                             ns <- base::getNamespace("future")
[13:21:33.759]                             version <- ns[[".package"]][["version"]]
[13:21:33.759]                             if (is.null(version)) 
[13:21:33.759]                               version <- utils::packageVersion("future")
[13:21:33.759]                           }
[13:21:33.759]                           else {
[13:21:33.759]                             version <- NULL
[13:21:33.759]                           }
[13:21:33.759]                           if (!has_future || version < "1.8.0") {
[13:21:33.759]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:33.759]                               "", base::R.version$version.string), 
[13:21:33.759]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:33.759]                                 base::R.version$platform, 8 * 
[13:21:33.759]                                   base::.Machine$sizeof.pointer), 
[13:21:33.759]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:33.759]                                 "release", "version")], collapse = " "), 
[13:21:33.759]                               hostname = base::Sys.info()[["nodename"]])
[13:21:33.759]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:33.759]                               info)
[13:21:33.759]                             info <- base::paste(info, collapse = "; ")
[13:21:33.759]                             if (!has_future) {
[13:21:33.759]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:33.759]                                 info)
[13:21:33.759]                             }
[13:21:33.759]                             else {
[13:21:33.759]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:33.759]                                 info, version)
[13:21:33.759]                             }
[13:21:33.759]                             base::stop(msg)
[13:21:33.759]                           }
[13:21:33.759]                         })
[13:21:33.759]                       }
[13:21:33.759]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:33.759]                       base::options(mc.cores = 1L)
[13:21:33.759]                     }
[13:21:33.759]                     base::local({
[13:21:33.759]                       for (pkg in "future.apply") {
[13:21:33.759]                         base::loadNamespace(pkg)
[13:21:33.759]                         base::library(pkg, character.only = TRUE)
[13:21:33.759]                       }
[13:21:33.759]                     })
[13:21:33.759]                   }
[13:21:33.759]                   options(future.plan = NULL)
[13:21:33.759]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:33.759]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:33.759]                 }
[13:21:33.759]                 ...future.workdir <- getwd()
[13:21:33.759]             }
[13:21:33.759]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:33.759]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:33.759]         }
[13:21:33.759]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:33.759]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:33.759]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:33.759]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:33.759]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:33.759]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:33.759]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:33.759]             base::names(...future.oldOptions))
[13:21:33.759]     }
[13:21:33.759]     if (FALSE) {
[13:21:33.759]     }
[13:21:33.759]     else {
[13:21:33.759]         if (TRUE) {
[13:21:33.759]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:33.759]                 open = "w")
[13:21:33.759]         }
[13:21:33.759]         else {
[13:21:33.759]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:33.759]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:33.759]         }
[13:21:33.759]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:33.759]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:33.759]             base::sink(type = "output", split = FALSE)
[13:21:33.759]             base::close(...future.stdout)
[13:21:33.759]         }, add = TRUE)
[13:21:33.759]     }
[13:21:33.759]     ...future.frame <- base::sys.nframe()
[13:21:33.759]     ...future.conditions <- base::list()
[13:21:33.759]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:33.759]     if (FALSE) {
[13:21:33.759]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:33.759]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:33.759]     }
[13:21:33.759]     ...future.result <- base::tryCatch({
[13:21:33.759]         base::withCallingHandlers({
[13:21:33.759]             ...future.value <- base::withVisible(base::local({
[13:21:33.759]                 withCallingHandlers({
[13:21:33.759]                   {
[13:21:33.759]                     do.call(function(...) {
[13:21:33.759]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.759]                       if (!identical(...future.globals.maxSize.org, 
[13:21:33.759]                         ...future.globals.maxSize)) {
[13:21:33.759]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.759]                         on.exit(options(oopts), add = TRUE)
[13:21:33.759]                       }
[13:21:33.759]                       {
[13:21:33.759]                         lapply(seq_along(...future.elements_ii), 
[13:21:33.759]                           FUN = function(jj) {
[13:21:33.759]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.759]                             ...future.FUN(...future.X_jj, ...)
[13:21:33.759]                           })
[13:21:33.759]                       }
[13:21:33.759]                     }, args = future.call.arguments)
[13:21:33.759]                   }
[13:21:33.759]                 }, immediateCondition = function(cond) {
[13:21:33.759]                   save_rds <- function (object, pathname, ...) 
[13:21:33.759]                   {
[13:21:33.759]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:33.759]                     if (file_test("-f", pathname_tmp)) {
[13:21:33.759]                       fi_tmp <- file.info(pathname_tmp)
[13:21:33.759]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:33.759]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:33.759]                         fi_tmp[["mtime"]])
[13:21:33.759]                     }
[13:21:33.759]                     tryCatch({
[13:21:33.759]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:33.759]                     }, error = function(ex) {
[13:21:33.759]                       msg <- conditionMessage(ex)
[13:21:33.759]                       fi_tmp <- file.info(pathname_tmp)
[13:21:33.759]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:33.759]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:33.759]                         fi_tmp[["mtime"]], msg)
[13:21:33.759]                       ex$message <- msg
[13:21:33.759]                       stop(ex)
[13:21:33.759]                     })
[13:21:33.759]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:33.759]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:33.759]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:33.759]                       fi_tmp <- file.info(pathname_tmp)
[13:21:33.759]                       fi <- file.info(pathname)
[13:21:33.759]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:33.759]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:33.759]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:33.759]                         fi[["size"]], fi[["mtime"]])
[13:21:33.759]                       stop(msg)
[13:21:33.759]                     }
[13:21:33.759]                     invisible(pathname)
[13:21:33.759]                   }
[13:21:33.759]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:33.759]                     rootPath = tempdir()) 
[13:21:33.759]                   {
[13:21:33.759]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:33.759]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:33.759]                       tmpdir = path, fileext = ".rds")
[13:21:33.759]                     save_rds(obj, file)
[13:21:33.759]                   }
[13:21:33.759]                   saveImmediateCondition(cond, path = "/tmp/RtmpbpFWGO/.future/immediateConditions")
[13:21:33.759]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.759]                   {
[13:21:33.759]                     inherits <- base::inherits
[13:21:33.759]                     invokeRestart <- base::invokeRestart
[13:21:33.759]                     is.null <- base::is.null
[13:21:33.759]                     muffled <- FALSE
[13:21:33.759]                     if (inherits(cond, "message")) {
[13:21:33.759]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:33.759]                       if (muffled) 
[13:21:33.759]                         invokeRestart("muffleMessage")
[13:21:33.759]                     }
[13:21:33.759]                     else if (inherits(cond, "warning")) {
[13:21:33.759]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:33.759]                       if (muffled) 
[13:21:33.759]                         invokeRestart("muffleWarning")
[13:21:33.759]                     }
[13:21:33.759]                     else if (inherits(cond, "condition")) {
[13:21:33.759]                       if (!is.null(pattern)) {
[13:21:33.759]                         computeRestarts <- base::computeRestarts
[13:21:33.759]                         grepl <- base::grepl
[13:21:33.759]                         restarts <- computeRestarts(cond)
[13:21:33.759]                         for (restart in restarts) {
[13:21:33.759]                           name <- restart$name
[13:21:33.759]                           if (is.null(name)) 
[13:21:33.759]                             next
[13:21:33.759]                           if (!grepl(pattern, name)) 
[13:21:33.759]                             next
[13:21:33.759]                           invokeRestart(restart)
[13:21:33.759]                           muffled <- TRUE
[13:21:33.759]                           break
[13:21:33.759]                         }
[13:21:33.759]                       }
[13:21:33.759]                     }
[13:21:33.759]                     invisible(muffled)
[13:21:33.759]                   }
[13:21:33.759]                   muffleCondition(cond)
[13:21:33.759]                 })
[13:21:33.759]             }))
[13:21:33.759]             future::FutureResult(value = ...future.value$value, 
[13:21:33.759]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:33.759]                   ...future.rng), globalenv = if (FALSE) 
[13:21:33.759]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:33.759]                     ...future.globalenv.names))
[13:21:33.759]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:33.759]         }, condition = base::local({
[13:21:33.759]             c <- base::c
[13:21:33.759]             inherits <- base::inherits
[13:21:33.759]             invokeRestart <- base::invokeRestart
[13:21:33.759]             length <- base::length
[13:21:33.759]             list <- base::list
[13:21:33.759]             seq.int <- base::seq.int
[13:21:33.759]             signalCondition <- base::signalCondition
[13:21:33.759]             sys.calls <- base::sys.calls
[13:21:33.759]             `[[` <- base::`[[`
[13:21:33.759]             `+` <- base::`+`
[13:21:33.759]             `<<-` <- base::`<<-`
[13:21:33.759]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:33.759]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:33.759]                   3L)]
[13:21:33.759]             }
[13:21:33.759]             function(cond) {
[13:21:33.759]                 is_error <- inherits(cond, "error")
[13:21:33.759]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:33.759]                   NULL)
[13:21:33.759]                 if (is_error) {
[13:21:33.759]                   sessionInformation <- function() {
[13:21:33.759]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:33.759]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:33.759]                       search = base::search(), system = base::Sys.info())
[13:21:33.759]                   }
[13:21:33.759]                   ...future.conditions[[length(...future.conditions) + 
[13:21:33.759]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:33.759]                     cond$call), session = sessionInformation(), 
[13:21:33.759]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:33.759]                   signalCondition(cond)
[13:21:33.759]                 }
[13:21:33.759]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:33.759]                 "immediateCondition"))) {
[13:21:33.759]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:33.759]                   ...future.conditions[[length(...future.conditions) + 
[13:21:33.759]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:33.759]                   if (TRUE && !signal) {
[13:21:33.759]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.759]                     {
[13:21:33.759]                       inherits <- base::inherits
[13:21:33.759]                       invokeRestart <- base::invokeRestart
[13:21:33.759]                       is.null <- base::is.null
[13:21:33.759]                       muffled <- FALSE
[13:21:33.759]                       if (inherits(cond, "message")) {
[13:21:33.759]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:33.759]                         if (muffled) 
[13:21:33.759]                           invokeRestart("muffleMessage")
[13:21:33.759]                       }
[13:21:33.759]                       else if (inherits(cond, "warning")) {
[13:21:33.759]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:33.759]                         if (muffled) 
[13:21:33.759]                           invokeRestart("muffleWarning")
[13:21:33.759]                       }
[13:21:33.759]                       else if (inherits(cond, "condition")) {
[13:21:33.759]                         if (!is.null(pattern)) {
[13:21:33.759]                           computeRestarts <- base::computeRestarts
[13:21:33.759]                           grepl <- base::grepl
[13:21:33.759]                           restarts <- computeRestarts(cond)
[13:21:33.759]                           for (restart in restarts) {
[13:21:33.759]                             name <- restart$name
[13:21:33.759]                             if (is.null(name)) 
[13:21:33.759]                               next
[13:21:33.759]                             if (!grepl(pattern, name)) 
[13:21:33.759]                               next
[13:21:33.759]                             invokeRestart(restart)
[13:21:33.759]                             muffled <- TRUE
[13:21:33.759]                             break
[13:21:33.759]                           }
[13:21:33.759]                         }
[13:21:33.759]                       }
[13:21:33.759]                       invisible(muffled)
[13:21:33.759]                     }
[13:21:33.759]                     muffleCondition(cond, pattern = "^muffle")
[13:21:33.759]                   }
[13:21:33.759]                 }
[13:21:33.759]                 else {
[13:21:33.759]                   if (TRUE) {
[13:21:33.759]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.759]                     {
[13:21:33.759]                       inherits <- base::inherits
[13:21:33.759]                       invokeRestart <- base::invokeRestart
[13:21:33.759]                       is.null <- base::is.null
[13:21:33.759]                       muffled <- FALSE
[13:21:33.759]                       if (inherits(cond, "message")) {
[13:21:33.759]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:33.759]                         if (muffled) 
[13:21:33.759]                           invokeRestart("muffleMessage")
[13:21:33.759]                       }
[13:21:33.759]                       else if (inherits(cond, "warning")) {
[13:21:33.759]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:33.759]                         if (muffled) 
[13:21:33.759]                           invokeRestart("muffleWarning")
[13:21:33.759]                       }
[13:21:33.759]                       else if (inherits(cond, "condition")) {
[13:21:33.759]                         if (!is.null(pattern)) {
[13:21:33.759]                           computeRestarts <- base::computeRestarts
[13:21:33.759]                           grepl <- base::grepl
[13:21:33.759]                           restarts <- computeRestarts(cond)
[13:21:33.759]                           for (restart in restarts) {
[13:21:33.759]                             name <- restart$name
[13:21:33.759]                             if (is.null(name)) 
[13:21:33.759]                               next
[13:21:33.759]                             if (!grepl(pattern, name)) 
[13:21:33.759]                               next
[13:21:33.759]                             invokeRestart(restart)
[13:21:33.759]                             muffled <- TRUE
[13:21:33.759]                             break
[13:21:33.759]                           }
[13:21:33.759]                         }
[13:21:33.759]                       }
[13:21:33.759]                       invisible(muffled)
[13:21:33.759]                     }
[13:21:33.759]                     muffleCondition(cond, pattern = "^muffle")
[13:21:33.759]                   }
[13:21:33.759]                 }
[13:21:33.759]             }
[13:21:33.759]         }))
[13:21:33.759]     }, error = function(ex) {
[13:21:33.759]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:33.759]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:33.759]                 ...future.rng), started = ...future.startTime, 
[13:21:33.759]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:33.759]             version = "1.8"), class = "FutureResult")
[13:21:33.759]     }, finally = {
[13:21:33.759]         if (!identical(...future.workdir, getwd())) 
[13:21:33.759]             setwd(...future.workdir)
[13:21:33.759]         {
[13:21:33.759]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:33.759]                 ...future.oldOptions$nwarnings <- NULL
[13:21:33.759]             }
[13:21:33.759]             base::options(...future.oldOptions)
[13:21:33.759]             if (.Platform$OS.type == "windows") {
[13:21:33.759]                 old_names <- names(...future.oldEnvVars)
[13:21:33.759]                 envs <- base::Sys.getenv()
[13:21:33.759]                 names <- names(envs)
[13:21:33.759]                 common <- intersect(names, old_names)
[13:21:33.759]                 added <- setdiff(names, old_names)
[13:21:33.759]                 removed <- setdiff(old_names, names)
[13:21:33.759]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:33.759]                   envs[common]]
[13:21:33.759]                 NAMES <- toupper(changed)
[13:21:33.759]                 args <- list()
[13:21:33.759]                 for (kk in seq_along(NAMES)) {
[13:21:33.759]                   name <- changed[[kk]]
[13:21:33.759]                   NAME <- NAMES[[kk]]
[13:21:33.759]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.759]                     next
[13:21:33.759]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:33.759]                 }
[13:21:33.759]                 NAMES <- toupper(added)
[13:21:33.759]                 for (kk in seq_along(NAMES)) {
[13:21:33.759]                   name <- added[[kk]]
[13:21:33.759]                   NAME <- NAMES[[kk]]
[13:21:33.759]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.759]                     next
[13:21:33.759]                   args[[name]] <- ""
[13:21:33.759]                 }
[13:21:33.759]                 NAMES <- toupper(removed)
[13:21:33.759]                 for (kk in seq_along(NAMES)) {
[13:21:33.759]                   name <- removed[[kk]]
[13:21:33.759]                   NAME <- NAMES[[kk]]
[13:21:33.759]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.759]                     next
[13:21:33.759]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:33.759]                 }
[13:21:33.759]                 if (length(args) > 0) 
[13:21:33.759]                   base::do.call(base::Sys.setenv, args = args)
[13:21:33.759]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:33.759]             }
[13:21:33.759]             else {
[13:21:33.759]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:33.759]             }
[13:21:33.759]             {
[13:21:33.759]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:33.759]                   0L) {
[13:21:33.759]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:33.759]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:33.759]                   base::options(opts)
[13:21:33.759]                 }
[13:21:33.759]                 {
[13:21:33.759]                   {
[13:21:33.759]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:33.759]                     NULL
[13:21:33.759]                   }
[13:21:33.759]                   options(future.plan = NULL)
[13:21:33.759]                   if (is.na(NA_character_)) 
[13:21:33.759]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:33.759]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:33.759]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:33.759]                     envir = parent.frame()) 
[13:21:33.759]                   {
[13:21:33.759]                     default_workers <- missing(workers)
[13:21:33.759]                     if (is.function(workers)) 
[13:21:33.759]                       workers <- workers()
[13:21:33.759]                     workers <- structure(as.integer(workers), 
[13:21:33.759]                       class = class(workers))
[13:21:33.759]                     stop_if_not(is.finite(workers), workers >= 
[13:21:33.759]                       1L)
[13:21:33.759]                     if ((workers == 1L && !inherits(workers, 
[13:21:33.759]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:33.759]                       if (default_workers) 
[13:21:33.759]                         supportsMulticore(warn = TRUE)
[13:21:33.759]                       return(sequential(..., envir = envir))
[13:21:33.759]                     }
[13:21:33.759]                     oopts <- options(mc.cores = workers)
[13:21:33.759]                     on.exit(options(oopts))
[13:21:33.759]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:33.759]                       envir = envir)
[13:21:33.759]                     if (!future$lazy) 
[13:21:33.759]                       future <- run(future)
[13:21:33.759]                     invisible(future)
[13:21:33.759]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:33.759]                 }
[13:21:33.759]             }
[13:21:33.759]         }
[13:21:33.759]     })
[13:21:33.759]     if (TRUE) {
[13:21:33.759]         base::sink(type = "output", split = FALSE)
[13:21:33.759]         if (TRUE) {
[13:21:33.759]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:33.759]         }
[13:21:33.759]         else {
[13:21:33.759]             ...future.result["stdout"] <- base::list(NULL)
[13:21:33.759]         }
[13:21:33.759]         base::close(...future.stdout)
[13:21:33.759]         ...future.stdout <- NULL
[13:21:33.759]     }
[13:21:33.759]     ...future.result$conditions <- ...future.conditions
[13:21:33.759]     ...future.result$finished <- base::Sys.time()
[13:21:33.759]     ...future.result
[13:21:33.759] }
[13:21:33.762] assign_globals() ...
[13:21:33.762] List of 11
[13:21:33.762]  $ ...future.FUN            :function (x, ...)  
[13:21:33.762]  $ x_FUN                    :function (x)  
[13:21:33.762]  $ times                    : int 1
[13:21:33.762]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:33.762]  $ stop_if_not              :function (...)  
[13:21:33.762]  $ dim                      : NULL
[13:21:33.762]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:21:33.762]  $ future.call.arguments    : list()
[13:21:33.762]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:33.762]  $ ...future.elements_ii    :List of 5
[13:21:33.762]   ..$ : int 1
[13:21:33.762]   ..$ : int 2
[13:21:33.762]   ..$ : int 3
[13:21:33.762]   ..$ : int 4
[13:21:33.762]   ..$ : int 5
[13:21:33.762]  $ ...future.seeds_ii       : NULL
[13:21:33.762]  $ ...future.globals.maxSize: NULL
[13:21:33.762]  - attr(*, "where")=List of 11
[13:21:33.762]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:33.762]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:33.762]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:33.762]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:33.762]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:33.762]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:33.762]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:33.762]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:33.762]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:33.762]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:33.762]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:33.762]  - attr(*, "resolved")= logi FALSE
[13:21:33.762]  - attr(*, "total_size")= num 94336
[13:21:33.762]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:33.762]  - attr(*, "already-done")= logi TRUE
[13:21:33.774] - copied ‘...future.FUN’ to environment
[13:21:33.774] - copied ‘x_FUN’ to environment
[13:21:33.774] - copied ‘times’ to environment
[13:21:33.774] - copied ‘stopf’ to environment
[13:21:33.774] - copied ‘stop_if_not’ to environment
[13:21:33.774] - copied ‘dim’ to environment
[13:21:33.774] - copied ‘valid_types’ to environment
[13:21:33.775] - copied ‘future.call.arguments’ to environment
[13:21:33.775] - copied ‘...future.elements_ii’ to environment
[13:21:33.775] - copied ‘...future.seeds_ii’ to environment
[13:21:33.775] - copied ‘...future.globals.maxSize’ to environment
[13:21:33.775] assign_globals() ... done
[13:21:33.775] requestCore(): workers = 2
[13:21:33.777] MulticoreFuture started
[13:21:33.778] - Launch lazy future ... done
[13:21:33.778] run() for ‘MulticoreFuture’ ... done
[13:21:33.778] Created future:
[13:21:33.779] plan(): Setting new future strategy stack:
[13:21:33.779] List of future strategies:
[13:21:33.779] 1. sequential:
[13:21:33.779]    - args: function (..., envir = parent.frame())
[13:21:33.779]    - tweaked: FALSE
[13:21:33.779]    - call: NULL
[13:21:33.780] plan(): nbrOfWorkers() = 1
[13:21:33.782] plan(): Setting new future strategy stack:
[13:21:33.782] List of future strategies:
[13:21:33.782] 1. multicore:
[13:21:33.782]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:33.782]    - tweaked: FALSE
[13:21:33.782]    - call: plan(strategy)
[13:21:33.788] plan(): nbrOfWorkers() = 2
[13:21:33.779] MulticoreFuture:
[13:21:33.779] Label: ‘future_vapply-1’
[13:21:33.779] Expression:
[13:21:33.779] {
[13:21:33.779]     do.call(function(...) {
[13:21:33.779]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.779]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:33.779]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.779]             on.exit(options(oopts), add = TRUE)
[13:21:33.779]         }
[13:21:33.779]         {
[13:21:33.779]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:33.779]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.779]                 ...future.FUN(...future.X_jj, ...)
[13:21:33.779]             })
[13:21:33.779]         }
[13:21:33.779]     }, args = future.call.arguments)
[13:21:33.779] }
[13:21:33.779] Lazy evaluation: FALSE
[13:21:33.779] Asynchronous evaluation: TRUE
[13:21:33.779] Local evaluation: TRUE
[13:21:33.779] Environment: R_GlobalEnv
[13:21:33.779] Capture standard output: TRUE
[13:21:33.779] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:33.779] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:33.779] Packages: 1 packages (‘future.apply’)
[13:21:33.779] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:33.779] Resolved: TRUE
[13:21:33.779] Value: <not collected>
[13:21:33.779] Conditions captured: <none>
[13:21:33.779] Early signaling: FALSE
[13:21:33.779] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:33.779] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:33.789] Chunk #1 of 2 ... DONE
[13:21:33.789] Chunk #2 of 2 ...
[13:21:33.789]  - Finding globals in 'X' for chunk #2 ...
[13:21:33.790] getGlobalsAndPackages() ...
[13:21:33.790] Searching for globals...
[13:21:33.790] 
[13:21:33.790] Searching for globals ... DONE
[13:21:33.791] - globals: [0] <none>
[13:21:33.791] getGlobalsAndPackages() ... DONE
[13:21:33.791]    + additional globals found: [n=0] 
[13:21:33.791]    + additional namespaces needed: [n=0] 
[13:21:33.791]  - Finding globals in 'X' for chunk #2 ... DONE
[13:21:33.791]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:33.791]  - seeds: <none>
[13:21:33.791]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.792] getGlobalsAndPackages() ...
[13:21:33.792] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.792] Resolving globals: FALSE
[13:21:33.792] Tweak future expression to call with '...' arguments ...
[13:21:33.792] {
[13:21:33.792]     do.call(function(...) {
[13:21:33.792]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.792]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:33.792]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.792]             on.exit(options(oopts), add = TRUE)
[13:21:33.792]         }
[13:21:33.792]         {
[13:21:33.792]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:33.792]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.792]                 ...future.FUN(...future.X_jj, ...)
[13:21:33.792]             })
[13:21:33.792]         }
[13:21:33.792]     }, args = future.call.arguments)
[13:21:33.792] }
[13:21:33.793] Tweak future expression to call with '...' arguments ... DONE
[13:21:33.794] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.794] - packages: [1] ‘future.apply’
[13:21:33.794] getGlobalsAndPackages() ... DONE
[13:21:33.795] run() for ‘Future’ ...
[13:21:33.795] - state: ‘created’
[13:21:33.795] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:33.800] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:33.800] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:33.800]   - Field: ‘label’
[13:21:33.801]   - Field: ‘local’
[13:21:33.801]   - Field: ‘owner’
[13:21:33.801]   - Field: ‘envir’
[13:21:33.801]   - Field: ‘workers’
[13:21:33.801]   - Field: ‘packages’
[13:21:33.801]   - Field: ‘gc’
[13:21:33.801]   - Field: ‘job’
[13:21:33.802]   - Field: ‘conditions’
[13:21:33.802]   - Field: ‘expr’
[13:21:33.802]   - Field: ‘uuid’
[13:21:33.802]   - Field: ‘seed’
[13:21:33.802]   - Field: ‘version’
[13:21:33.802]   - Field: ‘result’
[13:21:33.805]   - Field: ‘asynchronous’
[13:21:33.805]   - Field: ‘calls’
[13:21:33.805]   - Field: ‘globals’
[13:21:33.806]   - Field: ‘stdout’
[13:21:33.806]   - Field: ‘earlySignal’
[13:21:33.807]   - Field: ‘lazy’
[13:21:33.807]   - Field: ‘state’
[13:21:33.807] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:33.808] - Launch lazy future ...
[13:21:33.808] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:33.809] Packages needed by future strategies (n = 0): <none>
[13:21:33.810] {
[13:21:33.810]     {
[13:21:33.810]         {
[13:21:33.810]             ...future.startTime <- base::Sys.time()
[13:21:33.810]             {
[13:21:33.810]                 {
[13:21:33.810]                   {
[13:21:33.810]                     {
[13:21:33.810]                       {
[13:21:33.810]                         base::local({
[13:21:33.810]                           has_future <- base::requireNamespace("future", 
[13:21:33.810]                             quietly = TRUE)
[13:21:33.810]                           if (has_future) {
[13:21:33.810]                             ns <- base::getNamespace("future")
[13:21:33.810]                             version <- ns[[".package"]][["version"]]
[13:21:33.810]                             if (is.null(version)) 
[13:21:33.810]                               version <- utils::packageVersion("future")
[13:21:33.810]                           }
[13:21:33.810]                           else {
[13:21:33.810]                             version <- NULL
[13:21:33.810]                           }
[13:21:33.810]                           if (!has_future || version < "1.8.0") {
[13:21:33.810]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:33.810]                               "", base::R.version$version.string), 
[13:21:33.810]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:33.810]                                 base::R.version$platform, 8 * 
[13:21:33.810]                                   base::.Machine$sizeof.pointer), 
[13:21:33.810]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:33.810]                                 "release", "version")], collapse = " "), 
[13:21:33.810]                               hostname = base::Sys.info()[["nodename"]])
[13:21:33.810]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:33.810]                               info)
[13:21:33.810]                             info <- base::paste(info, collapse = "; ")
[13:21:33.810]                             if (!has_future) {
[13:21:33.810]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:33.810]                                 info)
[13:21:33.810]                             }
[13:21:33.810]                             else {
[13:21:33.810]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:33.810]                                 info, version)
[13:21:33.810]                             }
[13:21:33.810]                             base::stop(msg)
[13:21:33.810]                           }
[13:21:33.810]                         })
[13:21:33.810]                       }
[13:21:33.810]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:33.810]                       base::options(mc.cores = 1L)
[13:21:33.810]                     }
[13:21:33.810]                     base::local({
[13:21:33.810]                       for (pkg in "future.apply") {
[13:21:33.810]                         base::loadNamespace(pkg)
[13:21:33.810]                         base::library(pkg, character.only = TRUE)
[13:21:33.810]                       }
[13:21:33.810]                     })
[13:21:33.810]                   }
[13:21:33.810]                   options(future.plan = NULL)
[13:21:33.810]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:33.810]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:33.810]                 }
[13:21:33.810]                 ...future.workdir <- getwd()
[13:21:33.810]             }
[13:21:33.810]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:33.810]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:33.810]         }
[13:21:33.810]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:33.810]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:33.810]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:33.810]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:33.810]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:33.810]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:33.810]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:33.810]             base::names(...future.oldOptions))
[13:21:33.810]     }
[13:21:33.810]     if (FALSE) {
[13:21:33.810]     }
[13:21:33.810]     else {
[13:21:33.810]         if (TRUE) {
[13:21:33.810]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:33.810]                 open = "w")
[13:21:33.810]         }
[13:21:33.810]         else {
[13:21:33.810]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:33.810]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:33.810]         }
[13:21:33.810]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:33.810]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:33.810]             base::sink(type = "output", split = FALSE)
[13:21:33.810]             base::close(...future.stdout)
[13:21:33.810]         }, add = TRUE)
[13:21:33.810]     }
[13:21:33.810]     ...future.frame <- base::sys.nframe()
[13:21:33.810]     ...future.conditions <- base::list()
[13:21:33.810]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:33.810]     if (FALSE) {
[13:21:33.810]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:33.810]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:33.810]     }
[13:21:33.810]     ...future.result <- base::tryCatch({
[13:21:33.810]         base::withCallingHandlers({
[13:21:33.810]             ...future.value <- base::withVisible(base::local({
[13:21:33.810]                 withCallingHandlers({
[13:21:33.810]                   {
[13:21:33.810]                     do.call(function(...) {
[13:21:33.810]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.810]                       if (!identical(...future.globals.maxSize.org, 
[13:21:33.810]                         ...future.globals.maxSize)) {
[13:21:33.810]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.810]                         on.exit(options(oopts), add = TRUE)
[13:21:33.810]                       }
[13:21:33.810]                       {
[13:21:33.810]                         lapply(seq_along(...future.elements_ii), 
[13:21:33.810]                           FUN = function(jj) {
[13:21:33.810]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.810]                             ...future.FUN(...future.X_jj, ...)
[13:21:33.810]                           })
[13:21:33.810]                       }
[13:21:33.810]                     }, args = future.call.arguments)
[13:21:33.810]                   }
[13:21:33.810]                 }, immediateCondition = function(cond) {
[13:21:33.810]                   save_rds <- function (object, pathname, ...) 
[13:21:33.810]                   {
[13:21:33.810]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:33.810]                     if (file_test("-f", pathname_tmp)) {
[13:21:33.810]                       fi_tmp <- file.info(pathname_tmp)
[13:21:33.810]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:33.810]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:33.810]                         fi_tmp[["mtime"]])
[13:21:33.810]                     }
[13:21:33.810]                     tryCatch({
[13:21:33.810]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:33.810]                     }, error = function(ex) {
[13:21:33.810]                       msg <- conditionMessage(ex)
[13:21:33.810]                       fi_tmp <- file.info(pathname_tmp)
[13:21:33.810]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:33.810]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:33.810]                         fi_tmp[["mtime"]], msg)
[13:21:33.810]                       ex$message <- msg
[13:21:33.810]                       stop(ex)
[13:21:33.810]                     })
[13:21:33.810]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:33.810]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:33.810]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:33.810]                       fi_tmp <- file.info(pathname_tmp)
[13:21:33.810]                       fi <- file.info(pathname)
[13:21:33.810]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:33.810]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:33.810]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:33.810]                         fi[["size"]], fi[["mtime"]])
[13:21:33.810]                       stop(msg)
[13:21:33.810]                     }
[13:21:33.810]                     invisible(pathname)
[13:21:33.810]                   }
[13:21:33.810]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:33.810]                     rootPath = tempdir()) 
[13:21:33.810]                   {
[13:21:33.810]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:33.810]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:33.810]                       tmpdir = path, fileext = ".rds")
[13:21:33.810]                     save_rds(obj, file)
[13:21:33.810]                   }
[13:21:33.810]                   saveImmediateCondition(cond, path = "/tmp/RtmpbpFWGO/.future/immediateConditions")
[13:21:33.810]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.810]                   {
[13:21:33.810]                     inherits <- base::inherits
[13:21:33.810]                     invokeRestart <- base::invokeRestart
[13:21:33.810]                     is.null <- base::is.null
[13:21:33.810]                     muffled <- FALSE
[13:21:33.810]                     if (inherits(cond, "message")) {
[13:21:33.810]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:33.810]                       if (muffled) 
[13:21:33.810]                         invokeRestart("muffleMessage")
[13:21:33.810]                     }
[13:21:33.810]                     else if (inherits(cond, "warning")) {
[13:21:33.810]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:33.810]                       if (muffled) 
[13:21:33.810]                         invokeRestart("muffleWarning")
[13:21:33.810]                     }
[13:21:33.810]                     else if (inherits(cond, "condition")) {
[13:21:33.810]                       if (!is.null(pattern)) {
[13:21:33.810]                         computeRestarts <- base::computeRestarts
[13:21:33.810]                         grepl <- base::grepl
[13:21:33.810]                         restarts <- computeRestarts(cond)
[13:21:33.810]                         for (restart in restarts) {
[13:21:33.810]                           name <- restart$name
[13:21:33.810]                           if (is.null(name)) 
[13:21:33.810]                             next
[13:21:33.810]                           if (!grepl(pattern, name)) 
[13:21:33.810]                             next
[13:21:33.810]                           invokeRestart(restart)
[13:21:33.810]                           muffled <- TRUE
[13:21:33.810]                           break
[13:21:33.810]                         }
[13:21:33.810]                       }
[13:21:33.810]                     }
[13:21:33.810]                     invisible(muffled)
[13:21:33.810]                   }
[13:21:33.810]                   muffleCondition(cond)
[13:21:33.810]                 })
[13:21:33.810]             }))
[13:21:33.810]             future::FutureResult(value = ...future.value$value, 
[13:21:33.810]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:33.810]                   ...future.rng), globalenv = if (FALSE) 
[13:21:33.810]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:33.810]                     ...future.globalenv.names))
[13:21:33.810]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:33.810]         }, condition = base::local({
[13:21:33.810]             c <- base::c
[13:21:33.810]             inherits <- base::inherits
[13:21:33.810]             invokeRestart <- base::invokeRestart
[13:21:33.810]             length <- base::length
[13:21:33.810]             list <- base::list
[13:21:33.810]             seq.int <- base::seq.int
[13:21:33.810]             signalCondition <- base::signalCondition
[13:21:33.810]             sys.calls <- base::sys.calls
[13:21:33.810]             `[[` <- base::`[[`
[13:21:33.810]             `+` <- base::`+`
[13:21:33.810]             `<<-` <- base::`<<-`
[13:21:33.810]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:33.810]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:33.810]                   3L)]
[13:21:33.810]             }
[13:21:33.810]             function(cond) {
[13:21:33.810]                 is_error <- inherits(cond, "error")
[13:21:33.810]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:33.810]                   NULL)
[13:21:33.810]                 if (is_error) {
[13:21:33.810]                   sessionInformation <- function() {
[13:21:33.810]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:33.810]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:33.810]                       search = base::search(), system = base::Sys.info())
[13:21:33.810]                   }
[13:21:33.810]                   ...future.conditions[[length(...future.conditions) + 
[13:21:33.810]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:33.810]                     cond$call), session = sessionInformation(), 
[13:21:33.810]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:33.810]                   signalCondition(cond)
[13:21:33.810]                 }
[13:21:33.810]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:33.810]                 "immediateCondition"))) {
[13:21:33.810]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:33.810]                   ...future.conditions[[length(...future.conditions) + 
[13:21:33.810]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:33.810]                   if (TRUE && !signal) {
[13:21:33.810]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.810]                     {
[13:21:33.810]                       inherits <- base::inherits
[13:21:33.810]                       invokeRestart <- base::invokeRestart
[13:21:33.810]                       is.null <- base::is.null
[13:21:33.810]                       muffled <- FALSE
[13:21:33.810]                       if (inherits(cond, "message")) {
[13:21:33.810]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:33.810]                         if (muffled) 
[13:21:33.810]                           invokeRestart("muffleMessage")
[13:21:33.810]                       }
[13:21:33.810]                       else if (inherits(cond, "warning")) {
[13:21:33.810]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:33.810]                         if (muffled) 
[13:21:33.810]                           invokeRestart("muffleWarning")
[13:21:33.810]                       }
[13:21:33.810]                       else if (inherits(cond, "condition")) {
[13:21:33.810]                         if (!is.null(pattern)) {
[13:21:33.810]                           computeRestarts <- base::computeRestarts
[13:21:33.810]                           grepl <- base::grepl
[13:21:33.810]                           restarts <- computeRestarts(cond)
[13:21:33.810]                           for (restart in restarts) {
[13:21:33.810]                             name <- restart$name
[13:21:33.810]                             if (is.null(name)) 
[13:21:33.810]                               next
[13:21:33.810]                             if (!grepl(pattern, name)) 
[13:21:33.810]                               next
[13:21:33.810]                             invokeRestart(restart)
[13:21:33.810]                             muffled <- TRUE
[13:21:33.810]                             break
[13:21:33.810]                           }
[13:21:33.810]                         }
[13:21:33.810]                       }
[13:21:33.810]                       invisible(muffled)
[13:21:33.810]                     }
[13:21:33.810]                     muffleCondition(cond, pattern = "^muffle")
[13:21:33.810]                   }
[13:21:33.810]                 }
[13:21:33.810]                 else {
[13:21:33.810]                   if (TRUE) {
[13:21:33.810]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.810]                     {
[13:21:33.810]                       inherits <- base::inherits
[13:21:33.810]                       invokeRestart <- base::invokeRestart
[13:21:33.810]                       is.null <- base::is.null
[13:21:33.810]                       muffled <- FALSE
[13:21:33.810]                       if (inherits(cond, "message")) {
[13:21:33.810]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:33.810]                         if (muffled) 
[13:21:33.810]                           invokeRestart("muffleMessage")
[13:21:33.810]                       }
[13:21:33.810]                       else if (inherits(cond, "warning")) {
[13:21:33.810]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:33.810]                         if (muffled) 
[13:21:33.810]                           invokeRestart("muffleWarning")
[13:21:33.810]                       }
[13:21:33.810]                       else if (inherits(cond, "condition")) {
[13:21:33.810]                         if (!is.null(pattern)) {
[13:21:33.810]                           computeRestarts <- base::computeRestarts
[13:21:33.810]                           grepl <- base::grepl
[13:21:33.810]                           restarts <- computeRestarts(cond)
[13:21:33.810]                           for (restart in restarts) {
[13:21:33.810]                             name <- restart$name
[13:21:33.810]                             if (is.null(name)) 
[13:21:33.810]                               next
[13:21:33.810]                             if (!grepl(pattern, name)) 
[13:21:33.810]                               next
[13:21:33.810]                             invokeRestart(restart)
[13:21:33.810]                             muffled <- TRUE
[13:21:33.810]                             break
[13:21:33.810]                           }
[13:21:33.810]                         }
[13:21:33.810]                       }
[13:21:33.810]                       invisible(muffled)
[13:21:33.810]                     }
[13:21:33.810]                     muffleCondition(cond, pattern = "^muffle")
[13:21:33.810]                   }
[13:21:33.810]                 }
[13:21:33.810]             }
[13:21:33.810]         }))
[13:21:33.810]     }, error = function(ex) {
[13:21:33.810]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:33.810]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:33.810]                 ...future.rng), started = ...future.startTime, 
[13:21:33.810]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:33.810]             version = "1.8"), class = "FutureResult")
[13:21:33.810]     }, finally = {
[13:21:33.810]         if (!identical(...future.workdir, getwd())) 
[13:21:33.810]             setwd(...future.workdir)
[13:21:33.810]         {
[13:21:33.810]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:33.810]                 ...future.oldOptions$nwarnings <- NULL
[13:21:33.810]             }
[13:21:33.810]             base::options(...future.oldOptions)
[13:21:33.810]             if (.Platform$OS.type == "windows") {
[13:21:33.810]                 old_names <- names(...future.oldEnvVars)
[13:21:33.810]                 envs <- base::Sys.getenv()
[13:21:33.810]                 names <- names(envs)
[13:21:33.810]                 common <- intersect(names, old_names)
[13:21:33.810]                 added <- setdiff(names, old_names)
[13:21:33.810]                 removed <- setdiff(old_names, names)
[13:21:33.810]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:33.810]                   envs[common]]
[13:21:33.810]                 NAMES <- toupper(changed)
[13:21:33.810]                 args <- list()
[13:21:33.810]                 for (kk in seq_along(NAMES)) {
[13:21:33.810]                   name <- changed[[kk]]
[13:21:33.810]                   NAME <- NAMES[[kk]]
[13:21:33.810]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.810]                     next
[13:21:33.810]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:33.810]                 }
[13:21:33.810]                 NAMES <- toupper(added)
[13:21:33.810]                 for (kk in seq_along(NAMES)) {
[13:21:33.810]                   name <- added[[kk]]
[13:21:33.810]                   NAME <- NAMES[[kk]]
[13:21:33.810]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.810]                     next
[13:21:33.810]                   args[[name]] <- ""
[13:21:33.810]                 }
[13:21:33.810]                 NAMES <- toupper(removed)
[13:21:33.810]                 for (kk in seq_along(NAMES)) {
[13:21:33.810]                   name <- removed[[kk]]
[13:21:33.810]                   NAME <- NAMES[[kk]]
[13:21:33.810]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.810]                     next
[13:21:33.810]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:33.810]                 }
[13:21:33.810]                 if (length(args) > 0) 
[13:21:33.810]                   base::do.call(base::Sys.setenv, args = args)
[13:21:33.810]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:33.810]             }
[13:21:33.810]             else {
[13:21:33.810]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:33.810]             }
[13:21:33.810]             {
[13:21:33.810]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:33.810]                   0L) {
[13:21:33.810]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:33.810]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:33.810]                   base::options(opts)
[13:21:33.810]                 }
[13:21:33.810]                 {
[13:21:33.810]                   {
[13:21:33.810]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:33.810]                     NULL
[13:21:33.810]                   }
[13:21:33.810]                   options(future.plan = NULL)
[13:21:33.810]                   if (is.na(NA_character_)) 
[13:21:33.810]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:33.810]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:33.810]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:33.810]                     envir = parent.frame()) 
[13:21:33.810]                   {
[13:21:33.810]                     default_workers <- missing(workers)
[13:21:33.810]                     if (is.function(workers)) 
[13:21:33.810]                       workers <- workers()
[13:21:33.810]                     workers <- structure(as.integer(workers), 
[13:21:33.810]                       class = class(workers))
[13:21:33.810]                     stop_if_not(is.finite(workers), workers >= 
[13:21:33.810]                       1L)
[13:21:33.810]                     if ((workers == 1L && !inherits(workers, 
[13:21:33.810]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:33.810]                       if (default_workers) 
[13:21:33.810]                         supportsMulticore(warn = TRUE)
[13:21:33.810]                       return(sequential(..., envir = envir))
[13:21:33.810]                     }
[13:21:33.810]                     oopts <- options(mc.cores = workers)
[13:21:33.810]                     on.exit(options(oopts))
[13:21:33.810]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:33.810]                       envir = envir)
[13:21:33.810]                     if (!future$lazy) 
[13:21:33.810]                       future <- run(future)
[13:21:33.810]                     invisible(future)
[13:21:33.810]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:33.810]                 }
[13:21:33.810]             }
[13:21:33.810]         }
[13:21:33.810]     })
[13:21:33.810]     if (TRUE) {
[13:21:33.810]         base::sink(type = "output", split = FALSE)
[13:21:33.810]         if (TRUE) {
[13:21:33.810]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:33.810]         }
[13:21:33.810]         else {
[13:21:33.810]             ...future.result["stdout"] <- base::list(NULL)
[13:21:33.810]         }
[13:21:33.810]         base::close(...future.stdout)
[13:21:33.810]         ...future.stdout <- NULL
[13:21:33.810]     }
[13:21:33.810]     ...future.result$conditions <- ...future.conditions
[13:21:33.810]     ...future.result$finished <- base::Sys.time()
[13:21:33.810]     ...future.result
[13:21:33.810] }
[13:21:33.814] assign_globals() ...
[13:21:33.814] List of 11
[13:21:33.814]  $ ...future.FUN            :function (x, ...)  
[13:21:33.814]  $ x_FUN                    :function (x)  
[13:21:33.814]  $ times                    : int 1
[13:21:33.814]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:33.814]  $ stop_if_not              :function (...)  
[13:21:33.814]  $ dim                      : NULL
[13:21:33.814]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:21:33.814]  $ future.call.arguments    : list()
[13:21:33.814]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:33.814]  $ ...future.elements_ii    :List of 5
[13:21:33.814]   ..$ : int 6
[13:21:33.814]   ..$ : int 7
[13:21:33.814]   ..$ : int 8
[13:21:33.814]   ..$ : int 9
[13:21:33.814]   ..$ : int 10
[13:21:33.814]  $ ...future.seeds_ii       : NULL
[13:21:33.814]  $ ...future.globals.maxSize: NULL
[13:21:33.814]  - attr(*, "where")=List of 11
[13:21:33.814]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:33.814]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:33.814]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:33.814]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:33.814]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:33.814]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:33.814]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:33.814]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:33.814]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:33.814]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:33.814]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:33.814]  - attr(*, "resolved")= logi FALSE
[13:21:33.814]  - attr(*, "total_size")= num 94336
[13:21:33.814]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:33.814]  - attr(*, "already-done")= logi TRUE
[13:21:33.827] - copied ‘...future.FUN’ to environment
[13:21:33.827] - copied ‘x_FUN’ to environment
[13:21:33.827] - copied ‘times’ to environment
[13:21:33.828] - copied ‘stopf’ to environment
[13:21:33.828] - copied ‘stop_if_not’ to environment
[13:21:33.828] - copied ‘dim’ to environment
[13:21:33.828] - copied ‘valid_types’ to environment
[13:21:33.828] - copied ‘future.call.arguments’ to environment
[13:21:33.828] - copied ‘...future.elements_ii’ to environment
[13:21:33.828] - copied ‘...future.seeds_ii’ to environment
[13:21:33.828] - copied ‘...future.globals.maxSize’ to environment
[13:21:33.828] assign_globals() ... done
[13:21:33.829] requestCore(): workers = 2
[13:21:33.831] MulticoreFuture started
[13:21:33.831] - Launch lazy future ... done
[13:21:33.832] run() for ‘MulticoreFuture’ ... done
[13:21:33.832] Created future:
[13:21:33.833] plan(): Setting new future strategy stack:
[13:21:33.833] List of future strategies:
[13:21:33.833] 1. sequential:
[13:21:33.833]    - args: function (..., envir = parent.frame())
[13:21:33.833]    - tweaked: FALSE
[13:21:33.833]    - call: NULL
[13:21:33.834] plan(): nbrOfWorkers() = 1
[13:21:33.836] plan(): Setting new future strategy stack:
[13:21:33.836] List of future strategies:
[13:21:33.836] 1. multicore:
[13:21:33.836]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:33.836]    - tweaked: FALSE
[13:21:33.836]    - call: plan(strategy)
[13:21:33.841] plan(): nbrOfWorkers() = 2
[13:21:33.832] MulticoreFuture:
[13:21:33.832] Label: ‘future_vapply-2’
[13:21:33.832] Expression:
[13:21:33.832] {
[13:21:33.832]     do.call(function(...) {
[13:21:33.832]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.832]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:33.832]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.832]             on.exit(options(oopts), add = TRUE)
[13:21:33.832]         }
[13:21:33.832]         {
[13:21:33.832]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:33.832]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.832]                 ...future.FUN(...future.X_jj, ...)
[13:21:33.832]             })
[13:21:33.832]         }
[13:21:33.832]     }, args = future.call.arguments)
[13:21:33.832] }
[13:21:33.832] Lazy evaluation: FALSE
[13:21:33.832] Asynchronous evaluation: TRUE
[13:21:33.832] Local evaluation: TRUE
[13:21:33.832] Environment: R_GlobalEnv
[13:21:33.832] Capture standard output: TRUE
[13:21:33.832] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:33.832] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:33.832] Packages: 1 packages (‘future.apply’)
[13:21:33.832] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:33.832] Resolved: TRUE
[13:21:33.832] Value: <not collected>
[13:21:33.832] Conditions captured: <none>
[13:21:33.832] Early signaling: FALSE
[13:21:33.832] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:33.832] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:33.842] Chunk #2 of 2 ... DONE
[13:21:33.843] Launching 2 futures (chunks) ... DONE
[13:21:33.843] Resolving 2 futures (chunks) ...
[13:21:33.843] resolve() on list ...
[13:21:33.843]  recursive: 0
[13:21:33.843]  length: 2
[13:21:33.843] 
[13:21:33.844] Future #1
[13:21:33.844] result() for MulticoreFuture ...
[13:21:33.845] result() for MulticoreFuture ...
[13:21:33.845] result() for MulticoreFuture ... done
[13:21:33.845] result() for MulticoreFuture ... done
[13:21:33.845] result() for MulticoreFuture ...
[13:21:33.845] result() for MulticoreFuture ... done
[13:21:33.846] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:21:33.846] - nx: 2
[13:21:33.846] - relay: TRUE
[13:21:33.846] - stdout: TRUE
[13:21:33.846] - signal: TRUE
[13:21:33.846] - resignal: FALSE
[13:21:33.846] - force: TRUE
[13:21:33.847] - relayed: [n=2] FALSE, FALSE
[13:21:33.847] - queued futures: [n=2] FALSE, FALSE
[13:21:33.847]  - until=1
[13:21:33.847]  - relaying element #1
[13:21:33.847] result() for MulticoreFuture ...
[13:21:33.847] result() for MulticoreFuture ... done
[13:21:33.847] result() for MulticoreFuture ...
[13:21:33.848] result() for MulticoreFuture ... done
[13:21:33.848] result() for MulticoreFuture ...
[13:21:33.848] result() for MulticoreFuture ... done
[13:21:33.848] result() for MulticoreFuture ...
[13:21:33.848] result() for MulticoreFuture ... done
[13:21:33.848] - relayed: [n=2] TRUE, FALSE
[13:21:33.849] - queued futures: [n=2] TRUE, FALSE
[13:21:33.849] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:21:33.852]  length: 1 (resolved future 1)
[13:21:33.853] Future #2
[13:21:33.853] result() for MulticoreFuture ...
[13:21:33.855] result() for MulticoreFuture ...
[13:21:33.855] result() for MulticoreFuture ... done
[13:21:33.856] result() for MulticoreFuture ... done
[13:21:33.856] result() for MulticoreFuture ...
[13:21:33.857] result() for MulticoreFuture ... done
[13:21:33.857] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:21:33.857] - nx: 2
[13:21:33.857] - relay: TRUE
[13:21:33.858] - stdout: TRUE
[13:21:33.858] - signal: TRUE
[13:21:33.858] - resignal: FALSE
[13:21:33.858] - force: TRUE
[13:21:33.858] - relayed: [n=2] TRUE, FALSE
[13:21:33.859] - queued futures: [n=2] TRUE, FALSE
[13:21:33.859]  - until=2
[13:21:33.859]  - relaying element #2
[13:21:33.859] result() for MulticoreFuture ...
[13:21:33.859] result() for MulticoreFuture ... done
[13:21:33.859] result() for MulticoreFuture ...
[13:21:33.860] result() for MulticoreFuture ... done
[13:21:33.860] result() for MulticoreFuture ...
[13:21:33.860] result() for MulticoreFuture ... done
[13:21:33.860] result() for MulticoreFuture ...
[13:21:33.860] result() for MulticoreFuture ... done
[13:21:33.860] - relayed: [n=2] TRUE, TRUE
[13:21:33.861] - queued futures: [n=2] TRUE, TRUE
[13:21:33.861] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:21:33.861]  length: 0 (resolved future 2)
[13:21:33.861] Relaying remaining futures
[13:21:33.861] signalConditionsASAP(NULL, pos=0) ...
[13:21:33.861] - nx: 2
[13:21:33.861] - relay: TRUE
[13:21:33.862] - stdout: TRUE
[13:21:33.862] - signal: TRUE
[13:21:33.862] - resignal: FALSE
[13:21:33.862] - force: TRUE
[13:21:33.862] - relayed: [n=2] TRUE, TRUE
[13:21:33.862] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:21:33.862] - relayed: [n=2] TRUE, TRUE
[13:21:33.862] - queued futures: [n=2] TRUE, TRUE
[13:21:33.862] signalConditionsASAP(NULL, pos=0) ... done
[13:21:33.863] resolve() on list ... DONE
[13:21:33.863] result() for MulticoreFuture ...
[13:21:33.863] result() for MulticoreFuture ... done
[13:21:33.863] result() for MulticoreFuture ...
[13:21:33.863] result() for MulticoreFuture ... done
[13:21:33.863] result() for MulticoreFuture ...
[13:21:33.863] result() for MulticoreFuture ... done
[13:21:33.863] result() for MulticoreFuture ...
[13:21:33.864] result() for MulticoreFuture ... done
[13:21:33.864]  - Number of value chunks collected: 2
[13:21:33.864] Resolving 2 futures (chunks) ... DONE
[13:21:33.864] Reducing values from 2 chunks ...
[13:21:33.864]  - Number of values collected after concatenation: 10
[13:21:33.864]  - Number of values expected: 10
[13:21:33.864] Reducing values from 2 chunks ... DONE
[13:21:33.864] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[13:21:33.866] future_lapply() ...
[13:21:33.872] Number of chunks: 2
[13:21:33.872] getGlobalsAndPackagesXApply() ...
[13:21:33.872]  - future.globals: TRUE
[13:21:33.873] getGlobalsAndPackages() ...
[13:21:33.873] Searching for globals...
[13:21:33.877] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[13:21:33.877] Searching for globals ... DONE
[13:21:33.877] Resolving globals: FALSE
[13:21:33.878] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[13:21:33.878] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:33.879] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:33.879] - packages: [1] ‘future.apply’
[13:21:33.879] getGlobalsAndPackages() ... DONE
[13:21:33.879]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:33.879]  - needed namespaces: [n=1] ‘future.apply’
[13:21:33.879] Finding globals ... DONE
[13:21:33.879]  - use_args: TRUE
[13:21:33.879]  - Getting '...' globals ...
[13:21:33.880] resolve() on list ...
[13:21:33.880]  recursive: 0
[13:21:33.880]  length: 1
[13:21:33.880]  elements: ‘...’
[13:21:33.880]  length: 0 (resolved future 1)
[13:21:33.880] resolve() on list ... DONE
[13:21:33.880]    - '...' content: [n=0] 
[13:21:33.880] List of 1
[13:21:33.880]  $ ...: list()
[13:21:33.880]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:33.880]  - attr(*, "where")=List of 1
[13:21:33.880]   ..$ ...:<environment: 0x563b6d5898e0> 
[13:21:33.880]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:33.880]  - attr(*, "resolved")= logi TRUE
[13:21:33.880]  - attr(*, "total_size")= num NA
[13:21:33.886]  - Getting '...' globals ... DONE
[13:21:33.886] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:33.886] List of 8
[13:21:33.886]  $ ...future.FUN:function (x, ...)  
[13:21:33.886]  $ x_FUN        :function (x)  
[13:21:33.886]  $ times        : int 2
[13:21:33.886]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:33.886]  $ stop_if_not  :function (...)  
[13:21:33.886]  $ dim          : NULL
[13:21:33.886]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:21:33.886]  $ ...          : list()
[13:21:33.886]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:33.886]  - attr(*, "where")=List of 8
[13:21:33.886]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:33.886]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:33.886]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:33.886]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:33.886]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:33.886]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:33.886]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:33.886]   ..$ ...          :<environment: 0x563b6d5898e0> 
[13:21:33.886]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:33.886]  - attr(*, "resolved")= logi FALSE
[13:21:33.886]  - attr(*, "total_size")= num 96456
[13:21:33.892] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:21:33.892] getGlobalsAndPackagesXApply() ... DONE
[13:21:33.892] Number of futures (= number of chunks): 2
[13:21:33.893] Launching 2 futures (chunks) ...
[13:21:33.893] Chunk #1 of 2 ...
[13:21:33.893]  - Finding globals in 'X' for chunk #1 ...
[13:21:33.893] getGlobalsAndPackages() ...
[13:21:33.893] Searching for globals...
[13:21:33.893] 
[13:21:33.893] Searching for globals ... DONE
[13:21:33.894] - globals: [0] <none>
[13:21:33.894] getGlobalsAndPackages() ... DONE
[13:21:33.894]    + additional globals found: [n=0] 
[13:21:33.894]    + additional namespaces needed: [n=0] 
[13:21:33.894]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:33.894]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:33.894]  - seeds: <none>
[13:21:33.894]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.894] getGlobalsAndPackages() ...
[13:21:33.894] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.895] Resolving globals: FALSE
[13:21:33.895] Tweak future expression to call with '...' arguments ...
[13:21:33.895] {
[13:21:33.895]     do.call(function(...) {
[13:21:33.895]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.895]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:33.895]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.895]             on.exit(options(oopts), add = TRUE)
[13:21:33.895]         }
[13:21:33.895]         {
[13:21:33.895]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:33.895]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.895]                 ...future.FUN(...future.X_jj, ...)
[13:21:33.895]             })
[13:21:33.895]         }
[13:21:33.895]     }, args = future.call.arguments)
[13:21:33.895] }
[13:21:33.895] Tweak future expression to call with '...' arguments ... DONE
[13:21:33.896] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.896] - packages: [1] ‘future.apply’
[13:21:33.896] getGlobalsAndPackages() ... DONE
[13:21:33.896] run() for ‘Future’ ...
[13:21:33.896] - state: ‘created’
[13:21:33.897] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:33.900] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:33.901] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:33.901]   - Field: ‘label’
[13:21:33.901]   - Field: ‘local’
[13:21:33.901]   - Field: ‘owner’
[13:21:33.901]   - Field: ‘envir’
[13:21:33.901]   - Field: ‘workers’
[13:21:33.901]   - Field: ‘packages’
[13:21:33.901]   - Field: ‘gc’
[13:21:33.901]   - Field: ‘job’
[13:21:33.902]   - Field: ‘conditions’
[13:21:33.902]   - Field: ‘expr’
[13:21:33.902]   - Field: ‘uuid’
[13:21:33.902]   - Field: ‘seed’
[13:21:33.902]   - Field: ‘version’
[13:21:33.902]   - Field: ‘result’
[13:21:33.902]   - Field: ‘asynchronous’
[13:21:33.902]   - Field: ‘calls’
[13:21:33.902]   - Field: ‘globals’
[13:21:33.902]   - Field: ‘stdout’
[13:21:33.902]   - Field: ‘earlySignal’
[13:21:33.903]   - Field: ‘lazy’
[13:21:33.903]   - Field: ‘state’
[13:21:33.903] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:33.903] - Launch lazy future ...
[13:21:33.903] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:33.903] Packages needed by future strategies (n = 0): <none>
[13:21:33.904] {
[13:21:33.904]     {
[13:21:33.904]         {
[13:21:33.904]             ...future.startTime <- base::Sys.time()
[13:21:33.904]             {
[13:21:33.904]                 {
[13:21:33.904]                   {
[13:21:33.904]                     {
[13:21:33.904]                       {
[13:21:33.904]                         base::local({
[13:21:33.904]                           has_future <- base::requireNamespace("future", 
[13:21:33.904]                             quietly = TRUE)
[13:21:33.904]                           if (has_future) {
[13:21:33.904]                             ns <- base::getNamespace("future")
[13:21:33.904]                             version <- ns[[".package"]][["version"]]
[13:21:33.904]                             if (is.null(version)) 
[13:21:33.904]                               version <- utils::packageVersion("future")
[13:21:33.904]                           }
[13:21:33.904]                           else {
[13:21:33.904]                             version <- NULL
[13:21:33.904]                           }
[13:21:33.904]                           if (!has_future || version < "1.8.0") {
[13:21:33.904]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:33.904]                               "", base::R.version$version.string), 
[13:21:33.904]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:33.904]                                 base::R.version$platform, 8 * 
[13:21:33.904]                                   base::.Machine$sizeof.pointer), 
[13:21:33.904]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:33.904]                                 "release", "version")], collapse = " "), 
[13:21:33.904]                               hostname = base::Sys.info()[["nodename"]])
[13:21:33.904]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:33.904]                               info)
[13:21:33.904]                             info <- base::paste(info, collapse = "; ")
[13:21:33.904]                             if (!has_future) {
[13:21:33.904]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:33.904]                                 info)
[13:21:33.904]                             }
[13:21:33.904]                             else {
[13:21:33.904]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:33.904]                                 info, version)
[13:21:33.904]                             }
[13:21:33.904]                             base::stop(msg)
[13:21:33.904]                           }
[13:21:33.904]                         })
[13:21:33.904]                       }
[13:21:33.904]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:33.904]                       base::options(mc.cores = 1L)
[13:21:33.904]                     }
[13:21:33.904]                     base::local({
[13:21:33.904]                       for (pkg in "future.apply") {
[13:21:33.904]                         base::loadNamespace(pkg)
[13:21:33.904]                         base::library(pkg, character.only = TRUE)
[13:21:33.904]                       }
[13:21:33.904]                     })
[13:21:33.904]                   }
[13:21:33.904]                   options(future.plan = NULL)
[13:21:33.904]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:33.904]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:33.904]                 }
[13:21:33.904]                 ...future.workdir <- getwd()
[13:21:33.904]             }
[13:21:33.904]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:33.904]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:33.904]         }
[13:21:33.904]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:33.904]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:33.904]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:33.904]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:33.904]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:33.904]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:33.904]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:33.904]             base::names(...future.oldOptions))
[13:21:33.904]     }
[13:21:33.904]     if (FALSE) {
[13:21:33.904]     }
[13:21:33.904]     else {
[13:21:33.904]         if (TRUE) {
[13:21:33.904]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:33.904]                 open = "w")
[13:21:33.904]         }
[13:21:33.904]         else {
[13:21:33.904]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:33.904]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:33.904]         }
[13:21:33.904]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:33.904]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:33.904]             base::sink(type = "output", split = FALSE)
[13:21:33.904]             base::close(...future.stdout)
[13:21:33.904]         }, add = TRUE)
[13:21:33.904]     }
[13:21:33.904]     ...future.frame <- base::sys.nframe()
[13:21:33.904]     ...future.conditions <- base::list()
[13:21:33.904]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:33.904]     if (FALSE) {
[13:21:33.904]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:33.904]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:33.904]     }
[13:21:33.904]     ...future.result <- base::tryCatch({
[13:21:33.904]         base::withCallingHandlers({
[13:21:33.904]             ...future.value <- base::withVisible(base::local({
[13:21:33.904]                 withCallingHandlers({
[13:21:33.904]                   {
[13:21:33.904]                     do.call(function(...) {
[13:21:33.904]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.904]                       if (!identical(...future.globals.maxSize.org, 
[13:21:33.904]                         ...future.globals.maxSize)) {
[13:21:33.904]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.904]                         on.exit(options(oopts), add = TRUE)
[13:21:33.904]                       }
[13:21:33.904]                       {
[13:21:33.904]                         lapply(seq_along(...future.elements_ii), 
[13:21:33.904]                           FUN = function(jj) {
[13:21:33.904]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.904]                             ...future.FUN(...future.X_jj, ...)
[13:21:33.904]                           })
[13:21:33.904]                       }
[13:21:33.904]                     }, args = future.call.arguments)
[13:21:33.904]                   }
[13:21:33.904]                 }, immediateCondition = function(cond) {
[13:21:33.904]                   save_rds <- function (object, pathname, ...) 
[13:21:33.904]                   {
[13:21:33.904]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:33.904]                     if (file_test("-f", pathname_tmp)) {
[13:21:33.904]                       fi_tmp <- file.info(pathname_tmp)
[13:21:33.904]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:33.904]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:33.904]                         fi_tmp[["mtime"]])
[13:21:33.904]                     }
[13:21:33.904]                     tryCatch({
[13:21:33.904]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:33.904]                     }, error = function(ex) {
[13:21:33.904]                       msg <- conditionMessage(ex)
[13:21:33.904]                       fi_tmp <- file.info(pathname_tmp)
[13:21:33.904]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:33.904]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:33.904]                         fi_tmp[["mtime"]], msg)
[13:21:33.904]                       ex$message <- msg
[13:21:33.904]                       stop(ex)
[13:21:33.904]                     })
[13:21:33.904]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:33.904]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:33.904]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:33.904]                       fi_tmp <- file.info(pathname_tmp)
[13:21:33.904]                       fi <- file.info(pathname)
[13:21:33.904]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:33.904]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:33.904]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:33.904]                         fi[["size"]], fi[["mtime"]])
[13:21:33.904]                       stop(msg)
[13:21:33.904]                     }
[13:21:33.904]                     invisible(pathname)
[13:21:33.904]                   }
[13:21:33.904]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:33.904]                     rootPath = tempdir()) 
[13:21:33.904]                   {
[13:21:33.904]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:33.904]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:33.904]                       tmpdir = path, fileext = ".rds")
[13:21:33.904]                     save_rds(obj, file)
[13:21:33.904]                   }
[13:21:33.904]                   saveImmediateCondition(cond, path = "/tmp/RtmpbpFWGO/.future/immediateConditions")
[13:21:33.904]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.904]                   {
[13:21:33.904]                     inherits <- base::inherits
[13:21:33.904]                     invokeRestart <- base::invokeRestart
[13:21:33.904]                     is.null <- base::is.null
[13:21:33.904]                     muffled <- FALSE
[13:21:33.904]                     if (inherits(cond, "message")) {
[13:21:33.904]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:33.904]                       if (muffled) 
[13:21:33.904]                         invokeRestart("muffleMessage")
[13:21:33.904]                     }
[13:21:33.904]                     else if (inherits(cond, "warning")) {
[13:21:33.904]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:33.904]                       if (muffled) 
[13:21:33.904]                         invokeRestart("muffleWarning")
[13:21:33.904]                     }
[13:21:33.904]                     else if (inherits(cond, "condition")) {
[13:21:33.904]                       if (!is.null(pattern)) {
[13:21:33.904]                         computeRestarts <- base::computeRestarts
[13:21:33.904]                         grepl <- base::grepl
[13:21:33.904]                         restarts <- computeRestarts(cond)
[13:21:33.904]                         for (restart in restarts) {
[13:21:33.904]                           name <- restart$name
[13:21:33.904]                           if (is.null(name)) 
[13:21:33.904]                             next
[13:21:33.904]                           if (!grepl(pattern, name)) 
[13:21:33.904]                             next
[13:21:33.904]                           invokeRestart(restart)
[13:21:33.904]                           muffled <- TRUE
[13:21:33.904]                           break
[13:21:33.904]                         }
[13:21:33.904]                       }
[13:21:33.904]                     }
[13:21:33.904]                     invisible(muffled)
[13:21:33.904]                   }
[13:21:33.904]                   muffleCondition(cond)
[13:21:33.904]                 })
[13:21:33.904]             }))
[13:21:33.904]             future::FutureResult(value = ...future.value$value, 
[13:21:33.904]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:33.904]                   ...future.rng), globalenv = if (FALSE) 
[13:21:33.904]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:33.904]                     ...future.globalenv.names))
[13:21:33.904]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:33.904]         }, condition = base::local({
[13:21:33.904]             c <- base::c
[13:21:33.904]             inherits <- base::inherits
[13:21:33.904]             invokeRestart <- base::invokeRestart
[13:21:33.904]             length <- base::length
[13:21:33.904]             list <- base::list
[13:21:33.904]             seq.int <- base::seq.int
[13:21:33.904]             signalCondition <- base::signalCondition
[13:21:33.904]             sys.calls <- base::sys.calls
[13:21:33.904]             `[[` <- base::`[[`
[13:21:33.904]             `+` <- base::`+`
[13:21:33.904]             `<<-` <- base::`<<-`
[13:21:33.904]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:33.904]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:33.904]                   3L)]
[13:21:33.904]             }
[13:21:33.904]             function(cond) {
[13:21:33.904]                 is_error <- inherits(cond, "error")
[13:21:33.904]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:33.904]                   NULL)
[13:21:33.904]                 if (is_error) {
[13:21:33.904]                   sessionInformation <- function() {
[13:21:33.904]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:33.904]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:33.904]                       search = base::search(), system = base::Sys.info())
[13:21:33.904]                   }
[13:21:33.904]                   ...future.conditions[[length(...future.conditions) + 
[13:21:33.904]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:33.904]                     cond$call), session = sessionInformation(), 
[13:21:33.904]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:33.904]                   signalCondition(cond)
[13:21:33.904]                 }
[13:21:33.904]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:33.904]                 "immediateCondition"))) {
[13:21:33.904]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:33.904]                   ...future.conditions[[length(...future.conditions) + 
[13:21:33.904]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:33.904]                   if (TRUE && !signal) {
[13:21:33.904]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.904]                     {
[13:21:33.904]                       inherits <- base::inherits
[13:21:33.904]                       invokeRestart <- base::invokeRestart
[13:21:33.904]                       is.null <- base::is.null
[13:21:33.904]                       muffled <- FALSE
[13:21:33.904]                       if (inherits(cond, "message")) {
[13:21:33.904]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:33.904]                         if (muffled) 
[13:21:33.904]                           invokeRestart("muffleMessage")
[13:21:33.904]                       }
[13:21:33.904]                       else if (inherits(cond, "warning")) {
[13:21:33.904]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:33.904]                         if (muffled) 
[13:21:33.904]                           invokeRestart("muffleWarning")
[13:21:33.904]                       }
[13:21:33.904]                       else if (inherits(cond, "condition")) {
[13:21:33.904]                         if (!is.null(pattern)) {
[13:21:33.904]                           computeRestarts <- base::computeRestarts
[13:21:33.904]                           grepl <- base::grepl
[13:21:33.904]                           restarts <- computeRestarts(cond)
[13:21:33.904]                           for (restart in restarts) {
[13:21:33.904]                             name <- restart$name
[13:21:33.904]                             if (is.null(name)) 
[13:21:33.904]                               next
[13:21:33.904]                             if (!grepl(pattern, name)) 
[13:21:33.904]                               next
[13:21:33.904]                             invokeRestart(restart)
[13:21:33.904]                             muffled <- TRUE
[13:21:33.904]                             break
[13:21:33.904]                           }
[13:21:33.904]                         }
[13:21:33.904]                       }
[13:21:33.904]                       invisible(muffled)
[13:21:33.904]                     }
[13:21:33.904]                     muffleCondition(cond, pattern = "^muffle")
[13:21:33.904]                   }
[13:21:33.904]                 }
[13:21:33.904]                 else {
[13:21:33.904]                   if (TRUE) {
[13:21:33.904]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.904]                     {
[13:21:33.904]                       inherits <- base::inherits
[13:21:33.904]                       invokeRestart <- base::invokeRestart
[13:21:33.904]                       is.null <- base::is.null
[13:21:33.904]                       muffled <- FALSE
[13:21:33.904]                       if (inherits(cond, "message")) {
[13:21:33.904]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:33.904]                         if (muffled) 
[13:21:33.904]                           invokeRestart("muffleMessage")
[13:21:33.904]                       }
[13:21:33.904]                       else if (inherits(cond, "warning")) {
[13:21:33.904]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:33.904]                         if (muffled) 
[13:21:33.904]                           invokeRestart("muffleWarning")
[13:21:33.904]                       }
[13:21:33.904]                       else if (inherits(cond, "condition")) {
[13:21:33.904]                         if (!is.null(pattern)) {
[13:21:33.904]                           computeRestarts <- base::computeRestarts
[13:21:33.904]                           grepl <- base::grepl
[13:21:33.904]                           restarts <- computeRestarts(cond)
[13:21:33.904]                           for (restart in restarts) {
[13:21:33.904]                             name <- restart$name
[13:21:33.904]                             if (is.null(name)) 
[13:21:33.904]                               next
[13:21:33.904]                             if (!grepl(pattern, name)) 
[13:21:33.904]                               next
[13:21:33.904]                             invokeRestart(restart)
[13:21:33.904]                             muffled <- TRUE
[13:21:33.904]                             break
[13:21:33.904]                           }
[13:21:33.904]                         }
[13:21:33.904]                       }
[13:21:33.904]                       invisible(muffled)
[13:21:33.904]                     }
[13:21:33.904]                     muffleCondition(cond, pattern = "^muffle")
[13:21:33.904]                   }
[13:21:33.904]                 }
[13:21:33.904]             }
[13:21:33.904]         }))
[13:21:33.904]     }, error = function(ex) {
[13:21:33.904]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:33.904]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:33.904]                 ...future.rng), started = ...future.startTime, 
[13:21:33.904]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:33.904]             version = "1.8"), class = "FutureResult")
[13:21:33.904]     }, finally = {
[13:21:33.904]         if (!identical(...future.workdir, getwd())) 
[13:21:33.904]             setwd(...future.workdir)
[13:21:33.904]         {
[13:21:33.904]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:33.904]                 ...future.oldOptions$nwarnings <- NULL
[13:21:33.904]             }
[13:21:33.904]             base::options(...future.oldOptions)
[13:21:33.904]             if (.Platform$OS.type == "windows") {
[13:21:33.904]                 old_names <- names(...future.oldEnvVars)
[13:21:33.904]                 envs <- base::Sys.getenv()
[13:21:33.904]                 names <- names(envs)
[13:21:33.904]                 common <- intersect(names, old_names)
[13:21:33.904]                 added <- setdiff(names, old_names)
[13:21:33.904]                 removed <- setdiff(old_names, names)
[13:21:33.904]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:33.904]                   envs[common]]
[13:21:33.904]                 NAMES <- toupper(changed)
[13:21:33.904]                 args <- list()
[13:21:33.904]                 for (kk in seq_along(NAMES)) {
[13:21:33.904]                   name <- changed[[kk]]
[13:21:33.904]                   NAME <- NAMES[[kk]]
[13:21:33.904]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.904]                     next
[13:21:33.904]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:33.904]                 }
[13:21:33.904]                 NAMES <- toupper(added)
[13:21:33.904]                 for (kk in seq_along(NAMES)) {
[13:21:33.904]                   name <- added[[kk]]
[13:21:33.904]                   NAME <- NAMES[[kk]]
[13:21:33.904]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.904]                     next
[13:21:33.904]                   args[[name]] <- ""
[13:21:33.904]                 }
[13:21:33.904]                 NAMES <- toupper(removed)
[13:21:33.904]                 for (kk in seq_along(NAMES)) {
[13:21:33.904]                   name <- removed[[kk]]
[13:21:33.904]                   NAME <- NAMES[[kk]]
[13:21:33.904]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.904]                     next
[13:21:33.904]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:33.904]                 }
[13:21:33.904]                 if (length(args) > 0) 
[13:21:33.904]                   base::do.call(base::Sys.setenv, args = args)
[13:21:33.904]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:33.904]             }
[13:21:33.904]             else {
[13:21:33.904]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:33.904]             }
[13:21:33.904]             {
[13:21:33.904]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:33.904]                   0L) {
[13:21:33.904]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:33.904]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:33.904]                   base::options(opts)
[13:21:33.904]                 }
[13:21:33.904]                 {
[13:21:33.904]                   {
[13:21:33.904]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:33.904]                     NULL
[13:21:33.904]                   }
[13:21:33.904]                   options(future.plan = NULL)
[13:21:33.904]                   if (is.na(NA_character_)) 
[13:21:33.904]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:33.904]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:33.904]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:33.904]                     envir = parent.frame()) 
[13:21:33.904]                   {
[13:21:33.904]                     default_workers <- missing(workers)
[13:21:33.904]                     if (is.function(workers)) 
[13:21:33.904]                       workers <- workers()
[13:21:33.904]                     workers <- structure(as.integer(workers), 
[13:21:33.904]                       class = class(workers))
[13:21:33.904]                     stop_if_not(is.finite(workers), workers >= 
[13:21:33.904]                       1L)
[13:21:33.904]                     if ((workers == 1L && !inherits(workers, 
[13:21:33.904]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:33.904]                       if (default_workers) 
[13:21:33.904]                         supportsMulticore(warn = TRUE)
[13:21:33.904]                       return(sequential(..., envir = envir))
[13:21:33.904]                     }
[13:21:33.904]                     oopts <- options(mc.cores = workers)
[13:21:33.904]                     on.exit(options(oopts))
[13:21:33.904]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:33.904]                       envir = envir)
[13:21:33.904]                     if (!future$lazy) 
[13:21:33.904]                       future <- run(future)
[13:21:33.904]                     invisible(future)
[13:21:33.904]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:33.904]                 }
[13:21:33.904]             }
[13:21:33.904]         }
[13:21:33.904]     })
[13:21:33.904]     if (TRUE) {
[13:21:33.904]         base::sink(type = "output", split = FALSE)
[13:21:33.904]         if (TRUE) {
[13:21:33.904]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:33.904]         }
[13:21:33.904]         else {
[13:21:33.904]             ...future.result["stdout"] <- base::list(NULL)
[13:21:33.904]         }
[13:21:33.904]         base::close(...future.stdout)
[13:21:33.904]         ...future.stdout <- NULL
[13:21:33.904]     }
[13:21:33.904]     ...future.result$conditions <- ...future.conditions
[13:21:33.904]     ...future.result$finished <- base::Sys.time()
[13:21:33.904]     ...future.result
[13:21:33.904] }
[13:21:33.907] assign_globals() ...
[13:21:33.907] List of 11
[13:21:33.907]  $ ...future.FUN            :function (x, ...)  
[13:21:33.907]  $ x_FUN                    :function (x)  
[13:21:33.907]  $ times                    : int 2
[13:21:33.907]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:33.907]  $ stop_if_not              :function (...)  
[13:21:33.907]  $ dim                      : NULL
[13:21:33.907]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:21:33.907]  $ future.call.arguments    : list()
[13:21:33.907]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:33.907]  $ ...future.elements_ii    :List of 5
[13:21:33.907]   ..$ : int 1
[13:21:33.907]   ..$ : int 2
[13:21:33.907]   ..$ : int 3
[13:21:33.907]   ..$ : int 4
[13:21:33.907]   ..$ : int 5
[13:21:33.907]  $ ...future.seeds_ii       : NULL
[13:21:33.907]  $ ...future.globals.maxSize: NULL
[13:21:33.907]  - attr(*, "where")=List of 11
[13:21:33.907]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:33.907]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:33.907]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:33.907]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:33.907]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:33.907]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:33.907]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:33.907]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:33.907]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:33.907]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:33.907]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:33.907]  - attr(*, "resolved")= logi FALSE
[13:21:33.907]  - attr(*, "total_size")= num 96456
[13:21:33.907]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:33.907]  - attr(*, "already-done")= logi TRUE
[13:21:33.918] - copied ‘...future.FUN’ to environment
[13:21:33.919] - reassign environment for ‘x_FUN’
[13:21:33.919] - copied ‘x_FUN’ to environment
[13:21:33.919] - copied ‘times’ to environment
[13:21:33.919] - copied ‘stopf’ to environment
[13:21:33.919] - copied ‘stop_if_not’ to environment
[13:21:33.919] - copied ‘dim’ to environment
[13:21:33.919] - copied ‘valid_types’ to environment
[13:21:33.919] - copied ‘future.call.arguments’ to environment
[13:21:33.919] - copied ‘...future.elements_ii’ to environment
[13:21:33.919] - copied ‘...future.seeds_ii’ to environment
[13:21:33.920] - copied ‘...future.globals.maxSize’ to environment
[13:21:33.920] assign_globals() ... done
[13:21:33.920] requestCore(): workers = 2
[13:21:33.922] MulticoreFuture started
[13:21:33.923] - Launch lazy future ... done
[13:21:33.923] run() for ‘MulticoreFuture’ ... done
[13:21:33.923] Created future:
[13:21:33.924] plan(): Setting new future strategy stack:
[13:21:33.924] List of future strategies:
[13:21:33.924] 1. sequential:
[13:21:33.924]    - args: function (..., envir = parent.frame())
[13:21:33.924]    - tweaked: FALSE
[13:21:33.924]    - call: NULL
[13:21:33.925] plan(): nbrOfWorkers() = 1
[13:21:33.927] plan(): Setting new future strategy stack:
[13:21:33.927] List of future strategies:
[13:21:33.927] 1. multicore:
[13:21:33.927]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:33.927]    - tweaked: FALSE
[13:21:33.927]    - call: plan(strategy)
[13:21:33.932] plan(): nbrOfWorkers() = 2
[13:21:33.923] MulticoreFuture:
[13:21:33.923] Label: ‘future_vapply-1’
[13:21:33.923] Expression:
[13:21:33.923] {
[13:21:33.923]     do.call(function(...) {
[13:21:33.923]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.923]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:33.923]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.923]             on.exit(options(oopts), add = TRUE)
[13:21:33.923]         }
[13:21:33.923]         {
[13:21:33.923]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:33.923]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.923]                 ...future.FUN(...future.X_jj, ...)
[13:21:33.923]             })
[13:21:33.923]         }
[13:21:33.923]     }, args = future.call.arguments)
[13:21:33.923] }
[13:21:33.923] Lazy evaluation: FALSE
[13:21:33.923] Asynchronous evaluation: TRUE
[13:21:33.923] Local evaluation: TRUE
[13:21:33.923] Environment: R_GlobalEnv
[13:21:33.923] Capture standard output: TRUE
[13:21:33.923] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:33.923] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:33.923] Packages: 1 packages (‘future.apply’)
[13:21:33.923] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:33.923] Resolved: TRUE
[13:21:33.923] Value: <not collected>
[13:21:33.923] Conditions captured: <none>
[13:21:33.923] Early signaling: FALSE
[13:21:33.923] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:33.923] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:33.933] Chunk #1 of 2 ... DONE
[13:21:33.933] Chunk #2 of 2 ...
[13:21:33.934]  - Finding globals in 'X' for chunk #2 ...
[13:21:33.934] getGlobalsAndPackages() ...
[13:21:33.934] Searching for globals...
[13:21:33.934] 
[13:21:33.935] Searching for globals ... DONE
[13:21:33.935] - globals: [0] <none>
[13:21:33.935] getGlobalsAndPackages() ... DONE
[13:21:33.935]    + additional globals found: [n=0] 
[13:21:33.935]    + additional namespaces needed: [n=0] 
[13:21:33.935]  - Finding globals in 'X' for chunk #2 ... DONE
[13:21:33.935]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:33.936]  - seeds: <none>
[13:21:33.936]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.936] getGlobalsAndPackages() ...
[13:21:33.936] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.936] Resolving globals: FALSE
[13:21:33.937] Tweak future expression to call with '...' arguments ...
[13:21:33.937] {
[13:21:33.937]     do.call(function(...) {
[13:21:33.937]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.937]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:33.937]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.937]             on.exit(options(oopts), add = TRUE)
[13:21:33.937]         }
[13:21:33.937]         {
[13:21:33.937]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:33.937]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.937]                 ...future.FUN(...future.X_jj, ...)
[13:21:33.937]             })
[13:21:33.937]         }
[13:21:33.937]     }, args = future.call.arguments)
[13:21:33.937] }
[13:21:33.937] Tweak future expression to call with '...' arguments ... DONE
[13:21:33.938] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:33.938] - packages: [1] ‘future.apply’
[13:21:33.938] getGlobalsAndPackages() ... DONE
[13:21:33.939] run() for ‘Future’ ...
[13:21:33.939] - state: ‘created’
[13:21:33.939] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:33.944] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:33.944] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:33.944]   - Field: ‘label’
[13:21:33.945]   - Field: ‘local’
[13:21:33.945]   - Field: ‘owner’
[13:21:33.945]   - Field: ‘envir’
[13:21:33.945]   - Field: ‘workers’
[13:21:33.945]   - Field: ‘packages’
[13:21:33.945]   - Field: ‘gc’
[13:21:33.945]   - Field: ‘job’
[13:21:33.946]   - Field: ‘conditions’
[13:21:33.946]   - Field: ‘expr’
[13:21:33.946]   - Field: ‘uuid’
[13:21:33.946]   - Field: ‘seed’
[13:21:33.946]   - Field: ‘version’
[13:21:33.946]   - Field: ‘result’
[13:21:33.946]   - Field: ‘asynchronous’
[13:21:33.947]   - Field: ‘calls’
[13:21:33.947]   - Field: ‘globals’
[13:21:33.947]   - Field: ‘stdout’
[13:21:33.947]   - Field: ‘earlySignal’
[13:21:33.947]   - Field: ‘lazy’
[13:21:33.947]   - Field: ‘state’
[13:21:33.947] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:33.950] - Launch lazy future ...
[13:21:33.951] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:33.951] Packages needed by future strategies (n = 0): <none>
[13:21:33.953] {
[13:21:33.953]     {
[13:21:33.953]         {
[13:21:33.953]             ...future.startTime <- base::Sys.time()
[13:21:33.953]             {
[13:21:33.953]                 {
[13:21:33.953]                   {
[13:21:33.953]                     {
[13:21:33.953]                       {
[13:21:33.953]                         base::local({
[13:21:33.953]                           has_future <- base::requireNamespace("future", 
[13:21:33.953]                             quietly = TRUE)
[13:21:33.953]                           if (has_future) {
[13:21:33.953]                             ns <- base::getNamespace("future")
[13:21:33.953]                             version <- ns[[".package"]][["version"]]
[13:21:33.953]                             if (is.null(version)) 
[13:21:33.953]                               version <- utils::packageVersion("future")
[13:21:33.953]                           }
[13:21:33.953]                           else {
[13:21:33.953]                             version <- NULL
[13:21:33.953]                           }
[13:21:33.953]                           if (!has_future || version < "1.8.0") {
[13:21:33.953]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:33.953]                               "", base::R.version$version.string), 
[13:21:33.953]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:33.953]                                 base::R.version$platform, 8 * 
[13:21:33.953]                                   base::.Machine$sizeof.pointer), 
[13:21:33.953]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:33.953]                                 "release", "version")], collapse = " "), 
[13:21:33.953]                               hostname = base::Sys.info()[["nodename"]])
[13:21:33.953]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:33.953]                               info)
[13:21:33.953]                             info <- base::paste(info, collapse = "; ")
[13:21:33.953]                             if (!has_future) {
[13:21:33.953]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:33.953]                                 info)
[13:21:33.953]                             }
[13:21:33.953]                             else {
[13:21:33.953]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:33.953]                                 info, version)
[13:21:33.953]                             }
[13:21:33.953]                             base::stop(msg)
[13:21:33.953]                           }
[13:21:33.953]                         })
[13:21:33.953]                       }
[13:21:33.953]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:33.953]                       base::options(mc.cores = 1L)
[13:21:33.953]                     }
[13:21:33.953]                     base::local({
[13:21:33.953]                       for (pkg in "future.apply") {
[13:21:33.953]                         base::loadNamespace(pkg)
[13:21:33.953]                         base::library(pkg, character.only = TRUE)
[13:21:33.953]                       }
[13:21:33.953]                     })
[13:21:33.953]                   }
[13:21:33.953]                   options(future.plan = NULL)
[13:21:33.953]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:33.953]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:33.953]                 }
[13:21:33.953]                 ...future.workdir <- getwd()
[13:21:33.953]             }
[13:21:33.953]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:33.953]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:33.953]         }
[13:21:33.953]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:33.953]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:33.953]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:33.953]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:33.953]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:33.953]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:33.953]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:33.953]             base::names(...future.oldOptions))
[13:21:33.953]     }
[13:21:33.953]     if (FALSE) {
[13:21:33.953]     }
[13:21:33.953]     else {
[13:21:33.953]         if (TRUE) {
[13:21:33.953]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:33.953]                 open = "w")
[13:21:33.953]         }
[13:21:33.953]         else {
[13:21:33.953]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:33.953]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:33.953]         }
[13:21:33.953]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:33.953]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:33.953]             base::sink(type = "output", split = FALSE)
[13:21:33.953]             base::close(...future.stdout)
[13:21:33.953]         }, add = TRUE)
[13:21:33.953]     }
[13:21:33.953]     ...future.frame <- base::sys.nframe()
[13:21:33.953]     ...future.conditions <- base::list()
[13:21:33.953]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:33.953]     if (FALSE) {
[13:21:33.953]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:33.953]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:33.953]     }
[13:21:33.953]     ...future.result <- base::tryCatch({
[13:21:33.953]         base::withCallingHandlers({
[13:21:33.953]             ...future.value <- base::withVisible(base::local({
[13:21:33.953]                 withCallingHandlers({
[13:21:33.953]                   {
[13:21:33.953]                     do.call(function(...) {
[13:21:33.953]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.953]                       if (!identical(...future.globals.maxSize.org, 
[13:21:33.953]                         ...future.globals.maxSize)) {
[13:21:33.953]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.953]                         on.exit(options(oopts), add = TRUE)
[13:21:33.953]                       }
[13:21:33.953]                       {
[13:21:33.953]                         lapply(seq_along(...future.elements_ii), 
[13:21:33.953]                           FUN = function(jj) {
[13:21:33.953]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.953]                             ...future.FUN(...future.X_jj, ...)
[13:21:33.953]                           })
[13:21:33.953]                       }
[13:21:33.953]                     }, args = future.call.arguments)
[13:21:33.953]                   }
[13:21:33.953]                 }, immediateCondition = function(cond) {
[13:21:33.953]                   save_rds <- function (object, pathname, ...) 
[13:21:33.953]                   {
[13:21:33.953]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:33.953]                     if (file_test("-f", pathname_tmp)) {
[13:21:33.953]                       fi_tmp <- file.info(pathname_tmp)
[13:21:33.953]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:33.953]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:33.953]                         fi_tmp[["mtime"]])
[13:21:33.953]                     }
[13:21:33.953]                     tryCatch({
[13:21:33.953]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:33.953]                     }, error = function(ex) {
[13:21:33.953]                       msg <- conditionMessage(ex)
[13:21:33.953]                       fi_tmp <- file.info(pathname_tmp)
[13:21:33.953]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:33.953]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:33.953]                         fi_tmp[["mtime"]], msg)
[13:21:33.953]                       ex$message <- msg
[13:21:33.953]                       stop(ex)
[13:21:33.953]                     })
[13:21:33.953]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:33.953]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:33.953]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:33.953]                       fi_tmp <- file.info(pathname_tmp)
[13:21:33.953]                       fi <- file.info(pathname)
[13:21:33.953]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:33.953]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:33.953]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:33.953]                         fi[["size"]], fi[["mtime"]])
[13:21:33.953]                       stop(msg)
[13:21:33.953]                     }
[13:21:33.953]                     invisible(pathname)
[13:21:33.953]                   }
[13:21:33.953]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:33.953]                     rootPath = tempdir()) 
[13:21:33.953]                   {
[13:21:33.953]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:33.953]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:33.953]                       tmpdir = path, fileext = ".rds")
[13:21:33.953]                     save_rds(obj, file)
[13:21:33.953]                   }
[13:21:33.953]                   saveImmediateCondition(cond, path = "/tmp/RtmpbpFWGO/.future/immediateConditions")
[13:21:33.953]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.953]                   {
[13:21:33.953]                     inherits <- base::inherits
[13:21:33.953]                     invokeRestart <- base::invokeRestart
[13:21:33.953]                     is.null <- base::is.null
[13:21:33.953]                     muffled <- FALSE
[13:21:33.953]                     if (inherits(cond, "message")) {
[13:21:33.953]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:33.953]                       if (muffled) 
[13:21:33.953]                         invokeRestart("muffleMessage")
[13:21:33.953]                     }
[13:21:33.953]                     else if (inherits(cond, "warning")) {
[13:21:33.953]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:33.953]                       if (muffled) 
[13:21:33.953]                         invokeRestart("muffleWarning")
[13:21:33.953]                     }
[13:21:33.953]                     else if (inherits(cond, "condition")) {
[13:21:33.953]                       if (!is.null(pattern)) {
[13:21:33.953]                         computeRestarts <- base::computeRestarts
[13:21:33.953]                         grepl <- base::grepl
[13:21:33.953]                         restarts <- computeRestarts(cond)
[13:21:33.953]                         for (restart in restarts) {
[13:21:33.953]                           name <- restart$name
[13:21:33.953]                           if (is.null(name)) 
[13:21:33.953]                             next
[13:21:33.953]                           if (!grepl(pattern, name)) 
[13:21:33.953]                             next
[13:21:33.953]                           invokeRestart(restart)
[13:21:33.953]                           muffled <- TRUE
[13:21:33.953]                           break
[13:21:33.953]                         }
[13:21:33.953]                       }
[13:21:33.953]                     }
[13:21:33.953]                     invisible(muffled)
[13:21:33.953]                   }
[13:21:33.953]                   muffleCondition(cond)
[13:21:33.953]                 })
[13:21:33.953]             }))
[13:21:33.953]             future::FutureResult(value = ...future.value$value, 
[13:21:33.953]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:33.953]                   ...future.rng), globalenv = if (FALSE) 
[13:21:33.953]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:33.953]                     ...future.globalenv.names))
[13:21:33.953]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:33.953]         }, condition = base::local({
[13:21:33.953]             c <- base::c
[13:21:33.953]             inherits <- base::inherits
[13:21:33.953]             invokeRestart <- base::invokeRestart
[13:21:33.953]             length <- base::length
[13:21:33.953]             list <- base::list
[13:21:33.953]             seq.int <- base::seq.int
[13:21:33.953]             signalCondition <- base::signalCondition
[13:21:33.953]             sys.calls <- base::sys.calls
[13:21:33.953]             `[[` <- base::`[[`
[13:21:33.953]             `+` <- base::`+`
[13:21:33.953]             `<<-` <- base::`<<-`
[13:21:33.953]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:33.953]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:33.953]                   3L)]
[13:21:33.953]             }
[13:21:33.953]             function(cond) {
[13:21:33.953]                 is_error <- inherits(cond, "error")
[13:21:33.953]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:33.953]                   NULL)
[13:21:33.953]                 if (is_error) {
[13:21:33.953]                   sessionInformation <- function() {
[13:21:33.953]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:33.953]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:33.953]                       search = base::search(), system = base::Sys.info())
[13:21:33.953]                   }
[13:21:33.953]                   ...future.conditions[[length(...future.conditions) + 
[13:21:33.953]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:33.953]                     cond$call), session = sessionInformation(), 
[13:21:33.953]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:33.953]                   signalCondition(cond)
[13:21:33.953]                 }
[13:21:33.953]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:33.953]                 "immediateCondition"))) {
[13:21:33.953]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:33.953]                   ...future.conditions[[length(...future.conditions) + 
[13:21:33.953]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:33.953]                   if (TRUE && !signal) {
[13:21:33.953]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.953]                     {
[13:21:33.953]                       inherits <- base::inherits
[13:21:33.953]                       invokeRestart <- base::invokeRestart
[13:21:33.953]                       is.null <- base::is.null
[13:21:33.953]                       muffled <- FALSE
[13:21:33.953]                       if (inherits(cond, "message")) {
[13:21:33.953]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:33.953]                         if (muffled) 
[13:21:33.953]                           invokeRestart("muffleMessage")
[13:21:33.953]                       }
[13:21:33.953]                       else if (inherits(cond, "warning")) {
[13:21:33.953]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:33.953]                         if (muffled) 
[13:21:33.953]                           invokeRestart("muffleWarning")
[13:21:33.953]                       }
[13:21:33.953]                       else if (inherits(cond, "condition")) {
[13:21:33.953]                         if (!is.null(pattern)) {
[13:21:33.953]                           computeRestarts <- base::computeRestarts
[13:21:33.953]                           grepl <- base::grepl
[13:21:33.953]                           restarts <- computeRestarts(cond)
[13:21:33.953]                           for (restart in restarts) {
[13:21:33.953]                             name <- restart$name
[13:21:33.953]                             if (is.null(name)) 
[13:21:33.953]                               next
[13:21:33.953]                             if (!grepl(pattern, name)) 
[13:21:33.953]                               next
[13:21:33.953]                             invokeRestart(restart)
[13:21:33.953]                             muffled <- TRUE
[13:21:33.953]                             break
[13:21:33.953]                           }
[13:21:33.953]                         }
[13:21:33.953]                       }
[13:21:33.953]                       invisible(muffled)
[13:21:33.953]                     }
[13:21:33.953]                     muffleCondition(cond, pattern = "^muffle")
[13:21:33.953]                   }
[13:21:33.953]                 }
[13:21:33.953]                 else {
[13:21:33.953]                   if (TRUE) {
[13:21:33.953]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:33.953]                     {
[13:21:33.953]                       inherits <- base::inherits
[13:21:33.953]                       invokeRestart <- base::invokeRestart
[13:21:33.953]                       is.null <- base::is.null
[13:21:33.953]                       muffled <- FALSE
[13:21:33.953]                       if (inherits(cond, "message")) {
[13:21:33.953]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:33.953]                         if (muffled) 
[13:21:33.953]                           invokeRestart("muffleMessage")
[13:21:33.953]                       }
[13:21:33.953]                       else if (inherits(cond, "warning")) {
[13:21:33.953]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:33.953]                         if (muffled) 
[13:21:33.953]                           invokeRestart("muffleWarning")
[13:21:33.953]                       }
[13:21:33.953]                       else if (inherits(cond, "condition")) {
[13:21:33.953]                         if (!is.null(pattern)) {
[13:21:33.953]                           computeRestarts <- base::computeRestarts
[13:21:33.953]                           grepl <- base::grepl
[13:21:33.953]                           restarts <- computeRestarts(cond)
[13:21:33.953]                           for (restart in restarts) {
[13:21:33.953]                             name <- restart$name
[13:21:33.953]                             if (is.null(name)) 
[13:21:33.953]                               next
[13:21:33.953]                             if (!grepl(pattern, name)) 
[13:21:33.953]                               next
[13:21:33.953]                             invokeRestart(restart)
[13:21:33.953]                             muffled <- TRUE
[13:21:33.953]                             break
[13:21:33.953]                           }
[13:21:33.953]                         }
[13:21:33.953]                       }
[13:21:33.953]                       invisible(muffled)
[13:21:33.953]                     }
[13:21:33.953]                     muffleCondition(cond, pattern = "^muffle")
[13:21:33.953]                   }
[13:21:33.953]                 }
[13:21:33.953]             }
[13:21:33.953]         }))
[13:21:33.953]     }, error = function(ex) {
[13:21:33.953]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:33.953]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:33.953]                 ...future.rng), started = ...future.startTime, 
[13:21:33.953]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:33.953]             version = "1.8"), class = "FutureResult")
[13:21:33.953]     }, finally = {
[13:21:33.953]         if (!identical(...future.workdir, getwd())) 
[13:21:33.953]             setwd(...future.workdir)
[13:21:33.953]         {
[13:21:33.953]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:33.953]                 ...future.oldOptions$nwarnings <- NULL
[13:21:33.953]             }
[13:21:33.953]             base::options(...future.oldOptions)
[13:21:33.953]             if (.Platform$OS.type == "windows") {
[13:21:33.953]                 old_names <- names(...future.oldEnvVars)
[13:21:33.953]                 envs <- base::Sys.getenv()
[13:21:33.953]                 names <- names(envs)
[13:21:33.953]                 common <- intersect(names, old_names)
[13:21:33.953]                 added <- setdiff(names, old_names)
[13:21:33.953]                 removed <- setdiff(old_names, names)
[13:21:33.953]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:33.953]                   envs[common]]
[13:21:33.953]                 NAMES <- toupper(changed)
[13:21:33.953]                 args <- list()
[13:21:33.953]                 for (kk in seq_along(NAMES)) {
[13:21:33.953]                   name <- changed[[kk]]
[13:21:33.953]                   NAME <- NAMES[[kk]]
[13:21:33.953]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.953]                     next
[13:21:33.953]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:33.953]                 }
[13:21:33.953]                 NAMES <- toupper(added)
[13:21:33.953]                 for (kk in seq_along(NAMES)) {
[13:21:33.953]                   name <- added[[kk]]
[13:21:33.953]                   NAME <- NAMES[[kk]]
[13:21:33.953]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.953]                     next
[13:21:33.953]                   args[[name]] <- ""
[13:21:33.953]                 }
[13:21:33.953]                 NAMES <- toupper(removed)
[13:21:33.953]                 for (kk in seq_along(NAMES)) {
[13:21:33.953]                   name <- removed[[kk]]
[13:21:33.953]                   NAME <- NAMES[[kk]]
[13:21:33.953]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:33.953]                     next
[13:21:33.953]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:33.953]                 }
[13:21:33.953]                 if (length(args) > 0) 
[13:21:33.953]                   base::do.call(base::Sys.setenv, args = args)
[13:21:33.953]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:33.953]             }
[13:21:33.953]             else {
[13:21:33.953]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:33.953]             }
[13:21:33.953]             {
[13:21:33.953]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:33.953]                   0L) {
[13:21:33.953]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:33.953]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:33.953]                   base::options(opts)
[13:21:33.953]                 }
[13:21:33.953]                 {
[13:21:33.953]                   {
[13:21:33.953]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:33.953]                     NULL
[13:21:33.953]                   }
[13:21:33.953]                   options(future.plan = NULL)
[13:21:33.953]                   if (is.na(NA_character_)) 
[13:21:33.953]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:33.953]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:33.953]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:33.953]                     envir = parent.frame()) 
[13:21:33.953]                   {
[13:21:33.953]                     default_workers <- missing(workers)
[13:21:33.953]                     if (is.function(workers)) 
[13:21:33.953]                       workers <- workers()
[13:21:33.953]                     workers <- structure(as.integer(workers), 
[13:21:33.953]                       class = class(workers))
[13:21:33.953]                     stop_if_not(is.finite(workers), workers >= 
[13:21:33.953]                       1L)
[13:21:33.953]                     if ((workers == 1L && !inherits(workers, 
[13:21:33.953]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:33.953]                       if (default_workers) 
[13:21:33.953]                         supportsMulticore(warn = TRUE)
[13:21:33.953]                       return(sequential(..., envir = envir))
[13:21:33.953]                     }
[13:21:33.953]                     oopts <- options(mc.cores = workers)
[13:21:33.953]                     on.exit(options(oopts))
[13:21:33.953]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:33.953]                       envir = envir)
[13:21:33.953]                     if (!future$lazy) 
[13:21:33.953]                       future <- run(future)
[13:21:33.953]                     invisible(future)
[13:21:33.953]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:33.953]                 }
[13:21:33.953]             }
[13:21:33.953]         }
[13:21:33.953]     })
[13:21:33.953]     if (TRUE) {
[13:21:33.953]         base::sink(type = "output", split = FALSE)
[13:21:33.953]         if (TRUE) {
[13:21:33.953]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:33.953]         }
[13:21:33.953]         else {
[13:21:33.953]             ...future.result["stdout"] <- base::list(NULL)
[13:21:33.953]         }
[13:21:33.953]         base::close(...future.stdout)
[13:21:33.953]         ...future.stdout <- NULL
[13:21:33.953]     }
[13:21:33.953]     ...future.result$conditions <- ...future.conditions
[13:21:33.953]     ...future.result$finished <- base::Sys.time()
[13:21:33.953]     ...future.result
[13:21:33.953] }
[13:21:33.957] assign_globals() ...
[13:21:33.957] List of 11
[13:21:33.957]  $ ...future.FUN            :function (x, ...)  
[13:21:33.957]  $ x_FUN                    :function (x)  
[13:21:33.957]  $ times                    : int 2
[13:21:33.957]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:33.957]  $ stop_if_not              :function (...)  
[13:21:33.957]  $ dim                      : NULL
[13:21:33.957]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:21:33.957]  $ future.call.arguments    : list()
[13:21:33.957]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:33.957]  $ ...future.elements_ii    :List of 5
[13:21:33.957]   ..$ : int 6
[13:21:33.957]   ..$ : int 7
[13:21:33.957]   ..$ : int 8
[13:21:33.957]   ..$ : int 9
[13:21:33.957]   ..$ : int 10
[13:21:33.957]  $ ...future.seeds_ii       : NULL
[13:21:33.957]  $ ...future.globals.maxSize: NULL
[13:21:33.957]  - attr(*, "where")=List of 11
[13:21:33.957]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:33.957]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:33.957]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:33.957]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:33.957]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:33.957]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:33.957]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:33.957]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:33.957]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:33.957]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:33.957]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:33.957]  - attr(*, "resolved")= logi FALSE
[13:21:33.957]  - attr(*, "total_size")= num 96456
[13:21:33.957]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:33.957]  - attr(*, "already-done")= logi TRUE
[13:21:33.971] - copied ‘...future.FUN’ to environment
[13:21:33.971] - reassign environment for ‘x_FUN’
[13:21:33.971] - copied ‘x_FUN’ to environment
[13:21:33.972] - copied ‘times’ to environment
[13:21:33.972] - copied ‘stopf’ to environment
[13:21:33.972] - copied ‘stop_if_not’ to environment
[13:21:33.972] - copied ‘dim’ to environment
[13:21:33.972] - copied ‘valid_types’ to environment
[13:21:33.972] - copied ‘future.call.arguments’ to environment
[13:21:33.972] - copied ‘...future.elements_ii’ to environment
[13:21:33.972] - copied ‘...future.seeds_ii’ to environment
[13:21:33.972] - copied ‘...future.globals.maxSize’ to environment
[13:21:33.972] assign_globals() ... done
[13:21:33.973] requestCore(): workers = 2
[13:21:33.975] MulticoreFuture started
[13:21:33.975] - Launch lazy future ... done
[13:21:33.976] run() for ‘MulticoreFuture’ ... done
[13:21:33.976] Created future:
[13:21:33.977] plan(): Setting new future strategy stack:
[13:21:33.977] List of future strategies:
[13:21:33.977] 1. sequential:
[13:21:33.977]    - args: function (..., envir = parent.frame())
[13:21:33.977]    - tweaked: FALSE
[13:21:33.977]    - call: NULL
[13:21:33.978] plan(): nbrOfWorkers() = 1
[13:21:33.980] plan(): Setting new future strategy stack:
[13:21:33.980] List of future strategies:
[13:21:33.980] 1. multicore:
[13:21:33.980]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:33.980]    - tweaked: FALSE
[13:21:33.980]    - call: plan(strategy)
[13:21:33.986] plan(): nbrOfWorkers() = 2
[13:21:33.976] MulticoreFuture:
[13:21:33.976] Label: ‘future_vapply-2’
[13:21:33.976] Expression:
[13:21:33.976] {
[13:21:33.976]     do.call(function(...) {
[13:21:33.976]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:33.976]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:33.976]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:33.976]             on.exit(options(oopts), add = TRUE)
[13:21:33.976]         }
[13:21:33.976]         {
[13:21:33.976]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:33.976]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:33.976]                 ...future.FUN(...future.X_jj, ...)
[13:21:33.976]             })
[13:21:33.976]         }
[13:21:33.976]     }, args = future.call.arguments)
[13:21:33.976] }
[13:21:33.976] Lazy evaluation: FALSE
[13:21:33.976] Asynchronous evaluation: TRUE
[13:21:33.976] Local evaluation: TRUE
[13:21:33.976] Environment: R_GlobalEnv
[13:21:33.976] Capture standard output: TRUE
[13:21:33.976] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:33.976] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:33.976] Packages: 1 packages (‘future.apply’)
[13:21:33.976] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:33.976] Resolved: TRUE
[13:21:33.976] Value: <not collected>
[13:21:33.976] Conditions captured: <none>
[13:21:33.976] Early signaling: FALSE
[13:21:33.976] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:33.976] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:33.987] Chunk #2 of 2 ... DONE
[13:21:33.987] Launching 2 futures (chunks) ... DONE
[13:21:33.987] Resolving 2 futures (chunks) ...
[13:21:33.987] resolve() on list ...
[13:21:33.987]  recursive: 0
[13:21:33.988]  length: 2
[13:21:33.988] 
[13:21:33.988] Future #1
[13:21:33.988] result() for MulticoreFuture ...
[13:21:33.989] result() for MulticoreFuture ...
[13:21:33.989] result() for MulticoreFuture ... done
[13:21:33.989] result() for MulticoreFuture ... done
[13:21:33.990] result() for MulticoreFuture ...
[13:21:33.990] result() for MulticoreFuture ... done
[13:21:33.990] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:21:33.990] - nx: 2
[13:21:33.990] - relay: TRUE
[13:21:33.990] - stdout: TRUE
[13:21:33.990] - signal: TRUE
[13:21:33.990] - resignal: FALSE
[13:21:33.991] - force: TRUE
[13:21:33.991] - relayed: [n=2] FALSE, FALSE
[13:21:33.991] - queued futures: [n=2] FALSE, FALSE
[13:21:33.991]  - until=1
[13:21:33.991]  - relaying element #1
[13:21:33.991] result() for MulticoreFuture ...
[13:21:33.991] result() for MulticoreFuture ... done
[13:21:33.992] result() for MulticoreFuture ...
[13:21:33.992] result() for MulticoreFuture ... done
[13:21:33.992] result() for MulticoreFuture ...
[13:21:33.992] result() for MulticoreFuture ... done
[13:21:33.992] result() for MulticoreFuture ...
[13:21:33.993] result() for MulticoreFuture ... done
[13:21:33.993] - relayed: [n=2] TRUE, FALSE
[13:21:33.993] - queued futures: [n=2] TRUE, FALSE
[13:21:33.993] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:21:33.993]  length: 1 (resolved future 1)
[13:21:33.993] Future #2
[13:21:33.994] result() for MulticoreFuture ...
[13:21:33.998] result() for MulticoreFuture ...
[13:21:33.999] result() for MulticoreFuture ... done
[13:21:33.999] result() for MulticoreFuture ... done
[13:21:33.999] result() for MulticoreFuture ...
[13:21:34.000] result() for MulticoreFuture ... done
[13:21:34.000] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:21:34.000] - nx: 2
[13:21:34.000] - relay: TRUE
[13:21:34.001] - stdout: TRUE
[13:21:34.001] - signal: TRUE
[13:21:34.001] - resignal: FALSE
[13:21:34.001] - force: TRUE
[13:21:34.001] - relayed: [n=2] TRUE, FALSE
[13:21:34.001] - queued futures: [n=2] TRUE, FALSE
[13:21:34.002]  - until=2
[13:21:34.002]  - relaying element #2
[13:21:34.002] result() for MulticoreFuture ...
[13:21:34.002] result() for MulticoreFuture ... done
[13:21:34.002] result() for MulticoreFuture ...
[13:21:34.002] result() for MulticoreFuture ... done
[13:21:34.003] result() for MulticoreFuture ...
[13:21:34.003] result() for MulticoreFuture ... done
[13:21:34.003] result() for MulticoreFuture ...
[13:21:34.003] result() for MulticoreFuture ... done
[13:21:34.003] - relayed: [n=2] TRUE, TRUE
[13:21:34.003] - queued futures: [n=2] TRUE, TRUE
[13:21:34.004] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:21:34.004]  length: 0 (resolved future 2)
[13:21:34.004] Relaying remaining futures
[13:21:34.004] signalConditionsASAP(NULL, pos=0) ...
[13:21:34.004] - nx: 2
[13:21:34.004] - relay: TRUE
[13:21:34.004] - stdout: TRUE
[13:21:34.005] - signal: TRUE
[13:21:34.005] - resignal: FALSE
[13:21:34.005] - force: TRUE
[13:21:34.005] - relayed: [n=2] TRUE, TRUE
[13:21:34.005] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:21:34.005] - relayed: [n=2] TRUE, TRUE
[13:21:34.005] - queued futures: [n=2] TRUE, TRUE
[13:21:34.005] signalConditionsASAP(NULL, pos=0) ... done
[13:21:34.005] resolve() on list ... DONE
[13:21:34.006] result() for MulticoreFuture ...
[13:21:34.006] result() for MulticoreFuture ... done
[13:21:34.006] result() for MulticoreFuture ...
[13:21:34.006] result() for MulticoreFuture ... done
[13:21:34.006] result() for MulticoreFuture ...
[13:21:34.006] result() for MulticoreFuture ... done
[13:21:34.006] result() for MulticoreFuture ...
[13:21:34.007] result() for MulticoreFuture ... done
[13:21:34.007]  - Number of value chunks collected: 2
[13:21:34.007] Resolving 2 futures (chunks) ... DONE
[13:21:34.007] Reducing values from 2 chunks ...
[13:21:34.007]  - Number of values collected after concatenation: 10
[13:21:34.007]  - Number of values expected: 10
[13:21:34.007] Reducing values from 2 chunks ... DONE
[13:21:34.007] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[13:21:34.009] future_lapply() ...
[13:21:34.015] Number of chunks: 2
[13:21:34.015] getGlobalsAndPackagesXApply() ...
[13:21:34.015]  - future.globals: TRUE
[13:21:34.015] getGlobalsAndPackages() ...
[13:21:34.015] Searching for globals...
[13:21:34.019] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[13:21:34.019] Searching for globals ... DONE
[13:21:34.019] Resolving globals: FALSE
[13:21:34.020] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[13:21:34.021] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:34.021] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:34.021] - packages: [1] ‘future.apply’
[13:21:34.021] getGlobalsAndPackages() ... DONE
[13:21:34.021]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:34.021]  - needed namespaces: [n=1] ‘future.apply’
[13:21:34.022] Finding globals ... DONE
[13:21:34.022]  - use_args: TRUE
[13:21:34.022]  - Getting '...' globals ...
[13:21:34.022] resolve() on list ...
[13:21:34.022]  recursive: 0
[13:21:34.022]  length: 1
[13:21:34.022]  elements: ‘...’
[13:21:34.023]  length: 0 (resolved future 1)
[13:21:34.023] resolve() on list ... DONE
[13:21:34.023]    - '...' content: [n=0] 
[13:21:34.023] List of 1
[13:21:34.023]  $ ...: list()
[13:21:34.023]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:34.023]  - attr(*, "where")=List of 1
[13:21:34.023]   ..$ ...:<environment: 0x563b6d5a1cd0> 
[13:21:34.023]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:34.023]  - attr(*, "resolved")= logi TRUE
[13:21:34.023]  - attr(*, "total_size")= num NA
[13:21:34.028]  - Getting '...' globals ... DONE
[13:21:34.028] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:34.028] List of 8
[13:21:34.028]  $ ...future.FUN:function (x, ...)  
[13:21:34.028]  $ x_FUN        :function (x)  
[13:21:34.028]  $ times        : int 4
[13:21:34.028]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:34.028]  $ stop_if_not  :function (...)  
[13:21:34.028]  $ dim          : int [1:2] 2 2
[13:21:34.028]  $ valid_types  : chr [1:2] "logical" "integer"
[13:21:34.028]  $ ...          : list()
[13:21:34.028]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:34.028]  - attr(*, "where")=List of 8
[13:21:34.028]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:34.028]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:34.028]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:34.028]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:34.028]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:34.028]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:34.028]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:34.028]   ..$ ...          :<environment: 0x563b6d5a1cd0> 
[13:21:34.028]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:34.028]  - attr(*, "resolved")= logi FALSE
[13:21:34.028]  - attr(*, "total_size")= num 97232
[13:21:34.034] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:21:34.035] getGlobalsAndPackagesXApply() ... DONE
[13:21:34.035] Number of futures (= number of chunks): 2
[13:21:34.035] Launching 2 futures (chunks) ...
[13:21:34.035] Chunk #1 of 2 ...
[13:21:34.035]  - Finding globals in 'X' for chunk #1 ...
[13:21:34.035] getGlobalsAndPackages() ...
[13:21:34.035] Searching for globals...
[13:21:34.036] 
[13:21:34.036] Searching for globals ... DONE
[13:21:34.036] - globals: [0] <none>
[13:21:34.036] getGlobalsAndPackages() ... DONE
[13:21:34.036]    + additional globals found: [n=0] 
[13:21:34.036]    + additional namespaces needed: [n=0] 
[13:21:34.036]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:34.036]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:34.036]  - seeds: <none>
[13:21:34.036]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.037] getGlobalsAndPackages() ...
[13:21:34.037] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.037] Resolving globals: FALSE
[13:21:34.037] Tweak future expression to call with '...' arguments ...
[13:21:34.037] {
[13:21:34.037]     do.call(function(...) {
[13:21:34.037]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.037]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:34.037]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.037]             on.exit(options(oopts), add = TRUE)
[13:21:34.037]         }
[13:21:34.037]         {
[13:21:34.037]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:34.037]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.037]                 ...future.FUN(...future.X_jj, ...)
[13:21:34.037]             })
[13:21:34.037]         }
[13:21:34.037]     }, args = future.call.arguments)
[13:21:34.037] }
[13:21:34.037] Tweak future expression to call with '...' arguments ... DONE
[13:21:34.038] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.038] - packages: [1] ‘future.apply’
[13:21:34.038] getGlobalsAndPackages() ... DONE
[13:21:34.038] run() for ‘Future’ ...
[13:21:34.038] - state: ‘created’
[13:21:34.039] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:34.043] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:34.043] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:34.043]   - Field: ‘label’
[13:21:34.043]   - Field: ‘local’
[13:21:34.043]   - Field: ‘owner’
[13:21:34.043]   - Field: ‘envir’
[13:21:34.043]   - Field: ‘workers’
[13:21:34.043]   - Field: ‘packages’
[13:21:34.043]   - Field: ‘gc’
[13:21:34.044]   - Field: ‘job’
[13:21:34.044]   - Field: ‘conditions’
[13:21:34.044]   - Field: ‘expr’
[13:21:34.044]   - Field: ‘uuid’
[13:21:34.044]   - Field: ‘seed’
[13:21:34.044]   - Field: ‘version’
[13:21:34.044]   - Field: ‘result’
[13:21:34.044]   - Field: ‘asynchronous’
[13:21:34.044]   - Field: ‘calls’
[13:21:34.044]   - Field: ‘globals’
[13:21:34.045]   - Field: ‘stdout’
[13:21:34.045]   - Field: ‘earlySignal’
[13:21:34.045]   - Field: ‘lazy’
[13:21:34.045]   - Field: ‘state’
[13:21:34.045] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:34.045] - Launch lazy future ...
[13:21:34.045] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:34.045] Packages needed by future strategies (n = 0): <none>
[13:21:34.046] {
[13:21:34.046]     {
[13:21:34.046]         {
[13:21:34.046]             ...future.startTime <- base::Sys.time()
[13:21:34.046]             {
[13:21:34.046]                 {
[13:21:34.046]                   {
[13:21:34.046]                     {
[13:21:34.046]                       {
[13:21:34.046]                         base::local({
[13:21:34.046]                           has_future <- base::requireNamespace("future", 
[13:21:34.046]                             quietly = TRUE)
[13:21:34.046]                           if (has_future) {
[13:21:34.046]                             ns <- base::getNamespace("future")
[13:21:34.046]                             version <- ns[[".package"]][["version"]]
[13:21:34.046]                             if (is.null(version)) 
[13:21:34.046]                               version <- utils::packageVersion("future")
[13:21:34.046]                           }
[13:21:34.046]                           else {
[13:21:34.046]                             version <- NULL
[13:21:34.046]                           }
[13:21:34.046]                           if (!has_future || version < "1.8.0") {
[13:21:34.046]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:34.046]                               "", base::R.version$version.string), 
[13:21:34.046]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:34.046]                                 base::R.version$platform, 8 * 
[13:21:34.046]                                   base::.Machine$sizeof.pointer), 
[13:21:34.046]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:34.046]                                 "release", "version")], collapse = " "), 
[13:21:34.046]                               hostname = base::Sys.info()[["nodename"]])
[13:21:34.046]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:34.046]                               info)
[13:21:34.046]                             info <- base::paste(info, collapse = "; ")
[13:21:34.046]                             if (!has_future) {
[13:21:34.046]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:34.046]                                 info)
[13:21:34.046]                             }
[13:21:34.046]                             else {
[13:21:34.046]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:34.046]                                 info, version)
[13:21:34.046]                             }
[13:21:34.046]                             base::stop(msg)
[13:21:34.046]                           }
[13:21:34.046]                         })
[13:21:34.046]                       }
[13:21:34.046]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:34.046]                       base::options(mc.cores = 1L)
[13:21:34.046]                     }
[13:21:34.046]                     base::local({
[13:21:34.046]                       for (pkg in "future.apply") {
[13:21:34.046]                         base::loadNamespace(pkg)
[13:21:34.046]                         base::library(pkg, character.only = TRUE)
[13:21:34.046]                       }
[13:21:34.046]                     })
[13:21:34.046]                   }
[13:21:34.046]                   options(future.plan = NULL)
[13:21:34.046]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:34.046]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:34.046]                 }
[13:21:34.046]                 ...future.workdir <- getwd()
[13:21:34.046]             }
[13:21:34.046]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:34.046]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:34.046]         }
[13:21:34.046]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:34.046]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:34.046]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:34.046]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:34.046]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:34.046]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:34.046]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:34.046]             base::names(...future.oldOptions))
[13:21:34.046]     }
[13:21:34.046]     if (FALSE) {
[13:21:34.046]     }
[13:21:34.046]     else {
[13:21:34.046]         if (TRUE) {
[13:21:34.046]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:34.046]                 open = "w")
[13:21:34.046]         }
[13:21:34.046]         else {
[13:21:34.046]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:34.046]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:34.046]         }
[13:21:34.046]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:34.046]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:34.046]             base::sink(type = "output", split = FALSE)
[13:21:34.046]             base::close(...future.stdout)
[13:21:34.046]         }, add = TRUE)
[13:21:34.046]     }
[13:21:34.046]     ...future.frame <- base::sys.nframe()
[13:21:34.046]     ...future.conditions <- base::list()
[13:21:34.046]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:34.046]     if (FALSE) {
[13:21:34.046]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:34.046]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:34.046]     }
[13:21:34.046]     ...future.result <- base::tryCatch({
[13:21:34.046]         base::withCallingHandlers({
[13:21:34.046]             ...future.value <- base::withVisible(base::local({
[13:21:34.046]                 withCallingHandlers({
[13:21:34.046]                   {
[13:21:34.046]                     do.call(function(...) {
[13:21:34.046]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.046]                       if (!identical(...future.globals.maxSize.org, 
[13:21:34.046]                         ...future.globals.maxSize)) {
[13:21:34.046]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.046]                         on.exit(options(oopts), add = TRUE)
[13:21:34.046]                       }
[13:21:34.046]                       {
[13:21:34.046]                         lapply(seq_along(...future.elements_ii), 
[13:21:34.046]                           FUN = function(jj) {
[13:21:34.046]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.046]                             ...future.FUN(...future.X_jj, ...)
[13:21:34.046]                           })
[13:21:34.046]                       }
[13:21:34.046]                     }, args = future.call.arguments)
[13:21:34.046]                   }
[13:21:34.046]                 }, immediateCondition = function(cond) {
[13:21:34.046]                   save_rds <- function (object, pathname, ...) 
[13:21:34.046]                   {
[13:21:34.046]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:34.046]                     if (file_test("-f", pathname_tmp)) {
[13:21:34.046]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.046]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:34.046]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.046]                         fi_tmp[["mtime"]])
[13:21:34.046]                     }
[13:21:34.046]                     tryCatch({
[13:21:34.046]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:34.046]                     }, error = function(ex) {
[13:21:34.046]                       msg <- conditionMessage(ex)
[13:21:34.046]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.046]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:34.046]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.046]                         fi_tmp[["mtime"]], msg)
[13:21:34.046]                       ex$message <- msg
[13:21:34.046]                       stop(ex)
[13:21:34.046]                     })
[13:21:34.046]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:34.046]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:34.046]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:34.046]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.046]                       fi <- file.info(pathname)
[13:21:34.046]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:34.046]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.046]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:34.046]                         fi[["size"]], fi[["mtime"]])
[13:21:34.046]                       stop(msg)
[13:21:34.046]                     }
[13:21:34.046]                     invisible(pathname)
[13:21:34.046]                   }
[13:21:34.046]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:34.046]                     rootPath = tempdir()) 
[13:21:34.046]                   {
[13:21:34.046]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:34.046]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:34.046]                       tmpdir = path, fileext = ".rds")
[13:21:34.046]                     save_rds(obj, file)
[13:21:34.046]                   }
[13:21:34.046]                   saveImmediateCondition(cond, path = "/tmp/RtmpbpFWGO/.future/immediateConditions")
[13:21:34.046]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.046]                   {
[13:21:34.046]                     inherits <- base::inherits
[13:21:34.046]                     invokeRestart <- base::invokeRestart
[13:21:34.046]                     is.null <- base::is.null
[13:21:34.046]                     muffled <- FALSE
[13:21:34.046]                     if (inherits(cond, "message")) {
[13:21:34.046]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:34.046]                       if (muffled) 
[13:21:34.046]                         invokeRestart("muffleMessage")
[13:21:34.046]                     }
[13:21:34.046]                     else if (inherits(cond, "warning")) {
[13:21:34.046]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:34.046]                       if (muffled) 
[13:21:34.046]                         invokeRestart("muffleWarning")
[13:21:34.046]                     }
[13:21:34.046]                     else if (inherits(cond, "condition")) {
[13:21:34.046]                       if (!is.null(pattern)) {
[13:21:34.046]                         computeRestarts <- base::computeRestarts
[13:21:34.046]                         grepl <- base::grepl
[13:21:34.046]                         restarts <- computeRestarts(cond)
[13:21:34.046]                         for (restart in restarts) {
[13:21:34.046]                           name <- restart$name
[13:21:34.046]                           if (is.null(name)) 
[13:21:34.046]                             next
[13:21:34.046]                           if (!grepl(pattern, name)) 
[13:21:34.046]                             next
[13:21:34.046]                           invokeRestart(restart)
[13:21:34.046]                           muffled <- TRUE
[13:21:34.046]                           break
[13:21:34.046]                         }
[13:21:34.046]                       }
[13:21:34.046]                     }
[13:21:34.046]                     invisible(muffled)
[13:21:34.046]                   }
[13:21:34.046]                   muffleCondition(cond)
[13:21:34.046]                 })
[13:21:34.046]             }))
[13:21:34.046]             future::FutureResult(value = ...future.value$value, 
[13:21:34.046]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:34.046]                   ...future.rng), globalenv = if (FALSE) 
[13:21:34.046]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:34.046]                     ...future.globalenv.names))
[13:21:34.046]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:34.046]         }, condition = base::local({
[13:21:34.046]             c <- base::c
[13:21:34.046]             inherits <- base::inherits
[13:21:34.046]             invokeRestart <- base::invokeRestart
[13:21:34.046]             length <- base::length
[13:21:34.046]             list <- base::list
[13:21:34.046]             seq.int <- base::seq.int
[13:21:34.046]             signalCondition <- base::signalCondition
[13:21:34.046]             sys.calls <- base::sys.calls
[13:21:34.046]             `[[` <- base::`[[`
[13:21:34.046]             `+` <- base::`+`
[13:21:34.046]             `<<-` <- base::`<<-`
[13:21:34.046]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:34.046]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:34.046]                   3L)]
[13:21:34.046]             }
[13:21:34.046]             function(cond) {
[13:21:34.046]                 is_error <- inherits(cond, "error")
[13:21:34.046]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:34.046]                   NULL)
[13:21:34.046]                 if (is_error) {
[13:21:34.046]                   sessionInformation <- function() {
[13:21:34.046]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:34.046]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:34.046]                       search = base::search(), system = base::Sys.info())
[13:21:34.046]                   }
[13:21:34.046]                   ...future.conditions[[length(...future.conditions) + 
[13:21:34.046]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:34.046]                     cond$call), session = sessionInformation(), 
[13:21:34.046]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:34.046]                   signalCondition(cond)
[13:21:34.046]                 }
[13:21:34.046]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:34.046]                 "immediateCondition"))) {
[13:21:34.046]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:34.046]                   ...future.conditions[[length(...future.conditions) + 
[13:21:34.046]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:34.046]                   if (TRUE && !signal) {
[13:21:34.046]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.046]                     {
[13:21:34.046]                       inherits <- base::inherits
[13:21:34.046]                       invokeRestart <- base::invokeRestart
[13:21:34.046]                       is.null <- base::is.null
[13:21:34.046]                       muffled <- FALSE
[13:21:34.046]                       if (inherits(cond, "message")) {
[13:21:34.046]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:34.046]                         if (muffled) 
[13:21:34.046]                           invokeRestart("muffleMessage")
[13:21:34.046]                       }
[13:21:34.046]                       else if (inherits(cond, "warning")) {
[13:21:34.046]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:34.046]                         if (muffled) 
[13:21:34.046]                           invokeRestart("muffleWarning")
[13:21:34.046]                       }
[13:21:34.046]                       else if (inherits(cond, "condition")) {
[13:21:34.046]                         if (!is.null(pattern)) {
[13:21:34.046]                           computeRestarts <- base::computeRestarts
[13:21:34.046]                           grepl <- base::grepl
[13:21:34.046]                           restarts <- computeRestarts(cond)
[13:21:34.046]                           for (restart in restarts) {
[13:21:34.046]                             name <- restart$name
[13:21:34.046]                             if (is.null(name)) 
[13:21:34.046]                               next
[13:21:34.046]                             if (!grepl(pattern, name)) 
[13:21:34.046]                               next
[13:21:34.046]                             invokeRestart(restart)
[13:21:34.046]                             muffled <- TRUE
[13:21:34.046]                             break
[13:21:34.046]                           }
[13:21:34.046]                         }
[13:21:34.046]                       }
[13:21:34.046]                       invisible(muffled)
[13:21:34.046]                     }
[13:21:34.046]                     muffleCondition(cond, pattern = "^muffle")
[13:21:34.046]                   }
[13:21:34.046]                 }
[13:21:34.046]                 else {
[13:21:34.046]                   if (TRUE) {
[13:21:34.046]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.046]                     {
[13:21:34.046]                       inherits <- base::inherits
[13:21:34.046]                       invokeRestart <- base::invokeRestart
[13:21:34.046]                       is.null <- base::is.null
[13:21:34.046]                       muffled <- FALSE
[13:21:34.046]                       if (inherits(cond, "message")) {
[13:21:34.046]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:34.046]                         if (muffled) 
[13:21:34.046]                           invokeRestart("muffleMessage")
[13:21:34.046]                       }
[13:21:34.046]                       else if (inherits(cond, "warning")) {
[13:21:34.046]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:34.046]                         if (muffled) 
[13:21:34.046]                           invokeRestart("muffleWarning")
[13:21:34.046]                       }
[13:21:34.046]                       else if (inherits(cond, "condition")) {
[13:21:34.046]                         if (!is.null(pattern)) {
[13:21:34.046]                           computeRestarts <- base::computeRestarts
[13:21:34.046]                           grepl <- base::grepl
[13:21:34.046]                           restarts <- computeRestarts(cond)
[13:21:34.046]                           for (restart in restarts) {
[13:21:34.046]                             name <- restart$name
[13:21:34.046]                             if (is.null(name)) 
[13:21:34.046]                               next
[13:21:34.046]                             if (!grepl(pattern, name)) 
[13:21:34.046]                               next
[13:21:34.046]                             invokeRestart(restart)
[13:21:34.046]                             muffled <- TRUE
[13:21:34.046]                             break
[13:21:34.046]                           }
[13:21:34.046]                         }
[13:21:34.046]                       }
[13:21:34.046]                       invisible(muffled)
[13:21:34.046]                     }
[13:21:34.046]                     muffleCondition(cond, pattern = "^muffle")
[13:21:34.046]                   }
[13:21:34.046]                 }
[13:21:34.046]             }
[13:21:34.046]         }))
[13:21:34.046]     }, error = function(ex) {
[13:21:34.046]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:34.046]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:34.046]                 ...future.rng), started = ...future.startTime, 
[13:21:34.046]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:34.046]             version = "1.8"), class = "FutureResult")
[13:21:34.046]     }, finally = {
[13:21:34.046]         if (!identical(...future.workdir, getwd())) 
[13:21:34.046]             setwd(...future.workdir)
[13:21:34.046]         {
[13:21:34.046]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:34.046]                 ...future.oldOptions$nwarnings <- NULL
[13:21:34.046]             }
[13:21:34.046]             base::options(...future.oldOptions)
[13:21:34.046]             if (.Platform$OS.type == "windows") {
[13:21:34.046]                 old_names <- names(...future.oldEnvVars)
[13:21:34.046]                 envs <- base::Sys.getenv()
[13:21:34.046]                 names <- names(envs)
[13:21:34.046]                 common <- intersect(names, old_names)
[13:21:34.046]                 added <- setdiff(names, old_names)
[13:21:34.046]                 removed <- setdiff(old_names, names)
[13:21:34.046]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:34.046]                   envs[common]]
[13:21:34.046]                 NAMES <- toupper(changed)
[13:21:34.046]                 args <- list()
[13:21:34.046]                 for (kk in seq_along(NAMES)) {
[13:21:34.046]                   name <- changed[[kk]]
[13:21:34.046]                   NAME <- NAMES[[kk]]
[13:21:34.046]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.046]                     next
[13:21:34.046]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:34.046]                 }
[13:21:34.046]                 NAMES <- toupper(added)
[13:21:34.046]                 for (kk in seq_along(NAMES)) {
[13:21:34.046]                   name <- added[[kk]]
[13:21:34.046]                   NAME <- NAMES[[kk]]
[13:21:34.046]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.046]                     next
[13:21:34.046]                   args[[name]] <- ""
[13:21:34.046]                 }
[13:21:34.046]                 NAMES <- toupper(removed)
[13:21:34.046]                 for (kk in seq_along(NAMES)) {
[13:21:34.046]                   name <- removed[[kk]]
[13:21:34.046]                   NAME <- NAMES[[kk]]
[13:21:34.046]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.046]                     next
[13:21:34.046]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:34.046]                 }
[13:21:34.046]                 if (length(args) > 0) 
[13:21:34.046]                   base::do.call(base::Sys.setenv, args = args)
[13:21:34.046]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:34.046]             }
[13:21:34.046]             else {
[13:21:34.046]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:34.046]             }
[13:21:34.046]             {
[13:21:34.046]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:34.046]                   0L) {
[13:21:34.046]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:34.046]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:34.046]                   base::options(opts)
[13:21:34.046]                 }
[13:21:34.046]                 {
[13:21:34.046]                   {
[13:21:34.046]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:34.046]                     NULL
[13:21:34.046]                   }
[13:21:34.046]                   options(future.plan = NULL)
[13:21:34.046]                   if (is.na(NA_character_)) 
[13:21:34.046]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:34.046]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:34.046]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:34.046]                     envir = parent.frame()) 
[13:21:34.046]                   {
[13:21:34.046]                     default_workers <- missing(workers)
[13:21:34.046]                     if (is.function(workers)) 
[13:21:34.046]                       workers <- workers()
[13:21:34.046]                     workers <- structure(as.integer(workers), 
[13:21:34.046]                       class = class(workers))
[13:21:34.046]                     stop_if_not(is.finite(workers), workers >= 
[13:21:34.046]                       1L)
[13:21:34.046]                     if ((workers == 1L && !inherits(workers, 
[13:21:34.046]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:34.046]                       if (default_workers) 
[13:21:34.046]                         supportsMulticore(warn = TRUE)
[13:21:34.046]                       return(sequential(..., envir = envir))
[13:21:34.046]                     }
[13:21:34.046]                     oopts <- options(mc.cores = workers)
[13:21:34.046]                     on.exit(options(oopts))
[13:21:34.046]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:34.046]                       envir = envir)
[13:21:34.046]                     if (!future$lazy) 
[13:21:34.046]                       future <- run(future)
[13:21:34.046]                     invisible(future)
[13:21:34.046]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:34.046]                 }
[13:21:34.046]             }
[13:21:34.046]         }
[13:21:34.046]     })
[13:21:34.046]     if (TRUE) {
[13:21:34.046]         base::sink(type = "output", split = FALSE)
[13:21:34.046]         if (TRUE) {
[13:21:34.046]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:34.046]         }
[13:21:34.046]         else {
[13:21:34.046]             ...future.result["stdout"] <- base::list(NULL)
[13:21:34.046]         }
[13:21:34.046]         base::close(...future.stdout)
[13:21:34.046]         ...future.stdout <- NULL
[13:21:34.046]     }
[13:21:34.046]     ...future.result$conditions <- ...future.conditions
[13:21:34.046]     ...future.result$finished <- base::Sys.time()
[13:21:34.046]     ...future.result
[13:21:34.046] }
[13:21:34.049] assign_globals() ...
[13:21:34.049] List of 11
[13:21:34.049]  $ ...future.FUN            :function (x, ...)  
[13:21:34.049]  $ x_FUN                    :function (x)  
[13:21:34.049]  $ times                    : int 4
[13:21:34.049]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:34.049]  $ stop_if_not              :function (...)  
[13:21:34.049]  $ dim                      : int [1:2] 2 2
[13:21:34.049]  $ valid_types              : chr [1:2] "logical" "integer"
[13:21:34.049]  $ future.call.arguments    : list()
[13:21:34.049]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:34.049]  $ ...future.elements_ii    :List of 5
[13:21:34.049]   ..$ : int 1
[13:21:34.049]   ..$ : int 2
[13:21:34.049]   ..$ : int 3
[13:21:34.049]   ..$ : int 4
[13:21:34.049]   ..$ : int 5
[13:21:34.049]  $ ...future.seeds_ii       : NULL
[13:21:34.049]  $ ...future.globals.maxSize: NULL
[13:21:34.049]  - attr(*, "where")=List of 11
[13:21:34.049]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:34.049]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:34.049]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:34.049]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:34.049]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:34.049]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:34.049]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:34.049]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:34.049]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:34.049]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:34.049]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:34.049]  - attr(*, "resolved")= logi FALSE
[13:21:34.049]  - attr(*, "total_size")= num 97232
[13:21:34.049]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:34.049]  - attr(*, "already-done")= logi TRUE
[13:21:34.061] - copied ‘...future.FUN’ to environment
[13:21:34.061] - reassign environment for ‘x_FUN’
[13:21:34.061] - copied ‘x_FUN’ to environment
[13:21:34.061] - copied ‘times’ to environment
[13:21:34.061] - copied ‘stopf’ to environment
[13:21:34.061] - copied ‘stop_if_not’ to environment
[13:21:34.061] - copied ‘dim’ to environment
[13:21:34.062] - copied ‘valid_types’ to environment
[13:21:34.062] - copied ‘future.call.arguments’ to environment
[13:21:34.062] - copied ‘...future.elements_ii’ to environment
[13:21:34.062] - copied ‘...future.seeds_ii’ to environment
[13:21:34.062] - copied ‘...future.globals.maxSize’ to environment
[13:21:34.062] assign_globals() ... done
[13:21:34.062] requestCore(): workers = 2
[13:21:34.065] MulticoreFuture started
[13:21:34.065] - Launch lazy future ... done
[13:21:34.065] run() for ‘MulticoreFuture’ ... done
[13:21:34.066] Created future:
[13:21:34.066] plan(): Setting new future strategy stack:
[13:21:34.066] List of future strategies:
[13:21:34.066] 1. sequential:
[13:21:34.066]    - args: function (..., envir = parent.frame())
[13:21:34.066]    - tweaked: FALSE
[13:21:34.066]    - call: NULL
[13:21:34.067] plan(): nbrOfWorkers() = 1
[13:21:34.069] plan(): Setting new future strategy stack:
[13:21:34.069] List of future strategies:
[13:21:34.069] 1. multicore:
[13:21:34.069]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:34.069]    - tweaked: FALSE
[13:21:34.069]    - call: plan(strategy)
[13:21:34.075] plan(): nbrOfWorkers() = 2
[13:21:34.066] MulticoreFuture:
[13:21:34.066] Label: ‘future_vapply-1’
[13:21:34.066] Expression:
[13:21:34.066] {
[13:21:34.066]     do.call(function(...) {
[13:21:34.066]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.066]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:34.066]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.066]             on.exit(options(oopts), add = TRUE)
[13:21:34.066]         }
[13:21:34.066]         {
[13:21:34.066]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:34.066]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.066]                 ...future.FUN(...future.X_jj, ...)
[13:21:34.066]             })
[13:21:34.066]         }
[13:21:34.066]     }, args = future.call.arguments)
[13:21:34.066] }
[13:21:34.066] Lazy evaluation: FALSE
[13:21:34.066] Asynchronous evaluation: TRUE
[13:21:34.066] Local evaluation: TRUE
[13:21:34.066] Environment: R_GlobalEnv
[13:21:34.066] Capture standard output: TRUE
[13:21:34.066] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:34.066] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:34.066] Packages: 1 packages (‘future.apply’)
[13:21:34.066] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:34.066] Resolved: TRUE
[13:21:34.066] Value: <not collected>
[13:21:34.066] Conditions captured: <none>
[13:21:34.066] Early signaling: FALSE
[13:21:34.066] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:34.066] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:34.077] Chunk #1 of 2 ... DONE
[13:21:34.077] Chunk #2 of 2 ...
[13:21:34.077]  - Finding globals in 'X' for chunk #2 ...
[13:21:34.077] getGlobalsAndPackages() ...
[13:21:34.077] Searching for globals...
[13:21:34.078] 
[13:21:34.078] Searching for globals ... DONE
[13:21:34.078] - globals: [0] <none>
[13:21:34.078] getGlobalsAndPackages() ... DONE
[13:21:34.078]    + additional globals found: [n=0] 
[13:21:34.078]    + additional namespaces needed: [n=0] 
[13:21:34.079]  - Finding globals in 'X' for chunk #2 ... DONE
[13:21:34.079]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:34.079]  - seeds: <none>
[13:21:34.079]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.079] getGlobalsAndPackages() ...
[13:21:34.079] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.080] Resolving globals: FALSE
[13:21:34.080] Tweak future expression to call with '...' arguments ...
[13:21:34.080] {
[13:21:34.080]     do.call(function(...) {
[13:21:34.080]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.080]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:34.080]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.080]             on.exit(options(oopts), add = TRUE)
[13:21:34.080]         }
[13:21:34.080]         {
[13:21:34.080]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:34.080]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.080]                 ...future.FUN(...future.X_jj, ...)
[13:21:34.080]             })
[13:21:34.080]         }
[13:21:34.080]     }, args = future.call.arguments)
[13:21:34.080] }
[13:21:34.080] Tweak future expression to call with '...' arguments ... DONE
[13:21:34.081] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.082] - packages: [1] ‘future.apply’
[13:21:34.082] getGlobalsAndPackages() ... DONE
[13:21:34.082] run() for ‘Future’ ...
[13:21:34.083] - state: ‘created’
[13:21:34.083] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:34.088] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:34.088] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:34.088]   - Field: ‘label’
[13:21:34.088]   - Field: ‘local’
[13:21:34.088]   - Field: ‘owner’
[13:21:34.089]   - Field: ‘envir’
[13:21:34.089]   - Field: ‘workers’
[13:21:34.089]   - Field: ‘packages’
[13:21:34.089]   - Field: ‘gc’
[13:21:34.097]   - Field: ‘job’
[13:21:34.097]   - Field: ‘conditions’
[13:21:34.098]   - Field: ‘expr’
[13:21:34.098]   - Field: ‘uuid’
[13:21:34.098]   - Field: ‘seed’
[13:21:34.098]   - Field: ‘version’
[13:21:34.098]   - Field: ‘result’
[13:21:34.098]   - Field: ‘asynchronous’
[13:21:34.098]   - Field: ‘calls’
[13:21:34.098]   - Field: ‘globals’
[13:21:34.099]   - Field: ‘stdout’
[13:21:34.099]   - Field: ‘earlySignal’
[13:21:34.099]   - Field: ‘lazy’
[13:21:34.099]   - Field: ‘state’
[13:21:34.099] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:34.099] - Launch lazy future ...
[13:21:34.100] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:34.100] Packages needed by future strategies (n = 0): <none>
[13:21:34.101] {
[13:21:34.101]     {
[13:21:34.101]         {
[13:21:34.101]             ...future.startTime <- base::Sys.time()
[13:21:34.101]             {
[13:21:34.101]                 {
[13:21:34.101]                   {
[13:21:34.101]                     {
[13:21:34.101]                       {
[13:21:34.101]                         base::local({
[13:21:34.101]                           has_future <- base::requireNamespace("future", 
[13:21:34.101]                             quietly = TRUE)
[13:21:34.101]                           if (has_future) {
[13:21:34.101]                             ns <- base::getNamespace("future")
[13:21:34.101]                             version <- ns[[".package"]][["version"]]
[13:21:34.101]                             if (is.null(version)) 
[13:21:34.101]                               version <- utils::packageVersion("future")
[13:21:34.101]                           }
[13:21:34.101]                           else {
[13:21:34.101]                             version <- NULL
[13:21:34.101]                           }
[13:21:34.101]                           if (!has_future || version < "1.8.0") {
[13:21:34.101]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:34.101]                               "", base::R.version$version.string), 
[13:21:34.101]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:34.101]                                 base::R.version$platform, 8 * 
[13:21:34.101]                                   base::.Machine$sizeof.pointer), 
[13:21:34.101]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:34.101]                                 "release", "version")], collapse = " "), 
[13:21:34.101]                               hostname = base::Sys.info()[["nodename"]])
[13:21:34.101]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:34.101]                               info)
[13:21:34.101]                             info <- base::paste(info, collapse = "; ")
[13:21:34.101]                             if (!has_future) {
[13:21:34.101]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:34.101]                                 info)
[13:21:34.101]                             }
[13:21:34.101]                             else {
[13:21:34.101]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:34.101]                                 info, version)
[13:21:34.101]                             }
[13:21:34.101]                             base::stop(msg)
[13:21:34.101]                           }
[13:21:34.101]                         })
[13:21:34.101]                       }
[13:21:34.101]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:34.101]                       base::options(mc.cores = 1L)
[13:21:34.101]                     }
[13:21:34.101]                     base::local({
[13:21:34.101]                       for (pkg in "future.apply") {
[13:21:34.101]                         base::loadNamespace(pkg)
[13:21:34.101]                         base::library(pkg, character.only = TRUE)
[13:21:34.101]                       }
[13:21:34.101]                     })
[13:21:34.101]                   }
[13:21:34.101]                   options(future.plan = NULL)
[13:21:34.101]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:34.101]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:34.101]                 }
[13:21:34.101]                 ...future.workdir <- getwd()
[13:21:34.101]             }
[13:21:34.101]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:34.101]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:34.101]         }
[13:21:34.101]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:34.101]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:34.101]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:34.101]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:34.101]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:34.101]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:34.101]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:34.101]             base::names(...future.oldOptions))
[13:21:34.101]     }
[13:21:34.101]     if (FALSE) {
[13:21:34.101]     }
[13:21:34.101]     else {
[13:21:34.101]         if (TRUE) {
[13:21:34.101]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:34.101]                 open = "w")
[13:21:34.101]         }
[13:21:34.101]         else {
[13:21:34.101]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:34.101]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:34.101]         }
[13:21:34.101]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:34.101]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:34.101]             base::sink(type = "output", split = FALSE)
[13:21:34.101]             base::close(...future.stdout)
[13:21:34.101]         }, add = TRUE)
[13:21:34.101]     }
[13:21:34.101]     ...future.frame <- base::sys.nframe()
[13:21:34.101]     ...future.conditions <- base::list()
[13:21:34.101]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:34.101]     if (FALSE) {
[13:21:34.101]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:34.101]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:34.101]     }
[13:21:34.101]     ...future.result <- base::tryCatch({
[13:21:34.101]         base::withCallingHandlers({
[13:21:34.101]             ...future.value <- base::withVisible(base::local({
[13:21:34.101]                 withCallingHandlers({
[13:21:34.101]                   {
[13:21:34.101]                     do.call(function(...) {
[13:21:34.101]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.101]                       if (!identical(...future.globals.maxSize.org, 
[13:21:34.101]                         ...future.globals.maxSize)) {
[13:21:34.101]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.101]                         on.exit(options(oopts), add = TRUE)
[13:21:34.101]                       }
[13:21:34.101]                       {
[13:21:34.101]                         lapply(seq_along(...future.elements_ii), 
[13:21:34.101]                           FUN = function(jj) {
[13:21:34.101]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.101]                             ...future.FUN(...future.X_jj, ...)
[13:21:34.101]                           })
[13:21:34.101]                       }
[13:21:34.101]                     }, args = future.call.arguments)
[13:21:34.101]                   }
[13:21:34.101]                 }, immediateCondition = function(cond) {
[13:21:34.101]                   save_rds <- function (object, pathname, ...) 
[13:21:34.101]                   {
[13:21:34.101]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:34.101]                     if (file_test("-f", pathname_tmp)) {
[13:21:34.101]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.101]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:34.101]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.101]                         fi_tmp[["mtime"]])
[13:21:34.101]                     }
[13:21:34.101]                     tryCatch({
[13:21:34.101]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:34.101]                     }, error = function(ex) {
[13:21:34.101]                       msg <- conditionMessage(ex)
[13:21:34.101]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.101]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:34.101]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.101]                         fi_tmp[["mtime"]], msg)
[13:21:34.101]                       ex$message <- msg
[13:21:34.101]                       stop(ex)
[13:21:34.101]                     })
[13:21:34.101]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:34.101]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:34.101]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:34.101]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.101]                       fi <- file.info(pathname)
[13:21:34.101]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:34.101]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.101]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:34.101]                         fi[["size"]], fi[["mtime"]])
[13:21:34.101]                       stop(msg)
[13:21:34.101]                     }
[13:21:34.101]                     invisible(pathname)
[13:21:34.101]                   }
[13:21:34.101]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:34.101]                     rootPath = tempdir()) 
[13:21:34.101]                   {
[13:21:34.101]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:34.101]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:34.101]                       tmpdir = path, fileext = ".rds")
[13:21:34.101]                     save_rds(obj, file)
[13:21:34.101]                   }
[13:21:34.101]                   saveImmediateCondition(cond, path = "/tmp/RtmpbpFWGO/.future/immediateConditions")
[13:21:34.101]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.101]                   {
[13:21:34.101]                     inherits <- base::inherits
[13:21:34.101]                     invokeRestart <- base::invokeRestart
[13:21:34.101]                     is.null <- base::is.null
[13:21:34.101]                     muffled <- FALSE
[13:21:34.101]                     if (inherits(cond, "message")) {
[13:21:34.101]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:34.101]                       if (muffled) 
[13:21:34.101]                         invokeRestart("muffleMessage")
[13:21:34.101]                     }
[13:21:34.101]                     else if (inherits(cond, "warning")) {
[13:21:34.101]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:34.101]                       if (muffled) 
[13:21:34.101]                         invokeRestart("muffleWarning")
[13:21:34.101]                     }
[13:21:34.101]                     else if (inherits(cond, "condition")) {
[13:21:34.101]                       if (!is.null(pattern)) {
[13:21:34.101]                         computeRestarts <- base::computeRestarts
[13:21:34.101]                         grepl <- base::grepl
[13:21:34.101]                         restarts <- computeRestarts(cond)
[13:21:34.101]                         for (restart in restarts) {
[13:21:34.101]                           name <- restart$name
[13:21:34.101]                           if (is.null(name)) 
[13:21:34.101]                             next
[13:21:34.101]                           if (!grepl(pattern, name)) 
[13:21:34.101]                             next
[13:21:34.101]                           invokeRestart(restart)
[13:21:34.101]                           muffled <- TRUE
[13:21:34.101]                           break
[13:21:34.101]                         }
[13:21:34.101]                       }
[13:21:34.101]                     }
[13:21:34.101]                     invisible(muffled)
[13:21:34.101]                   }
[13:21:34.101]                   muffleCondition(cond)
[13:21:34.101]                 })
[13:21:34.101]             }))
[13:21:34.101]             future::FutureResult(value = ...future.value$value, 
[13:21:34.101]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:34.101]                   ...future.rng), globalenv = if (FALSE) 
[13:21:34.101]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:34.101]                     ...future.globalenv.names))
[13:21:34.101]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:34.101]         }, condition = base::local({
[13:21:34.101]             c <- base::c
[13:21:34.101]             inherits <- base::inherits
[13:21:34.101]             invokeRestart <- base::invokeRestart
[13:21:34.101]             length <- base::length
[13:21:34.101]             list <- base::list
[13:21:34.101]             seq.int <- base::seq.int
[13:21:34.101]             signalCondition <- base::signalCondition
[13:21:34.101]             sys.calls <- base::sys.calls
[13:21:34.101]             `[[` <- base::`[[`
[13:21:34.101]             `+` <- base::`+`
[13:21:34.101]             `<<-` <- base::`<<-`
[13:21:34.101]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:34.101]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:34.101]                   3L)]
[13:21:34.101]             }
[13:21:34.101]             function(cond) {
[13:21:34.101]                 is_error <- inherits(cond, "error")
[13:21:34.101]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:34.101]                   NULL)
[13:21:34.101]                 if (is_error) {
[13:21:34.101]                   sessionInformation <- function() {
[13:21:34.101]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:34.101]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:34.101]                       search = base::search(), system = base::Sys.info())
[13:21:34.101]                   }
[13:21:34.101]                   ...future.conditions[[length(...future.conditions) + 
[13:21:34.101]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:34.101]                     cond$call), session = sessionInformation(), 
[13:21:34.101]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:34.101]                   signalCondition(cond)
[13:21:34.101]                 }
[13:21:34.101]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:34.101]                 "immediateCondition"))) {
[13:21:34.101]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:34.101]                   ...future.conditions[[length(...future.conditions) + 
[13:21:34.101]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:34.101]                   if (TRUE && !signal) {
[13:21:34.101]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.101]                     {
[13:21:34.101]                       inherits <- base::inherits
[13:21:34.101]                       invokeRestart <- base::invokeRestart
[13:21:34.101]                       is.null <- base::is.null
[13:21:34.101]                       muffled <- FALSE
[13:21:34.101]                       if (inherits(cond, "message")) {
[13:21:34.101]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:34.101]                         if (muffled) 
[13:21:34.101]                           invokeRestart("muffleMessage")
[13:21:34.101]                       }
[13:21:34.101]                       else if (inherits(cond, "warning")) {
[13:21:34.101]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:34.101]                         if (muffled) 
[13:21:34.101]                           invokeRestart("muffleWarning")
[13:21:34.101]                       }
[13:21:34.101]                       else if (inherits(cond, "condition")) {
[13:21:34.101]                         if (!is.null(pattern)) {
[13:21:34.101]                           computeRestarts <- base::computeRestarts
[13:21:34.101]                           grepl <- base::grepl
[13:21:34.101]                           restarts <- computeRestarts(cond)
[13:21:34.101]                           for (restart in restarts) {
[13:21:34.101]                             name <- restart$name
[13:21:34.101]                             if (is.null(name)) 
[13:21:34.101]                               next
[13:21:34.101]                             if (!grepl(pattern, name)) 
[13:21:34.101]                               next
[13:21:34.101]                             invokeRestart(restart)
[13:21:34.101]                             muffled <- TRUE
[13:21:34.101]                             break
[13:21:34.101]                           }
[13:21:34.101]                         }
[13:21:34.101]                       }
[13:21:34.101]                       invisible(muffled)
[13:21:34.101]                     }
[13:21:34.101]                     muffleCondition(cond, pattern = "^muffle")
[13:21:34.101]                   }
[13:21:34.101]                 }
[13:21:34.101]                 else {
[13:21:34.101]                   if (TRUE) {
[13:21:34.101]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.101]                     {
[13:21:34.101]                       inherits <- base::inherits
[13:21:34.101]                       invokeRestart <- base::invokeRestart
[13:21:34.101]                       is.null <- base::is.null
[13:21:34.101]                       muffled <- FALSE
[13:21:34.101]                       if (inherits(cond, "message")) {
[13:21:34.101]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:34.101]                         if (muffled) 
[13:21:34.101]                           invokeRestart("muffleMessage")
[13:21:34.101]                       }
[13:21:34.101]                       else if (inherits(cond, "warning")) {
[13:21:34.101]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:34.101]                         if (muffled) 
[13:21:34.101]                           invokeRestart("muffleWarning")
[13:21:34.101]                       }
[13:21:34.101]                       else if (inherits(cond, "condition")) {
[13:21:34.101]                         if (!is.null(pattern)) {
[13:21:34.101]                           computeRestarts <- base::computeRestarts
[13:21:34.101]                           grepl <- base::grepl
[13:21:34.101]                           restarts <- computeRestarts(cond)
[13:21:34.101]                           for (restart in restarts) {
[13:21:34.101]                             name <- restart$name
[13:21:34.101]                             if (is.null(name)) 
[13:21:34.101]                               next
[13:21:34.101]                             if (!grepl(pattern, name)) 
[13:21:34.101]                               next
[13:21:34.101]                             invokeRestart(restart)
[13:21:34.101]                             muffled <- TRUE
[13:21:34.101]                             break
[13:21:34.101]                           }
[13:21:34.101]                         }
[13:21:34.101]                       }
[13:21:34.101]                       invisible(muffled)
[13:21:34.101]                     }
[13:21:34.101]                     muffleCondition(cond, pattern = "^muffle")
[13:21:34.101]                   }
[13:21:34.101]                 }
[13:21:34.101]             }
[13:21:34.101]         }))
[13:21:34.101]     }, error = function(ex) {
[13:21:34.101]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:34.101]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:34.101]                 ...future.rng), started = ...future.startTime, 
[13:21:34.101]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:34.101]             version = "1.8"), class = "FutureResult")
[13:21:34.101]     }, finally = {
[13:21:34.101]         if (!identical(...future.workdir, getwd())) 
[13:21:34.101]             setwd(...future.workdir)
[13:21:34.101]         {
[13:21:34.101]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:34.101]                 ...future.oldOptions$nwarnings <- NULL
[13:21:34.101]             }
[13:21:34.101]             base::options(...future.oldOptions)
[13:21:34.101]             if (.Platform$OS.type == "windows") {
[13:21:34.101]                 old_names <- names(...future.oldEnvVars)
[13:21:34.101]                 envs <- base::Sys.getenv()
[13:21:34.101]                 names <- names(envs)
[13:21:34.101]                 common <- intersect(names, old_names)
[13:21:34.101]                 added <- setdiff(names, old_names)
[13:21:34.101]                 removed <- setdiff(old_names, names)
[13:21:34.101]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:34.101]                   envs[common]]
[13:21:34.101]                 NAMES <- toupper(changed)
[13:21:34.101]                 args <- list()
[13:21:34.101]                 for (kk in seq_along(NAMES)) {
[13:21:34.101]                   name <- changed[[kk]]
[13:21:34.101]                   NAME <- NAMES[[kk]]
[13:21:34.101]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.101]                     next
[13:21:34.101]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:34.101]                 }
[13:21:34.101]                 NAMES <- toupper(added)
[13:21:34.101]                 for (kk in seq_along(NAMES)) {
[13:21:34.101]                   name <- added[[kk]]
[13:21:34.101]                   NAME <- NAMES[[kk]]
[13:21:34.101]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.101]                     next
[13:21:34.101]                   args[[name]] <- ""
[13:21:34.101]                 }
[13:21:34.101]                 NAMES <- toupper(removed)
[13:21:34.101]                 for (kk in seq_along(NAMES)) {
[13:21:34.101]                   name <- removed[[kk]]
[13:21:34.101]                   NAME <- NAMES[[kk]]
[13:21:34.101]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.101]                     next
[13:21:34.101]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:34.101]                 }
[13:21:34.101]                 if (length(args) > 0) 
[13:21:34.101]                   base::do.call(base::Sys.setenv, args = args)
[13:21:34.101]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:34.101]             }
[13:21:34.101]             else {
[13:21:34.101]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:34.101]             }
[13:21:34.101]             {
[13:21:34.101]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:34.101]                   0L) {
[13:21:34.101]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:34.101]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:34.101]                   base::options(opts)
[13:21:34.101]                 }
[13:21:34.101]                 {
[13:21:34.101]                   {
[13:21:34.101]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:34.101]                     NULL
[13:21:34.101]                   }
[13:21:34.101]                   options(future.plan = NULL)
[13:21:34.101]                   if (is.na(NA_character_)) 
[13:21:34.101]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:34.101]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:34.101]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:34.101]                     envir = parent.frame()) 
[13:21:34.101]                   {
[13:21:34.101]                     default_workers <- missing(workers)
[13:21:34.101]                     if (is.function(workers)) 
[13:21:34.101]                       workers <- workers()
[13:21:34.101]                     workers <- structure(as.integer(workers), 
[13:21:34.101]                       class = class(workers))
[13:21:34.101]                     stop_if_not(is.finite(workers), workers >= 
[13:21:34.101]                       1L)
[13:21:34.101]                     if ((workers == 1L && !inherits(workers, 
[13:21:34.101]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:34.101]                       if (default_workers) 
[13:21:34.101]                         supportsMulticore(warn = TRUE)
[13:21:34.101]                       return(sequential(..., envir = envir))
[13:21:34.101]                     }
[13:21:34.101]                     oopts <- options(mc.cores = workers)
[13:21:34.101]                     on.exit(options(oopts))
[13:21:34.101]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:34.101]                       envir = envir)
[13:21:34.101]                     if (!future$lazy) 
[13:21:34.101]                       future <- run(future)
[13:21:34.101]                     invisible(future)
[13:21:34.101]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:34.101]                 }
[13:21:34.101]             }
[13:21:34.101]         }
[13:21:34.101]     })
[13:21:34.101]     if (TRUE) {
[13:21:34.101]         base::sink(type = "output", split = FALSE)
[13:21:34.101]         if (TRUE) {
[13:21:34.101]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:34.101]         }
[13:21:34.101]         else {
[13:21:34.101]             ...future.result["stdout"] <- base::list(NULL)
[13:21:34.101]         }
[13:21:34.101]         base::close(...future.stdout)
[13:21:34.101]         ...future.stdout <- NULL
[13:21:34.101]     }
[13:21:34.101]     ...future.result$conditions <- ...future.conditions
[13:21:34.101]     ...future.result$finished <- base::Sys.time()
[13:21:34.101]     ...future.result
[13:21:34.101] }
[13:21:34.105] assign_globals() ...
[13:21:34.105] List of 11
[13:21:34.105]  $ ...future.FUN            :function (x, ...)  
[13:21:34.105]  $ x_FUN                    :function (x)  
[13:21:34.105]  $ times                    : int 4
[13:21:34.105]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:34.105]  $ stop_if_not              :function (...)  
[13:21:34.105]  $ dim                      : int [1:2] 2 2
[13:21:34.105]  $ valid_types              : chr [1:2] "logical" "integer"
[13:21:34.105]  $ future.call.arguments    : list()
[13:21:34.105]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:34.105]  $ ...future.elements_ii    :List of 5
[13:21:34.105]   ..$ : int 6
[13:21:34.105]   ..$ : int 7
[13:21:34.105]   ..$ : int 8
[13:21:34.105]   ..$ : int 9
[13:21:34.105]   ..$ : int 10
[13:21:34.105]  $ ...future.seeds_ii       : NULL
[13:21:34.105]  $ ...future.globals.maxSize: NULL
[13:21:34.105]  - attr(*, "where")=List of 11
[13:21:34.105]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:34.105]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:34.105]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:34.105]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:34.105]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:34.105]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:34.105]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:34.105]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:34.105]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:34.105]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:34.105]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:34.105]  - attr(*, "resolved")= logi FALSE
[13:21:34.105]  - attr(*, "total_size")= num 97232
[13:21:34.105]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:34.105]  - attr(*, "already-done")= logi TRUE
[13:21:34.119] - copied ‘...future.FUN’ to environment
[13:21:34.119] - reassign environment for ‘x_FUN’
[13:21:34.119] - copied ‘x_FUN’ to environment
[13:21:34.119] - copied ‘times’ to environment
[13:21:34.119] - copied ‘stopf’ to environment
[13:21:34.119] - copied ‘stop_if_not’ to environment
[13:21:34.120] - copied ‘dim’ to environment
[13:21:34.120] - copied ‘valid_types’ to environment
[13:21:34.120] - copied ‘future.call.arguments’ to environment
[13:21:34.120] - copied ‘...future.elements_ii’ to environment
[13:21:34.120] - copied ‘...future.seeds_ii’ to environment
[13:21:34.120] - copied ‘...future.globals.maxSize’ to environment
[13:21:34.120] assign_globals() ... done
[13:21:34.120] requestCore(): workers = 2
[13:21:34.123] MulticoreFuture started
[13:21:34.123] - Launch lazy future ... done
[13:21:34.123] run() for ‘MulticoreFuture’ ... done
[13:21:34.124] Created future:
[13:21:34.124] plan(): Setting new future strategy stack:
[13:21:34.124] List of future strategies:
[13:21:34.124] 1. sequential:
[13:21:34.124]    - args: function (..., envir = parent.frame())
[13:21:34.124]    - tweaked: FALSE
[13:21:34.124]    - call: NULL
[13:21:34.125] plan(): nbrOfWorkers() = 1
[13:21:34.127] plan(): Setting new future strategy stack:
[13:21:34.128] List of future strategies:
[13:21:34.128] 1. multicore:
[13:21:34.128]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:34.128]    - tweaked: FALSE
[13:21:34.128]    - call: plan(strategy)
[13:21:34.133] plan(): nbrOfWorkers() = 2
[13:21:34.124] MulticoreFuture:
[13:21:34.124] Label: ‘future_vapply-2’
[13:21:34.124] Expression:
[13:21:34.124] {
[13:21:34.124]     do.call(function(...) {
[13:21:34.124]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.124]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:34.124]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.124]             on.exit(options(oopts), add = TRUE)
[13:21:34.124]         }
[13:21:34.124]         {
[13:21:34.124]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:34.124]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.124]                 ...future.FUN(...future.X_jj, ...)
[13:21:34.124]             })
[13:21:34.124]         }
[13:21:34.124]     }, args = future.call.arguments)
[13:21:34.124] }
[13:21:34.124] Lazy evaluation: FALSE
[13:21:34.124] Asynchronous evaluation: TRUE
[13:21:34.124] Local evaluation: TRUE
[13:21:34.124] Environment: R_GlobalEnv
[13:21:34.124] Capture standard output: TRUE
[13:21:34.124] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:34.124] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:34.124] Packages: 1 packages (‘future.apply’)
[13:21:34.124] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:34.124] Resolved: TRUE
[13:21:34.124] Value: <not collected>
[13:21:34.124] Conditions captured: <none>
[13:21:34.124] Early signaling: FALSE
[13:21:34.124] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:34.124] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:34.134] Chunk #2 of 2 ... DONE
[13:21:34.134] Launching 2 futures (chunks) ... DONE
[13:21:34.135] Resolving 2 futures (chunks) ...
[13:21:34.135] resolve() on list ...
[13:21:34.135]  recursive: 0
[13:21:34.135]  length: 2
[13:21:34.135] 
[13:21:34.136] Future #1
[13:21:34.136] result() for MulticoreFuture ...
[13:21:34.137] result() for MulticoreFuture ...
[13:21:34.137] result() for MulticoreFuture ... done
[13:21:34.137] result() for MulticoreFuture ... done
[13:21:34.137] result() for MulticoreFuture ...
[13:21:34.137] result() for MulticoreFuture ... done
[13:21:34.138] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:21:34.138] - nx: 2
[13:21:34.138] - relay: TRUE
[13:21:34.138] - stdout: TRUE
[13:21:34.138] - signal: TRUE
[13:21:34.138] - resignal: FALSE
[13:21:34.138] - force: TRUE
[13:21:34.139] - relayed: [n=2] FALSE, FALSE
[13:21:34.139] - queued futures: [n=2] FALSE, FALSE
[13:21:34.139]  - until=1
[13:21:34.139]  - relaying element #1
[13:21:34.139] result() for MulticoreFuture ...
[13:21:34.139] result() for MulticoreFuture ... done
[13:21:34.140] result() for MulticoreFuture ...
[13:21:34.140] result() for MulticoreFuture ... done
[13:21:34.140] result() for MulticoreFuture ...
[13:21:34.140] result() for MulticoreFuture ... done
[13:21:34.140] result() for MulticoreFuture ...
[13:21:34.140] result() for MulticoreFuture ... done
[13:21:34.141] - relayed: [n=2] TRUE, FALSE
[13:21:34.141] - queued futures: [n=2] TRUE, FALSE
[13:21:34.145] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:21:34.145]  length: 1 (resolved future 1)
[13:21:34.146] Future #2
[13:21:34.146] result() for MulticoreFuture ...
[13:21:34.147] result() for MulticoreFuture ...
[13:21:34.148] result() for MulticoreFuture ... done
[13:21:34.148] result() for MulticoreFuture ... done
[13:21:34.148] result() for MulticoreFuture ...
[13:21:34.149] result() for MulticoreFuture ... done
[13:21:34.149] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:21:34.149] - nx: 2
[13:21:34.149] - relay: TRUE
[13:21:34.149] - stdout: TRUE
[13:21:34.149] - signal: TRUE
[13:21:34.150] - resignal: FALSE
[13:21:34.150] - force: TRUE
[13:21:34.150] - relayed: [n=2] TRUE, FALSE
[13:21:34.150] - queued futures: [n=2] TRUE, FALSE
[13:21:34.150]  - until=2
[13:21:34.150]  - relaying element #2
[13:21:34.151] result() for MulticoreFuture ...
[13:21:34.151] result() for MulticoreFuture ... done
[13:21:34.151] result() for MulticoreFuture ...
[13:21:34.151] result() for MulticoreFuture ... done
[13:21:34.151] result() for MulticoreFuture ...
[13:21:34.151] result() for MulticoreFuture ... done
[13:21:34.152] result() for MulticoreFuture ...
[13:21:34.152] result() for MulticoreFuture ... done
[13:21:34.152] - relayed: [n=2] TRUE, TRUE
[13:21:34.152] - queued futures: [n=2] TRUE, TRUE
[13:21:34.152] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:21:34.152]  length: 0 (resolved future 2)
[13:21:34.153] Relaying remaining futures
[13:21:34.153] signalConditionsASAP(NULL, pos=0) ...
[13:21:34.153] - nx: 2
[13:21:34.153] - relay: TRUE
[13:21:34.153] - stdout: TRUE
[13:21:34.153] - signal: TRUE
[13:21:34.153] - resignal: FALSE
[13:21:34.154] - force: TRUE
[13:21:34.154] - relayed: [n=2] TRUE, TRUE
[13:21:34.154] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:21:34.154] - relayed: [n=2] TRUE, TRUE
[13:21:34.154] - queued futures: [n=2] TRUE, TRUE
[13:21:34.154] signalConditionsASAP(NULL, pos=0) ... done
[13:21:34.155] resolve() on list ... DONE
[13:21:34.155] result() for MulticoreFuture ...
[13:21:34.155] result() for MulticoreFuture ... done
[13:21:34.155] result() for MulticoreFuture ...
[13:21:34.155] result() for MulticoreFuture ... done
[13:21:34.155] result() for MulticoreFuture ...
[13:21:34.155] result() for MulticoreFuture ... done
[13:21:34.155] result() for MulticoreFuture ...
[13:21:34.156] result() for MulticoreFuture ... done
[13:21:34.156]  - Number of value chunks collected: 2
[13:21:34.156] Resolving 2 futures (chunks) ... DONE
[13:21:34.156] Reducing values from 2 chunks ...
[13:21:34.156]  - Number of values collected after concatenation: 10
[13:21:34.156]  - Number of values expected: 10
[13:21:34.156] Reducing values from 2 chunks ... DONE
[13:21:34.157] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[13:21:34.158] future_lapply() ...
[13:21:34.164] Number of chunks: 2
[13:21:34.164] getGlobalsAndPackagesXApply() ...
[13:21:34.165]  - future.globals: TRUE
[13:21:34.165] getGlobalsAndPackages() ...
[13:21:34.165] Searching for globals...
[13:21:34.169] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[13:21:34.169] Searching for globals ... DONE
[13:21:34.169] Resolving globals: FALSE
[13:21:34.170] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[13:21:34.170] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:34.170] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:34.171] - packages: [1] ‘future.apply’
[13:21:34.171] getGlobalsAndPackages() ... DONE
[13:21:34.171]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:34.171]  - needed namespaces: [n=1] ‘future.apply’
[13:21:34.171] Finding globals ... DONE
[13:21:34.171]  - use_args: TRUE
[13:21:34.171]  - Getting '...' globals ...
[13:21:34.171] resolve() on list ...
[13:21:34.172]  recursive: 0
[13:21:34.172]  length: 1
[13:21:34.172]  elements: ‘...’
[13:21:34.172]  length: 0 (resolved future 1)
[13:21:34.172] resolve() on list ... DONE
[13:21:34.172]    - '...' content: [n=0] 
[13:21:34.172] List of 1
[13:21:34.172]  $ ...: list()
[13:21:34.172]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:34.172]  - attr(*, "where")=List of 1
[13:21:34.172]   ..$ ...:<environment: 0x563b6d87c498> 
[13:21:34.172]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:34.172]  - attr(*, "resolved")= logi TRUE
[13:21:34.172]  - attr(*, "total_size")= num NA
[13:21:34.177]  - Getting '...' globals ... DONE
[13:21:34.178] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:34.178] List of 8
[13:21:34.178]  $ ...future.FUN:function (x, ...)  
[13:21:34.178]  $ x_FUN        :function (x)  
[13:21:34.178]  $ times        : int 4
[13:21:34.178]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:34.178]  $ stop_if_not  :function (...)  
[13:21:34.178]  $ dim          : int [1:2] 2 2
[13:21:34.178]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:21:34.178]  $ ...          : list()
[13:21:34.178]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:34.178]  - attr(*, "where")=List of 8
[13:21:34.178]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:34.178]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:34.178]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:34.178]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:34.178]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:34.178]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:34.178]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:34.178]   ..$ ...          :<environment: 0x563b6d87c498> 
[13:21:34.178]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:34.178]  - attr(*, "resolved")= logi FALSE
[13:21:34.178]  - attr(*, "total_size")= num 97304
[13:21:34.184] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:21:34.185] getGlobalsAndPackagesXApply() ... DONE
[13:21:34.185] Number of futures (= number of chunks): 2
[13:21:34.185] Launching 2 futures (chunks) ...
[13:21:34.185] Chunk #1 of 2 ...
[13:21:34.185]  - Finding globals in 'X' for chunk #1 ...
[13:21:34.185] getGlobalsAndPackages() ...
[13:21:34.185] Searching for globals...
[13:21:34.186] 
[13:21:34.186] Searching for globals ... DONE
[13:21:34.186] - globals: [0] <none>
[13:21:34.186] getGlobalsAndPackages() ... DONE
[13:21:34.186]    + additional globals found: [n=0] 
[13:21:34.186]    + additional namespaces needed: [n=0] 
[13:21:34.186]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:34.186]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:34.186]  - seeds: <none>
[13:21:34.187]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.187] getGlobalsAndPackages() ...
[13:21:34.187] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.187] Resolving globals: FALSE
[13:21:34.187] Tweak future expression to call with '...' arguments ...
[13:21:34.187] {
[13:21:34.187]     do.call(function(...) {
[13:21:34.187]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.187]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:34.187]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.187]             on.exit(options(oopts), add = TRUE)
[13:21:34.187]         }
[13:21:34.187]         {
[13:21:34.187]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:34.187]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.187]                 ...future.FUN(...future.X_jj, ...)
[13:21:34.187]             })
[13:21:34.187]         }
[13:21:34.187]     }, args = future.call.arguments)
[13:21:34.187] }
[13:21:34.187] Tweak future expression to call with '...' arguments ... DONE
[13:21:34.188] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.188] - packages: [1] ‘future.apply’
[13:21:34.188] getGlobalsAndPackages() ... DONE
[13:21:34.189] run() for ‘Future’ ...
[13:21:34.189] - state: ‘created’
[13:21:34.189] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:34.193] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:34.193] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:34.193]   - Field: ‘label’
[13:21:34.194]   - Field: ‘local’
[13:21:34.194]   - Field: ‘owner’
[13:21:34.194]   - Field: ‘envir’
[13:21:34.194]   - Field: ‘workers’
[13:21:34.194]   - Field: ‘packages’
[13:21:34.194]   - Field: ‘gc’
[13:21:34.194]   - Field: ‘job’
[13:21:34.194]   - Field: ‘conditions’
[13:21:34.194]   - Field: ‘expr’
[13:21:34.195]   - Field: ‘uuid’
[13:21:34.195]   - Field: ‘seed’
[13:21:34.195]   - Field: ‘version’
[13:21:34.195]   - Field: ‘result’
[13:21:34.195]   - Field: ‘asynchronous’
[13:21:34.195]   - Field: ‘calls’
[13:21:34.195]   - Field: ‘globals’
[13:21:34.195]   - Field: ‘stdout’
[13:21:34.195]   - Field: ‘earlySignal’
[13:21:34.195]   - Field: ‘lazy’
[13:21:34.196]   - Field: ‘state’
[13:21:34.196] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:34.196] - Launch lazy future ...
[13:21:34.196] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:34.196] Packages needed by future strategies (n = 0): <none>
[13:21:34.197] {
[13:21:34.197]     {
[13:21:34.197]         {
[13:21:34.197]             ...future.startTime <- base::Sys.time()
[13:21:34.197]             {
[13:21:34.197]                 {
[13:21:34.197]                   {
[13:21:34.197]                     {
[13:21:34.197]                       {
[13:21:34.197]                         base::local({
[13:21:34.197]                           has_future <- base::requireNamespace("future", 
[13:21:34.197]                             quietly = TRUE)
[13:21:34.197]                           if (has_future) {
[13:21:34.197]                             ns <- base::getNamespace("future")
[13:21:34.197]                             version <- ns[[".package"]][["version"]]
[13:21:34.197]                             if (is.null(version)) 
[13:21:34.197]                               version <- utils::packageVersion("future")
[13:21:34.197]                           }
[13:21:34.197]                           else {
[13:21:34.197]                             version <- NULL
[13:21:34.197]                           }
[13:21:34.197]                           if (!has_future || version < "1.8.0") {
[13:21:34.197]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:34.197]                               "", base::R.version$version.string), 
[13:21:34.197]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:34.197]                                 base::R.version$platform, 8 * 
[13:21:34.197]                                   base::.Machine$sizeof.pointer), 
[13:21:34.197]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:34.197]                                 "release", "version")], collapse = " "), 
[13:21:34.197]                               hostname = base::Sys.info()[["nodename"]])
[13:21:34.197]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:34.197]                               info)
[13:21:34.197]                             info <- base::paste(info, collapse = "; ")
[13:21:34.197]                             if (!has_future) {
[13:21:34.197]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:34.197]                                 info)
[13:21:34.197]                             }
[13:21:34.197]                             else {
[13:21:34.197]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:34.197]                                 info, version)
[13:21:34.197]                             }
[13:21:34.197]                             base::stop(msg)
[13:21:34.197]                           }
[13:21:34.197]                         })
[13:21:34.197]                       }
[13:21:34.197]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:34.197]                       base::options(mc.cores = 1L)
[13:21:34.197]                     }
[13:21:34.197]                     base::local({
[13:21:34.197]                       for (pkg in "future.apply") {
[13:21:34.197]                         base::loadNamespace(pkg)
[13:21:34.197]                         base::library(pkg, character.only = TRUE)
[13:21:34.197]                       }
[13:21:34.197]                     })
[13:21:34.197]                   }
[13:21:34.197]                   options(future.plan = NULL)
[13:21:34.197]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:34.197]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:34.197]                 }
[13:21:34.197]                 ...future.workdir <- getwd()
[13:21:34.197]             }
[13:21:34.197]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:34.197]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:34.197]         }
[13:21:34.197]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:34.197]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:34.197]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:34.197]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:34.197]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:34.197]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:34.197]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:34.197]             base::names(...future.oldOptions))
[13:21:34.197]     }
[13:21:34.197]     if (FALSE) {
[13:21:34.197]     }
[13:21:34.197]     else {
[13:21:34.197]         if (TRUE) {
[13:21:34.197]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:34.197]                 open = "w")
[13:21:34.197]         }
[13:21:34.197]         else {
[13:21:34.197]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:34.197]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:34.197]         }
[13:21:34.197]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:34.197]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:34.197]             base::sink(type = "output", split = FALSE)
[13:21:34.197]             base::close(...future.stdout)
[13:21:34.197]         }, add = TRUE)
[13:21:34.197]     }
[13:21:34.197]     ...future.frame <- base::sys.nframe()
[13:21:34.197]     ...future.conditions <- base::list()
[13:21:34.197]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:34.197]     if (FALSE) {
[13:21:34.197]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:34.197]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:34.197]     }
[13:21:34.197]     ...future.result <- base::tryCatch({
[13:21:34.197]         base::withCallingHandlers({
[13:21:34.197]             ...future.value <- base::withVisible(base::local({
[13:21:34.197]                 withCallingHandlers({
[13:21:34.197]                   {
[13:21:34.197]                     do.call(function(...) {
[13:21:34.197]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.197]                       if (!identical(...future.globals.maxSize.org, 
[13:21:34.197]                         ...future.globals.maxSize)) {
[13:21:34.197]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.197]                         on.exit(options(oopts), add = TRUE)
[13:21:34.197]                       }
[13:21:34.197]                       {
[13:21:34.197]                         lapply(seq_along(...future.elements_ii), 
[13:21:34.197]                           FUN = function(jj) {
[13:21:34.197]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.197]                             ...future.FUN(...future.X_jj, ...)
[13:21:34.197]                           })
[13:21:34.197]                       }
[13:21:34.197]                     }, args = future.call.arguments)
[13:21:34.197]                   }
[13:21:34.197]                 }, immediateCondition = function(cond) {
[13:21:34.197]                   save_rds <- function (object, pathname, ...) 
[13:21:34.197]                   {
[13:21:34.197]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:34.197]                     if (file_test("-f", pathname_tmp)) {
[13:21:34.197]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.197]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:34.197]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.197]                         fi_tmp[["mtime"]])
[13:21:34.197]                     }
[13:21:34.197]                     tryCatch({
[13:21:34.197]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:34.197]                     }, error = function(ex) {
[13:21:34.197]                       msg <- conditionMessage(ex)
[13:21:34.197]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.197]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:34.197]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.197]                         fi_tmp[["mtime"]], msg)
[13:21:34.197]                       ex$message <- msg
[13:21:34.197]                       stop(ex)
[13:21:34.197]                     })
[13:21:34.197]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:34.197]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:34.197]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:34.197]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.197]                       fi <- file.info(pathname)
[13:21:34.197]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:34.197]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.197]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:34.197]                         fi[["size"]], fi[["mtime"]])
[13:21:34.197]                       stop(msg)
[13:21:34.197]                     }
[13:21:34.197]                     invisible(pathname)
[13:21:34.197]                   }
[13:21:34.197]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:34.197]                     rootPath = tempdir()) 
[13:21:34.197]                   {
[13:21:34.197]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:34.197]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:34.197]                       tmpdir = path, fileext = ".rds")
[13:21:34.197]                     save_rds(obj, file)
[13:21:34.197]                   }
[13:21:34.197]                   saveImmediateCondition(cond, path = "/tmp/RtmpbpFWGO/.future/immediateConditions")
[13:21:34.197]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.197]                   {
[13:21:34.197]                     inherits <- base::inherits
[13:21:34.197]                     invokeRestart <- base::invokeRestart
[13:21:34.197]                     is.null <- base::is.null
[13:21:34.197]                     muffled <- FALSE
[13:21:34.197]                     if (inherits(cond, "message")) {
[13:21:34.197]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:34.197]                       if (muffled) 
[13:21:34.197]                         invokeRestart("muffleMessage")
[13:21:34.197]                     }
[13:21:34.197]                     else if (inherits(cond, "warning")) {
[13:21:34.197]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:34.197]                       if (muffled) 
[13:21:34.197]                         invokeRestart("muffleWarning")
[13:21:34.197]                     }
[13:21:34.197]                     else if (inherits(cond, "condition")) {
[13:21:34.197]                       if (!is.null(pattern)) {
[13:21:34.197]                         computeRestarts <- base::computeRestarts
[13:21:34.197]                         grepl <- base::grepl
[13:21:34.197]                         restarts <- computeRestarts(cond)
[13:21:34.197]                         for (restart in restarts) {
[13:21:34.197]                           name <- restart$name
[13:21:34.197]                           if (is.null(name)) 
[13:21:34.197]                             next
[13:21:34.197]                           if (!grepl(pattern, name)) 
[13:21:34.197]                             next
[13:21:34.197]                           invokeRestart(restart)
[13:21:34.197]                           muffled <- TRUE
[13:21:34.197]                           break
[13:21:34.197]                         }
[13:21:34.197]                       }
[13:21:34.197]                     }
[13:21:34.197]                     invisible(muffled)
[13:21:34.197]                   }
[13:21:34.197]                   muffleCondition(cond)
[13:21:34.197]                 })
[13:21:34.197]             }))
[13:21:34.197]             future::FutureResult(value = ...future.value$value, 
[13:21:34.197]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:34.197]                   ...future.rng), globalenv = if (FALSE) 
[13:21:34.197]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:34.197]                     ...future.globalenv.names))
[13:21:34.197]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:34.197]         }, condition = base::local({
[13:21:34.197]             c <- base::c
[13:21:34.197]             inherits <- base::inherits
[13:21:34.197]             invokeRestart <- base::invokeRestart
[13:21:34.197]             length <- base::length
[13:21:34.197]             list <- base::list
[13:21:34.197]             seq.int <- base::seq.int
[13:21:34.197]             signalCondition <- base::signalCondition
[13:21:34.197]             sys.calls <- base::sys.calls
[13:21:34.197]             `[[` <- base::`[[`
[13:21:34.197]             `+` <- base::`+`
[13:21:34.197]             `<<-` <- base::`<<-`
[13:21:34.197]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:34.197]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:34.197]                   3L)]
[13:21:34.197]             }
[13:21:34.197]             function(cond) {
[13:21:34.197]                 is_error <- inherits(cond, "error")
[13:21:34.197]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:34.197]                   NULL)
[13:21:34.197]                 if (is_error) {
[13:21:34.197]                   sessionInformation <- function() {
[13:21:34.197]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:34.197]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:34.197]                       search = base::search(), system = base::Sys.info())
[13:21:34.197]                   }
[13:21:34.197]                   ...future.conditions[[length(...future.conditions) + 
[13:21:34.197]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:34.197]                     cond$call), session = sessionInformation(), 
[13:21:34.197]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:34.197]                   signalCondition(cond)
[13:21:34.197]                 }
[13:21:34.197]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:34.197]                 "immediateCondition"))) {
[13:21:34.197]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:34.197]                   ...future.conditions[[length(...future.conditions) + 
[13:21:34.197]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:34.197]                   if (TRUE && !signal) {
[13:21:34.197]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.197]                     {
[13:21:34.197]                       inherits <- base::inherits
[13:21:34.197]                       invokeRestart <- base::invokeRestart
[13:21:34.197]                       is.null <- base::is.null
[13:21:34.197]                       muffled <- FALSE
[13:21:34.197]                       if (inherits(cond, "message")) {
[13:21:34.197]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:34.197]                         if (muffled) 
[13:21:34.197]                           invokeRestart("muffleMessage")
[13:21:34.197]                       }
[13:21:34.197]                       else if (inherits(cond, "warning")) {
[13:21:34.197]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:34.197]                         if (muffled) 
[13:21:34.197]                           invokeRestart("muffleWarning")
[13:21:34.197]                       }
[13:21:34.197]                       else if (inherits(cond, "condition")) {
[13:21:34.197]                         if (!is.null(pattern)) {
[13:21:34.197]                           computeRestarts <- base::computeRestarts
[13:21:34.197]                           grepl <- base::grepl
[13:21:34.197]                           restarts <- computeRestarts(cond)
[13:21:34.197]                           for (restart in restarts) {
[13:21:34.197]                             name <- restart$name
[13:21:34.197]                             if (is.null(name)) 
[13:21:34.197]                               next
[13:21:34.197]                             if (!grepl(pattern, name)) 
[13:21:34.197]                               next
[13:21:34.197]                             invokeRestart(restart)
[13:21:34.197]                             muffled <- TRUE
[13:21:34.197]                             break
[13:21:34.197]                           }
[13:21:34.197]                         }
[13:21:34.197]                       }
[13:21:34.197]                       invisible(muffled)
[13:21:34.197]                     }
[13:21:34.197]                     muffleCondition(cond, pattern = "^muffle")
[13:21:34.197]                   }
[13:21:34.197]                 }
[13:21:34.197]                 else {
[13:21:34.197]                   if (TRUE) {
[13:21:34.197]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.197]                     {
[13:21:34.197]                       inherits <- base::inherits
[13:21:34.197]                       invokeRestart <- base::invokeRestart
[13:21:34.197]                       is.null <- base::is.null
[13:21:34.197]                       muffled <- FALSE
[13:21:34.197]                       if (inherits(cond, "message")) {
[13:21:34.197]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:34.197]                         if (muffled) 
[13:21:34.197]                           invokeRestart("muffleMessage")
[13:21:34.197]                       }
[13:21:34.197]                       else if (inherits(cond, "warning")) {
[13:21:34.197]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:34.197]                         if (muffled) 
[13:21:34.197]                           invokeRestart("muffleWarning")
[13:21:34.197]                       }
[13:21:34.197]                       else if (inherits(cond, "condition")) {
[13:21:34.197]                         if (!is.null(pattern)) {
[13:21:34.197]                           computeRestarts <- base::computeRestarts
[13:21:34.197]                           grepl <- base::grepl
[13:21:34.197]                           restarts <- computeRestarts(cond)
[13:21:34.197]                           for (restart in restarts) {
[13:21:34.197]                             name <- restart$name
[13:21:34.197]                             if (is.null(name)) 
[13:21:34.197]                               next
[13:21:34.197]                             if (!grepl(pattern, name)) 
[13:21:34.197]                               next
[13:21:34.197]                             invokeRestart(restart)
[13:21:34.197]                             muffled <- TRUE
[13:21:34.197]                             break
[13:21:34.197]                           }
[13:21:34.197]                         }
[13:21:34.197]                       }
[13:21:34.197]                       invisible(muffled)
[13:21:34.197]                     }
[13:21:34.197]                     muffleCondition(cond, pattern = "^muffle")
[13:21:34.197]                   }
[13:21:34.197]                 }
[13:21:34.197]             }
[13:21:34.197]         }))
[13:21:34.197]     }, error = function(ex) {
[13:21:34.197]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:34.197]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:34.197]                 ...future.rng), started = ...future.startTime, 
[13:21:34.197]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:34.197]             version = "1.8"), class = "FutureResult")
[13:21:34.197]     }, finally = {
[13:21:34.197]         if (!identical(...future.workdir, getwd())) 
[13:21:34.197]             setwd(...future.workdir)
[13:21:34.197]         {
[13:21:34.197]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:34.197]                 ...future.oldOptions$nwarnings <- NULL
[13:21:34.197]             }
[13:21:34.197]             base::options(...future.oldOptions)
[13:21:34.197]             if (.Platform$OS.type == "windows") {
[13:21:34.197]                 old_names <- names(...future.oldEnvVars)
[13:21:34.197]                 envs <- base::Sys.getenv()
[13:21:34.197]                 names <- names(envs)
[13:21:34.197]                 common <- intersect(names, old_names)
[13:21:34.197]                 added <- setdiff(names, old_names)
[13:21:34.197]                 removed <- setdiff(old_names, names)
[13:21:34.197]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:34.197]                   envs[common]]
[13:21:34.197]                 NAMES <- toupper(changed)
[13:21:34.197]                 args <- list()
[13:21:34.197]                 for (kk in seq_along(NAMES)) {
[13:21:34.197]                   name <- changed[[kk]]
[13:21:34.197]                   NAME <- NAMES[[kk]]
[13:21:34.197]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.197]                     next
[13:21:34.197]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:34.197]                 }
[13:21:34.197]                 NAMES <- toupper(added)
[13:21:34.197]                 for (kk in seq_along(NAMES)) {
[13:21:34.197]                   name <- added[[kk]]
[13:21:34.197]                   NAME <- NAMES[[kk]]
[13:21:34.197]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.197]                     next
[13:21:34.197]                   args[[name]] <- ""
[13:21:34.197]                 }
[13:21:34.197]                 NAMES <- toupper(removed)
[13:21:34.197]                 for (kk in seq_along(NAMES)) {
[13:21:34.197]                   name <- removed[[kk]]
[13:21:34.197]                   NAME <- NAMES[[kk]]
[13:21:34.197]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.197]                     next
[13:21:34.197]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:34.197]                 }
[13:21:34.197]                 if (length(args) > 0) 
[13:21:34.197]                   base::do.call(base::Sys.setenv, args = args)
[13:21:34.197]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:34.197]             }
[13:21:34.197]             else {
[13:21:34.197]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:34.197]             }
[13:21:34.197]             {
[13:21:34.197]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:34.197]                   0L) {
[13:21:34.197]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:34.197]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:34.197]                   base::options(opts)
[13:21:34.197]                 }
[13:21:34.197]                 {
[13:21:34.197]                   {
[13:21:34.197]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:34.197]                     NULL
[13:21:34.197]                   }
[13:21:34.197]                   options(future.plan = NULL)
[13:21:34.197]                   if (is.na(NA_character_)) 
[13:21:34.197]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:34.197]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:34.197]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:34.197]                     envir = parent.frame()) 
[13:21:34.197]                   {
[13:21:34.197]                     default_workers <- missing(workers)
[13:21:34.197]                     if (is.function(workers)) 
[13:21:34.197]                       workers <- workers()
[13:21:34.197]                     workers <- structure(as.integer(workers), 
[13:21:34.197]                       class = class(workers))
[13:21:34.197]                     stop_if_not(is.finite(workers), workers >= 
[13:21:34.197]                       1L)
[13:21:34.197]                     if ((workers == 1L && !inherits(workers, 
[13:21:34.197]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:34.197]                       if (default_workers) 
[13:21:34.197]                         supportsMulticore(warn = TRUE)
[13:21:34.197]                       return(sequential(..., envir = envir))
[13:21:34.197]                     }
[13:21:34.197]                     oopts <- options(mc.cores = workers)
[13:21:34.197]                     on.exit(options(oopts))
[13:21:34.197]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:34.197]                       envir = envir)
[13:21:34.197]                     if (!future$lazy) 
[13:21:34.197]                       future <- run(future)
[13:21:34.197]                     invisible(future)
[13:21:34.197]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:34.197]                 }
[13:21:34.197]             }
[13:21:34.197]         }
[13:21:34.197]     })
[13:21:34.197]     if (TRUE) {
[13:21:34.197]         base::sink(type = "output", split = FALSE)
[13:21:34.197]         if (TRUE) {
[13:21:34.197]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:34.197]         }
[13:21:34.197]         else {
[13:21:34.197]             ...future.result["stdout"] <- base::list(NULL)
[13:21:34.197]         }
[13:21:34.197]         base::close(...future.stdout)
[13:21:34.197]         ...future.stdout <- NULL
[13:21:34.197]     }
[13:21:34.197]     ...future.result$conditions <- ...future.conditions
[13:21:34.197]     ...future.result$finished <- base::Sys.time()
[13:21:34.197]     ...future.result
[13:21:34.197] }
[13:21:34.199] assign_globals() ...
[13:21:34.200] List of 11
[13:21:34.200]  $ ...future.FUN            :function (x, ...)  
[13:21:34.200]  $ x_FUN                    :function (x)  
[13:21:34.200]  $ times                    : int 4
[13:21:34.200]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:34.200]  $ stop_if_not              :function (...)  
[13:21:34.200]  $ dim                      : int [1:2] 2 2
[13:21:34.200]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:21:34.200]  $ future.call.arguments    : list()
[13:21:34.200]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:34.200]  $ ...future.elements_ii    :List of 5
[13:21:34.200]   ..$ : int 1
[13:21:34.200]   ..$ : int 2
[13:21:34.200]   ..$ : int 3
[13:21:34.200]   ..$ : int 4
[13:21:34.200]   ..$ : int 5
[13:21:34.200]  $ ...future.seeds_ii       : NULL
[13:21:34.200]  $ ...future.globals.maxSize: NULL
[13:21:34.200]  - attr(*, "where")=List of 11
[13:21:34.200]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:34.200]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:34.200]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:34.200]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:34.200]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:34.200]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:34.200]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:34.200]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:34.200]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:34.200]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:34.200]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:34.200]  - attr(*, "resolved")= logi FALSE
[13:21:34.200]  - attr(*, "total_size")= num 97304
[13:21:34.200]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:34.200]  - attr(*, "already-done")= logi TRUE
[13:21:34.212] - copied ‘...future.FUN’ to environment
[13:21:34.212] - reassign environment for ‘x_FUN’
[13:21:34.212] - copied ‘x_FUN’ to environment
[13:21:34.212] - copied ‘times’ to environment
[13:21:34.212] - copied ‘stopf’ to environment
[13:21:34.212] - copied ‘stop_if_not’ to environment
[13:21:34.213] - copied ‘dim’ to environment
[13:21:34.213] - copied ‘valid_types’ to environment
[13:21:34.213] - copied ‘future.call.arguments’ to environment
[13:21:34.213] - copied ‘...future.elements_ii’ to environment
[13:21:34.213] - copied ‘...future.seeds_ii’ to environment
[13:21:34.213] - copied ‘...future.globals.maxSize’ to environment
[13:21:34.213] assign_globals() ... done
[13:21:34.213] requestCore(): workers = 2
[13:21:34.216] MulticoreFuture started
[13:21:34.216] - Launch lazy future ... done
[13:21:34.216] run() for ‘MulticoreFuture’ ... done
[13:21:34.217] Created future:
[13:21:34.217] plan(): Setting new future strategy stack:
[13:21:34.217] List of future strategies:
[13:21:34.217] 1. sequential:
[13:21:34.217]    - args: function (..., envir = parent.frame())
[13:21:34.217]    - tweaked: FALSE
[13:21:34.217]    - call: NULL
[13:21:34.218] plan(): nbrOfWorkers() = 1
[13:21:34.220] plan(): Setting new future strategy stack:
[13:21:34.221] List of future strategies:
[13:21:34.221] 1. multicore:
[13:21:34.221]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:34.221]    - tweaked: FALSE
[13:21:34.221]    - call: plan(strategy)
[13:21:34.226] plan(): nbrOfWorkers() = 2
[13:21:34.217] MulticoreFuture:
[13:21:34.217] Label: ‘future_vapply-1’
[13:21:34.217] Expression:
[13:21:34.217] {
[13:21:34.217]     do.call(function(...) {
[13:21:34.217]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.217]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:34.217]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.217]             on.exit(options(oopts), add = TRUE)
[13:21:34.217]         }
[13:21:34.217]         {
[13:21:34.217]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:34.217]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.217]                 ...future.FUN(...future.X_jj, ...)
[13:21:34.217]             })
[13:21:34.217]         }
[13:21:34.217]     }, args = future.call.arguments)
[13:21:34.217] }
[13:21:34.217] Lazy evaluation: FALSE
[13:21:34.217] Asynchronous evaluation: TRUE
[13:21:34.217] Local evaluation: TRUE
[13:21:34.217] Environment: R_GlobalEnv
[13:21:34.217] Capture standard output: TRUE
[13:21:34.217] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:34.217] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:34.217] Packages: 1 packages (‘future.apply’)
[13:21:34.217] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:34.217] Resolved: TRUE
[13:21:34.217] Value: <not collected>
[13:21:34.217] Conditions captured: <none>
[13:21:34.217] Early signaling: FALSE
[13:21:34.217] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:34.217] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:34.227] Chunk #1 of 2 ... DONE
[13:21:34.228] Chunk #2 of 2 ...
[13:21:34.228]  - Finding globals in 'X' for chunk #2 ...
[13:21:34.228] getGlobalsAndPackages() ...
[13:21:34.228] Searching for globals...
[13:21:34.229] 
[13:21:34.229] Searching for globals ... DONE
[13:21:34.229] - globals: [0] <none>
[13:21:34.229] getGlobalsAndPackages() ... DONE
[13:21:34.229]    + additional globals found: [n=0] 
[13:21:34.230]    + additional namespaces needed: [n=0] 
[13:21:34.230]  - Finding globals in 'X' for chunk #2 ... DONE
[13:21:34.230]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:34.230]  - seeds: <none>
[13:21:34.230]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.230] getGlobalsAndPackages() ...
[13:21:34.230] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.231] Resolving globals: FALSE
[13:21:34.231] Tweak future expression to call with '...' arguments ...
[13:21:34.231] {
[13:21:34.231]     do.call(function(...) {
[13:21:34.231]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.231]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:34.231]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.231]             on.exit(options(oopts), add = TRUE)
[13:21:34.231]         }
[13:21:34.231]         {
[13:21:34.231]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:34.231]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.231]                 ...future.FUN(...future.X_jj, ...)
[13:21:34.231]             })
[13:21:34.231]         }
[13:21:34.231]     }, args = future.call.arguments)
[13:21:34.231] }
[13:21:34.232] Tweak future expression to call with '...' arguments ... DONE
[13:21:34.233] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.233] - packages: [1] ‘future.apply’
[13:21:34.233] getGlobalsAndPackages() ... DONE
[13:21:34.233] run() for ‘Future’ ...
[13:21:34.234] - state: ‘created’
[13:21:34.234] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:34.239] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:34.239] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:34.239]   - Field: ‘label’
[13:21:34.239]   - Field: ‘local’
[13:21:34.239]   - Field: ‘owner’
[13:21:34.239]   - Field: ‘envir’
[13:21:34.240]   - Field: ‘workers’
[13:21:34.240]   - Field: ‘packages’
[13:21:34.240]   - Field: ‘gc’
[13:21:34.240]   - Field: ‘job’
[13:21:34.240]   - Field: ‘conditions’
[13:21:34.240]   - Field: ‘expr’
[13:21:34.241]   - Field: ‘uuid’
[13:21:34.241]   - Field: ‘seed’
[13:21:34.241]   - Field: ‘version’
[13:21:34.241]   - Field: ‘result’
[13:21:34.241]   - Field: ‘asynchronous’
[13:21:34.241]   - Field: ‘calls’
[13:21:34.241]   - Field: ‘globals’
[13:21:34.242]   - Field: ‘stdout’
[13:21:34.242]   - Field: ‘earlySignal’
[13:21:34.242]   - Field: ‘lazy’
[13:21:34.242]   - Field: ‘state’
[13:21:34.242] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:34.242] - Launch lazy future ...
[13:21:34.243] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:34.243] Packages needed by future strategies (n = 0): <none>
[13:21:34.244] {
[13:21:34.244]     {
[13:21:34.244]         {
[13:21:34.244]             ...future.startTime <- base::Sys.time()
[13:21:34.244]             {
[13:21:34.244]                 {
[13:21:34.244]                   {
[13:21:34.244]                     {
[13:21:34.244]                       {
[13:21:34.244]                         base::local({
[13:21:34.244]                           has_future <- base::requireNamespace("future", 
[13:21:34.244]                             quietly = TRUE)
[13:21:34.244]                           if (has_future) {
[13:21:34.244]                             ns <- base::getNamespace("future")
[13:21:34.244]                             version <- ns[[".package"]][["version"]]
[13:21:34.244]                             if (is.null(version)) 
[13:21:34.244]                               version <- utils::packageVersion("future")
[13:21:34.244]                           }
[13:21:34.244]                           else {
[13:21:34.244]                             version <- NULL
[13:21:34.244]                           }
[13:21:34.244]                           if (!has_future || version < "1.8.0") {
[13:21:34.244]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:34.244]                               "", base::R.version$version.string), 
[13:21:34.244]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:34.244]                                 base::R.version$platform, 8 * 
[13:21:34.244]                                   base::.Machine$sizeof.pointer), 
[13:21:34.244]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:34.244]                                 "release", "version")], collapse = " "), 
[13:21:34.244]                               hostname = base::Sys.info()[["nodename"]])
[13:21:34.244]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:34.244]                               info)
[13:21:34.244]                             info <- base::paste(info, collapse = "; ")
[13:21:34.244]                             if (!has_future) {
[13:21:34.244]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:34.244]                                 info)
[13:21:34.244]                             }
[13:21:34.244]                             else {
[13:21:34.244]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:34.244]                                 info, version)
[13:21:34.244]                             }
[13:21:34.244]                             base::stop(msg)
[13:21:34.244]                           }
[13:21:34.244]                         })
[13:21:34.244]                       }
[13:21:34.244]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:34.244]                       base::options(mc.cores = 1L)
[13:21:34.244]                     }
[13:21:34.244]                     base::local({
[13:21:34.244]                       for (pkg in "future.apply") {
[13:21:34.244]                         base::loadNamespace(pkg)
[13:21:34.244]                         base::library(pkg, character.only = TRUE)
[13:21:34.244]                       }
[13:21:34.244]                     })
[13:21:34.244]                   }
[13:21:34.244]                   options(future.plan = NULL)
[13:21:34.244]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:34.244]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:34.244]                 }
[13:21:34.244]                 ...future.workdir <- getwd()
[13:21:34.244]             }
[13:21:34.244]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:34.244]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:34.244]         }
[13:21:34.244]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:34.244]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:34.244]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:34.244]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:34.244]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:34.244]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:34.244]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:34.244]             base::names(...future.oldOptions))
[13:21:34.244]     }
[13:21:34.244]     if (FALSE) {
[13:21:34.244]     }
[13:21:34.244]     else {
[13:21:34.244]         if (TRUE) {
[13:21:34.244]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:34.244]                 open = "w")
[13:21:34.244]         }
[13:21:34.244]         else {
[13:21:34.244]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:34.244]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:34.244]         }
[13:21:34.244]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:34.244]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:34.244]             base::sink(type = "output", split = FALSE)
[13:21:34.244]             base::close(...future.stdout)
[13:21:34.244]         }, add = TRUE)
[13:21:34.244]     }
[13:21:34.244]     ...future.frame <- base::sys.nframe()
[13:21:34.244]     ...future.conditions <- base::list()
[13:21:34.244]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:34.244]     if (FALSE) {
[13:21:34.244]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:34.244]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:34.244]     }
[13:21:34.244]     ...future.result <- base::tryCatch({
[13:21:34.244]         base::withCallingHandlers({
[13:21:34.244]             ...future.value <- base::withVisible(base::local({
[13:21:34.244]                 withCallingHandlers({
[13:21:34.244]                   {
[13:21:34.244]                     do.call(function(...) {
[13:21:34.244]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.244]                       if (!identical(...future.globals.maxSize.org, 
[13:21:34.244]                         ...future.globals.maxSize)) {
[13:21:34.244]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.244]                         on.exit(options(oopts), add = TRUE)
[13:21:34.244]                       }
[13:21:34.244]                       {
[13:21:34.244]                         lapply(seq_along(...future.elements_ii), 
[13:21:34.244]                           FUN = function(jj) {
[13:21:34.244]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.244]                             ...future.FUN(...future.X_jj, ...)
[13:21:34.244]                           })
[13:21:34.244]                       }
[13:21:34.244]                     }, args = future.call.arguments)
[13:21:34.244]                   }
[13:21:34.244]                 }, immediateCondition = function(cond) {
[13:21:34.244]                   save_rds <- function (object, pathname, ...) 
[13:21:34.244]                   {
[13:21:34.244]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:34.244]                     if (file_test("-f", pathname_tmp)) {
[13:21:34.244]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.244]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:34.244]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.244]                         fi_tmp[["mtime"]])
[13:21:34.244]                     }
[13:21:34.244]                     tryCatch({
[13:21:34.244]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:34.244]                     }, error = function(ex) {
[13:21:34.244]                       msg <- conditionMessage(ex)
[13:21:34.244]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.244]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:34.244]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.244]                         fi_tmp[["mtime"]], msg)
[13:21:34.244]                       ex$message <- msg
[13:21:34.244]                       stop(ex)
[13:21:34.244]                     })
[13:21:34.244]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:34.244]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:34.244]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:34.244]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.244]                       fi <- file.info(pathname)
[13:21:34.244]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:34.244]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.244]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:34.244]                         fi[["size"]], fi[["mtime"]])
[13:21:34.244]                       stop(msg)
[13:21:34.244]                     }
[13:21:34.244]                     invisible(pathname)
[13:21:34.244]                   }
[13:21:34.244]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:34.244]                     rootPath = tempdir()) 
[13:21:34.244]                   {
[13:21:34.244]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:34.244]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:34.244]                       tmpdir = path, fileext = ".rds")
[13:21:34.244]                     save_rds(obj, file)
[13:21:34.244]                   }
[13:21:34.244]                   saveImmediateCondition(cond, path = "/tmp/RtmpbpFWGO/.future/immediateConditions")
[13:21:34.244]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.244]                   {
[13:21:34.244]                     inherits <- base::inherits
[13:21:34.244]                     invokeRestart <- base::invokeRestart
[13:21:34.244]                     is.null <- base::is.null
[13:21:34.244]                     muffled <- FALSE
[13:21:34.244]                     if (inherits(cond, "message")) {
[13:21:34.244]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:34.244]                       if (muffled) 
[13:21:34.244]                         invokeRestart("muffleMessage")
[13:21:34.244]                     }
[13:21:34.244]                     else if (inherits(cond, "warning")) {
[13:21:34.244]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:34.244]                       if (muffled) 
[13:21:34.244]                         invokeRestart("muffleWarning")
[13:21:34.244]                     }
[13:21:34.244]                     else if (inherits(cond, "condition")) {
[13:21:34.244]                       if (!is.null(pattern)) {
[13:21:34.244]                         computeRestarts <- base::computeRestarts
[13:21:34.244]                         grepl <- base::grepl
[13:21:34.244]                         restarts <- computeRestarts(cond)
[13:21:34.244]                         for (restart in restarts) {
[13:21:34.244]                           name <- restart$name
[13:21:34.244]                           if (is.null(name)) 
[13:21:34.244]                             next
[13:21:34.244]                           if (!grepl(pattern, name)) 
[13:21:34.244]                             next
[13:21:34.244]                           invokeRestart(restart)
[13:21:34.244]                           muffled <- TRUE
[13:21:34.244]                           break
[13:21:34.244]                         }
[13:21:34.244]                       }
[13:21:34.244]                     }
[13:21:34.244]                     invisible(muffled)
[13:21:34.244]                   }
[13:21:34.244]                   muffleCondition(cond)
[13:21:34.244]                 })
[13:21:34.244]             }))
[13:21:34.244]             future::FutureResult(value = ...future.value$value, 
[13:21:34.244]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:34.244]                   ...future.rng), globalenv = if (FALSE) 
[13:21:34.244]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:34.244]                     ...future.globalenv.names))
[13:21:34.244]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:34.244]         }, condition = base::local({
[13:21:34.244]             c <- base::c
[13:21:34.244]             inherits <- base::inherits
[13:21:34.244]             invokeRestart <- base::invokeRestart
[13:21:34.244]             length <- base::length
[13:21:34.244]             list <- base::list
[13:21:34.244]             seq.int <- base::seq.int
[13:21:34.244]             signalCondition <- base::signalCondition
[13:21:34.244]             sys.calls <- base::sys.calls
[13:21:34.244]             `[[` <- base::`[[`
[13:21:34.244]             `+` <- base::`+`
[13:21:34.244]             `<<-` <- base::`<<-`
[13:21:34.244]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:34.244]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:34.244]                   3L)]
[13:21:34.244]             }
[13:21:34.244]             function(cond) {
[13:21:34.244]                 is_error <- inherits(cond, "error")
[13:21:34.244]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:34.244]                   NULL)
[13:21:34.244]                 if (is_error) {
[13:21:34.244]                   sessionInformation <- function() {
[13:21:34.244]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:34.244]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:34.244]                       search = base::search(), system = base::Sys.info())
[13:21:34.244]                   }
[13:21:34.244]                   ...future.conditions[[length(...future.conditions) + 
[13:21:34.244]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:34.244]                     cond$call), session = sessionInformation(), 
[13:21:34.244]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:34.244]                   signalCondition(cond)
[13:21:34.244]                 }
[13:21:34.244]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:34.244]                 "immediateCondition"))) {
[13:21:34.244]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:34.244]                   ...future.conditions[[length(...future.conditions) + 
[13:21:34.244]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:34.244]                   if (TRUE && !signal) {
[13:21:34.244]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.244]                     {
[13:21:34.244]                       inherits <- base::inherits
[13:21:34.244]                       invokeRestart <- base::invokeRestart
[13:21:34.244]                       is.null <- base::is.null
[13:21:34.244]                       muffled <- FALSE
[13:21:34.244]                       if (inherits(cond, "message")) {
[13:21:34.244]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:34.244]                         if (muffled) 
[13:21:34.244]                           invokeRestart("muffleMessage")
[13:21:34.244]                       }
[13:21:34.244]                       else if (inherits(cond, "warning")) {
[13:21:34.244]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:34.244]                         if (muffled) 
[13:21:34.244]                           invokeRestart("muffleWarning")
[13:21:34.244]                       }
[13:21:34.244]                       else if (inherits(cond, "condition")) {
[13:21:34.244]                         if (!is.null(pattern)) {
[13:21:34.244]                           computeRestarts <- base::computeRestarts
[13:21:34.244]                           grepl <- base::grepl
[13:21:34.244]                           restarts <- computeRestarts(cond)
[13:21:34.244]                           for (restart in restarts) {
[13:21:34.244]                             name <- restart$name
[13:21:34.244]                             if (is.null(name)) 
[13:21:34.244]                               next
[13:21:34.244]                             if (!grepl(pattern, name)) 
[13:21:34.244]                               next
[13:21:34.244]                             invokeRestart(restart)
[13:21:34.244]                             muffled <- TRUE
[13:21:34.244]                             break
[13:21:34.244]                           }
[13:21:34.244]                         }
[13:21:34.244]                       }
[13:21:34.244]                       invisible(muffled)
[13:21:34.244]                     }
[13:21:34.244]                     muffleCondition(cond, pattern = "^muffle")
[13:21:34.244]                   }
[13:21:34.244]                 }
[13:21:34.244]                 else {
[13:21:34.244]                   if (TRUE) {
[13:21:34.244]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.244]                     {
[13:21:34.244]                       inherits <- base::inherits
[13:21:34.244]                       invokeRestart <- base::invokeRestart
[13:21:34.244]                       is.null <- base::is.null
[13:21:34.244]                       muffled <- FALSE
[13:21:34.244]                       if (inherits(cond, "message")) {
[13:21:34.244]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:34.244]                         if (muffled) 
[13:21:34.244]                           invokeRestart("muffleMessage")
[13:21:34.244]                       }
[13:21:34.244]                       else if (inherits(cond, "warning")) {
[13:21:34.244]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:34.244]                         if (muffled) 
[13:21:34.244]                           invokeRestart("muffleWarning")
[13:21:34.244]                       }
[13:21:34.244]                       else if (inherits(cond, "condition")) {
[13:21:34.244]                         if (!is.null(pattern)) {
[13:21:34.244]                           computeRestarts <- base::computeRestarts
[13:21:34.244]                           grepl <- base::grepl
[13:21:34.244]                           restarts <- computeRestarts(cond)
[13:21:34.244]                           for (restart in restarts) {
[13:21:34.244]                             name <- restart$name
[13:21:34.244]                             if (is.null(name)) 
[13:21:34.244]                               next
[13:21:34.244]                             if (!grepl(pattern, name)) 
[13:21:34.244]                               next
[13:21:34.244]                             invokeRestart(restart)
[13:21:34.244]                             muffled <- TRUE
[13:21:34.244]                             break
[13:21:34.244]                           }
[13:21:34.244]                         }
[13:21:34.244]                       }
[13:21:34.244]                       invisible(muffled)
[13:21:34.244]                     }
[13:21:34.244]                     muffleCondition(cond, pattern = "^muffle")
[13:21:34.244]                   }
[13:21:34.244]                 }
[13:21:34.244]             }
[13:21:34.244]         }))
[13:21:34.244]     }, error = function(ex) {
[13:21:34.244]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:34.244]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:34.244]                 ...future.rng), started = ...future.startTime, 
[13:21:34.244]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:34.244]             version = "1.8"), class = "FutureResult")
[13:21:34.244]     }, finally = {
[13:21:34.244]         if (!identical(...future.workdir, getwd())) 
[13:21:34.244]             setwd(...future.workdir)
[13:21:34.244]         {
[13:21:34.244]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:34.244]                 ...future.oldOptions$nwarnings <- NULL
[13:21:34.244]             }
[13:21:34.244]             base::options(...future.oldOptions)
[13:21:34.244]             if (.Platform$OS.type == "windows") {
[13:21:34.244]                 old_names <- names(...future.oldEnvVars)
[13:21:34.244]                 envs <- base::Sys.getenv()
[13:21:34.244]                 names <- names(envs)
[13:21:34.244]                 common <- intersect(names, old_names)
[13:21:34.244]                 added <- setdiff(names, old_names)
[13:21:34.244]                 removed <- setdiff(old_names, names)
[13:21:34.244]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:34.244]                   envs[common]]
[13:21:34.244]                 NAMES <- toupper(changed)
[13:21:34.244]                 args <- list()
[13:21:34.244]                 for (kk in seq_along(NAMES)) {
[13:21:34.244]                   name <- changed[[kk]]
[13:21:34.244]                   NAME <- NAMES[[kk]]
[13:21:34.244]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.244]                     next
[13:21:34.244]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:34.244]                 }
[13:21:34.244]                 NAMES <- toupper(added)
[13:21:34.244]                 for (kk in seq_along(NAMES)) {
[13:21:34.244]                   name <- added[[kk]]
[13:21:34.244]                   NAME <- NAMES[[kk]]
[13:21:34.244]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.244]                     next
[13:21:34.244]                   args[[name]] <- ""
[13:21:34.244]                 }
[13:21:34.244]                 NAMES <- toupper(removed)
[13:21:34.244]                 for (kk in seq_along(NAMES)) {
[13:21:34.244]                   name <- removed[[kk]]
[13:21:34.244]                   NAME <- NAMES[[kk]]
[13:21:34.244]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.244]                     next
[13:21:34.244]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:34.244]                 }
[13:21:34.244]                 if (length(args) > 0) 
[13:21:34.244]                   base::do.call(base::Sys.setenv, args = args)
[13:21:34.244]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:34.244]             }
[13:21:34.244]             else {
[13:21:34.244]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:34.244]             }
[13:21:34.244]             {
[13:21:34.244]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:34.244]                   0L) {
[13:21:34.244]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:34.244]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:34.244]                   base::options(opts)
[13:21:34.244]                 }
[13:21:34.244]                 {
[13:21:34.244]                   {
[13:21:34.244]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:34.244]                     NULL
[13:21:34.244]                   }
[13:21:34.244]                   options(future.plan = NULL)
[13:21:34.244]                   if (is.na(NA_character_)) 
[13:21:34.244]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:34.244]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:34.244]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:34.244]                     envir = parent.frame()) 
[13:21:34.244]                   {
[13:21:34.244]                     default_workers <- missing(workers)
[13:21:34.244]                     if (is.function(workers)) 
[13:21:34.244]                       workers <- workers()
[13:21:34.244]                     workers <- structure(as.integer(workers), 
[13:21:34.244]                       class = class(workers))
[13:21:34.244]                     stop_if_not(is.finite(workers), workers >= 
[13:21:34.244]                       1L)
[13:21:34.244]                     if ((workers == 1L && !inherits(workers, 
[13:21:34.244]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:34.244]                       if (default_workers) 
[13:21:34.244]                         supportsMulticore(warn = TRUE)
[13:21:34.244]                       return(sequential(..., envir = envir))
[13:21:34.244]                     }
[13:21:34.244]                     oopts <- options(mc.cores = workers)
[13:21:34.244]                     on.exit(options(oopts))
[13:21:34.244]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:34.244]                       envir = envir)
[13:21:34.244]                     if (!future$lazy) 
[13:21:34.244]                       future <- run(future)
[13:21:34.244]                     invisible(future)
[13:21:34.244]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:34.244]                 }
[13:21:34.244]             }
[13:21:34.244]         }
[13:21:34.244]     })
[13:21:34.244]     if (TRUE) {
[13:21:34.244]         base::sink(type = "output", split = FALSE)
[13:21:34.244]         if (TRUE) {
[13:21:34.244]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:34.244]         }
[13:21:34.244]         else {
[13:21:34.244]             ...future.result["stdout"] <- base::list(NULL)
[13:21:34.244]         }
[13:21:34.244]         base::close(...future.stdout)
[13:21:34.244]         ...future.stdout <- NULL
[13:21:34.244]     }
[13:21:34.244]     ...future.result$conditions <- ...future.conditions
[13:21:34.244]     ...future.result$finished <- base::Sys.time()
[13:21:34.244]     ...future.result
[13:21:34.244] }
[13:21:34.248] assign_globals() ...
[13:21:34.248] List of 11
[13:21:34.248]  $ ...future.FUN            :function (x, ...)  
[13:21:34.248]  $ x_FUN                    :function (x)  
[13:21:34.248]  $ times                    : int 4
[13:21:34.248]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:34.248]  $ stop_if_not              :function (...)  
[13:21:34.248]  $ dim                      : int [1:2] 2 2
[13:21:34.248]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:21:34.248]  $ future.call.arguments    : list()
[13:21:34.248]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:34.248]  $ ...future.elements_ii    :List of 5
[13:21:34.248]   ..$ : int 6
[13:21:34.248]   ..$ : int 7
[13:21:34.248]   ..$ : int 8
[13:21:34.248]   ..$ : int 9
[13:21:34.248]   ..$ : int 10
[13:21:34.248]  $ ...future.seeds_ii       : NULL
[13:21:34.248]  $ ...future.globals.maxSize: NULL
[13:21:34.248]  - attr(*, "where")=List of 11
[13:21:34.248]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:34.248]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:34.248]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:34.248]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:34.248]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:34.248]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:34.248]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:34.248]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:34.248]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:34.248]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:34.248]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:34.248]  - attr(*, "resolved")= logi FALSE
[13:21:34.248]  - attr(*, "total_size")= num 97304
[13:21:34.248]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:34.248]  - attr(*, "already-done")= logi TRUE
[13:21:34.266] - copied ‘...future.FUN’ to environment
[13:21:34.266] - reassign environment for ‘x_FUN’
[13:21:34.266] - copied ‘x_FUN’ to environment
[13:21:34.267] - copied ‘times’ to environment
[13:21:34.267] - copied ‘stopf’ to environment
[13:21:34.267] - copied ‘stop_if_not’ to environment
[13:21:34.267] - copied ‘dim’ to environment
[13:21:34.267] - copied ‘valid_types’ to environment
[13:21:34.267] - copied ‘future.call.arguments’ to environment
[13:21:34.267] - copied ‘...future.elements_ii’ to environment
[13:21:34.267] - copied ‘...future.seeds_ii’ to environment
[13:21:34.267] - copied ‘...future.globals.maxSize’ to environment
[13:21:34.268] assign_globals() ... done
[13:21:34.268] requestCore(): workers = 2
[13:21:34.270] MulticoreFuture started
[13:21:34.270] - Launch lazy future ... done
[13:21:34.271] run() for ‘MulticoreFuture’ ... done
[13:21:34.271] Created future:
[13:21:34.272] plan(): Setting new future strategy stack:
[13:21:34.272] List of future strategies:
[13:21:34.272] 1. sequential:
[13:21:34.272]    - args: function (..., envir = parent.frame())
[13:21:34.272]    - tweaked: FALSE
[13:21:34.272]    - call: NULL
[13:21:34.273] plan(): nbrOfWorkers() = 1
[13:21:34.275] plan(): Setting new future strategy stack:
[13:21:34.275] List of future strategies:
[13:21:34.275] 1. multicore:
[13:21:34.275]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:34.275]    - tweaked: FALSE
[13:21:34.275]    - call: plan(strategy)
[13:21:34.281] plan(): nbrOfWorkers() = 2
[13:21:34.271] MulticoreFuture:
[13:21:34.271] Label: ‘future_vapply-2’
[13:21:34.271] Expression:
[13:21:34.271] {
[13:21:34.271]     do.call(function(...) {
[13:21:34.271]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.271]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:34.271]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.271]             on.exit(options(oopts), add = TRUE)
[13:21:34.271]         }
[13:21:34.271]         {
[13:21:34.271]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:34.271]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.271]                 ...future.FUN(...future.X_jj, ...)
[13:21:34.271]             })
[13:21:34.271]         }
[13:21:34.271]     }, args = future.call.arguments)
[13:21:34.271] }
[13:21:34.271] Lazy evaluation: FALSE
[13:21:34.271] Asynchronous evaluation: TRUE
[13:21:34.271] Local evaluation: TRUE
[13:21:34.271] Environment: R_GlobalEnv
[13:21:34.271] Capture standard output: TRUE
[13:21:34.271] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:34.271] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:34.271] Packages: 1 packages (‘future.apply’)
[13:21:34.271] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:34.271] Resolved: TRUE
[13:21:34.271] Value: <not collected>
[13:21:34.271] Conditions captured: <none>
[13:21:34.271] Early signaling: FALSE
[13:21:34.271] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:34.271] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:34.282] Chunk #2 of 2 ... DONE
[13:21:34.282] Launching 2 futures (chunks) ... DONE
[13:21:34.282] Resolving 2 futures (chunks) ...
[13:21:34.282] resolve() on list ...
[13:21:34.282]  recursive: 0
[13:21:34.283]  length: 2
[13:21:34.283] 
[13:21:34.283] Future #1
[13:21:34.283] result() for MulticoreFuture ...
[13:21:34.284] result() for MulticoreFuture ...
[13:21:34.284] result() for MulticoreFuture ... done
[13:21:34.284] result() for MulticoreFuture ... done
[13:21:34.285] result() for MulticoreFuture ...
[13:21:34.285] result() for MulticoreFuture ... done
[13:21:34.285] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:21:34.285] - nx: 2
[13:21:34.285] - relay: TRUE
[13:21:34.285] - stdout: TRUE
[13:21:34.286] - signal: TRUE
[13:21:34.286] - resignal: FALSE
[13:21:34.286] - force: TRUE
[13:21:34.286] - relayed: [n=2] FALSE, FALSE
[13:21:34.286] - queued futures: [n=2] FALSE, FALSE
[13:21:34.286]  - until=1
[13:21:34.286]  - relaying element #1
[13:21:34.287] result() for MulticoreFuture ...
[13:21:34.287] result() for MulticoreFuture ... done
[13:21:34.287] result() for MulticoreFuture ...
[13:21:34.287] result() for MulticoreFuture ... done
[13:21:34.287] result() for MulticoreFuture ...
[13:21:34.287] result() for MulticoreFuture ... done
[13:21:34.288] result() for MulticoreFuture ...
[13:21:34.288] result() for MulticoreFuture ... done
[13:21:34.288] - relayed: [n=2] TRUE, FALSE
[13:21:34.288] - queued futures: [n=2] TRUE, FALSE
[13:21:34.288] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:21:34.288]  length: 1 (resolved future 1)
[13:21:34.289] Future #2
[13:21:34.289] result() for MulticoreFuture ...
[13:21:34.290] result() for MulticoreFuture ...
[13:21:34.290] result() for MulticoreFuture ... done
[13:21:34.290] result() for MulticoreFuture ... done
[13:21:34.290] result() for MulticoreFuture ...
[13:21:34.290] result() for MulticoreFuture ... done
[13:21:34.290] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:21:34.290] - nx: 2
[13:21:34.291] - relay: TRUE
[13:21:34.291] - stdout: TRUE
[13:21:34.291] - signal: TRUE
[13:21:34.291] - resignal: FALSE
[13:21:34.291] - force: TRUE
[13:21:34.291] - relayed: [n=2] TRUE, FALSE
[13:21:34.291] - queued futures: [n=2] TRUE, FALSE
[13:21:34.292]  - until=2
[13:21:34.292]  - relaying element #2
[13:21:34.292] result() for MulticoreFuture ...
[13:21:34.292] result() for MulticoreFuture ... done
[13:21:34.292] result() for MulticoreFuture ...
[13:21:34.292] result() for MulticoreFuture ... done
[13:21:34.295] result() for MulticoreFuture ...
[13:21:34.295] result() for MulticoreFuture ... done
[13:21:34.295] result() for MulticoreFuture ...
[13:21:34.295] result() for MulticoreFuture ... done
[13:21:34.296] - relayed: [n=2] TRUE, TRUE
[13:21:34.296] - queued futures: [n=2] TRUE, TRUE
[13:21:34.296] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:21:34.296]  length: 0 (resolved future 2)
[13:21:34.296] Relaying remaining futures
[13:21:34.297] signalConditionsASAP(NULL, pos=0) ...
[13:21:34.297] - nx: 2
[13:21:34.297] - relay: TRUE
[13:21:34.297] - stdout: TRUE
[13:21:34.297] - signal: TRUE
[13:21:34.297] - resignal: FALSE
[13:21:34.297] - force: TRUE
[13:21:34.298] - relayed: [n=2] TRUE, TRUE
[13:21:34.298] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:21:34.298] - relayed: [n=2] TRUE, TRUE
[13:21:34.298] - queued futures: [n=2] TRUE, TRUE
[13:21:34.298] signalConditionsASAP(NULL, pos=0) ... done
[13:21:34.298] resolve() on list ... DONE
[13:21:34.299] result() for MulticoreFuture ...
[13:21:34.299] result() for MulticoreFuture ... done
[13:21:34.299] result() for MulticoreFuture ...
[13:21:34.299] result() for MulticoreFuture ... done
[13:21:34.299] result() for MulticoreFuture ...
[13:21:34.299] result() for MulticoreFuture ... done
[13:21:34.300] result() for MulticoreFuture ...
[13:21:34.300] result() for MulticoreFuture ... done
[13:21:34.300]  - Number of value chunks collected: 2
[13:21:34.300] Resolving 2 futures (chunks) ... DONE
[13:21:34.300] Reducing values from 2 chunks ...
[13:21:34.300]  - Number of values collected after concatenation: 10
[13:21:34.301]  - Number of values expected: 10
[13:21:34.301] Reducing values from 2 chunks ... DONE
[13:21:34.301] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[13:21:34.304] future_lapply() ...
[13:21:34.310] Number of chunks: 2
[13:21:34.311] getGlobalsAndPackagesXApply() ...
[13:21:34.311]  - future.globals: TRUE
[13:21:34.311] getGlobalsAndPackages() ...
[13:21:34.311] Searching for globals...
[13:21:34.315] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[13:21:34.315] Searching for globals ... DONE
[13:21:34.315] Resolving globals: FALSE
[13:21:34.316] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[13:21:34.317] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:34.317] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:34.317] - packages: [1] ‘future.apply’
[13:21:34.317] getGlobalsAndPackages() ... DONE
[13:21:34.317]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:34.318]  - needed namespaces: [n=1] ‘future.apply’
[13:21:34.318] Finding globals ... DONE
[13:21:34.318]  - use_args: TRUE
[13:21:34.318]  - Getting '...' globals ...
[13:21:34.318] resolve() on list ...
[13:21:34.318]  recursive: 0
[13:21:34.318]  length: 1
[13:21:34.318]  elements: ‘...’
[13:21:34.319]  length: 0 (resolved future 1)
[13:21:34.319] resolve() on list ... DONE
[13:21:34.319]    - '...' content: [n=0] 
[13:21:34.319] List of 1
[13:21:34.319]  $ ...: list()
[13:21:34.319]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:34.319]  - attr(*, "where")=List of 1
[13:21:34.319]   ..$ ...:<environment: 0x563b6e38eae0> 
[13:21:34.319]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:34.319]  - attr(*, "resolved")= logi TRUE
[13:21:34.319]  - attr(*, "total_size")= num NA
[13:21:34.324]  - Getting '...' globals ... DONE
[13:21:34.325] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:34.325] List of 8
[13:21:34.325]  $ ...future.FUN:function (x, ...)  
[13:21:34.325]  $ x_FUN        :function (x)  
[13:21:34.325]  $ times        : int 4
[13:21:34.325]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:34.325]  $ stop_if_not  :function (...)  
[13:21:34.325]  $ dim          : int [1:2] 2 2
[13:21:34.325]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:21:34.325]  $ ...          : list()
[13:21:34.325]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:34.325]  - attr(*, "where")=List of 8
[13:21:34.325]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:34.325]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:34.325]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:34.325]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:34.325]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:34.325]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:34.325]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:34.325]   ..$ ...          :<environment: 0x563b6e38eae0> 
[13:21:34.325]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:34.325]  - attr(*, "resolved")= logi FALSE
[13:21:34.325]  - attr(*, "total_size")= num 105552
[13:21:34.331] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:21:34.332] getGlobalsAndPackagesXApply() ... DONE
[13:21:34.332] Number of futures (= number of chunks): 2
[13:21:34.332] Launching 2 futures (chunks) ...
[13:21:34.332] Chunk #1 of 2 ...
[13:21:34.332]  - Finding globals in 'X' for chunk #1 ...
[13:21:34.332] getGlobalsAndPackages() ...
[13:21:34.332] Searching for globals...
[13:21:34.333] 
[13:21:34.333] Searching for globals ... DONE
[13:21:34.333] - globals: [0] <none>
[13:21:34.333] getGlobalsAndPackages() ... DONE
[13:21:34.333]    + additional globals found: [n=0] 
[13:21:34.333]    + additional namespaces needed: [n=0] 
[13:21:34.333]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:34.333]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:34.334]  - seeds: <none>
[13:21:34.334]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.334] getGlobalsAndPackages() ...
[13:21:34.334] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.334] Resolving globals: FALSE
[13:21:34.334] Tweak future expression to call with '...' arguments ...
[13:21:34.334] {
[13:21:34.334]     do.call(function(...) {
[13:21:34.334]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.334]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:34.334]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.334]             on.exit(options(oopts), add = TRUE)
[13:21:34.334]         }
[13:21:34.334]         {
[13:21:34.334]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:34.334]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.334]                 ...future.FUN(...future.X_jj, ...)
[13:21:34.334]             })
[13:21:34.334]         }
[13:21:34.334]     }, args = future.call.arguments)
[13:21:34.334] }
[13:21:34.334] Tweak future expression to call with '...' arguments ... DONE
[13:21:34.335] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.335] - packages: [1] ‘future.apply’
[13:21:34.335] getGlobalsAndPackages() ... DONE
[13:21:34.336] run() for ‘Future’ ...
[13:21:34.336] - state: ‘created’
[13:21:34.336] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:34.340] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:34.340] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:34.340]   - Field: ‘label’
[13:21:34.340]   - Field: ‘local’
[13:21:34.340]   - Field: ‘owner’
[13:21:34.340]   - Field: ‘envir’
[13:21:34.341]   - Field: ‘workers’
[13:21:34.341]   - Field: ‘packages’
[13:21:34.341]   - Field: ‘gc’
[13:21:34.341]   - Field: ‘job’
[13:21:34.341]   - Field: ‘conditions’
[13:21:34.341]   - Field: ‘expr’
[13:21:34.341]   - Field: ‘uuid’
[13:21:34.341]   - Field: ‘seed’
[13:21:34.341]   - Field: ‘version’
[13:21:34.341]   - Field: ‘result’
[13:21:34.341]   - Field: ‘asynchronous’
[13:21:34.342]   - Field: ‘calls’
[13:21:34.342]   - Field: ‘globals’
[13:21:34.342]   - Field: ‘stdout’
[13:21:34.342]   - Field: ‘earlySignal’
[13:21:34.342]   - Field: ‘lazy’
[13:21:34.342]   - Field: ‘state’
[13:21:34.342] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:34.342] - Launch lazy future ...
[13:21:34.343] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:34.343] Packages needed by future strategies (n = 0): <none>
[13:21:34.343] {
[13:21:34.343]     {
[13:21:34.343]         {
[13:21:34.343]             ...future.startTime <- base::Sys.time()
[13:21:34.343]             {
[13:21:34.343]                 {
[13:21:34.343]                   {
[13:21:34.343]                     {
[13:21:34.343]                       {
[13:21:34.343]                         base::local({
[13:21:34.343]                           has_future <- base::requireNamespace("future", 
[13:21:34.343]                             quietly = TRUE)
[13:21:34.343]                           if (has_future) {
[13:21:34.343]                             ns <- base::getNamespace("future")
[13:21:34.343]                             version <- ns[[".package"]][["version"]]
[13:21:34.343]                             if (is.null(version)) 
[13:21:34.343]                               version <- utils::packageVersion("future")
[13:21:34.343]                           }
[13:21:34.343]                           else {
[13:21:34.343]                             version <- NULL
[13:21:34.343]                           }
[13:21:34.343]                           if (!has_future || version < "1.8.0") {
[13:21:34.343]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:34.343]                               "", base::R.version$version.string), 
[13:21:34.343]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:34.343]                                 base::R.version$platform, 8 * 
[13:21:34.343]                                   base::.Machine$sizeof.pointer), 
[13:21:34.343]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:34.343]                                 "release", "version")], collapse = " "), 
[13:21:34.343]                               hostname = base::Sys.info()[["nodename"]])
[13:21:34.343]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:34.343]                               info)
[13:21:34.343]                             info <- base::paste(info, collapse = "; ")
[13:21:34.343]                             if (!has_future) {
[13:21:34.343]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:34.343]                                 info)
[13:21:34.343]                             }
[13:21:34.343]                             else {
[13:21:34.343]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:34.343]                                 info, version)
[13:21:34.343]                             }
[13:21:34.343]                             base::stop(msg)
[13:21:34.343]                           }
[13:21:34.343]                         })
[13:21:34.343]                       }
[13:21:34.343]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:34.343]                       base::options(mc.cores = 1L)
[13:21:34.343]                     }
[13:21:34.343]                     base::local({
[13:21:34.343]                       for (pkg in "future.apply") {
[13:21:34.343]                         base::loadNamespace(pkg)
[13:21:34.343]                         base::library(pkg, character.only = TRUE)
[13:21:34.343]                       }
[13:21:34.343]                     })
[13:21:34.343]                   }
[13:21:34.343]                   options(future.plan = NULL)
[13:21:34.343]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:34.343]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:34.343]                 }
[13:21:34.343]                 ...future.workdir <- getwd()
[13:21:34.343]             }
[13:21:34.343]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:34.343]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:34.343]         }
[13:21:34.343]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:34.343]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:34.343]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:34.343]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:34.343]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:34.343]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:34.343]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:34.343]             base::names(...future.oldOptions))
[13:21:34.343]     }
[13:21:34.343]     if (FALSE) {
[13:21:34.343]     }
[13:21:34.343]     else {
[13:21:34.343]         if (TRUE) {
[13:21:34.343]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:34.343]                 open = "w")
[13:21:34.343]         }
[13:21:34.343]         else {
[13:21:34.343]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:34.343]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:34.343]         }
[13:21:34.343]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:34.343]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:34.343]             base::sink(type = "output", split = FALSE)
[13:21:34.343]             base::close(...future.stdout)
[13:21:34.343]         }, add = TRUE)
[13:21:34.343]     }
[13:21:34.343]     ...future.frame <- base::sys.nframe()
[13:21:34.343]     ...future.conditions <- base::list()
[13:21:34.343]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:34.343]     if (FALSE) {
[13:21:34.343]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:34.343]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:34.343]     }
[13:21:34.343]     ...future.result <- base::tryCatch({
[13:21:34.343]         base::withCallingHandlers({
[13:21:34.343]             ...future.value <- base::withVisible(base::local({
[13:21:34.343]                 withCallingHandlers({
[13:21:34.343]                   {
[13:21:34.343]                     do.call(function(...) {
[13:21:34.343]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.343]                       if (!identical(...future.globals.maxSize.org, 
[13:21:34.343]                         ...future.globals.maxSize)) {
[13:21:34.343]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.343]                         on.exit(options(oopts), add = TRUE)
[13:21:34.343]                       }
[13:21:34.343]                       {
[13:21:34.343]                         lapply(seq_along(...future.elements_ii), 
[13:21:34.343]                           FUN = function(jj) {
[13:21:34.343]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.343]                             ...future.FUN(...future.X_jj, ...)
[13:21:34.343]                           })
[13:21:34.343]                       }
[13:21:34.343]                     }, args = future.call.arguments)
[13:21:34.343]                   }
[13:21:34.343]                 }, immediateCondition = function(cond) {
[13:21:34.343]                   save_rds <- function (object, pathname, ...) 
[13:21:34.343]                   {
[13:21:34.343]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:34.343]                     if (file_test("-f", pathname_tmp)) {
[13:21:34.343]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.343]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:34.343]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.343]                         fi_tmp[["mtime"]])
[13:21:34.343]                     }
[13:21:34.343]                     tryCatch({
[13:21:34.343]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:34.343]                     }, error = function(ex) {
[13:21:34.343]                       msg <- conditionMessage(ex)
[13:21:34.343]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.343]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:34.343]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.343]                         fi_tmp[["mtime"]], msg)
[13:21:34.343]                       ex$message <- msg
[13:21:34.343]                       stop(ex)
[13:21:34.343]                     })
[13:21:34.343]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:34.343]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:34.343]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:34.343]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.343]                       fi <- file.info(pathname)
[13:21:34.343]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:34.343]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.343]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:34.343]                         fi[["size"]], fi[["mtime"]])
[13:21:34.343]                       stop(msg)
[13:21:34.343]                     }
[13:21:34.343]                     invisible(pathname)
[13:21:34.343]                   }
[13:21:34.343]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:34.343]                     rootPath = tempdir()) 
[13:21:34.343]                   {
[13:21:34.343]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:34.343]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:34.343]                       tmpdir = path, fileext = ".rds")
[13:21:34.343]                     save_rds(obj, file)
[13:21:34.343]                   }
[13:21:34.343]                   saveImmediateCondition(cond, path = "/tmp/RtmpbpFWGO/.future/immediateConditions")
[13:21:34.343]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.343]                   {
[13:21:34.343]                     inherits <- base::inherits
[13:21:34.343]                     invokeRestart <- base::invokeRestart
[13:21:34.343]                     is.null <- base::is.null
[13:21:34.343]                     muffled <- FALSE
[13:21:34.343]                     if (inherits(cond, "message")) {
[13:21:34.343]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:34.343]                       if (muffled) 
[13:21:34.343]                         invokeRestart("muffleMessage")
[13:21:34.343]                     }
[13:21:34.343]                     else if (inherits(cond, "warning")) {
[13:21:34.343]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:34.343]                       if (muffled) 
[13:21:34.343]                         invokeRestart("muffleWarning")
[13:21:34.343]                     }
[13:21:34.343]                     else if (inherits(cond, "condition")) {
[13:21:34.343]                       if (!is.null(pattern)) {
[13:21:34.343]                         computeRestarts <- base::computeRestarts
[13:21:34.343]                         grepl <- base::grepl
[13:21:34.343]                         restarts <- computeRestarts(cond)
[13:21:34.343]                         for (restart in restarts) {
[13:21:34.343]                           name <- restart$name
[13:21:34.343]                           if (is.null(name)) 
[13:21:34.343]                             next
[13:21:34.343]                           if (!grepl(pattern, name)) 
[13:21:34.343]                             next
[13:21:34.343]                           invokeRestart(restart)
[13:21:34.343]                           muffled <- TRUE
[13:21:34.343]                           break
[13:21:34.343]                         }
[13:21:34.343]                       }
[13:21:34.343]                     }
[13:21:34.343]                     invisible(muffled)
[13:21:34.343]                   }
[13:21:34.343]                   muffleCondition(cond)
[13:21:34.343]                 })
[13:21:34.343]             }))
[13:21:34.343]             future::FutureResult(value = ...future.value$value, 
[13:21:34.343]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:34.343]                   ...future.rng), globalenv = if (FALSE) 
[13:21:34.343]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:34.343]                     ...future.globalenv.names))
[13:21:34.343]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:34.343]         }, condition = base::local({
[13:21:34.343]             c <- base::c
[13:21:34.343]             inherits <- base::inherits
[13:21:34.343]             invokeRestart <- base::invokeRestart
[13:21:34.343]             length <- base::length
[13:21:34.343]             list <- base::list
[13:21:34.343]             seq.int <- base::seq.int
[13:21:34.343]             signalCondition <- base::signalCondition
[13:21:34.343]             sys.calls <- base::sys.calls
[13:21:34.343]             `[[` <- base::`[[`
[13:21:34.343]             `+` <- base::`+`
[13:21:34.343]             `<<-` <- base::`<<-`
[13:21:34.343]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:34.343]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:34.343]                   3L)]
[13:21:34.343]             }
[13:21:34.343]             function(cond) {
[13:21:34.343]                 is_error <- inherits(cond, "error")
[13:21:34.343]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:34.343]                   NULL)
[13:21:34.343]                 if (is_error) {
[13:21:34.343]                   sessionInformation <- function() {
[13:21:34.343]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:34.343]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:34.343]                       search = base::search(), system = base::Sys.info())
[13:21:34.343]                   }
[13:21:34.343]                   ...future.conditions[[length(...future.conditions) + 
[13:21:34.343]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:34.343]                     cond$call), session = sessionInformation(), 
[13:21:34.343]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:34.343]                   signalCondition(cond)
[13:21:34.343]                 }
[13:21:34.343]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:34.343]                 "immediateCondition"))) {
[13:21:34.343]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:34.343]                   ...future.conditions[[length(...future.conditions) + 
[13:21:34.343]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:34.343]                   if (TRUE && !signal) {
[13:21:34.343]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.343]                     {
[13:21:34.343]                       inherits <- base::inherits
[13:21:34.343]                       invokeRestart <- base::invokeRestart
[13:21:34.343]                       is.null <- base::is.null
[13:21:34.343]                       muffled <- FALSE
[13:21:34.343]                       if (inherits(cond, "message")) {
[13:21:34.343]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:34.343]                         if (muffled) 
[13:21:34.343]                           invokeRestart("muffleMessage")
[13:21:34.343]                       }
[13:21:34.343]                       else if (inherits(cond, "warning")) {
[13:21:34.343]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:34.343]                         if (muffled) 
[13:21:34.343]                           invokeRestart("muffleWarning")
[13:21:34.343]                       }
[13:21:34.343]                       else if (inherits(cond, "condition")) {
[13:21:34.343]                         if (!is.null(pattern)) {
[13:21:34.343]                           computeRestarts <- base::computeRestarts
[13:21:34.343]                           grepl <- base::grepl
[13:21:34.343]                           restarts <- computeRestarts(cond)
[13:21:34.343]                           for (restart in restarts) {
[13:21:34.343]                             name <- restart$name
[13:21:34.343]                             if (is.null(name)) 
[13:21:34.343]                               next
[13:21:34.343]                             if (!grepl(pattern, name)) 
[13:21:34.343]                               next
[13:21:34.343]                             invokeRestart(restart)
[13:21:34.343]                             muffled <- TRUE
[13:21:34.343]                             break
[13:21:34.343]                           }
[13:21:34.343]                         }
[13:21:34.343]                       }
[13:21:34.343]                       invisible(muffled)
[13:21:34.343]                     }
[13:21:34.343]                     muffleCondition(cond, pattern = "^muffle")
[13:21:34.343]                   }
[13:21:34.343]                 }
[13:21:34.343]                 else {
[13:21:34.343]                   if (TRUE) {
[13:21:34.343]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.343]                     {
[13:21:34.343]                       inherits <- base::inherits
[13:21:34.343]                       invokeRestart <- base::invokeRestart
[13:21:34.343]                       is.null <- base::is.null
[13:21:34.343]                       muffled <- FALSE
[13:21:34.343]                       if (inherits(cond, "message")) {
[13:21:34.343]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:34.343]                         if (muffled) 
[13:21:34.343]                           invokeRestart("muffleMessage")
[13:21:34.343]                       }
[13:21:34.343]                       else if (inherits(cond, "warning")) {
[13:21:34.343]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:34.343]                         if (muffled) 
[13:21:34.343]                           invokeRestart("muffleWarning")
[13:21:34.343]                       }
[13:21:34.343]                       else if (inherits(cond, "condition")) {
[13:21:34.343]                         if (!is.null(pattern)) {
[13:21:34.343]                           computeRestarts <- base::computeRestarts
[13:21:34.343]                           grepl <- base::grepl
[13:21:34.343]                           restarts <- computeRestarts(cond)
[13:21:34.343]                           for (restart in restarts) {
[13:21:34.343]                             name <- restart$name
[13:21:34.343]                             if (is.null(name)) 
[13:21:34.343]                               next
[13:21:34.343]                             if (!grepl(pattern, name)) 
[13:21:34.343]                               next
[13:21:34.343]                             invokeRestart(restart)
[13:21:34.343]                             muffled <- TRUE
[13:21:34.343]                             break
[13:21:34.343]                           }
[13:21:34.343]                         }
[13:21:34.343]                       }
[13:21:34.343]                       invisible(muffled)
[13:21:34.343]                     }
[13:21:34.343]                     muffleCondition(cond, pattern = "^muffle")
[13:21:34.343]                   }
[13:21:34.343]                 }
[13:21:34.343]             }
[13:21:34.343]         }))
[13:21:34.343]     }, error = function(ex) {
[13:21:34.343]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:34.343]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:34.343]                 ...future.rng), started = ...future.startTime, 
[13:21:34.343]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:34.343]             version = "1.8"), class = "FutureResult")
[13:21:34.343]     }, finally = {
[13:21:34.343]         if (!identical(...future.workdir, getwd())) 
[13:21:34.343]             setwd(...future.workdir)
[13:21:34.343]         {
[13:21:34.343]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:34.343]                 ...future.oldOptions$nwarnings <- NULL
[13:21:34.343]             }
[13:21:34.343]             base::options(...future.oldOptions)
[13:21:34.343]             if (.Platform$OS.type == "windows") {
[13:21:34.343]                 old_names <- names(...future.oldEnvVars)
[13:21:34.343]                 envs <- base::Sys.getenv()
[13:21:34.343]                 names <- names(envs)
[13:21:34.343]                 common <- intersect(names, old_names)
[13:21:34.343]                 added <- setdiff(names, old_names)
[13:21:34.343]                 removed <- setdiff(old_names, names)
[13:21:34.343]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:34.343]                   envs[common]]
[13:21:34.343]                 NAMES <- toupper(changed)
[13:21:34.343]                 args <- list()
[13:21:34.343]                 for (kk in seq_along(NAMES)) {
[13:21:34.343]                   name <- changed[[kk]]
[13:21:34.343]                   NAME <- NAMES[[kk]]
[13:21:34.343]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.343]                     next
[13:21:34.343]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:34.343]                 }
[13:21:34.343]                 NAMES <- toupper(added)
[13:21:34.343]                 for (kk in seq_along(NAMES)) {
[13:21:34.343]                   name <- added[[kk]]
[13:21:34.343]                   NAME <- NAMES[[kk]]
[13:21:34.343]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.343]                     next
[13:21:34.343]                   args[[name]] <- ""
[13:21:34.343]                 }
[13:21:34.343]                 NAMES <- toupper(removed)
[13:21:34.343]                 for (kk in seq_along(NAMES)) {
[13:21:34.343]                   name <- removed[[kk]]
[13:21:34.343]                   NAME <- NAMES[[kk]]
[13:21:34.343]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.343]                     next
[13:21:34.343]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:34.343]                 }
[13:21:34.343]                 if (length(args) > 0) 
[13:21:34.343]                   base::do.call(base::Sys.setenv, args = args)
[13:21:34.343]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:34.343]             }
[13:21:34.343]             else {
[13:21:34.343]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:34.343]             }
[13:21:34.343]             {
[13:21:34.343]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:34.343]                   0L) {
[13:21:34.343]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:34.343]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:34.343]                   base::options(opts)
[13:21:34.343]                 }
[13:21:34.343]                 {
[13:21:34.343]                   {
[13:21:34.343]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:34.343]                     NULL
[13:21:34.343]                   }
[13:21:34.343]                   options(future.plan = NULL)
[13:21:34.343]                   if (is.na(NA_character_)) 
[13:21:34.343]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:34.343]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:34.343]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:34.343]                     envir = parent.frame()) 
[13:21:34.343]                   {
[13:21:34.343]                     default_workers <- missing(workers)
[13:21:34.343]                     if (is.function(workers)) 
[13:21:34.343]                       workers <- workers()
[13:21:34.343]                     workers <- structure(as.integer(workers), 
[13:21:34.343]                       class = class(workers))
[13:21:34.343]                     stop_if_not(is.finite(workers), workers >= 
[13:21:34.343]                       1L)
[13:21:34.343]                     if ((workers == 1L && !inherits(workers, 
[13:21:34.343]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:34.343]                       if (default_workers) 
[13:21:34.343]                         supportsMulticore(warn = TRUE)
[13:21:34.343]                       return(sequential(..., envir = envir))
[13:21:34.343]                     }
[13:21:34.343]                     oopts <- options(mc.cores = workers)
[13:21:34.343]                     on.exit(options(oopts))
[13:21:34.343]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:34.343]                       envir = envir)
[13:21:34.343]                     if (!future$lazy) 
[13:21:34.343]                       future <- run(future)
[13:21:34.343]                     invisible(future)
[13:21:34.343]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:34.343]                 }
[13:21:34.343]             }
[13:21:34.343]         }
[13:21:34.343]     })
[13:21:34.343]     if (TRUE) {
[13:21:34.343]         base::sink(type = "output", split = FALSE)
[13:21:34.343]         if (TRUE) {
[13:21:34.343]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:34.343]         }
[13:21:34.343]         else {
[13:21:34.343]             ...future.result["stdout"] <- base::list(NULL)
[13:21:34.343]         }
[13:21:34.343]         base::close(...future.stdout)
[13:21:34.343]         ...future.stdout <- NULL
[13:21:34.343]     }
[13:21:34.343]     ...future.result$conditions <- ...future.conditions
[13:21:34.343]     ...future.result$finished <- base::Sys.time()
[13:21:34.343]     ...future.result
[13:21:34.343] }
[13:21:34.346] assign_globals() ...
[13:21:34.346] List of 11
[13:21:34.346]  $ ...future.FUN            :function (x, ...)  
[13:21:34.346]  $ x_FUN                    :function (x)  
[13:21:34.346]  $ times                    : int 4
[13:21:34.346]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:34.346]  $ stop_if_not              :function (...)  
[13:21:34.346]  $ dim                      : int [1:2] 2 2
[13:21:34.346]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:21:34.346]  $ future.call.arguments    : list()
[13:21:34.346]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:34.346]  $ ...future.elements_ii    :List of 5
[13:21:34.346]   ..$ : int 1
[13:21:34.346]   ..$ : int 2
[13:21:34.346]   ..$ : int 3
[13:21:34.346]   ..$ : int 4
[13:21:34.346]   ..$ : int 5
[13:21:34.346]  $ ...future.seeds_ii       : NULL
[13:21:34.346]  $ ...future.globals.maxSize: NULL
[13:21:34.346]  - attr(*, "where")=List of 11
[13:21:34.346]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:34.346]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:34.346]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:34.346]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:34.346]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:34.346]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:34.346]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:34.346]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:34.346]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:34.346]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:34.346]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:34.346]  - attr(*, "resolved")= logi FALSE
[13:21:34.346]  - attr(*, "total_size")= num 105552
[13:21:34.346]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:34.346]  - attr(*, "already-done")= logi TRUE
[13:21:34.359] - copied ‘...future.FUN’ to environment
[13:21:34.359] - reassign environment for ‘x_FUN’
[13:21:34.359] - copied ‘x_FUN’ to environment
[13:21:34.359] - copied ‘times’ to environment
[13:21:34.359] - copied ‘stopf’ to environment
[13:21:34.359] - copied ‘stop_if_not’ to environment
[13:21:34.359] - copied ‘dim’ to environment
[13:21:34.359] - copied ‘valid_types’ to environment
[13:21:34.360] - copied ‘future.call.arguments’ to environment
[13:21:34.360] - copied ‘...future.elements_ii’ to environment
[13:21:34.360] - copied ‘...future.seeds_ii’ to environment
[13:21:34.360] - copied ‘...future.globals.maxSize’ to environment
[13:21:34.360] assign_globals() ... done
[13:21:34.360] requestCore(): workers = 2
[13:21:34.363] MulticoreFuture started
[13:21:34.363] - Launch lazy future ... done
[13:21:34.363] run() for ‘MulticoreFuture’ ... done
[13:21:34.364] Created future:
[13:21:34.364] plan(): Setting new future strategy stack:
[13:21:34.364] List of future strategies:
[13:21:34.364] 1. sequential:
[13:21:34.364]    - args: function (..., envir = parent.frame())
[13:21:34.364]    - tweaked: FALSE
[13:21:34.364]    - call: NULL
[13:21:34.365] plan(): nbrOfWorkers() = 1
[13:21:34.367] plan(): Setting new future strategy stack:
[13:21:34.368] List of future strategies:
[13:21:34.368] 1. multicore:
[13:21:34.368]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:34.368]    - tweaked: FALSE
[13:21:34.368]    - call: plan(strategy)
[13:21:34.373] plan(): nbrOfWorkers() = 2
[13:21:34.364] MulticoreFuture:
[13:21:34.364] Label: ‘future_vapply-1’
[13:21:34.364] Expression:
[13:21:34.364] {
[13:21:34.364]     do.call(function(...) {
[13:21:34.364]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.364]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:34.364]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.364]             on.exit(options(oopts), add = TRUE)
[13:21:34.364]         }
[13:21:34.364]         {
[13:21:34.364]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:34.364]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.364]                 ...future.FUN(...future.X_jj, ...)
[13:21:34.364]             })
[13:21:34.364]         }
[13:21:34.364]     }, args = future.call.arguments)
[13:21:34.364] }
[13:21:34.364] Lazy evaluation: FALSE
[13:21:34.364] Asynchronous evaluation: TRUE
[13:21:34.364] Local evaluation: TRUE
[13:21:34.364] Environment: R_GlobalEnv
[13:21:34.364] Capture standard output: TRUE
[13:21:34.364] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:34.364] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:34.364] Packages: 1 packages (‘future.apply’)
[13:21:34.364] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:34.364] Resolved: TRUE
[13:21:34.364] Value: <not collected>
[13:21:34.364] Conditions captured: <none>
[13:21:34.364] Early signaling: FALSE
[13:21:34.364] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:34.364] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:34.374] Chunk #1 of 2 ... DONE
[13:21:34.375] Chunk #2 of 2 ...
[13:21:34.375]  - Finding globals in 'X' for chunk #2 ...
[13:21:34.375] getGlobalsAndPackages() ...
[13:21:34.375] Searching for globals...
[13:21:34.376] 
[13:21:34.376] Searching for globals ... DONE
[13:21:34.376] - globals: [0] <none>
[13:21:34.376] getGlobalsAndPackages() ... DONE
[13:21:34.376]    + additional globals found: [n=0] 
[13:21:34.377]    + additional namespaces needed: [n=0] 
[13:21:34.377]  - Finding globals in 'X' for chunk #2 ... DONE
[13:21:34.377]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:34.377]  - seeds: <none>
[13:21:34.377]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.377] getGlobalsAndPackages() ...
[13:21:34.378] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.378] Resolving globals: FALSE
[13:21:34.378] Tweak future expression to call with '...' arguments ...
[13:21:34.378] {
[13:21:34.378]     do.call(function(...) {
[13:21:34.378]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.378]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:34.378]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.378]             on.exit(options(oopts), add = TRUE)
[13:21:34.378]         }
[13:21:34.378]         {
[13:21:34.378]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:34.378]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.378]                 ...future.FUN(...future.X_jj, ...)
[13:21:34.378]             })
[13:21:34.378]         }
[13:21:34.378]     }, args = future.call.arguments)
[13:21:34.378] }
[13:21:34.379] Tweak future expression to call with '...' arguments ... DONE
[13:21:34.380] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.380] - packages: [1] ‘future.apply’
[13:21:34.380] getGlobalsAndPackages() ... DONE
[13:21:34.381] run() for ‘Future’ ...
[13:21:34.381] - state: ‘created’
[13:21:34.381] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:34.386] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:34.386] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:34.386]   - Field: ‘label’
[13:21:34.387]   - Field: ‘local’
[13:21:34.387]   - Field: ‘owner’
[13:21:34.387]   - Field: ‘envir’
[13:21:34.387]   - Field: ‘workers’
[13:21:34.387]   - Field: ‘packages’
[13:21:34.387]   - Field: ‘gc’
[13:21:34.388]   - Field: ‘job’
[13:21:34.388]   - Field: ‘conditions’
[13:21:34.388]   - Field: ‘expr’
[13:21:34.388]   - Field: ‘uuid’
[13:21:34.388]   - Field: ‘seed’
[13:21:34.388]   - Field: ‘version’
[13:21:34.388]   - Field: ‘result’
[13:21:34.389]   - Field: ‘asynchronous’
[13:21:34.389]   - Field: ‘calls’
[13:21:34.389]   - Field: ‘globals’
[13:21:34.389]   - Field: ‘stdout’
[13:21:34.389]   - Field: ‘earlySignal’
[13:21:34.389]   - Field: ‘lazy’
[13:21:34.389]   - Field: ‘state’
[13:21:34.390] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:34.390] - Launch lazy future ...
[13:21:34.390] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:34.391] Packages needed by future strategies (n = 0): <none>
[13:21:34.394] {
[13:21:34.394]     {
[13:21:34.394]         {
[13:21:34.394]             ...future.startTime <- base::Sys.time()
[13:21:34.394]             {
[13:21:34.394]                 {
[13:21:34.394]                   {
[13:21:34.394]                     {
[13:21:34.394]                       {
[13:21:34.394]                         base::local({
[13:21:34.394]                           has_future <- base::requireNamespace("future", 
[13:21:34.394]                             quietly = TRUE)
[13:21:34.394]                           if (has_future) {
[13:21:34.394]                             ns <- base::getNamespace("future")
[13:21:34.394]                             version <- ns[[".package"]][["version"]]
[13:21:34.394]                             if (is.null(version)) 
[13:21:34.394]                               version <- utils::packageVersion("future")
[13:21:34.394]                           }
[13:21:34.394]                           else {
[13:21:34.394]                             version <- NULL
[13:21:34.394]                           }
[13:21:34.394]                           if (!has_future || version < "1.8.0") {
[13:21:34.394]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:34.394]                               "", base::R.version$version.string), 
[13:21:34.394]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:34.394]                                 base::R.version$platform, 8 * 
[13:21:34.394]                                   base::.Machine$sizeof.pointer), 
[13:21:34.394]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:34.394]                                 "release", "version")], collapse = " "), 
[13:21:34.394]                               hostname = base::Sys.info()[["nodename"]])
[13:21:34.394]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:34.394]                               info)
[13:21:34.394]                             info <- base::paste(info, collapse = "; ")
[13:21:34.394]                             if (!has_future) {
[13:21:34.394]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:34.394]                                 info)
[13:21:34.394]                             }
[13:21:34.394]                             else {
[13:21:34.394]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:34.394]                                 info, version)
[13:21:34.394]                             }
[13:21:34.394]                             base::stop(msg)
[13:21:34.394]                           }
[13:21:34.394]                         })
[13:21:34.394]                       }
[13:21:34.394]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:34.394]                       base::options(mc.cores = 1L)
[13:21:34.394]                     }
[13:21:34.394]                     base::local({
[13:21:34.394]                       for (pkg in "future.apply") {
[13:21:34.394]                         base::loadNamespace(pkg)
[13:21:34.394]                         base::library(pkg, character.only = TRUE)
[13:21:34.394]                       }
[13:21:34.394]                     })
[13:21:34.394]                   }
[13:21:34.394]                   options(future.plan = NULL)
[13:21:34.394]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:34.394]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:34.394]                 }
[13:21:34.394]                 ...future.workdir <- getwd()
[13:21:34.394]             }
[13:21:34.394]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:34.394]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:34.394]         }
[13:21:34.394]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:34.394]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:34.394]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:34.394]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:34.394]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:34.394]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:34.394]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:34.394]             base::names(...future.oldOptions))
[13:21:34.394]     }
[13:21:34.394]     if (FALSE) {
[13:21:34.394]     }
[13:21:34.394]     else {
[13:21:34.394]         if (TRUE) {
[13:21:34.394]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:34.394]                 open = "w")
[13:21:34.394]         }
[13:21:34.394]         else {
[13:21:34.394]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:34.394]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:34.394]         }
[13:21:34.394]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:34.394]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:34.394]             base::sink(type = "output", split = FALSE)
[13:21:34.394]             base::close(...future.stdout)
[13:21:34.394]         }, add = TRUE)
[13:21:34.394]     }
[13:21:34.394]     ...future.frame <- base::sys.nframe()
[13:21:34.394]     ...future.conditions <- base::list()
[13:21:34.394]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:34.394]     if (FALSE) {
[13:21:34.394]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:34.394]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:34.394]     }
[13:21:34.394]     ...future.result <- base::tryCatch({
[13:21:34.394]         base::withCallingHandlers({
[13:21:34.394]             ...future.value <- base::withVisible(base::local({
[13:21:34.394]                 withCallingHandlers({
[13:21:34.394]                   {
[13:21:34.394]                     do.call(function(...) {
[13:21:34.394]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.394]                       if (!identical(...future.globals.maxSize.org, 
[13:21:34.394]                         ...future.globals.maxSize)) {
[13:21:34.394]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.394]                         on.exit(options(oopts), add = TRUE)
[13:21:34.394]                       }
[13:21:34.394]                       {
[13:21:34.394]                         lapply(seq_along(...future.elements_ii), 
[13:21:34.394]                           FUN = function(jj) {
[13:21:34.394]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.394]                             ...future.FUN(...future.X_jj, ...)
[13:21:34.394]                           })
[13:21:34.394]                       }
[13:21:34.394]                     }, args = future.call.arguments)
[13:21:34.394]                   }
[13:21:34.394]                 }, immediateCondition = function(cond) {
[13:21:34.394]                   save_rds <- function (object, pathname, ...) 
[13:21:34.394]                   {
[13:21:34.394]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:34.394]                     if (file_test("-f", pathname_tmp)) {
[13:21:34.394]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.394]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:34.394]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.394]                         fi_tmp[["mtime"]])
[13:21:34.394]                     }
[13:21:34.394]                     tryCatch({
[13:21:34.394]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:34.394]                     }, error = function(ex) {
[13:21:34.394]                       msg <- conditionMessage(ex)
[13:21:34.394]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.394]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:34.394]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.394]                         fi_tmp[["mtime"]], msg)
[13:21:34.394]                       ex$message <- msg
[13:21:34.394]                       stop(ex)
[13:21:34.394]                     })
[13:21:34.394]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:34.394]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:34.394]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:34.394]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.394]                       fi <- file.info(pathname)
[13:21:34.394]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:34.394]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.394]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:34.394]                         fi[["size"]], fi[["mtime"]])
[13:21:34.394]                       stop(msg)
[13:21:34.394]                     }
[13:21:34.394]                     invisible(pathname)
[13:21:34.394]                   }
[13:21:34.394]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:34.394]                     rootPath = tempdir()) 
[13:21:34.394]                   {
[13:21:34.394]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:34.394]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:34.394]                       tmpdir = path, fileext = ".rds")
[13:21:34.394]                     save_rds(obj, file)
[13:21:34.394]                   }
[13:21:34.394]                   saveImmediateCondition(cond, path = "/tmp/RtmpbpFWGO/.future/immediateConditions")
[13:21:34.394]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.394]                   {
[13:21:34.394]                     inherits <- base::inherits
[13:21:34.394]                     invokeRestart <- base::invokeRestart
[13:21:34.394]                     is.null <- base::is.null
[13:21:34.394]                     muffled <- FALSE
[13:21:34.394]                     if (inherits(cond, "message")) {
[13:21:34.394]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:34.394]                       if (muffled) 
[13:21:34.394]                         invokeRestart("muffleMessage")
[13:21:34.394]                     }
[13:21:34.394]                     else if (inherits(cond, "warning")) {
[13:21:34.394]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:34.394]                       if (muffled) 
[13:21:34.394]                         invokeRestart("muffleWarning")
[13:21:34.394]                     }
[13:21:34.394]                     else if (inherits(cond, "condition")) {
[13:21:34.394]                       if (!is.null(pattern)) {
[13:21:34.394]                         computeRestarts <- base::computeRestarts
[13:21:34.394]                         grepl <- base::grepl
[13:21:34.394]                         restarts <- computeRestarts(cond)
[13:21:34.394]                         for (restart in restarts) {
[13:21:34.394]                           name <- restart$name
[13:21:34.394]                           if (is.null(name)) 
[13:21:34.394]                             next
[13:21:34.394]                           if (!grepl(pattern, name)) 
[13:21:34.394]                             next
[13:21:34.394]                           invokeRestart(restart)
[13:21:34.394]                           muffled <- TRUE
[13:21:34.394]                           break
[13:21:34.394]                         }
[13:21:34.394]                       }
[13:21:34.394]                     }
[13:21:34.394]                     invisible(muffled)
[13:21:34.394]                   }
[13:21:34.394]                   muffleCondition(cond)
[13:21:34.394]                 })
[13:21:34.394]             }))
[13:21:34.394]             future::FutureResult(value = ...future.value$value, 
[13:21:34.394]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:34.394]                   ...future.rng), globalenv = if (FALSE) 
[13:21:34.394]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:34.394]                     ...future.globalenv.names))
[13:21:34.394]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:34.394]         }, condition = base::local({
[13:21:34.394]             c <- base::c
[13:21:34.394]             inherits <- base::inherits
[13:21:34.394]             invokeRestart <- base::invokeRestart
[13:21:34.394]             length <- base::length
[13:21:34.394]             list <- base::list
[13:21:34.394]             seq.int <- base::seq.int
[13:21:34.394]             signalCondition <- base::signalCondition
[13:21:34.394]             sys.calls <- base::sys.calls
[13:21:34.394]             `[[` <- base::`[[`
[13:21:34.394]             `+` <- base::`+`
[13:21:34.394]             `<<-` <- base::`<<-`
[13:21:34.394]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:34.394]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:34.394]                   3L)]
[13:21:34.394]             }
[13:21:34.394]             function(cond) {
[13:21:34.394]                 is_error <- inherits(cond, "error")
[13:21:34.394]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:34.394]                   NULL)
[13:21:34.394]                 if (is_error) {
[13:21:34.394]                   sessionInformation <- function() {
[13:21:34.394]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:34.394]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:34.394]                       search = base::search(), system = base::Sys.info())
[13:21:34.394]                   }
[13:21:34.394]                   ...future.conditions[[length(...future.conditions) + 
[13:21:34.394]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:34.394]                     cond$call), session = sessionInformation(), 
[13:21:34.394]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:34.394]                   signalCondition(cond)
[13:21:34.394]                 }
[13:21:34.394]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:34.394]                 "immediateCondition"))) {
[13:21:34.394]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:34.394]                   ...future.conditions[[length(...future.conditions) + 
[13:21:34.394]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:34.394]                   if (TRUE && !signal) {
[13:21:34.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.394]                     {
[13:21:34.394]                       inherits <- base::inherits
[13:21:34.394]                       invokeRestart <- base::invokeRestart
[13:21:34.394]                       is.null <- base::is.null
[13:21:34.394]                       muffled <- FALSE
[13:21:34.394]                       if (inherits(cond, "message")) {
[13:21:34.394]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:34.394]                         if (muffled) 
[13:21:34.394]                           invokeRestart("muffleMessage")
[13:21:34.394]                       }
[13:21:34.394]                       else if (inherits(cond, "warning")) {
[13:21:34.394]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:34.394]                         if (muffled) 
[13:21:34.394]                           invokeRestart("muffleWarning")
[13:21:34.394]                       }
[13:21:34.394]                       else if (inherits(cond, "condition")) {
[13:21:34.394]                         if (!is.null(pattern)) {
[13:21:34.394]                           computeRestarts <- base::computeRestarts
[13:21:34.394]                           grepl <- base::grepl
[13:21:34.394]                           restarts <- computeRestarts(cond)
[13:21:34.394]                           for (restart in restarts) {
[13:21:34.394]                             name <- restart$name
[13:21:34.394]                             if (is.null(name)) 
[13:21:34.394]                               next
[13:21:34.394]                             if (!grepl(pattern, name)) 
[13:21:34.394]                               next
[13:21:34.394]                             invokeRestart(restart)
[13:21:34.394]                             muffled <- TRUE
[13:21:34.394]                             break
[13:21:34.394]                           }
[13:21:34.394]                         }
[13:21:34.394]                       }
[13:21:34.394]                       invisible(muffled)
[13:21:34.394]                     }
[13:21:34.394]                     muffleCondition(cond, pattern = "^muffle")
[13:21:34.394]                   }
[13:21:34.394]                 }
[13:21:34.394]                 else {
[13:21:34.394]                   if (TRUE) {
[13:21:34.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.394]                     {
[13:21:34.394]                       inherits <- base::inherits
[13:21:34.394]                       invokeRestart <- base::invokeRestart
[13:21:34.394]                       is.null <- base::is.null
[13:21:34.394]                       muffled <- FALSE
[13:21:34.394]                       if (inherits(cond, "message")) {
[13:21:34.394]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:34.394]                         if (muffled) 
[13:21:34.394]                           invokeRestart("muffleMessage")
[13:21:34.394]                       }
[13:21:34.394]                       else if (inherits(cond, "warning")) {
[13:21:34.394]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:34.394]                         if (muffled) 
[13:21:34.394]                           invokeRestart("muffleWarning")
[13:21:34.394]                       }
[13:21:34.394]                       else if (inherits(cond, "condition")) {
[13:21:34.394]                         if (!is.null(pattern)) {
[13:21:34.394]                           computeRestarts <- base::computeRestarts
[13:21:34.394]                           grepl <- base::grepl
[13:21:34.394]                           restarts <- computeRestarts(cond)
[13:21:34.394]                           for (restart in restarts) {
[13:21:34.394]                             name <- restart$name
[13:21:34.394]                             if (is.null(name)) 
[13:21:34.394]                               next
[13:21:34.394]                             if (!grepl(pattern, name)) 
[13:21:34.394]                               next
[13:21:34.394]                             invokeRestart(restart)
[13:21:34.394]                             muffled <- TRUE
[13:21:34.394]                             break
[13:21:34.394]                           }
[13:21:34.394]                         }
[13:21:34.394]                       }
[13:21:34.394]                       invisible(muffled)
[13:21:34.394]                     }
[13:21:34.394]                     muffleCondition(cond, pattern = "^muffle")
[13:21:34.394]                   }
[13:21:34.394]                 }
[13:21:34.394]             }
[13:21:34.394]         }))
[13:21:34.394]     }, error = function(ex) {
[13:21:34.394]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:34.394]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:34.394]                 ...future.rng), started = ...future.startTime, 
[13:21:34.394]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:34.394]             version = "1.8"), class = "FutureResult")
[13:21:34.394]     }, finally = {
[13:21:34.394]         if (!identical(...future.workdir, getwd())) 
[13:21:34.394]             setwd(...future.workdir)
[13:21:34.394]         {
[13:21:34.394]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:34.394]                 ...future.oldOptions$nwarnings <- NULL
[13:21:34.394]             }
[13:21:34.394]             base::options(...future.oldOptions)
[13:21:34.394]             if (.Platform$OS.type == "windows") {
[13:21:34.394]                 old_names <- names(...future.oldEnvVars)
[13:21:34.394]                 envs <- base::Sys.getenv()
[13:21:34.394]                 names <- names(envs)
[13:21:34.394]                 common <- intersect(names, old_names)
[13:21:34.394]                 added <- setdiff(names, old_names)
[13:21:34.394]                 removed <- setdiff(old_names, names)
[13:21:34.394]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:34.394]                   envs[common]]
[13:21:34.394]                 NAMES <- toupper(changed)
[13:21:34.394]                 args <- list()
[13:21:34.394]                 for (kk in seq_along(NAMES)) {
[13:21:34.394]                   name <- changed[[kk]]
[13:21:34.394]                   NAME <- NAMES[[kk]]
[13:21:34.394]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.394]                     next
[13:21:34.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:34.394]                 }
[13:21:34.394]                 NAMES <- toupper(added)
[13:21:34.394]                 for (kk in seq_along(NAMES)) {
[13:21:34.394]                   name <- added[[kk]]
[13:21:34.394]                   NAME <- NAMES[[kk]]
[13:21:34.394]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.394]                     next
[13:21:34.394]                   args[[name]] <- ""
[13:21:34.394]                 }
[13:21:34.394]                 NAMES <- toupper(removed)
[13:21:34.394]                 for (kk in seq_along(NAMES)) {
[13:21:34.394]                   name <- removed[[kk]]
[13:21:34.394]                   NAME <- NAMES[[kk]]
[13:21:34.394]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.394]                     next
[13:21:34.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:34.394]                 }
[13:21:34.394]                 if (length(args) > 0) 
[13:21:34.394]                   base::do.call(base::Sys.setenv, args = args)
[13:21:34.394]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:34.394]             }
[13:21:34.394]             else {
[13:21:34.394]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:34.394]             }
[13:21:34.394]             {
[13:21:34.394]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:34.394]                   0L) {
[13:21:34.394]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:34.394]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:34.394]                   base::options(opts)
[13:21:34.394]                 }
[13:21:34.394]                 {
[13:21:34.394]                   {
[13:21:34.394]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:34.394]                     NULL
[13:21:34.394]                   }
[13:21:34.394]                   options(future.plan = NULL)
[13:21:34.394]                   if (is.na(NA_character_)) 
[13:21:34.394]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:34.394]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:34.394]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:34.394]                     envir = parent.frame()) 
[13:21:34.394]                   {
[13:21:34.394]                     default_workers <- missing(workers)
[13:21:34.394]                     if (is.function(workers)) 
[13:21:34.394]                       workers <- workers()
[13:21:34.394]                     workers <- structure(as.integer(workers), 
[13:21:34.394]                       class = class(workers))
[13:21:34.394]                     stop_if_not(is.finite(workers), workers >= 
[13:21:34.394]                       1L)
[13:21:34.394]                     if ((workers == 1L && !inherits(workers, 
[13:21:34.394]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:34.394]                       if (default_workers) 
[13:21:34.394]                         supportsMulticore(warn = TRUE)
[13:21:34.394]                       return(sequential(..., envir = envir))
[13:21:34.394]                     }
[13:21:34.394]                     oopts <- options(mc.cores = workers)
[13:21:34.394]                     on.exit(options(oopts))
[13:21:34.394]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:34.394]                       envir = envir)
[13:21:34.394]                     if (!future$lazy) 
[13:21:34.394]                       future <- run(future)
[13:21:34.394]                     invisible(future)
[13:21:34.394]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:34.394]                 }
[13:21:34.394]             }
[13:21:34.394]         }
[13:21:34.394]     })
[13:21:34.394]     if (TRUE) {
[13:21:34.394]         base::sink(type = "output", split = FALSE)
[13:21:34.394]         if (TRUE) {
[13:21:34.394]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:34.394]         }
[13:21:34.394]         else {
[13:21:34.394]             ...future.result["stdout"] <- base::list(NULL)
[13:21:34.394]         }
[13:21:34.394]         base::close(...future.stdout)
[13:21:34.394]         ...future.stdout <- NULL
[13:21:34.394]     }
[13:21:34.394]     ...future.result$conditions <- ...future.conditions
[13:21:34.394]     ...future.result$finished <- base::Sys.time()
[13:21:34.394]     ...future.result
[13:21:34.394] }
[13:21:34.399] assign_globals() ...
[13:21:34.399] List of 11
[13:21:34.399]  $ ...future.FUN            :function (x, ...)  
[13:21:34.399]  $ x_FUN                    :function (x)  
[13:21:34.399]  $ times                    : int 4
[13:21:34.399]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:34.399]  $ stop_if_not              :function (...)  
[13:21:34.399]  $ dim                      : int [1:2] 2 2
[13:21:34.399]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:21:34.399]  $ future.call.arguments    : list()
[13:21:34.399]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:34.399]  $ ...future.elements_ii    :List of 5
[13:21:34.399]   ..$ : int 6
[13:21:34.399]   ..$ : int 7
[13:21:34.399]   ..$ : int 8
[13:21:34.399]   ..$ : int 9
[13:21:34.399]   ..$ : int 10
[13:21:34.399]  $ ...future.seeds_ii       : NULL
[13:21:34.399]  $ ...future.globals.maxSize: NULL
[13:21:34.399]  - attr(*, "where")=List of 11
[13:21:34.399]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:34.399]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:34.399]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:34.399]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:34.399]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:34.399]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:34.399]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:34.399]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:34.399]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:34.399]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:34.399]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:34.399]  - attr(*, "resolved")= logi FALSE
[13:21:34.399]  - attr(*, "total_size")= num 105552
[13:21:34.399]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:34.399]  - attr(*, "already-done")= logi TRUE
[13:21:34.415] - copied ‘...future.FUN’ to environment
[13:21:34.415] - reassign environment for ‘x_FUN’
[13:21:34.415] - copied ‘x_FUN’ to environment
[13:21:34.415] - copied ‘times’ to environment
[13:21:34.415] - copied ‘stopf’ to environment
[13:21:34.415] - copied ‘stop_if_not’ to environment
[13:21:34.416] - copied ‘dim’ to environment
[13:21:34.416] - copied ‘valid_types’ to environment
[13:21:34.416] - copied ‘future.call.arguments’ to environment
[13:21:34.416] - copied ‘...future.elements_ii’ to environment
[13:21:34.416] - copied ‘...future.seeds_ii’ to environment
[13:21:34.416] - copied ‘...future.globals.maxSize’ to environment
[13:21:34.416] assign_globals() ... done
[13:21:34.416] requestCore(): workers = 2
[13:21:34.419] MulticoreFuture started
[13:21:34.419] - Launch lazy future ... done
[13:21:34.419] run() for ‘MulticoreFuture’ ... done
[13:21:34.420] Created future:
[13:21:34.420] plan(): Setting new future strategy stack:
[13:21:34.421] List of future strategies:
[13:21:34.421] 1. sequential:
[13:21:34.421]    - args: function (..., envir = parent.frame())
[13:21:34.421]    - tweaked: FALSE
[13:21:34.421]    - call: NULL
[13:21:34.421] plan(): nbrOfWorkers() = 1
[13:21:34.424] plan(): Setting new future strategy stack:
[13:21:34.424] List of future strategies:
[13:21:34.424] 1. multicore:
[13:21:34.424]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:34.424]    - tweaked: FALSE
[13:21:34.424]    - call: plan(strategy)
[13:21:34.429] plan(): nbrOfWorkers() = 2
[13:21:34.420] MulticoreFuture:
[13:21:34.420] Label: ‘future_vapply-2’
[13:21:34.420] Expression:
[13:21:34.420] {
[13:21:34.420]     do.call(function(...) {
[13:21:34.420]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.420]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:34.420]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.420]             on.exit(options(oopts), add = TRUE)
[13:21:34.420]         }
[13:21:34.420]         {
[13:21:34.420]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:34.420]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.420]                 ...future.FUN(...future.X_jj, ...)
[13:21:34.420]             })
[13:21:34.420]         }
[13:21:34.420]     }, args = future.call.arguments)
[13:21:34.420] }
[13:21:34.420] Lazy evaluation: FALSE
[13:21:34.420] Asynchronous evaluation: TRUE
[13:21:34.420] Local evaluation: TRUE
[13:21:34.420] Environment: R_GlobalEnv
[13:21:34.420] Capture standard output: TRUE
[13:21:34.420] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:34.420] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:34.420] Packages: 1 packages (‘future.apply’)
[13:21:34.420] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:34.420] Resolved: TRUE
[13:21:34.420] Value: <not collected>
[13:21:34.420] Conditions captured: <none>
[13:21:34.420] Early signaling: FALSE
[13:21:34.420] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:34.420] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:34.430] Chunk #2 of 2 ... DONE
[13:21:34.430] Launching 2 futures (chunks) ... DONE
[13:21:34.430] Resolving 2 futures (chunks) ...
[13:21:34.431] resolve() on list ...
[13:21:34.431]  recursive: 0
[13:21:34.431]  length: 2
[13:21:34.431] 
[13:21:34.431] Future #1
[13:21:34.431] result() for MulticoreFuture ...
[13:21:34.432] result() for MulticoreFuture ...
[13:21:34.433] result() for MulticoreFuture ... done
[13:21:34.433] result() for MulticoreFuture ... done
[13:21:34.433] result() for MulticoreFuture ...
[13:21:34.433] result() for MulticoreFuture ... done
[13:21:34.433] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:21:34.433] - nx: 2
[13:21:34.433] - relay: TRUE
[13:21:34.434] - stdout: TRUE
[13:21:34.434] - signal: TRUE
[13:21:34.434] - resignal: FALSE
[13:21:34.434] - force: TRUE
[13:21:34.434] - relayed: [n=2] FALSE, FALSE
[13:21:34.434] - queued futures: [n=2] FALSE, FALSE
[13:21:34.434]  - until=1
[13:21:34.435]  - relaying element #1
[13:21:34.435] result() for MulticoreFuture ...
[13:21:34.435] result() for MulticoreFuture ... done
[13:21:34.435] result() for MulticoreFuture ...
[13:21:34.435] result() for MulticoreFuture ... done
[13:21:34.435] result() for MulticoreFuture ...
[13:21:34.436] result() for MulticoreFuture ... done
[13:21:34.436] result() for MulticoreFuture ...
[13:21:34.436] result() for MulticoreFuture ... done
[13:21:34.436] - relayed: [n=2] TRUE, FALSE
[13:21:34.436] - queued futures: [n=2] TRUE, FALSE
[13:21:34.436] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:21:34.437]  length: 1 (resolved future 1)
[13:21:34.437] Future #2
[13:21:34.437] result() for MulticoreFuture ...
[13:21:34.438] result() for MulticoreFuture ...
[13:21:34.438] result() for MulticoreFuture ... done
[13:21:34.438] result() for MulticoreFuture ... done
[13:21:34.438] result() for MulticoreFuture ...
[13:21:34.438] result() for MulticoreFuture ... done
[13:21:34.442] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:21:34.442] - nx: 2
[13:21:34.442] - relay: TRUE
[13:21:34.442] - stdout: TRUE
[13:21:34.442] - signal: TRUE
[13:21:34.443] - resignal: FALSE
[13:21:34.443] - force: TRUE
[13:21:34.443] - relayed: [n=2] TRUE, FALSE
[13:21:34.443] - queued futures: [n=2] TRUE, FALSE
[13:21:34.443]  - until=2
[13:21:34.444]  - relaying element #2
[13:21:34.444] result() for MulticoreFuture ...
[13:21:34.444] result() for MulticoreFuture ... done
[13:21:34.444] result() for MulticoreFuture ...
[13:21:34.444] result() for MulticoreFuture ... done
[13:21:34.444] result() for MulticoreFuture ...
[13:21:34.445] result() for MulticoreFuture ... done
[13:21:34.445] result() for MulticoreFuture ...
[13:21:34.445] result() for MulticoreFuture ... done
[13:21:34.445] - relayed: [n=2] TRUE, TRUE
[13:21:34.445] - queued futures: [n=2] TRUE, TRUE
[13:21:34.445] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:21:34.446]  length: 0 (resolved future 2)
[13:21:34.446] Relaying remaining futures
[13:21:34.446] signalConditionsASAP(NULL, pos=0) ...
[13:21:34.446] - nx: 2
[13:21:34.446] - relay: TRUE
[13:21:34.446] - stdout: TRUE
[13:21:34.447] - signal: TRUE
[13:21:34.447] - resignal: FALSE
[13:21:34.447] - force: TRUE
[13:21:34.447] - relayed: [n=2] TRUE, TRUE
[13:21:34.447] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:21:34.447] - relayed: [n=2] TRUE, TRUE
[13:21:34.448] - queued futures: [n=2] TRUE, TRUE
[13:21:34.448] signalConditionsASAP(NULL, pos=0) ... done
[13:21:34.448] resolve() on list ... DONE
[13:21:34.448] result() for MulticoreFuture ...
[13:21:34.448] result() for MulticoreFuture ... done
[13:21:34.448] result() for MulticoreFuture ...
[13:21:34.448] result() for MulticoreFuture ... done
[13:21:34.449] result() for MulticoreFuture ...
[13:21:34.449] result() for MulticoreFuture ... done
[13:21:34.449] result() for MulticoreFuture ...
[13:21:34.449] result() for MulticoreFuture ... done
[13:21:34.449]  - Number of value chunks collected: 2
[13:21:34.449] Resolving 2 futures (chunks) ... DONE
[13:21:34.450] Reducing values from 2 chunks ...
[13:21:34.450]  - Number of values collected after concatenation: 10
[13:21:34.450]  - Number of values expected: 10
[13:21:34.450] Reducing values from 2 chunks ... DONE
[13:21:34.450] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[13:21:34.453] future_lapply() ...
[13:21:34.460] Number of chunks: 2
[13:21:34.460] getGlobalsAndPackagesXApply() ...
[13:21:34.460]  - future.globals: TRUE
[13:21:34.460] getGlobalsAndPackages() ...
[13:21:34.460] Searching for globals...
[13:21:34.464] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[13:21:34.464] Searching for globals ... DONE
[13:21:34.464] Resolving globals: FALSE
[13:21:34.465] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[13:21:34.466] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:34.466] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:34.466] - packages: [2] ‘stats’, ‘future.apply’
[13:21:34.466] getGlobalsAndPackages() ... DONE
[13:21:34.466]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:34.466]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[13:21:34.467] Finding globals ... DONE
[13:21:34.467]  - use_args: TRUE
[13:21:34.467]  - Getting '...' globals ...
[13:21:34.467] resolve() on list ...
[13:21:34.467]  recursive: 0
[13:21:34.467]  length: 1
[13:21:34.467]  elements: ‘...’
[13:21:34.468]  length: 0 (resolved future 1)
[13:21:34.468] resolve() on list ... DONE
[13:21:34.468]    - '...' content: [n=0] 
[13:21:34.468] List of 1
[13:21:34.468]  $ ...: list()
[13:21:34.468]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:34.468]  - attr(*, "where")=List of 1
[13:21:34.468]   ..$ ...:<environment: 0x563b6d76e480> 
[13:21:34.468]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:34.468]  - attr(*, "resolved")= logi TRUE
[13:21:34.468]  - attr(*, "total_size")= num NA
[13:21:34.473]  - Getting '...' globals ... DONE
[13:21:34.474] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:34.474] List of 8
[13:21:34.474]  $ ...future.FUN:function (x, ...)  
[13:21:34.474]  $ x_FUN        :function (x, ...)  
[13:21:34.474]  $ times        : int 5
[13:21:34.474]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:34.474]  $ stop_if_not  :function (...)  
[13:21:34.474]  $ dim          : NULL
[13:21:34.474]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:21:34.474]  $ ...          : list()
[13:21:34.474]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:34.474]  - attr(*, "where")=List of 8
[13:21:34.474]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:34.474]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:34.474]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:34.474]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:34.474]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:34.474]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:34.474]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:34.474]   ..$ ...          :<environment: 0x563b6d76e480> 
[13:21:34.474]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:34.474]  - attr(*, "resolved")= logi FALSE
[13:21:34.474]  - attr(*, "total_size")= num 95528
[13:21:34.480] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[13:21:34.480] getGlobalsAndPackagesXApply() ... DONE
[13:21:34.480] Number of futures (= number of chunks): 2
[13:21:34.480] Launching 2 futures (chunks) ...
[13:21:34.480] Chunk #1 of 2 ...
[13:21:34.481]  - Finding globals in 'X' for chunk #1 ...
[13:21:34.481] getGlobalsAndPackages() ...
[13:21:34.481] Searching for globals...
[13:21:34.481] 
[13:21:34.481] Searching for globals ... DONE
[13:21:34.481] - globals: [0] <none>
[13:21:34.481] getGlobalsAndPackages() ... DONE
[13:21:34.481]    + additional globals found: [n=0] 
[13:21:34.482]    + additional namespaces needed: [n=0] 
[13:21:34.482]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:34.482]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:34.482]  - seeds: <none>
[13:21:34.482]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.482] getGlobalsAndPackages() ...
[13:21:34.482] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.482] Resolving globals: FALSE
[13:21:34.482] Tweak future expression to call with '...' arguments ...
[13:21:34.483] {
[13:21:34.483]     do.call(function(...) {
[13:21:34.483]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.483]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:34.483]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.483]             on.exit(options(oopts), add = TRUE)
[13:21:34.483]         }
[13:21:34.483]         {
[13:21:34.483]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:34.483]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.483]                 ...future.FUN(...future.X_jj, ...)
[13:21:34.483]             })
[13:21:34.483]         }
[13:21:34.483]     }, args = future.call.arguments)
[13:21:34.483] }
[13:21:34.483] Tweak future expression to call with '...' arguments ... DONE
[13:21:34.483] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.483] - packages: [2] ‘stats’, ‘future.apply’
[13:21:34.484] getGlobalsAndPackages() ... DONE
[13:21:34.484] run() for ‘Future’ ...
[13:21:34.484] - state: ‘created’
[13:21:34.484] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:34.488] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:34.488] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:34.488]   - Field: ‘label’
[13:21:34.489]   - Field: ‘local’
[13:21:34.489]   - Field: ‘owner’
[13:21:34.489]   - Field: ‘envir’
[13:21:34.489]   - Field: ‘workers’
[13:21:34.489]   - Field: ‘packages’
[13:21:34.489]   - Field: ‘gc’
[13:21:34.489]   - Field: ‘job’
[13:21:34.489]   - Field: ‘conditions’
[13:21:34.489]   - Field: ‘expr’
[13:21:34.490]   - Field: ‘uuid’
[13:21:34.490]   - Field: ‘seed’
[13:21:34.490]   - Field: ‘version’
[13:21:34.490]   - Field: ‘result’
[13:21:34.490]   - Field: ‘asynchronous’
[13:21:34.490]   - Field: ‘calls’
[13:21:34.490]   - Field: ‘globals’
[13:21:34.490]   - Field: ‘stdout’
[13:21:34.490]   - Field: ‘earlySignal’
[13:21:34.490]   - Field: ‘lazy’
[13:21:34.491]   - Field: ‘state’
[13:21:34.491] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:34.491] - Launch lazy future ...
[13:21:34.491] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[13:21:34.491] Packages needed by future strategies (n = 0): <none>
[13:21:34.492] {
[13:21:34.492]     {
[13:21:34.492]         {
[13:21:34.492]             ...future.startTime <- base::Sys.time()
[13:21:34.492]             {
[13:21:34.492]                 {
[13:21:34.492]                   {
[13:21:34.492]                     {
[13:21:34.492]                       {
[13:21:34.492]                         base::local({
[13:21:34.492]                           has_future <- base::requireNamespace("future", 
[13:21:34.492]                             quietly = TRUE)
[13:21:34.492]                           if (has_future) {
[13:21:34.492]                             ns <- base::getNamespace("future")
[13:21:34.492]                             version <- ns[[".package"]][["version"]]
[13:21:34.492]                             if (is.null(version)) 
[13:21:34.492]                               version <- utils::packageVersion("future")
[13:21:34.492]                           }
[13:21:34.492]                           else {
[13:21:34.492]                             version <- NULL
[13:21:34.492]                           }
[13:21:34.492]                           if (!has_future || version < "1.8.0") {
[13:21:34.492]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:34.492]                               "", base::R.version$version.string), 
[13:21:34.492]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:34.492]                                 base::R.version$platform, 8 * 
[13:21:34.492]                                   base::.Machine$sizeof.pointer), 
[13:21:34.492]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:34.492]                                 "release", "version")], collapse = " "), 
[13:21:34.492]                               hostname = base::Sys.info()[["nodename"]])
[13:21:34.492]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:34.492]                               info)
[13:21:34.492]                             info <- base::paste(info, collapse = "; ")
[13:21:34.492]                             if (!has_future) {
[13:21:34.492]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:34.492]                                 info)
[13:21:34.492]                             }
[13:21:34.492]                             else {
[13:21:34.492]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:34.492]                                 info, version)
[13:21:34.492]                             }
[13:21:34.492]                             base::stop(msg)
[13:21:34.492]                           }
[13:21:34.492]                         })
[13:21:34.492]                       }
[13:21:34.492]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:34.492]                       base::options(mc.cores = 1L)
[13:21:34.492]                     }
[13:21:34.492]                     base::local({
[13:21:34.492]                       for (pkg in c("stats", "future.apply")) {
[13:21:34.492]                         base::loadNamespace(pkg)
[13:21:34.492]                         base::library(pkg, character.only = TRUE)
[13:21:34.492]                       }
[13:21:34.492]                     })
[13:21:34.492]                   }
[13:21:34.492]                   options(future.plan = NULL)
[13:21:34.492]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:34.492]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:34.492]                 }
[13:21:34.492]                 ...future.workdir <- getwd()
[13:21:34.492]             }
[13:21:34.492]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:34.492]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:34.492]         }
[13:21:34.492]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:34.492]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:34.492]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:34.492]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:34.492]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:34.492]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:34.492]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:34.492]             base::names(...future.oldOptions))
[13:21:34.492]     }
[13:21:34.492]     if (FALSE) {
[13:21:34.492]     }
[13:21:34.492]     else {
[13:21:34.492]         if (TRUE) {
[13:21:34.492]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:34.492]                 open = "w")
[13:21:34.492]         }
[13:21:34.492]         else {
[13:21:34.492]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:34.492]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:34.492]         }
[13:21:34.492]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:34.492]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:34.492]             base::sink(type = "output", split = FALSE)
[13:21:34.492]             base::close(...future.stdout)
[13:21:34.492]         }, add = TRUE)
[13:21:34.492]     }
[13:21:34.492]     ...future.frame <- base::sys.nframe()
[13:21:34.492]     ...future.conditions <- base::list()
[13:21:34.492]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:34.492]     if (FALSE) {
[13:21:34.492]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:34.492]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:34.492]     }
[13:21:34.492]     ...future.result <- base::tryCatch({
[13:21:34.492]         base::withCallingHandlers({
[13:21:34.492]             ...future.value <- base::withVisible(base::local({
[13:21:34.492]                 withCallingHandlers({
[13:21:34.492]                   {
[13:21:34.492]                     do.call(function(...) {
[13:21:34.492]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.492]                       if (!identical(...future.globals.maxSize.org, 
[13:21:34.492]                         ...future.globals.maxSize)) {
[13:21:34.492]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.492]                         on.exit(options(oopts), add = TRUE)
[13:21:34.492]                       }
[13:21:34.492]                       {
[13:21:34.492]                         lapply(seq_along(...future.elements_ii), 
[13:21:34.492]                           FUN = function(jj) {
[13:21:34.492]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.492]                             ...future.FUN(...future.X_jj, ...)
[13:21:34.492]                           })
[13:21:34.492]                       }
[13:21:34.492]                     }, args = future.call.arguments)
[13:21:34.492]                   }
[13:21:34.492]                 }, immediateCondition = function(cond) {
[13:21:34.492]                   save_rds <- function (object, pathname, ...) 
[13:21:34.492]                   {
[13:21:34.492]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:34.492]                     if (file_test("-f", pathname_tmp)) {
[13:21:34.492]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.492]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:34.492]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.492]                         fi_tmp[["mtime"]])
[13:21:34.492]                     }
[13:21:34.492]                     tryCatch({
[13:21:34.492]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:34.492]                     }, error = function(ex) {
[13:21:34.492]                       msg <- conditionMessage(ex)
[13:21:34.492]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.492]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:34.492]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.492]                         fi_tmp[["mtime"]], msg)
[13:21:34.492]                       ex$message <- msg
[13:21:34.492]                       stop(ex)
[13:21:34.492]                     })
[13:21:34.492]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:34.492]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:34.492]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:34.492]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.492]                       fi <- file.info(pathname)
[13:21:34.492]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:34.492]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.492]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:34.492]                         fi[["size"]], fi[["mtime"]])
[13:21:34.492]                       stop(msg)
[13:21:34.492]                     }
[13:21:34.492]                     invisible(pathname)
[13:21:34.492]                   }
[13:21:34.492]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:34.492]                     rootPath = tempdir()) 
[13:21:34.492]                   {
[13:21:34.492]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:34.492]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:34.492]                       tmpdir = path, fileext = ".rds")
[13:21:34.492]                     save_rds(obj, file)
[13:21:34.492]                   }
[13:21:34.492]                   saveImmediateCondition(cond, path = "/tmp/RtmpbpFWGO/.future/immediateConditions")
[13:21:34.492]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.492]                   {
[13:21:34.492]                     inherits <- base::inherits
[13:21:34.492]                     invokeRestart <- base::invokeRestart
[13:21:34.492]                     is.null <- base::is.null
[13:21:34.492]                     muffled <- FALSE
[13:21:34.492]                     if (inherits(cond, "message")) {
[13:21:34.492]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:34.492]                       if (muffled) 
[13:21:34.492]                         invokeRestart("muffleMessage")
[13:21:34.492]                     }
[13:21:34.492]                     else if (inherits(cond, "warning")) {
[13:21:34.492]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:34.492]                       if (muffled) 
[13:21:34.492]                         invokeRestart("muffleWarning")
[13:21:34.492]                     }
[13:21:34.492]                     else if (inherits(cond, "condition")) {
[13:21:34.492]                       if (!is.null(pattern)) {
[13:21:34.492]                         computeRestarts <- base::computeRestarts
[13:21:34.492]                         grepl <- base::grepl
[13:21:34.492]                         restarts <- computeRestarts(cond)
[13:21:34.492]                         for (restart in restarts) {
[13:21:34.492]                           name <- restart$name
[13:21:34.492]                           if (is.null(name)) 
[13:21:34.492]                             next
[13:21:34.492]                           if (!grepl(pattern, name)) 
[13:21:34.492]                             next
[13:21:34.492]                           invokeRestart(restart)
[13:21:34.492]                           muffled <- TRUE
[13:21:34.492]                           break
[13:21:34.492]                         }
[13:21:34.492]                       }
[13:21:34.492]                     }
[13:21:34.492]                     invisible(muffled)
[13:21:34.492]                   }
[13:21:34.492]                   muffleCondition(cond)
[13:21:34.492]                 })
[13:21:34.492]             }))
[13:21:34.492]             future::FutureResult(value = ...future.value$value, 
[13:21:34.492]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:34.492]                   ...future.rng), globalenv = if (FALSE) 
[13:21:34.492]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:34.492]                     ...future.globalenv.names))
[13:21:34.492]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:34.492]         }, condition = base::local({
[13:21:34.492]             c <- base::c
[13:21:34.492]             inherits <- base::inherits
[13:21:34.492]             invokeRestart <- base::invokeRestart
[13:21:34.492]             length <- base::length
[13:21:34.492]             list <- base::list
[13:21:34.492]             seq.int <- base::seq.int
[13:21:34.492]             signalCondition <- base::signalCondition
[13:21:34.492]             sys.calls <- base::sys.calls
[13:21:34.492]             `[[` <- base::`[[`
[13:21:34.492]             `+` <- base::`+`
[13:21:34.492]             `<<-` <- base::`<<-`
[13:21:34.492]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:34.492]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:34.492]                   3L)]
[13:21:34.492]             }
[13:21:34.492]             function(cond) {
[13:21:34.492]                 is_error <- inherits(cond, "error")
[13:21:34.492]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:34.492]                   NULL)
[13:21:34.492]                 if (is_error) {
[13:21:34.492]                   sessionInformation <- function() {
[13:21:34.492]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:34.492]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:34.492]                       search = base::search(), system = base::Sys.info())
[13:21:34.492]                   }
[13:21:34.492]                   ...future.conditions[[length(...future.conditions) + 
[13:21:34.492]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:34.492]                     cond$call), session = sessionInformation(), 
[13:21:34.492]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:34.492]                   signalCondition(cond)
[13:21:34.492]                 }
[13:21:34.492]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:34.492]                 "immediateCondition"))) {
[13:21:34.492]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:34.492]                   ...future.conditions[[length(...future.conditions) + 
[13:21:34.492]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:34.492]                   if (TRUE && !signal) {
[13:21:34.492]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.492]                     {
[13:21:34.492]                       inherits <- base::inherits
[13:21:34.492]                       invokeRestart <- base::invokeRestart
[13:21:34.492]                       is.null <- base::is.null
[13:21:34.492]                       muffled <- FALSE
[13:21:34.492]                       if (inherits(cond, "message")) {
[13:21:34.492]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:34.492]                         if (muffled) 
[13:21:34.492]                           invokeRestart("muffleMessage")
[13:21:34.492]                       }
[13:21:34.492]                       else if (inherits(cond, "warning")) {
[13:21:34.492]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:34.492]                         if (muffled) 
[13:21:34.492]                           invokeRestart("muffleWarning")
[13:21:34.492]                       }
[13:21:34.492]                       else if (inherits(cond, "condition")) {
[13:21:34.492]                         if (!is.null(pattern)) {
[13:21:34.492]                           computeRestarts <- base::computeRestarts
[13:21:34.492]                           grepl <- base::grepl
[13:21:34.492]                           restarts <- computeRestarts(cond)
[13:21:34.492]                           for (restart in restarts) {
[13:21:34.492]                             name <- restart$name
[13:21:34.492]                             if (is.null(name)) 
[13:21:34.492]                               next
[13:21:34.492]                             if (!grepl(pattern, name)) 
[13:21:34.492]                               next
[13:21:34.492]                             invokeRestart(restart)
[13:21:34.492]                             muffled <- TRUE
[13:21:34.492]                             break
[13:21:34.492]                           }
[13:21:34.492]                         }
[13:21:34.492]                       }
[13:21:34.492]                       invisible(muffled)
[13:21:34.492]                     }
[13:21:34.492]                     muffleCondition(cond, pattern = "^muffle")
[13:21:34.492]                   }
[13:21:34.492]                 }
[13:21:34.492]                 else {
[13:21:34.492]                   if (TRUE) {
[13:21:34.492]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.492]                     {
[13:21:34.492]                       inherits <- base::inherits
[13:21:34.492]                       invokeRestart <- base::invokeRestart
[13:21:34.492]                       is.null <- base::is.null
[13:21:34.492]                       muffled <- FALSE
[13:21:34.492]                       if (inherits(cond, "message")) {
[13:21:34.492]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:34.492]                         if (muffled) 
[13:21:34.492]                           invokeRestart("muffleMessage")
[13:21:34.492]                       }
[13:21:34.492]                       else if (inherits(cond, "warning")) {
[13:21:34.492]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:34.492]                         if (muffled) 
[13:21:34.492]                           invokeRestart("muffleWarning")
[13:21:34.492]                       }
[13:21:34.492]                       else if (inherits(cond, "condition")) {
[13:21:34.492]                         if (!is.null(pattern)) {
[13:21:34.492]                           computeRestarts <- base::computeRestarts
[13:21:34.492]                           grepl <- base::grepl
[13:21:34.492]                           restarts <- computeRestarts(cond)
[13:21:34.492]                           for (restart in restarts) {
[13:21:34.492]                             name <- restart$name
[13:21:34.492]                             if (is.null(name)) 
[13:21:34.492]                               next
[13:21:34.492]                             if (!grepl(pattern, name)) 
[13:21:34.492]                               next
[13:21:34.492]                             invokeRestart(restart)
[13:21:34.492]                             muffled <- TRUE
[13:21:34.492]                             break
[13:21:34.492]                           }
[13:21:34.492]                         }
[13:21:34.492]                       }
[13:21:34.492]                       invisible(muffled)
[13:21:34.492]                     }
[13:21:34.492]                     muffleCondition(cond, pattern = "^muffle")
[13:21:34.492]                   }
[13:21:34.492]                 }
[13:21:34.492]             }
[13:21:34.492]         }))
[13:21:34.492]     }, error = function(ex) {
[13:21:34.492]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:34.492]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:34.492]                 ...future.rng), started = ...future.startTime, 
[13:21:34.492]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:34.492]             version = "1.8"), class = "FutureResult")
[13:21:34.492]     }, finally = {
[13:21:34.492]         if (!identical(...future.workdir, getwd())) 
[13:21:34.492]             setwd(...future.workdir)
[13:21:34.492]         {
[13:21:34.492]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:34.492]                 ...future.oldOptions$nwarnings <- NULL
[13:21:34.492]             }
[13:21:34.492]             base::options(...future.oldOptions)
[13:21:34.492]             if (.Platform$OS.type == "windows") {
[13:21:34.492]                 old_names <- names(...future.oldEnvVars)
[13:21:34.492]                 envs <- base::Sys.getenv()
[13:21:34.492]                 names <- names(envs)
[13:21:34.492]                 common <- intersect(names, old_names)
[13:21:34.492]                 added <- setdiff(names, old_names)
[13:21:34.492]                 removed <- setdiff(old_names, names)
[13:21:34.492]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:34.492]                   envs[common]]
[13:21:34.492]                 NAMES <- toupper(changed)
[13:21:34.492]                 args <- list()
[13:21:34.492]                 for (kk in seq_along(NAMES)) {
[13:21:34.492]                   name <- changed[[kk]]
[13:21:34.492]                   NAME <- NAMES[[kk]]
[13:21:34.492]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.492]                     next
[13:21:34.492]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:34.492]                 }
[13:21:34.492]                 NAMES <- toupper(added)
[13:21:34.492]                 for (kk in seq_along(NAMES)) {
[13:21:34.492]                   name <- added[[kk]]
[13:21:34.492]                   NAME <- NAMES[[kk]]
[13:21:34.492]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.492]                     next
[13:21:34.492]                   args[[name]] <- ""
[13:21:34.492]                 }
[13:21:34.492]                 NAMES <- toupper(removed)
[13:21:34.492]                 for (kk in seq_along(NAMES)) {
[13:21:34.492]                   name <- removed[[kk]]
[13:21:34.492]                   NAME <- NAMES[[kk]]
[13:21:34.492]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.492]                     next
[13:21:34.492]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:34.492]                 }
[13:21:34.492]                 if (length(args) > 0) 
[13:21:34.492]                   base::do.call(base::Sys.setenv, args = args)
[13:21:34.492]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:34.492]             }
[13:21:34.492]             else {
[13:21:34.492]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:34.492]             }
[13:21:34.492]             {
[13:21:34.492]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:34.492]                   0L) {
[13:21:34.492]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:34.492]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:34.492]                   base::options(opts)
[13:21:34.492]                 }
[13:21:34.492]                 {
[13:21:34.492]                   {
[13:21:34.492]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:34.492]                     NULL
[13:21:34.492]                   }
[13:21:34.492]                   options(future.plan = NULL)
[13:21:34.492]                   if (is.na(NA_character_)) 
[13:21:34.492]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:34.492]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:34.492]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:34.492]                     envir = parent.frame()) 
[13:21:34.492]                   {
[13:21:34.492]                     default_workers <- missing(workers)
[13:21:34.492]                     if (is.function(workers)) 
[13:21:34.492]                       workers <- workers()
[13:21:34.492]                     workers <- structure(as.integer(workers), 
[13:21:34.492]                       class = class(workers))
[13:21:34.492]                     stop_if_not(is.finite(workers), workers >= 
[13:21:34.492]                       1L)
[13:21:34.492]                     if ((workers == 1L && !inherits(workers, 
[13:21:34.492]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:34.492]                       if (default_workers) 
[13:21:34.492]                         supportsMulticore(warn = TRUE)
[13:21:34.492]                       return(sequential(..., envir = envir))
[13:21:34.492]                     }
[13:21:34.492]                     oopts <- options(mc.cores = workers)
[13:21:34.492]                     on.exit(options(oopts))
[13:21:34.492]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:34.492]                       envir = envir)
[13:21:34.492]                     if (!future$lazy) 
[13:21:34.492]                       future <- run(future)
[13:21:34.492]                     invisible(future)
[13:21:34.492]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:34.492]                 }
[13:21:34.492]             }
[13:21:34.492]         }
[13:21:34.492]     })
[13:21:34.492]     if (TRUE) {
[13:21:34.492]         base::sink(type = "output", split = FALSE)
[13:21:34.492]         if (TRUE) {
[13:21:34.492]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:34.492]         }
[13:21:34.492]         else {
[13:21:34.492]             ...future.result["stdout"] <- base::list(NULL)
[13:21:34.492]         }
[13:21:34.492]         base::close(...future.stdout)
[13:21:34.492]         ...future.stdout <- NULL
[13:21:34.492]     }
[13:21:34.492]     ...future.result$conditions <- ...future.conditions
[13:21:34.492]     ...future.result$finished <- base::Sys.time()
[13:21:34.492]     ...future.result
[13:21:34.492] }
[13:21:34.494] assign_globals() ...
[13:21:34.495] List of 11
[13:21:34.495]  $ ...future.FUN            :function (x, ...)  
[13:21:34.495]  $ x_FUN                    :function (x, ...)  
[13:21:34.495]  $ times                    : int 5
[13:21:34.495]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:34.495]  $ stop_if_not              :function (...)  
[13:21:34.495]  $ dim                      : NULL
[13:21:34.495]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:21:34.495]  $ future.call.arguments    : list()
[13:21:34.495]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:34.495]  $ ...future.elements_ii    :List of 1
[13:21:34.495]   ..$ a: int [1:10] 1 2 3 4 5 6 7 8 9 10
[13:21:34.495]  $ ...future.seeds_ii       : NULL
[13:21:34.495]  $ ...future.globals.maxSize: NULL
[13:21:34.495]  - attr(*, "where")=List of 11
[13:21:34.495]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:34.495]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:34.495]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:34.495]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:34.495]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:34.495]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:34.495]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:34.495]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:34.495]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:34.495]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:34.495]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:34.495]  - attr(*, "resolved")= logi FALSE
[13:21:34.495]  - attr(*, "total_size")= num 95528
[13:21:34.495]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:34.495]  - attr(*, "already-done")= logi TRUE
[13:21:34.506] - copied ‘...future.FUN’ to environment
[13:21:34.506] - copied ‘x_FUN’ to environment
[13:21:34.506] - copied ‘times’ to environment
[13:21:34.506] - copied ‘stopf’ to environment
[13:21:34.506] - copied ‘stop_if_not’ to environment
[13:21:34.506] - copied ‘dim’ to environment
[13:21:34.507] - copied ‘valid_types’ to environment
[13:21:34.507] - copied ‘future.call.arguments’ to environment
[13:21:34.507] - copied ‘...future.elements_ii’ to environment
[13:21:34.507] - copied ‘...future.seeds_ii’ to environment
[13:21:34.507] - copied ‘...future.globals.maxSize’ to environment
[13:21:34.507] assign_globals() ... done
[13:21:34.507] requestCore(): workers = 2
[13:21:34.510] MulticoreFuture started
[13:21:34.510] - Launch lazy future ... done
[13:21:34.510] run() for ‘MulticoreFuture’ ... done
[13:21:34.511] Created future:
[13:21:34.511] plan(): Setting new future strategy stack:
[13:21:34.512] List of future strategies:
[13:21:34.512] 1. sequential:
[13:21:34.512]    - args: function (..., envir = parent.frame())
[13:21:34.512]    - tweaked: FALSE
[13:21:34.512]    - call: NULL
[13:21:34.512] plan(): nbrOfWorkers() = 1
[13:21:34.515] plan(): Setting new future strategy stack:
[13:21:34.515] List of future strategies:
[13:21:34.515] 1. multicore:
[13:21:34.515]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:34.515]    - tweaked: FALSE
[13:21:34.515]    - call: plan(strategy)
[13:21:34.521] plan(): nbrOfWorkers() = 2
[13:21:34.511] MulticoreFuture:
[13:21:34.511] Label: ‘future_vapply-1’
[13:21:34.511] Expression:
[13:21:34.511] {
[13:21:34.511]     do.call(function(...) {
[13:21:34.511]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.511]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:34.511]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.511]             on.exit(options(oopts), add = TRUE)
[13:21:34.511]         }
[13:21:34.511]         {
[13:21:34.511]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:34.511]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.511]                 ...future.FUN(...future.X_jj, ...)
[13:21:34.511]             })
[13:21:34.511]         }
[13:21:34.511]     }, args = future.call.arguments)
[13:21:34.511] }
[13:21:34.511] Lazy evaluation: FALSE
[13:21:34.511] Asynchronous evaluation: TRUE
[13:21:34.511] Local evaluation: TRUE
[13:21:34.511] Environment: R_GlobalEnv
[13:21:34.511] Capture standard output: TRUE
[13:21:34.511] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:34.511] Globals: 11 objects totaling 93.38 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:34.511] Packages: 2 packages (‘stats’, ‘future.apply’)
[13:21:34.511] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:34.511] Resolved: TRUE
[13:21:34.511] Value: <not collected>
[13:21:34.511] Conditions captured: <none>
[13:21:34.511] Early signaling: FALSE
[13:21:34.511] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:34.511] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:34.522] Chunk #1 of 2 ... DONE
[13:21:34.523] Chunk #2 of 2 ...
[13:21:34.523]  - Finding globals in 'X' for chunk #2 ...
[13:21:34.523] getGlobalsAndPackages() ...
[13:21:34.523] Searching for globals...
[13:21:34.524] 
[13:21:34.524] Searching for globals ... DONE
[13:21:34.524] - globals: [0] <none>
[13:21:34.524] getGlobalsAndPackages() ... DONE
[13:21:34.524]    + additional globals found: [n=0] 
[13:21:34.524]    + additional namespaces needed: [n=0] 
[13:21:34.525]  - Finding globals in 'X' for chunk #2 ... DONE
[13:21:34.525]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:34.525]  - seeds: <none>
[13:21:34.525]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.525] getGlobalsAndPackages() ...
[13:21:34.525] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.526] Resolving globals: FALSE
[13:21:34.526] Tweak future expression to call with '...' arguments ...
[13:21:34.526] {
[13:21:34.526]     do.call(function(...) {
[13:21:34.526]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.526]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:34.526]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.526]             on.exit(options(oopts), add = TRUE)
[13:21:34.526]         }
[13:21:34.526]         {
[13:21:34.526]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:34.526]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.526]                 ...future.FUN(...future.X_jj, ...)
[13:21:34.526]             })
[13:21:34.526]         }
[13:21:34.526]     }, args = future.call.arguments)
[13:21:34.526] }
[13:21:34.526] Tweak future expression to call with '...' arguments ... DONE
[13:21:34.527] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.528] - packages: [2] ‘stats’, ‘future.apply’
[13:21:34.528] getGlobalsAndPackages() ... DONE
[13:21:34.529] run() for ‘Future’ ...
[13:21:34.529] - state: ‘created’
[13:21:34.529] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:34.534] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:34.534] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:34.534]   - Field: ‘label’
[13:21:34.535]   - Field: ‘local’
[13:21:34.535]   - Field: ‘owner’
[13:21:34.535]   - Field: ‘envir’
[13:21:34.535]   - Field: ‘workers’
[13:21:34.535]   - Field: ‘packages’
[13:21:34.535]   - Field: ‘gc’
[13:21:34.535]   - Field: ‘job’
[13:21:34.536]   - Field: ‘conditions’
[13:21:34.536]   - Field: ‘expr’
[13:21:34.536]   - Field: ‘uuid’
[13:21:34.536]   - Field: ‘seed’
[13:21:34.536]   - Field: ‘version’
[13:21:34.536]   - Field: ‘result’
[13:21:34.537]   - Field: ‘asynchronous’
[13:21:34.537]   - Field: ‘calls’
[13:21:34.537]   - Field: ‘globals’
[13:21:34.537]   - Field: ‘stdout’
[13:21:34.537]   - Field: ‘earlySignal’
[13:21:34.537]   - Field: ‘lazy’
[13:21:34.540]   - Field: ‘state’
[13:21:34.541] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:34.541] - Launch lazy future ...
[13:21:34.542] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[13:21:34.542] Packages needed by future strategies (n = 0): <none>
[13:21:34.544] {
[13:21:34.544]     {
[13:21:34.544]         {
[13:21:34.544]             ...future.startTime <- base::Sys.time()
[13:21:34.544]             {
[13:21:34.544]                 {
[13:21:34.544]                   {
[13:21:34.544]                     {
[13:21:34.544]                       {
[13:21:34.544]                         base::local({
[13:21:34.544]                           has_future <- base::requireNamespace("future", 
[13:21:34.544]                             quietly = TRUE)
[13:21:34.544]                           if (has_future) {
[13:21:34.544]                             ns <- base::getNamespace("future")
[13:21:34.544]                             version <- ns[[".package"]][["version"]]
[13:21:34.544]                             if (is.null(version)) 
[13:21:34.544]                               version <- utils::packageVersion("future")
[13:21:34.544]                           }
[13:21:34.544]                           else {
[13:21:34.544]                             version <- NULL
[13:21:34.544]                           }
[13:21:34.544]                           if (!has_future || version < "1.8.0") {
[13:21:34.544]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:34.544]                               "", base::R.version$version.string), 
[13:21:34.544]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:34.544]                                 base::R.version$platform, 8 * 
[13:21:34.544]                                   base::.Machine$sizeof.pointer), 
[13:21:34.544]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:34.544]                                 "release", "version")], collapse = " "), 
[13:21:34.544]                               hostname = base::Sys.info()[["nodename"]])
[13:21:34.544]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:34.544]                               info)
[13:21:34.544]                             info <- base::paste(info, collapse = "; ")
[13:21:34.544]                             if (!has_future) {
[13:21:34.544]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:34.544]                                 info)
[13:21:34.544]                             }
[13:21:34.544]                             else {
[13:21:34.544]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:34.544]                                 info, version)
[13:21:34.544]                             }
[13:21:34.544]                             base::stop(msg)
[13:21:34.544]                           }
[13:21:34.544]                         })
[13:21:34.544]                       }
[13:21:34.544]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:34.544]                       base::options(mc.cores = 1L)
[13:21:34.544]                     }
[13:21:34.544]                     base::local({
[13:21:34.544]                       for (pkg in c("stats", "future.apply")) {
[13:21:34.544]                         base::loadNamespace(pkg)
[13:21:34.544]                         base::library(pkg, character.only = TRUE)
[13:21:34.544]                       }
[13:21:34.544]                     })
[13:21:34.544]                   }
[13:21:34.544]                   options(future.plan = NULL)
[13:21:34.544]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:34.544]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:34.544]                 }
[13:21:34.544]                 ...future.workdir <- getwd()
[13:21:34.544]             }
[13:21:34.544]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:34.544]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:34.544]         }
[13:21:34.544]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:34.544]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:34.544]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:34.544]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:34.544]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:34.544]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:34.544]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:34.544]             base::names(...future.oldOptions))
[13:21:34.544]     }
[13:21:34.544]     if (FALSE) {
[13:21:34.544]     }
[13:21:34.544]     else {
[13:21:34.544]         if (TRUE) {
[13:21:34.544]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:34.544]                 open = "w")
[13:21:34.544]         }
[13:21:34.544]         else {
[13:21:34.544]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:34.544]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:34.544]         }
[13:21:34.544]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:34.544]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:34.544]             base::sink(type = "output", split = FALSE)
[13:21:34.544]             base::close(...future.stdout)
[13:21:34.544]         }, add = TRUE)
[13:21:34.544]     }
[13:21:34.544]     ...future.frame <- base::sys.nframe()
[13:21:34.544]     ...future.conditions <- base::list()
[13:21:34.544]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:34.544]     if (FALSE) {
[13:21:34.544]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:34.544]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:34.544]     }
[13:21:34.544]     ...future.result <- base::tryCatch({
[13:21:34.544]         base::withCallingHandlers({
[13:21:34.544]             ...future.value <- base::withVisible(base::local({
[13:21:34.544]                 withCallingHandlers({
[13:21:34.544]                   {
[13:21:34.544]                     do.call(function(...) {
[13:21:34.544]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.544]                       if (!identical(...future.globals.maxSize.org, 
[13:21:34.544]                         ...future.globals.maxSize)) {
[13:21:34.544]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.544]                         on.exit(options(oopts), add = TRUE)
[13:21:34.544]                       }
[13:21:34.544]                       {
[13:21:34.544]                         lapply(seq_along(...future.elements_ii), 
[13:21:34.544]                           FUN = function(jj) {
[13:21:34.544]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.544]                             ...future.FUN(...future.X_jj, ...)
[13:21:34.544]                           })
[13:21:34.544]                       }
[13:21:34.544]                     }, args = future.call.arguments)
[13:21:34.544]                   }
[13:21:34.544]                 }, immediateCondition = function(cond) {
[13:21:34.544]                   save_rds <- function (object, pathname, ...) 
[13:21:34.544]                   {
[13:21:34.544]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:34.544]                     if (file_test("-f", pathname_tmp)) {
[13:21:34.544]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.544]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:34.544]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.544]                         fi_tmp[["mtime"]])
[13:21:34.544]                     }
[13:21:34.544]                     tryCatch({
[13:21:34.544]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:34.544]                     }, error = function(ex) {
[13:21:34.544]                       msg <- conditionMessage(ex)
[13:21:34.544]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.544]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:34.544]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.544]                         fi_tmp[["mtime"]], msg)
[13:21:34.544]                       ex$message <- msg
[13:21:34.544]                       stop(ex)
[13:21:34.544]                     })
[13:21:34.544]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:34.544]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:34.544]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:34.544]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.544]                       fi <- file.info(pathname)
[13:21:34.544]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:34.544]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.544]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:34.544]                         fi[["size"]], fi[["mtime"]])
[13:21:34.544]                       stop(msg)
[13:21:34.544]                     }
[13:21:34.544]                     invisible(pathname)
[13:21:34.544]                   }
[13:21:34.544]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:34.544]                     rootPath = tempdir()) 
[13:21:34.544]                   {
[13:21:34.544]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:34.544]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:34.544]                       tmpdir = path, fileext = ".rds")
[13:21:34.544]                     save_rds(obj, file)
[13:21:34.544]                   }
[13:21:34.544]                   saveImmediateCondition(cond, path = "/tmp/RtmpbpFWGO/.future/immediateConditions")
[13:21:34.544]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.544]                   {
[13:21:34.544]                     inherits <- base::inherits
[13:21:34.544]                     invokeRestart <- base::invokeRestart
[13:21:34.544]                     is.null <- base::is.null
[13:21:34.544]                     muffled <- FALSE
[13:21:34.544]                     if (inherits(cond, "message")) {
[13:21:34.544]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:34.544]                       if (muffled) 
[13:21:34.544]                         invokeRestart("muffleMessage")
[13:21:34.544]                     }
[13:21:34.544]                     else if (inherits(cond, "warning")) {
[13:21:34.544]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:34.544]                       if (muffled) 
[13:21:34.544]                         invokeRestart("muffleWarning")
[13:21:34.544]                     }
[13:21:34.544]                     else if (inherits(cond, "condition")) {
[13:21:34.544]                       if (!is.null(pattern)) {
[13:21:34.544]                         computeRestarts <- base::computeRestarts
[13:21:34.544]                         grepl <- base::grepl
[13:21:34.544]                         restarts <- computeRestarts(cond)
[13:21:34.544]                         for (restart in restarts) {
[13:21:34.544]                           name <- restart$name
[13:21:34.544]                           if (is.null(name)) 
[13:21:34.544]                             next
[13:21:34.544]                           if (!grepl(pattern, name)) 
[13:21:34.544]                             next
[13:21:34.544]                           invokeRestart(restart)
[13:21:34.544]                           muffled <- TRUE
[13:21:34.544]                           break
[13:21:34.544]                         }
[13:21:34.544]                       }
[13:21:34.544]                     }
[13:21:34.544]                     invisible(muffled)
[13:21:34.544]                   }
[13:21:34.544]                   muffleCondition(cond)
[13:21:34.544]                 })
[13:21:34.544]             }))
[13:21:34.544]             future::FutureResult(value = ...future.value$value, 
[13:21:34.544]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:34.544]                   ...future.rng), globalenv = if (FALSE) 
[13:21:34.544]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:34.544]                     ...future.globalenv.names))
[13:21:34.544]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:34.544]         }, condition = base::local({
[13:21:34.544]             c <- base::c
[13:21:34.544]             inherits <- base::inherits
[13:21:34.544]             invokeRestart <- base::invokeRestart
[13:21:34.544]             length <- base::length
[13:21:34.544]             list <- base::list
[13:21:34.544]             seq.int <- base::seq.int
[13:21:34.544]             signalCondition <- base::signalCondition
[13:21:34.544]             sys.calls <- base::sys.calls
[13:21:34.544]             `[[` <- base::`[[`
[13:21:34.544]             `+` <- base::`+`
[13:21:34.544]             `<<-` <- base::`<<-`
[13:21:34.544]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:34.544]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:34.544]                   3L)]
[13:21:34.544]             }
[13:21:34.544]             function(cond) {
[13:21:34.544]                 is_error <- inherits(cond, "error")
[13:21:34.544]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:34.544]                   NULL)
[13:21:34.544]                 if (is_error) {
[13:21:34.544]                   sessionInformation <- function() {
[13:21:34.544]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:34.544]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:34.544]                       search = base::search(), system = base::Sys.info())
[13:21:34.544]                   }
[13:21:34.544]                   ...future.conditions[[length(...future.conditions) + 
[13:21:34.544]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:34.544]                     cond$call), session = sessionInformation(), 
[13:21:34.544]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:34.544]                   signalCondition(cond)
[13:21:34.544]                 }
[13:21:34.544]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:34.544]                 "immediateCondition"))) {
[13:21:34.544]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:34.544]                   ...future.conditions[[length(...future.conditions) + 
[13:21:34.544]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:34.544]                   if (TRUE && !signal) {
[13:21:34.544]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.544]                     {
[13:21:34.544]                       inherits <- base::inherits
[13:21:34.544]                       invokeRestart <- base::invokeRestart
[13:21:34.544]                       is.null <- base::is.null
[13:21:34.544]                       muffled <- FALSE
[13:21:34.544]                       if (inherits(cond, "message")) {
[13:21:34.544]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:34.544]                         if (muffled) 
[13:21:34.544]                           invokeRestart("muffleMessage")
[13:21:34.544]                       }
[13:21:34.544]                       else if (inherits(cond, "warning")) {
[13:21:34.544]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:34.544]                         if (muffled) 
[13:21:34.544]                           invokeRestart("muffleWarning")
[13:21:34.544]                       }
[13:21:34.544]                       else if (inherits(cond, "condition")) {
[13:21:34.544]                         if (!is.null(pattern)) {
[13:21:34.544]                           computeRestarts <- base::computeRestarts
[13:21:34.544]                           grepl <- base::grepl
[13:21:34.544]                           restarts <- computeRestarts(cond)
[13:21:34.544]                           for (restart in restarts) {
[13:21:34.544]                             name <- restart$name
[13:21:34.544]                             if (is.null(name)) 
[13:21:34.544]                               next
[13:21:34.544]                             if (!grepl(pattern, name)) 
[13:21:34.544]                               next
[13:21:34.544]                             invokeRestart(restart)
[13:21:34.544]                             muffled <- TRUE
[13:21:34.544]                             break
[13:21:34.544]                           }
[13:21:34.544]                         }
[13:21:34.544]                       }
[13:21:34.544]                       invisible(muffled)
[13:21:34.544]                     }
[13:21:34.544]                     muffleCondition(cond, pattern = "^muffle")
[13:21:34.544]                   }
[13:21:34.544]                 }
[13:21:34.544]                 else {
[13:21:34.544]                   if (TRUE) {
[13:21:34.544]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.544]                     {
[13:21:34.544]                       inherits <- base::inherits
[13:21:34.544]                       invokeRestart <- base::invokeRestart
[13:21:34.544]                       is.null <- base::is.null
[13:21:34.544]                       muffled <- FALSE
[13:21:34.544]                       if (inherits(cond, "message")) {
[13:21:34.544]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:34.544]                         if (muffled) 
[13:21:34.544]                           invokeRestart("muffleMessage")
[13:21:34.544]                       }
[13:21:34.544]                       else if (inherits(cond, "warning")) {
[13:21:34.544]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:34.544]                         if (muffled) 
[13:21:34.544]                           invokeRestart("muffleWarning")
[13:21:34.544]                       }
[13:21:34.544]                       else if (inherits(cond, "condition")) {
[13:21:34.544]                         if (!is.null(pattern)) {
[13:21:34.544]                           computeRestarts <- base::computeRestarts
[13:21:34.544]                           grepl <- base::grepl
[13:21:34.544]                           restarts <- computeRestarts(cond)
[13:21:34.544]                           for (restart in restarts) {
[13:21:34.544]                             name <- restart$name
[13:21:34.544]                             if (is.null(name)) 
[13:21:34.544]                               next
[13:21:34.544]                             if (!grepl(pattern, name)) 
[13:21:34.544]                               next
[13:21:34.544]                             invokeRestart(restart)
[13:21:34.544]                             muffled <- TRUE
[13:21:34.544]                             break
[13:21:34.544]                           }
[13:21:34.544]                         }
[13:21:34.544]                       }
[13:21:34.544]                       invisible(muffled)
[13:21:34.544]                     }
[13:21:34.544]                     muffleCondition(cond, pattern = "^muffle")
[13:21:34.544]                   }
[13:21:34.544]                 }
[13:21:34.544]             }
[13:21:34.544]         }))
[13:21:34.544]     }, error = function(ex) {
[13:21:34.544]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:34.544]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:34.544]                 ...future.rng), started = ...future.startTime, 
[13:21:34.544]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:34.544]             version = "1.8"), class = "FutureResult")
[13:21:34.544]     }, finally = {
[13:21:34.544]         if (!identical(...future.workdir, getwd())) 
[13:21:34.544]             setwd(...future.workdir)
[13:21:34.544]         {
[13:21:34.544]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:34.544]                 ...future.oldOptions$nwarnings <- NULL
[13:21:34.544]             }
[13:21:34.544]             base::options(...future.oldOptions)
[13:21:34.544]             if (.Platform$OS.type == "windows") {
[13:21:34.544]                 old_names <- names(...future.oldEnvVars)
[13:21:34.544]                 envs <- base::Sys.getenv()
[13:21:34.544]                 names <- names(envs)
[13:21:34.544]                 common <- intersect(names, old_names)
[13:21:34.544]                 added <- setdiff(names, old_names)
[13:21:34.544]                 removed <- setdiff(old_names, names)
[13:21:34.544]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:34.544]                   envs[common]]
[13:21:34.544]                 NAMES <- toupper(changed)
[13:21:34.544]                 args <- list()
[13:21:34.544]                 for (kk in seq_along(NAMES)) {
[13:21:34.544]                   name <- changed[[kk]]
[13:21:34.544]                   NAME <- NAMES[[kk]]
[13:21:34.544]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.544]                     next
[13:21:34.544]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:34.544]                 }
[13:21:34.544]                 NAMES <- toupper(added)
[13:21:34.544]                 for (kk in seq_along(NAMES)) {
[13:21:34.544]                   name <- added[[kk]]
[13:21:34.544]                   NAME <- NAMES[[kk]]
[13:21:34.544]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.544]                     next
[13:21:34.544]                   args[[name]] <- ""
[13:21:34.544]                 }
[13:21:34.544]                 NAMES <- toupper(removed)
[13:21:34.544]                 for (kk in seq_along(NAMES)) {
[13:21:34.544]                   name <- removed[[kk]]
[13:21:34.544]                   NAME <- NAMES[[kk]]
[13:21:34.544]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.544]                     next
[13:21:34.544]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:34.544]                 }
[13:21:34.544]                 if (length(args) > 0) 
[13:21:34.544]                   base::do.call(base::Sys.setenv, args = args)
[13:21:34.544]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:34.544]             }
[13:21:34.544]             else {
[13:21:34.544]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:34.544]             }
[13:21:34.544]             {
[13:21:34.544]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:34.544]                   0L) {
[13:21:34.544]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:34.544]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:34.544]                   base::options(opts)
[13:21:34.544]                 }
[13:21:34.544]                 {
[13:21:34.544]                   {
[13:21:34.544]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:34.544]                     NULL
[13:21:34.544]                   }
[13:21:34.544]                   options(future.plan = NULL)
[13:21:34.544]                   if (is.na(NA_character_)) 
[13:21:34.544]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:34.544]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:34.544]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:34.544]                     envir = parent.frame()) 
[13:21:34.544]                   {
[13:21:34.544]                     default_workers <- missing(workers)
[13:21:34.544]                     if (is.function(workers)) 
[13:21:34.544]                       workers <- workers()
[13:21:34.544]                     workers <- structure(as.integer(workers), 
[13:21:34.544]                       class = class(workers))
[13:21:34.544]                     stop_if_not(is.finite(workers), workers >= 
[13:21:34.544]                       1L)
[13:21:34.544]                     if ((workers == 1L && !inherits(workers, 
[13:21:34.544]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:34.544]                       if (default_workers) 
[13:21:34.544]                         supportsMulticore(warn = TRUE)
[13:21:34.544]                       return(sequential(..., envir = envir))
[13:21:34.544]                     }
[13:21:34.544]                     oopts <- options(mc.cores = workers)
[13:21:34.544]                     on.exit(options(oopts))
[13:21:34.544]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:34.544]                       envir = envir)
[13:21:34.544]                     if (!future$lazy) 
[13:21:34.544]                       future <- run(future)
[13:21:34.544]                     invisible(future)
[13:21:34.544]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:34.544]                 }
[13:21:34.544]             }
[13:21:34.544]         }
[13:21:34.544]     })
[13:21:34.544]     if (TRUE) {
[13:21:34.544]         base::sink(type = "output", split = FALSE)
[13:21:34.544]         if (TRUE) {
[13:21:34.544]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:34.544]         }
[13:21:34.544]         else {
[13:21:34.544]             ...future.result["stdout"] <- base::list(NULL)
[13:21:34.544]         }
[13:21:34.544]         base::close(...future.stdout)
[13:21:34.544]         ...future.stdout <- NULL
[13:21:34.544]     }
[13:21:34.544]     ...future.result$conditions <- ...future.conditions
[13:21:34.544]     ...future.result$finished <- base::Sys.time()
[13:21:34.544]     ...future.result
[13:21:34.544] }
[13:21:34.548] assign_globals() ...
[13:21:34.548] List of 11
[13:21:34.548]  $ ...future.FUN            :function (x, ...)  
[13:21:34.548]  $ x_FUN                    :function (x, ...)  
[13:21:34.548]  $ times                    : int 5
[13:21:34.548]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:34.548]  $ stop_if_not              :function (...)  
[13:21:34.548]  $ dim                      : NULL
[13:21:34.548]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:21:34.548]  $ future.call.arguments    : list()
[13:21:34.548]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:34.548]  $ ...future.elements_ii    :List of 2
[13:21:34.548]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[13:21:34.548]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[13:21:34.548]  $ ...future.seeds_ii       : NULL
[13:21:34.548]  $ ...future.globals.maxSize: NULL
[13:21:34.548]  - attr(*, "where")=List of 11
[13:21:34.548]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:34.548]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:34.548]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:34.548]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:34.548]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:34.548]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:34.548]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:34.548]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:34.548]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:34.548]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:34.548]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:34.548]  - attr(*, "resolved")= logi FALSE
[13:21:34.548]  - attr(*, "total_size")= num 95528
[13:21:34.548]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:34.548]  - attr(*, "already-done")= logi TRUE
[13:21:34.562] - copied ‘...future.FUN’ to environment
[13:21:34.562] - copied ‘x_FUN’ to environment
[13:21:34.562] - copied ‘times’ to environment
[13:21:34.562] - copied ‘stopf’ to environment
[13:21:34.562] - copied ‘stop_if_not’ to environment
[13:21:34.562] - copied ‘dim’ to environment
[13:21:34.562] - copied ‘valid_types’ to environment
[13:21:34.563] - copied ‘future.call.arguments’ to environment
[13:21:34.563] - copied ‘...future.elements_ii’ to environment
[13:21:34.563] - copied ‘...future.seeds_ii’ to environment
[13:21:34.563] - copied ‘...future.globals.maxSize’ to environment
[13:21:34.563] assign_globals() ... done
[13:21:34.563] requestCore(): workers = 2
[13:21:34.566] MulticoreFuture started
[13:21:34.566] - Launch lazy future ... done
[13:21:34.566] run() for ‘MulticoreFuture’ ... done
[13:21:34.566] Created future:
[13:21:34.567] plan(): Setting new future strategy stack:
[13:21:34.567] List of future strategies:
[13:21:34.567] 1. sequential:
[13:21:34.567]    - args: function (..., envir = parent.frame())
[13:21:34.567]    - tweaked: FALSE
[13:21:34.567]    - call: NULL
[13:21:34.568] plan(): nbrOfWorkers() = 1
[13:21:34.571] plan(): Setting new future strategy stack:
[13:21:34.571] List of future strategies:
[13:21:34.571] 1. multicore:
[13:21:34.571]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:34.571]    - tweaked: FALSE
[13:21:34.571]    - call: plan(strategy)
[13:21:34.577] plan(): nbrOfWorkers() = 2
[13:21:34.567] MulticoreFuture:
[13:21:34.567] Label: ‘future_vapply-2’
[13:21:34.567] Expression:
[13:21:34.567] {
[13:21:34.567]     do.call(function(...) {
[13:21:34.567]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.567]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:34.567]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.567]             on.exit(options(oopts), add = TRUE)
[13:21:34.567]         }
[13:21:34.567]         {
[13:21:34.567]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:34.567]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.567]                 ...future.FUN(...future.X_jj, ...)
[13:21:34.567]             })
[13:21:34.567]         }
[13:21:34.567]     }, args = future.call.arguments)
[13:21:34.567] }
[13:21:34.567] Lazy evaluation: FALSE
[13:21:34.567] Asynchronous evaluation: TRUE
[13:21:34.567] Local evaluation: TRUE
[13:21:34.567] Environment: R_GlobalEnv
[13:21:34.567] Capture standard output: TRUE
[13:21:34.567] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:34.567] Globals: 11 objects totaling 93.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:34.567] Packages: 2 packages (‘stats’, ‘future.apply’)
[13:21:34.567] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:34.567] Resolved: TRUE
[13:21:34.567] Value: <not collected>
[13:21:34.567] Conditions captured: <none>
[13:21:34.567] Early signaling: FALSE
[13:21:34.567] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:34.567] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:34.578] Chunk #2 of 2 ... DONE
[13:21:34.578] Launching 2 futures (chunks) ... DONE
[13:21:34.578] Resolving 2 futures (chunks) ...
[13:21:34.578] resolve() on list ...
[13:21:34.578]  recursive: 0
[13:21:34.578]  length: 2
[13:21:34.579] 
[13:21:34.579] Future #1
[13:21:34.579] result() for MulticoreFuture ...
[13:21:34.580] result() for MulticoreFuture ...
[13:21:34.580] result() for MulticoreFuture ... done
[13:21:34.580] result() for MulticoreFuture ... done
[13:21:34.580] result() for MulticoreFuture ...
[13:21:34.581] result() for MulticoreFuture ... done
[13:21:34.581] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:21:34.581] - nx: 2
[13:21:34.581] - relay: TRUE
[13:21:34.581] - stdout: TRUE
[13:21:34.581] - signal: TRUE
[13:21:34.581] - resignal: FALSE
[13:21:34.582] - force: TRUE
[13:21:34.582] - relayed: [n=2] FALSE, FALSE
[13:21:34.582] - queued futures: [n=2] FALSE, FALSE
[13:21:34.582]  - until=1
[13:21:34.582]  - relaying element #1
[13:21:34.582] result() for MulticoreFuture ...
[13:21:34.582] result() for MulticoreFuture ... done
[13:21:34.583] result() for MulticoreFuture ...
[13:21:34.583] result() for MulticoreFuture ... done
[13:21:34.583] result() for MulticoreFuture ...
[13:21:34.583] result() for MulticoreFuture ... done
[13:21:34.583] result() for MulticoreFuture ...
[13:21:34.583] result() for MulticoreFuture ... done
[13:21:34.584] - relayed: [n=2] TRUE, FALSE
[13:21:34.584] - queued futures: [n=2] TRUE, FALSE
[13:21:34.584] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:21:34.584]  length: 1 (resolved future 1)
[13:21:34.584] Future #2
[13:21:34.585] result() for MulticoreFuture ...
[13:21:34.585] result() for MulticoreFuture ...
[13:21:34.589] result() for MulticoreFuture ... done
[13:21:34.589] result() for MulticoreFuture ... done
[13:21:34.589] result() for MulticoreFuture ...
[13:21:34.589] result() for MulticoreFuture ... done
[13:21:34.589] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:21:34.590] - nx: 2
[13:21:34.590] - relay: TRUE
[13:21:34.590] - stdout: TRUE
[13:21:34.590] - signal: TRUE
[13:21:34.590] - resignal: FALSE
[13:21:34.590] - force: TRUE
[13:21:34.591] - relayed: [n=2] TRUE, FALSE
[13:21:34.591] - queued futures: [n=2] TRUE, FALSE
[13:21:34.591]  - until=2
[13:21:34.591]  - relaying element #2
[13:21:34.591] result() for MulticoreFuture ...
[13:21:34.591] result() for MulticoreFuture ... done
[13:21:34.592] result() for MulticoreFuture ...
[13:21:34.592] result() for MulticoreFuture ... done
[13:21:34.592] result() for MulticoreFuture ...
[13:21:34.592] result() for MulticoreFuture ... done
[13:21:34.592] result() for MulticoreFuture ...
[13:21:34.593] result() for MulticoreFuture ... done
[13:21:34.593] - relayed: [n=2] TRUE, TRUE
[13:21:34.593] - queued futures: [n=2] TRUE, TRUE
[13:21:34.593] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:21:34.593]  length: 0 (resolved future 2)
[13:21:34.593] Relaying remaining futures
[13:21:34.594] signalConditionsASAP(NULL, pos=0) ...
[13:21:34.594] - nx: 2
[13:21:34.594] - relay: TRUE
[13:21:34.594] - stdout: TRUE
[13:21:34.594] - signal: TRUE
[13:21:34.594] - resignal: FALSE
[13:21:34.594] - force: TRUE
[13:21:34.595] - relayed: [n=2] TRUE, TRUE
[13:21:34.595] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:21:34.595] - relayed: [n=2] TRUE, TRUE
[13:21:34.595] - queued futures: [n=2] TRUE, TRUE
[13:21:34.595] signalConditionsASAP(NULL, pos=0) ... done
[13:21:34.595] resolve() on list ... DONE
[13:21:34.596] result() for MulticoreFuture ...
[13:21:34.596] result() for MulticoreFuture ... done
[13:21:34.596] result() for MulticoreFuture ...
[13:21:34.596] result() for MulticoreFuture ... done
[13:21:34.596] result() for MulticoreFuture ...
[13:21:34.596] result() for MulticoreFuture ... done
[13:21:34.597] result() for MulticoreFuture ...
[13:21:34.597] result() for MulticoreFuture ... done
[13:21:34.597]  - Number of value chunks collected: 2
[13:21:34.597] Resolving 2 futures (chunks) ... DONE
[13:21:34.597] Reducing values from 2 chunks ...
[13:21:34.597]  - Number of values collected after concatenation: 3
[13:21:34.597]  - Number of values expected: 3
[13:21:34.597] Reducing values from 2 chunks ... DONE
[13:21:34.598] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[13:21:34.600] future_lapply() ...
[13:21:34.609] Number of chunks: 2
[13:21:34.609] getGlobalsAndPackagesXApply() ...
[13:21:34.609]  - future.globals: TRUE
[13:21:34.609] getGlobalsAndPackages() ...
[13:21:34.609] Searching for globals...
[13:21:34.617] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[13:21:34.617] Searching for globals ... DONE
[13:21:34.617] Resolving globals: FALSE
[13:21:34.618] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[13:21:34.618] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[13:21:34.619] - globals: [1] ‘FUN’
[13:21:34.619] - packages: [1] ‘stats’
[13:21:34.619] getGlobalsAndPackages() ... DONE
[13:21:34.619]  - globals found/used: [n=1] ‘FUN’
[13:21:34.619]  - needed namespaces: [n=1] ‘stats’
[13:21:34.619] Finding globals ... DONE
[13:21:34.619]  - use_args: TRUE
[13:21:34.620]  - Getting '...' globals ...
[13:21:34.620] resolve() on list ...
[13:21:34.620]  recursive: 0
[13:21:34.620]  length: 1
[13:21:34.620]  elements: ‘...’
[13:21:34.620]  length: 0 (resolved future 1)
[13:21:34.621] resolve() on list ... DONE
[13:21:34.621]    - '...' content: [n=0] 
[13:21:34.621] List of 1
[13:21:34.621]  $ ...: list()
[13:21:34.621]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:34.621]  - attr(*, "where")=List of 1
[13:21:34.621]   ..$ ...:<environment: 0x563b6d7faad8> 
[13:21:34.621]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:34.621]  - attr(*, "resolved")= logi TRUE
[13:21:34.621]  - attr(*, "total_size")= num NA
[13:21:34.623]  - Getting '...' globals ... DONE
[13:21:34.624] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:21:34.624] List of 2
[13:21:34.624]  $ ...future.FUN:function (x, na.rm = TRUE)  
[13:21:34.624]  $ ...          : list()
[13:21:34.624]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:34.624]  - attr(*, "where")=List of 2
[13:21:34.624]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:34.624]   ..$ ...          :<environment: 0x563b6d7faad8> 
[13:21:34.624]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:34.624]  - attr(*, "resolved")= logi FALSE
[13:21:34.624]  - attr(*, "total_size")= num 46960
[13:21:34.627] Packages to be attached in all futures: [n=1] ‘stats’
[13:21:34.627] getGlobalsAndPackagesXApply() ... DONE
[13:21:34.627] Number of futures (= number of chunks): 2
[13:21:34.627] Launching 2 futures (chunks) ...
[13:21:34.627] Chunk #1 of 2 ...
[13:21:34.627]  - Finding globals in 'X' for chunk #1 ...
[13:21:34.627] getGlobalsAndPackages() ...
[13:21:34.627] Searching for globals...
[13:21:34.628] 
[13:21:34.628] Searching for globals ... DONE
[13:21:34.628] - globals: [0] <none>
[13:21:34.628] getGlobalsAndPackages() ... DONE
[13:21:34.628]    + additional globals found: [n=0] 
[13:21:34.628]    + additional namespaces needed: [n=0] 
[13:21:34.628]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:34.628]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:34.629]  - seeds: <none>
[13:21:34.629]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.629] getGlobalsAndPackages() ...
[13:21:34.629] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.629] Resolving globals: FALSE
[13:21:34.629] Tweak future expression to call with '...' arguments ...
[13:21:34.629] {
[13:21:34.629]     do.call(function(...) {
[13:21:34.629]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.629]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:34.629]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.629]             on.exit(options(oopts), add = TRUE)
[13:21:34.629]         }
[13:21:34.629]         {
[13:21:34.629]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:34.629]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.629]                 ...future.FUN(...future.X_jj, ...)
[13:21:34.629]             })
[13:21:34.629]         }
[13:21:34.629]     }, args = future.call.arguments)
[13:21:34.629] }
[13:21:34.629] Tweak future expression to call with '...' arguments ... DONE
[13:21:34.630] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.630] - packages: [1] ‘stats’
[13:21:34.630] getGlobalsAndPackages() ... DONE
[13:21:34.630] run() for ‘Future’ ...
[13:21:34.631] - state: ‘created’
[13:21:34.631] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:34.635] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:34.635] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:34.635]   - Field: ‘label’
[13:21:34.635]   - Field: ‘local’
[13:21:34.635]   - Field: ‘owner’
[13:21:34.635]   - Field: ‘envir’
[13:21:34.635]   - Field: ‘workers’
[13:21:34.635]   - Field: ‘packages’
[13:21:34.636]   - Field: ‘gc’
[13:21:34.636]   - Field: ‘job’
[13:21:34.636]   - Field: ‘conditions’
[13:21:34.636]   - Field: ‘expr’
[13:21:34.636]   - Field: ‘uuid’
[13:21:34.636]   - Field: ‘seed’
[13:21:34.636]   - Field: ‘version’
[13:21:34.636]   - Field: ‘result’
[13:21:34.636]   - Field: ‘asynchronous’
[13:21:34.636]   - Field: ‘calls’
[13:21:34.637]   - Field: ‘globals’
[13:21:34.639]   - Field: ‘stdout’
[13:21:34.639]   - Field: ‘earlySignal’
[13:21:34.639]   - Field: ‘lazy’
[13:21:34.639]   - Field: ‘state’
[13:21:34.639] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:34.640] - Launch lazy future ...
[13:21:34.640] Packages needed by the future expression (n = 1): ‘stats’
[13:21:34.640] Packages needed by future strategies (n = 0): <none>
[13:21:34.641] {
[13:21:34.641]     {
[13:21:34.641]         {
[13:21:34.641]             ...future.startTime <- base::Sys.time()
[13:21:34.641]             {
[13:21:34.641]                 {
[13:21:34.641]                   {
[13:21:34.641]                     {
[13:21:34.641]                       {
[13:21:34.641]                         base::local({
[13:21:34.641]                           has_future <- base::requireNamespace("future", 
[13:21:34.641]                             quietly = TRUE)
[13:21:34.641]                           if (has_future) {
[13:21:34.641]                             ns <- base::getNamespace("future")
[13:21:34.641]                             version <- ns[[".package"]][["version"]]
[13:21:34.641]                             if (is.null(version)) 
[13:21:34.641]                               version <- utils::packageVersion("future")
[13:21:34.641]                           }
[13:21:34.641]                           else {
[13:21:34.641]                             version <- NULL
[13:21:34.641]                           }
[13:21:34.641]                           if (!has_future || version < "1.8.0") {
[13:21:34.641]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:34.641]                               "", base::R.version$version.string), 
[13:21:34.641]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:34.641]                                 base::R.version$platform, 8 * 
[13:21:34.641]                                   base::.Machine$sizeof.pointer), 
[13:21:34.641]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:34.641]                                 "release", "version")], collapse = " "), 
[13:21:34.641]                               hostname = base::Sys.info()[["nodename"]])
[13:21:34.641]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:34.641]                               info)
[13:21:34.641]                             info <- base::paste(info, collapse = "; ")
[13:21:34.641]                             if (!has_future) {
[13:21:34.641]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:34.641]                                 info)
[13:21:34.641]                             }
[13:21:34.641]                             else {
[13:21:34.641]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:34.641]                                 info, version)
[13:21:34.641]                             }
[13:21:34.641]                             base::stop(msg)
[13:21:34.641]                           }
[13:21:34.641]                         })
[13:21:34.641]                       }
[13:21:34.641]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:34.641]                       base::options(mc.cores = 1L)
[13:21:34.641]                     }
[13:21:34.641]                     base::local({
[13:21:34.641]                       for (pkg in "stats") {
[13:21:34.641]                         base::loadNamespace(pkg)
[13:21:34.641]                         base::library(pkg, character.only = TRUE)
[13:21:34.641]                       }
[13:21:34.641]                     })
[13:21:34.641]                   }
[13:21:34.641]                   options(future.plan = NULL)
[13:21:34.641]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:34.641]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:34.641]                 }
[13:21:34.641]                 ...future.workdir <- getwd()
[13:21:34.641]             }
[13:21:34.641]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:34.641]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:34.641]         }
[13:21:34.641]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:34.641]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:34.641]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:34.641]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:34.641]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:34.641]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:34.641]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:34.641]             base::names(...future.oldOptions))
[13:21:34.641]     }
[13:21:34.641]     if (FALSE) {
[13:21:34.641]     }
[13:21:34.641]     else {
[13:21:34.641]         if (TRUE) {
[13:21:34.641]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:34.641]                 open = "w")
[13:21:34.641]         }
[13:21:34.641]         else {
[13:21:34.641]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:34.641]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:34.641]         }
[13:21:34.641]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:34.641]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:34.641]             base::sink(type = "output", split = FALSE)
[13:21:34.641]             base::close(...future.stdout)
[13:21:34.641]         }, add = TRUE)
[13:21:34.641]     }
[13:21:34.641]     ...future.frame <- base::sys.nframe()
[13:21:34.641]     ...future.conditions <- base::list()
[13:21:34.641]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:34.641]     if (FALSE) {
[13:21:34.641]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:34.641]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:34.641]     }
[13:21:34.641]     ...future.result <- base::tryCatch({
[13:21:34.641]         base::withCallingHandlers({
[13:21:34.641]             ...future.value <- base::withVisible(base::local({
[13:21:34.641]                 withCallingHandlers({
[13:21:34.641]                   {
[13:21:34.641]                     do.call(function(...) {
[13:21:34.641]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.641]                       if (!identical(...future.globals.maxSize.org, 
[13:21:34.641]                         ...future.globals.maxSize)) {
[13:21:34.641]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.641]                         on.exit(options(oopts), add = TRUE)
[13:21:34.641]                       }
[13:21:34.641]                       {
[13:21:34.641]                         lapply(seq_along(...future.elements_ii), 
[13:21:34.641]                           FUN = function(jj) {
[13:21:34.641]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.641]                             ...future.FUN(...future.X_jj, ...)
[13:21:34.641]                           })
[13:21:34.641]                       }
[13:21:34.641]                     }, args = future.call.arguments)
[13:21:34.641]                   }
[13:21:34.641]                 }, immediateCondition = function(cond) {
[13:21:34.641]                   save_rds <- function (object, pathname, ...) 
[13:21:34.641]                   {
[13:21:34.641]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:34.641]                     if (file_test("-f", pathname_tmp)) {
[13:21:34.641]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.641]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:34.641]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.641]                         fi_tmp[["mtime"]])
[13:21:34.641]                     }
[13:21:34.641]                     tryCatch({
[13:21:34.641]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:34.641]                     }, error = function(ex) {
[13:21:34.641]                       msg <- conditionMessage(ex)
[13:21:34.641]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.641]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:34.641]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.641]                         fi_tmp[["mtime"]], msg)
[13:21:34.641]                       ex$message <- msg
[13:21:34.641]                       stop(ex)
[13:21:34.641]                     })
[13:21:34.641]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:34.641]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:34.641]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:34.641]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.641]                       fi <- file.info(pathname)
[13:21:34.641]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:34.641]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.641]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:34.641]                         fi[["size"]], fi[["mtime"]])
[13:21:34.641]                       stop(msg)
[13:21:34.641]                     }
[13:21:34.641]                     invisible(pathname)
[13:21:34.641]                   }
[13:21:34.641]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:34.641]                     rootPath = tempdir()) 
[13:21:34.641]                   {
[13:21:34.641]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:34.641]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:34.641]                       tmpdir = path, fileext = ".rds")
[13:21:34.641]                     save_rds(obj, file)
[13:21:34.641]                   }
[13:21:34.641]                   saveImmediateCondition(cond, path = "/tmp/RtmpbpFWGO/.future/immediateConditions")
[13:21:34.641]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.641]                   {
[13:21:34.641]                     inherits <- base::inherits
[13:21:34.641]                     invokeRestart <- base::invokeRestart
[13:21:34.641]                     is.null <- base::is.null
[13:21:34.641]                     muffled <- FALSE
[13:21:34.641]                     if (inherits(cond, "message")) {
[13:21:34.641]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:34.641]                       if (muffled) 
[13:21:34.641]                         invokeRestart("muffleMessage")
[13:21:34.641]                     }
[13:21:34.641]                     else if (inherits(cond, "warning")) {
[13:21:34.641]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:34.641]                       if (muffled) 
[13:21:34.641]                         invokeRestart("muffleWarning")
[13:21:34.641]                     }
[13:21:34.641]                     else if (inherits(cond, "condition")) {
[13:21:34.641]                       if (!is.null(pattern)) {
[13:21:34.641]                         computeRestarts <- base::computeRestarts
[13:21:34.641]                         grepl <- base::grepl
[13:21:34.641]                         restarts <- computeRestarts(cond)
[13:21:34.641]                         for (restart in restarts) {
[13:21:34.641]                           name <- restart$name
[13:21:34.641]                           if (is.null(name)) 
[13:21:34.641]                             next
[13:21:34.641]                           if (!grepl(pattern, name)) 
[13:21:34.641]                             next
[13:21:34.641]                           invokeRestart(restart)
[13:21:34.641]                           muffled <- TRUE
[13:21:34.641]                           break
[13:21:34.641]                         }
[13:21:34.641]                       }
[13:21:34.641]                     }
[13:21:34.641]                     invisible(muffled)
[13:21:34.641]                   }
[13:21:34.641]                   muffleCondition(cond)
[13:21:34.641]                 })
[13:21:34.641]             }))
[13:21:34.641]             future::FutureResult(value = ...future.value$value, 
[13:21:34.641]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:34.641]                   ...future.rng), globalenv = if (FALSE) 
[13:21:34.641]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:34.641]                     ...future.globalenv.names))
[13:21:34.641]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:34.641]         }, condition = base::local({
[13:21:34.641]             c <- base::c
[13:21:34.641]             inherits <- base::inherits
[13:21:34.641]             invokeRestart <- base::invokeRestart
[13:21:34.641]             length <- base::length
[13:21:34.641]             list <- base::list
[13:21:34.641]             seq.int <- base::seq.int
[13:21:34.641]             signalCondition <- base::signalCondition
[13:21:34.641]             sys.calls <- base::sys.calls
[13:21:34.641]             `[[` <- base::`[[`
[13:21:34.641]             `+` <- base::`+`
[13:21:34.641]             `<<-` <- base::`<<-`
[13:21:34.641]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:34.641]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:34.641]                   3L)]
[13:21:34.641]             }
[13:21:34.641]             function(cond) {
[13:21:34.641]                 is_error <- inherits(cond, "error")
[13:21:34.641]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:34.641]                   NULL)
[13:21:34.641]                 if (is_error) {
[13:21:34.641]                   sessionInformation <- function() {
[13:21:34.641]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:34.641]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:34.641]                       search = base::search(), system = base::Sys.info())
[13:21:34.641]                   }
[13:21:34.641]                   ...future.conditions[[length(...future.conditions) + 
[13:21:34.641]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:34.641]                     cond$call), session = sessionInformation(), 
[13:21:34.641]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:34.641]                   signalCondition(cond)
[13:21:34.641]                 }
[13:21:34.641]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:34.641]                 "immediateCondition"))) {
[13:21:34.641]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:34.641]                   ...future.conditions[[length(...future.conditions) + 
[13:21:34.641]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:34.641]                   if (TRUE && !signal) {
[13:21:34.641]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.641]                     {
[13:21:34.641]                       inherits <- base::inherits
[13:21:34.641]                       invokeRestart <- base::invokeRestart
[13:21:34.641]                       is.null <- base::is.null
[13:21:34.641]                       muffled <- FALSE
[13:21:34.641]                       if (inherits(cond, "message")) {
[13:21:34.641]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:34.641]                         if (muffled) 
[13:21:34.641]                           invokeRestart("muffleMessage")
[13:21:34.641]                       }
[13:21:34.641]                       else if (inherits(cond, "warning")) {
[13:21:34.641]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:34.641]                         if (muffled) 
[13:21:34.641]                           invokeRestart("muffleWarning")
[13:21:34.641]                       }
[13:21:34.641]                       else if (inherits(cond, "condition")) {
[13:21:34.641]                         if (!is.null(pattern)) {
[13:21:34.641]                           computeRestarts <- base::computeRestarts
[13:21:34.641]                           grepl <- base::grepl
[13:21:34.641]                           restarts <- computeRestarts(cond)
[13:21:34.641]                           for (restart in restarts) {
[13:21:34.641]                             name <- restart$name
[13:21:34.641]                             if (is.null(name)) 
[13:21:34.641]                               next
[13:21:34.641]                             if (!grepl(pattern, name)) 
[13:21:34.641]                               next
[13:21:34.641]                             invokeRestart(restart)
[13:21:34.641]                             muffled <- TRUE
[13:21:34.641]                             break
[13:21:34.641]                           }
[13:21:34.641]                         }
[13:21:34.641]                       }
[13:21:34.641]                       invisible(muffled)
[13:21:34.641]                     }
[13:21:34.641]                     muffleCondition(cond, pattern = "^muffle")
[13:21:34.641]                   }
[13:21:34.641]                 }
[13:21:34.641]                 else {
[13:21:34.641]                   if (TRUE) {
[13:21:34.641]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.641]                     {
[13:21:34.641]                       inherits <- base::inherits
[13:21:34.641]                       invokeRestart <- base::invokeRestart
[13:21:34.641]                       is.null <- base::is.null
[13:21:34.641]                       muffled <- FALSE
[13:21:34.641]                       if (inherits(cond, "message")) {
[13:21:34.641]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:34.641]                         if (muffled) 
[13:21:34.641]                           invokeRestart("muffleMessage")
[13:21:34.641]                       }
[13:21:34.641]                       else if (inherits(cond, "warning")) {
[13:21:34.641]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:34.641]                         if (muffled) 
[13:21:34.641]                           invokeRestart("muffleWarning")
[13:21:34.641]                       }
[13:21:34.641]                       else if (inherits(cond, "condition")) {
[13:21:34.641]                         if (!is.null(pattern)) {
[13:21:34.641]                           computeRestarts <- base::computeRestarts
[13:21:34.641]                           grepl <- base::grepl
[13:21:34.641]                           restarts <- computeRestarts(cond)
[13:21:34.641]                           for (restart in restarts) {
[13:21:34.641]                             name <- restart$name
[13:21:34.641]                             if (is.null(name)) 
[13:21:34.641]                               next
[13:21:34.641]                             if (!grepl(pattern, name)) 
[13:21:34.641]                               next
[13:21:34.641]                             invokeRestart(restart)
[13:21:34.641]                             muffled <- TRUE
[13:21:34.641]                             break
[13:21:34.641]                           }
[13:21:34.641]                         }
[13:21:34.641]                       }
[13:21:34.641]                       invisible(muffled)
[13:21:34.641]                     }
[13:21:34.641]                     muffleCondition(cond, pattern = "^muffle")
[13:21:34.641]                   }
[13:21:34.641]                 }
[13:21:34.641]             }
[13:21:34.641]         }))
[13:21:34.641]     }, error = function(ex) {
[13:21:34.641]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:34.641]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:34.641]                 ...future.rng), started = ...future.startTime, 
[13:21:34.641]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:34.641]             version = "1.8"), class = "FutureResult")
[13:21:34.641]     }, finally = {
[13:21:34.641]         if (!identical(...future.workdir, getwd())) 
[13:21:34.641]             setwd(...future.workdir)
[13:21:34.641]         {
[13:21:34.641]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:34.641]                 ...future.oldOptions$nwarnings <- NULL
[13:21:34.641]             }
[13:21:34.641]             base::options(...future.oldOptions)
[13:21:34.641]             if (.Platform$OS.type == "windows") {
[13:21:34.641]                 old_names <- names(...future.oldEnvVars)
[13:21:34.641]                 envs <- base::Sys.getenv()
[13:21:34.641]                 names <- names(envs)
[13:21:34.641]                 common <- intersect(names, old_names)
[13:21:34.641]                 added <- setdiff(names, old_names)
[13:21:34.641]                 removed <- setdiff(old_names, names)
[13:21:34.641]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:34.641]                   envs[common]]
[13:21:34.641]                 NAMES <- toupper(changed)
[13:21:34.641]                 args <- list()
[13:21:34.641]                 for (kk in seq_along(NAMES)) {
[13:21:34.641]                   name <- changed[[kk]]
[13:21:34.641]                   NAME <- NAMES[[kk]]
[13:21:34.641]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.641]                     next
[13:21:34.641]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:34.641]                 }
[13:21:34.641]                 NAMES <- toupper(added)
[13:21:34.641]                 for (kk in seq_along(NAMES)) {
[13:21:34.641]                   name <- added[[kk]]
[13:21:34.641]                   NAME <- NAMES[[kk]]
[13:21:34.641]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.641]                     next
[13:21:34.641]                   args[[name]] <- ""
[13:21:34.641]                 }
[13:21:34.641]                 NAMES <- toupper(removed)
[13:21:34.641]                 for (kk in seq_along(NAMES)) {
[13:21:34.641]                   name <- removed[[kk]]
[13:21:34.641]                   NAME <- NAMES[[kk]]
[13:21:34.641]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.641]                     next
[13:21:34.641]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:34.641]                 }
[13:21:34.641]                 if (length(args) > 0) 
[13:21:34.641]                   base::do.call(base::Sys.setenv, args = args)
[13:21:34.641]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:34.641]             }
[13:21:34.641]             else {
[13:21:34.641]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:34.641]             }
[13:21:34.641]             {
[13:21:34.641]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:34.641]                   0L) {
[13:21:34.641]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:34.641]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:34.641]                   base::options(opts)
[13:21:34.641]                 }
[13:21:34.641]                 {
[13:21:34.641]                   {
[13:21:34.641]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:34.641]                     NULL
[13:21:34.641]                   }
[13:21:34.641]                   options(future.plan = NULL)
[13:21:34.641]                   if (is.na(NA_character_)) 
[13:21:34.641]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:34.641]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:34.641]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:34.641]                     envir = parent.frame()) 
[13:21:34.641]                   {
[13:21:34.641]                     default_workers <- missing(workers)
[13:21:34.641]                     if (is.function(workers)) 
[13:21:34.641]                       workers <- workers()
[13:21:34.641]                     workers <- structure(as.integer(workers), 
[13:21:34.641]                       class = class(workers))
[13:21:34.641]                     stop_if_not(is.finite(workers), workers >= 
[13:21:34.641]                       1L)
[13:21:34.641]                     if ((workers == 1L && !inherits(workers, 
[13:21:34.641]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:34.641]                       if (default_workers) 
[13:21:34.641]                         supportsMulticore(warn = TRUE)
[13:21:34.641]                       return(sequential(..., envir = envir))
[13:21:34.641]                     }
[13:21:34.641]                     oopts <- options(mc.cores = workers)
[13:21:34.641]                     on.exit(options(oopts))
[13:21:34.641]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:34.641]                       envir = envir)
[13:21:34.641]                     if (!future$lazy) 
[13:21:34.641]                       future <- run(future)
[13:21:34.641]                     invisible(future)
[13:21:34.641]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:34.641]                 }
[13:21:34.641]             }
[13:21:34.641]         }
[13:21:34.641]     })
[13:21:34.641]     if (TRUE) {
[13:21:34.641]         base::sink(type = "output", split = FALSE)
[13:21:34.641]         if (TRUE) {
[13:21:34.641]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:34.641]         }
[13:21:34.641]         else {
[13:21:34.641]             ...future.result["stdout"] <- base::list(NULL)
[13:21:34.641]         }
[13:21:34.641]         base::close(...future.stdout)
[13:21:34.641]         ...future.stdout <- NULL
[13:21:34.641]     }
[13:21:34.641]     ...future.result$conditions <- ...future.conditions
[13:21:34.641]     ...future.result$finished <- base::Sys.time()
[13:21:34.641]     ...future.result
[13:21:34.641] }
[13:21:34.644] assign_globals() ...
[13:21:34.644] List of 5
[13:21:34.644]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[13:21:34.644]  $ future.call.arguments    : list()
[13:21:34.644]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:34.644]  $ ...future.elements_ii    :List of 4
[13:21:34.644]   ..$ : int [1:3] 1 2 3
[13:21:34.644]   ..$ : int [1:4] 1 2 3 4
[13:21:34.644]   ..$ : int [1:5] 1 2 3 4 5
[13:21:34.644]   ..$ : int [1:6] 1 2 3 4 5 6
[13:21:34.644]  $ ...future.seeds_ii       : NULL
[13:21:34.644]  $ ...future.globals.maxSize: NULL
[13:21:34.644]  - attr(*, "where")=List of 5
[13:21:34.644]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:34.644]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:34.644]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:34.644]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:34.644]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:34.644]  - attr(*, "resolved")= logi FALSE
[13:21:34.644]  - attr(*, "total_size")= num 46960
[13:21:34.644]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:34.644]  - attr(*, "already-done")= logi TRUE
[13:21:34.651] - copied ‘...future.FUN’ to environment
[13:21:34.651] - copied ‘future.call.arguments’ to environment
[13:21:34.651] - copied ‘...future.elements_ii’ to environment
[13:21:34.651] - copied ‘...future.seeds_ii’ to environment
[13:21:34.651] - copied ‘...future.globals.maxSize’ to environment
[13:21:34.651] assign_globals() ... done
[13:21:34.651] requestCore(): workers = 2
[13:21:34.654] MulticoreFuture started
[13:21:34.654] - Launch lazy future ... done
[13:21:34.655] run() for ‘MulticoreFuture’ ... done
[13:21:34.655] Created future:
[13:21:34.655] plan(): Setting new future strategy stack:
[13:21:34.656] List of future strategies:
[13:21:34.656] 1. sequential:
[13:21:34.656]    - args: function (..., envir = parent.frame())
[13:21:34.656]    - tweaked: FALSE
[13:21:34.656]    - call: NULL
[13:21:34.656] plan(): nbrOfWorkers() = 1
[13:21:34.659] plan(): Setting new future strategy stack:
[13:21:34.659] List of future strategies:
[13:21:34.659] 1. multicore:
[13:21:34.659]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:34.659]    - tweaked: FALSE
[13:21:34.659]    - call: plan(strategy)
[13:21:34.665] plan(): nbrOfWorkers() = 2
[13:21:34.655] MulticoreFuture:
[13:21:34.655] Label: ‘future_sapply-1’
[13:21:34.655] Expression:
[13:21:34.655] {
[13:21:34.655]     do.call(function(...) {
[13:21:34.655]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.655]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:34.655]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.655]             on.exit(options(oopts), add = TRUE)
[13:21:34.655]         }
[13:21:34.655]         {
[13:21:34.655]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:34.655]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.655]                 ...future.FUN(...future.X_jj, ...)
[13:21:34.655]             })
[13:21:34.655]         }
[13:21:34.655]     }, args = future.call.arguments)
[13:21:34.655] }
[13:21:34.655] Lazy evaluation: FALSE
[13:21:34.655] Asynchronous evaluation: TRUE
[13:21:34.655] Local evaluation: TRUE
[13:21:34.655] Environment: R_GlobalEnv
[13:21:34.655] Capture standard output: TRUE
[13:21:34.655] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:34.655] Globals: 5 objects totaling 46.14 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 288 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:21:34.655] Packages: 1 packages (‘stats’)
[13:21:34.655] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:34.655] Resolved: TRUE
[13:21:34.655] Value: <not collected>
[13:21:34.655] Conditions captured: <none>
[13:21:34.655] Early signaling: FALSE
[13:21:34.655] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:34.655] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:34.666] Chunk #1 of 2 ... DONE
[13:21:34.667] Chunk #2 of 2 ...
[13:21:34.667]  - Finding globals in 'X' for chunk #2 ...
[13:21:34.667] getGlobalsAndPackages() ...
[13:21:34.667] Searching for globals...
[13:21:34.668] 
[13:21:34.668] Searching for globals ... DONE
[13:21:34.668] - globals: [0] <none>
[13:21:34.668] getGlobalsAndPackages() ... DONE
[13:21:34.668]    + additional globals found: [n=0] 
[13:21:34.668]    + additional namespaces needed: [n=0] 
[13:21:34.669]  - Finding globals in 'X' for chunk #2 ... DONE
[13:21:34.669]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:34.669]  - seeds: <none>
[13:21:34.669]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.669] getGlobalsAndPackages() ...
[13:21:34.669] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.670] Resolving globals: FALSE
[13:21:34.670] Tweak future expression to call with '...' arguments ...
[13:21:34.670] {
[13:21:34.670]     do.call(function(...) {
[13:21:34.670]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.670]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:34.670]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.670]             on.exit(options(oopts), add = TRUE)
[13:21:34.670]         }
[13:21:34.670]         {
[13:21:34.670]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:34.670]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.670]                 ...future.FUN(...future.X_jj, ...)
[13:21:34.670]             })
[13:21:34.670]         }
[13:21:34.670]     }, args = future.call.arguments)
[13:21:34.670] }
[13:21:34.670] Tweak future expression to call with '...' arguments ... DONE
[13:21:34.671] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.671] - packages: [1] ‘stats’
[13:21:34.672] getGlobalsAndPackages() ... DONE
[13:21:34.672] run() for ‘Future’ ...
[13:21:34.672] - state: ‘created’
[13:21:34.673] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:34.678] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:34.678] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:34.678]   - Field: ‘label’
[13:21:34.678]   - Field: ‘local’
[13:21:34.678]   - Field: ‘owner’
[13:21:34.678]   - Field: ‘envir’
[13:21:34.679]   - Field: ‘workers’
[13:21:34.679]   - Field: ‘packages’
[13:21:34.679]   - Field: ‘gc’
[13:21:34.679]   - Field: ‘job’
[13:21:34.679]   - Field: ‘conditions’
[13:21:34.679]   - Field: ‘expr’
[13:21:34.679]   - Field: ‘uuid’
[13:21:34.680]   - Field: ‘seed’
[13:21:34.680]   - Field: ‘version’
[13:21:34.680]   - Field: ‘result’
[13:21:34.680]   - Field: ‘asynchronous’
[13:21:34.680]   - Field: ‘calls’
[13:21:34.680]   - Field: ‘globals’
[13:21:34.680]   - Field: ‘stdout’
[13:21:34.681]   - Field: ‘earlySignal’
[13:21:34.681]   - Field: ‘lazy’
[13:21:34.681]   - Field: ‘state’
[13:21:34.681] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:34.681] - Launch lazy future ...
[13:21:34.682] Packages needed by the future expression (n = 1): ‘stats’
[13:21:34.682] Packages needed by future strategies (n = 0): <none>
[13:21:34.687] {
[13:21:34.687]     {
[13:21:34.687]         {
[13:21:34.687]             ...future.startTime <- base::Sys.time()
[13:21:34.687]             {
[13:21:34.687]                 {
[13:21:34.687]                   {
[13:21:34.687]                     {
[13:21:34.687]                       {
[13:21:34.687]                         base::local({
[13:21:34.687]                           has_future <- base::requireNamespace("future", 
[13:21:34.687]                             quietly = TRUE)
[13:21:34.687]                           if (has_future) {
[13:21:34.687]                             ns <- base::getNamespace("future")
[13:21:34.687]                             version <- ns[[".package"]][["version"]]
[13:21:34.687]                             if (is.null(version)) 
[13:21:34.687]                               version <- utils::packageVersion("future")
[13:21:34.687]                           }
[13:21:34.687]                           else {
[13:21:34.687]                             version <- NULL
[13:21:34.687]                           }
[13:21:34.687]                           if (!has_future || version < "1.8.0") {
[13:21:34.687]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:34.687]                               "", base::R.version$version.string), 
[13:21:34.687]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:34.687]                                 base::R.version$platform, 8 * 
[13:21:34.687]                                   base::.Machine$sizeof.pointer), 
[13:21:34.687]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:34.687]                                 "release", "version")], collapse = " "), 
[13:21:34.687]                               hostname = base::Sys.info()[["nodename"]])
[13:21:34.687]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:34.687]                               info)
[13:21:34.687]                             info <- base::paste(info, collapse = "; ")
[13:21:34.687]                             if (!has_future) {
[13:21:34.687]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:34.687]                                 info)
[13:21:34.687]                             }
[13:21:34.687]                             else {
[13:21:34.687]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:34.687]                                 info, version)
[13:21:34.687]                             }
[13:21:34.687]                             base::stop(msg)
[13:21:34.687]                           }
[13:21:34.687]                         })
[13:21:34.687]                       }
[13:21:34.687]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:34.687]                       base::options(mc.cores = 1L)
[13:21:34.687]                     }
[13:21:34.687]                     base::local({
[13:21:34.687]                       for (pkg in "stats") {
[13:21:34.687]                         base::loadNamespace(pkg)
[13:21:34.687]                         base::library(pkg, character.only = TRUE)
[13:21:34.687]                       }
[13:21:34.687]                     })
[13:21:34.687]                   }
[13:21:34.687]                   options(future.plan = NULL)
[13:21:34.687]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:34.687]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:34.687]                 }
[13:21:34.687]                 ...future.workdir <- getwd()
[13:21:34.687]             }
[13:21:34.687]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:34.687]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:34.687]         }
[13:21:34.687]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:34.687]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:34.687]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:34.687]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:34.687]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:34.687]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:34.687]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:34.687]             base::names(...future.oldOptions))
[13:21:34.687]     }
[13:21:34.687]     if (FALSE) {
[13:21:34.687]     }
[13:21:34.687]     else {
[13:21:34.687]         if (TRUE) {
[13:21:34.687]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:34.687]                 open = "w")
[13:21:34.687]         }
[13:21:34.687]         else {
[13:21:34.687]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:34.687]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:34.687]         }
[13:21:34.687]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:34.687]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:34.687]             base::sink(type = "output", split = FALSE)
[13:21:34.687]             base::close(...future.stdout)
[13:21:34.687]         }, add = TRUE)
[13:21:34.687]     }
[13:21:34.687]     ...future.frame <- base::sys.nframe()
[13:21:34.687]     ...future.conditions <- base::list()
[13:21:34.687]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:34.687]     if (FALSE) {
[13:21:34.687]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:34.687]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:34.687]     }
[13:21:34.687]     ...future.result <- base::tryCatch({
[13:21:34.687]         base::withCallingHandlers({
[13:21:34.687]             ...future.value <- base::withVisible(base::local({
[13:21:34.687]                 withCallingHandlers({
[13:21:34.687]                   {
[13:21:34.687]                     do.call(function(...) {
[13:21:34.687]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.687]                       if (!identical(...future.globals.maxSize.org, 
[13:21:34.687]                         ...future.globals.maxSize)) {
[13:21:34.687]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.687]                         on.exit(options(oopts), add = TRUE)
[13:21:34.687]                       }
[13:21:34.687]                       {
[13:21:34.687]                         lapply(seq_along(...future.elements_ii), 
[13:21:34.687]                           FUN = function(jj) {
[13:21:34.687]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.687]                             ...future.FUN(...future.X_jj, ...)
[13:21:34.687]                           })
[13:21:34.687]                       }
[13:21:34.687]                     }, args = future.call.arguments)
[13:21:34.687]                   }
[13:21:34.687]                 }, immediateCondition = function(cond) {
[13:21:34.687]                   save_rds <- function (object, pathname, ...) 
[13:21:34.687]                   {
[13:21:34.687]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:34.687]                     if (file_test("-f", pathname_tmp)) {
[13:21:34.687]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.687]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:34.687]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.687]                         fi_tmp[["mtime"]])
[13:21:34.687]                     }
[13:21:34.687]                     tryCatch({
[13:21:34.687]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:34.687]                     }, error = function(ex) {
[13:21:34.687]                       msg <- conditionMessage(ex)
[13:21:34.687]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.687]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:34.687]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.687]                         fi_tmp[["mtime"]], msg)
[13:21:34.687]                       ex$message <- msg
[13:21:34.687]                       stop(ex)
[13:21:34.687]                     })
[13:21:34.687]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:34.687]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:34.687]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:34.687]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.687]                       fi <- file.info(pathname)
[13:21:34.687]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:34.687]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.687]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:34.687]                         fi[["size"]], fi[["mtime"]])
[13:21:34.687]                       stop(msg)
[13:21:34.687]                     }
[13:21:34.687]                     invisible(pathname)
[13:21:34.687]                   }
[13:21:34.687]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:34.687]                     rootPath = tempdir()) 
[13:21:34.687]                   {
[13:21:34.687]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:34.687]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:34.687]                       tmpdir = path, fileext = ".rds")
[13:21:34.687]                     save_rds(obj, file)
[13:21:34.687]                   }
[13:21:34.687]                   saveImmediateCondition(cond, path = "/tmp/RtmpbpFWGO/.future/immediateConditions")
[13:21:34.687]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.687]                   {
[13:21:34.687]                     inherits <- base::inherits
[13:21:34.687]                     invokeRestart <- base::invokeRestart
[13:21:34.687]                     is.null <- base::is.null
[13:21:34.687]                     muffled <- FALSE
[13:21:34.687]                     if (inherits(cond, "message")) {
[13:21:34.687]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:34.687]                       if (muffled) 
[13:21:34.687]                         invokeRestart("muffleMessage")
[13:21:34.687]                     }
[13:21:34.687]                     else if (inherits(cond, "warning")) {
[13:21:34.687]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:34.687]                       if (muffled) 
[13:21:34.687]                         invokeRestart("muffleWarning")
[13:21:34.687]                     }
[13:21:34.687]                     else if (inherits(cond, "condition")) {
[13:21:34.687]                       if (!is.null(pattern)) {
[13:21:34.687]                         computeRestarts <- base::computeRestarts
[13:21:34.687]                         grepl <- base::grepl
[13:21:34.687]                         restarts <- computeRestarts(cond)
[13:21:34.687]                         for (restart in restarts) {
[13:21:34.687]                           name <- restart$name
[13:21:34.687]                           if (is.null(name)) 
[13:21:34.687]                             next
[13:21:34.687]                           if (!grepl(pattern, name)) 
[13:21:34.687]                             next
[13:21:34.687]                           invokeRestart(restart)
[13:21:34.687]                           muffled <- TRUE
[13:21:34.687]                           break
[13:21:34.687]                         }
[13:21:34.687]                       }
[13:21:34.687]                     }
[13:21:34.687]                     invisible(muffled)
[13:21:34.687]                   }
[13:21:34.687]                   muffleCondition(cond)
[13:21:34.687]                 })
[13:21:34.687]             }))
[13:21:34.687]             future::FutureResult(value = ...future.value$value, 
[13:21:34.687]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:34.687]                   ...future.rng), globalenv = if (FALSE) 
[13:21:34.687]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:34.687]                     ...future.globalenv.names))
[13:21:34.687]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:34.687]         }, condition = base::local({
[13:21:34.687]             c <- base::c
[13:21:34.687]             inherits <- base::inherits
[13:21:34.687]             invokeRestart <- base::invokeRestart
[13:21:34.687]             length <- base::length
[13:21:34.687]             list <- base::list
[13:21:34.687]             seq.int <- base::seq.int
[13:21:34.687]             signalCondition <- base::signalCondition
[13:21:34.687]             sys.calls <- base::sys.calls
[13:21:34.687]             `[[` <- base::`[[`
[13:21:34.687]             `+` <- base::`+`
[13:21:34.687]             `<<-` <- base::`<<-`
[13:21:34.687]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:34.687]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:34.687]                   3L)]
[13:21:34.687]             }
[13:21:34.687]             function(cond) {
[13:21:34.687]                 is_error <- inherits(cond, "error")
[13:21:34.687]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:34.687]                   NULL)
[13:21:34.687]                 if (is_error) {
[13:21:34.687]                   sessionInformation <- function() {
[13:21:34.687]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:34.687]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:34.687]                       search = base::search(), system = base::Sys.info())
[13:21:34.687]                   }
[13:21:34.687]                   ...future.conditions[[length(...future.conditions) + 
[13:21:34.687]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:34.687]                     cond$call), session = sessionInformation(), 
[13:21:34.687]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:34.687]                   signalCondition(cond)
[13:21:34.687]                 }
[13:21:34.687]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:34.687]                 "immediateCondition"))) {
[13:21:34.687]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:34.687]                   ...future.conditions[[length(...future.conditions) + 
[13:21:34.687]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:34.687]                   if (TRUE && !signal) {
[13:21:34.687]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.687]                     {
[13:21:34.687]                       inherits <- base::inherits
[13:21:34.687]                       invokeRestart <- base::invokeRestart
[13:21:34.687]                       is.null <- base::is.null
[13:21:34.687]                       muffled <- FALSE
[13:21:34.687]                       if (inherits(cond, "message")) {
[13:21:34.687]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:34.687]                         if (muffled) 
[13:21:34.687]                           invokeRestart("muffleMessage")
[13:21:34.687]                       }
[13:21:34.687]                       else if (inherits(cond, "warning")) {
[13:21:34.687]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:34.687]                         if (muffled) 
[13:21:34.687]                           invokeRestart("muffleWarning")
[13:21:34.687]                       }
[13:21:34.687]                       else if (inherits(cond, "condition")) {
[13:21:34.687]                         if (!is.null(pattern)) {
[13:21:34.687]                           computeRestarts <- base::computeRestarts
[13:21:34.687]                           grepl <- base::grepl
[13:21:34.687]                           restarts <- computeRestarts(cond)
[13:21:34.687]                           for (restart in restarts) {
[13:21:34.687]                             name <- restart$name
[13:21:34.687]                             if (is.null(name)) 
[13:21:34.687]                               next
[13:21:34.687]                             if (!grepl(pattern, name)) 
[13:21:34.687]                               next
[13:21:34.687]                             invokeRestart(restart)
[13:21:34.687]                             muffled <- TRUE
[13:21:34.687]                             break
[13:21:34.687]                           }
[13:21:34.687]                         }
[13:21:34.687]                       }
[13:21:34.687]                       invisible(muffled)
[13:21:34.687]                     }
[13:21:34.687]                     muffleCondition(cond, pattern = "^muffle")
[13:21:34.687]                   }
[13:21:34.687]                 }
[13:21:34.687]                 else {
[13:21:34.687]                   if (TRUE) {
[13:21:34.687]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.687]                     {
[13:21:34.687]                       inherits <- base::inherits
[13:21:34.687]                       invokeRestart <- base::invokeRestart
[13:21:34.687]                       is.null <- base::is.null
[13:21:34.687]                       muffled <- FALSE
[13:21:34.687]                       if (inherits(cond, "message")) {
[13:21:34.687]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:34.687]                         if (muffled) 
[13:21:34.687]                           invokeRestart("muffleMessage")
[13:21:34.687]                       }
[13:21:34.687]                       else if (inherits(cond, "warning")) {
[13:21:34.687]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:34.687]                         if (muffled) 
[13:21:34.687]                           invokeRestart("muffleWarning")
[13:21:34.687]                       }
[13:21:34.687]                       else if (inherits(cond, "condition")) {
[13:21:34.687]                         if (!is.null(pattern)) {
[13:21:34.687]                           computeRestarts <- base::computeRestarts
[13:21:34.687]                           grepl <- base::grepl
[13:21:34.687]                           restarts <- computeRestarts(cond)
[13:21:34.687]                           for (restart in restarts) {
[13:21:34.687]                             name <- restart$name
[13:21:34.687]                             if (is.null(name)) 
[13:21:34.687]                               next
[13:21:34.687]                             if (!grepl(pattern, name)) 
[13:21:34.687]                               next
[13:21:34.687]                             invokeRestart(restart)
[13:21:34.687]                             muffled <- TRUE
[13:21:34.687]                             break
[13:21:34.687]                           }
[13:21:34.687]                         }
[13:21:34.687]                       }
[13:21:34.687]                       invisible(muffled)
[13:21:34.687]                     }
[13:21:34.687]                     muffleCondition(cond, pattern = "^muffle")
[13:21:34.687]                   }
[13:21:34.687]                 }
[13:21:34.687]             }
[13:21:34.687]         }))
[13:21:34.687]     }, error = function(ex) {
[13:21:34.687]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:34.687]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:34.687]                 ...future.rng), started = ...future.startTime, 
[13:21:34.687]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:34.687]             version = "1.8"), class = "FutureResult")
[13:21:34.687]     }, finally = {
[13:21:34.687]         if (!identical(...future.workdir, getwd())) 
[13:21:34.687]             setwd(...future.workdir)
[13:21:34.687]         {
[13:21:34.687]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:34.687]                 ...future.oldOptions$nwarnings <- NULL
[13:21:34.687]             }
[13:21:34.687]             base::options(...future.oldOptions)
[13:21:34.687]             if (.Platform$OS.type == "windows") {
[13:21:34.687]                 old_names <- names(...future.oldEnvVars)
[13:21:34.687]                 envs <- base::Sys.getenv()
[13:21:34.687]                 names <- names(envs)
[13:21:34.687]                 common <- intersect(names, old_names)
[13:21:34.687]                 added <- setdiff(names, old_names)
[13:21:34.687]                 removed <- setdiff(old_names, names)
[13:21:34.687]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:34.687]                   envs[common]]
[13:21:34.687]                 NAMES <- toupper(changed)
[13:21:34.687]                 args <- list()
[13:21:34.687]                 for (kk in seq_along(NAMES)) {
[13:21:34.687]                   name <- changed[[kk]]
[13:21:34.687]                   NAME <- NAMES[[kk]]
[13:21:34.687]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.687]                     next
[13:21:34.687]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:34.687]                 }
[13:21:34.687]                 NAMES <- toupper(added)
[13:21:34.687]                 for (kk in seq_along(NAMES)) {
[13:21:34.687]                   name <- added[[kk]]
[13:21:34.687]                   NAME <- NAMES[[kk]]
[13:21:34.687]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.687]                     next
[13:21:34.687]                   args[[name]] <- ""
[13:21:34.687]                 }
[13:21:34.687]                 NAMES <- toupper(removed)
[13:21:34.687]                 for (kk in seq_along(NAMES)) {
[13:21:34.687]                   name <- removed[[kk]]
[13:21:34.687]                   NAME <- NAMES[[kk]]
[13:21:34.687]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.687]                     next
[13:21:34.687]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:34.687]                 }
[13:21:34.687]                 if (length(args) > 0) 
[13:21:34.687]                   base::do.call(base::Sys.setenv, args = args)
[13:21:34.687]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:34.687]             }
[13:21:34.687]             else {
[13:21:34.687]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:34.687]             }
[13:21:34.687]             {
[13:21:34.687]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:34.687]                   0L) {
[13:21:34.687]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:34.687]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:34.687]                   base::options(opts)
[13:21:34.687]                 }
[13:21:34.687]                 {
[13:21:34.687]                   {
[13:21:34.687]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:34.687]                     NULL
[13:21:34.687]                   }
[13:21:34.687]                   options(future.plan = NULL)
[13:21:34.687]                   if (is.na(NA_character_)) 
[13:21:34.687]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:34.687]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:34.687]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:34.687]                     envir = parent.frame()) 
[13:21:34.687]                   {
[13:21:34.687]                     default_workers <- missing(workers)
[13:21:34.687]                     if (is.function(workers)) 
[13:21:34.687]                       workers <- workers()
[13:21:34.687]                     workers <- structure(as.integer(workers), 
[13:21:34.687]                       class = class(workers))
[13:21:34.687]                     stop_if_not(is.finite(workers), workers >= 
[13:21:34.687]                       1L)
[13:21:34.687]                     if ((workers == 1L && !inherits(workers, 
[13:21:34.687]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:34.687]                       if (default_workers) 
[13:21:34.687]                         supportsMulticore(warn = TRUE)
[13:21:34.687]                       return(sequential(..., envir = envir))
[13:21:34.687]                     }
[13:21:34.687]                     oopts <- options(mc.cores = workers)
[13:21:34.687]                     on.exit(options(oopts))
[13:21:34.687]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:34.687]                       envir = envir)
[13:21:34.687]                     if (!future$lazy) 
[13:21:34.687]                       future <- run(future)
[13:21:34.687]                     invisible(future)
[13:21:34.687]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:34.687]                 }
[13:21:34.687]             }
[13:21:34.687]         }
[13:21:34.687]     })
[13:21:34.687]     if (TRUE) {
[13:21:34.687]         base::sink(type = "output", split = FALSE)
[13:21:34.687]         if (TRUE) {
[13:21:34.687]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:34.687]         }
[13:21:34.687]         else {
[13:21:34.687]             ...future.result["stdout"] <- base::list(NULL)
[13:21:34.687]         }
[13:21:34.687]         base::close(...future.stdout)
[13:21:34.687]         ...future.stdout <- NULL
[13:21:34.687]     }
[13:21:34.687]     ...future.result$conditions <- ...future.conditions
[13:21:34.687]     ...future.result$finished <- base::Sys.time()
[13:21:34.687]     ...future.result
[13:21:34.687] }
[13:21:34.690] assign_globals() ...
[13:21:34.691] List of 5
[13:21:34.691]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[13:21:34.691]  $ future.call.arguments    : list()
[13:21:34.691]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:34.691]  $ ...future.elements_ii    :List of 3
[13:21:34.691]   ..$ : int [1:7] 1 2 3 4 5 6 7
[13:21:34.691]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[13:21:34.691]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[13:21:34.691]  $ ...future.seeds_ii       : NULL
[13:21:34.691]  $ ...future.globals.maxSize: NULL
[13:21:34.691]  - attr(*, "where")=List of 5
[13:21:34.691]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:34.691]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:34.691]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:34.691]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:34.691]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:34.691]  - attr(*, "resolved")= logi FALSE
[13:21:34.691]  - attr(*, "total_size")= num 46960
[13:21:34.691]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:34.691]  - attr(*, "already-done")= logi TRUE
[13:21:34.701] - copied ‘...future.FUN’ to environment
[13:21:34.701] - copied ‘future.call.arguments’ to environment
[13:21:34.701] - copied ‘...future.elements_ii’ to environment
[13:21:34.701] - copied ‘...future.seeds_ii’ to environment
[13:21:34.702] - copied ‘...future.globals.maxSize’ to environment
[13:21:34.702] assign_globals() ... done
[13:21:34.702] requestCore(): workers = 2
[13:21:34.704] MulticoreFuture started
[13:21:34.705] - Launch lazy future ... done
[13:21:34.705] run() for ‘MulticoreFuture’ ... done
[13:21:34.706] Created future:
[13:21:34.706] plan(): Setting new future strategy stack:
[13:21:34.707] List of future strategies:
[13:21:34.707] 1. sequential:
[13:21:34.707]    - args: function (..., envir = parent.frame())
[13:21:34.707]    - tweaked: FALSE
[13:21:34.707]    - call: NULL
[13:21:34.708] plan(): nbrOfWorkers() = 1
[13:21:34.710] plan(): Setting new future strategy stack:
[13:21:34.710] List of future strategies:
[13:21:34.710] 1. multicore:
[13:21:34.710]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:34.710]    - tweaked: FALSE
[13:21:34.710]    - call: plan(strategy)
[13:21:34.716] plan(): nbrOfWorkers() = 2
[13:21:34.706] MulticoreFuture:
[13:21:34.706] Label: ‘future_sapply-2’
[13:21:34.706] Expression:
[13:21:34.706] {
[13:21:34.706]     do.call(function(...) {
[13:21:34.706]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.706]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:34.706]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.706]             on.exit(options(oopts), add = TRUE)
[13:21:34.706]         }
[13:21:34.706]         {
[13:21:34.706]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:34.706]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.706]                 ...future.FUN(...future.X_jj, ...)
[13:21:34.706]             })
[13:21:34.706]         }
[13:21:34.706]     }, args = future.call.arguments)
[13:21:34.706] }
[13:21:34.706] Lazy evaluation: FALSE
[13:21:34.706] Asynchronous evaluation: TRUE
[13:21:34.706] Local evaluation: TRUE
[13:21:34.706] Environment: R_GlobalEnv
[13:21:34.706] Capture standard output: TRUE
[13:21:34.706] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:34.706] Globals: 5 objects totaling 46.11 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 256 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:21:34.706] Packages: 1 packages (‘stats’)
[13:21:34.706] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:34.706] Resolved: TRUE
[13:21:34.706] Value: <not collected>
[13:21:34.706] Conditions captured: <none>
[13:21:34.706] Early signaling: FALSE
[13:21:34.706] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:34.706] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:34.717] Chunk #2 of 2 ... DONE
[13:21:34.718] Launching 2 futures (chunks) ... DONE
[13:21:34.718] Resolving 2 futures (chunks) ...
[13:21:34.718] resolve() on list ...
[13:21:34.718]  recursive: 0
[13:21:34.718]  length: 2
[13:21:34.718] 
[13:21:34.719] Future #1
[13:21:34.719] result() for MulticoreFuture ...
[13:21:34.720] result() for MulticoreFuture ...
[13:21:34.720] result() for MulticoreFuture ... done
[13:21:34.720] result() for MulticoreFuture ... done
[13:21:34.720] result() for MulticoreFuture ...
[13:21:34.720] result() for MulticoreFuture ... done
[13:21:34.721] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:21:34.721] - nx: 2
[13:21:34.721] - relay: TRUE
[13:21:34.721] - stdout: TRUE
[13:21:34.721] - signal: TRUE
[13:21:34.721] - resignal: FALSE
[13:21:34.722] - force: TRUE
[13:21:34.722] - relayed: [n=2] FALSE, FALSE
[13:21:34.722] - queued futures: [n=2] FALSE, FALSE
[13:21:34.722]  - until=1
[13:21:34.722]  - relaying element #1
[13:21:34.722] result() for MulticoreFuture ...
[13:21:34.723] result() for MulticoreFuture ... done
[13:21:34.723] result() for MulticoreFuture ...
[13:21:34.723] result() for MulticoreFuture ... done
[13:21:34.723] result() for MulticoreFuture ...
[13:21:34.723] result() for MulticoreFuture ... done
[13:21:34.723] result() for MulticoreFuture ...
[13:21:34.724] result() for MulticoreFuture ... done
[13:21:34.724] - relayed: [n=2] TRUE, FALSE
[13:21:34.724] - queued futures: [n=2] TRUE, FALSE
[13:21:34.724] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:21:34.724]  length: 1 (resolved future 1)
[13:21:34.725] Future #2
[13:21:34.725] result() for MulticoreFuture ...
[13:21:34.725] result() for MulticoreFuture ...
[13:21:34.726] result() for MulticoreFuture ... done
[13:21:34.726] result() for MulticoreFuture ... done
[13:21:34.726] result() for MulticoreFuture ...
[13:21:34.726] result() for MulticoreFuture ... done
[13:21:34.726] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:21:34.726] - nx: 2
[13:21:34.726] - relay: TRUE
[13:21:34.727] - stdout: TRUE
[13:21:34.727] - signal: TRUE
[13:21:34.727] - resignal: FALSE
[13:21:34.727] - force: TRUE
[13:21:34.727] - relayed: [n=2] TRUE, FALSE
[13:21:34.727] - queued futures: [n=2] TRUE, FALSE
[13:21:34.727]  - until=2
[13:21:34.727]  - relaying element #2
[13:21:34.728] result() for MulticoreFuture ...
[13:21:34.728] result() for MulticoreFuture ... done
[13:21:34.728] result() for MulticoreFuture ...
[13:21:34.728] result() for MulticoreFuture ... done
[13:21:34.728] result() for MulticoreFuture ...
[13:21:34.728] result() for MulticoreFuture ... done
[13:21:34.728] result() for MulticoreFuture ...
[13:21:34.729] result() for MulticoreFuture ... done
[13:21:34.729] - relayed: [n=2] TRUE, TRUE
[13:21:34.729] - queued futures: [n=2] TRUE, TRUE
[13:21:34.729] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:21:34.729]  length: 0 (resolved future 2)
[13:21:34.729] Relaying remaining futures
[13:21:34.729] signalConditionsASAP(NULL, pos=0) ...
[13:21:34.729] - nx: 2
[13:21:34.729] - relay: TRUE
[13:21:34.730] - stdout: TRUE
[13:21:34.730] - signal: TRUE
[13:21:34.730] - resignal: FALSE
[13:21:34.730] - force: TRUE
[13:21:34.730] - relayed: [n=2] TRUE, TRUE
[13:21:34.730] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:21:34.730] - relayed: [n=2] TRUE, TRUE
[13:21:34.730] - queued futures: [n=2] TRUE, TRUE
[13:21:34.730] signalConditionsASAP(NULL, pos=0) ... done
[13:21:34.731] resolve() on list ... DONE
[13:21:34.734] result() for MulticoreFuture ...
[13:21:34.734] result() for MulticoreFuture ... done
[13:21:34.734] result() for MulticoreFuture ...
[13:21:34.734] result() for MulticoreFuture ... done
[13:21:34.734] result() for MulticoreFuture ...
[13:21:34.734] result() for MulticoreFuture ... done
[13:21:34.735] result() for MulticoreFuture ...
[13:21:34.735] result() for MulticoreFuture ... done
[13:21:34.735]  - Number of value chunks collected: 2
[13:21:34.735] Resolving 2 futures (chunks) ... DONE
[13:21:34.735] Reducing values from 2 chunks ...
[13:21:34.735]  - Number of values collected after concatenation: 7
[13:21:34.736]  - Number of values expected: 7
[13:21:34.736] Reducing values from 2 chunks ... DONE
[13:21:34.736] future_lapply() ... DONE
[13:21:34.737] future_lapply() ...
[13:21:34.745] Number of chunks: 2
[13:21:34.745] getGlobalsAndPackagesXApply() ...
[13:21:34.745]  - future.globals: TRUE
[13:21:34.745] getGlobalsAndPackages() ...
[13:21:34.745] Searching for globals...
[13:21:34.753] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[13:21:34.754] Searching for globals ... DONE
[13:21:34.754] Resolving globals: FALSE
[13:21:34.755] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[13:21:34.755] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[13:21:34.756] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:34.756] - packages: [2] ‘stats’, ‘future.apply’
[13:21:34.756] getGlobalsAndPackages() ... DONE
[13:21:34.756]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:34.756]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[13:21:34.756] Finding globals ... DONE
[13:21:34.756]  - use_args: TRUE
[13:21:34.756]  - Getting '...' globals ...
[13:21:34.759] resolve() on list ...
[13:21:34.759]  recursive: 0
[13:21:34.759]  length: 1
[13:21:34.759]  elements: ‘...’
[13:21:34.760]  length: 0 (resolved future 1)
[13:21:34.760] resolve() on list ... DONE
[13:21:34.760]    - '...' content: [n=0] 
[13:21:34.760] List of 1
[13:21:34.760]  $ ...: list()
[13:21:34.760]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:34.760]  - attr(*, "where")=List of 1
[13:21:34.760]   ..$ ...:<environment: 0x563b6e47a3e0> 
[13:21:34.760]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:34.760]  - attr(*, "resolved")= logi TRUE
[13:21:34.760]  - attr(*, "total_size")= num NA
[13:21:34.763]  - Getting '...' globals ... DONE
[13:21:34.764] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:34.764] List of 8
[13:21:34.764]  $ ...future.FUN:function (x, ...)  
[13:21:34.764]  $ x_FUN        :function (x, na.rm = TRUE)  
[13:21:34.764]  $ times        : int 5
[13:21:34.764]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:34.764]  $ stop_if_not  :function (...)  
[13:21:34.764]  $ dim          : NULL
[13:21:34.764]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:21:34.764]  $ ...          : list()
[13:21:34.764]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:34.764]  - attr(*, "where")=List of 8
[13:21:34.764]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:34.764]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:34.764]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:34.764]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:34.764]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:34.764]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:34.764]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:34.764]   ..$ ...          :<environment: 0x563b6e47a3e0> 
[13:21:34.764]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:34.764]  - attr(*, "resolved")= logi FALSE
[13:21:34.764]  - attr(*, "total_size")= num 141240
[13:21:34.770] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[13:21:34.770] getGlobalsAndPackagesXApply() ... DONE
[13:21:34.770] Number of futures (= number of chunks): 2
[13:21:34.770] Launching 2 futures (chunks) ...
[13:21:34.770] Chunk #1 of 2 ...
[13:21:34.770]  - Finding globals in 'X' for chunk #1 ...
[13:21:34.770] getGlobalsAndPackages() ...
[13:21:34.770] Searching for globals...
[13:21:34.771] 
[13:21:34.771] Searching for globals ... DONE
[13:21:34.771] - globals: [0] <none>
[13:21:34.771] getGlobalsAndPackages() ... DONE
[13:21:34.771]    + additional globals found: [n=0] 
[13:21:34.771]    + additional namespaces needed: [n=0] 
[13:21:34.771]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:34.771]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:34.772]  - seeds: <none>
[13:21:34.772]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.772] getGlobalsAndPackages() ...
[13:21:34.772] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.772] Resolving globals: FALSE
[13:21:34.772] Tweak future expression to call with '...' arguments ...
[13:21:34.772] {
[13:21:34.772]     do.call(function(...) {
[13:21:34.772]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.772]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:34.772]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.772]             on.exit(options(oopts), add = TRUE)
[13:21:34.772]         }
[13:21:34.772]         {
[13:21:34.772]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:34.772]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.772]                 ...future.FUN(...future.X_jj, ...)
[13:21:34.772]             })
[13:21:34.772]         }
[13:21:34.772]     }, args = future.call.arguments)
[13:21:34.772] }
[13:21:34.773] Tweak future expression to call with '...' arguments ... DONE
[13:21:34.773] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.773] - packages: [2] ‘stats’, ‘future.apply’
[13:21:34.773] getGlobalsAndPackages() ... DONE
[13:21:34.774] run() for ‘Future’ ...
[13:21:34.774] - state: ‘created’
[13:21:34.774] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:34.778] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:34.778] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:34.778]   - Field: ‘label’
[13:21:34.778]   - Field: ‘local’
[13:21:34.778]   - Field: ‘owner’
[13:21:34.779]   - Field: ‘envir’
[13:21:34.779]   - Field: ‘workers’
[13:21:34.779]   - Field: ‘packages’
[13:21:34.779]   - Field: ‘gc’
[13:21:34.779]   - Field: ‘job’
[13:21:34.779]   - Field: ‘conditions’
[13:21:34.779]   - Field: ‘expr’
[13:21:34.779]   - Field: ‘uuid’
[13:21:34.779]   - Field: ‘seed’
[13:21:34.779]   - Field: ‘version’
[13:21:34.779]   - Field: ‘result’
[13:21:34.780]   - Field: ‘asynchronous’
[13:21:34.780]   - Field: ‘calls’
[13:21:34.780]   - Field: ‘globals’
[13:21:34.780]   - Field: ‘stdout’
[13:21:34.780]   - Field: ‘earlySignal’
[13:21:34.782]   - Field: ‘lazy’
[13:21:34.782]   - Field: ‘state’
[13:21:34.783] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:34.783] - Launch lazy future ...
[13:21:34.783] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[13:21:34.783] Packages needed by future strategies (n = 0): <none>
[13:21:34.784] {
[13:21:34.784]     {
[13:21:34.784]         {
[13:21:34.784]             ...future.startTime <- base::Sys.time()
[13:21:34.784]             {
[13:21:34.784]                 {
[13:21:34.784]                   {
[13:21:34.784]                     {
[13:21:34.784]                       {
[13:21:34.784]                         base::local({
[13:21:34.784]                           has_future <- base::requireNamespace("future", 
[13:21:34.784]                             quietly = TRUE)
[13:21:34.784]                           if (has_future) {
[13:21:34.784]                             ns <- base::getNamespace("future")
[13:21:34.784]                             version <- ns[[".package"]][["version"]]
[13:21:34.784]                             if (is.null(version)) 
[13:21:34.784]                               version <- utils::packageVersion("future")
[13:21:34.784]                           }
[13:21:34.784]                           else {
[13:21:34.784]                             version <- NULL
[13:21:34.784]                           }
[13:21:34.784]                           if (!has_future || version < "1.8.0") {
[13:21:34.784]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:34.784]                               "", base::R.version$version.string), 
[13:21:34.784]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:34.784]                                 base::R.version$platform, 8 * 
[13:21:34.784]                                   base::.Machine$sizeof.pointer), 
[13:21:34.784]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:34.784]                                 "release", "version")], collapse = " "), 
[13:21:34.784]                               hostname = base::Sys.info()[["nodename"]])
[13:21:34.784]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:34.784]                               info)
[13:21:34.784]                             info <- base::paste(info, collapse = "; ")
[13:21:34.784]                             if (!has_future) {
[13:21:34.784]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:34.784]                                 info)
[13:21:34.784]                             }
[13:21:34.784]                             else {
[13:21:34.784]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:34.784]                                 info, version)
[13:21:34.784]                             }
[13:21:34.784]                             base::stop(msg)
[13:21:34.784]                           }
[13:21:34.784]                         })
[13:21:34.784]                       }
[13:21:34.784]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:34.784]                       base::options(mc.cores = 1L)
[13:21:34.784]                     }
[13:21:34.784]                     base::local({
[13:21:34.784]                       for (pkg in c("stats", "future.apply")) {
[13:21:34.784]                         base::loadNamespace(pkg)
[13:21:34.784]                         base::library(pkg, character.only = TRUE)
[13:21:34.784]                       }
[13:21:34.784]                     })
[13:21:34.784]                   }
[13:21:34.784]                   options(future.plan = NULL)
[13:21:34.784]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:34.784]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:34.784]                 }
[13:21:34.784]                 ...future.workdir <- getwd()
[13:21:34.784]             }
[13:21:34.784]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:34.784]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:34.784]         }
[13:21:34.784]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:34.784]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:34.784]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:34.784]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:34.784]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:34.784]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:34.784]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:34.784]             base::names(...future.oldOptions))
[13:21:34.784]     }
[13:21:34.784]     if (FALSE) {
[13:21:34.784]     }
[13:21:34.784]     else {
[13:21:34.784]         if (TRUE) {
[13:21:34.784]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:34.784]                 open = "w")
[13:21:34.784]         }
[13:21:34.784]         else {
[13:21:34.784]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:34.784]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:34.784]         }
[13:21:34.784]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:34.784]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:34.784]             base::sink(type = "output", split = FALSE)
[13:21:34.784]             base::close(...future.stdout)
[13:21:34.784]         }, add = TRUE)
[13:21:34.784]     }
[13:21:34.784]     ...future.frame <- base::sys.nframe()
[13:21:34.784]     ...future.conditions <- base::list()
[13:21:34.784]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:34.784]     if (FALSE) {
[13:21:34.784]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:34.784]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:34.784]     }
[13:21:34.784]     ...future.result <- base::tryCatch({
[13:21:34.784]         base::withCallingHandlers({
[13:21:34.784]             ...future.value <- base::withVisible(base::local({
[13:21:34.784]                 withCallingHandlers({
[13:21:34.784]                   {
[13:21:34.784]                     do.call(function(...) {
[13:21:34.784]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.784]                       if (!identical(...future.globals.maxSize.org, 
[13:21:34.784]                         ...future.globals.maxSize)) {
[13:21:34.784]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.784]                         on.exit(options(oopts), add = TRUE)
[13:21:34.784]                       }
[13:21:34.784]                       {
[13:21:34.784]                         lapply(seq_along(...future.elements_ii), 
[13:21:34.784]                           FUN = function(jj) {
[13:21:34.784]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.784]                             ...future.FUN(...future.X_jj, ...)
[13:21:34.784]                           })
[13:21:34.784]                       }
[13:21:34.784]                     }, args = future.call.arguments)
[13:21:34.784]                   }
[13:21:34.784]                 }, immediateCondition = function(cond) {
[13:21:34.784]                   save_rds <- function (object, pathname, ...) 
[13:21:34.784]                   {
[13:21:34.784]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:34.784]                     if (file_test("-f", pathname_tmp)) {
[13:21:34.784]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.784]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:34.784]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.784]                         fi_tmp[["mtime"]])
[13:21:34.784]                     }
[13:21:34.784]                     tryCatch({
[13:21:34.784]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:34.784]                     }, error = function(ex) {
[13:21:34.784]                       msg <- conditionMessage(ex)
[13:21:34.784]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.784]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:34.784]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.784]                         fi_tmp[["mtime"]], msg)
[13:21:34.784]                       ex$message <- msg
[13:21:34.784]                       stop(ex)
[13:21:34.784]                     })
[13:21:34.784]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:34.784]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:34.784]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:34.784]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.784]                       fi <- file.info(pathname)
[13:21:34.784]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:34.784]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.784]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:34.784]                         fi[["size"]], fi[["mtime"]])
[13:21:34.784]                       stop(msg)
[13:21:34.784]                     }
[13:21:34.784]                     invisible(pathname)
[13:21:34.784]                   }
[13:21:34.784]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:34.784]                     rootPath = tempdir()) 
[13:21:34.784]                   {
[13:21:34.784]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:34.784]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:34.784]                       tmpdir = path, fileext = ".rds")
[13:21:34.784]                     save_rds(obj, file)
[13:21:34.784]                   }
[13:21:34.784]                   saveImmediateCondition(cond, path = "/tmp/RtmpbpFWGO/.future/immediateConditions")
[13:21:34.784]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.784]                   {
[13:21:34.784]                     inherits <- base::inherits
[13:21:34.784]                     invokeRestart <- base::invokeRestart
[13:21:34.784]                     is.null <- base::is.null
[13:21:34.784]                     muffled <- FALSE
[13:21:34.784]                     if (inherits(cond, "message")) {
[13:21:34.784]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:34.784]                       if (muffled) 
[13:21:34.784]                         invokeRestart("muffleMessage")
[13:21:34.784]                     }
[13:21:34.784]                     else if (inherits(cond, "warning")) {
[13:21:34.784]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:34.784]                       if (muffled) 
[13:21:34.784]                         invokeRestart("muffleWarning")
[13:21:34.784]                     }
[13:21:34.784]                     else if (inherits(cond, "condition")) {
[13:21:34.784]                       if (!is.null(pattern)) {
[13:21:34.784]                         computeRestarts <- base::computeRestarts
[13:21:34.784]                         grepl <- base::grepl
[13:21:34.784]                         restarts <- computeRestarts(cond)
[13:21:34.784]                         for (restart in restarts) {
[13:21:34.784]                           name <- restart$name
[13:21:34.784]                           if (is.null(name)) 
[13:21:34.784]                             next
[13:21:34.784]                           if (!grepl(pattern, name)) 
[13:21:34.784]                             next
[13:21:34.784]                           invokeRestart(restart)
[13:21:34.784]                           muffled <- TRUE
[13:21:34.784]                           break
[13:21:34.784]                         }
[13:21:34.784]                       }
[13:21:34.784]                     }
[13:21:34.784]                     invisible(muffled)
[13:21:34.784]                   }
[13:21:34.784]                   muffleCondition(cond)
[13:21:34.784]                 })
[13:21:34.784]             }))
[13:21:34.784]             future::FutureResult(value = ...future.value$value, 
[13:21:34.784]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:34.784]                   ...future.rng), globalenv = if (FALSE) 
[13:21:34.784]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:34.784]                     ...future.globalenv.names))
[13:21:34.784]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:34.784]         }, condition = base::local({
[13:21:34.784]             c <- base::c
[13:21:34.784]             inherits <- base::inherits
[13:21:34.784]             invokeRestart <- base::invokeRestart
[13:21:34.784]             length <- base::length
[13:21:34.784]             list <- base::list
[13:21:34.784]             seq.int <- base::seq.int
[13:21:34.784]             signalCondition <- base::signalCondition
[13:21:34.784]             sys.calls <- base::sys.calls
[13:21:34.784]             `[[` <- base::`[[`
[13:21:34.784]             `+` <- base::`+`
[13:21:34.784]             `<<-` <- base::`<<-`
[13:21:34.784]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:34.784]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:34.784]                   3L)]
[13:21:34.784]             }
[13:21:34.784]             function(cond) {
[13:21:34.784]                 is_error <- inherits(cond, "error")
[13:21:34.784]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:34.784]                   NULL)
[13:21:34.784]                 if (is_error) {
[13:21:34.784]                   sessionInformation <- function() {
[13:21:34.784]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:34.784]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:34.784]                       search = base::search(), system = base::Sys.info())
[13:21:34.784]                   }
[13:21:34.784]                   ...future.conditions[[length(...future.conditions) + 
[13:21:34.784]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:34.784]                     cond$call), session = sessionInformation(), 
[13:21:34.784]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:34.784]                   signalCondition(cond)
[13:21:34.784]                 }
[13:21:34.784]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:34.784]                 "immediateCondition"))) {
[13:21:34.784]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:34.784]                   ...future.conditions[[length(...future.conditions) + 
[13:21:34.784]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:34.784]                   if (TRUE && !signal) {
[13:21:34.784]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.784]                     {
[13:21:34.784]                       inherits <- base::inherits
[13:21:34.784]                       invokeRestart <- base::invokeRestart
[13:21:34.784]                       is.null <- base::is.null
[13:21:34.784]                       muffled <- FALSE
[13:21:34.784]                       if (inherits(cond, "message")) {
[13:21:34.784]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:34.784]                         if (muffled) 
[13:21:34.784]                           invokeRestart("muffleMessage")
[13:21:34.784]                       }
[13:21:34.784]                       else if (inherits(cond, "warning")) {
[13:21:34.784]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:34.784]                         if (muffled) 
[13:21:34.784]                           invokeRestart("muffleWarning")
[13:21:34.784]                       }
[13:21:34.784]                       else if (inherits(cond, "condition")) {
[13:21:34.784]                         if (!is.null(pattern)) {
[13:21:34.784]                           computeRestarts <- base::computeRestarts
[13:21:34.784]                           grepl <- base::grepl
[13:21:34.784]                           restarts <- computeRestarts(cond)
[13:21:34.784]                           for (restart in restarts) {
[13:21:34.784]                             name <- restart$name
[13:21:34.784]                             if (is.null(name)) 
[13:21:34.784]                               next
[13:21:34.784]                             if (!grepl(pattern, name)) 
[13:21:34.784]                               next
[13:21:34.784]                             invokeRestart(restart)
[13:21:34.784]                             muffled <- TRUE
[13:21:34.784]                             break
[13:21:34.784]                           }
[13:21:34.784]                         }
[13:21:34.784]                       }
[13:21:34.784]                       invisible(muffled)
[13:21:34.784]                     }
[13:21:34.784]                     muffleCondition(cond, pattern = "^muffle")
[13:21:34.784]                   }
[13:21:34.784]                 }
[13:21:34.784]                 else {
[13:21:34.784]                   if (TRUE) {
[13:21:34.784]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.784]                     {
[13:21:34.784]                       inherits <- base::inherits
[13:21:34.784]                       invokeRestart <- base::invokeRestart
[13:21:34.784]                       is.null <- base::is.null
[13:21:34.784]                       muffled <- FALSE
[13:21:34.784]                       if (inherits(cond, "message")) {
[13:21:34.784]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:34.784]                         if (muffled) 
[13:21:34.784]                           invokeRestart("muffleMessage")
[13:21:34.784]                       }
[13:21:34.784]                       else if (inherits(cond, "warning")) {
[13:21:34.784]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:34.784]                         if (muffled) 
[13:21:34.784]                           invokeRestart("muffleWarning")
[13:21:34.784]                       }
[13:21:34.784]                       else if (inherits(cond, "condition")) {
[13:21:34.784]                         if (!is.null(pattern)) {
[13:21:34.784]                           computeRestarts <- base::computeRestarts
[13:21:34.784]                           grepl <- base::grepl
[13:21:34.784]                           restarts <- computeRestarts(cond)
[13:21:34.784]                           for (restart in restarts) {
[13:21:34.784]                             name <- restart$name
[13:21:34.784]                             if (is.null(name)) 
[13:21:34.784]                               next
[13:21:34.784]                             if (!grepl(pattern, name)) 
[13:21:34.784]                               next
[13:21:34.784]                             invokeRestart(restart)
[13:21:34.784]                             muffled <- TRUE
[13:21:34.784]                             break
[13:21:34.784]                           }
[13:21:34.784]                         }
[13:21:34.784]                       }
[13:21:34.784]                       invisible(muffled)
[13:21:34.784]                     }
[13:21:34.784]                     muffleCondition(cond, pattern = "^muffle")
[13:21:34.784]                   }
[13:21:34.784]                 }
[13:21:34.784]             }
[13:21:34.784]         }))
[13:21:34.784]     }, error = function(ex) {
[13:21:34.784]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:34.784]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:34.784]                 ...future.rng), started = ...future.startTime, 
[13:21:34.784]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:34.784]             version = "1.8"), class = "FutureResult")
[13:21:34.784]     }, finally = {
[13:21:34.784]         if (!identical(...future.workdir, getwd())) 
[13:21:34.784]             setwd(...future.workdir)
[13:21:34.784]         {
[13:21:34.784]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:34.784]                 ...future.oldOptions$nwarnings <- NULL
[13:21:34.784]             }
[13:21:34.784]             base::options(...future.oldOptions)
[13:21:34.784]             if (.Platform$OS.type == "windows") {
[13:21:34.784]                 old_names <- names(...future.oldEnvVars)
[13:21:34.784]                 envs <- base::Sys.getenv()
[13:21:34.784]                 names <- names(envs)
[13:21:34.784]                 common <- intersect(names, old_names)
[13:21:34.784]                 added <- setdiff(names, old_names)
[13:21:34.784]                 removed <- setdiff(old_names, names)
[13:21:34.784]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:34.784]                   envs[common]]
[13:21:34.784]                 NAMES <- toupper(changed)
[13:21:34.784]                 args <- list()
[13:21:34.784]                 for (kk in seq_along(NAMES)) {
[13:21:34.784]                   name <- changed[[kk]]
[13:21:34.784]                   NAME <- NAMES[[kk]]
[13:21:34.784]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.784]                     next
[13:21:34.784]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:34.784]                 }
[13:21:34.784]                 NAMES <- toupper(added)
[13:21:34.784]                 for (kk in seq_along(NAMES)) {
[13:21:34.784]                   name <- added[[kk]]
[13:21:34.784]                   NAME <- NAMES[[kk]]
[13:21:34.784]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.784]                     next
[13:21:34.784]                   args[[name]] <- ""
[13:21:34.784]                 }
[13:21:34.784]                 NAMES <- toupper(removed)
[13:21:34.784]                 for (kk in seq_along(NAMES)) {
[13:21:34.784]                   name <- removed[[kk]]
[13:21:34.784]                   NAME <- NAMES[[kk]]
[13:21:34.784]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.784]                     next
[13:21:34.784]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:34.784]                 }
[13:21:34.784]                 if (length(args) > 0) 
[13:21:34.784]                   base::do.call(base::Sys.setenv, args = args)
[13:21:34.784]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:34.784]             }
[13:21:34.784]             else {
[13:21:34.784]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:34.784]             }
[13:21:34.784]             {
[13:21:34.784]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:34.784]                   0L) {
[13:21:34.784]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:34.784]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:34.784]                   base::options(opts)
[13:21:34.784]                 }
[13:21:34.784]                 {
[13:21:34.784]                   {
[13:21:34.784]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:34.784]                     NULL
[13:21:34.784]                   }
[13:21:34.784]                   options(future.plan = NULL)
[13:21:34.784]                   if (is.na(NA_character_)) 
[13:21:34.784]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:34.784]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:34.784]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:34.784]                     envir = parent.frame()) 
[13:21:34.784]                   {
[13:21:34.784]                     default_workers <- missing(workers)
[13:21:34.784]                     if (is.function(workers)) 
[13:21:34.784]                       workers <- workers()
[13:21:34.784]                     workers <- structure(as.integer(workers), 
[13:21:34.784]                       class = class(workers))
[13:21:34.784]                     stop_if_not(is.finite(workers), workers >= 
[13:21:34.784]                       1L)
[13:21:34.784]                     if ((workers == 1L && !inherits(workers, 
[13:21:34.784]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:34.784]                       if (default_workers) 
[13:21:34.784]                         supportsMulticore(warn = TRUE)
[13:21:34.784]                       return(sequential(..., envir = envir))
[13:21:34.784]                     }
[13:21:34.784]                     oopts <- options(mc.cores = workers)
[13:21:34.784]                     on.exit(options(oopts))
[13:21:34.784]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:34.784]                       envir = envir)
[13:21:34.784]                     if (!future$lazy) 
[13:21:34.784]                       future <- run(future)
[13:21:34.784]                     invisible(future)
[13:21:34.784]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:34.784]                 }
[13:21:34.784]             }
[13:21:34.784]         }
[13:21:34.784]     })
[13:21:34.784]     if (TRUE) {
[13:21:34.784]         base::sink(type = "output", split = FALSE)
[13:21:34.784]         if (TRUE) {
[13:21:34.784]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:34.784]         }
[13:21:34.784]         else {
[13:21:34.784]             ...future.result["stdout"] <- base::list(NULL)
[13:21:34.784]         }
[13:21:34.784]         base::close(...future.stdout)
[13:21:34.784]         ...future.stdout <- NULL
[13:21:34.784]     }
[13:21:34.784]     ...future.result$conditions <- ...future.conditions
[13:21:34.784]     ...future.result$finished <- base::Sys.time()
[13:21:34.784]     ...future.result
[13:21:34.784] }
[13:21:34.787] assign_globals() ...
[13:21:34.787] List of 11
[13:21:34.787]  $ ...future.FUN            :function (x, ...)  
[13:21:34.787]  $ x_FUN                    :function (x, na.rm = TRUE)  
[13:21:34.787]  $ times                    : int 5
[13:21:34.787]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:34.787]  $ stop_if_not              :function (...)  
[13:21:34.787]  $ dim                      : NULL
[13:21:34.787]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:21:34.787]  $ future.call.arguments    : list()
[13:21:34.787]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:34.787]  $ ...future.elements_ii    :List of 4
[13:21:34.787]   ..$ : int [1:3] 1 2 3
[13:21:34.787]   ..$ : int [1:4] 1 2 3 4
[13:21:34.787]   ..$ : int [1:5] 1 2 3 4 5
[13:21:34.787]   ..$ : int [1:6] 1 2 3 4 5 6
[13:21:34.787]  $ ...future.seeds_ii       : NULL
[13:21:34.787]  $ ...future.globals.maxSize: NULL
[13:21:34.787]  - attr(*, "where")=List of 11
[13:21:34.787]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:34.787]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:34.787]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:34.787]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:34.787]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:34.787]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:34.787]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:34.787]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:34.787]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:34.787]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:34.787]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:34.787]  - attr(*, "resolved")= logi FALSE
[13:21:34.787]  - attr(*, "total_size")= num 141240
[13:21:34.787]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:34.787]  - attr(*, "already-done")= logi TRUE
[13:21:34.796] - copied ‘...future.FUN’ to environment
[13:21:34.797] - copied ‘x_FUN’ to environment
[13:21:34.797] - copied ‘times’ to environment
[13:21:34.797] - copied ‘stopf’ to environment
[13:21:34.797] - copied ‘stop_if_not’ to environment
[13:21:34.797] - copied ‘dim’ to environment
[13:21:34.797] - copied ‘valid_types’ to environment
[13:21:34.797] - copied ‘future.call.arguments’ to environment
[13:21:34.798] - copied ‘...future.elements_ii’ to environment
[13:21:34.798] - copied ‘...future.seeds_ii’ to environment
[13:21:34.798] - copied ‘...future.globals.maxSize’ to environment
[13:21:34.798] assign_globals() ... done
[13:21:34.798] requestCore(): workers = 2
[13:21:34.800] MulticoreFuture started
[13:21:34.801] - Launch lazy future ... done
[13:21:34.801] run() for ‘MulticoreFuture’ ... done
[13:21:34.801] Created future:
[13:21:34.802] plan(): Setting new future strategy stack:
[13:21:34.802] List of future strategies:
[13:21:34.802] 1. sequential:
[13:21:34.802]    - args: function (..., envir = parent.frame())
[13:21:34.802]    - tweaked: FALSE
[13:21:34.802]    - call: NULL
[13:21:34.803] plan(): nbrOfWorkers() = 1
[13:21:34.806] plan(): Setting new future strategy stack:
[13:21:34.806] List of future strategies:
[13:21:34.806] 1. multicore:
[13:21:34.806]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:34.806]    - tweaked: FALSE
[13:21:34.806]    - call: plan(strategy)
[13:21:34.812] plan(): nbrOfWorkers() = 2
[13:21:34.801] MulticoreFuture:
[13:21:34.801] Label: ‘future_vapply-1’
[13:21:34.801] Expression:
[13:21:34.801] {
[13:21:34.801]     do.call(function(...) {
[13:21:34.801]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.801]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:34.801]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.801]             on.exit(options(oopts), add = TRUE)
[13:21:34.801]         }
[13:21:34.801]         {
[13:21:34.801]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:34.801]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.801]                 ...future.FUN(...future.X_jj, ...)
[13:21:34.801]             })
[13:21:34.801]         }
[13:21:34.801]     }, args = future.call.arguments)
[13:21:34.801] }
[13:21:34.801] Lazy evaluation: FALSE
[13:21:34.801] Asynchronous evaluation: TRUE
[13:21:34.801] Local evaluation: TRUE
[13:21:34.801] Environment: R_GlobalEnv
[13:21:34.801] Capture standard output: TRUE
[13:21:34.801] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:34.801] Globals: 11 objects totaling 138.21 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:34.801] Packages: 2 packages (‘stats’, ‘future.apply’)
[13:21:34.801] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:34.801] Resolved: TRUE
[13:21:34.801] Value: <not collected>
[13:21:34.801] Conditions captured: <none>
[13:21:34.801] Early signaling: FALSE
[13:21:34.801] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:34.801] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:34.813] Chunk #1 of 2 ... DONE
[13:21:34.813] Chunk #2 of 2 ...
[13:21:34.813]  - Finding globals in 'X' for chunk #2 ...
[13:21:34.813] getGlobalsAndPackages() ...
[13:21:34.814] Searching for globals...
[13:21:34.814] 
[13:21:34.814] Searching for globals ... DONE
[13:21:34.814] - globals: [0] <none>
[13:21:34.814] getGlobalsAndPackages() ... DONE
[13:21:34.815]    + additional globals found: [n=0] 
[13:21:34.815]    + additional namespaces needed: [n=0] 
[13:21:34.815]  - Finding globals in 'X' for chunk #2 ... DONE
[13:21:34.815]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:34.815]  - seeds: <none>
[13:21:34.815]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.815] getGlobalsAndPackages() ...
[13:21:34.816] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.816] Resolving globals: FALSE
[13:21:34.816] Tweak future expression to call with '...' arguments ...
[13:21:34.816] {
[13:21:34.816]     do.call(function(...) {
[13:21:34.816]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.816]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:34.816]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.816]             on.exit(options(oopts), add = TRUE)
[13:21:34.816]         }
[13:21:34.816]         {
[13:21:34.816]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:34.816]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.816]                 ...future.FUN(...future.X_jj, ...)
[13:21:34.816]             })
[13:21:34.816]         }
[13:21:34.816]     }, args = future.call.arguments)
[13:21:34.816] }
[13:21:34.817] Tweak future expression to call with '...' arguments ... DONE
[13:21:34.818] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.818] - packages: [2] ‘stats’, ‘future.apply’
[13:21:34.818] getGlobalsAndPackages() ... DONE
[13:21:34.822] run() for ‘Future’ ...
[13:21:34.822] - state: ‘created’
[13:21:34.823] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:34.830] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:34.830] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:34.830]   - Field: ‘label’
[13:21:34.831]   - Field: ‘local’
[13:21:34.831]   - Field: ‘owner’
[13:21:34.831]   - Field: ‘envir’
[13:21:34.832]   - Field: ‘workers’
[13:21:34.832]   - Field: ‘packages’
[13:21:34.832]   - Field: ‘gc’
[13:21:34.832]   - Field: ‘job’
[13:21:34.833]   - Field: ‘conditions’
[13:21:34.833]   - Field: ‘expr’
[13:21:34.833]   - Field: ‘uuid’
[13:21:34.833]   - Field: ‘seed’
[13:21:34.833]   - Field: ‘version’
[13:21:34.834]   - Field: ‘result’
[13:21:34.834]   - Field: ‘asynchronous’
[13:21:34.834]   - Field: ‘calls’
[13:21:34.834]   - Field: ‘globals’
[13:21:34.834]   - Field: ‘stdout’
[13:21:34.835]   - Field: ‘earlySignal’
[13:21:34.835]   - Field: ‘lazy’
[13:21:34.835]   - Field: ‘state’
[13:21:34.835] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:34.836] - Launch lazy future ...
[13:21:34.836] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[13:21:34.836] Packages needed by future strategies (n = 0): <none>
[13:21:34.838] {
[13:21:34.838]     {
[13:21:34.838]         {
[13:21:34.838]             ...future.startTime <- base::Sys.time()
[13:21:34.838]             {
[13:21:34.838]                 {
[13:21:34.838]                   {
[13:21:34.838]                     {
[13:21:34.838]                       {
[13:21:34.838]                         base::local({
[13:21:34.838]                           has_future <- base::requireNamespace("future", 
[13:21:34.838]                             quietly = TRUE)
[13:21:34.838]                           if (has_future) {
[13:21:34.838]                             ns <- base::getNamespace("future")
[13:21:34.838]                             version <- ns[[".package"]][["version"]]
[13:21:34.838]                             if (is.null(version)) 
[13:21:34.838]                               version <- utils::packageVersion("future")
[13:21:34.838]                           }
[13:21:34.838]                           else {
[13:21:34.838]                             version <- NULL
[13:21:34.838]                           }
[13:21:34.838]                           if (!has_future || version < "1.8.0") {
[13:21:34.838]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:34.838]                               "", base::R.version$version.string), 
[13:21:34.838]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:34.838]                                 base::R.version$platform, 8 * 
[13:21:34.838]                                   base::.Machine$sizeof.pointer), 
[13:21:34.838]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:34.838]                                 "release", "version")], collapse = " "), 
[13:21:34.838]                               hostname = base::Sys.info()[["nodename"]])
[13:21:34.838]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:34.838]                               info)
[13:21:34.838]                             info <- base::paste(info, collapse = "; ")
[13:21:34.838]                             if (!has_future) {
[13:21:34.838]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:34.838]                                 info)
[13:21:34.838]                             }
[13:21:34.838]                             else {
[13:21:34.838]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:34.838]                                 info, version)
[13:21:34.838]                             }
[13:21:34.838]                             base::stop(msg)
[13:21:34.838]                           }
[13:21:34.838]                         })
[13:21:34.838]                       }
[13:21:34.838]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:34.838]                       base::options(mc.cores = 1L)
[13:21:34.838]                     }
[13:21:34.838]                     base::local({
[13:21:34.838]                       for (pkg in c("stats", "future.apply")) {
[13:21:34.838]                         base::loadNamespace(pkg)
[13:21:34.838]                         base::library(pkg, character.only = TRUE)
[13:21:34.838]                       }
[13:21:34.838]                     })
[13:21:34.838]                   }
[13:21:34.838]                   options(future.plan = NULL)
[13:21:34.838]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:34.838]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:34.838]                 }
[13:21:34.838]                 ...future.workdir <- getwd()
[13:21:34.838]             }
[13:21:34.838]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:34.838]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:34.838]         }
[13:21:34.838]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:34.838]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:34.838]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:34.838]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:34.838]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:34.838]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:34.838]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:34.838]             base::names(...future.oldOptions))
[13:21:34.838]     }
[13:21:34.838]     if (FALSE) {
[13:21:34.838]     }
[13:21:34.838]     else {
[13:21:34.838]         if (TRUE) {
[13:21:34.838]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:34.838]                 open = "w")
[13:21:34.838]         }
[13:21:34.838]         else {
[13:21:34.838]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:34.838]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:34.838]         }
[13:21:34.838]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:34.838]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:34.838]             base::sink(type = "output", split = FALSE)
[13:21:34.838]             base::close(...future.stdout)
[13:21:34.838]         }, add = TRUE)
[13:21:34.838]     }
[13:21:34.838]     ...future.frame <- base::sys.nframe()
[13:21:34.838]     ...future.conditions <- base::list()
[13:21:34.838]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:34.838]     if (FALSE) {
[13:21:34.838]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:34.838]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:34.838]     }
[13:21:34.838]     ...future.result <- base::tryCatch({
[13:21:34.838]         base::withCallingHandlers({
[13:21:34.838]             ...future.value <- base::withVisible(base::local({
[13:21:34.838]                 withCallingHandlers({
[13:21:34.838]                   {
[13:21:34.838]                     do.call(function(...) {
[13:21:34.838]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.838]                       if (!identical(...future.globals.maxSize.org, 
[13:21:34.838]                         ...future.globals.maxSize)) {
[13:21:34.838]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.838]                         on.exit(options(oopts), add = TRUE)
[13:21:34.838]                       }
[13:21:34.838]                       {
[13:21:34.838]                         lapply(seq_along(...future.elements_ii), 
[13:21:34.838]                           FUN = function(jj) {
[13:21:34.838]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.838]                             ...future.FUN(...future.X_jj, ...)
[13:21:34.838]                           })
[13:21:34.838]                       }
[13:21:34.838]                     }, args = future.call.arguments)
[13:21:34.838]                   }
[13:21:34.838]                 }, immediateCondition = function(cond) {
[13:21:34.838]                   save_rds <- function (object, pathname, ...) 
[13:21:34.838]                   {
[13:21:34.838]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:34.838]                     if (file_test("-f", pathname_tmp)) {
[13:21:34.838]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.838]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:34.838]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.838]                         fi_tmp[["mtime"]])
[13:21:34.838]                     }
[13:21:34.838]                     tryCatch({
[13:21:34.838]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:34.838]                     }, error = function(ex) {
[13:21:34.838]                       msg <- conditionMessage(ex)
[13:21:34.838]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.838]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:34.838]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.838]                         fi_tmp[["mtime"]], msg)
[13:21:34.838]                       ex$message <- msg
[13:21:34.838]                       stop(ex)
[13:21:34.838]                     })
[13:21:34.838]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:34.838]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:34.838]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:34.838]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.838]                       fi <- file.info(pathname)
[13:21:34.838]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:34.838]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.838]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:34.838]                         fi[["size"]], fi[["mtime"]])
[13:21:34.838]                       stop(msg)
[13:21:34.838]                     }
[13:21:34.838]                     invisible(pathname)
[13:21:34.838]                   }
[13:21:34.838]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:34.838]                     rootPath = tempdir()) 
[13:21:34.838]                   {
[13:21:34.838]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:34.838]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:34.838]                       tmpdir = path, fileext = ".rds")
[13:21:34.838]                     save_rds(obj, file)
[13:21:34.838]                   }
[13:21:34.838]                   saveImmediateCondition(cond, path = "/tmp/RtmpbpFWGO/.future/immediateConditions")
[13:21:34.838]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.838]                   {
[13:21:34.838]                     inherits <- base::inherits
[13:21:34.838]                     invokeRestart <- base::invokeRestart
[13:21:34.838]                     is.null <- base::is.null
[13:21:34.838]                     muffled <- FALSE
[13:21:34.838]                     if (inherits(cond, "message")) {
[13:21:34.838]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:34.838]                       if (muffled) 
[13:21:34.838]                         invokeRestart("muffleMessage")
[13:21:34.838]                     }
[13:21:34.838]                     else if (inherits(cond, "warning")) {
[13:21:34.838]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:34.838]                       if (muffled) 
[13:21:34.838]                         invokeRestart("muffleWarning")
[13:21:34.838]                     }
[13:21:34.838]                     else if (inherits(cond, "condition")) {
[13:21:34.838]                       if (!is.null(pattern)) {
[13:21:34.838]                         computeRestarts <- base::computeRestarts
[13:21:34.838]                         grepl <- base::grepl
[13:21:34.838]                         restarts <- computeRestarts(cond)
[13:21:34.838]                         for (restart in restarts) {
[13:21:34.838]                           name <- restart$name
[13:21:34.838]                           if (is.null(name)) 
[13:21:34.838]                             next
[13:21:34.838]                           if (!grepl(pattern, name)) 
[13:21:34.838]                             next
[13:21:34.838]                           invokeRestart(restart)
[13:21:34.838]                           muffled <- TRUE
[13:21:34.838]                           break
[13:21:34.838]                         }
[13:21:34.838]                       }
[13:21:34.838]                     }
[13:21:34.838]                     invisible(muffled)
[13:21:34.838]                   }
[13:21:34.838]                   muffleCondition(cond)
[13:21:34.838]                 })
[13:21:34.838]             }))
[13:21:34.838]             future::FutureResult(value = ...future.value$value, 
[13:21:34.838]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:34.838]                   ...future.rng), globalenv = if (FALSE) 
[13:21:34.838]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:34.838]                     ...future.globalenv.names))
[13:21:34.838]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:34.838]         }, condition = base::local({
[13:21:34.838]             c <- base::c
[13:21:34.838]             inherits <- base::inherits
[13:21:34.838]             invokeRestart <- base::invokeRestart
[13:21:34.838]             length <- base::length
[13:21:34.838]             list <- base::list
[13:21:34.838]             seq.int <- base::seq.int
[13:21:34.838]             signalCondition <- base::signalCondition
[13:21:34.838]             sys.calls <- base::sys.calls
[13:21:34.838]             `[[` <- base::`[[`
[13:21:34.838]             `+` <- base::`+`
[13:21:34.838]             `<<-` <- base::`<<-`
[13:21:34.838]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:34.838]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:34.838]                   3L)]
[13:21:34.838]             }
[13:21:34.838]             function(cond) {
[13:21:34.838]                 is_error <- inherits(cond, "error")
[13:21:34.838]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:34.838]                   NULL)
[13:21:34.838]                 if (is_error) {
[13:21:34.838]                   sessionInformation <- function() {
[13:21:34.838]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:34.838]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:34.838]                       search = base::search(), system = base::Sys.info())
[13:21:34.838]                   }
[13:21:34.838]                   ...future.conditions[[length(...future.conditions) + 
[13:21:34.838]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:34.838]                     cond$call), session = sessionInformation(), 
[13:21:34.838]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:34.838]                   signalCondition(cond)
[13:21:34.838]                 }
[13:21:34.838]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:34.838]                 "immediateCondition"))) {
[13:21:34.838]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:34.838]                   ...future.conditions[[length(...future.conditions) + 
[13:21:34.838]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:34.838]                   if (TRUE && !signal) {
[13:21:34.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.838]                     {
[13:21:34.838]                       inherits <- base::inherits
[13:21:34.838]                       invokeRestart <- base::invokeRestart
[13:21:34.838]                       is.null <- base::is.null
[13:21:34.838]                       muffled <- FALSE
[13:21:34.838]                       if (inherits(cond, "message")) {
[13:21:34.838]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:34.838]                         if (muffled) 
[13:21:34.838]                           invokeRestart("muffleMessage")
[13:21:34.838]                       }
[13:21:34.838]                       else if (inherits(cond, "warning")) {
[13:21:34.838]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:34.838]                         if (muffled) 
[13:21:34.838]                           invokeRestart("muffleWarning")
[13:21:34.838]                       }
[13:21:34.838]                       else if (inherits(cond, "condition")) {
[13:21:34.838]                         if (!is.null(pattern)) {
[13:21:34.838]                           computeRestarts <- base::computeRestarts
[13:21:34.838]                           grepl <- base::grepl
[13:21:34.838]                           restarts <- computeRestarts(cond)
[13:21:34.838]                           for (restart in restarts) {
[13:21:34.838]                             name <- restart$name
[13:21:34.838]                             if (is.null(name)) 
[13:21:34.838]                               next
[13:21:34.838]                             if (!grepl(pattern, name)) 
[13:21:34.838]                               next
[13:21:34.838]                             invokeRestart(restart)
[13:21:34.838]                             muffled <- TRUE
[13:21:34.838]                             break
[13:21:34.838]                           }
[13:21:34.838]                         }
[13:21:34.838]                       }
[13:21:34.838]                       invisible(muffled)
[13:21:34.838]                     }
[13:21:34.838]                     muffleCondition(cond, pattern = "^muffle")
[13:21:34.838]                   }
[13:21:34.838]                 }
[13:21:34.838]                 else {
[13:21:34.838]                   if (TRUE) {
[13:21:34.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.838]                     {
[13:21:34.838]                       inherits <- base::inherits
[13:21:34.838]                       invokeRestart <- base::invokeRestart
[13:21:34.838]                       is.null <- base::is.null
[13:21:34.838]                       muffled <- FALSE
[13:21:34.838]                       if (inherits(cond, "message")) {
[13:21:34.838]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:34.838]                         if (muffled) 
[13:21:34.838]                           invokeRestart("muffleMessage")
[13:21:34.838]                       }
[13:21:34.838]                       else if (inherits(cond, "warning")) {
[13:21:34.838]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:34.838]                         if (muffled) 
[13:21:34.838]                           invokeRestart("muffleWarning")
[13:21:34.838]                       }
[13:21:34.838]                       else if (inherits(cond, "condition")) {
[13:21:34.838]                         if (!is.null(pattern)) {
[13:21:34.838]                           computeRestarts <- base::computeRestarts
[13:21:34.838]                           grepl <- base::grepl
[13:21:34.838]                           restarts <- computeRestarts(cond)
[13:21:34.838]                           for (restart in restarts) {
[13:21:34.838]                             name <- restart$name
[13:21:34.838]                             if (is.null(name)) 
[13:21:34.838]                               next
[13:21:34.838]                             if (!grepl(pattern, name)) 
[13:21:34.838]                               next
[13:21:34.838]                             invokeRestart(restart)
[13:21:34.838]                             muffled <- TRUE
[13:21:34.838]                             break
[13:21:34.838]                           }
[13:21:34.838]                         }
[13:21:34.838]                       }
[13:21:34.838]                       invisible(muffled)
[13:21:34.838]                     }
[13:21:34.838]                     muffleCondition(cond, pattern = "^muffle")
[13:21:34.838]                   }
[13:21:34.838]                 }
[13:21:34.838]             }
[13:21:34.838]         }))
[13:21:34.838]     }, error = function(ex) {
[13:21:34.838]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:34.838]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:34.838]                 ...future.rng), started = ...future.startTime, 
[13:21:34.838]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:34.838]             version = "1.8"), class = "FutureResult")
[13:21:34.838]     }, finally = {
[13:21:34.838]         if (!identical(...future.workdir, getwd())) 
[13:21:34.838]             setwd(...future.workdir)
[13:21:34.838]         {
[13:21:34.838]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:34.838]                 ...future.oldOptions$nwarnings <- NULL
[13:21:34.838]             }
[13:21:34.838]             base::options(...future.oldOptions)
[13:21:34.838]             if (.Platform$OS.type == "windows") {
[13:21:34.838]                 old_names <- names(...future.oldEnvVars)
[13:21:34.838]                 envs <- base::Sys.getenv()
[13:21:34.838]                 names <- names(envs)
[13:21:34.838]                 common <- intersect(names, old_names)
[13:21:34.838]                 added <- setdiff(names, old_names)
[13:21:34.838]                 removed <- setdiff(old_names, names)
[13:21:34.838]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:34.838]                   envs[common]]
[13:21:34.838]                 NAMES <- toupper(changed)
[13:21:34.838]                 args <- list()
[13:21:34.838]                 for (kk in seq_along(NAMES)) {
[13:21:34.838]                   name <- changed[[kk]]
[13:21:34.838]                   NAME <- NAMES[[kk]]
[13:21:34.838]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.838]                     next
[13:21:34.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:34.838]                 }
[13:21:34.838]                 NAMES <- toupper(added)
[13:21:34.838]                 for (kk in seq_along(NAMES)) {
[13:21:34.838]                   name <- added[[kk]]
[13:21:34.838]                   NAME <- NAMES[[kk]]
[13:21:34.838]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.838]                     next
[13:21:34.838]                   args[[name]] <- ""
[13:21:34.838]                 }
[13:21:34.838]                 NAMES <- toupper(removed)
[13:21:34.838]                 for (kk in seq_along(NAMES)) {
[13:21:34.838]                   name <- removed[[kk]]
[13:21:34.838]                   NAME <- NAMES[[kk]]
[13:21:34.838]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.838]                     next
[13:21:34.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:34.838]                 }
[13:21:34.838]                 if (length(args) > 0) 
[13:21:34.838]                   base::do.call(base::Sys.setenv, args = args)
[13:21:34.838]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:34.838]             }
[13:21:34.838]             else {
[13:21:34.838]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:34.838]             }
[13:21:34.838]             {
[13:21:34.838]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:34.838]                   0L) {
[13:21:34.838]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:34.838]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:34.838]                   base::options(opts)
[13:21:34.838]                 }
[13:21:34.838]                 {
[13:21:34.838]                   {
[13:21:34.838]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:34.838]                     NULL
[13:21:34.838]                   }
[13:21:34.838]                   options(future.plan = NULL)
[13:21:34.838]                   if (is.na(NA_character_)) 
[13:21:34.838]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:34.838]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:34.838]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:34.838]                     envir = parent.frame()) 
[13:21:34.838]                   {
[13:21:34.838]                     default_workers <- missing(workers)
[13:21:34.838]                     if (is.function(workers)) 
[13:21:34.838]                       workers <- workers()
[13:21:34.838]                     workers <- structure(as.integer(workers), 
[13:21:34.838]                       class = class(workers))
[13:21:34.838]                     stop_if_not(is.finite(workers), workers >= 
[13:21:34.838]                       1L)
[13:21:34.838]                     if ((workers == 1L && !inherits(workers, 
[13:21:34.838]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:34.838]                       if (default_workers) 
[13:21:34.838]                         supportsMulticore(warn = TRUE)
[13:21:34.838]                       return(sequential(..., envir = envir))
[13:21:34.838]                     }
[13:21:34.838]                     oopts <- options(mc.cores = workers)
[13:21:34.838]                     on.exit(options(oopts))
[13:21:34.838]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:34.838]                       envir = envir)
[13:21:34.838]                     if (!future$lazy) 
[13:21:34.838]                       future <- run(future)
[13:21:34.838]                     invisible(future)
[13:21:34.838]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:34.838]                 }
[13:21:34.838]             }
[13:21:34.838]         }
[13:21:34.838]     })
[13:21:34.838]     if (TRUE) {
[13:21:34.838]         base::sink(type = "output", split = FALSE)
[13:21:34.838]         if (TRUE) {
[13:21:34.838]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:34.838]         }
[13:21:34.838]         else {
[13:21:34.838]             ...future.result["stdout"] <- base::list(NULL)
[13:21:34.838]         }
[13:21:34.838]         base::close(...future.stdout)
[13:21:34.838]         ...future.stdout <- NULL
[13:21:34.838]     }
[13:21:34.838]     ...future.result$conditions <- ...future.conditions
[13:21:34.838]     ...future.result$finished <- base::Sys.time()
[13:21:34.838]     ...future.result
[13:21:34.838] }
[13:21:34.841] assign_globals() ...
[13:21:34.841] List of 11
[13:21:34.841]  $ ...future.FUN            :function (x, ...)  
[13:21:34.841]  $ x_FUN                    :function (x, na.rm = TRUE)  
[13:21:34.841]  $ times                    : int 5
[13:21:34.841]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:34.841]  $ stop_if_not              :function (...)  
[13:21:34.841]  $ dim                      : NULL
[13:21:34.841]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:21:34.841]  $ future.call.arguments    : list()
[13:21:34.841]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:34.841]  $ ...future.elements_ii    :List of 3
[13:21:34.841]   ..$ : int [1:7] 1 2 3 4 5 6 7
[13:21:34.841]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[13:21:34.841]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[13:21:34.841]  $ ...future.seeds_ii       : NULL
[13:21:34.841]  $ ...future.globals.maxSize: NULL
[13:21:34.841]  - attr(*, "where")=List of 11
[13:21:34.841]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:34.841]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:34.841]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:34.841]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:34.841]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:34.841]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:34.841]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:34.841]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:34.841]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:34.841]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:34.841]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:34.841]  - attr(*, "resolved")= logi FALSE
[13:21:34.841]  - attr(*, "total_size")= num 141240
[13:21:34.841]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:34.841]  - attr(*, "already-done")= logi TRUE
[13:21:34.852] - copied ‘...future.FUN’ to environment
[13:21:34.852] - copied ‘x_FUN’ to environment
[13:21:34.852] - copied ‘times’ to environment
[13:21:34.852] - copied ‘stopf’ to environment
[13:21:34.853] - copied ‘stop_if_not’ to environment
[13:21:34.853] - copied ‘dim’ to environment
[13:21:34.853] - copied ‘valid_types’ to environment
[13:21:34.853] - copied ‘future.call.arguments’ to environment
[13:21:34.853] - copied ‘...future.elements_ii’ to environment
[13:21:34.853] - copied ‘...future.seeds_ii’ to environment
[13:21:34.853] - copied ‘...future.globals.maxSize’ to environment
[13:21:34.853] assign_globals() ... done
[13:21:34.853] requestCore(): workers = 2
[13:21:34.856] MulticoreFuture started
[13:21:34.856] - Launch lazy future ... done
[13:21:34.857] run() for ‘MulticoreFuture’ ... done
[13:21:34.857] Created future:
[13:21:34.858] plan(): Setting new future strategy stack:
[13:21:34.858] List of future strategies:
[13:21:34.858] 1. sequential:
[13:21:34.858]    - args: function (..., envir = parent.frame())
[13:21:34.858]    - tweaked: FALSE
[13:21:34.858]    - call: NULL
[13:21:34.859] plan(): nbrOfWorkers() = 1
[13:21:34.869] plan(): Setting new future strategy stack:
[13:21:34.869] List of future strategies:
[13:21:34.869] 1. multicore:
[13:21:34.869]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:34.869]    - tweaked: FALSE
[13:21:34.869]    - call: plan(strategy)
[13:21:34.875] plan(): nbrOfWorkers() = 2
[13:21:34.857] MulticoreFuture:
[13:21:34.857] Label: ‘future_vapply-2’
[13:21:34.857] Expression:
[13:21:34.857] {
[13:21:34.857]     do.call(function(...) {
[13:21:34.857]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.857]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:34.857]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.857]             on.exit(options(oopts), add = TRUE)
[13:21:34.857]         }
[13:21:34.857]         {
[13:21:34.857]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:34.857]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.857]                 ...future.FUN(...future.X_jj, ...)
[13:21:34.857]             })
[13:21:34.857]         }
[13:21:34.857]     }, args = future.call.arguments)
[13:21:34.857] }
[13:21:34.857] Lazy evaluation: FALSE
[13:21:34.857] Asynchronous evaluation: TRUE
[13:21:34.857] Local evaluation: TRUE
[13:21:34.857] Environment: R_GlobalEnv
[13:21:34.857] Capture standard output: TRUE
[13:21:34.857] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:34.857] Globals: 11 objects totaling 138.18 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:34.857] Packages: 2 packages (‘stats’, ‘future.apply’)
[13:21:34.857] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:34.857] Resolved: TRUE
[13:21:34.857] Value: <not collected>
[13:21:34.857] Conditions captured: <none>
[13:21:34.857] Early signaling: FALSE
[13:21:34.857] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:34.857] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:34.876] Chunk #2 of 2 ... DONE
[13:21:34.876] Launching 2 futures (chunks) ... DONE
[13:21:34.876] Resolving 2 futures (chunks) ...
[13:21:34.877] resolve() on list ...
[13:21:34.877]  recursive: 0
[13:21:34.877]  length: 2
[13:21:34.877] 
[13:21:34.877] Future #1
[13:21:34.878] result() for MulticoreFuture ...
[13:21:34.879] result() for MulticoreFuture ...
[13:21:34.879] result() for MulticoreFuture ... done
[13:21:34.879] result() for MulticoreFuture ... done
[13:21:34.879] result() for MulticoreFuture ...
[13:21:34.879] result() for MulticoreFuture ... done
[13:21:34.880] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:21:34.880] - nx: 2
[13:21:34.880] - relay: TRUE
[13:21:34.880] - stdout: TRUE
[13:21:34.881] - signal: TRUE
[13:21:34.881] - resignal: FALSE
[13:21:34.881] - force: TRUE
[13:21:34.881] - relayed: [n=2] FALSE, FALSE
[13:21:34.881] - queued futures: [n=2] FALSE, FALSE
[13:21:34.882]  - until=1
[13:21:34.882]  - relaying element #1
[13:21:34.882] result() for MulticoreFuture ...
[13:21:34.882] result() for MulticoreFuture ... done
[13:21:34.882] result() for MulticoreFuture ...
[13:21:34.883] result() for MulticoreFuture ... done
[13:21:34.883] result() for MulticoreFuture ...
[13:21:34.883] result() for MulticoreFuture ... done
[13:21:34.883] result() for MulticoreFuture ...
[13:21:34.884] result() for MulticoreFuture ... done
[13:21:34.884] - relayed: [n=2] TRUE, FALSE
[13:21:34.884] - queued futures: [n=2] TRUE, FALSE
[13:21:34.884] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:21:34.885]  length: 1 (resolved future 1)
[13:21:34.885] Future #2
[13:21:34.885] result() for MulticoreFuture ...
[13:21:34.886] result() for MulticoreFuture ...
[13:21:34.886] result() for MulticoreFuture ... done
[13:21:34.887] result() for MulticoreFuture ... done
[13:21:34.887] result() for MulticoreFuture ...
[13:21:34.887] result() for MulticoreFuture ... done
[13:21:34.887] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:21:34.887] - nx: 2
[13:21:34.888] - relay: TRUE
[13:21:34.888] - stdout: TRUE
[13:21:34.888] - signal: TRUE
[13:21:34.888] - resignal: FALSE
[13:21:34.888] - force: TRUE
[13:21:34.888] - relayed: [n=2] TRUE, FALSE
[13:21:34.888] - queued futures: [n=2] TRUE, FALSE
[13:21:34.888]  - until=2
[13:21:34.889]  - relaying element #2
[13:21:34.889] result() for MulticoreFuture ...
[13:21:34.889] result() for MulticoreFuture ... done
[13:21:34.889] result() for MulticoreFuture ...
[13:21:34.889] result() for MulticoreFuture ... done
[13:21:34.889] result() for MulticoreFuture ...
[13:21:34.889] result() for MulticoreFuture ... done
[13:21:34.890] result() for MulticoreFuture ...
[13:21:34.890] result() for MulticoreFuture ... done
[13:21:34.890] - relayed: [n=2] TRUE, TRUE
[13:21:34.890] - queued futures: [n=2] TRUE, TRUE
[13:21:34.890] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:21:34.890]  length: 0 (resolved future 2)
[13:21:34.890] Relaying remaining futures
[13:21:34.890] signalConditionsASAP(NULL, pos=0) ...
[13:21:34.890] - nx: 2
[13:21:34.891] - relay: TRUE
[13:21:34.891] - stdout: TRUE
[13:21:34.891] - signal: TRUE
[13:21:34.891] - resignal: FALSE
[13:21:34.891] - force: TRUE
[13:21:34.891] - relayed: [n=2] TRUE, TRUE
[13:21:34.891] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:21:34.891] - relayed: [n=2] TRUE, TRUE
[13:21:34.891] - queued futures: [n=2] TRUE, TRUE
[13:21:34.892] signalConditionsASAP(NULL, pos=0) ... done
[13:21:34.892] resolve() on list ... DONE
[13:21:34.892] result() for MulticoreFuture ...
[13:21:34.892] result() for MulticoreFuture ... done
[13:21:34.892] result() for MulticoreFuture ...
[13:21:34.892] result() for MulticoreFuture ... done
[13:21:34.892] result() for MulticoreFuture ...
[13:21:34.892] result() for MulticoreFuture ... done
[13:21:34.892] result() for MulticoreFuture ...
[13:21:34.893] result() for MulticoreFuture ... done
[13:21:34.893]  - Number of value chunks collected: 2
[13:21:34.893] Resolving 2 futures (chunks) ... DONE
[13:21:34.893] Reducing values from 2 chunks ...
[13:21:34.893]  - Number of values collected after concatenation: 7
[13:21:34.893]  - Number of values expected: 7
[13:21:34.893] Reducing values from 2 chunks ... DONE
[13:21:34.893] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[13:21:34.895] future_lapply() ...
[13:21:34.900] Number of chunks: 2
[13:21:34.900] getGlobalsAndPackagesXApply() ...
[13:21:34.900]  - future.globals: TRUE
[13:21:34.900] getGlobalsAndPackages() ...
[13:21:34.901] Searching for globals...
[13:21:34.902] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[13:21:34.902] Searching for globals ... DONE
[13:21:34.902] Resolving globals: FALSE
[13:21:34.903] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[13:21:34.903] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[13:21:34.903] - globals: [1] ‘FUN’
[13:21:34.903] 
[13:21:34.903] getGlobalsAndPackages() ... DONE
[13:21:34.903]  - globals found/used: [n=1] ‘FUN’
[13:21:34.904]  - needed namespaces: [n=0] 
[13:21:34.904] Finding globals ... DONE
[13:21:34.904]  - use_args: TRUE
[13:21:34.904]  - Getting '...' globals ...
[13:21:34.904] resolve() on list ...
[13:21:34.904]  recursive: 0
[13:21:34.904]  length: 1
[13:21:34.904]  elements: ‘...’
[13:21:34.905]  length: 0 (resolved future 1)
[13:21:34.905] resolve() on list ... DONE
[13:21:34.905]    - '...' content: [n=1] ‘y’
[13:21:34.905] List of 1
[13:21:34.905]  $ ...:List of 1
[13:21:34.905]   ..$ y: num [1:5] 2 4 6 8 10
[13:21:34.905]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:34.905]  - attr(*, "where")=List of 1
[13:21:34.905]   ..$ ...:<environment: 0x563b6d8d0be0> 
[13:21:34.905]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:34.905]  - attr(*, "resolved")= logi TRUE
[13:21:34.905]  - attr(*, "total_size")= num NA
[13:21:34.911]  - Getting '...' globals ... DONE
[13:21:34.911] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:21:34.911] List of 2
[13:21:34.911]  $ ...future.FUN:function (x, y)  
[13:21:34.911]  $ ...          :List of 1
[13:21:34.911]   ..$ y: num [1:5] 2 4 6 8 10
[13:21:34.911]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:34.911]  - attr(*, "where")=List of 2
[13:21:34.911]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:34.911]   ..$ ...          :<environment: 0x563b6d8d0be0> 
[13:21:34.911]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:34.911]  - attr(*, "resolved")= logi FALSE
[13:21:34.911]  - attr(*, "total_size")= num 4264
[13:21:34.915] Packages to be attached in all futures: [n=0] 
[13:21:34.915] getGlobalsAndPackagesXApply() ... DONE
[13:21:34.915] Number of futures (= number of chunks): 2
[13:21:34.915] Launching 2 futures (chunks) ...
[13:21:34.915] Chunk #1 of 2 ...
[13:21:34.916]  - Finding globals in 'X' for chunk #1 ...
[13:21:34.916] getGlobalsAndPackages() ...
[13:21:34.916] Searching for globals...
[13:21:34.916] 
[13:21:34.916] Searching for globals ... DONE
[13:21:34.916] - globals: [0] <none>
[13:21:34.916] getGlobalsAndPackages() ... DONE
[13:21:34.917]    + additional globals found: [n=0] 
[13:21:34.917]    + additional namespaces needed: [n=0] 
[13:21:34.917]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:34.917]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:34.917]  - seeds: <none>
[13:21:34.917]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.917] getGlobalsAndPackages() ...
[13:21:34.917] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.917] Resolving globals: FALSE
[13:21:34.917] Tweak future expression to call with '...' arguments ...
[13:21:34.918] {
[13:21:34.918]     do.call(function(...) {
[13:21:34.918]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.918]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:34.918]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.918]             on.exit(options(oopts), add = TRUE)
[13:21:34.918]         }
[13:21:34.918]         {
[13:21:34.918]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:34.918]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.918]                 ...future.FUN(...future.X_jj, ...)
[13:21:34.918]             })
[13:21:34.918]         }
[13:21:34.918]     }, args = future.call.arguments)
[13:21:34.918] }
[13:21:34.918] Tweak future expression to call with '...' arguments ... DONE
[13:21:34.918] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.918] 
[13:21:34.918] getGlobalsAndPackages() ... DONE
[13:21:34.919] run() for ‘Future’ ...
[13:21:34.919] - state: ‘created’
[13:21:34.919] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:34.923] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:34.923] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:34.923]   - Field: ‘label’
[13:21:34.923]   - Field: ‘local’
[13:21:34.923]   - Field: ‘owner’
[13:21:34.923]   - Field: ‘envir’
[13:21:34.923]   - Field: ‘workers’
[13:21:34.924]   - Field: ‘packages’
[13:21:34.924]   - Field: ‘gc’
[13:21:34.924]   - Field: ‘job’
[13:21:34.924]   - Field: ‘conditions’
[13:21:34.924]   - Field: ‘expr’
[13:21:34.924]   - Field: ‘uuid’
[13:21:34.924]   - Field: ‘seed’
[13:21:34.924]   - Field: ‘version’
[13:21:34.924]   - Field: ‘result’
[13:21:34.924]   - Field: ‘asynchronous’
[13:21:34.925]   - Field: ‘calls’
[13:21:34.925]   - Field: ‘globals’
[13:21:34.925]   - Field: ‘stdout’
[13:21:34.925]   - Field: ‘earlySignal’
[13:21:34.925]   - Field: ‘lazy’
[13:21:34.925]   - Field: ‘state’
[13:21:34.925] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:34.925] - Launch lazy future ...
[13:21:34.925] Packages needed by the future expression (n = 0): <none>
[13:21:34.926] Packages needed by future strategies (n = 0): <none>
[13:21:34.926] {
[13:21:34.926]     {
[13:21:34.926]         {
[13:21:34.926]             ...future.startTime <- base::Sys.time()
[13:21:34.926]             {
[13:21:34.926]                 {
[13:21:34.926]                   {
[13:21:34.926]                     {
[13:21:34.926]                       base::local({
[13:21:34.926]                         has_future <- base::requireNamespace("future", 
[13:21:34.926]                           quietly = TRUE)
[13:21:34.926]                         if (has_future) {
[13:21:34.926]                           ns <- base::getNamespace("future")
[13:21:34.926]                           version <- ns[[".package"]][["version"]]
[13:21:34.926]                           if (is.null(version)) 
[13:21:34.926]                             version <- utils::packageVersion("future")
[13:21:34.926]                         }
[13:21:34.926]                         else {
[13:21:34.926]                           version <- NULL
[13:21:34.926]                         }
[13:21:34.926]                         if (!has_future || version < "1.8.0") {
[13:21:34.926]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:34.926]                             "", base::R.version$version.string), 
[13:21:34.926]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:34.926]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:34.926]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:34.926]                               "release", "version")], collapse = " "), 
[13:21:34.926]                             hostname = base::Sys.info()[["nodename"]])
[13:21:34.926]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:34.926]                             info)
[13:21:34.926]                           info <- base::paste(info, collapse = "; ")
[13:21:34.926]                           if (!has_future) {
[13:21:34.926]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:34.926]                               info)
[13:21:34.926]                           }
[13:21:34.926]                           else {
[13:21:34.926]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:34.926]                               info, version)
[13:21:34.926]                           }
[13:21:34.926]                           base::stop(msg)
[13:21:34.926]                         }
[13:21:34.926]                       })
[13:21:34.926]                     }
[13:21:34.926]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:34.926]                     base::options(mc.cores = 1L)
[13:21:34.926]                   }
[13:21:34.926]                   options(future.plan = NULL)
[13:21:34.926]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:34.926]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:34.926]                 }
[13:21:34.926]                 ...future.workdir <- getwd()
[13:21:34.926]             }
[13:21:34.926]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:34.926]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:34.926]         }
[13:21:34.926]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:34.926]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:34.926]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:34.926]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:34.926]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:34.926]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:34.926]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:34.926]             base::names(...future.oldOptions))
[13:21:34.926]     }
[13:21:34.926]     if (FALSE) {
[13:21:34.926]     }
[13:21:34.926]     else {
[13:21:34.926]         if (TRUE) {
[13:21:34.926]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:34.926]                 open = "w")
[13:21:34.926]         }
[13:21:34.926]         else {
[13:21:34.926]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:34.926]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:34.926]         }
[13:21:34.926]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:34.926]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:34.926]             base::sink(type = "output", split = FALSE)
[13:21:34.926]             base::close(...future.stdout)
[13:21:34.926]         }, add = TRUE)
[13:21:34.926]     }
[13:21:34.926]     ...future.frame <- base::sys.nframe()
[13:21:34.926]     ...future.conditions <- base::list()
[13:21:34.926]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:34.926]     if (FALSE) {
[13:21:34.926]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:34.926]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:34.926]     }
[13:21:34.926]     ...future.result <- base::tryCatch({
[13:21:34.926]         base::withCallingHandlers({
[13:21:34.926]             ...future.value <- base::withVisible(base::local({
[13:21:34.926]                 withCallingHandlers({
[13:21:34.926]                   {
[13:21:34.926]                     do.call(function(...) {
[13:21:34.926]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.926]                       if (!identical(...future.globals.maxSize.org, 
[13:21:34.926]                         ...future.globals.maxSize)) {
[13:21:34.926]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.926]                         on.exit(options(oopts), add = TRUE)
[13:21:34.926]                       }
[13:21:34.926]                       {
[13:21:34.926]                         lapply(seq_along(...future.elements_ii), 
[13:21:34.926]                           FUN = function(jj) {
[13:21:34.926]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.926]                             ...future.FUN(...future.X_jj, ...)
[13:21:34.926]                           })
[13:21:34.926]                       }
[13:21:34.926]                     }, args = future.call.arguments)
[13:21:34.926]                   }
[13:21:34.926]                 }, immediateCondition = function(cond) {
[13:21:34.926]                   save_rds <- function (object, pathname, ...) 
[13:21:34.926]                   {
[13:21:34.926]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:34.926]                     if (file_test("-f", pathname_tmp)) {
[13:21:34.926]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.926]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:34.926]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.926]                         fi_tmp[["mtime"]])
[13:21:34.926]                     }
[13:21:34.926]                     tryCatch({
[13:21:34.926]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:34.926]                     }, error = function(ex) {
[13:21:34.926]                       msg <- conditionMessage(ex)
[13:21:34.926]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.926]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:34.926]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.926]                         fi_tmp[["mtime"]], msg)
[13:21:34.926]                       ex$message <- msg
[13:21:34.926]                       stop(ex)
[13:21:34.926]                     })
[13:21:34.926]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:34.926]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:34.926]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:34.926]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.926]                       fi <- file.info(pathname)
[13:21:34.926]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:34.926]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.926]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:34.926]                         fi[["size"]], fi[["mtime"]])
[13:21:34.926]                       stop(msg)
[13:21:34.926]                     }
[13:21:34.926]                     invisible(pathname)
[13:21:34.926]                   }
[13:21:34.926]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:34.926]                     rootPath = tempdir()) 
[13:21:34.926]                   {
[13:21:34.926]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:34.926]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:34.926]                       tmpdir = path, fileext = ".rds")
[13:21:34.926]                     save_rds(obj, file)
[13:21:34.926]                   }
[13:21:34.926]                   saveImmediateCondition(cond, path = "/tmp/RtmpbpFWGO/.future/immediateConditions")
[13:21:34.926]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.926]                   {
[13:21:34.926]                     inherits <- base::inherits
[13:21:34.926]                     invokeRestart <- base::invokeRestart
[13:21:34.926]                     is.null <- base::is.null
[13:21:34.926]                     muffled <- FALSE
[13:21:34.926]                     if (inherits(cond, "message")) {
[13:21:34.926]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:34.926]                       if (muffled) 
[13:21:34.926]                         invokeRestart("muffleMessage")
[13:21:34.926]                     }
[13:21:34.926]                     else if (inherits(cond, "warning")) {
[13:21:34.926]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:34.926]                       if (muffled) 
[13:21:34.926]                         invokeRestart("muffleWarning")
[13:21:34.926]                     }
[13:21:34.926]                     else if (inherits(cond, "condition")) {
[13:21:34.926]                       if (!is.null(pattern)) {
[13:21:34.926]                         computeRestarts <- base::computeRestarts
[13:21:34.926]                         grepl <- base::grepl
[13:21:34.926]                         restarts <- computeRestarts(cond)
[13:21:34.926]                         for (restart in restarts) {
[13:21:34.926]                           name <- restart$name
[13:21:34.926]                           if (is.null(name)) 
[13:21:34.926]                             next
[13:21:34.926]                           if (!grepl(pattern, name)) 
[13:21:34.926]                             next
[13:21:34.926]                           invokeRestart(restart)
[13:21:34.926]                           muffled <- TRUE
[13:21:34.926]                           break
[13:21:34.926]                         }
[13:21:34.926]                       }
[13:21:34.926]                     }
[13:21:34.926]                     invisible(muffled)
[13:21:34.926]                   }
[13:21:34.926]                   muffleCondition(cond)
[13:21:34.926]                 })
[13:21:34.926]             }))
[13:21:34.926]             future::FutureResult(value = ...future.value$value, 
[13:21:34.926]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:34.926]                   ...future.rng), globalenv = if (FALSE) 
[13:21:34.926]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:34.926]                     ...future.globalenv.names))
[13:21:34.926]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:34.926]         }, condition = base::local({
[13:21:34.926]             c <- base::c
[13:21:34.926]             inherits <- base::inherits
[13:21:34.926]             invokeRestart <- base::invokeRestart
[13:21:34.926]             length <- base::length
[13:21:34.926]             list <- base::list
[13:21:34.926]             seq.int <- base::seq.int
[13:21:34.926]             signalCondition <- base::signalCondition
[13:21:34.926]             sys.calls <- base::sys.calls
[13:21:34.926]             `[[` <- base::`[[`
[13:21:34.926]             `+` <- base::`+`
[13:21:34.926]             `<<-` <- base::`<<-`
[13:21:34.926]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:34.926]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:34.926]                   3L)]
[13:21:34.926]             }
[13:21:34.926]             function(cond) {
[13:21:34.926]                 is_error <- inherits(cond, "error")
[13:21:34.926]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:34.926]                   NULL)
[13:21:34.926]                 if (is_error) {
[13:21:34.926]                   sessionInformation <- function() {
[13:21:34.926]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:34.926]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:34.926]                       search = base::search(), system = base::Sys.info())
[13:21:34.926]                   }
[13:21:34.926]                   ...future.conditions[[length(...future.conditions) + 
[13:21:34.926]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:34.926]                     cond$call), session = sessionInformation(), 
[13:21:34.926]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:34.926]                   signalCondition(cond)
[13:21:34.926]                 }
[13:21:34.926]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:34.926]                 "immediateCondition"))) {
[13:21:34.926]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:34.926]                   ...future.conditions[[length(...future.conditions) + 
[13:21:34.926]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:34.926]                   if (TRUE && !signal) {
[13:21:34.926]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.926]                     {
[13:21:34.926]                       inherits <- base::inherits
[13:21:34.926]                       invokeRestart <- base::invokeRestart
[13:21:34.926]                       is.null <- base::is.null
[13:21:34.926]                       muffled <- FALSE
[13:21:34.926]                       if (inherits(cond, "message")) {
[13:21:34.926]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:34.926]                         if (muffled) 
[13:21:34.926]                           invokeRestart("muffleMessage")
[13:21:34.926]                       }
[13:21:34.926]                       else if (inherits(cond, "warning")) {
[13:21:34.926]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:34.926]                         if (muffled) 
[13:21:34.926]                           invokeRestart("muffleWarning")
[13:21:34.926]                       }
[13:21:34.926]                       else if (inherits(cond, "condition")) {
[13:21:34.926]                         if (!is.null(pattern)) {
[13:21:34.926]                           computeRestarts <- base::computeRestarts
[13:21:34.926]                           grepl <- base::grepl
[13:21:34.926]                           restarts <- computeRestarts(cond)
[13:21:34.926]                           for (restart in restarts) {
[13:21:34.926]                             name <- restart$name
[13:21:34.926]                             if (is.null(name)) 
[13:21:34.926]                               next
[13:21:34.926]                             if (!grepl(pattern, name)) 
[13:21:34.926]                               next
[13:21:34.926]                             invokeRestart(restart)
[13:21:34.926]                             muffled <- TRUE
[13:21:34.926]                             break
[13:21:34.926]                           }
[13:21:34.926]                         }
[13:21:34.926]                       }
[13:21:34.926]                       invisible(muffled)
[13:21:34.926]                     }
[13:21:34.926]                     muffleCondition(cond, pattern = "^muffle")
[13:21:34.926]                   }
[13:21:34.926]                 }
[13:21:34.926]                 else {
[13:21:34.926]                   if (TRUE) {
[13:21:34.926]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.926]                     {
[13:21:34.926]                       inherits <- base::inherits
[13:21:34.926]                       invokeRestart <- base::invokeRestart
[13:21:34.926]                       is.null <- base::is.null
[13:21:34.926]                       muffled <- FALSE
[13:21:34.926]                       if (inherits(cond, "message")) {
[13:21:34.926]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:34.926]                         if (muffled) 
[13:21:34.926]                           invokeRestart("muffleMessage")
[13:21:34.926]                       }
[13:21:34.926]                       else if (inherits(cond, "warning")) {
[13:21:34.926]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:34.926]                         if (muffled) 
[13:21:34.926]                           invokeRestart("muffleWarning")
[13:21:34.926]                       }
[13:21:34.926]                       else if (inherits(cond, "condition")) {
[13:21:34.926]                         if (!is.null(pattern)) {
[13:21:34.926]                           computeRestarts <- base::computeRestarts
[13:21:34.926]                           grepl <- base::grepl
[13:21:34.926]                           restarts <- computeRestarts(cond)
[13:21:34.926]                           for (restart in restarts) {
[13:21:34.926]                             name <- restart$name
[13:21:34.926]                             if (is.null(name)) 
[13:21:34.926]                               next
[13:21:34.926]                             if (!grepl(pattern, name)) 
[13:21:34.926]                               next
[13:21:34.926]                             invokeRestart(restart)
[13:21:34.926]                             muffled <- TRUE
[13:21:34.926]                             break
[13:21:34.926]                           }
[13:21:34.926]                         }
[13:21:34.926]                       }
[13:21:34.926]                       invisible(muffled)
[13:21:34.926]                     }
[13:21:34.926]                     muffleCondition(cond, pattern = "^muffle")
[13:21:34.926]                   }
[13:21:34.926]                 }
[13:21:34.926]             }
[13:21:34.926]         }))
[13:21:34.926]     }, error = function(ex) {
[13:21:34.926]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:34.926]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:34.926]                 ...future.rng), started = ...future.startTime, 
[13:21:34.926]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:34.926]             version = "1.8"), class = "FutureResult")
[13:21:34.926]     }, finally = {
[13:21:34.926]         if (!identical(...future.workdir, getwd())) 
[13:21:34.926]             setwd(...future.workdir)
[13:21:34.926]         {
[13:21:34.926]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:34.926]                 ...future.oldOptions$nwarnings <- NULL
[13:21:34.926]             }
[13:21:34.926]             base::options(...future.oldOptions)
[13:21:34.926]             if (.Platform$OS.type == "windows") {
[13:21:34.926]                 old_names <- names(...future.oldEnvVars)
[13:21:34.926]                 envs <- base::Sys.getenv()
[13:21:34.926]                 names <- names(envs)
[13:21:34.926]                 common <- intersect(names, old_names)
[13:21:34.926]                 added <- setdiff(names, old_names)
[13:21:34.926]                 removed <- setdiff(old_names, names)
[13:21:34.926]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:34.926]                   envs[common]]
[13:21:34.926]                 NAMES <- toupper(changed)
[13:21:34.926]                 args <- list()
[13:21:34.926]                 for (kk in seq_along(NAMES)) {
[13:21:34.926]                   name <- changed[[kk]]
[13:21:34.926]                   NAME <- NAMES[[kk]]
[13:21:34.926]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.926]                     next
[13:21:34.926]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:34.926]                 }
[13:21:34.926]                 NAMES <- toupper(added)
[13:21:34.926]                 for (kk in seq_along(NAMES)) {
[13:21:34.926]                   name <- added[[kk]]
[13:21:34.926]                   NAME <- NAMES[[kk]]
[13:21:34.926]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.926]                     next
[13:21:34.926]                   args[[name]] <- ""
[13:21:34.926]                 }
[13:21:34.926]                 NAMES <- toupper(removed)
[13:21:34.926]                 for (kk in seq_along(NAMES)) {
[13:21:34.926]                   name <- removed[[kk]]
[13:21:34.926]                   NAME <- NAMES[[kk]]
[13:21:34.926]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.926]                     next
[13:21:34.926]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:34.926]                 }
[13:21:34.926]                 if (length(args) > 0) 
[13:21:34.926]                   base::do.call(base::Sys.setenv, args = args)
[13:21:34.926]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:34.926]             }
[13:21:34.926]             else {
[13:21:34.926]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:34.926]             }
[13:21:34.926]             {
[13:21:34.926]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:34.926]                   0L) {
[13:21:34.926]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:34.926]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:34.926]                   base::options(opts)
[13:21:34.926]                 }
[13:21:34.926]                 {
[13:21:34.926]                   {
[13:21:34.926]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:34.926]                     NULL
[13:21:34.926]                   }
[13:21:34.926]                   options(future.plan = NULL)
[13:21:34.926]                   if (is.na(NA_character_)) 
[13:21:34.926]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:34.926]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:34.926]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:34.926]                     envir = parent.frame()) 
[13:21:34.926]                   {
[13:21:34.926]                     default_workers <- missing(workers)
[13:21:34.926]                     if (is.function(workers)) 
[13:21:34.926]                       workers <- workers()
[13:21:34.926]                     workers <- structure(as.integer(workers), 
[13:21:34.926]                       class = class(workers))
[13:21:34.926]                     stop_if_not(is.finite(workers), workers >= 
[13:21:34.926]                       1L)
[13:21:34.926]                     if ((workers == 1L && !inherits(workers, 
[13:21:34.926]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:34.926]                       if (default_workers) 
[13:21:34.926]                         supportsMulticore(warn = TRUE)
[13:21:34.926]                       return(sequential(..., envir = envir))
[13:21:34.926]                     }
[13:21:34.926]                     oopts <- options(mc.cores = workers)
[13:21:34.926]                     on.exit(options(oopts))
[13:21:34.926]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:34.926]                       envir = envir)
[13:21:34.926]                     if (!future$lazy) 
[13:21:34.926]                       future <- run(future)
[13:21:34.926]                     invisible(future)
[13:21:34.926]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:34.926]                 }
[13:21:34.926]             }
[13:21:34.926]         }
[13:21:34.926]     })
[13:21:34.926]     if (TRUE) {
[13:21:34.926]         base::sink(type = "output", split = FALSE)
[13:21:34.926]         if (TRUE) {
[13:21:34.926]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:34.926]         }
[13:21:34.926]         else {
[13:21:34.926]             ...future.result["stdout"] <- base::list(NULL)
[13:21:34.926]         }
[13:21:34.926]         base::close(...future.stdout)
[13:21:34.926]         ...future.stdout <- NULL
[13:21:34.926]     }
[13:21:34.926]     ...future.result$conditions <- ...future.conditions
[13:21:34.926]     ...future.result$finished <- base::Sys.time()
[13:21:34.926]     ...future.result
[13:21:34.926] }
[13:21:34.929] assign_globals() ...
[13:21:34.929] List of 5
[13:21:34.929]  $ ...future.FUN            :function (x, y)  
[13:21:34.929]  $ future.call.arguments    :List of 1
[13:21:34.929]   ..$ y: num [1:5] 2 4 6 8 10
[13:21:34.929]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:34.929]  $ ...future.elements_ii    :List of 2
[13:21:34.929]   ..$ A: num 50
[13:21:34.929]   ..$ B: num 60
[13:21:34.929]  $ ...future.seeds_ii       : NULL
[13:21:34.929]  $ ...future.globals.maxSize: NULL
[13:21:34.929]  - attr(*, "where")=List of 5
[13:21:34.929]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:34.929]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:34.929]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:34.929]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:34.929]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:34.929]  - attr(*, "resolved")= logi FALSE
[13:21:34.929]  - attr(*, "total_size")= num 4264
[13:21:34.929]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:34.929]  - attr(*, "already-done")= logi TRUE
[13:21:34.937] - reassign environment for ‘...future.FUN’
[13:21:34.937] - copied ‘...future.FUN’ to environment
[13:21:34.938] - copied ‘future.call.arguments’ to environment
[13:21:34.938] - copied ‘...future.elements_ii’ to environment
[13:21:34.938] - copied ‘...future.seeds_ii’ to environment
[13:21:34.938] - copied ‘...future.globals.maxSize’ to environment
[13:21:34.938] assign_globals() ... done
[13:21:34.938] requestCore(): workers = 2
[13:21:34.941] MulticoreFuture started
[13:21:34.941] - Launch lazy future ... done
[13:21:34.942] plan(): Setting new future strategy stack:
[13:21:34.942] run() for ‘MulticoreFuture’ ... done
[13:21:34.943] Created future:
[13:21:34.942] List of future strategies:
[13:21:34.942] 1. sequential:
[13:21:34.942]    - args: function (..., envir = parent.frame())
[13:21:34.942]    - tweaked: FALSE
[13:21:34.942]    - call: NULL
[13:21:34.944] plan(): nbrOfWorkers() = 1
[13:21:34.947] plan(): Setting new future strategy stack:
[13:21:34.947] List of future strategies:
[13:21:34.947] 1. multicore:
[13:21:34.947]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:34.947]    - tweaked: FALSE
[13:21:34.947]    - call: plan(strategy)
[13:21:34.954] plan(): nbrOfWorkers() = 2
[13:21:34.943] MulticoreFuture:
[13:21:34.943] Label: ‘future_sapply-1’
[13:21:34.943] Expression:
[13:21:34.943] {
[13:21:34.943]     do.call(function(...) {
[13:21:34.943]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.943]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:34.943]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.943]             on.exit(options(oopts), add = TRUE)
[13:21:34.943]         }
[13:21:34.943]         {
[13:21:34.943]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:34.943]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.943]                 ...future.FUN(...future.X_jj, ...)
[13:21:34.943]             })
[13:21:34.943]         }
[13:21:34.943]     }, args = future.call.arguments)
[13:21:34.943] }
[13:21:34.943] Lazy evaluation: FALSE
[13:21:34.943] Asynchronous evaluation: TRUE
[13:21:34.943] Local evaluation: TRUE
[13:21:34.943] Environment: R_GlobalEnv
[13:21:34.943] Capture standard output: TRUE
[13:21:34.943] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:34.943] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:21:34.943] Packages: <none>
[13:21:34.943] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:34.943] Resolved: TRUE
[13:21:34.943] Value: <not collected>
[13:21:34.943] Conditions captured: <none>
[13:21:34.943] Early signaling: FALSE
[13:21:34.943] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:34.943] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:34.956] Chunk #1 of 2 ... DONE
[13:21:34.956] Chunk #2 of 2 ...
[13:21:34.956]  - Finding globals in 'X' for chunk #2 ...
[13:21:34.956] getGlobalsAndPackages() ...
[13:21:34.957] Searching for globals...
[13:21:34.957] 
[13:21:34.957] Searching for globals ... DONE
[13:21:34.958] - globals: [0] <none>
[13:21:34.958] getGlobalsAndPackages() ... DONE
[13:21:34.958]    + additional globals found: [n=0] 
[13:21:34.958]    + additional namespaces needed: [n=0] 
[13:21:34.958]  - Finding globals in 'X' for chunk #2 ... DONE
[13:21:34.959]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:34.959]  - seeds: <none>
[13:21:34.959]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.959] getGlobalsAndPackages() ...
[13:21:34.960] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.960] Resolving globals: FALSE
[13:21:34.960] Tweak future expression to call with '...' arguments ...
[13:21:34.960] {
[13:21:34.960]     do.call(function(...) {
[13:21:34.960]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.960]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:34.960]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.960]             on.exit(options(oopts), add = TRUE)
[13:21:34.960]         }
[13:21:34.960]         {
[13:21:34.960]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:34.960]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.960]                 ...future.FUN(...future.X_jj, ...)
[13:21:34.960]             })
[13:21:34.960]         }
[13:21:34.960]     }, args = future.call.arguments)
[13:21:34.960] }
[13:21:34.961] Tweak future expression to call with '...' arguments ... DONE
[13:21:34.961] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:34.962] 
[13:21:34.962] getGlobalsAndPackages() ... DONE
[13:21:34.962] run() for ‘Future’ ...
[13:21:34.963] - state: ‘created’
[13:21:34.963] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:34.968] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:34.968] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:34.969]   - Field: ‘label’
[13:21:34.969]   - Field: ‘local’
[13:21:34.969]   - Field: ‘owner’
[13:21:34.969]   - Field: ‘envir’
[13:21:34.969]   - Field: ‘workers’
[13:21:34.970]   - Field: ‘packages’
[13:21:34.970]   - Field: ‘gc’
[13:21:34.970]   - Field: ‘job’
[13:21:34.970]   - Field: ‘conditions’
[13:21:34.970]   - Field: ‘expr’
[13:21:34.970]   - Field: ‘uuid’
[13:21:34.970]   - Field: ‘seed’
[13:21:34.971]   - Field: ‘version’
[13:21:34.971]   - Field: ‘result’
[13:21:34.971]   - Field: ‘asynchronous’
[13:21:34.971]   - Field: ‘calls’
[13:21:34.971]   - Field: ‘globals’
[13:21:34.971]   - Field: ‘stdout’
[13:21:34.971]   - Field: ‘earlySignal’
[13:21:34.972]   - Field: ‘lazy’
[13:21:34.972]   - Field: ‘state’
[13:21:34.972] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:34.972] - Launch lazy future ...
[13:21:34.972] Packages needed by the future expression (n = 0): <none>
[13:21:34.973] Packages needed by future strategies (n = 0): <none>
[13:21:34.973] {
[13:21:34.973]     {
[13:21:34.973]         {
[13:21:34.973]             ...future.startTime <- base::Sys.time()
[13:21:34.973]             {
[13:21:34.973]                 {
[13:21:34.973]                   {
[13:21:34.973]                     {
[13:21:34.973]                       base::local({
[13:21:34.973]                         has_future <- base::requireNamespace("future", 
[13:21:34.973]                           quietly = TRUE)
[13:21:34.973]                         if (has_future) {
[13:21:34.973]                           ns <- base::getNamespace("future")
[13:21:34.973]                           version <- ns[[".package"]][["version"]]
[13:21:34.973]                           if (is.null(version)) 
[13:21:34.973]                             version <- utils::packageVersion("future")
[13:21:34.973]                         }
[13:21:34.973]                         else {
[13:21:34.973]                           version <- NULL
[13:21:34.973]                         }
[13:21:34.973]                         if (!has_future || version < "1.8.0") {
[13:21:34.973]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:34.973]                             "", base::R.version$version.string), 
[13:21:34.973]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:34.973]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:34.973]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:34.973]                               "release", "version")], collapse = " "), 
[13:21:34.973]                             hostname = base::Sys.info()[["nodename"]])
[13:21:34.973]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:34.973]                             info)
[13:21:34.973]                           info <- base::paste(info, collapse = "; ")
[13:21:34.973]                           if (!has_future) {
[13:21:34.973]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:34.973]                               info)
[13:21:34.973]                           }
[13:21:34.973]                           else {
[13:21:34.973]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:34.973]                               info, version)
[13:21:34.973]                           }
[13:21:34.973]                           base::stop(msg)
[13:21:34.973]                         }
[13:21:34.973]                       })
[13:21:34.973]                     }
[13:21:34.973]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:34.973]                     base::options(mc.cores = 1L)
[13:21:34.973]                   }
[13:21:34.973]                   options(future.plan = NULL)
[13:21:34.973]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:34.973]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:34.973]                 }
[13:21:34.973]                 ...future.workdir <- getwd()
[13:21:34.973]             }
[13:21:34.973]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:34.973]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:34.973]         }
[13:21:34.973]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:34.973]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:34.973]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:34.973]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:34.973]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:34.973]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:34.973]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:34.973]             base::names(...future.oldOptions))
[13:21:34.973]     }
[13:21:34.973]     if (FALSE) {
[13:21:34.973]     }
[13:21:34.973]     else {
[13:21:34.973]         if (TRUE) {
[13:21:34.973]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:34.973]                 open = "w")
[13:21:34.973]         }
[13:21:34.973]         else {
[13:21:34.973]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:34.973]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:34.973]         }
[13:21:34.973]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:34.973]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:34.973]             base::sink(type = "output", split = FALSE)
[13:21:34.973]             base::close(...future.stdout)
[13:21:34.973]         }, add = TRUE)
[13:21:34.973]     }
[13:21:34.973]     ...future.frame <- base::sys.nframe()
[13:21:34.973]     ...future.conditions <- base::list()
[13:21:34.973]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:34.973]     if (FALSE) {
[13:21:34.973]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:34.973]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:34.973]     }
[13:21:34.973]     ...future.result <- base::tryCatch({
[13:21:34.973]         base::withCallingHandlers({
[13:21:34.973]             ...future.value <- base::withVisible(base::local({
[13:21:34.973]                 withCallingHandlers({
[13:21:34.973]                   {
[13:21:34.973]                     do.call(function(...) {
[13:21:34.973]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.973]                       if (!identical(...future.globals.maxSize.org, 
[13:21:34.973]                         ...future.globals.maxSize)) {
[13:21:34.973]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.973]                         on.exit(options(oopts), add = TRUE)
[13:21:34.973]                       }
[13:21:34.973]                       {
[13:21:34.973]                         lapply(seq_along(...future.elements_ii), 
[13:21:34.973]                           FUN = function(jj) {
[13:21:34.973]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.973]                             ...future.FUN(...future.X_jj, ...)
[13:21:34.973]                           })
[13:21:34.973]                       }
[13:21:34.973]                     }, args = future.call.arguments)
[13:21:34.973]                   }
[13:21:34.973]                 }, immediateCondition = function(cond) {
[13:21:34.973]                   save_rds <- function (object, pathname, ...) 
[13:21:34.973]                   {
[13:21:34.973]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:34.973]                     if (file_test("-f", pathname_tmp)) {
[13:21:34.973]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.973]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:34.973]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.973]                         fi_tmp[["mtime"]])
[13:21:34.973]                     }
[13:21:34.973]                     tryCatch({
[13:21:34.973]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:34.973]                     }, error = function(ex) {
[13:21:34.973]                       msg <- conditionMessage(ex)
[13:21:34.973]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.973]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:34.973]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.973]                         fi_tmp[["mtime"]], msg)
[13:21:34.973]                       ex$message <- msg
[13:21:34.973]                       stop(ex)
[13:21:34.973]                     })
[13:21:34.973]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:34.973]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:34.973]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:34.973]                       fi_tmp <- file.info(pathname_tmp)
[13:21:34.973]                       fi <- file.info(pathname)
[13:21:34.973]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:34.973]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:34.973]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:34.973]                         fi[["size"]], fi[["mtime"]])
[13:21:34.973]                       stop(msg)
[13:21:34.973]                     }
[13:21:34.973]                     invisible(pathname)
[13:21:34.973]                   }
[13:21:34.973]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:34.973]                     rootPath = tempdir()) 
[13:21:34.973]                   {
[13:21:34.973]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:34.973]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:34.973]                       tmpdir = path, fileext = ".rds")
[13:21:34.973]                     save_rds(obj, file)
[13:21:34.973]                   }
[13:21:34.973]                   saveImmediateCondition(cond, path = "/tmp/RtmpbpFWGO/.future/immediateConditions")
[13:21:34.973]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.973]                   {
[13:21:34.973]                     inherits <- base::inherits
[13:21:34.973]                     invokeRestart <- base::invokeRestart
[13:21:34.973]                     is.null <- base::is.null
[13:21:34.973]                     muffled <- FALSE
[13:21:34.973]                     if (inherits(cond, "message")) {
[13:21:34.973]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:34.973]                       if (muffled) 
[13:21:34.973]                         invokeRestart("muffleMessage")
[13:21:34.973]                     }
[13:21:34.973]                     else if (inherits(cond, "warning")) {
[13:21:34.973]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:34.973]                       if (muffled) 
[13:21:34.973]                         invokeRestart("muffleWarning")
[13:21:34.973]                     }
[13:21:34.973]                     else if (inherits(cond, "condition")) {
[13:21:34.973]                       if (!is.null(pattern)) {
[13:21:34.973]                         computeRestarts <- base::computeRestarts
[13:21:34.973]                         grepl <- base::grepl
[13:21:34.973]                         restarts <- computeRestarts(cond)
[13:21:34.973]                         for (restart in restarts) {
[13:21:34.973]                           name <- restart$name
[13:21:34.973]                           if (is.null(name)) 
[13:21:34.973]                             next
[13:21:34.973]                           if (!grepl(pattern, name)) 
[13:21:34.973]                             next
[13:21:34.973]                           invokeRestart(restart)
[13:21:34.973]                           muffled <- TRUE
[13:21:34.973]                           break
[13:21:34.973]                         }
[13:21:34.973]                       }
[13:21:34.973]                     }
[13:21:34.973]                     invisible(muffled)
[13:21:34.973]                   }
[13:21:34.973]                   muffleCondition(cond)
[13:21:34.973]                 })
[13:21:34.973]             }))
[13:21:34.973]             future::FutureResult(value = ...future.value$value, 
[13:21:34.973]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:34.973]                   ...future.rng), globalenv = if (FALSE) 
[13:21:34.973]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:34.973]                     ...future.globalenv.names))
[13:21:34.973]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:34.973]         }, condition = base::local({
[13:21:34.973]             c <- base::c
[13:21:34.973]             inherits <- base::inherits
[13:21:34.973]             invokeRestart <- base::invokeRestart
[13:21:34.973]             length <- base::length
[13:21:34.973]             list <- base::list
[13:21:34.973]             seq.int <- base::seq.int
[13:21:34.973]             signalCondition <- base::signalCondition
[13:21:34.973]             sys.calls <- base::sys.calls
[13:21:34.973]             `[[` <- base::`[[`
[13:21:34.973]             `+` <- base::`+`
[13:21:34.973]             `<<-` <- base::`<<-`
[13:21:34.973]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:34.973]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:34.973]                   3L)]
[13:21:34.973]             }
[13:21:34.973]             function(cond) {
[13:21:34.973]                 is_error <- inherits(cond, "error")
[13:21:34.973]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:34.973]                   NULL)
[13:21:34.973]                 if (is_error) {
[13:21:34.973]                   sessionInformation <- function() {
[13:21:34.973]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:34.973]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:34.973]                       search = base::search(), system = base::Sys.info())
[13:21:34.973]                   }
[13:21:34.973]                   ...future.conditions[[length(...future.conditions) + 
[13:21:34.973]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:34.973]                     cond$call), session = sessionInformation(), 
[13:21:34.973]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:34.973]                   signalCondition(cond)
[13:21:34.973]                 }
[13:21:34.973]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:34.973]                 "immediateCondition"))) {
[13:21:34.973]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:34.973]                   ...future.conditions[[length(...future.conditions) + 
[13:21:34.973]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:34.973]                   if (TRUE && !signal) {
[13:21:34.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.973]                     {
[13:21:34.973]                       inherits <- base::inherits
[13:21:34.973]                       invokeRestart <- base::invokeRestart
[13:21:34.973]                       is.null <- base::is.null
[13:21:34.973]                       muffled <- FALSE
[13:21:34.973]                       if (inherits(cond, "message")) {
[13:21:34.973]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:34.973]                         if (muffled) 
[13:21:34.973]                           invokeRestart("muffleMessage")
[13:21:34.973]                       }
[13:21:34.973]                       else if (inherits(cond, "warning")) {
[13:21:34.973]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:34.973]                         if (muffled) 
[13:21:34.973]                           invokeRestart("muffleWarning")
[13:21:34.973]                       }
[13:21:34.973]                       else if (inherits(cond, "condition")) {
[13:21:34.973]                         if (!is.null(pattern)) {
[13:21:34.973]                           computeRestarts <- base::computeRestarts
[13:21:34.973]                           grepl <- base::grepl
[13:21:34.973]                           restarts <- computeRestarts(cond)
[13:21:34.973]                           for (restart in restarts) {
[13:21:34.973]                             name <- restart$name
[13:21:34.973]                             if (is.null(name)) 
[13:21:34.973]                               next
[13:21:34.973]                             if (!grepl(pattern, name)) 
[13:21:34.973]                               next
[13:21:34.973]                             invokeRestart(restart)
[13:21:34.973]                             muffled <- TRUE
[13:21:34.973]                             break
[13:21:34.973]                           }
[13:21:34.973]                         }
[13:21:34.973]                       }
[13:21:34.973]                       invisible(muffled)
[13:21:34.973]                     }
[13:21:34.973]                     muffleCondition(cond, pattern = "^muffle")
[13:21:34.973]                   }
[13:21:34.973]                 }
[13:21:34.973]                 else {
[13:21:34.973]                   if (TRUE) {
[13:21:34.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:34.973]                     {
[13:21:34.973]                       inherits <- base::inherits
[13:21:34.973]                       invokeRestart <- base::invokeRestart
[13:21:34.973]                       is.null <- base::is.null
[13:21:34.973]                       muffled <- FALSE
[13:21:34.973]                       if (inherits(cond, "message")) {
[13:21:34.973]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:34.973]                         if (muffled) 
[13:21:34.973]                           invokeRestart("muffleMessage")
[13:21:34.973]                       }
[13:21:34.973]                       else if (inherits(cond, "warning")) {
[13:21:34.973]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:34.973]                         if (muffled) 
[13:21:34.973]                           invokeRestart("muffleWarning")
[13:21:34.973]                       }
[13:21:34.973]                       else if (inherits(cond, "condition")) {
[13:21:34.973]                         if (!is.null(pattern)) {
[13:21:34.973]                           computeRestarts <- base::computeRestarts
[13:21:34.973]                           grepl <- base::grepl
[13:21:34.973]                           restarts <- computeRestarts(cond)
[13:21:34.973]                           for (restart in restarts) {
[13:21:34.973]                             name <- restart$name
[13:21:34.973]                             if (is.null(name)) 
[13:21:34.973]                               next
[13:21:34.973]                             if (!grepl(pattern, name)) 
[13:21:34.973]                               next
[13:21:34.973]                             invokeRestart(restart)
[13:21:34.973]                             muffled <- TRUE
[13:21:34.973]                             break
[13:21:34.973]                           }
[13:21:34.973]                         }
[13:21:34.973]                       }
[13:21:34.973]                       invisible(muffled)
[13:21:34.973]                     }
[13:21:34.973]                     muffleCondition(cond, pattern = "^muffle")
[13:21:34.973]                   }
[13:21:34.973]                 }
[13:21:34.973]             }
[13:21:34.973]         }))
[13:21:34.973]     }, error = function(ex) {
[13:21:34.973]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:34.973]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:34.973]                 ...future.rng), started = ...future.startTime, 
[13:21:34.973]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:34.973]             version = "1.8"), class = "FutureResult")
[13:21:34.973]     }, finally = {
[13:21:34.973]         if (!identical(...future.workdir, getwd())) 
[13:21:34.973]             setwd(...future.workdir)
[13:21:34.973]         {
[13:21:34.973]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:34.973]                 ...future.oldOptions$nwarnings <- NULL
[13:21:34.973]             }
[13:21:34.973]             base::options(...future.oldOptions)
[13:21:34.973]             if (.Platform$OS.type == "windows") {
[13:21:34.973]                 old_names <- names(...future.oldEnvVars)
[13:21:34.973]                 envs <- base::Sys.getenv()
[13:21:34.973]                 names <- names(envs)
[13:21:34.973]                 common <- intersect(names, old_names)
[13:21:34.973]                 added <- setdiff(names, old_names)
[13:21:34.973]                 removed <- setdiff(old_names, names)
[13:21:34.973]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:34.973]                   envs[common]]
[13:21:34.973]                 NAMES <- toupper(changed)
[13:21:34.973]                 args <- list()
[13:21:34.973]                 for (kk in seq_along(NAMES)) {
[13:21:34.973]                   name <- changed[[kk]]
[13:21:34.973]                   NAME <- NAMES[[kk]]
[13:21:34.973]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.973]                     next
[13:21:34.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:34.973]                 }
[13:21:34.973]                 NAMES <- toupper(added)
[13:21:34.973]                 for (kk in seq_along(NAMES)) {
[13:21:34.973]                   name <- added[[kk]]
[13:21:34.973]                   NAME <- NAMES[[kk]]
[13:21:34.973]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.973]                     next
[13:21:34.973]                   args[[name]] <- ""
[13:21:34.973]                 }
[13:21:34.973]                 NAMES <- toupper(removed)
[13:21:34.973]                 for (kk in seq_along(NAMES)) {
[13:21:34.973]                   name <- removed[[kk]]
[13:21:34.973]                   NAME <- NAMES[[kk]]
[13:21:34.973]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:34.973]                     next
[13:21:34.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:34.973]                 }
[13:21:34.973]                 if (length(args) > 0) 
[13:21:34.973]                   base::do.call(base::Sys.setenv, args = args)
[13:21:34.973]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:34.973]             }
[13:21:34.973]             else {
[13:21:34.973]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:34.973]             }
[13:21:34.973]             {
[13:21:34.973]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:34.973]                   0L) {
[13:21:34.973]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:34.973]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:34.973]                   base::options(opts)
[13:21:34.973]                 }
[13:21:34.973]                 {
[13:21:34.973]                   {
[13:21:34.973]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:34.973]                     NULL
[13:21:34.973]                   }
[13:21:34.973]                   options(future.plan = NULL)
[13:21:34.973]                   if (is.na(NA_character_)) 
[13:21:34.973]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:34.973]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:34.973]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:34.973]                     envir = parent.frame()) 
[13:21:34.973]                   {
[13:21:34.973]                     default_workers <- missing(workers)
[13:21:34.973]                     if (is.function(workers)) 
[13:21:34.973]                       workers <- workers()
[13:21:34.973]                     workers <- structure(as.integer(workers), 
[13:21:34.973]                       class = class(workers))
[13:21:34.973]                     stop_if_not(is.finite(workers), workers >= 
[13:21:34.973]                       1L)
[13:21:34.973]                     if ((workers == 1L && !inherits(workers, 
[13:21:34.973]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:34.973]                       if (default_workers) 
[13:21:34.973]                         supportsMulticore(warn = TRUE)
[13:21:34.973]                       return(sequential(..., envir = envir))
[13:21:34.973]                     }
[13:21:34.973]                     oopts <- options(mc.cores = workers)
[13:21:34.973]                     on.exit(options(oopts))
[13:21:34.973]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:34.973]                       envir = envir)
[13:21:34.973]                     if (!future$lazy) 
[13:21:34.973]                       future <- run(future)
[13:21:34.973]                     invisible(future)
[13:21:34.973]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:34.973]                 }
[13:21:34.973]             }
[13:21:34.973]         }
[13:21:34.973]     })
[13:21:34.973]     if (TRUE) {
[13:21:34.973]         base::sink(type = "output", split = FALSE)
[13:21:34.973]         if (TRUE) {
[13:21:34.973]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:34.973]         }
[13:21:34.973]         else {
[13:21:34.973]             ...future.result["stdout"] <- base::list(NULL)
[13:21:34.973]         }
[13:21:34.973]         base::close(...future.stdout)
[13:21:34.973]         ...future.stdout <- NULL
[13:21:34.973]     }
[13:21:34.973]     ...future.result$conditions <- ...future.conditions
[13:21:34.973]     ...future.result$finished <- base::Sys.time()
[13:21:34.973]     ...future.result
[13:21:34.973] }
[13:21:34.977] assign_globals() ...
[13:21:34.977] List of 5
[13:21:34.977]  $ ...future.FUN            :function (x, y)  
[13:21:34.977]  $ future.call.arguments    :List of 1
[13:21:34.977]   ..$ y: num [1:5] 2 4 6 8 10
[13:21:34.977]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:34.977]  $ ...future.elements_ii    :List of 2
[13:21:34.977]   ..$ C: num 70
[13:21:34.977]   ..$ D: num 80
[13:21:34.977]  $ ...future.seeds_ii       : NULL
[13:21:34.977]  $ ...future.globals.maxSize: NULL
[13:21:34.977]  - attr(*, "where")=List of 5
[13:21:34.977]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:34.977]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:34.977]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:34.977]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:34.977]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:34.977]  - attr(*, "resolved")= logi FALSE
[13:21:34.977]  - attr(*, "total_size")= num 4264
[13:21:34.977]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:34.977]  - attr(*, "already-done")= logi TRUE
[13:21:34.987] - reassign environment for ‘...future.FUN’
[13:21:34.987] - copied ‘...future.FUN’ to environment
[13:21:34.987] - copied ‘future.call.arguments’ to environment
[13:21:34.987] - copied ‘...future.elements_ii’ to environment
[13:21:34.988] - copied ‘...future.seeds_ii’ to environment
[13:21:34.988] - copied ‘...future.globals.maxSize’ to environment
[13:21:34.988] assign_globals() ... done
[13:21:34.988] requestCore(): workers = 2
[13:21:34.991] MulticoreFuture started
[13:21:34.992] - Launch lazy future ... done
[13:21:34.992] plan(): Setting new future strategy stack:
[13:21:34.993] run() for ‘MulticoreFuture’ ... done
[13:21:34.993] Created future:
[13:21:34.993] List of future strategies:
[13:21:34.993] 1. sequential:
[13:21:34.993]    - args: function (..., envir = parent.frame())
[13:21:34.993]    - tweaked: FALSE
[13:21:34.993]    - call: NULL
[13:21:34.994] plan(): nbrOfWorkers() = 1
[13:21:34.997] plan(): Setting new future strategy stack:
[13:21:34.998] List of future strategies:
[13:21:34.998] 1. multicore:
[13:21:34.998]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:34.998]    - tweaked: FALSE
[13:21:34.998]    - call: plan(strategy)
[13:21:35.004] plan(): nbrOfWorkers() = 2
[13:21:34.994] MulticoreFuture:
[13:21:34.994] Label: ‘future_sapply-2’
[13:21:34.994] Expression:
[13:21:34.994] {
[13:21:34.994]     do.call(function(...) {
[13:21:34.994]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:34.994]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:34.994]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:34.994]             on.exit(options(oopts), add = TRUE)
[13:21:34.994]         }
[13:21:34.994]         {
[13:21:34.994]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:34.994]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:34.994]                 ...future.FUN(...future.X_jj, ...)
[13:21:34.994]             })
[13:21:34.994]         }
[13:21:34.994]     }, args = future.call.arguments)
[13:21:34.994] }
[13:21:34.994] Lazy evaluation: FALSE
[13:21:34.994] Asynchronous evaluation: TRUE
[13:21:34.994] Local evaluation: TRUE
[13:21:34.994] Environment: R_GlobalEnv
[13:21:34.994] Capture standard output: TRUE
[13:21:34.994] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:34.994] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:21:34.994] Packages: <none>
[13:21:34.994] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:34.994] Resolved: TRUE
[13:21:34.994] Value: <not collected>
[13:21:34.994] Conditions captured: <none>
[13:21:34.994] Early signaling: FALSE
[13:21:34.994] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:34.994] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:35.006] Chunk #2 of 2 ... DONE
[13:21:35.006] Launching 2 futures (chunks) ... DONE
[13:21:35.006] Resolving 2 futures (chunks) ...
[13:21:35.007] resolve() on list ...
[13:21:35.007]  recursive: 0
[13:21:35.007]  length: 2
[13:21:35.007] 
[13:21:35.008] Future #1
[13:21:35.008] result() for MulticoreFuture ...
[13:21:35.009] result() for MulticoreFuture ...
[13:21:35.009] result() for MulticoreFuture ... done
[13:21:35.010] result() for MulticoreFuture ... done
[13:21:35.010] result() for MulticoreFuture ...
[13:21:35.010] result() for MulticoreFuture ... done
[13:21:35.010] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:21:35.011] - nx: 2
[13:21:35.011] - relay: TRUE
[13:21:35.011] - stdout: TRUE
[13:21:35.011] - signal: TRUE
[13:21:35.012] - resignal: FALSE
[13:21:35.012] - force: TRUE
[13:21:35.012] - relayed: [n=2] FALSE, FALSE
[13:21:35.012] - queued futures: [n=2] FALSE, FALSE
[13:21:35.013]  - until=1
[13:21:35.013]  - relaying element #1
[13:21:35.013] result() for MulticoreFuture ...
[13:21:35.013] result() for MulticoreFuture ... done
[13:21:35.014] result() for MulticoreFuture ...
[13:21:35.014] result() for MulticoreFuture ... done
[13:21:35.014] result() for MulticoreFuture ...
[13:21:35.014] result() for MulticoreFuture ... done
[13:21:35.014] result() for MulticoreFuture ...
[13:21:35.015] result() for MulticoreFuture ... done
[13:21:35.015] - relayed: [n=2] TRUE, FALSE
[13:21:35.015] - queued futures: [n=2] TRUE, FALSE
[13:21:35.015] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:21:35.015]  length: 1 (resolved future 1)
[13:21:35.016] Future #2
[13:21:35.016] result() for MulticoreFuture ...
[13:21:35.017] result() for MulticoreFuture ...
[13:21:35.017] result() for MulticoreFuture ... done
[13:21:35.017] result() for MulticoreFuture ... done
[13:21:35.017] result() for MulticoreFuture ...
[13:21:35.018] result() for MulticoreFuture ... done
[13:21:35.018] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:21:35.018] - nx: 2
[13:21:35.018] - relay: TRUE
[13:21:35.018] - stdout: TRUE
[13:21:35.018] - signal: TRUE
[13:21:35.018] - resignal: FALSE
[13:21:35.018] - force: TRUE
[13:21:35.019] - relayed: [n=2] TRUE, FALSE
[13:21:35.019] - queued futures: [n=2] TRUE, FALSE
[13:21:35.019]  - until=2
[13:21:35.019]  - relaying element #2
[13:21:35.019] result() for MulticoreFuture ...
[13:21:35.019] result() for MulticoreFuture ... done
[13:21:35.019] result() for MulticoreFuture ...
[13:21:35.019] result() for MulticoreFuture ... done
[13:21:35.020] result() for MulticoreFuture ...
[13:21:35.020] result() for MulticoreFuture ... done
[13:21:35.020] result() for MulticoreFuture ...
[13:21:35.020] result() for MulticoreFuture ... done
[13:21:35.020] - relayed: [n=2] TRUE, TRUE
[13:21:35.020] - queued futures: [n=2] TRUE, TRUE
[13:21:35.020] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:21:35.020]  length: 0 (resolved future 2)
[13:21:35.021] Relaying remaining futures
[13:21:35.021] signalConditionsASAP(NULL, pos=0) ...
[13:21:35.021] - nx: 2
[13:21:35.021] - relay: TRUE
[13:21:35.021] - stdout: TRUE
[13:21:35.021] - signal: TRUE
[13:21:35.021] - resignal: FALSE
[13:21:35.021] - force: TRUE
[13:21:35.021] - relayed: [n=2] TRUE, TRUE
[13:21:35.021] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:21:35.022] - relayed: [n=2] TRUE, TRUE
[13:21:35.022] - queued futures: [n=2] TRUE, TRUE
[13:21:35.022] signalConditionsASAP(NULL, pos=0) ... done
[13:21:35.022] resolve() on list ... DONE
[13:21:35.022] result() for MulticoreFuture ...
[13:21:35.022] result() for MulticoreFuture ... done
[13:21:35.022] result() for MulticoreFuture ...
[13:21:35.022] result() for MulticoreFuture ... done
[13:21:35.022] result() for MulticoreFuture ...
[13:21:35.023] result() for MulticoreFuture ... done
[13:21:35.023] result() for MulticoreFuture ...
[13:21:35.023] result() for MulticoreFuture ... done
[13:21:35.023]  - Number of value chunks collected: 2
[13:21:35.023] Resolving 2 futures (chunks) ... DONE
[13:21:35.023] Reducing values from 2 chunks ...
[13:21:35.023]  - Number of values collected after concatenation: 4
[13:21:35.023]  - Number of values expected: 4
[13:21:35.023] Reducing values from 2 chunks ... DONE
[13:21:35.024] future_lapply() ... DONE
[13:21:35.024] future_lapply() ...
[13:21:35.031] Number of chunks: 2
[13:21:35.032] getGlobalsAndPackagesXApply() ...
[13:21:35.032]  - future.globals: TRUE
[13:21:35.032] getGlobalsAndPackages() ...
[13:21:35.032] Searching for globals...
[13:21:35.040] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[13:21:35.040] Searching for globals ... DONE
[13:21:35.040] Resolving globals: FALSE
[13:21:35.041] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[13:21:35.042] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:35.042] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:35.042] - packages: [1] ‘future.apply’
[13:21:35.042] getGlobalsAndPackages() ... DONE
[13:21:35.042]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:35.043]  - needed namespaces: [n=1] ‘future.apply’
[13:21:35.043] Finding globals ... DONE
[13:21:35.043]  - use_args: TRUE
[13:21:35.043]  - Getting '...' globals ...
[13:21:35.043] resolve() on list ...
[13:21:35.043]  recursive: 0
[13:21:35.044]  length: 1
[13:21:35.044]  elements: ‘...’
[13:21:35.044]  length: 0 (resolved future 1)
[13:21:35.044] resolve() on list ... DONE
[13:21:35.044]    - '...' content: [n=1] ‘y’
[13:21:35.044] List of 1
[13:21:35.044]  $ ...:List of 1
[13:21:35.044]   ..$ y: num [1:5] 2 4 6 8 10
[13:21:35.044]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:35.044]  - attr(*, "where")=List of 1
[13:21:35.044]   ..$ ...:<environment: 0x563b6e85cec8> 
[13:21:35.044]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:35.044]  - attr(*, "resolved")= logi TRUE
[13:21:35.044]  - attr(*, "total_size")= num NA
[13:21:35.048]  - Getting '...' globals ... DONE
[13:21:35.048] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:35.048] List of 8
[13:21:35.048]  $ ...future.FUN:function (x, ...)  
[13:21:35.048]  $ x_FUN        :function (x, y)  
[13:21:35.048]  $ times        : int 15
[13:21:35.048]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:35.048]  $ stop_if_not  :function (...)  
[13:21:35.048]  $ dim          : int [1:2] 3 5
[13:21:35.048]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:21:35.048]  $ ...          :List of 1
[13:21:35.048]   ..$ y: num [1:5] 2 4 6 8 10
[13:21:35.048]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:35.048]  - attr(*, "where")=List of 8
[13:21:35.048]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:35.048]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:35.048]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:35.048]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:35.048]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:35.048]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:35.048]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:35.048]   ..$ ...          :<environment: 0x563b6e85cec8> 
[13:21:35.048]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:35.048]  - attr(*, "resolved")= logi FALSE
[13:21:35.048]  - attr(*, "total_size")= num 98600
[13:21:35.054] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:21:35.054] getGlobalsAndPackagesXApply() ... DONE
[13:21:35.055] Number of futures (= number of chunks): 2
[13:21:35.055] Launching 2 futures (chunks) ...
[13:21:35.055] Chunk #1 of 2 ...
[13:21:35.055]  - Finding globals in 'X' for chunk #1 ...
[13:21:35.055] getGlobalsAndPackages() ...
[13:21:35.055] Searching for globals...
[13:21:35.056] 
[13:21:35.056] Searching for globals ... DONE
[13:21:35.056] - globals: [0] <none>
[13:21:35.056] getGlobalsAndPackages() ... DONE
[13:21:35.056]    + additional globals found: [n=0] 
[13:21:35.059]    + additional namespaces needed: [n=0] 
[13:21:35.059]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:35.059]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:35.059]  - seeds: <none>
[13:21:35.059]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:35.059] getGlobalsAndPackages() ...
[13:21:35.059] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:35.060] Resolving globals: FALSE
[13:21:35.060] Tweak future expression to call with '...' arguments ...
[13:21:35.060] {
[13:21:35.060]     do.call(function(...) {
[13:21:35.060]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:35.060]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:35.060]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:35.060]             on.exit(options(oopts), add = TRUE)
[13:21:35.060]         }
[13:21:35.060]         {
[13:21:35.060]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:35.060]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:35.060]                 ...future.FUN(...future.X_jj, ...)
[13:21:35.060]             })
[13:21:35.060]         }
[13:21:35.060]     }, args = future.call.arguments)
[13:21:35.060] }
[13:21:35.060] Tweak future expression to call with '...' arguments ... DONE
[13:21:35.061] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:35.061] - packages: [1] ‘future.apply’
[13:21:35.061] getGlobalsAndPackages() ... DONE
[13:21:35.062] run() for ‘Future’ ...
[13:21:35.062] - state: ‘created’
[13:21:35.062] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:35.066] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:35.067] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:35.067]   - Field: ‘label’
[13:21:35.067]   - Field: ‘local’
[13:21:35.067]   - Field: ‘owner’
[13:21:35.067]   - Field: ‘envir’
[13:21:35.067]   - Field: ‘workers’
[13:21:35.067]   - Field: ‘packages’
[13:21:35.067]   - Field: ‘gc’
[13:21:35.068]   - Field: ‘job’
[13:21:35.068]   - Field: ‘conditions’
[13:21:35.068]   - Field: ‘expr’
[13:21:35.068]   - Field: ‘uuid’
[13:21:35.068]   - Field: ‘seed’
[13:21:35.068]   - Field: ‘version’
[13:21:35.068]   - Field: ‘result’
[13:21:35.069]   - Field: ‘asynchronous’
[13:21:35.069]   - Field: ‘calls’
[13:21:35.069]   - Field: ‘globals’
[13:21:35.069]   - Field: ‘stdout’
[13:21:35.069]   - Field: ‘earlySignal’
[13:21:35.069]   - Field: ‘lazy’
[13:21:35.069]   - Field: ‘state’
[13:21:35.069] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:35.070] - Launch lazy future ...
[13:21:35.070] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:35.070] Packages needed by future strategies (n = 0): <none>
[13:21:35.071] {
[13:21:35.071]     {
[13:21:35.071]         {
[13:21:35.071]             ...future.startTime <- base::Sys.time()
[13:21:35.071]             {
[13:21:35.071]                 {
[13:21:35.071]                   {
[13:21:35.071]                     {
[13:21:35.071]                       {
[13:21:35.071]                         base::local({
[13:21:35.071]                           has_future <- base::requireNamespace("future", 
[13:21:35.071]                             quietly = TRUE)
[13:21:35.071]                           if (has_future) {
[13:21:35.071]                             ns <- base::getNamespace("future")
[13:21:35.071]                             version <- ns[[".package"]][["version"]]
[13:21:35.071]                             if (is.null(version)) 
[13:21:35.071]                               version <- utils::packageVersion("future")
[13:21:35.071]                           }
[13:21:35.071]                           else {
[13:21:35.071]                             version <- NULL
[13:21:35.071]                           }
[13:21:35.071]                           if (!has_future || version < "1.8.0") {
[13:21:35.071]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:35.071]                               "", base::R.version$version.string), 
[13:21:35.071]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:35.071]                                 base::R.version$platform, 8 * 
[13:21:35.071]                                   base::.Machine$sizeof.pointer), 
[13:21:35.071]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:35.071]                                 "release", "version")], collapse = " "), 
[13:21:35.071]                               hostname = base::Sys.info()[["nodename"]])
[13:21:35.071]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:35.071]                               info)
[13:21:35.071]                             info <- base::paste(info, collapse = "; ")
[13:21:35.071]                             if (!has_future) {
[13:21:35.071]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:35.071]                                 info)
[13:21:35.071]                             }
[13:21:35.071]                             else {
[13:21:35.071]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:35.071]                                 info, version)
[13:21:35.071]                             }
[13:21:35.071]                             base::stop(msg)
[13:21:35.071]                           }
[13:21:35.071]                         })
[13:21:35.071]                       }
[13:21:35.071]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:35.071]                       base::options(mc.cores = 1L)
[13:21:35.071]                     }
[13:21:35.071]                     base::local({
[13:21:35.071]                       for (pkg in "future.apply") {
[13:21:35.071]                         base::loadNamespace(pkg)
[13:21:35.071]                         base::library(pkg, character.only = TRUE)
[13:21:35.071]                       }
[13:21:35.071]                     })
[13:21:35.071]                   }
[13:21:35.071]                   options(future.plan = NULL)
[13:21:35.071]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:35.071]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:35.071]                 }
[13:21:35.071]                 ...future.workdir <- getwd()
[13:21:35.071]             }
[13:21:35.071]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:35.071]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:35.071]         }
[13:21:35.071]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:35.071]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:35.071]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:35.071]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:35.071]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:35.071]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:35.071]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:35.071]             base::names(...future.oldOptions))
[13:21:35.071]     }
[13:21:35.071]     if (FALSE) {
[13:21:35.071]     }
[13:21:35.071]     else {
[13:21:35.071]         if (TRUE) {
[13:21:35.071]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:35.071]                 open = "w")
[13:21:35.071]         }
[13:21:35.071]         else {
[13:21:35.071]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:35.071]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:35.071]         }
[13:21:35.071]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:35.071]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:35.071]             base::sink(type = "output", split = FALSE)
[13:21:35.071]             base::close(...future.stdout)
[13:21:35.071]         }, add = TRUE)
[13:21:35.071]     }
[13:21:35.071]     ...future.frame <- base::sys.nframe()
[13:21:35.071]     ...future.conditions <- base::list()
[13:21:35.071]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:35.071]     if (FALSE) {
[13:21:35.071]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:35.071]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:35.071]     }
[13:21:35.071]     ...future.result <- base::tryCatch({
[13:21:35.071]         base::withCallingHandlers({
[13:21:35.071]             ...future.value <- base::withVisible(base::local({
[13:21:35.071]                 withCallingHandlers({
[13:21:35.071]                   {
[13:21:35.071]                     do.call(function(...) {
[13:21:35.071]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:35.071]                       if (!identical(...future.globals.maxSize.org, 
[13:21:35.071]                         ...future.globals.maxSize)) {
[13:21:35.071]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:35.071]                         on.exit(options(oopts), add = TRUE)
[13:21:35.071]                       }
[13:21:35.071]                       {
[13:21:35.071]                         lapply(seq_along(...future.elements_ii), 
[13:21:35.071]                           FUN = function(jj) {
[13:21:35.071]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:35.071]                             ...future.FUN(...future.X_jj, ...)
[13:21:35.071]                           })
[13:21:35.071]                       }
[13:21:35.071]                     }, args = future.call.arguments)
[13:21:35.071]                   }
[13:21:35.071]                 }, immediateCondition = function(cond) {
[13:21:35.071]                   save_rds <- function (object, pathname, ...) 
[13:21:35.071]                   {
[13:21:35.071]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:35.071]                     if (file_test("-f", pathname_tmp)) {
[13:21:35.071]                       fi_tmp <- file.info(pathname_tmp)
[13:21:35.071]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:35.071]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:35.071]                         fi_tmp[["mtime"]])
[13:21:35.071]                     }
[13:21:35.071]                     tryCatch({
[13:21:35.071]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:35.071]                     }, error = function(ex) {
[13:21:35.071]                       msg <- conditionMessage(ex)
[13:21:35.071]                       fi_tmp <- file.info(pathname_tmp)
[13:21:35.071]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:35.071]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:35.071]                         fi_tmp[["mtime"]], msg)
[13:21:35.071]                       ex$message <- msg
[13:21:35.071]                       stop(ex)
[13:21:35.071]                     })
[13:21:35.071]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:35.071]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:35.071]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:35.071]                       fi_tmp <- file.info(pathname_tmp)
[13:21:35.071]                       fi <- file.info(pathname)
[13:21:35.071]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:35.071]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:35.071]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:35.071]                         fi[["size"]], fi[["mtime"]])
[13:21:35.071]                       stop(msg)
[13:21:35.071]                     }
[13:21:35.071]                     invisible(pathname)
[13:21:35.071]                   }
[13:21:35.071]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:35.071]                     rootPath = tempdir()) 
[13:21:35.071]                   {
[13:21:35.071]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:35.071]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:35.071]                       tmpdir = path, fileext = ".rds")
[13:21:35.071]                     save_rds(obj, file)
[13:21:35.071]                   }
[13:21:35.071]                   saveImmediateCondition(cond, path = "/tmp/RtmpbpFWGO/.future/immediateConditions")
[13:21:35.071]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:35.071]                   {
[13:21:35.071]                     inherits <- base::inherits
[13:21:35.071]                     invokeRestart <- base::invokeRestart
[13:21:35.071]                     is.null <- base::is.null
[13:21:35.071]                     muffled <- FALSE
[13:21:35.071]                     if (inherits(cond, "message")) {
[13:21:35.071]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:35.071]                       if (muffled) 
[13:21:35.071]                         invokeRestart("muffleMessage")
[13:21:35.071]                     }
[13:21:35.071]                     else if (inherits(cond, "warning")) {
[13:21:35.071]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:35.071]                       if (muffled) 
[13:21:35.071]                         invokeRestart("muffleWarning")
[13:21:35.071]                     }
[13:21:35.071]                     else if (inherits(cond, "condition")) {
[13:21:35.071]                       if (!is.null(pattern)) {
[13:21:35.071]                         computeRestarts <- base::computeRestarts
[13:21:35.071]                         grepl <- base::grepl
[13:21:35.071]                         restarts <- computeRestarts(cond)
[13:21:35.071]                         for (restart in restarts) {
[13:21:35.071]                           name <- restart$name
[13:21:35.071]                           if (is.null(name)) 
[13:21:35.071]                             next
[13:21:35.071]                           if (!grepl(pattern, name)) 
[13:21:35.071]                             next
[13:21:35.071]                           invokeRestart(restart)
[13:21:35.071]                           muffled <- TRUE
[13:21:35.071]                           break
[13:21:35.071]                         }
[13:21:35.071]                       }
[13:21:35.071]                     }
[13:21:35.071]                     invisible(muffled)
[13:21:35.071]                   }
[13:21:35.071]                   muffleCondition(cond)
[13:21:35.071]                 })
[13:21:35.071]             }))
[13:21:35.071]             future::FutureResult(value = ...future.value$value, 
[13:21:35.071]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:35.071]                   ...future.rng), globalenv = if (FALSE) 
[13:21:35.071]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:35.071]                     ...future.globalenv.names))
[13:21:35.071]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:35.071]         }, condition = base::local({
[13:21:35.071]             c <- base::c
[13:21:35.071]             inherits <- base::inherits
[13:21:35.071]             invokeRestart <- base::invokeRestart
[13:21:35.071]             length <- base::length
[13:21:35.071]             list <- base::list
[13:21:35.071]             seq.int <- base::seq.int
[13:21:35.071]             signalCondition <- base::signalCondition
[13:21:35.071]             sys.calls <- base::sys.calls
[13:21:35.071]             `[[` <- base::`[[`
[13:21:35.071]             `+` <- base::`+`
[13:21:35.071]             `<<-` <- base::`<<-`
[13:21:35.071]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:35.071]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:35.071]                   3L)]
[13:21:35.071]             }
[13:21:35.071]             function(cond) {
[13:21:35.071]                 is_error <- inherits(cond, "error")
[13:21:35.071]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:35.071]                   NULL)
[13:21:35.071]                 if (is_error) {
[13:21:35.071]                   sessionInformation <- function() {
[13:21:35.071]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:35.071]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:35.071]                       search = base::search(), system = base::Sys.info())
[13:21:35.071]                   }
[13:21:35.071]                   ...future.conditions[[length(...future.conditions) + 
[13:21:35.071]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:35.071]                     cond$call), session = sessionInformation(), 
[13:21:35.071]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:35.071]                   signalCondition(cond)
[13:21:35.071]                 }
[13:21:35.071]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:35.071]                 "immediateCondition"))) {
[13:21:35.071]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:35.071]                   ...future.conditions[[length(...future.conditions) + 
[13:21:35.071]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:35.071]                   if (TRUE && !signal) {
[13:21:35.071]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:35.071]                     {
[13:21:35.071]                       inherits <- base::inherits
[13:21:35.071]                       invokeRestart <- base::invokeRestart
[13:21:35.071]                       is.null <- base::is.null
[13:21:35.071]                       muffled <- FALSE
[13:21:35.071]                       if (inherits(cond, "message")) {
[13:21:35.071]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:35.071]                         if (muffled) 
[13:21:35.071]                           invokeRestart("muffleMessage")
[13:21:35.071]                       }
[13:21:35.071]                       else if (inherits(cond, "warning")) {
[13:21:35.071]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:35.071]                         if (muffled) 
[13:21:35.071]                           invokeRestart("muffleWarning")
[13:21:35.071]                       }
[13:21:35.071]                       else if (inherits(cond, "condition")) {
[13:21:35.071]                         if (!is.null(pattern)) {
[13:21:35.071]                           computeRestarts <- base::computeRestarts
[13:21:35.071]                           grepl <- base::grepl
[13:21:35.071]                           restarts <- computeRestarts(cond)
[13:21:35.071]                           for (restart in restarts) {
[13:21:35.071]                             name <- restart$name
[13:21:35.071]                             if (is.null(name)) 
[13:21:35.071]                               next
[13:21:35.071]                             if (!grepl(pattern, name)) 
[13:21:35.071]                               next
[13:21:35.071]                             invokeRestart(restart)
[13:21:35.071]                             muffled <- TRUE
[13:21:35.071]                             break
[13:21:35.071]                           }
[13:21:35.071]                         }
[13:21:35.071]                       }
[13:21:35.071]                       invisible(muffled)
[13:21:35.071]                     }
[13:21:35.071]                     muffleCondition(cond, pattern = "^muffle")
[13:21:35.071]                   }
[13:21:35.071]                 }
[13:21:35.071]                 else {
[13:21:35.071]                   if (TRUE) {
[13:21:35.071]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:35.071]                     {
[13:21:35.071]                       inherits <- base::inherits
[13:21:35.071]                       invokeRestart <- base::invokeRestart
[13:21:35.071]                       is.null <- base::is.null
[13:21:35.071]                       muffled <- FALSE
[13:21:35.071]                       if (inherits(cond, "message")) {
[13:21:35.071]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:35.071]                         if (muffled) 
[13:21:35.071]                           invokeRestart("muffleMessage")
[13:21:35.071]                       }
[13:21:35.071]                       else if (inherits(cond, "warning")) {
[13:21:35.071]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:35.071]                         if (muffled) 
[13:21:35.071]                           invokeRestart("muffleWarning")
[13:21:35.071]                       }
[13:21:35.071]                       else if (inherits(cond, "condition")) {
[13:21:35.071]                         if (!is.null(pattern)) {
[13:21:35.071]                           computeRestarts <- base::computeRestarts
[13:21:35.071]                           grepl <- base::grepl
[13:21:35.071]                           restarts <- computeRestarts(cond)
[13:21:35.071]                           for (restart in restarts) {
[13:21:35.071]                             name <- restart$name
[13:21:35.071]                             if (is.null(name)) 
[13:21:35.071]                               next
[13:21:35.071]                             if (!grepl(pattern, name)) 
[13:21:35.071]                               next
[13:21:35.071]                             invokeRestart(restart)
[13:21:35.071]                             muffled <- TRUE
[13:21:35.071]                             break
[13:21:35.071]                           }
[13:21:35.071]                         }
[13:21:35.071]                       }
[13:21:35.071]                       invisible(muffled)
[13:21:35.071]                     }
[13:21:35.071]                     muffleCondition(cond, pattern = "^muffle")
[13:21:35.071]                   }
[13:21:35.071]                 }
[13:21:35.071]             }
[13:21:35.071]         }))
[13:21:35.071]     }, error = function(ex) {
[13:21:35.071]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:35.071]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:35.071]                 ...future.rng), started = ...future.startTime, 
[13:21:35.071]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:35.071]             version = "1.8"), class = "FutureResult")
[13:21:35.071]     }, finally = {
[13:21:35.071]         if (!identical(...future.workdir, getwd())) 
[13:21:35.071]             setwd(...future.workdir)
[13:21:35.071]         {
[13:21:35.071]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:35.071]                 ...future.oldOptions$nwarnings <- NULL
[13:21:35.071]             }
[13:21:35.071]             base::options(...future.oldOptions)
[13:21:35.071]             if (.Platform$OS.type == "windows") {
[13:21:35.071]                 old_names <- names(...future.oldEnvVars)
[13:21:35.071]                 envs <- base::Sys.getenv()
[13:21:35.071]                 names <- names(envs)
[13:21:35.071]                 common <- intersect(names, old_names)
[13:21:35.071]                 added <- setdiff(names, old_names)
[13:21:35.071]                 removed <- setdiff(old_names, names)
[13:21:35.071]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:35.071]                   envs[common]]
[13:21:35.071]                 NAMES <- toupper(changed)
[13:21:35.071]                 args <- list()
[13:21:35.071]                 for (kk in seq_along(NAMES)) {
[13:21:35.071]                   name <- changed[[kk]]
[13:21:35.071]                   NAME <- NAMES[[kk]]
[13:21:35.071]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:35.071]                     next
[13:21:35.071]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:35.071]                 }
[13:21:35.071]                 NAMES <- toupper(added)
[13:21:35.071]                 for (kk in seq_along(NAMES)) {
[13:21:35.071]                   name <- added[[kk]]
[13:21:35.071]                   NAME <- NAMES[[kk]]
[13:21:35.071]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:35.071]                     next
[13:21:35.071]                   args[[name]] <- ""
[13:21:35.071]                 }
[13:21:35.071]                 NAMES <- toupper(removed)
[13:21:35.071]                 for (kk in seq_along(NAMES)) {
[13:21:35.071]                   name <- removed[[kk]]
[13:21:35.071]                   NAME <- NAMES[[kk]]
[13:21:35.071]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:35.071]                     next
[13:21:35.071]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:35.071]                 }
[13:21:35.071]                 if (length(args) > 0) 
[13:21:35.071]                   base::do.call(base::Sys.setenv, args = args)
[13:21:35.071]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:35.071]             }
[13:21:35.071]             else {
[13:21:35.071]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:35.071]             }
[13:21:35.071]             {
[13:21:35.071]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:35.071]                   0L) {
[13:21:35.071]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:35.071]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:35.071]                   base::options(opts)
[13:21:35.071]                 }
[13:21:35.071]                 {
[13:21:35.071]                   {
[13:21:35.071]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:35.071]                     NULL
[13:21:35.071]                   }
[13:21:35.071]                   options(future.plan = NULL)
[13:21:35.071]                   if (is.na(NA_character_)) 
[13:21:35.071]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:35.071]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:35.071]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:35.071]                     envir = parent.frame()) 
[13:21:35.071]                   {
[13:21:35.071]                     default_workers <- missing(workers)
[13:21:35.071]                     if (is.function(workers)) 
[13:21:35.071]                       workers <- workers()
[13:21:35.071]                     workers <- structure(as.integer(workers), 
[13:21:35.071]                       class = class(workers))
[13:21:35.071]                     stop_if_not(is.finite(workers), workers >= 
[13:21:35.071]                       1L)
[13:21:35.071]                     if ((workers == 1L && !inherits(workers, 
[13:21:35.071]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:35.071]                       if (default_workers) 
[13:21:35.071]                         supportsMulticore(warn = TRUE)
[13:21:35.071]                       return(sequential(..., envir = envir))
[13:21:35.071]                     }
[13:21:35.071]                     oopts <- options(mc.cores = workers)
[13:21:35.071]                     on.exit(options(oopts))
[13:21:35.071]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:35.071]                       envir = envir)
[13:21:35.071]                     if (!future$lazy) 
[13:21:35.071]                       future <- run(future)
[13:21:35.071]                     invisible(future)
[13:21:35.071]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:35.071]                 }
[13:21:35.071]             }
[13:21:35.071]         }
[13:21:35.071]     })
[13:21:35.071]     if (TRUE) {
[13:21:35.071]         base::sink(type = "output", split = FALSE)
[13:21:35.071]         if (TRUE) {
[13:21:35.071]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:35.071]         }
[13:21:35.071]         else {
[13:21:35.071]             ...future.result["stdout"] <- base::list(NULL)
[13:21:35.071]         }
[13:21:35.071]         base::close(...future.stdout)
[13:21:35.071]         ...future.stdout <- NULL
[13:21:35.071]     }
[13:21:35.071]     ...future.result$conditions <- ...future.conditions
[13:21:35.071]     ...future.result$finished <- base::Sys.time()
[13:21:35.071]     ...future.result
[13:21:35.071] }
[13:21:35.074] assign_globals() ...
[13:21:35.074] List of 11
[13:21:35.074]  $ ...future.FUN            :function (x, ...)  
[13:21:35.074]  $ x_FUN                    :function (x, y)  
[13:21:35.074]  $ times                    : int 15
[13:21:35.074]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:35.074]  $ stop_if_not              :function (...)  
[13:21:35.074]  $ dim                      : int [1:2] 3 5
[13:21:35.074]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:21:35.074]  $ future.call.arguments    :List of 1
[13:21:35.074]   ..$ y: num [1:5] 2 4 6 8 10
[13:21:35.074]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:35.074]  $ ...future.elements_ii    :List of 2
[13:21:35.074]   ..$ A: num 50
[13:21:35.074]   ..$ B: num 60
[13:21:35.074]  $ ...future.seeds_ii       : NULL
[13:21:35.074]  $ ...future.globals.maxSize: NULL
[13:21:35.074]  - attr(*, "where")=List of 11
[13:21:35.074]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:35.074]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:35.074]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:35.074]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:35.074]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:35.074]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:35.074]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:35.074]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:35.074]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:35.074]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:35.074]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:35.074]  - attr(*, "resolved")= logi FALSE
[13:21:35.074]  - attr(*, "total_size")= num 98600
[13:21:35.074]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:35.074]  - attr(*, "already-done")= logi TRUE
[13:21:35.083] - copied ‘...future.FUN’ to environment
[13:21:35.083] - reassign environment for ‘x_FUN’
[13:21:35.083] - copied ‘x_FUN’ to environment
[13:21:35.083] - copied ‘times’ to environment
[13:21:35.083] - copied ‘stopf’ to environment
[13:21:35.083] - copied ‘stop_if_not’ to environment
[13:21:35.083] - copied ‘dim’ to environment
[13:21:35.083] - copied ‘valid_types’ to environment
[13:21:35.084] - copied ‘future.call.arguments’ to environment
[13:21:35.084] - copied ‘...future.elements_ii’ to environment
[13:21:35.084] - copied ‘...future.seeds_ii’ to environment
[13:21:35.087] - copied ‘...future.globals.maxSize’ to environment
[13:21:35.087] assign_globals() ... done
[13:21:35.087] requestCore(): workers = 2
[13:21:35.090] MulticoreFuture started
[13:21:35.090] - Launch lazy future ... done
[13:21:35.091] run() for ‘MulticoreFuture’ ... done
[13:21:35.091] Created future:
[13:21:35.092] plan(): Setting new future strategy stack:
[13:21:35.092] List of future strategies:
[13:21:35.092] 1. sequential:
[13:21:35.092]    - args: function (..., envir = parent.frame())
[13:21:35.092]    - tweaked: FALSE
[13:21:35.092]    - call: NULL
[13:21:35.093] plan(): nbrOfWorkers() = 1
[13:21:35.096] plan(): Setting new future strategy stack:
[13:21:35.097] List of future strategies:
[13:21:35.097] 1. multicore:
[13:21:35.097]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:35.097]    - tweaked: FALSE
[13:21:35.097]    - call: plan(strategy)
[13:21:35.104] plan(): nbrOfWorkers() = 2
[13:21:35.092] MulticoreFuture:
[13:21:35.092] Label: ‘future_vapply-1’
[13:21:35.092] Expression:
[13:21:35.092] {
[13:21:35.092]     do.call(function(...) {
[13:21:35.092]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:35.092]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:35.092]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:35.092]             on.exit(options(oopts), add = TRUE)
[13:21:35.092]         }
[13:21:35.092]         {
[13:21:35.092]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:35.092]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:35.092]                 ...future.FUN(...future.X_jj, ...)
[13:21:35.092]             })
[13:21:35.092]         }
[13:21:35.092]     }, args = future.call.arguments)
[13:21:35.092] }
[13:21:35.092] Lazy evaluation: FALSE
[13:21:35.092] Asynchronous evaluation: TRUE
[13:21:35.092] Local evaluation: TRUE
[13:21:35.092] Environment: R_GlobalEnv
[13:21:35.092] Capture standard output: TRUE
[13:21:35.092] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:35.092] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:35.092] Packages: 1 packages (‘future.apply’)
[13:21:35.092] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:35.092] Resolved: TRUE
[13:21:35.092] Value: <not collected>
[13:21:35.092] Conditions captured: <none>
[13:21:35.092] Early signaling: FALSE
[13:21:35.092] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:35.092] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:35.106] Chunk #1 of 2 ... DONE
[13:21:35.106] Chunk #2 of 2 ...
[13:21:35.107]  - Finding globals in 'X' for chunk #2 ...
[13:21:35.107] getGlobalsAndPackages() ...
[13:21:35.107] Searching for globals...
[13:21:35.108] 
[13:21:35.108] Searching for globals ... DONE
[13:21:35.108] - globals: [0] <none>
[13:21:35.108] getGlobalsAndPackages() ... DONE
[13:21:35.108]    + additional globals found: [n=0] 
[13:21:35.109]    + additional namespaces needed: [n=0] 
[13:21:35.109]  - Finding globals in 'X' for chunk #2 ... DONE
[13:21:35.109]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:35.109]  - seeds: <none>
[13:21:35.109]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:35.110] getGlobalsAndPackages() ...
[13:21:35.110] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:35.110] Resolving globals: FALSE
[13:21:35.111] Tweak future expression to call with '...' arguments ...
[13:21:35.111] {
[13:21:35.111]     do.call(function(...) {
[13:21:35.111]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:35.111]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:35.111]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:35.111]             on.exit(options(oopts), add = TRUE)
[13:21:35.111]         }
[13:21:35.111]         {
[13:21:35.111]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:35.111]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:35.111]                 ...future.FUN(...future.X_jj, ...)
[13:21:35.111]             })
[13:21:35.111]         }
[13:21:35.111]     }, args = future.call.arguments)
[13:21:35.111] }
[13:21:35.111] Tweak future expression to call with '...' arguments ... DONE
[13:21:35.113] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:35.113] - packages: [1] ‘future.apply’
[13:21:35.113] getGlobalsAndPackages() ... DONE
[13:21:35.114] run() for ‘Future’ ...
[13:21:35.114] - state: ‘created’
[13:21:35.115] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:35.120] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:35.120] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:35.121]   - Field: ‘label’
[13:21:35.121]   - Field: ‘local’
[13:21:35.121]   - Field: ‘owner’
[13:21:35.121]   - Field: ‘envir’
[13:21:35.122]   - Field: ‘workers’
[13:21:35.122]   - Field: ‘packages’
[13:21:35.122]   - Field: ‘gc’
[13:21:35.122]   - Field: ‘job’
[13:21:35.122]   - Field: ‘conditions’
[13:21:35.122]   - Field: ‘expr’
[13:21:35.123]   - Field: ‘uuid’
[13:21:35.123]   - Field: ‘seed’
[13:21:35.123]   - Field: ‘version’
[13:21:35.123]   - Field: ‘result’
[13:21:35.123]   - Field: ‘asynchronous’
[13:21:35.123]   - Field: ‘calls’
[13:21:35.124]   - Field: ‘globals’
[13:21:35.124]   - Field: ‘stdout’
[13:21:35.124]   - Field: ‘earlySignal’
[13:21:35.124]   - Field: ‘lazy’
[13:21:35.124]   - Field: ‘state’
[13:21:35.124] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:35.124] - Launch lazy future ...
[13:21:35.125] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:35.125] Packages needed by future strategies (n = 0): <none>
[13:21:35.126] {
[13:21:35.126]     {
[13:21:35.126]         {
[13:21:35.126]             ...future.startTime <- base::Sys.time()
[13:21:35.126]             {
[13:21:35.126]                 {
[13:21:35.126]                   {
[13:21:35.126]                     {
[13:21:35.126]                       {
[13:21:35.126]                         base::local({
[13:21:35.126]                           has_future <- base::requireNamespace("future", 
[13:21:35.126]                             quietly = TRUE)
[13:21:35.126]                           if (has_future) {
[13:21:35.126]                             ns <- base::getNamespace("future")
[13:21:35.126]                             version <- ns[[".package"]][["version"]]
[13:21:35.126]                             if (is.null(version)) 
[13:21:35.126]                               version <- utils::packageVersion("future")
[13:21:35.126]                           }
[13:21:35.126]                           else {
[13:21:35.126]                             version <- NULL
[13:21:35.126]                           }
[13:21:35.126]                           if (!has_future || version < "1.8.0") {
[13:21:35.126]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:35.126]                               "", base::R.version$version.string), 
[13:21:35.126]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:35.126]                                 base::R.version$platform, 8 * 
[13:21:35.126]                                   base::.Machine$sizeof.pointer), 
[13:21:35.126]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:35.126]                                 "release", "version")], collapse = " "), 
[13:21:35.126]                               hostname = base::Sys.info()[["nodename"]])
[13:21:35.126]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:35.126]                               info)
[13:21:35.126]                             info <- base::paste(info, collapse = "; ")
[13:21:35.126]                             if (!has_future) {
[13:21:35.126]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:35.126]                                 info)
[13:21:35.126]                             }
[13:21:35.126]                             else {
[13:21:35.126]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:35.126]                                 info, version)
[13:21:35.126]                             }
[13:21:35.126]                             base::stop(msg)
[13:21:35.126]                           }
[13:21:35.126]                         })
[13:21:35.126]                       }
[13:21:35.126]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:35.126]                       base::options(mc.cores = 1L)
[13:21:35.126]                     }
[13:21:35.126]                     base::local({
[13:21:35.126]                       for (pkg in "future.apply") {
[13:21:35.126]                         base::loadNamespace(pkg)
[13:21:35.126]                         base::library(pkg, character.only = TRUE)
[13:21:35.126]                       }
[13:21:35.126]                     })
[13:21:35.126]                   }
[13:21:35.126]                   options(future.plan = NULL)
[13:21:35.126]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:35.126]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:35.126]                 }
[13:21:35.126]                 ...future.workdir <- getwd()
[13:21:35.126]             }
[13:21:35.126]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:35.126]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:35.126]         }
[13:21:35.126]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:35.126]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:35.126]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:35.126]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:35.126]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:35.126]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:35.126]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:35.126]             base::names(...future.oldOptions))
[13:21:35.126]     }
[13:21:35.126]     if (FALSE) {
[13:21:35.126]     }
[13:21:35.126]     else {
[13:21:35.126]         if (TRUE) {
[13:21:35.126]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:35.126]                 open = "w")
[13:21:35.126]         }
[13:21:35.126]         else {
[13:21:35.126]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:35.126]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:35.126]         }
[13:21:35.126]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:35.126]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:35.126]             base::sink(type = "output", split = FALSE)
[13:21:35.126]             base::close(...future.stdout)
[13:21:35.126]         }, add = TRUE)
[13:21:35.126]     }
[13:21:35.126]     ...future.frame <- base::sys.nframe()
[13:21:35.126]     ...future.conditions <- base::list()
[13:21:35.126]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:35.126]     if (FALSE) {
[13:21:35.126]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:35.126]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:35.126]     }
[13:21:35.126]     ...future.result <- base::tryCatch({
[13:21:35.126]         base::withCallingHandlers({
[13:21:35.126]             ...future.value <- base::withVisible(base::local({
[13:21:35.126]                 withCallingHandlers({
[13:21:35.126]                   {
[13:21:35.126]                     do.call(function(...) {
[13:21:35.126]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:35.126]                       if (!identical(...future.globals.maxSize.org, 
[13:21:35.126]                         ...future.globals.maxSize)) {
[13:21:35.126]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:35.126]                         on.exit(options(oopts), add = TRUE)
[13:21:35.126]                       }
[13:21:35.126]                       {
[13:21:35.126]                         lapply(seq_along(...future.elements_ii), 
[13:21:35.126]                           FUN = function(jj) {
[13:21:35.126]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:35.126]                             ...future.FUN(...future.X_jj, ...)
[13:21:35.126]                           })
[13:21:35.126]                       }
[13:21:35.126]                     }, args = future.call.arguments)
[13:21:35.126]                   }
[13:21:35.126]                 }, immediateCondition = function(cond) {
[13:21:35.126]                   save_rds <- function (object, pathname, ...) 
[13:21:35.126]                   {
[13:21:35.126]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:35.126]                     if (file_test("-f", pathname_tmp)) {
[13:21:35.126]                       fi_tmp <- file.info(pathname_tmp)
[13:21:35.126]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:35.126]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:35.126]                         fi_tmp[["mtime"]])
[13:21:35.126]                     }
[13:21:35.126]                     tryCatch({
[13:21:35.126]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:35.126]                     }, error = function(ex) {
[13:21:35.126]                       msg <- conditionMessage(ex)
[13:21:35.126]                       fi_tmp <- file.info(pathname_tmp)
[13:21:35.126]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:35.126]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:35.126]                         fi_tmp[["mtime"]], msg)
[13:21:35.126]                       ex$message <- msg
[13:21:35.126]                       stop(ex)
[13:21:35.126]                     })
[13:21:35.126]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:35.126]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:35.126]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:35.126]                       fi_tmp <- file.info(pathname_tmp)
[13:21:35.126]                       fi <- file.info(pathname)
[13:21:35.126]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:35.126]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:35.126]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:35.126]                         fi[["size"]], fi[["mtime"]])
[13:21:35.126]                       stop(msg)
[13:21:35.126]                     }
[13:21:35.126]                     invisible(pathname)
[13:21:35.126]                   }
[13:21:35.126]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:35.126]                     rootPath = tempdir()) 
[13:21:35.126]                   {
[13:21:35.126]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:35.126]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:35.126]                       tmpdir = path, fileext = ".rds")
[13:21:35.126]                     save_rds(obj, file)
[13:21:35.126]                   }
[13:21:35.126]                   saveImmediateCondition(cond, path = "/tmp/RtmpbpFWGO/.future/immediateConditions")
[13:21:35.126]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:35.126]                   {
[13:21:35.126]                     inherits <- base::inherits
[13:21:35.126]                     invokeRestart <- base::invokeRestart
[13:21:35.126]                     is.null <- base::is.null
[13:21:35.126]                     muffled <- FALSE
[13:21:35.126]                     if (inherits(cond, "message")) {
[13:21:35.126]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:35.126]                       if (muffled) 
[13:21:35.126]                         invokeRestart("muffleMessage")
[13:21:35.126]                     }
[13:21:35.126]                     else if (inherits(cond, "warning")) {
[13:21:35.126]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:35.126]                       if (muffled) 
[13:21:35.126]                         invokeRestart("muffleWarning")
[13:21:35.126]                     }
[13:21:35.126]                     else if (inherits(cond, "condition")) {
[13:21:35.126]                       if (!is.null(pattern)) {
[13:21:35.126]                         computeRestarts <- base::computeRestarts
[13:21:35.126]                         grepl <- base::grepl
[13:21:35.126]                         restarts <- computeRestarts(cond)
[13:21:35.126]                         for (restart in restarts) {
[13:21:35.126]                           name <- restart$name
[13:21:35.126]                           if (is.null(name)) 
[13:21:35.126]                             next
[13:21:35.126]                           if (!grepl(pattern, name)) 
[13:21:35.126]                             next
[13:21:35.126]                           invokeRestart(restart)
[13:21:35.126]                           muffled <- TRUE
[13:21:35.126]                           break
[13:21:35.126]                         }
[13:21:35.126]                       }
[13:21:35.126]                     }
[13:21:35.126]                     invisible(muffled)
[13:21:35.126]                   }
[13:21:35.126]                   muffleCondition(cond)
[13:21:35.126]                 })
[13:21:35.126]             }))
[13:21:35.126]             future::FutureResult(value = ...future.value$value, 
[13:21:35.126]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:35.126]                   ...future.rng), globalenv = if (FALSE) 
[13:21:35.126]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:35.126]                     ...future.globalenv.names))
[13:21:35.126]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:35.126]         }, condition = base::local({
[13:21:35.126]             c <- base::c
[13:21:35.126]             inherits <- base::inherits
[13:21:35.126]             invokeRestart <- base::invokeRestart
[13:21:35.126]             length <- base::length
[13:21:35.126]             list <- base::list
[13:21:35.126]             seq.int <- base::seq.int
[13:21:35.126]             signalCondition <- base::signalCondition
[13:21:35.126]             sys.calls <- base::sys.calls
[13:21:35.126]             `[[` <- base::`[[`
[13:21:35.126]             `+` <- base::`+`
[13:21:35.126]             `<<-` <- base::`<<-`
[13:21:35.126]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:35.126]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:35.126]                   3L)]
[13:21:35.126]             }
[13:21:35.126]             function(cond) {
[13:21:35.126]                 is_error <- inherits(cond, "error")
[13:21:35.126]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:35.126]                   NULL)
[13:21:35.126]                 if (is_error) {
[13:21:35.126]                   sessionInformation <- function() {
[13:21:35.126]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:35.126]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:35.126]                       search = base::search(), system = base::Sys.info())
[13:21:35.126]                   }
[13:21:35.126]                   ...future.conditions[[length(...future.conditions) + 
[13:21:35.126]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:35.126]                     cond$call), session = sessionInformation(), 
[13:21:35.126]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:35.126]                   signalCondition(cond)
[13:21:35.126]                 }
[13:21:35.126]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:35.126]                 "immediateCondition"))) {
[13:21:35.126]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:35.126]                   ...future.conditions[[length(...future.conditions) + 
[13:21:35.126]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:35.126]                   if (TRUE && !signal) {
[13:21:35.126]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:35.126]                     {
[13:21:35.126]                       inherits <- base::inherits
[13:21:35.126]                       invokeRestart <- base::invokeRestart
[13:21:35.126]                       is.null <- base::is.null
[13:21:35.126]                       muffled <- FALSE
[13:21:35.126]                       if (inherits(cond, "message")) {
[13:21:35.126]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:35.126]                         if (muffled) 
[13:21:35.126]                           invokeRestart("muffleMessage")
[13:21:35.126]                       }
[13:21:35.126]                       else if (inherits(cond, "warning")) {
[13:21:35.126]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:35.126]                         if (muffled) 
[13:21:35.126]                           invokeRestart("muffleWarning")
[13:21:35.126]                       }
[13:21:35.126]                       else if (inherits(cond, "condition")) {
[13:21:35.126]                         if (!is.null(pattern)) {
[13:21:35.126]                           computeRestarts <- base::computeRestarts
[13:21:35.126]                           grepl <- base::grepl
[13:21:35.126]                           restarts <- computeRestarts(cond)
[13:21:35.126]                           for (restart in restarts) {
[13:21:35.126]                             name <- restart$name
[13:21:35.126]                             if (is.null(name)) 
[13:21:35.126]                               next
[13:21:35.126]                             if (!grepl(pattern, name)) 
[13:21:35.126]                               next
[13:21:35.126]                             invokeRestart(restart)
[13:21:35.126]                             muffled <- TRUE
[13:21:35.126]                             break
[13:21:35.126]                           }
[13:21:35.126]                         }
[13:21:35.126]                       }
[13:21:35.126]                       invisible(muffled)
[13:21:35.126]                     }
[13:21:35.126]                     muffleCondition(cond, pattern = "^muffle")
[13:21:35.126]                   }
[13:21:35.126]                 }
[13:21:35.126]                 else {
[13:21:35.126]                   if (TRUE) {
[13:21:35.126]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:35.126]                     {
[13:21:35.126]                       inherits <- base::inherits
[13:21:35.126]                       invokeRestart <- base::invokeRestart
[13:21:35.126]                       is.null <- base::is.null
[13:21:35.126]                       muffled <- FALSE
[13:21:35.126]                       if (inherits(cond, "message")) {
[13:21:35.126]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:35.126]                         if (muffled) 
[13:21:35.126]                           invokeRestart("muffleMessage")
[13:21:35.126]                       }
[13:21:35.126]                       else if (inherits(cond, "warning")) {
[13:21:35.126]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:35.126]                         if (muffled) 
[13:21:35.126]                           invokeRestart("muffleWarning")
[13:21:35.126]                       }
[13:21:35.126]                       else if (inherits(cond, "condition")) {
[13:21:35.126]                         if (!is.null(pattern)) {
[13:21:35.126]                           computeRestarts <- base::computeRestarts
[13:21:35.126]                           grepl <- base::grepl
[13:21:35.126]                           restarts <- computeRestarts(cond)
[13:21:35.126]                           for (restart in restarts) {
[13:21:35.126]                             name <- restart$name
[13:21:35.126]                             if (is.null(name)) 
[13:21:35.126]                               next
[13:21:35.126]                             if (!grepl(pattern, name)) 
[13:21:35.126]                               next
[13:21:35.126]                             invokeRestart(restart)
[13:21:35.126]                             muffled <- TRUE
[13:21:35.126]                             break
[13:21:35.126]                           }
[13:21:35.126]                         }
[13:21:35.126]                       }
[13:21:35.126]                       invisible(muffled)
[13:21:35.126]                     }
[13:21:35.126]                     muffleCondition(cond, pattern = "^muffle")
[13:21:35.126]                   }
[13:21:35.126]                 }
[13:21:35.126]             }
[13:21:35.126]         }))
[13:21:35.126]     }, error = function(ex) {
[13:21:35.126]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:35.126]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:35.126]                 ...future.rng), started = ...future.startTime, 
[13:21:35.126]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:35.126]             version = "1.8"), class = "FutureResult")
[13:21:35.126]     }, finally = {
[13:21:35.126]         if (!identical(...future.workdir, getwd())) 
[13:21:35.126]             setwd(...future.workdir)
[13:21:35.126]         {
[13:21:35.126]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:35.126]                 ...future.oldOptions$nwarnings <- NULL
[13:21:35.126]             }
[13:21:35.126]             base::options(...future.oldOptions)
[13:21:35.126]             if (.Platform$OS.type == "windows") {
[13:21:35.126]                 old_names <- names(...future.oldEnvVars)
[13:21:35.126]                 envs <- base::Sys.getenv()
[13:21:35.126]                 names <- names(envs)
[13:21:35.126]                 common <- intersect(names, old_names)
[13:21:35.126]                 added <- setdiff(names, old_names)
[13:21:35.126]                 removed <- setdiff(old_names, names)
[13:21:35.126]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:35.126]                   envs[common]]
[13:21:35.126]                 NAMES <- toupper(changed)
[13:21:35.126]                 args <- list()
[13:21:35.126]                 for (kk in seq_along(NAMES)) {
[13:21:35.126]                   name <- changed[[kk]]
[13:21:35.126]                   NAME <- NAMES[[kk]]
[13:21:35.126]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:35.126]                     next
[13:21:35.126]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:35.126]                 }
[13:21:35.126]                 NAMES <- toupper(added)
[13:21:35.126]                 for (kk in seq_along(NAMES)) {
[13:21:35.126]                   name <- added[[kk]]
[13:21:35.126]                   NAME <- NAMES[[kk]]
[13:21:35.126]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:35.126]                     next
[13:21:35.126]                   args[[name]] <- ""
[13:21:35.126]                 }
[13:21:35.126]                 NAMES <- toupper(removed)
[13:21:35.126]                 for (kk in seq_along(NAMES)) {
[13:21:35.126]                   name <- removed[[kk]]
[13:21:35.126]                   NAME <- NAMES[[kk]]
[13:21:35.126]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:35.126]                     next
[13:21:35.126]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:35.126]                 }
[13:21:35.126]                 if (length(args) > 0) 
[13:21:35.126]                   base::do.call(base::Sys.setenv, args = args)
[13:21:35.126]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:35.126]             }
[13:21:35.126]             else {
[13:21:35.126]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:35.126]             }
[13:21:35.126]             {
[13:21:35.126]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:35.126]                   0L) {
[13:21:35.126]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:35.126]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:35.126]                   base::options(opts)
[13:21:35.126]                 }
[13:21:35.126]                 {
[13:21:35.126]                   {
[13:21:35.126]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:35.126]                     NULL
[13:21:35.126]                   }
[13:21:35.126]                   options(future.plan = NULL)
[13:21:35.126]                   if (is.na(NA_character_)) 
[13:21:35.126]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:35.126]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:35.126]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:35.126]                     envir = parent.frame()) 
[13:21:35.126]                   {
[13:21:35.126]                     default_workers <- missing(workers)
[13:21:35.126]                     if (is.function(workers)) 
[13:21:35.126]                       workers <- workers()
[13:21:35.126]                     workers <- structure(as.integer(workers), 
[13:21:35.126]                       class = class(workers))
[13:21:35.126]                     stop_if_not(is.finite(workers), workers >= 
[13:21:35.126]                       1L)
[13:21:35.126]                     if ((workers == 1L && !inherits(workers, 
[13:21:35.126]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:35.126]                       if (default_workers) 
[13:21:35.126]                         supportsMulticore(warn = TRUE)
[13:21:35.126]                       return(sequential(..., envir = envir))
[13:21:35.126]                     }
[13:21:35.126]                     oopts <- options(mc.cores = workers)
[13:21:35.126]                     on.exit(options(oopts))
[13:21:35.126]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:35.126]                       envir = envir)
[13:21:35.126]                     if (!future$lazy) 
[13:21:35.126]                       future <- run(future)
[13:21:35.126]                     invisible(future)
[13:21:35.126]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:35.126]                 }
[13:21:35.126]             }
[13:21:35.126]         }
[13:21:35.126]     })
[13:21:35.126]     if (TRUE) {
[13:21:35.126]         base::sink(type = "output", split = FALSE)
[13:21:35.126]         if (TRUE) {
[13:21:35.126]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:35.126]         }
[13:21:35.126]         else {
[13:21:35.126]             ...future.result["stdout"] <- base::list(NULL)
[13:21:35.126]         }
[13:21:35.126]         base::close(...future.stdout)
[13:21:35.126]         ...future.stdout <- NULL
[13:21:35.126]     }
[13:21:35.126]     ...future.result$conditions <- ...future.conditions
[13:21:35.126]     ...future.result$finished <- base::Sys.time()
[13:21:35.126]     ...future.result
[13:21:35.126] }
[13:21:35.130] assign_globals() ...
[13:21:35.130] List of 11
[13:21:35.130]  $ ...future.FUN            :function (x, ...)  
[13:21:35.130]  $ x_FUN                    :function (x, y)  
[13:21:35.130]  $ times                    : int 15
[13:21:35.130]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:35.130]  $ stop_if_not              :function (...)  
[13:21:35.130]  $ dim                      : int [1:2] 3 5
[13:21:35.130]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:21:35.130]  $ future.call.arguments    :List of 1
[13:21:35.130]   ..$ y: num [1:5] 2 4 6 8 10
[13:21:35.130]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:35.130]  $ ...future.elements_ii    :List of 2
[13:21:35.130]   ..$ C: num 70
[13:21:35.130]   ..$ D: num 80
[13:21:35.130]  $ ...future.seeds_ii       : NULL
[13:21:35.130]  $ ...future.globals.maxSize: NULL
[13:21:35.130]  - attr(*, "where")=List of 11
[13:21:35.130]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:35.130]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:35.130]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:35.130]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:35.130]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:35.130]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:35.130]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:35.130]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:35.130]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:35.130]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:35.130]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:35.130]  - attr(*, "resolved")= logi FALSE
[13:21:35.130]  - attr(*, "total_size")= num 98600
[13:21:35.130]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:35.130]  - attr(*, "already-done")= logi TRUE
[13:21:35.143] - copied ‘...future.FUN’ to environment
[13:21:35.143] - reassign environment for ‘x_FUN’
[13:21:35.144] - copied ‘x_FUN’ to environment
[13:21:35.144] - copied ‘times’ to environment
[13:21:35.144] - copied ‘stopf’ to environment
[13:21:35.144] - copied ‘stop_if_not’ to environment
[13:21:35.144] - copied ‘dim’ to environment
[13:21:35.144] - copied ‘valid_types’ to environment
[13:21:35.144] - copied ‘future.call.arguments’ to environment
[13:21:35.145] - copied ‘...future.elements_ii’ to environment
[13:21:35.145] - copied ‘...future.seeds_ii’ to environment
[13:21:35.145] - copied ‘...future.globals.maxSize’ to environment
[13:21:35.145] assign_globals() ... done
[13:21:35.145] requestCore(): workers = 2
[13:21:35.148] MulticoreFuture started
[13:21:35.149] - Launch lazy future ... done
[13:21:35.149] run() for ‘MulticoreFuture’ ... done
[13:21:35.150] Created future:
[13:21:35.150] plan(): Setting new future strategy stack:
[13:21:35.150] List of future strategies:
[13:21:35.150] 1. sequential:
[13:21:35.150]    - args: function (..., envir = parent.frame())
[13:21:35.150]    - tweaked: FALSE
[13:21:35.150]    - call: NULL
[13:21:35.151] plan(): nbrOfWorkers() = 1
[13:21:35.154] plan(): Setting new future strategy stack:
[13:21:35.155] List of future strategies:
[13:21:35.155] 1. multicore:
[13:21:35.155]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:35.155]    - tweaked: FALSE
[13:21:35.155]    - call: plan(strategy)
[13:21:35.162] plan(): nbrOfWorkers() = 2
[13:21:35.150] MulticoreFuture:
[13:21:35.150] Label: ‘future_vapply-2’
[13:21:35.150] Expression:
[13:21:35.150] {
[13:21:35.150]     do.call(function(...) {
[13:21:35.150]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:35.150]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:35.150]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:35.150]             on.exit(options(oopts), add = TRUE)
[13:21:35.150]         }
[13:21:35.150]         {
[13:21:35.150]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:35.150]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:35.150]                 ...future.FUN(...future.X_jj, ...)
[13:21:35.150]             })
[13:21:35.150]         }
[13:21:35.150]     }, args = future.call.arguments)
[13:21:35.150] }
[13:21:35.150] Lazy evaluation: FALSE
[13:21:35.150] Asynchronous evaluation: TRUE
[13:21:35.150] Local evaluation: TRUE
[13:21:35.150] Environment: R_GlobalEnv
[13:21:35.150] Capture standard output: TRUE
[13:21:35.150] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:35.150] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:35.150] Packages: 1 packages (‘future.apply’)
[13:21:35.150] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:35.150] Resolved: TRUE
[13:21:35.150] Value: <not collected>
[13:21:35.150] Conditions captured: <none>
[13:21:35.150] Early signaling: FALSE
[13:21:35.150] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:35.150] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:35.164] Chunk #2 of 2 ... DONE
[13:21:35.164] Launching 2 futures (chunks) ... DONE
[13:21:35.164] Resolving 2 futures (chunks) ...
[13:21:35.164] resolve() on list ...
[13:21:35.165]  recursive: 0
[13:21:35.165]  length: 2
[13:21:35.165] 
[13:21:35.166] Future #1
[13:21:35.166] result() for MulticoreFuture ...
[13:21:35.167] result() for MulticoreFuture ...
[13:21:35.167] result() for MulticoreFuture ... done
[13:21:35.167] result() for MulticoreFuture ... done
[13:21:35.168] result() for MulticoreFuture ...
[13:21:35.168] result() for MulticoreFuture ... done
[13:21:35.168] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:21:35.168] - nx: 2
[13:21:35.168] - relay: TRUE
[13:21:35.169] - stdout: TRUE
[13:21:35.169] - signal: TRUE
[13:21:35.169] - resignal: FALSE
[13:21:35.169] - force: TRUE
[13:21:35.170] - relayed: [n=2] FALSE, FALSE
[13:21:35.170] - queued futures: [n=2] FALSE, FALSE
[13:21:35.170]  - until=1
[13:21:35.171]  - relaying element #1
[13:21:35.171] result() for MulticoreFuture ...
[13:21:35.171] result() for MulticoreFuture ... done
[13:21:35.171] result() for MulticoreFuture ...
[13:21:35.171] result() for MulticoreFuture ... done
[13:21:35.172] result() for MulticoreFuture ...
[13:21:35.172] result() for MulticoreFuture ... done
[13:21:35.172] result() for MulticoreFuture ...
[13:21:35.172] result() for MulticoreFuture ... done
[13:21:35.173] - relayed: [n=2] TRUE, FALSE
[13:21:35.173] - queued futures: [n=2] TRUE, FALSE
[13:21:35.173] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:21:35.173]  length: 1 (resolved future 1)
[13:21:35.174] Future #2
[13:21:35.174] result() for MulticoreFuture ...
[13:21:35.174] result() for MulticoreFuture ...
[13:21:35.175] result() for MulticoreFuture ... done
[13:21:35.175] result() for MulticoreFuture ... done
[13:21:35.175] result() for MulticoreFuture ...
[13:21:35.175] result() for MulticoreFuture ... done
[13:21:35.175] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:21:35.175] - nx: 2
[13:21:35.175] - relay: TRUE
[13:21:35.176] - stdout: TRUE
[13:21:35.176] - signal: TRUE
[13:21:35.176] - resignal: FALSE
[13:21:35.176] - force: TRUE
[13:21:35.176] - relayed: [n=2] TRUE, FALSE
[13:21:35.176] - queued futures: [n=2] TRUE, FALSE
[13:21:35.176]  - until=2
[13:21:35.176]  - relaying element #2
[13:21:35.176] result() for MulticoreFuture ...
[13:21:35.177] result() for MulticoreFuture ... done
[13:21:35.177] result() for MulticoreFuture ...
[13:21:35.177] result() for MulticoreFuture ... done
[13:21:35.177] result() for MulticoreFuture ...
[13:21:35.177] result() for MulticoreFuture ... done
[13:21:35.177] result() for MulticoreFuture ...
[13:21:35.177] result() for MulticoreFuture ... done
[13:21:35.178] - relayed: [n=2] TRUE, TRUE
[13:21:35.178] - queued futures: [n=2] TRUE, TRUE
[13:21:35.178] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:21:35.178]  length: 0 (resolved future 2)
[13:21:35.178] Relaying remaining futures
[13:21:35.178] signalConditionsASAP(NULL, pos=0) ...
[13:21:35.178] - nx: 2
[13:21:35.178] - relay: TRUE
[13:21:35.178] - stdout: TRUE
[13:21:35.178] - signal: TRUE
[13:21:35.179] - resignal: FALSE
[13:21:35.179] - force: TRUE
[13:21:35.179] - relayed: [n=2] TRUE, TRUE
[13:21:35.179] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:21:35.179] - relayed: [n=2] TRUE, TRUE
[13:21:35.179] - queued futures: [n=2] TRUE, TRUE
[13:21:35.179] signalConditionsASAP(NULL, pos=0) ... done
[13:21:35.179] resolve() on list ... DONE
[13:21:35.179] result() for MulticoreFuture ...
[13:21:35.180] result() for MulticoreFuture ... done
[13:21:35.180] result() for MulticoreFuture ...
[13:21:35.180] result() for MulticoreFuture ... done
[13:21:35.180] result() for MulticoreFuture ...
[13:21:35.180] result() for MulticoreFuture ... done
[13:21:35.180] result() for MulticoreFuture ...
[13:21:35.180] result() for MulticoreFuture ... done
[13:21:35.181]  - Number of value chunks collected: 2
[13:21:35.181] Resolving 2 futures (chunks) ... DONE
[13:21:35.181] Reducing values from 2 chunks ...
[13:21:35.181]  - Number of values collected after concatenation: 4
[13:21:35.181]  - Number of values expected: 4
[13:21:35.181] Reducing values from 2 chunks ... DONE
[13:21:35.181] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[13:21:35.183] future_lapply() ...
[13:21:35.194] Number of chunks: 2
[13:21:35.194] getGlobalsAndPackagesXApply() ...
[13:21:35.194]  - future.globals: TRUE
[13:21:35.194] getGlobalsAndPackages() ...
[13:21:35.194] Searching for globals...
[13:21:35.199] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:21:35.199] Searching for globals ... DONE
[13:21:35.199] Resolving globals: FALSE
[13:21:35.200] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[13:21:35.200] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:35.201] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:35.201] - packages: [1] ‘future.apply’
[13:21:35.201] getGlobalsAndPackages() ... DONE
[13:21:35.201]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:35.201]  - needed namespaces: [n=1] ‘future.apply’
[13:21:35.201] Finding globals ... DONE
[13:21:35.201]  - use_args: TRUE
[13:21:35.201]  - Getting '...' globals ...
[13:21:35.202] resolve() on list ...
[13:21:35.202]  recursive: 0
[13:21:35.202]  length: 1
[13:21:35.202]  elements: ‘...’
[13:21:35.202]  length: 0 (resolved future 1)
[13:21:35.202] resolve() on list ... DONE
[13:21:35.202]    - '...' content: [n=0] 
[13:21:35.202] List of 1
[13:21:35.202]  $ ...: list()
[13:21:35.202]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:35.202]  - attr(*, "where")=List of 1
[13:21:35.202]   ..$ ...:<environment: 0x563b6efb1408> 
[13:21:35.202]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:35.202]  - attr(*, "resolved")= logi TRUE
[13:21:35.202]  - attr(*, "total_size")= num NA
[13:21:35.205]  - Getting '...' globals ... DONE
[13:21:35.206] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:35.206] List of 8
[13:21:35.206]  $ ...future.FUN:function (x, ...)  
[13:21:35.206]  $ x_FUN        :function (x)  
[13:21:35.206]  $ times        : int 1
[13:21:35.206]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:35.206]  $ stop_if_not  :function (...)  
[13:21:35.206]  $ dim          : NULL
[13:21:35.206]  $ valid_types  : chr "logical"
[13:21:35.206]  $ ...          : list()
[13:21:35.206]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:35.206]  - attr(*, "where")=List of 8
[13:21:35.206]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:35.206]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:35.206]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:35.206]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:35.206]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:35.206]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:35.206]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:35.206]   ..$ ...          :<environment: 0x563b6efb1408> 
[13:21:35.206]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:35.206]  - attr(*, "resolved")= logi FALSE
[13:21:35.206]  - attr(*, "total_size")= num 94200
[13:21:35.214] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:21:35.214] getGlobalsAndPackagesXApply() ... DONE
[13:21:35.215] Number of futures (= number of chunks): 2
[13:21:35.215] Launching 2 futures (chunks) ...
[13:21:35.215] Chunk #1 of 2 ...
[13:21:35.215]  - Finding globals in 'X' for chunk #1 ...
[13:21:35.215] getGlobalsAndPackages() ...
[13:21:35.215] Searching for globals...
[13:21:35.216] 
[13:21:35.216] Searching for globals ... DONE
[13:21:35.216] - globals: [0] <none>
[13:21:35.216] getGlobalsAndPackages() ... DONE
[13:21:35.216]    + additional globals found: [n=0] 
[13:21:35.216]    + additional namespaces needed: [n=0] 
[13:21:35.216]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:35.216]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:35.217]  - seeds: <none>
[13:21:35.217]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:35.217] getGlobalsAndPackages() ...
[13:21:35.217] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:35.217] Resolving globals: FALSE
[13:21:35.217] Tweak future expression to call with '...' arguments ...
[13:21:35.217] {
[13:21:35.217]     do.call(function(...) {
[13:21:35.217]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:35.217]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:35.217]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:35.217]             on.exit(options(oopts), add = TRUE)
[13:21:35.217]         }
[13:21:35.217]         {
[13:21:35.217]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:35.217]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:35.217]                 ...future.FUN(...future.X_jj, ...)
[13:21:35.217]             })
[13:21:35.217]         }
[13:21:35.217]     }, args = future.call.arguments)
[13:21:35.217] }
[13:21:35.218] Tweak future expression to call with '...' arguments ... DONE
[13:21:35.218] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:35.219] - packages: [1] ‘future.apply’
[13:21:35.219] getGlobalsAndPackages() ... DONE
[13:21:35.219] run() for ‘Future’ ...
[13:21:35.219] - state: ‘created’
[13:21:35.219] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:35.224] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:35.224] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:35.224]   - Field: ‘label’
[13:21:35.224]   - Field: ‘local’
[13:21:35.224]   - Field: ‘owner’
[13:21:35.224]   - Field: ‘envir’
[13:21:35.224]   - Field: ‘workers’
[13:21:35.224]   - Field: ‘packages’
[13:21:35.225]   - Field: ‘gc’
[13:21:35.225]   - Field: ‘job’
[13:21:35.225]   - Field: ‘conditions’
[13:21:35.225]   - Field: ‘expr’
[13:21:35.225]   - Field: ‘uuid’
[13:21:35.225]   - Field: ‘seed’
[13:21:35.225]   - Field: ‘version’
[13:21:35.225]   - Field: ‘result’
[13:21:35.225]   - Field: ‘asynchronous’
[13:21:35.225]   - Field: ‘calls’
[13:21:35.226]   - Field: ‘globals’
[13:21:35.226]   - Field: ‘stdout’
[13:21:35.226]   - Field: ‘earlySignal’
[13:21:35.226]   - Field: ‘lazy’
[13:21:35.226]   - Field: ‘state’
[13:21:35.226] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:35.226] - Launch lazy future ...
[13:21:35.226] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:35.227] Packages needed by future strategies (n = 0): <none>
[13:21:35.227] {
[13:21:35.227]     {
[13:21:35.227]         {
[13:21:35.227]             ...future.startTime <- base::Sys.time()
[13:21:35.227]             {
[13:21:35.227]                 {
[13:21:35.227]                   {
[13:21:35.227]                     {
[13:21:35.227]                       {
[13:21:35.227]                         base::local({
[13:21:35.227]                           has_future <- base::requireNamespace("future", 
[13:21:35.227]                             quietly = TRUE)
[13:21:35.227]                           if (has_future) {
[13:21:35.227]                             ns <- base::getNamespace("future")
[13:21:35.227]                             version <- ns[[".package"]][["version"]]
[13:21:35.227]                             if (is.null(version)) 
[13:21:35.227]                               version <- utils::packageVersion("future")
[13:21:35.227]                           }
[13:21:35.227]                           else {
[13:21:35.227]                             version <- NULL
[13:21:35.227]                           }
[13:21:35.227]                           if (!has_future || version < "1.8.0") {
[13:21:35.227]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:35.227]                               "", base::R.version$version.string), 
[13:21:35.227]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:35.227]                                 base::R.version$platform, 8 * 
[13:21:35.227]                                   base::.Machine$sizeof.pointer), 
[13:21:35.227]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:35.227]                                 "release", "version")], collapse = " "), 
[13:21:35.227]                               hostname = base::Sys.info()[["nodename"]])
[13:21:35.227]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:35.227]                               info)
[13:21:35.227]                             info <- base::paste(info, collapse = "; ")
[13:21:35.227]                             if (!has_future) {
[13:21:35.227]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:35.227]                                 info)
[13:21:35.227]                             }
[13:21:35.227]                             else {
[13:21:35.227]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:35.227]                                 info, version)
[13:21:35.227]                             }
[13:21:35.227]                             base::stop(msg)
[13:21:35.227]                           }
[13:21:35.227]                         })
[13:21:35.227]                       }
[13:21:35.227]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:35.227]                       base::options(mc.cores = 1L)
[13:21:35.227]                     }
[13:21:35.227]                     base::local({
[13:21:35.227]                       for (pkg in "future.apply") {
[13:21:35.227]                         base::loadNamespace(pkg)
[13:21:35.227]                         base::library(pkg, character.only = TRUE)
[13:21:35.227]                       }
[13:21:35.227]                     })
[13:21:35.227]                   }
[13:21:35.227]                   options(future.plan = NULL)
[13:21:35.227]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:35.227]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:35.227]                 }
[13:21:35.227]                 ...future.workdir <- getwd()
[13:21:35.227]             }
[13:21:35.227]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:35.227]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:35.227]         }
[13:21:35.227]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:35.227]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:35.227]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:35.227]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:35.227]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:35.227]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:35.227]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:35.227]             base::names(...future.oldOptions))
[13:21:35.227]     }
[13:21:35.227]     if (FALSE) {
[13:21:35.227]     }
[13:21:35.227]     else {
[13:21:35.227]         if (TRUE) {
[13:21:35.227]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:35.227]                 open = "w")
[13:21:35.227]         }
[13:21:35.227]         else {
[13:21:35.227]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:35.227]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:35.227]         }
[13:21:35.227]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:35.227]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:35.227]             base::sink(type = "output", split = FALSE)
[13:21:35.227]             base::close(...future.stdout)
[13:21:35.227]         }, add = TRUE)
[13:21:35.227]     }
[13:21:35.227]     ...future.frame <- base::sys.nframe()
[13:21:35.227]     ...future.conditions <- base::list()
[13:21:35.227]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:35.227]     if (FALSE) {
[13:21:35.227]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:35.227]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:35.227]     }
[13:21:35.227]     ...future.result <- base::tryCatch({
[13:21:35.227]         base::withCallingHandlers({
[13:21:35.227]             ...future.value <- base::withVisible(base::local({
[13:21:35.227]                 withCallingHandlers({
[13:21:35.227]                   {
[13:21:35.227]                     do.call(function(...) {
[13:21:35.227]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:35.227]                       if (!identical(...future.globals.maxSize.org, 
[13:21:35.227]                         ...future.globals.maxSize)) {
[13:21:35.227]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:35.227]                         on.exit(options(oopts), add = TRUE)
[13:21:35.227]                       }
[13:21:35.227]                       {
[13:21:35.227]                         lapply(seq_along(...future.elements_ii), 
[13:21:35.227]                           FUN = function(jj) {
[13:21:35.227]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:35.227]                             ...future.FUN(...future.X_jj, ...)
[13:21:35.227]                           })
[13:21:35.227]                       }
[13:21:35.227]                     }, args = future.call.arguments)
[13:21:35.227]                   }
[13:21:35.227]                 }, immediateCondition = function(cond) {
[13:21:35.227]                   save_rds <- function (object, pathname, ...) 
[13:21:35.227]                   {
[13:21:35.227]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:35.227]                     if (file_test("-f", pathname_tmp)) {
[13:21:35.227]                       fi_tmp <- file.info(pathname_tmp)
[13:21:35.227]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:35.227]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:35.227]                         fi_tmp[["mtime"]])
[13:21:35.227]                     }
[13:21:35.227]                     tryCatch({
[13:21:35.227]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:35.227]                     }, error = function(ex) {
[13:21:35.227]                       msg <- conditionMessage(ex)
[13:21:35.227]                       fi_tmp <- file.info(pathname_tmp)
[13:21:35.227]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:35.227]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:35.227]                         fi_tmp[["mtime"]], msg)
[13:21:35.227]                       ex$message <- msg
[13:21:35.227]                       stop(ex)
[13:21:35.227]                     })
[13:21:35.227]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:35.227]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:35.227]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:35.227]                       fi_tmp <- file.info(pathname_tmp)
[13:21:35.227]                       fi <- file.info(pathname)
[13:21:35.227]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:35.227]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:35.227]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:35.227]                         fi[["size"]], fi[["mtime"]])
[13:21:35.227]                       stop(msg)
[13:21:35.227]                     }
[13:21:35.227]                     invisible(pathname)
[13:21:35.227]                   }
[13:21:35.227]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:35.227]                     rootPath = tempdir()) 
[13:21:35.227]                   {
[13:21:35.227]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:35.227]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:35.227]                       tmpdir = path, fileext = ".rds")
[13:21:35.227]                     save_rds(obj, file)
[13:21:35.227]                   }
[13:21:35.227]                   saveImmediateCondition(cond, path = "/tmp/RtmpbpFWGO/.future/immediateConditions")
[13:21:35.227]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:35.227]                   {
[13:21:35.227]                     inherits <- base::inherits
[13:21:35.227]                     invokeRestart <- base::invokeRestart
[13:21:35.227]                     is.null <- base::is.null
[13:21:35.227]                     muffled <- FALSE
[13:21:35.227]                     if (inherits(cond, "message")) {
[13:21:35.227]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:35.227]                       if (muffled) 
[13:21:35.227]                         invokeRestart("muffleMessage")
[13:21:35.227]                     }
[13:21:35.227]                     else if (inherits(cond, "warning")) {
[13:21:35.227]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:35.227]                       if (muffled) 
[13:21:35.227]                         invokeRestart("muffleWarning")
[13:21:35.227]                     }
[13:21:35.227]                     else if (inherits(cond, "condition")) {
[13:21:35.227]                       if (!is.null(pattern)) {
[13:21:35.227]                         computeRestarts <- base::computeRestarts
[13:21:35.227]                         grepl <- base::grepl
[13:21:35.227]                         restarts <- computeRestarts(cond)
[13:21:35.227]                         for (restart in restarts) {
[13:21:35.227]                           name <- restart$name
[13:21:35.227]                           if (is.null(name)) 
[13:21:35.227]                             next
[13:21:35.227]                           if (!grepl(pattern, name)) 
[13:21:35.227]                             next
[13:21:35.227]                           invokeRestart(restart)
[13:21:35.227]                           muffled <- TRUE
[13:21:35.227]                           break
[13:21:35.227]                         }
[13:21:35.227]                       }
[13:21:35.227]                     }
[13:21:35.227]                     invisible(muffled)
[13:21:35.227]                   }
[13:21:35.227]                   muffleCondition(cond)
[13:21:35.227]                 })
[13:21:35.227]             }))
[13:21:35.227]             future::FutureResult(value = ...future.value$value, 
[13:21:35.227]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:35.227]                   ...future.rng), globalenv = if (FALSE) 
[13:21:35.227]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:35.227]                     ...future.globalenv.names))
[13:21:35.227]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:35.227]         }, condition = base::local({
[13:21:35.227]             c <- base::c
[13:21:35.227]             inherits <- base::inherits
[13:21:35.227]             invokeRestart <- base::invokeRestart
[13:21:35.227]             length <- base::length
[13:21:35.227]             list <- base::list
[13:21:35.227]             seq.int <- base::seq.int
[13:21:35.227]             signalCondition <- base::signalCondition
[13:21:35.227]             sys.calls <- base::sys.calls
[13:21:35.227]             `[[` <- base::`[[`
[13:21:35.227]             `+` <- base::`+`
[13:21:35.227]             `<<-` <- base::`<<-`
[13:21:35.227]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:35.227]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:35.227]                   3L)]
[13:21:35.227]             }
[13:21:35.227]             function(cond) {
[13:21:35.227]                 is_error <- inherits(cond, "error")
[13:21:35.227]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:35.227]                   NULL)
[13:21:35.227]                 if (is_error) {
[13:21:35.227]                   sessionInformation <- function() {
[13:21:35.227]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:35.227]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:35.227]                       search = base::search(), system = base::Sys.info())
[13:21:35.227]                   }
[13:21:35.227]                   ...future.conditions[[length(...future.conditions) + 
[13:21:35.227]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:35.227]                     cond$call), session = sessionInformation(), 
[13:21:35.227]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:35.227]                   signalCondition(cond)
[13:21:35.227]                 }
[13:21:35.227]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:35.227]                 "immediateCondition"))) {
[13:21:35.227]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:35.227]                   ...future.conditions[[length(...future.conditions) + 
[13:21:35.227]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:35.227]                   if (TRUE && !signal) {
[13:21:35.227]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:35.227]                     {
[13:21:35.227]                       inherits <- base::inherits
[13:21:35.227]                       invokeRestart <- base::invokeRestart
[13:21:35.227]                       is.null <- base::is.null
[13:21:35.227]                       muffled <- FALSE
[13:21:35.227]                       if (inherits(cond, "message")) {
[13:21:35.227]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:35.227]                         if (muffled) 
[13:21:35.227]                           invokeRestart("muffleMessage")
[13:21:35.227]                       }
[13:21:35.227]                       else if (inherits(cond, "warning")) {
[13:21:35.227]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:35.227]                         if (muffled) 
[13:21:35.227]                           invokeRestart("muffleWarning")
[13:21:35.227]                       }
[13:21:35.227]                       else if (inherits(cond, "condition")) {
[13:21:35.227]                         if (!is.null(pattern)) {
[13:21:35.227]                           computeRestarts <- base::computeRestarts
[13:21:35.227]                           grepl <- base::grepl
[13:21:35.227]                           restarts <- computeRestarts(cond)
[13:21:35.227]                           for (restart in restarts) {
[13:21:35.227]                             name <- restart$name
[13:21:35.227]                             if (is.null(name)) 
[13:21:35.227]                               next
[13:21:35.227]                             if (!grepl(pattern, name)) 
[13:21:35.227]                               next
[13:21:35.227]                             invokeRestart(restart)
[13:21:35.227]                             muffled <- TRUE
[13:21:35.227]                             break
[13:21:35.227]                           }
[13:21:35.227]                         }
[13:21:35.227]                       }
[13:21:35.227]                       invisible(muffled)
[13:21:35.227]                     }
[13:21:35.227]                     muffleCondition(cond, pattern = "^muffle")
[13:21:35.227]                   }
[13:21:35.227]                 }
[13:21:35.227]                 else {
[13:21:35.227]                   if (TRUE) {
[13:21:35.227]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:35.227]                     {
[13:21:35.227]                       inherits <- base::inherits
[13:21:35.227]                       invokeRestart <- base::invokeRestart
[13:21:35.227]                       is.null <- base::is.null
[13:21:35.227]                       muffled <- FALSE
[13:21:35.227]                       if (inherits(cond, "message")) {
[13:21:35.227]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:35.227]                         if (muffled) 
[13:21:35.227]                           invokeRestart("muffleMessage")
[13:21:35.227]                       }
[13:21:35.227]                       else if (inherits(cond, "warning")) {
[13:21:35.227]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:35.227]                         if (muffled) 
[13:21:35.227]                           invokeRestart("muffleWarning")
[13:21:35.227]                       }
[13:21:35.227]                       else if (inherits(cond, "condition")) {
[13:21:35.227]                         if (!is.null(pattern)) {
[13:21:35.227]                           computeRestarts <- base::computeRestarts
[13:21:35.227]                           grepl <- base::grepl
[13:21:35.227]                           restarts <- computeRestarts(cond)
[13:21:35.227]                           for (restart in restarts) {
[13:21:35.227]                             name <- restart$name
[13:21:35.227]                             if (is.null(name)) 
[13:21:35.227]                               next
[13:21:35.227]                             if (!grepl(pattern, name)) 
[13:21:35.227]                               next
[13:21:35.227]                             invokeRestart(restart)
[13:21:35.227]                             muffled <- TRUE
[13:21:35.227]                             break
[13:21:35.227]                           }
[13:21:35.227]                         }
[13:21:35.227]                       }
[13:21:35.227]                       invisible(muffled)
[13:21:35.227]                     }
[13:21:35.227]                     muffleCondition(cond, pattern = "^muffle")
[13:21:35.227]                   }
[13:21:35.227]                 }
[13:21:35.227]             }
[13:21:35.227]         }))
[13:21:35.227]     }, error = function(ex) {
[13:21:35.227]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:35.227]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:35.227]                 ...future.rng), started = ...future.startTime, 
[13:21:35.227]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:35.227]             version = "1.8"), class = "FutureResult")
[13:21:35.227]     }, finally = {
[13:21:35.227]         if (!identical(...future.workdir, getwd())) 
[13:21:35.227]             setwd(...future.workdir)
[13:21:35.227]         {
[13:21:35.227]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:35.227]                 ...future.oldOptions$nwarnings <- NULL
[13:21:35.227]             }
[13:21:35.227]             base::options(...future.oldOptions)
[13:21:35.227]             if (.Platform$OS.type == "windows") {
[13:21:35.227]                 old_names <- names(...future.oldEnvVars)
[13:21:35.227]                 envs <- base::Sys.getenv()
[13:21:35.227]                 names <- names(envs)
[13:21:35.227]                 common <- intersect(names, old_names)
[13:21:35.227]                 added <- setdiff(names, old_names)
[13:21:35.227]                 removed <- setdiff(old_names, names)
[13:21:35.227]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:35.227]                   envs[common]]
[13:21:35.227]                 NAMES <- toupper(changed)
[13:21:35.227]                 args <- list()
[13:21:35.227]                 for (kk in seq_along(NAMES)) {
[13:21:35.227]                   name <- changed[[kk]]
[13:21:35.227]                   NAME <- NAMES[[kk]]
[13:21:35.227]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:35.227]                     next
[13:21:35.227]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:35.227]                 }
[13:21:35.227]                 NAMES <- toupper(added)
[13:21:35.227]                 for (kk in seq_along(NAMES)) {
[13:21:35.227]                   name <- added[[kk]]
[13:21:35.227]                   NAME <- NAMES[[kk]]
[13:21:35.227]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:35.227]                     next
[13:21:35.227]                   args[[name]] <- ""
[13:21:35.227]                 }
[13:21:35.227]                 NAMES <- toupper(removed)
[13:21:35.227]                 for (kk in seq_along(NAMES)) {
[13:21:35.227]                   name <- removed[[kk]]
[13:21:35.227]                   NAME <- NAMES[[kk]]
[13:21:35.227]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:35.227]                     next
[13:21:35.227]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:35.227]                 }
[13:21:35.227]                 if (length(args) > 0) 
[13:21:35.227]                   base::do.call(base::Sys.setenv, args = args)
[13:21:35.227]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:35.227]             }
[13:21:35.227]             else {
[13:21:35.227]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:35.227]             }
[13:21:35.227]             {
[13:21:35.227]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:35.227]                   0L) {
[13:21:35.227]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:35.227]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:35.227]                   base::options(opts)
[13:21:35.227]                 }
[13:21:35.227]                 {
[13:21:35.227]                   {
[13:21:35.227]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:35.227]                     NULL
[13:21:35.227]                   }
[13:21:35.227]                   options(future.plan = NULL)
[13:21:35.227]                   if (is.na(NA_character_)) 
[13:21:35.227]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:35.227]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:35.227]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:35.227]                     envir = parent.frame()) 
[13:21:35.227]                   {
[13:21:35.227]                     default_workers <- missing(workers)
[13:21:35.227]                     if (is.function(workers)) 
[13:21:35.227]                       workers <- workers()
[13:21:35.227]                     workers <- structure(as.integer(workers), 
[13:21:35.227]                       class = class(workers))
[13:21:35.227]                     stop_if_not(is.finite(workers), workers >= 
[13:21:35.227]                       1L)
[13:21:35.227]                     if ((workers == 1L && !inherits(workers, 
[13:21:35.227]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:35.227]                       if (default_workers) 
[13:21:35.227]                         supportsMulticore(warn = TRUE)
[13:21:35.227]                       return(sequential(..., envir = envir))
[13:21:35.227]                     }
[13:21:35.227]                     oopts <- options(mc.cores = workers)
[13:21:35.227]                     on.exit(options(oopts))
[13:21:35.227]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:35.227]                       envir = envir)
[13:21:35.227]                     if (!future$lazy) 
[13:21:35.227]                       future <- run(future)
[13:21:35.227]                     invisible(future)
[13:21:35.227]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:35.227]                 }
[13:21:35.227]             }
[13:21:35.227]         }
[13:21:35.227]     })
[13:21:35.227]     if (TRUE) {
[13:21:35.227]         base::sink(type = "output", split = FALSE)
[13:21:35.227]         if (TRUE) {
[13:21:35.227]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:35.227]         }
[13:21:35.227]         else {
[13:21:35.227]             ...future.result["stdout"] <- base::list(NULL)
[13:21:35.227]         }
[13:21:35.227]         base::close(...future.stdout)
[13:21:35.227]         ...future.stdout <- NULL
[13:21:35.227]     }
[13:21:35.227]     ...future.result$conditions <- ...future.conditions
[13:21:35.227]     ...future.result$finished <- base::Sys.time()
[13:21:35.227]     ...future.result
[13:21:35.227] }
[13:21:35.230] assign_globals() ...
[13:21:35.230] List of 11
[13:21:35.230]  $ ...future.FUN            :function (x, ...)  
[13:21:35.230]  $ x_FUN                    :function (x)  
[13:21:35.230]  $ times                    : int 1
[13:21:35.230]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:35.230]  $ stop_if_not              :function (...)  
[13:21:35.230]  $ dim                      : NULL
[13:21:35.230]  $ valid_types              : chr "logical"
[13:21:35.230]  $ future.call.arguments    : list()
[13:21:35.230]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:35.230]  $ ...future.elements_ii    :List of 6
[13:21:35.230]   ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
[13:21:35.230]   ..$ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ...
[13:21:35.230]   ..$ disp: num [1:32] 160 160 108 258 360 ...
[13:21:35.230]   ..$ hp  : num [1:32] 110 110 93 110 175 105 245 62 95 123 ...
[13:21:35.230]   ..$ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
[13:21:35.230]   ..$ wt  : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...
[13:21:35.230]  $ ...future.seeds_ii       : NULL
[13:21:35.230]  $ ...future.globals.maxSize: NULL
[13:21:35.230]  - attr(*, "where")=List of 11
[13:21:35.230]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:35.230]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:35.230]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:35.230]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:35.230]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:35.230]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:35.230]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:35.230]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:35.230]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:35.230]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:35.230]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:35.230]  - attr(*, "resolved")= logi FALSE
[13:21:35.230]  - attr(*, "total_size")= num 94200
[13:21:35.230]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:35.230]  - attr(*, "already-done")= logi TRUE
[13:21:35.244] - copied ‘...future.FUN’ to environment
[13:21:35.244] - copied ‘x_FUN’ to environment
[13:21:35.244] - copied ‘times’ to environment
[13:21:35.244] - copied ‘stopf’ to environment
[13:21:35.245] - copied ‘stop_if_not’ to environment
[13:21:35.245] - copied ‘dim’ to environment
[13:21:35.245] - copied ‘valid_types’ to environment
[13:21:35.245] - copied ‘future.call.arguments’ to environment
[13:21:35.245] - copied ‘...future.elements_ii’ to environment
[13:21:35.245] - copied ‘...future.seeds_ii’ to environment
[13:21:35.245] - copied ‘...future.globals.maxSize’ to environment
[13:21:35.246] assign_globals() ... done
[13:21:35.246] requestCore(): workers = 2
[13:21:35.248] MulticoreFuture started
[13:21:35.249] - Launch lazy future ... done
[13:21:35.249] run() for ‘MulticoreFuture’ ... done
[13:21:35.250] Created future:
[13:21:35.250] plan(): Setting new future strategy stack:
[13:21:35.251] List of future strategies:
[13:21:35.251] 1. sequential:
[13:21:35.251]    - args: function (..., envir = parent.frame())
[13:21:35.251]    - tweaked: FALSE
[13:21:35.251]    - call: NULL
[13:21:35.252] plan(): nbrOfWorkers() = 1
[13:21:35.255] plan(): Setting new future strategy stack:
[13:21:35.255] List of future strategies:
[13:21:35.255] 1. multicore:
[13:21:35.255]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:35.255]    - tweaked: FALSE
[13:21:35.255]    - call: plan(strategy)
[13:21:35.261] plan(): nbrOfWorkers() = 2
[13:21:35.251] MulticoreFuture:
[13:21:35.251] Label: ‘future_vapply-1’
[13:21:35.251] Expression:
[13:21:35.251] {
[13:21:35.251]     do.call(function(...) {
[13:21:35.251]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:35.251]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:35.251]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:35.251]             on.exit(options(oopts), add = TRUE)
[13:21:35.251]         }
[13:21:35.251]         {
[13:21:35.251]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:35.251]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:35.251]                 ...future.FUN(...future.X_jj, ...)
[13:21:35.251]             })
[13:21:35.251]         }
[13:21:35.251]     }, args = future.call.arguments)
[13:21:35.251] }
[13:21:35.251] Lazy evaluation: FALSE
[13:21:35.251] Asynchronous evaluation: TRUE
[13:21:35.251] Local evaluation: TRUE
[13:21:35.251] Environment: R_GlobalEnv
[13:21:35.251] Capture standard output: TRUE
[13:21:35.251] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:35.251] Globals: 11 objects totaling 93.77 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:35.251] Packages: 1 packages (‘future.apply’)
[13:21:35.251] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:35.251] Resolved: TRUE
[13:21:35.251] Value: <not collected>
[13:21:35.251] Conditions captured: <none>
[13:21:35.251] Early signaling: FALSE
[13:21:35.251] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:35.251] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:35.262] Chunk #1 of 2 ... DONE
[13:21:35.263] Chunk #2 of 2 ...
[13:21:35.263]  - Finding globals in 'X' for chunk #2 ...
[13:21:35.263] getGlobalsAndPackages() ...
[13:21:35.263] Searching for globals...
[13:21:35.264] 
[13:21:35.264] Searching for globals ... DONE
[13:21:35.264] - globals: [0] <none>
[13:21:35.264] getGlobalsAndPackages() ... DONE
[13:21:35.264]    + additional globals found: [n=0] 
[13:21:35.265]    + additional namespaces needed: [n=0] 
[13:21:35.265]  - Finding globals in 'X' for chunk #2 ... DONE
[13:21:35.265]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:35.265]  - seeds: <none>
[13:21:35.265]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:35.266] getGlobalsAndPackages() ...
[13:21:35.266] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:35.266] Resolving globals: FALSE
[13:21:35.266] Tweak future expression to call with '...' arguments ...
[13:21:35.267] {
[13:21:35.267]     do.call(function(...) {
[13:21:35.267]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:35.267]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:35.267]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:35.267]             on.exit(options(oopts), add = TRUE)
[13:21:35.267]         }
[13:21:35.267]         {
[13:21:35.267]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:35.267]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:35.267]                 ...future.FUN(...future.X_jj, ...)
[13:21:35.267]             })
[13:21:35.267]         }
[13:21:35.267]     }, args = future.call.arguments)
[13:21:35.267] }
[13:21:35.267] Tweak future expression to call with '...' arguments ... DONE
[13:21:35.268] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:35.268] - packages: [1] ‘future.apply’
[13:21:35.269] getGlobalsAndPackages() ... DONE
[13:21:35.269] run() for ‘Future’ ...
[13:21:35.269] - state: ‘created’
[13:21:35.269] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:35.275] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:35.275] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:35.275]   - Field: ‘label’
[13:21:35.276]   - Field: ‘local’
[13:21:35.276]   - Field: ‘owner’
[13:21:35.276]   - Field: ‘envir’
[13:21:35.276]   - Field: ‘workers’
[13:21:35.276]   - Field: ‘packages’
[13:21:35.276]   - Field: ‘gc’
[13:21:35.277]   - Field: ‘job’
[13:21:35.277]   - Field: ‘conditions’
[13:21:35.277]   - Field: ‘expr’
[13:21:35.277]   - Field: ‘uuid’
[13:21:35.277]   - Field: ‘seed’
[13:21:35.277]   - Field: ‘version’
[13:21:35.277]   - Field: ‘result’
[13:21:35.278]   - Field: ‘asynchronous’
[13:21:35.278]   - Field: ‘calls’
[13:21:35.278]   - Field: ‘globals’
[13:21:35.278]   - Field: ‘stdout’
[13:21:35.278]   - Field: ‘earlySignal’
[13:21:35.278]   - Field: ‘lazy’
[13:21:35.278]   - Field: ‘state’
[13:21:35.279] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:35.279] - Launch lazy future ...
[13:21:35.279] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:35.279] Packages needed by future strategies (n = 0): <none>
[13:21:35.280] {
[13:21:35.280]     {
[13:21:35.280]         {
[13:21:35.280]             ...future.startTime <- base::Sys.time()
[13:21:35.280]             {
[13:21:35.280]                 {
[13:21:35.280]                   {
[13:21:35.280]                     {
[13:21:35.280]                       {
[13:21:35.280]                         base::local({
[13:21:35.280]                           has_future <- base::requireNamespace("future", 
[13:21:35.280]                             quietly = TRUE)
[13:21:35.280]                           if (has_future) {
[13:21:35.280]                             ns <- base::getNamespace("future")
[13:21:35.280]                             version <- ns[[".package"]][["version"]]
[13:21:35.280]                             if (is.null(version)) 
[13:21:35.280]                               version <- utils::packageVersion("future")
[13:21:35.280]                           }
[13:21:35.280]                           else {
[13:21:35.280]                             version <- NULL
[13:21:35.280]                           }
[13:21:35.280]                           if (!has_future || version < "1.8.0") {
[13:21:35.280]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:35.280]                               "", base::R.version$version.string), 
[13:21:35.280]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:35.280]                                 base::R.version$platform, 8 * 
[13:21:35.280]                                   base::.Machine$sizeof.pointer), 
[13:21:35.280]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:35.280]                                 "release", "version")], collapse = " "), 
[13:21:35.280]                               hostname = base::Sys.info()[["nodename"]])
[13:21:35.280]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:35.280]                               info)
[13:21:35.280]                             info <- base::paste(info, collapse = "; ")
[13:21:35.280]                             if (!has_future) {
[13:21:35.280]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:35.280]                                 info)
[13:21:35.280]                             }
[13:21:35.280]                             else {
[13:21:35.280]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:35.280]                                 info, version)
[13:21:35.280]                             }
[13:21:35.280]                             base::stop(msg)
[13:21:35.280]                           }
[13:21:35.280]                         })
[13:21:35.280]                       }
[13:21:35.280]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:35.280]                       base::options(mc.cores = 1L)
[13:21:35.280]                     }
[13:21:35.280]                     base::local({
[13:21:35.280]                       for (pkg in "future.apply") {
[13:21:35.280]                         base::loadNamespace(pkg)
[13:21:35.280]                         base::library(pkg, character.only = TRUE)
[13:21:35.280]                       }
[13:21:35.280]                     })
[13:21:35.280]                   }
[13:21:35.280]                   options(future.plan = NULL)
[13:21:35.280]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:35.280]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:35.280]                 }
[13:21:35.280]                 ...future.workdir <- getwd()
[13:21:35.280]             }
[13:21:35.280]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:35.280]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:35.280]         }
[13:21:35.280]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:35.280]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:35.280]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:35.280]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:35.280]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:35.280]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:35.280]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:35.280]             base::names(...future.oldOptions))
[13:21:35.280]     }
[13:21:35.280]     if (FALSE) {
[13:21:35.280]     }
[13:21:35.280]     else {
[13:21:35.280]         if (TRUE) {
[13:21:35.280]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:35.280]                 open = "w")
[13:21:35.280]         }
[13:21:35.280]         else {
[13:21:35.280]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:35.280]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:35.280]         }
[13:21:35.280]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:35.280]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:35.280]             base::sink(type = "output", split = FALSE)
[13:21:35.280]             base::close(...future.stdout)
[13:21:35.280]         }, add = TRUE)
[13:21:35.280]     }
[13:21:35.280]     ...future.frame <- base::sys.nframe()
[13:21:35.280]     ...future.conditions <- base::list()
[13:21:35.280]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:35.280]     if (FALSE) {
[13:21:35.280]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:35.280]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:35.280]     }
[13:21:35.280]     ...future.result <- base::tryCatch({
[13:21:35.280]         base::withCallingHandlers({
[13:21:35.280]             ...future.value <- base::withVisible(base::local({
[13:21:35.280]                 withCallingHandlers({
[13:21:35.280]                   {
[13:21:35.280]                     do.call(function(...) {
[13:21:35.280]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:35.280]                       if (!identical(...future.globals.maxSize.org, 
[13:21:35.280]                         ...future.globals.maxSize)) {
[13:21:35.280]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:35.280]                         on.exit(options(oopts), add = TRUE)
[13:21:35.280]                       }
[13:21:35.280]                       {
[13:21:35.280]                         lapply(seq_along(...future.elements_ii), 
[13:21:35.280]                           FUN = function(jj) {
[13:21:35.280]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:35.280]                             ...future.FUN(...future.X_jj, ...)
[13:21:35.280]                           })
[13:21:35.280]                       }
[13:21:35.280]                     }, args = future.call.arguments)
[13:21:35.280]                   }
[13:21:35.280]                 }, immediateCondition = function(cond) {
[13:21:35.280]                   save_rds <- function (object, pathname, ...) 
[13:21:35.280]                   {
[13:21:35.280]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:35.280]                     if (file_test("-f", pathname_tmp)) {
[13:21:35.280]                       fi_tmp <- file.info(pathname_tmp)
[13:21:35.280]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:35.280]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:35.280]                         fi_tmp[["mtime"]])
[13:21:35.280]                     }
[13:21:35.280]                     tryCatch({
[13:21:35.280]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:35.280]                     }, error = function(ex) {
[13:21:35.280]                       msg <- conditionMessage(ex)
[13:21:35.280]                       fi_tmp <- file.info(pathname_tmp)
[13:21:35.280]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:35.280]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:35.280]                         fi_tmp[["mtime"]], msg)
[13:21:35.280]                       ex$message <- msg
[13:21:35.280]                       stop(ex)
[13:21:35.280]                     })
[13:21:35.280]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:35.280]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:35.280]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:35.280]                       fi_tmp <- file.info(pathname_tmp)
[13:21:35.280]                       fi <- file.info(pathname)
[13:21:35.280]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:35.280]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:35.280]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:35.280]                         fi[["size"]], fi[["mtime"]])
[13:21:35.280]                       stop(msg)
[13:21:35.280]                     }
[13:21:35.280]                     invisible(pathname)
[13:21:35.280]                   }
[13:21:35.280]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:35.280]                     rootPath = tempdir()) 
[13:21:35.280]                   {
[13:21:35.280]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:35.280]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:35.280]                       tmpdir = path, fileext = ".rds")
[13:21:35.280]                     save_rds(obj, file)
[13:21:35.280]                   }
[13:21:35.280]                   saveImmediateCondition(cond, path = "/tmp/RtmpbpFWGO/.future/immediateConditions")
[13:21:35.280]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:35.280]                   {
[13:21:35.280]                     inherits <- base::inherits
[13:21:35.280]                     invokeRestart <- base::invokeRestart
[13:21:35.280]                     is.null <- base::is.null
[13:21:35.280]                     muffled <- FALSE
[13:21:35.280]                     if (inherits(cond, "message")) {
[13:21:35.280]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:35.280]                       if (muffled) 
[13:21:35.280]                         invokeRestart("muffleMessage")
[13:21:35.280]                     }
[13:21:35.280]                     else if (inherits(cond, "warning")) {
[13:21:35.280]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:35.280]                       if (muffled) 
[13:21:35.280]                         invokeRestart("muffleWarning")
[13:21:35.280]                     }
[13:21:35.280]                     else if (inherits(cond, "condition")) {
[13:21:35.280]                       if (!is.null(pattern)) {
[13:21:35.280]                         computeRestarts <- base::computeRestarts
[13:21:35.280]                         grepl <- base::grepl
[13:21:35.280]                         restarts <- computeRestarts(cond)
[13:21:35.280]                         for (restart in restarts) {
[13:21:35.280]                           name <- restart$name
[13:21:35.280]                           if (is.null(name)) 
[13:21:35.280]                             next
[13:21:35.280]                           if (!grepl(pattern, name)) 
[13:21:35.280]                             next
[13:21:35.280]                           invokeRestart(restart)
[13:21:35.280]                           muffled <- TRUE
[13:21:35.280]                           break
[13:21:35.280]                         }
[13:21:35.280]                       }
[13:21:35.280]                     }
[13:21:35.280]                     invisible(muffled)
[13:21:35.280]                   }
[13:21:35.280]                   muffleCondition(cond)
[13:21:35.280]                 })
[13:21:35.280]             }))
[13:21:35.280]             future::FutureResult(value = ...future.value$value, 
[13:21:35.280]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:35.280]                   ...future.rng), globalenv = if (FALSE) 
[13:21:35.280]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:35.280]                     ...future.globalenv.names))
[13:21:35.280]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:35.280]         }, condition = base::local({
[13:21:35.280]             c <- base::c
[13:21:35.280]             inherits <- base::inherits
[13:21:35.280]             invokeRestart <- base::invokeRestart
[13:21:35.280]             length <- base::length
[13:21:35.280]             list <- base::list
[13:21:35.280]             seq.int <- base::seq.int
[13:21:35.280]             signalCondition <- base::signalCondition
[13:21:35.280]             sys.calls <- base::sys.calls
[13:21:35.280]             `[[` <- base::`[[`
[13:21:35.280]             `+` <- base::`+`
[13:21:35.280]             `<<-` <- base::`<<-`
[13:21:35.280]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:35.280]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:35.280]                   3L)]
[13:21:35.280]             }
[13:21:35.280]             function(cond) {
[13:21:35.280]                 is_error <- inherits(cond, "error")
[13:21:35.280]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:35.280]                   NULL)
[13:21:35.280]                 if (is_error) {
[13:21:35.280]                   sessionInformation <- function() {
[13:21:35.280]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:35.280]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:35.280]                       search = base::search(), system = base::Sys.info())
[13:21:35.280]                   }
[13:21:35.280]                   ...future.conditions[[length(...future.conditions) + 
[13:21:35.280]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:35.280]                     cond$call), session = sessionInformation(), 
[13:21:35.280]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:35.280]                   signalCondition(cond)
[13:21:35.280]                 }
[13:21:35.280]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:35.280]                 "immediateCondition"))) {
[13:21:35.280]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:35.280]                   ...future.conditions[[length(...future.conditions) + 
[13:21:35.280]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:35.280]                   if (TRUE && !signal) {
[13:21:35.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:35.280]                     {
[13:21:35.280]                       inherits <- base::inherits
[13:21:35.280]                       invokeRestart <- base::invokeRestart
[13:21:35.280]                       is.null <- base::is.null
[13:21:35.280]                       muffled <- FALSE
[13:21:35.280]                       if (inherits(cond, "message")) {
[13:21:35.280]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:35.280]                         if (muffled) 
[13:21:35.280]                           invokeRestart("muffleMessage")
[13:21:35.280]                       }
[13:21:35.280]                       else if (inherits(cond, "warning")) {
[13:21:35.280]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:35.280]                         if (muffled) 
[13:21:35.280]                           invokeRestart("muffleWarning")
[13:21:35.280]                       }
[13:21:35.280]                       else if (inherits(cond, "condition")) {
[13:21:35.280]                         if (!is.null(pattern)) {
[13:21:35.280]                           computeRestarts <- base::computeRestarts
[13:21:35.280]                           grepl <- base::grepl
[13:21:35.280]                           restarts <- computeRestarts(cond)
[13:21:35.280]                           for (restart in restarts) {
[13:21:35.280]                             name <- restart$name
[13:21:35.280]                             if (is.null(name)) 
[13:21:35.280]                               next
[13:21:35.280]                             if (!grepl(pattern, name)) 
[13:21:35.280]                               next
[13:21:35.280]                             invokeRestart(restart)
[13:21:35.280]                             muffled <- TRUE
[13:21:35.280]                             break
[13:21:35.280]                           }
[13:21:35.280]                         }
[13:21:35.280]                       }
[13:21:35.280]                       invisible(muffled)
[13:21:35.280]                     }
[13:21:35.280]                     muffleCondition(cond, pattern = "^muffle")
[13:21:35.280]                   }
[13:21:35.280]                 }
[13:21:35.280]                 else {
[13:21:35.280]                   if (TRUE) {
[13:21:35.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:35.280]                     {
[13:21:35.280]                       inherits <- base::inherits
[13:21:35.280]                       invokeRestart <- base::invokeRestart
[13:21:35.280]                       is.null <- base::is.null
[13:21:35.280]                       muffled <- FALSE
[13:21:35.280]                       if (inherits(cond, "message")) {
[13:21:35.280]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:35.280]                         if (muffled) 
[13:21:35.280]                           invokeRestart("muffleMessage")
[13:21:35.280]                       }
[13:21:35.280]                       else if (inherits(cond, "warning")) {
[13:21:35.280]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:35.280]                         if (muffled) 
[13:21:35.280]                           invokeRestart("muffleWarning")
[13:21:35.280]                       }
[13:21:35.280]                       else if (inherits(cond, "condition")) {
[13:21:35.280]                         if (!is.null(pattern)) {
[13:21:35.280]                           computeRestarts <- base::computeRestarts
[13:21:35.280]                           grepl <- base::grepl
[13:21:35.280]                           restarts <- computeRestarts(cond)
[13:21:35.280]                           for (restart in restarts) {
[13:21:35.280]                             name <- restart$name
[13:21:35.280]                             if (is.null(name)) 
[13:21:35.280]                               next
[13:21:35.280]                             if (!grepl(pattern, name)) 
[13:21:35.280]                               next
[13:21:35.280]                             invokeRestart(restart)
[13:21:35.280]                             muffled <- TRUE
[13:21:35.280]                             break
[13:21:35.280]                           }
[13:21:35.280]                         }
[13:21:35.280]                       }
[13:21:35.280]                       invisible(muffled)
[13:21:35.280]                     }
[13:21:35.280]                     muffleCondition(cond, pattern = "^muffle")
[13:21:35.280]                   }
[13:21:35.280]                 }
[13:21:35.280]             }
[13:21:35.280]         }))
[13:21:35.280]     }, error = function(ex) {
[13:21:35.280]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:35.280]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:35.280]                 ...future.rng), started = ...future.startTime, 
[13:21:35.280]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:35.280]             version = "1.8"), class = "FutureResult")
[13:21:35.280]     }, finally = {
[13:21:35.280]         if (!identical(...future.workdir, getwd())) 
[13:21:35.280]             setwd(...future.workdir)
[13:21:35.280]         {
[13:21:35.280]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:35.280]                 ...future.oldOptions$nwarnings <- NULL
[13:21:35.280]             }
[13:21:35.280]             base::options(...future.oldOptions)
[13:21:35.280]             if (.Platform$OS.type == "windows") {
[13:21:35.280]                 old_names <- names(...future.oldEnvVars)
[13:21:35.280]                 envs <- base::Sys.getenv()
[13:21:35.280]                 names <- names(envs)
[13:21:35.280]                 common <- intersect(names, old_names)
[13:21:35.280]                 added <- setdiff(names, old_names)
[13:21:35.280]                 removed <- setdiff(old_names, names)
[13:21:35.280]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:35.280]                   envs[common]]
[13:21:35.280]                 NAMES <- toupper(changed)
[13:21:35.280]                 args <- list()
[13:21:35.280]                 for (kk in seq_along(NAMES)) {
[13:21:35.280]                   name <- changed[[kk]]
[13:21:35.280]                   NAME <- NAMES[[kk]]
[13:21:35.280]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:35.280]                     next
[13:21:35.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:35.280]                 }
[13:21:35.280]                 NAMES <- toupper(added)
[13:21:35.280]                 for (kk in seq_along(NAMES)) {
[13:21:35.280]                   name <- added[[kk]]
[13:21:35.280]                   NAME <- NAMES[[kk]]
[13:21:35.280]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:35.280]                     next
[13:21:35.280]                   args[[name]] <- ""
[13:21:35.280]                 }
[13:21:35.280]                 NAMES <- toupper(removed)
[13:21:35.280]                 for (kk in seq_along(NAMES)) {
[13:21:35.280]                   name <- removed[[kk]]
[13:21:35.280]                   NAME <- NAMES[[kk]]
[13:21:35.280]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:35.280]                     next
[13:21:35.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:35.280]                 }
[13:21:35.280]                 if (length(args) > 0) 
[13:21:35.280]                   base::do.call(base::Sys.setenv, args = args)
[13:21:35.280]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:35.280]             }
[13:21:35.280]             else {
[13:21:35.280]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:35.280]             }
[13:21:35.280]             {
[13:21:35.280]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:35.280]                   0L) {
[13:21:35.280]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:35.280]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:35.280]                   base::options(opts)
[13:21:35.280]                 }
[13:21:35.280]                 {
[13:21:35.280]                   {
[13:21:35.280]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:35.280]                     NULL
[13:21:35.280]                   }
[13:21:35.280]                   options(future.plan = NULL)
[13:21:35.280]                   if (is.na(NA_character_)) 
[13:21:35.280]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:35.280]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:35.280]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:35.280]                     envir = parent.frame()) 
[13:21:35.280]                   {
[13:21:35.280]                     default_workers <- missing(workers)
[13:21:35.280]                     if (is.function(workers)) 
[13:21:35.280]                       workers <- workers()
[13:21:35.280]                     workers <- structure(as.integer(workers), 
[13:21:35.280]                       class = class(workers))
[13:21:35.280]                     stop_if_not(is.finite(workers), workers >= 
[13:21:35.280]                       1L)
[13:21:35.280]                     if ((workers == 1L && !inherits(workers, 
[13:21:35.280]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:35.280]                       if (default_workers) 
[13:21:35.280]                         supportsMulticore(warn = TRUE)
[13:21:35.280]                       return(sequential(..., envir = envir))
[13:21:35.280]                     }
[13:21:35.280]                     oopts <- options(mc.cores = workers)
[13:21:35.280]                     on.exit(options(oopts))
[13:21:35.280]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:35.280]                       envir = envir)
[13:21:35.280]                     if (!future$lazy) 
[13:21:35.280]                       future <- run(future)
[13:21:35.280]                     invisible(future)
[13:21:35.280]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:35.280]                 }
[13:21:35.280]             }
[13:21:35.280]         }
[13:21:35.280]     })
[13:21:35.280]     if (TRUE) {
[13:21:35.280]         base::sink(type = "output", split = FALSE)
[13:21:35.280]         if (TRUE) {
[13:21:35.280]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:35.280]         }
[13:21:35.280]         else {
[13:21:35.280]             ...future.result["stdout"] <- base::list(NULL)
[13:21:35.280]         }
[13:21:35.280]         base::close(...future.stdout)
[13:21:35.280]         ...future.stdout <- NULL
[13:21:35.280]     }
[13:21:35.280]     ...future.result$conditions <- ...future.conditions
[13:21:35.280]     ...future.result$finished <- base::Sys.time()
[13:21:35.280]     ...future.result
[13:21:35.280] }
[13:21:35.284] assign_globals() ...
[13:21:35.284] List of 11
[13:21:35.284]  $ ...future.FUN            :function (x, ...)  
[13:21:35.284]  $ x_FUN                    :function (x)  
[13:21:35.284]  $ times                    : int 1
[13:21:35.284]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:35.284]  $ stop_if_not              :function (...)  
[13:21:35.284]  $ dim                      : NULL
[13:21:35.284]  $ valid_types              : chr "logical"
[13:21:35.284]  $ future.call.arguments    : list()
[13:21:35.284]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:35.284]  $ ...future.elements_ii    :List of 5
[13:21:35.284]   ..$ qsec: num [1:32] 16.5 17 18.6 19.4 17 ...
[13:21:35.284]   ..$ vs  : num [1:32] 0 0 1 1 0 1 0 1 1 1 ...
[13:21:35.284]   ..$ am  : num [1:32] 1 1 1 0 0 0 0 0 0 0 ...
[13:21:35.284]   ..$ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ...
[13:21:35.284]   ..$ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ...
[13:21:35.284]  $ ...future.seeds_ii       : NULL
[13:21:35.284]  $ ...future.globals.maxSize: NULL
[13:21:35.284]  - attr(*, "where")=List of 11
[13:21:35.284]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:35.284]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:35.284]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:35.284]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:35.284]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:35.284]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:35.284]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:35.284]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:35.284]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:35.284]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:35.284]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:35.284]  - attr(*, "resolved")= logi FALSE
[13:21:35.284]  - attr(*, "total_size")= num 94200
[13:21:35.284]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:35.284]  - attr(*, "already-done")= logi TRUE
[13:21:35.301] - copied ‘...future.FUN’ to environment
[13:21:35.302] - copied ‘x_FUN’ to environment
[13:21:35.302] - copied ‘times’ to environment
[13:21:35.302] - copied ‘stopf’ to environment
[13:21:35.302] - copied ‘stop_if_not’ to environment
[13:21:35.302] - copied ‘dim’ to environment
[13:21:35.302] - copied ‘valid_types’ to environment
[13:21:35.302] - copied ‘future.call.arguments’ to environment
[13:21:35.302] - copied ‘...future.elements_ii’ to environment
[13:21:35.302] - copied ‘...future.seeds_ii’ to environment
[13:21:35.303] - copied ‘...future.globals.maxSize’ to environment
[13:21:35.303] assign_globals() ... done
[13:21:35.303] requestCore(): workers = 2
[13:21:35.305] MulticoreFuture started
[13:21:35.306] - Launch lazy future ... done
[13:21:35.306] run() for ‘MulticoreFuture’ ... done
[13:21:35.307] Created future:
[13:21:35.307] plan(): Setting new future strategy stack:
[13:21:35.307] List of future strategies:
[13:21:35.307] 1. sequential:
[13:21:35.307]    - args: function (..., envir = parent.frame())
[13:21:35.307]    - tweaked: FALSE
[13:21:35.307]    - call: NULL
[13:21:35.308] plan(): nbrOfWorkers() = 1
[13:21:35.310] plan(): Setting new future strategy stack:
[13:21:35.310] List of future strategies:
[13:21:35.310] 1. multicore:
[13:21:35.310]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:35.310]    - tweaked: FALSE
[13:21:35.310]    - call: plan(strategy)
[13:21:35.316] plan(): nbrOfWorkers() = 2
[13:21:35.307] MulticoreFuture:
[13:21:35.307] Label: ‘future_vapply-2’
[13:21:35.307] Expression:
[13:21:35.307] {
[13:21:35.307]     do.call(function(...) {
[13:21:35.307]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:35.307]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:35.307]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:35.307]             on.exit(options(oopts), add = TRUE)
[13:21:35.307]         }
[13:21:35.307]         {
[13:21:35.307]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:35.307]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:35.307]                 ...future.FUN(...future.X_jj, ...)
[13:21:35.307]             })
[13:21:35.307]         }
[13:21:35.307]     }, args = future.call.arguments)
[13:21:35.307] }
[13:21:35.307] Lazy evaluation: FALSE
[13:21:35.307] Asynchronous evaluation: TRUE
[13:21:35.307] Local evaluation: TRUE
[13:21:35.307] Environment: R_GlobalEnv
[13:21:35.307] Capture standard output: TRUE
[13:21:35.307] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:35.307] Globals: 11 objects totaling 93.48 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:35.307] Packages: 1 packages (‘future.apply’)
[13:21:35.307] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:35.307] Resolved: TRUE
[13:21:35.307] Value: <not collected>
[13:21:35.307] Conditions captured: <none>
[13:21:35.307] Early signaling: FALSE
[13:21:35.307] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:35.307] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:35.317] Chunk #2 of 2 ... DONE
[13:21:35.317] Launching 2 futures (chunks) ... DONE
[13:21:35.318] Resolving 2 futures (chunks) ...
[13:21:35.318] resolve() on list ...
[13:21:35.318]  recursive: 0
[13:21:35.318]  length: 2
[13:21:35.318] 
[13:21:35.319] Future #1
[13:21:35.319] result() for MulticoreFuture ...
[13:21:35.320] result() for MulticoreFuture ...
[13:21:35.320] result() for MulticoreFuture ... done
[13:21:35.320] result() for MulticoreFuture ... done
[13:21:35.320] result() for MulticoreFuture ...
[13:21:35.320] result() for MulticoreFuture ... done
[13:21:35.321] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:21:35.321] - nx: 2
[13:21:35.321] - relay: TRUE
[13:21:35.321] - stdout: TRUE
[13:21:35.321] - signal: TRUE
[13:21:35.321] - resignal: FALSE
[13:21:35.322] - force: TRUE
[13:21:35.322] - relayed: [n=2] FALSE, FALSE
[13:21:35.322] - queued futures: [n=2] FALSE, FALSE
[13:21:35.322]  - until=1
[13:21:35.322]  - relaying element #1
[13:21:35.322] result() for MulticoreFuture ...
[13:21:35.322] result() for MulticoreFuture ... done
[13:21:35.323] result() for MulticoreFuture ...
[13:21:35.323] result() for MulticoreFuture ... done
[13:21:35.323] result() for MulticoreFuture ...
[13:21:35.323] result() for MulticoreFuture ... done
[13:21:35.323] result() for MulticoreFuture ...
[13:21:35.323] result() for MulticoreFuture ... done
[13:21:35.324] - relayed: [n=2] TRUE, FALSE
[13:21:35.324] - queued futures: [n=2] TRUE, FALSE
[13:21:35.324] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:21:35.324]  length: 1 (resolved future 1)
[13:21:35.324] Future #2
[13:21:35.325] result() for MulticoreFuture ...
[13:21:35.325] result() for MulticoreFuture ...
[13:21:35.326] result() for MulticoreFuture ... done
[13:21:35.326] result() for MulticoreFuture ... done
[13:21:35.326] result() for MulticoreFuture ...
[13:21:35.326] result() for MulticoreFuture ... done
[13:21:35.326] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:21:35.326] - nx: 2
[13:21:35.326] - relay: TRUE
[13:21:35.327] - stdout: TRUE
[13:21:35.327] - signal: TRUE
[13:21:35.327] - resignal: FALSE
[13:21:35.327] - force: TRUE
[13:21:35.327] - relayed: [n=2] TRUE, FALSE
[13:21:35.327] - queued futures: [n=2] TRUE, FALSE
[13:21:35.327]  - until=2
[13:21:35.327]  - relaying element #2
[13:21:35.332] result() for MulticoreFuture ...
[13:21:35.332] result() for MulticoreFuture ... done
[13:21:35.332] result() for MulticoreFuture ...
[13:21:35.332] result() for MulticoreFuture ... done
[13:21:35.333] result() for MulticoreFuture ...
[13:21:35.333] result() for MulticoreFuture ... done
[13:21:35.333] result() for MulticoreFuture ...
[13:21:35.333] result() for MulticoreFuture ... done
[13:21:35.333] - relayed: [n=2] TRUE, TRUE
[13:21:35.333] - queued futures: [n=2] TRUE, TRUE
[13:21:35.333] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:21:35.333]  length: 0 (resolved future 2)
[13:21:35.334] Relaying remaining futures
[13:21:35.334] signalConditionsASAP(NULL, pos=0) ...
[13:21:35.334] - nx: 2
[13:21:35.334] - relay: TRUE
[13:21:35.334] - stdout: TRUE
[13:21:35.334] - signal: TRUE
[13:21:35.334] - resignal: FALSE
[13:21:35.334] - force: TRUE
[13:21:35.335] - relayed: [n=2] TRUE, TRUE
[13:21:35.335] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:21:35.335] - relayed: [n=2] TRUE, TRUE
[13:21:35.335] - queued futures: [n=2] TRUE, TRUE
[13:21:35.335] signalConditionsASAP(NULL, pos=0) ... done
[13:21:35.335] resolve() on list ... DONE
[13:21:35.336] result() for MulticoreFuture ...
[13:21:35.336] result() for MulticoreFuture ... done
[13:21:35.336] result() for MulticoreFuture ...
[13:21:35.336] result() for MulticoreFuture ... done
[13:21:35.336] result() for MulticoreFuture ...
[13:21:35.336] result() for MulticoreFuture ... done
[13:21:35.337] result() for MulticoreFuture ...
[13:21:35.337] result() for MulticoreFuture ... done
[13:21:35.337]  - Number of value chunks collected: 2
[13:21:35.337] Resolving 2 futures (chunks) ... DONE
[13:21:35.337] Reducing values from 2 chunks ...
[13:21:35.337]  - Number of values collected after concatenation: 11
[13:21:35.337]  - Number of values expected: 11
[13:21:35.338] Reducing values from 2 chunks ... DONE
[13:21:35.338] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[13:21:35.339] future_lapply() ...
[13:21:35.347] Number of chunks: 2
[13:21:35.348] getGlobalsAndPackagesXApply() ...
[13:21:35.348]  - future.globals: TRUE
[13:21:35.348] getGlobalsAndPackages() ...
[13:21:35.348] Searching for globals...
[13:21:35.352] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:21:35.352] Searching for globals ... DONE
[13:21:35.352] Resolving globals: FALSE
[13:21:35.353] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[13:21:35.353] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:35.354] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:35.354] - packages: [1] ‘future.apply’
[13:21:35.354] getGlobalsAndPackages() ... DONE
[13:21:35.354]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:35.354]  - needed namespaces: [n=1] ‘future.apply’
[13:21:35.354] Finding globals ... DONE
[13:21:35.354]  - use_args: TRUE
[13:21:35.354]  - Getting '...' globals ...
[13:21:35.355] resolve() on list ...
[13:21:35.355]  recursive: 0
[13:21:35.355]  length: 1
[13:21:35.355]  elements: ‘...’
[13:21:35.355]  length: 0 (resolved future 1)
[13:21:35.355] resolve() on list ... DONE
[13:21:35.355]    - '...' content: [n=0] 
[13:21:35.355] List of 1
[13:21:35.355]  $ ...: list()
[13:21:35.355]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:35.355]  - attr(*, "where")=List of 1
[13:21:35.355]   ..$ ...:<environment: 0x563b6dabd248> 
[13:21:35.355]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:35.355]  - attr(*, "resolved")= logi TRUE
[13:21:35.355]  - attr(*, "total_size")= num NA
[13:21:35.358]  - Getting '...' globals ... DONE
[13:21:35.358] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:35.361] List of 8
[13:21:35.361]  $ ...future.FUN:function (x, ...)  
[13:21:35.361]  $ x_FUN        :function (x)  
[13:21:35.361]  $ times        : int 1
[13:21:35.361]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:35.361]  $ stop_if_not  :function (...)  
[13:21:35.361]  $ dim          : NULL
[13:21:35.361]  $ valid_types  : chr [1:2] "logical" "integer"
[13:21:35.361]  $ ...          : list()
[13:21:35.361]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:35.361]  - attr(*, "where")=List of 8
[13:21:35.361]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:35.361]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:35.361]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:35.361]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:35.361]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:35.361]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:35.361]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:35.361]   ..$ ...          :<environment: 0x563b6dabd248> 
[13:21:35.361]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:35.361]  - attr(*, "resolved")= logi FALSE
[13:21:35.361]  - attr(*, "total_size")= num 94264
[13:21:35.368] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:21:35.368] getGlobalsAndPackagesXApply() ... DONE
[13:21:35.368] Number of futures (= number of chunks): 2
[13:21:35.369] Launching 2 futures (chunks) ...
[13:21:35.369] Chunk #1 of 2 ...
[13:21:35.369]  - Finding globals in 'X' for chunk #1 ...
[13:21:35.369] getGlobalsAndPackages() ...
[13:21:35.369] Searching for globals...
[13:21:35.369] 
[13:21:35.370] Searching for globals ... DONE
[13:21:35.370] - globals: [0] <none>
[13:21:35.370] getGlobalsAndPackages() ... DONE
[13:21:35.370]    + additional globals found: [n=0] 
[13:21:35.370]    + additional namespaces needed: [n=0] 
[13:21:35.370]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:35.370]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:35.370]  - seeds: <none>
[13:21:35.370]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:35.370] getGlobalsAndPackages() ...
[13:21:35.371] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:35.371] Resolving globals: FALSE
[13:21:35.371] Tweak future expression to call with '...' arguments ...
[13:21:35.371] {
[13:21:35.371]     do.call(function(...) {
[13:21:35.371]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:35.371]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:35.371]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:35.371]             on.exit(options(oopts), add = TRUE)
[13:21:35.371]         }
[13:21:35.371]         {
[13:21:35.371]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:35.371]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:35.371]                 ...future.FUN(...future.X_jj, ...)
[13:21:35.371]             })
[13:21:35.371]         }
[13:21:35.371]     }, args = future.call.arguments)
[13:21:35.371] }
[13:21:35.371] Tweak future expression to call with '...' arguments ... DONE
[13:21:35.372] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:35.372] - packages: [1] ‘future.apply’
[13:21:35.372] getGlobalsAndPackages() ... DONE
[13:21:35.372] run() for ‘Future’ ...
[13:21:35.373] - state: ‘created’
[13:21:35.373] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:35.377] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:35.377] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:35.377]   - Field: ‘label’
[13:21:35.377]   - Field: ‘local’
[13:21:35.378]   - Field: ‘owner’
[13:21:35.378]   - Field: ‘envir’
[13:21:35.378]   - Field: ‘workers’
[13:21:35.378]   - Field: ‘packages’
[13:21:35.378]   - Field: ‘gc’
[13:21:35.378]   - Field: ‘job’
[13:21:35.378]   - Field: ‘conditions’
[13:21:35.378]   - Field: ‘expr’
[13:21:35.378]   - Field: ‘uuid’
[13:21:35.379]   - Field: ‘seed’
[13:21:35.379]   - Field: ‘version’
[13:21:35.379]   - Field: ‘result’
[13:21:35.379]   - Field: ‘asynchronous’
[13:21:35.379]   - Field: ‘calls’
[13:21:35.379]   - Field: ‘globals’
[13:21:35.379]   - Field: ‘stdout’
[13:21:35.379]   - Field: ‘earlySignal’
[13:21:35.379]   - Field: ‘lazy’
[13:21:35.379]   - Field: ‘state’
[13:21:35.380] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:35.380] - Launch lazy future ...
[13:21:35.380] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:35.380] Packages needed by future strategies (n = 0): <none>
[13:21:35.381] {
[13:21:35.381]     {
[13:21:35.381]         {
[13:21:35.381]             ...future.startTime <- base::Sys.time()
[13:21:35.381]             {
[13:21:35.381]                 {
[13:21:35.381]                   {
[13:21:35.381]                     {
[13:21:35.381]                       {
[13:21:35.381]                         base::local({
[13:21:35.381]                           has_future <- base::requireNamespace("future", 
[13:21:35.381]                             quietly = TRUE)
[13:21:35.381]                           if (has_future) {
[13:21:35.381]                             ns <- base::getNamespace("future")
[13:21:35.381]                             version <- ns[[".package"]][["version"]]
[13:21:35.381]                             if (is.null(version)) 
[13:21:35.381]                               version <- utils::packageVersion("future")
[13:21:35.381]                           }
[13:21:35.381]                           else {
[13:21:35.381]                             version <- NULL
[13:21:35.381]                           }
[13:21:35.381]                           if (!has_future || version < "1.8.0") {
[13:21:35.381]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:35.381]                               "", base::R.version$version.string), 
[13:21:35.381]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:35.381]                                 base::R.version$platform, 8 * 
[13:21:35.381]                                   base::.Machine$sizeof.pointer), 
[13:21:35.381]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:35.381]                                 "release", "version")], collapse = " "), 
[13:21:35.381]                               hostname = base::Sys.info()[["nodename"]])
[13:21:35.381]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:35.381]                               info)
[13:21:35.381]                             info <- base::paste(info, collapse = "; ")
[13:21:35.381]                             if (!has_future) {
[13:21:35.381]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:35.381]                                 info)
[13:21:35.381]                             }
[13:21:35.381]                             else {
[13:21:35.381]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:35.381]                                 info, version)
[13:21:35.381]                             }
[13:21:35.381]                             base::stop(msg)
[13:21:35.381]                           }
[13:21:35.381]                         })
[13:21:35.381]                       }
[13:21:35.381]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:35.381]                       base::options(mc.cores = 1L)
[13:21:35.381]                     }
[13:21:35.381]                     base::local({
[13:21:35.381]                       for (pkg in "future.apply") {
[13:21:35.381]                         base::loadNamespace(pkg)
[13:21:35.381]                         base::library(pkg, character.only = TRUE)
[13:21:35.381]                       }
[13:21:35.381]                     })
[13:21:35.381]                   }
[13:21:35.381]                   options(future.plan = NULL)
[13:21:35.381]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:35.381]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:35.381]                 }
[13:21:35.381]                 ...future.workdir <- getwd()
[13:21:35.381]             }
[13:21:35.381]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:35.381]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:35.381]         }
[13:21:35.381]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:35.381]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:35.381]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:35.381]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:35.381]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:35.381]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:35.381]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:35.381]             base::names(...future.oldOptions))
[13:21:35.381]     }
[13:21:35.381]     if (FALSE) {
[13:21:35.381]     }
[13:21:35.381]     else {
[13:21:35.381]         if (TRUE) {
[13:21:35.381]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:35.381]                 open = "w")
[13:21:35.381]         }
[13:21:35.381]         else {
[13:21:35.381]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:35.381]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:35.381]         }
[13:21:35.381]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:35.381]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:35.381]             base::sink(type = "output", split = FALSE)
[13:21:35.381]             base::close(...future.stdout)
[13:21:35.381]         }, add = TRUE)
[13:21:35.381]     }
[13:21:35.381]     ...future.frame <- base::sys.nframe()
[13:21:35.381]     ...future.conditions <- base::list()
[13:21:35.381]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:35.381]     if (FALSE) {
[13:21:35.381]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:35.381]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:35.381]     }
[13:21:35.381]     ...future.result <- base::tryCatch({
[13:21:35.381]         base::withCallingHandlers({
[13:21:35.381]             ...future.value <- base::withVisible(base::local({
[13:21:35.381]                 withCallingHandlers({
[13:21:35.381]                   {
[13:21:35.381]                     do.call(function(...) {
[13:21:35.381]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:35.381]                       if (!identical(...future.globals.maxSize.org, 
[13:21:35.381]                         ...future.globals.maxSize)) {
[13:21:35.381]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:35.381]                         on.exit(options(oopts), add = TRUE)
[13:21:35.381]                       }
[13:21:35.381]                       {
[13:21:35.381]                         lapply(seq_along(...future.elements_ii), 
[13:21:35.381]                           FUN = function(jj) {
[13:21:35.381]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:35.381]                             ...future.FUN(...future.X_jj, ...)
[13:21:35.381]                           })
[13:21:35.381]                       }
[13:21:35.381]                     }, args = future.call.arguments)
[13:21:35.381]                   }
[13:21:35.381]                 }, immediateCondition = function(cond) {
[13:21:35.381]                   save_rds <- function (object, pathname, ...) 
[13:21:35.381]                   {
[13:21:35.381]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:35.381]                     if (file_test("-f", pathname_tmp)) {
[13:21:35.381]                       fi_tmp <- file.info(pathname_tmp)
[13:21:35.381]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:35.381]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:35.381]                         fi_tmp[["mtime"]])
[13:21:35.381]                     }
[13:21:35.381]                     tryCatch({
[13:21:35.381]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:35.381]                     }, error = function(ex) {
[13:21:35.381]                       msg <- conditionMessage(ex)
[13:21:35.381]                       fi_tmp <- file.info(pathname_tmp)
[13:21:35.381]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:35.381]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:35.381]                         fi_tmp[["mtime"]], msg)
[13:21:35.381]                       ex$message <- msg
[13:21:35.381]                       stop(ex)
[13:21:35.381]                     })
[13:21:35.381]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:35.381]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:35.381]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:35.381]                       fi_tmp <- file.info(pathname_tmp)
[13:21:35.381]                       fi <- file.info(pathname)
[13:21:35.381]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:35.381]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:35.381]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:35.381]                         fi[["size"]], fi[["mtime"]])
[13:21:35.381]                       stop(msg)
[13:21:35.381]                     }
[13:21:35.381]                     invisible(pathname)
[13:21:35.381]                   }
[13:21:35.381]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:35.381]                     rootPath = tempdir()) 
[13:21:35.381]                   {
[13:21:35.381]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:35.381]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:35.381]                       tmpdir = path, fileext = ".rds")
[13:21:35.381]                     save_rds(obj, file)
[13:21:35.381]                   }
[13:21:35.381]                   saveImmediateCondition(cond, path = "/tmp/RtmpbpFWGO/.future/immediateConditions")
[13:21:35.381]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:35.381]                   {
[13:21:35.381]                     inherits <- base::inherits
[13:21:35.381]                     invokeRestart <- base::invokeRestart
[13:21:35.381]                     is.null <- base::is.null
[13:21:35.381]                     muffled <- FALSE
[13:21:35.381]                     if (inherits(cond, "message")) {
[13:21:35.381]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:35.381]                       if (muffled) 
[13:21:35.381]                         invokeRestart("muffleMessage")
[13:21:35.381]                     }
[13:21:35.381]                     else if (inherits(cond, "warning")) {
[13:21:35.381]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:35.381]                       if (muffled) 
[13:21:35.381]                         invokeRestart("muffleWarning")
[13:21:35.381]                     }
[13:21:35.381]                     else if (inherits(cond, "condition")) {
[13:21:35.381]                       if (!is.null(pattern)) {
[13:21:35.381]                         computeRestarts <- base::computeRestarts
[13:21:35.381]                         grepl <- base::grepl
[13:21:35.381]                         restarts <- computeRestarts(cond)
[13:21:35.381]                         for (restart in restarts) {
[13:21:35.381]                           name <- restart$name
[13:21:35.381]                           if (is.null(name)) 
[13:21:35.381]                             next
[13:21:35.381]                           if (!grepl(pattern, name)) 
[13:21:35.381]                             next
[13:21:35.381]                           invokeRestart(restart)
[13:21:35.381]                           muffled <- TRUE
[13:21:35.381]                           break
[13:21:35.381]                         }
[13:21:35.381]                       }
[13:21:35.381]                     }
[13:21:35.381]                     invisible(muffled)
[13:21:35.381]                   }
[13:21:35.381]                   muffleCondition(cond)
[13:21:35.381]                 })
[13:21:35.381]             }))
[13:21:35.381]             future::FutureResult(value = ...future.value$value, 
[13:21:35.381]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:35.381]                   ...future.rng), globalenv = if (FALSE) 
[13:21:35.381]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:35.381]                     ...future.globalenv.names))
[13:21:35.381]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:35.381]         }, condition = base::local({
[13:21:35.381]             c <- base::c
[13:21:35.381]             inherits <- base::inherits
[13:21:35.381]             invokeRestart <- base::invokeRestart
[13:21:35.381]             length <- base::length
[13:21:35.381]             list <- base::list
[13:21:35.381]             seq.int <- base::seq.int
[13:21:35.381]             signalCondition <- base::signalCondition
[13:21:35.381]             sys.calls <- base::sys.calls
[13:21:35.381]             `[[` <- base::`[[`
[13:21:35.381]             `+` <- base::`+`
[13:21:35.381]             `<<-` <- base::`<<-`
[13:21:35.381]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:35.381]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:35.381]                   3L)]
[13:21:35.381]             }
[13:21:35.381]             function(cond) {
[13:21:35.381]                 is_error <- inherits(cond, "error")
[13:21:35.381]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:35.381]                   NULL)
[13:21:35.381]                 if (is_error) {
[13:21:35.381]                   sessionInformation <- function() {
[13:21:35.381]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:35.381]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:35.381]                       search = base::search(), system = base::Sys.info())
[13:21:35.381]                   }
[13:21:35.381]                   ...future.conditions[[length(...future.conditions) + 
[13:21:35.381]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:35.381]                     cond$call), session = sessionInformation(), 
[13:21:35.381]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:35.381]                   signalCondition(cond)
[13:21:35.381]                 }
[13:21:35.381]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:35.381]                 "immediateCondition"))) {
[13:21:35.381]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:35.381]                   ...future.conditions[[length(...future.conditions) + 
[13:21:35.381]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:35.381]                   if (TRUE && !signal) {
[13:21:35.381]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:35.381]                     {
[13:21:35.381]                       inherits <- base::inherits
[13:21:35.381]                       invokeRestart <- base::invokeRestart
[13:21:35.381]                       is.null <- base::is.null
[13:21:35.381]                       muffled <- FALSE
[13:21:35.381]                       if (inherits(cond, "message")) {
[13:21:35.381]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:35.381]                         if (muffled) 
[13:21:35.381]                           invokeRestart("muffleMessage")
[13:21:35.381]                       }
[13:21:35.381]                       else if (inherits(cond, "warning")) {
[13:21:35.381]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:35.381]                         if (muffled) 
[13:21:35.381]                           invokeRestart("muffleWarning")
[13:21:35.381]                       }
[13:21:35.381]                       else if (inherits(cond, "condition")) {
[13:21:35.381]                         if (!is.null(pattern)) {
[13:21:35.381]                           computeRestarts <- base::computeRestarts
[13:21:35.381]                           grepl <- base::grepl
[13:21:35.381]                           restarts <- computeRestarts(cond)
[13:21:35.381]                           for (restart in restarts) {
[13:21:35.381]                             name <- restart$name
[13:21:35.381]                             if (is.null(name)) 
[13:21:35.381]                               next
[13:21:35.381]                             if (!grepl(pattern, name)) 
[13:21:35.381]                               next
[13:21:35.381]                             invokeRestart(restart)
[13:21:35.381]                             muffled <- TRUE
[13:21:35.381]                             break
[13:21:35.381]                           }
[13:21:35.381]                         }
[13:21:35.381]                       }
[13:21:35.381]                       invisible(muffled)
[13:21:35.381]                     }
[13:21:35.381]                     muffleCondition(cond, pattern = "^muffle")
[13:21:35.381]                   }
[13:21:35.381]                 }
[13:21:35.381]                 else {
[13:21:35.381]                   if (TRUE) {
[13:21:35.381]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:35.381]                     {
[13:21:35.381]                       inherits <- base::inherits
[13:21:35.381]                       invokeRestart <- base::invokeRestart
[13:21:35.381]                       is.null <- base::is.null
[13:21:35.381]                       muffled <- FALSE
[13:21:35.381]                       if (inherits(cond, "message")) {
[13:21:35.381]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:35.381]                         if (muffled) 
[13:21:35.381]                           invokeRestart("muffleMessage")
[13:21:35.381]                       }
[13:21:35.381]                       else if (inherits(cond, "warning")) {
[13:21:35.381]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:35.381]                         if (muffled) 
[13:21:35.381]                           invokeRestart("muffleWarning")
[13:21:35.381]                       }
[13:21:35.381]                       else if (inherits(cond, "condition")) {
[13:21:35.381]                         if (!is.null(pattern)) {
[13:21:35.381]                           computeRestarts <- base::computeRestarts
[13:21:35.381]                           grepl <- base::grepl
[13:21:35.381]                           restarts <- computeRestarts(cond)
[13:21:35.381]                           for (restart in restarts) {
[13:21:35.381]                             name <- restart$name
[13:21:35.381]                             if (is.null(name)) 
[13:21:35.381]                               next
[13:21:35.381]                             if (!grepl(pattern, name)) 
[13:21:35.381]                               next
[13:21:35.381]                             invokeRestart(restart)
[13:21:35.381]                             muffled <- TRUE
[13:21:35.381]                             break
[13:21:35.381]                           }
[13:21:35.381]                         }
[13:21:35.381]                       }
[13:21:35.381]                       invisible(muffled)
[13:21:35.381]                     }
[13:21:35.381]                     muffleCondition(cond, pattern = "^muffle")
[13:21:35.381]                   }
[13:21:35.381]                 }
[13:21:35.381]             }
[13:21:35.381]         }))
[13:21:35.381]     }, error = function(ex) {
[13:21:35.381]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:35.381]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:35.381]                 ...future.rng), started = ...future.startTime, 
[13:21:35.381]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:35.381]             version = "1.8"), class = "FutureResult")
[13:21:35.381]     }, finally = {
[13:21:35.381]         if (!identical(...future.workdir, getwd())) 
[13:21:35.381]             setwd(...future.workdir)
[13:21:35.381]         {
[13:21:35.381]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:35.381]                 ...future.oldOptions$nwarnings <- NULL
[13:21:35.381]             }
[13:21:35.381]             base::options(...future.oldOptions)
[13:21:35.381]             if (.Platform$OS.type == "windows") {
[13:21:35.381]                 old_names <- names(...future.oldEnvVars)
[13:21:35.381]                 envs <- base::Sys.getenv()
[13:21:35.381]                 names <- names(envs)
[13:21:35.381]                 common <- intersect(names, old_names)
[13:21:35.381]                 added <- setdiff(names, old_names)
[13:21:35.381]                 removed <- setdiff(old_names, names)
[13:21:35.381]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:35.381]                   envs[common]]
[13:21:35.381]                 NAMES <- toupper(changed)
[13:21:35.381]                 args <- list()
[13:21:35.381]                 for (kk in seq_along(NAMES)) {
[13:21:35.381]                   name <- changed[[kk]]
[13:21:35.381]                   NAME <- NAMES[[kk]]
[13:21:35.381]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:35.381]                     next
[13:21:35.381]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:35.381]                 }
[13:21:35.381]                 NAMES <- toupper(added)
[13:21:35.381]                 for (kk in seq_along(NAMES)) {
[13:21:35.381]                   name <- added[[kk]]
[13:21:35.381]                   NAME <- NAMES[[kk]]
[13:21:35.381]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:35.381]                     next
[13:21:35.381]                   args[[name]] <- ""
[13:21:35.381]                 }
[13:21:35.381]                 NAMES <- toupper(removed)
[13:21:35.381]                 for (kk in seq_along(NAMES)) {
[13:21:35.381]                   name <- removed[[kk]]
[13:21:35.381]                   NAME <- NAMES[[kk]]
[13:21:35.381]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:35.381]                     next
[13:21:35.381]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:35.381]                 }
[13:21:35.381]                 if (length(args) > 0) 
[13:21:35.381]                   base::do.call(base::Sys.setenv, args = args)
[13:21:35.381]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:35.381]             }
[13:21:35.381]             else {
[13:21:35.381]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:35.381]             }
[13:21:35.381]             {
[13:21:35.381]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:35.381]                   0L) {
[13:21:35.381]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:35.381]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:35.381]                   base::options(opts)
[13:21:35.381]                 }
[13:21:35.381]                 {
[13:21:35.381]                   {
[13:21:35.381]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:35.381]                     NULL
[13:21:35.381]                   }
[13:21:35.381]                   options(future.plan = NULL)
[13:21:35.381]                   if (is.na(NA_character_)) 
[13:21:35.381]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:35.381]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:35.381]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:35.381]                     envir = parent.frame()) 
[13:21:35.381]                   {
[13:21:35.381]                     default_workers <- missing(workers)
[13:21:35.381]                     if (is.function(workers)) 
[13:21:35.381]                       workers <- workers()
[13:21:35.381]                     workers <- structure(as.integer(workers), 
[13:21:35.381]                       class = class(workers))
[13:21:35.381]                     stop_if_not(is.finite(workers), workers >= 
[13:21:35.381]                       1L)
[13:21:35.381]                     if ((workers == 1L && !inherits(workers, 
[13:21:35.381]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:35.381]                       if (default_workers) 
[13:21:35.381]                         supportsMulticore(warn = TRUE)
[13:21:35.381]                       return(sequential(..., envir = envir))
[13:21:35.381]                     }
[13:21:35.381]                     oopts <- options(mc.cores = workers)
[13:21:35.381]                     on.exit(options(oopts))
[13:21:35.381]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:35.381]                       envir = envir)
[13:21:35.381]                     if (!future$lazy) 
[13:21:35.381]                       future <- run(future)
[13:21:35.381]                     invisible(future)
[13:21:35.381]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:35.381]                 }
[13:21:35.381]             }
[13:21:35.381]         }
[13:21:35.381]     })
[13:21:35.381]     if (TRUE) {
[13:21:35.381]         base::sink(type = "output", split = FALSE)
[13:21:35.381]         if (TRUE) {
[13:21:35.381]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:35.381]         }
[13:21:35.381]         else {
[13:21:35.381]             ...future.result["stdout"] <- base::list(NULL)
[13:21:35.381]         }
[13:21:35.381]         base::close(...future.stdout)
[13:21:35.381]         ...future.stdout <- NULL
[13:21:35.381]     }
[13:21:35.381]     ...future.result$conditions <- ...future.conditions
[13:21:35.381]     ...future.result$finished <- base::Sys.time()
[13:21:35.381]     ...future.result
[13:21:35.381] }
[13:21:35.384] assign_globals() ...
[13:21:35.384] List of 11
[13:21:35.384]  $ ...future.FUN            :function (x, ...)  
[13:21:35.384]  $ x_FUN                    :function (x)  
[13:21:35.384]  $ times                    : int 1
[13:21:35.384]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:35.384]  $ stop_if_not              :function (...)  
[13:21:35.384]  $ dim                      : NULL
[13:21:35.384]  $ valid_types              : chr [1:2] "logical" "integer"
[13:21:35.384]  $ future.call.arguments    : list()
[13:21:35.384]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:35.384]  $ ...future.elements_ii    :List of 1
[13:21:35.384]   ..$ a: num 1
[13:21:35.384]  $ ...future.seeds_ii       : NULL
[13:21:35.384]  $ ...future.globals.maxSize: NULL
[13:21:35.384]  - attr(*, "where")=List of 11
[13:21:35.384]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:35.384]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:35.384]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:35.384]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:35.384]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:35.384]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:35.384]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:35.384]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:35.384]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:35.384]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:35.384]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:35.384]  - attr(*, "resolved")= logi FALSE
[13:21:35.384]  - attr(*, "total_size")= num 94264
[13:21:35.384]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:35.384]  - attr(*, "already-done")= logi TRUE
[13:21:35.396] - copied ‘...future.FUN’ to environment
[13:21:35.396] - copied ‘x_FUN’ to environment
[13:21:35.396] - copied ‘times’ to environment
[13:21:35.396] - copied ‘stopf’ to environment
[13:21:35.396] - copied ‘stop_if_not’ to environment
[13:21:35.396] - copied ‘dim’ to environment
[13:21:35.397] - copied ‘valid_types’ to environment
[13:21:35.397] - copied ‘future.call.arguments’ to environment
[13:21:35.397] - copied ‘...future.elements_ii’ to environment
[13:21:35.397] - copied ‘...future.seeds_ii’ to environment
[13:21:35.397] - copied ‘...future.globals.maxSize’ to environment
[13:21:35.397] assign_globals() ... done
[13:21:35.397] requestCore(): workers = 2
[13:21:35.400] MulticoreFuture started
[13:21:35.401] - Launch lazy future ... done
[13:21:35.401] run() for ‘MulticoreFuture’ ... done
[13:21:35.402] Created future:
[13:21:35.402] plan(): Setting new future strategy stack:
[13:21:35.402] List of future strategies:
[13:21:35.402] 1. sequential:
[13:21:35.402]    - args: function (..., envir = parent.frame())
[13:21:35.402]    - tweaked: FALSE
[13:21:35.402]    - call: NULL
[13:21:35.403] plan(): nbrOfWorkers() = 1
[13:21:35.406] plan(): Setting new future strategy stack:
[13:21:35.406] List of future strategies:
[13:21:35.406] 1. multicore:
[13:21:35.406]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:35.406]    - tweaked: FALSE
[13:21:35.406]    - call: plan(strategy)
[13:21:35.412] plan(): nbrOfWorkers() = 2
[13:21:35.402] MulticoreFuture:
[13:21:35.402] Label: ‘future_vapply-1’
[13:21:35.402] Expression:
[13:21:35.402] {
[13:21:35.402]     do.call(function(...) {
[13:21:35.402]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:35.402]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:35.402]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:35.402]             on.exit(options(oopts), add = TRUE)
[13:21:35.402]         }
[13:21:35.402]         {
[13:21:35.402]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:35.402]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:35.402]                 ...future.FUN(...future.X_jj, ...)
[13:21:35.402]             })
[13:21:35.402]         }
[13:21:35.402]     }, args = future.call.arguments)
[13:21:35.402] }
[13:21:35.402] Lazy evaluation: FALSE
[13:21:35.402] Asynchronous evaluation: TRUE
[13:21:35.402] Local evaluation: TRUE
[13:21:35.402] Environment: R_GlobalEnv
[13:21:35.402] Capture standard output: TRUE
[13:21:35.402] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:35.402] Globals: 11 objects totaling 92.11 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:35.402] Packages: 1 packages (‘future.apply’)
[13:21:35.402] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:35.402] Resolved: TRUE
[13:21:35.402] Value: <not collected>
[13:21:35.402] Conditions captured: <none>
[13:21:35.402] Early signaling: FALSE
[13:21:35.402] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:35.402] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:35.413] Chunk #1 of 2 ... DONE
[13:21:35.414] Chunk #2 of 2 ...
[13:21:35.414]  - Finding globals in 'X' for chunk #2 ...
[13:21:35.414] getGlobalsAndPackages() ...
[13:21:35.414] Searching for globals...
[13:21:35.415] 
[13:21:35.415] Searching for globals ... DONE
[13:21:35.415] - globals: [0] <none>
[13:21:35.415] getGlobalsAndPackages() ... DONE
[13:21:35.415]    + additional globals found: [n=0] 
[13:21:35.415]    + additional namespaces needed: [n=0] 
[13:21:35.416]  - Finding globals in 'X' for chunk #2 ... DONE
[13:21:35.416]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:35.416]  - seeds: <none>
[13:21:35.416]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:35.416] getGlobalsAndPackages() ...
[13:21:35.417] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:35.417] Resolving globals: FALSE
[13:21:35.417] Tweak future expression to call with '...' arguments ...
[13:21:35.417] {
[13:21:35.417]     do.call(function(...) {
[13:21:35.417]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:35.417]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:35.417]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:35.417]             on.exit(options(oopts), add = TRUE)
[13:21:35.417]         }
[13:21:35.417]         {
[13:21:35.417]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:35.417]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:35.417]                 ...future.FUN(...future.X_jj, ...)
[13:21:35.417]             })
[13:21:35.417]         }
[13:21:35.417]     }, args = future.call.arguments)
[13:21:35.417] }
[13:21:35.418] Tweak future expression to call with '...' arguments ... DONE
[13:21:35.419] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:35.419] - packages: [1] ‘future.apply’
[13:21:35.419] getGlobalsAndPackages() ... DONE
[13:21:35.420] run() for ‘Future’ ...
[13:21:35.420] - state: ‘created’
[13:21:35.420] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:35.426] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:35.426] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:35.426]   - Field: ‘label’
[13:21:35.426]   - Field: ‘local’
[13:21:35.427]   - Field: ‘owner’
[13:21:35.427]   - Field: ‘envir’
[13:21:35.427]   - Field: ‘workers’
[13:21:35.427]   - Field: ‘packages’
[13:21:35.427]   - Field: ‘gc’
[13:21:35.427]   - Field: ‘job’
[13:21:35.428]   - Field: ‘conditions’
[13:21:35.428]   - Field: ‘expr’
[13:21:35.428]   - Field: ‘uuid’
[13:21:35.428]   - Field: ‘seed’
[13:21:35.428]   - Field: ‘version’
[13:21:35.428]   - Field: ‘result’
[13:21:35.428]   - Field: ‘asynchronous’
[13:21:35.429]   - Field: ‘calls’
[13:21:35.429]   - Field: ‘globals’
[13:21:35.429]   - Field: ‘stdout’
[13:21:35.429]   - Field: ‘earlySignal’
[13:21:35.429]   - Field: ‘lazy’
[13:21:35.429]   - Field: ‘state’
[13:21:35.430] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:35.430] - Launch lazy future ...
[13:21:35.430] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:35.430] Packages needed by future strategies (n = 0): <none>
[13:21:35.431] {
[13:21:35.431]     {
[13:21:35.431]         {
[13:21:35.431]             ...future.startTime <- base::Sys.time()
[13:21:35.431]             {
[13:21:35.431]                 {
[13:21:35.431]                   {
[13:21:35.431]                     {
[13:21:35.431]                       {
[13:21:35.431]                         base::local({
[13:21:35.431]                           has_future <- base::requireNamespace("future", 
[13:21:35.431]                             quietly = TRUE)
[13:21:35.431]                           if (has_future) {
[13:21:35.431]                             ns <- base::getNamespace("future")
[13:21:35.431]                             version <- ns[[".package"]][["version"]]
[13:21:35.431]                             if (is.null(version)) 
[13:21:35.431]                               version <- utils::packageVersion("future")
[13:21:35.431]                           }
[13:21:35.431]                           else {
[13:21:35.431]                             version <- NULL
[13:21:35.431]                           }
[13:21:35.431]                           if (!has_future || version < "1.8.0") {
[13:21:35.431]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:35.431]                               "", base::R.version$version.string), 
[13:21:35.431]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:35.431]                                 base::R.version$platform, 8 * 
[13:21:35.431]                                   base::.Machine$sizeof.pointer), 
[13:21:35.431]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:35.431]                                 "release", "version")], collapse = " "), 
[13:21:35.431]                               hostname = base::Sys.info()[["nodename"]])
[13:21:35.431]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:35.431]                               info)
[13:21:35.431]                             info <- base::paste(info, collapse = "; ")
[13:21:35.431]                             if (!has_future) {
[13:21:35.431]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:35.431]                                 info)
[13:21:35.431]                             }
[13:21:35.431]                             else {
[13:21:35.431]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:35.431]                                 info, version)
[13:21:35.431]                             }
[13:21:35.431]                             base::stop(msg)
[13:21:35.431]                           }
[13:21:35.431]                         })
[13:21:35.431]                       }
[13:21:35.431]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:35.431]                       base::options(mc.cores = 1L)
[13:21:35.431]                     }
[13:21:35.431]                     base::local({
[13:21:35.431]                       for (pkg in "future.apply") {
[13:21:35.431]                         base::loadNamespace(pkg)
[13:21:35.431]                         base::library(pkg, character.only = TRUE)
[13:21:35.431]                       }
[13:21:35.431]                     })
[13:21:35.431]                   }
[13:21:35.431]                   options(future.plan = NULL)
[13:21:35.431]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:35.431]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:35.431]                 }
[13:21:35.431]                 ...future.workdir <- getwd()
[13:21:35.431]             }
[13:21:35.431]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:35.431]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:35.431]         }
[13:21:35.431]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:35.431]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:35.431]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:35.431]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:35.431]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:35.431]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:35.431]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:35.431]             base::names(...future.oldOptions))
[13:21:35.431]     }
[13:21:35.431]     if (FALSE) {
[13:21:35.431]     }
[13:21:35.431]     else {
[13:21:35.431]         if (TRUE) {
[13:21:35.431]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:35.431]                 open = "w")
[13:21:35.431]         }
[13:21:35.431]         else {
[13:21:35.431]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:35.431]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:35.431]         }
[13:21:35.431]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:35.431]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:35.431]             base::sink(type = "output", split = FALSE)
[13:21:35.431]             base::close(...future.stdout)
[13:21:35.431]         }, add = TRUE)
[13:21:35.431]     }
[13:21:35.431]     ...future.frame <- base::sys.nframe()
[13:21:35.431]     ...future.conditions <- base::list()
[13:21:35.431]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:35.431]     if (FALSE) {
[13:21:35.431]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:35.431]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:35.431]     }
[13:21:35.431]     ...future.result <- base::tryCatch({
[13:21:35.431]         base::withCallingHandlers({
[13:21:35.431]             ...future.value <- base::withVisible(base::local({
[13:21:35.431]                 withCallingHandlers({
[13:21:35.431]                   {
[13:21:35.431]                     do.call(function(...) {
[13:21:35.431]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:35.431]                       if (!identical(...future.globals.maxSize.org, 
[13:21:35.431]                         ...future.globals.maxSize)) {
[13:21:35.431]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:35.431]                         on.exit(options(oopts), add = TRUE)
[13:21:35.431]                       }
[13:21:35.431]                       {
[13:21:35.431]                         lapply(seq_along(...future.elements_ii), 
[13:21:35.431]                           FUN = function(jj) {
[13:21:35.431]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:35.431]                             ...future.FUN(...future.X_jj, ...)
[13:21:35.431]                           })
[13:21:35.431]                       }
[13:21:35.431]                     }, args = future.call.arguments)
[13:21:35.431]                   }
[13:21:35.431]                 }, immediateCondition = function(cond) {
[13:21:35.431]                   save_rds <- function (object, pathname, ...) 
[13:21:35.431]                   {
[13:21:35.431]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:35.431]                     if (file_test("-f", pathname_tmp)) {
[13:21:35.431]                       fi_tmp <- file.info(pathname_tmp)
[13:21:35.431]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:35.431]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:35.431]                         fi_tmp[["mtime"]])
[13:21:35.431]                     }
[13:21:35.431]                     tryCatch({
[13:21:35.431]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:35.431]                     }, error = function(ex) {
[13:21:35.431]                       msg <- conditionMessage(ex)
[13:21:35.431]                       fi_tmp <- file.info(pathname_tmp)
[13:21:35.431]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:35.431]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:35.431]                         fi_tmp[["mtime"]], msg)
[13:21:35.431]                       ex$message <- msg
[13:21:35.431]                       stop(ex)
[13:21:35.431]                     })
[13:21:35.431]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:35.431]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:35.431]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:35.431]                       fi_tmp <- file.info(pathname_tmp)
[13:21:35.431]                       fi <- file.info(pathname)
[13:21:35.431]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:35.431]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:35.431]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:35.431]                         fi[["size"]], fi[["mtime"]])
[13:21:35.431]                       stop(msg)
[13:21:35.431]                     }
[13:21:35.431]                     invisible(pathname)
[13:21:35.431]                   }
[13:21:35.431]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:35.431]                     rootPath = tempdir()) 
[13:21:35.431]                   {
[13:21:35.431]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:35.431]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:35.431]                       tmpdir = path, fileext = ".rds")
[13:21:35.431]                     save_rds(obj, file)
[13:21:35.431]                   }
[13:21:35.431]                   saveImmediateCondition(cond, path = "/tmp/RtmpbpFWGO/.future/immediateConditions")
[13:21:35.431]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:35.431]                   {
[13:21:35.431]                     inherits <- base::inherits
[13:21:35.431]                     invokeRestart <- base::invokeRestart
[13:21:35.431]                     is.null <- base::is.null
[13:21:35.431]                     muffled <- FALSE
[13:21:35.431]                     if (inherits(cond, "message")) {
[13:21:35.431]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:35.431]                       if (muffled) 
[13:21:35.431]                         invokeRestart("muffleMessage")
[13:21:35.431]                     }
[13:21:35.431]                     else if (inherits(cond, "warning")) {
[13:21:35.431]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:35.431]                       if (muffled) 
[13:21:35.431]                         invokeRestart("muffleWarning")
[13:21:35.431]                     }
[13:21:35.431]                     else if (inherits(cond, "condition")) {
[13:21:35.431]                       if (!is.null(pattern)) {
[13:21:35.431]                         computeRestarts <- base::computeRestarts
[13:21:35.431]                         grepl <- base::grepl
[13:21:35.431]                         restarts <- computeRestarts(cond)
[13:21:35.431]                         for (restart in restarts) {
[13:21:35.431]                           name <- restart$name
[13:21:35.431]                           if (is.null(name)) 
[13:21:35.431]                             next
[13:21:35.431]                           if (!grepl(pattern, name)) 
[13:21:35.431]                             next
[13:21:35.431]                           invokeRestart(restart)
[13:21:35.431]                           muffled <- TRUE
[13:21:35.431]                           break
[13:21:35.431]                         }
[13:21:35.431]                       }
[13:21:35.431]                     }
[13:21:35.431]                     invisible(muffled)
[13:21:35.431]                   }
[13:21:35.431]                   muffleCondition(cond)
[13:21:35.431]                 })
[13:21:35.431]             }))
[13:21:35.431]             future::FutureResult(value = ...future.value$value, 
[13:21:35.431]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:35.431]                   ...future.rng), globalenv = if (FALSE) 
[13:21:35.431]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:35.431]                     ...future.globalenv.names))
[13:21:35.431]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:35.431]         }, condition = base::local({
[13:21:35.431]             c <- base::c
[13:21:35.431]             inherits <- base::inherits
[13:21:35.431]             invokeRestart <- base::invokeRestart
[13:21:35.431]             length <- base::length
[13:21:35.431]             list <- base::list
[13:21:35.431]             seq.int <- base::seq.int
[13:21:35.431]             signalCondition <- base::signalCondition
[13:21:35.431]             sys.calls <- base::sys.calls
[13:21:35.431]             `[[` <- base::`[[`
[13:21:35.431]             `+` <- base::`+`
[13:21:35.431]             `<<-` <- base::`<<-`
[13:21:35.431]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:35.431]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:35.431]                   3L)]
[13:21:35.431]             }
[13:21:35.431]             function(cond) {
[13:21:35.431]                 is_error <- inherits(cond, "error")
[13:21:35.431]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:35.431]                   NULL)
[13:21:35.431]                 if (is_error) {
[13:21:35.431]                   sessionInformation <- function() {
[13:21:35.431]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:35.431]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:35.431]                       search = base::search(), system = base::Sys.info())
[13:21:35.431]                   }
[13:21:35.431]                   ...future.conditions[[length(...future.conditions) + 
[13:21:35.431]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:35.431]                     cond$call), session = sessionInformation(), 
[13:21:35.431]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:35.431]                   signalCondition(cond)
[13:21:35.431]                 }
[13:21:35.431]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:35.431]                 "immediateCondition"))) {
[13:21:35.431]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:35.431]                   ...future.conditions[[length(...future.conditions) + 
[13:21:35.431]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:35.431]                   if (TRUE && !signal) {
[13:21:35.431]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:35.431]                     {
[13:21:35.431]                       inherits <- base::inherits
[13:21:35.431]                       invokeRestart <- base::invokeRestart
[13:21:35.431]                       is.null <- base::is.null
[13:21:35.431]                       muffled <- FALSE
[13:21:35.431]                       if (inherits(cond, "message")) {
[13:21:35.431]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:35.431]                         if (muffled) 
[13:21:35.431]                           invokeRestart("muffleMessage")
[13:21:35.431]                       }
[13:21:35.431]                       else if (inherits(cond, "warning")) {
[13:21:35.431]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:35.431]                         if (muffled) 
[13:21:35.431]                           invokeRestart("muffleWarning")
[13:21:35.431]                       }
[13:21:35.431]                       else if (inherits(cond, "condition")) {
[13:21:35.431]                         if (!is.null(pattern)) {
[13:21:35.431]                           computeRestarts <- base::computeRestarts
[13:21:35.431]                           grepl <- base::grepl
[13:21:35.431]                           restarts <- computeRestarts(cond)
[13:21:35.431]                           for (restart in restarts) {
[13:21:35.431]                             name <- restart$name
[13:21:35.431]                             if (is.null(name)) 
[13:21:35.431]                               next
[13:21:35.431]                             if (!grepl(pattern, name)) 
[13:21:35.431]                               next
[13:21:35.431]                             invokeRestart(restart)
[13:21:35.431]                             muffled <- TRUE
[13:21:35.431]                             break
[13:21:35.431]                           }
[13:21:35.431]                         }
[13:21:35.431]                       }
[13:21:35.431]                       invisible(muffled)
[13:21:35.431]                     }
[13:21:35.431]                     muffleCondition(cond, pattern = "^muffle")
[13:21:35.431]                   }
[13:21:35.431]                 }
[13:21:35.431]                 else {
[13:21:35.431]                   if (TRUE) {
[13:21:35.431]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:35.431]                     {
[13:21:35.431]                       inherits <- base::inherits
[13:21:35.431]                       invokeRestart <- base::invokeRestart
[13:21:35.431]                       is.null <- base::is.null
[13:21:35.431]                       muffled <- FALSE
[13:21:35.431]                       if (inherits(cond, "message")) {
[13:21:35.431]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:35.431]                         if (muffled) 
[13:21:35.431]                           invokeRestart("muffleMessage")
[13:21:35.431]                       }
[13:21:35.431]                       else if (inherits(cond, "warning")) {
[13:21:35.431]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:35.431]                         if (muffled) 
[13:21:35.431]                           invokeRestart("muffleWarning")
[13:21:35.431]                       }
[13:21:35.431]                       else if (inherits(cond, "condition")) {
[13:21:35.431]                         if (!is.null(pattern)) {
[13:21:35.431]                           computeRestarts <- base::computeRestarts
[13:21:35.431]                           grepl <- base::grepl
[13:21:35.431]                           restarts <- computeRestarts(cond)
[13:21:35.431]                           for (restart in restarts) {
[13:21:35.431]                             name <- restart$name
[13:21:35.431]                             if (is.null(name)) 
[13:21:35.431]                               next
[13:21:35.431]                             if (!grepl(pattern, name)) 
[13:21:35.431]                               next
[13:21:35.431]                             invokeRestart(restart)
[13:21:35.431]                             muffled <- TRUE
[13:21:35.431]                             break
[13:21:35.431]                           }
[13:21:35.431]                         }
[13:21:35.431]                       }
[13:21:35.431]                       invisible(muffled)
[13:21:35.431]                     }
[13:21:35.431]                     muffleCondition(cond, pattern = "^muffle")
[13:21:35.431]                   }
[13:21:35.431]                 }
[13:21:35.431]             }
[13:21:35.431]         }))
[13:21:35.431]     }, error = function(ex) {
[13:21:35.431]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:35.431]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:35.431]                 ...future.rng), started = ...future.startTime, 
[13:21:35.431]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:35.431]             version = "1.8"), class = "FutureResult")
[13:21:35.431]     }, finally = {
[13:21:35.431]         if (!identical(...future.workdir, getwd())) 
[13:21:35.431]             setwd(...future.workdir)
[13:21:35.431]         {
[13:21:35.431]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:35.431]                 ...future.oldOptions$nwarnings <- NULL
[13:21:35.431]             }
[13:21:35.431]             base::options(...future.oldOptions)
[13:21:35.431]             if (.Platform$OS.type == "windows") {
[13:21:35.431]                 old_names <- names(...future.oldEnvVars)
[13:21:35.431]                 envs <- base::Sys.getenv()
[13:21:35.431]                 names <- names(envs)
[13:21:35.431]                 common <- intersect(names, old_names)
[13:21:35.431]                 added <- setdiff(names, old_names)
[13:21:35.431]                 removed <- setdiff(old_names, names)
[13:21:35.431]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:35.431]                   envs[common]]
[13:21:35.431]                 NAMES <- toupper(changed)
[13:21:35.431]                 args <- list()
[13:21:35.431]                 for (kk in seq_along(NAMES)) {
[13:21:35.431]                   name <- changed[[kk]]
[13:21:35.431]                   NAME <- NAMES[[kk]]
[13:21:35.431]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:35.431]                     next
[13:21:35.431]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:35.431]                 }
[13:21:35.431]                 NAMES <- toupper(added)
[13:21:35.431]                 for (kk in seq_along(NAMES)) {
[13:21:35.431]                   name <- added[[kk]]
[13:21:35.431]                   NAME <- NAMES[[kk]]
[13:21:35.431]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:35.431]                     next
[13:21:35.431]                   args[[name]] <- ""
[13:21:35.431]                 }
[13:21:35.431]                 NAMES <- toupper(removed)
[13:21:35.431]                 for (kk in seq_along(NAMES)) {
[13:21:35.431]                   name <- removed[[kk]]
[13:21:35.431]                   NAME <- NAMES[[kk]]
[13:21:35.431]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:35.431]                     next
[13:21:35.431]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:35.431]                 }
[13:21:35.431]                 if (length(args) > 0) 
[13:21:35.431]                   base::do.call(base::Sys.setenv, args = args)
[13:21:35.431]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:35.431]             }
[13:21:35.431]             else {
[13:21:35.431]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:35.431]             }
[13:21:35.431]             {
[13:21:35.431]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:35.431]                   0L) {
[13:21:35.431]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:35.431]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:35.431]                   base::options(opts)
[13:21:35.431]                 }
[13:21:35.431]                 {
[13:21:35.431]                   {
[13:21:35.431]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:35.431]                     NULL
[13:21:35.431]                   }
[13:21:35.431]                   options(future.plan = NULL)
[13:21:35.431]                   if (is.na(NA_character_)) 
[13:21:35.431]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:35.431]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:35.431]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:35.431]                     envir = parent.frame()) 
[13:21:35.431]                   {
[13:21:35.431]                     default_workers <- missing(workers)
[13:21:35.431]                     if (is.function(workers)) 
[13:21:35.431]                       workers <- workers()
[13:21:35.431]                     workers <- structure(as.integer(workers), 
[13:21:35.431]                       class = class(workers))
[13:21:35.431]                     stop_if_not(is.finite(workers), workers >= 
[13:21:35.431]                       1L)
[13:21:35.431]                     if ((workers == 1L && !inherits(workers, 
[13:21:35.431]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:35.431]                       if (default_workers) 
[13:21:35.431]                         supportsMulticore(warn = TRUE)
[13:21:35.431]                       return(sequential(..., envir = envir))
[13:21:35.431]                     }
[13:21:35.431]                     oopts <- options(mc.cores = workers)
[13:21:35.431]                     on.exit(options(oopts))
[13:21:35.431]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:35.431]                       envir = envir)
[13:21:35.431]                     if (!future$lazy) 
[13:21:35.431]                       future <- run(future)
[13:21:35.431]                     invisible(future)
[13:21:35.431]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:35.431]                 }
[13:21:35.431]             }
[13:21:35.431]         }
[13:21:35.431]     })
[13:21:35.431]     if (TRUE) {
[13:21:35.431]         base::sink(type = "output", split = FALSE)
[13:21:35.431]         if (TRUE) {
[13:21:35.431]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:35.431]         }
[13:21:35.431]         else {
[13:21:35.431]             ...future.result["stdout"] <- base::list(NULL)
[13:21:35.431]         }
[13:21:35.431]         base::close(...future.stdout)
[13:21:35.431]         ...future.stdout <- NULL
[13:21:35.431]     }
[13:21:35.431]     ...future.result$conditions <- ...future.conditions
[13:21:35.431]     ...future.result$finished <- base::Sys.time()
[13:21:35.431]     ...future.result
[13:21:35.431] }
[13:21:35.435] assign_globals() ...
[13:21:35.435] List of 11
[13:21:35.435]  $ ...future.FUN            :function (x, ...)  
[13:21:35.435]  $ x_FUN                    :function (x)  
[13:21:35.435]  $ times                    : int 1
[13:21:35.435]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:35.435]  $ stop_if_not              :function (...)  
[13:21:35.435]  $ dim                      : NULL
[13:21:35.435]  $ valid_types              : chr [1:2] "logical" "integer"
[13:21:35.435]  $ future.call.arguments    : list()
[13:21:35.435]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:35.435]  $ ...future.elements_ii    :List of 2
[13:21:35.435]   ..$ b: num 2
[13:21:35.435]   ..$ c: num 3
[13:21:35.435]  $ ...future.seeds_ii       : NULL
[13:21:35.435]  $ ...future.globals.maxSize: NULL
[13:21:35.435]  - attr(*, "where")=List of 11
[13:21:35.435]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:35.435]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:35.435]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:35.435]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:35.435]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:35.435]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:35.435]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:35.435]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:35.435]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:35.435]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:35.435]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:35.435]  - attr(*, "resolved")= logi FALSE
[13:21:35.435]  - attr(*, "total_size")= num 94264
[13:21:35.435]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:35.435]  - attr(*, "already-done")= logi TRUE
[13:21:35.452] - copied ‘...future.FUN’ to environment
[13:21:35.452] - copied ‘x_FUN’ to environment
[13:21:35.452] - copied ‘times’ to environment
[13:21:35.453] - copied ‘stopf’ to environment
[13:21:35.453] - copied ‘stop_if_not’ to environment
[13:21:35.453] - copied ‘dim’ to environment
[13:21:35.453] - copied ‘valid_types’ to environment
[13:21:35.453] - copied ‘future.call.arguments’ to environment
[13:21:35.453] - copied ‘...future.elements_ii’ to environment
[13:21:35.453] - copied ‘...future.seeds_ii’ to environment
[13:21:35.453] - copied ‘...future.globals.maxSize’ to environment
[13:21:35.453] assign_globals() ... done
[13:21:35.454] requestCore(): workers = 2
[13:21:35.456] MulticoreFuture started
[13:21:35.456] - Launch lazy future ... done
[13:21:35.457] run() for ‘MulticoreFuture’ ... done
[13:21:35.457] Created future:
[13:21:35.458] plan(): Setting new future strategy stack:
[13:21:35.458] List of future strategies:
[13:21:35.458] 1. sequential:
[13:21:35.458]    - args: function (..., envir = parent.frame())
[13:21:35.458]    - tweaked: FALSE
[13:21:35.458]    - call: NULL
[13:21:35.459] plan(): nbrOfWorkers() = 1
[13:21:35.461] plan(): Setting new future strategy stack:
[13:21:35.461] List of future strategies:
[13:21:35.461] 1. multicore:
[13:21:35.461]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:35.461]    - tweaked: FALSE
[13:21:35.461]    - call: plan(strategy)
[13:21:35.467] plan(): nbrOfWorkers() = 2
[13:21:35.457] MulticoreFuture:
[13:21:35.457] Label: ‘future_vapply-2’
[13:21:35.457] Expression:
[13:21:35.457] {
[13:21:35.457]     do.call(function(...) {
[13:21:35.457]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:35.457]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:35.457]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:35.457]             on.exit(options(oopts), add = TRUE)
[13:21:35.457]         }
[13:21:35.457]         {
[13:21:35.457]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:35.457]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:35.457]                 ...future.FUN(...future.X_jj, ...)
[13:21:35.457]             })
[13:21:35.457]         }
[13:21:35.457]     }, args = future.call.arguments)
[13:21:35.457] }
[13:21:35.457] Lazy evaluation: FALSE
[13:21:35.457] Asynchronous evaluation: TRUE
[13:21:35.457] Local evaluation: TRUE
[13:21:35.457] Environment: R_GlobalEnv
[13:21:35.457] Capture standard output: TRUE
[13:21:35.457] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:35.457] Globals: 11 objects totaling 92.16 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:35.457] Packages: 1 packages (‘future.apply’)
[13:21:35.457] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:35.457] Resolved: TRUE
[13:21:35.457] Value: <not collected>
[13:21:35.457] Conditions captured: <none>
[13:21:35.457] Early signaling: FALSE
[13:21:35.457] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:35.457] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:35.468] Chunk #2 of 2 ... DONE
[13:21:35.468] Launching 2 futures (chunks) ... DONE
[13:21:35.469] Resolving 2 futures (chunks) ...
[13:21:35.469] resolve() on list ...
[13:21:35.469]  recursive: 0
[13:21:35.469]  length: 2
[13:21:35.469] 
[13:21:35.470] Future #1
[13:21:35.470] result() for MulticoreFuture ...
[13:21:35.471] result() for MulticoreFuture ...
[13:21:35.471] result() for MulticoreFuture ... done
[13:21:35.471] result() for MulticoreFuture ... done
[13:21:35.471] result() for MulticoreFuture ...
[13:21:35.472] result() for MulticoreFuture ... done
[13:21:35.472] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:21:35.472] - nx: 2
[13:21:35.472] - relay: TRUE
[13:21:35.472] - stdout: TRUE
[13:21:35.473] - signal: TRUE
[13:21:35.473] - resignal: FALSE
[13:21:35.473] - force: TRUE
[13:21:35.473] - relayed: [n=2] FALSE, FALSE
[13:21:35.473] - queued futures: [n=2] FALSE, FALSE
[13:21:35.473]  - until=1
[13:21:35.474]  - relaying element #1
[13:21:35.474] result() for MulticoreFuture ...
[13:21:35.474] result() for MulticoreFuture ... done
[13:21:35.474] result() for MulticoreFuture ...
[13:21:35.474] result() for MulticoreFuture ... done
[13:21:35.474] result() for MulticoreFuture ...
[13:21:35.475] result() for MulticoreFuture ... done
[13:21:35.475] result() for MulticoreFuture ...
[13:21:35.475] result() for MulticoreFuture ... done
[13:21:35.475] - relayed: [n=2] TRUE, FALSE
[13:21:35.475] - queued futures: [n=2] TRUE, FALSE
[13:21:35.475] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:21:35.476]  length: 1 (resolved future 1)
[13:21:35.476] Future #2
[13:21:35.476] result() for MulticoreFuture ...
[13:21:35.477] result() for MulticoreFuture ...
[13:21:35.477] result() for MulticoreFuture ... done
[13:21:35.477] result() for MulticoreFuture ... done
[13:21:35.477] result() for MulticoreFuture ...
[13:21:35.478] result() for MulticoreFuture ... done
[13:21:35.478] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:21:35.478] - nx: 2
[13:21:35.478] - relay: TRUE
[13:21:35.478] - stdout: TRUE
[13:21:35.478] - signal: TRUE
[13:21:35.478] - resignal: FALSE
[13:21:35.478] - force: TRUE
[13:21:35.479] - relayed: [n=2] TRUE, FALSE
[13:21:35.479] - queued futures: [n=2] TRUE, FALSE
[13:21:35.479]  - until=2
[13:21:35.479]  - relaying element #2
[13:21:35.479] result() for MulticoreFuture ...
[13:21:35.479] result() for MulticoreFuture ... done
[13:21:35.479] result() for MulticoreFuture ...
[13:21:35.480] result() for MulticoreFuture ... done
[13:21:35.482] result() for MulticoreFuture ...
[13:21:35.483] result() for MulticoreFuture ... done
[13:21:35.483] result() for MulticoreFuture ...
[13:21:35.483] result() for MulticoreFuture ... done
[13:21:35.483] - relayed: [n=2] TRUE, TRUE
[13:21:35.483] - queued futures: [n=2] TRUE, TRUE
[13:21:35.483] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:21:35.484]  length: 0 (resolved future 2)
[13:21:35.484] Relaying remaining futures
[13:21:35.484] signalConditionsASAP(NULL, pos=0) ...
[13:21:35.484] - nx: 2
[13:21:35.484] - relay: TRUE
[13:21:35.484] - stdout: TRUE
[13:21:35.485] - signal: TRUE
[13:21:35.485] - resignal: FALSE
[13:21:35.485] - force: TRUE
[13:21:35.485] - relayed: [n=2] TRUE, TRUE
[13:21:35.485] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:21:35.485] - relayed: [n=2] TRUE, TRUE
[13:21:35.486] - queued futures: [n=2] TRUE, TRUE
[13:21:35.486] signalConditionsASAP(NULL, pos=0) ... done
[13:21:35.486] resolve() on list ... DONE
[13:21:35.486] result() for MulticoreFuture ...
[13:21:35.486] result() for MulticoreFuture ... done
[13:21:35.486] result() for MulticoreFuture ...
[13:21:35.486] result() for MulticoreFuture ... done
[13:21:35.487] result() for MulticoreFuture ...
[13:21:35.487] result() for MulticoreFuture ... done
[13:21:35.487] result() for MulticoreFuture ...
[13:21:35.487] result() for MulticoreFuture ... done
[13:21:35.487]  - Number of value chunks collected: 2
[13:21:35.487] Resolving 2 futures (chunks) ... DONE
[13:21:35.488] Reducing values from 2 chunks ...
[13:21:35.488]  - Number of values collected after concatenation: 3
[13:21:35.488]  - Number of values expected: 3
[13:21:35.488] Reducing values from 2 chunks ... DONE
[13:21:35.488] future_lapply() ... DONE
- exceptions ...
[13:21:35.489] future_lapply() ...
[13:21:35.496] Number of chunks: 2
[13:21:35.497] getGlobalsAndPackagesXApply() ...
[13:21:35.497]  - future.globals: TRUE
[13:21:35.497] getGlobalsAndPackages() ...
[13:21:35.497] Searching for globals...
[13:21:35.501] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:21:35.501] Searching for globals ... DONE
[13:21:35.501] Resolving globals: FALSE
[13:21:35.502] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[13:21:35.503] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:35.503] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:35.503] - packages: [1] ‘future.apply’
[13:21:35.503] getGlobalsAndPackages() ... DONE
[13:21:35.503]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:35.503]  - needed namespaces: [n=1] ‘future.apply’
[13:21:35.504] Finding globals ... DONE
[13:21:35.504]  - use_args: TRUE
[13:21:35.504]  - Getting '...' globals ...
[13:21:35.504] resolve() on list ...
[13:21:35.504]  recursive: 0
[13:21:35.504]  length: 1
[13:21:35.504]  elements: ‘...’
[13:21:35.505]  length: 0 (resolved future 1)
[13:21:35.505] resolve() on list ... DONE
[13:21:35.505]    - '...' content: [n=0] 
[13:21:35.505] List of 1
[13:21:35.505]  $ ...: list()
[13:21:35.505]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:35.505]  - attr(*, "where")=List of 1
[13:21:35.505]   ..$ ...:<environment: 0x563b6f2bdb10> 
[13:21:35.505]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:35.505]  - attr(*, "resolved")= logi TRUE
[13:21:35.505]  - attr(*, "total_size")= num NA
[13:21:35.508]  - Getting '...' globals ... DONE
[13:21:35.508] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:35.511] List of 8
[13:21:35.511]  $ ...future.FUN:function (x, ...)  
[13:21:35.511]  $ x_FUN        :function (x)  
[13:21:35.511]  $ times        : int 2
[13:21:35.511]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:35.511]  $ stop_if_not  :function (...)  
[13:21:35.511]  $ dim          : NULL
[13:21:35.511]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:21:35.511]  $ ...          : list()
[13:21:35.511]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:35.511]  - attr(*, "where")=List of 8
[13:21:35.511]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:35.511]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:35.511]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:35.511]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:35.511]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:35.511]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:35.511]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:35.511]   ..$ ...          :<environment: 0x563b6f2bdb10> 
[13:21:35.511]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:35.511]  - attr(*, "resolved")= logi FALSE
[13:21:35.511]  - attr(*, "total_size")= num 95128
[13:21:35.518] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:21:35.518] getGlobalsAndPackagesXApply() ... DONE
[13:21:35.518] Number of futures (= number of chunks): 2
[13:21:35.519] Launching 2 futures (chunks) ...
[13:21:35.519] Chunk #1 of 2 ...
[13:21:35.519]  - Finding globals in 'X' for chunk #1 ...
[13:21:35.519] getGlobalsAndPackages() ...
[13:21:35.519] Searching for globals...
[13:21:35.519] 
[13:21:35.520] Searching for globals ... DONE
[13:21:35.520] - globals: [0] <none>
[13:21:35.520] getGlobalsAndPackages() ... DONE
[13:21:35.520]    + additional globals found: [n=0] 
[13:21:35.520]    + additional namespaces needed: [n=0] 
[13:21:35.520]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:35.520]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:35.520]  - seeds: <none>
[13:21:35.520]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:35.521] getGlobalsAndPackages() ...
[13:21:35.521] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:35.521] Resolving globals: FALSE
[13:21:35.521] Tweak future expression to call with '...' arguments ...
[13:21:35.521] {
[13:21:35.521]     do.call(function(...) {
[13:21:35.521]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:35.521]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:35.521]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:35.521]             on.exit(options(oopts), add = TRUE)
[13:21:35.521]         }
[13:21:35.521]         {
[13:21:35.521]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:35.521]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:35.521]                 ...future.FUN(...future.X_jj, ...)
[13:21:35.521]             })
[13:21:35.521]         }
[13:21:35.521]     }, args = future.call.arguments)
[13:21:35.521] }
[13:21:35.521] Tweak future expression to call with '...' arguments ... DONE
[13:21:35.522] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:35.522] - packages: [1] ‘future.apply’
[13:21:35.522] getGlobalsAndPackages() ... DONE
[13:21:35.522] run() for ‘Future’ ...
[13:21:35.523] - state: ‘created’
[13:21:35.523] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:35.527] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:35.527] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:35.527]   - Field: ‘label’
[13:21:35.527]   - Field: ‘local’
[13:21:35.527]   - Field: ‘owner’
[13:21:35.527]   - Field: ‘envir’
[13:21:35.527]   - Field: ‘workers’
[13:21:35.527]   - Field: ‘packages’
[13:21:35.528]   - Field: ‘gc’
[13:21:35.528]   - Field: ‘job’
[13:21:35.528]   - Field: ‘conditions’
[13:21:35.528]   - Field: ‘expr’
[13:21:35.528]   - Field: ‘uuid’
[13:21:35.528]   - Field: ‘seed’
[13:21:35.528]   - Field: ‘version’
[13:21:35.528]   - Field: ‘result’
[13:21:35.528]   - Field: ‘asynchronous’
[13:21:35.529]   - Field: ‘calls’
[13:21:35.529]   - Field: ‘globals’
[13:21:35.529]   - Field: ‘stdout’
[13:21:35.529]   - Field: ‘earlySignal’
[13:21:35.529]   - Field: ‘lazy’
[13:21:35.529]   - Field: ‘state’
[13:21:35.529] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:35.529] - Launch lazy future ...
[13:21:35.530] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:35.530] Packages needed by future strategies (n = 0): <none>
[13:21:35.530] {
[13:21:35.530]     {
[13:21:35.530]         {
[13:21:35.530]             ...future.startTime <- base::Sys.time()
[13:21:35.530]             {
[13:21:35.530]                 {
[13:21:35.530]                   {
[13:21:35.530]                     {
[13:21:35.530]                       {
[13:21:35.530]                         base::local({
[13:21:35.530]                           has_future <- base::requireNamespace("future", 
[13:21:35.530]                             quietly = TRUE)
[13:21:35.530]                           if (has_future) {
[13:21:35.530]                             ns <- base::getNamespace("future")
[13:21:35.530]                             version <- ns[[".package"]][["version"]]
[13:21:35.530]                             if (is.null(version)) 
[13:21:35.530]                               version <- utils::packageVersion("future")
[13:21:35.530]                           }
[13:21:35.530]                           else {
[13:21:35.530]                             version <- NULL
[13:21:35.530]                           }
[13:21:35.530]                           if (!has_future || version < "1.8.0") {
[13:21:35.530]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:35.530]                               "", base::R.version$version.string), 
[13:21:35.530]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:35.530]                                 base::R.version$platform, 8 * 
[13:21:35.530]                                   base::.Machine$sizeof.pointer), 
[13:21:35.530]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:35.530]                                 "release", "version")], collapse = " "), 
[13:21:35.530]                               hostname = base::Sys.info()[["nodename"]])
[13:21:35.530]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:35.530]                               info)
[13:21:35.530]                             info <- base::paste(info, collapse = "; ")
[13:21:35.530]                             if (!has_future) {
[13:21:35.530]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:35.530]                                 info)
[13:21:35.530]                             }
[13:21:35.530]                             else {
[13:21:35.530]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:35.530]                                 info, version)
[13:21:35.530]                             }
[13:21:35.530]                             base::stop(msg)
[13:21:35.530]                           }
[13:21:35.530]                         })
[13:21:35.530]                       }
[13:21:35.530]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:35.530]                       base::options(mc.cores = 1L)
[13:21:35.530]                     }
[13:21:35.530]                     base::local({
[13:21:35.530]                       for (pkg in "future.apply") {
[13:21:35.530]                         base::loadNamespace(pkg)
[13:21:35.530]                         base::library(pkg, character.only = TRUE)
[13:21:35.530]                       }
[13:21:35.530]                     })
[13:21:35.530]                   }
[13:21:35.530]                   options(future.plan = NULL)
[13:21:35.530]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:35.530]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:35.530]                 }
[13:21:35.530]                 ...future.workdir <- getwd()
[13:21:35.530]             }
[13:21:35.530]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:35.530]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:35.530]         }
[13:21:35.530]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:35.530]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:35.530]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:35.530]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:35.530]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:35.530]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:35.530]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:35.530]             base::names(...future.oldOptions))
[13:21:35.530]     }
[13:21:35.530]     if (FALSE) {
[13:21:35.530]     }
[13:21:35.530]     else {
[13:21:35.530]         if (TRUE) {
[13:21:35.530]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:35.530]                 open = "w")
[13:21:35.530]         }
[13:21:35.530]         else {
[13:21:35.530]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:35.530]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:35.530]         }
[13:21:35.530]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:35.530]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:35.530]             base::sink(type = "output", split = FALSE)
[13:21:35.530]             base::close(...future.stdout)
[13:21:35.530]         }, add = TRUE)
[13:21:35.530]     }
[13:21:35.530]     ...future.frame <- base::sys.nframe()
[13:21:35.530]     ...future.conditions <- base::list()
[13:21:35.530]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:35.530]     if (FALSE) {
[13:21:35.530]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:35.530]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:35.530]     }
[13:21:35.530]     ...future.result <- base::tryCatch({
[13:21:35.530]         base::withCallingHandlers({
[13:21:35.530]             ...future.value <- base::withVisible(base::local({
[13:21:35.530]                 withCallingHandlers({
[13:21:35.530]                   {
[13:21:35.530]                     do.call(function(...) {
[13:21:35.530]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:35.530]                       if (!identical(...future.globals.maxSize.org, 
[13:21:35.530]                         ...future.globals.maxSize)) {
[13:21:35.530]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:35.530]                         on.exit(options(oopts), add = TRUE)
[13:21:35.530]                       }
[13:21:35.530]                       {
[13:21:35.530]                         lapply(seq_along(...future.elements_ii), 
[13:21:35.530]                           FUN = function(jj) {
[13:21:35.530]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:35.530]                             ...future.FUN(...future.X_jj, ...)
[13:21:35.530]                           })
[13:21:35.530]                       }
[13:21:35.530]                     }, args = future.call.arguments)
[13:21:35.530]                   }
[13:21:35.530]                 }, immediateCondition = function(cond) {
[13:21:35.530]                   save_rds <- function (object, pathname, ...) 
[13:21:35.530]                   {
[13:21:35.530]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:35.530]                     if (file_test("-f", pathname_tmp)) {
[13:21:35.530]                       fi_tmp <- file.info(pathname_tmp)
[13:21:35.530]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:35.530]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:35.530]                         fi_tmp[["mtime"]])
[13:21:35.530]                     }
[13:21:35.530]                     tryCatch({
[13:21:35.530]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:35.530]                     }, error = function(ex) {
[13:21:35.530]                       msg <- conditionMessage(ex)
[13:21:35.530]                       fi_tmp <- file.info(pathname_tmp)
[13:21:35.530]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:35.530]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:35.530]                         fi_tmp[["mtime"]], msg)
[13:21:35.530]                       ex$message <- msg
[13:21:35.530]                       stop(ex)
[13:21:35.530]                     })
[13:21:35.530]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:35.530]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:35.530]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:35.530]                       fi_tmp <- file.info(pathname_tmp)
[13:21:35.530]                       fi <- file.info(pathname)
[13:21:35.530]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:35.530]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:35.530]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:35.530]                         fi[["size"]], fi[["mtime"]])
[13:21:35.530]                       stop(msg)
[13:21:35.530]                     }
[13:21:35.530]                     invisible(pathname)
[13:21:35.530]                   }
[13:21:35.530]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:35.530]                     rootPath = tempdir()) 
[13:21:35.530]                   {
[13:21:35.530]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:35.530]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:35.530]                       tmpdir = path, fileext = ".rds")
[13:21:35.530]                     save_rds(obj, file)
[13:21:35.530]                   }
[13:21:35.530]                   saveImmediateCondition(cond, path = "/tmp/RtmpbpFWGO/.future/immediateConditions")
[13:21:35.530]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:35.530]                   {
[13:21:35.530]                     inherits <- base::inherits
[13:21:35.530]                     invokeRestart <- base::invokeRestart
[13:21:35.530]                     is.null <- base::is.null
[13:21:35.530]                     muffled <- FALSE
[13:21:35.530]                     if (inherits(cond, "message")) {
[13:21:35.530]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:35.530]                       if (muffled) 
[13:21:35.530]                         invokeRestart("muffleMessage")
[13:21:35.530]                     }
[13:21:35.530]                     else if (inherits(cond, "warning")) {
[13:21:35.530]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:35.530]                       if (muffled) 
[13:21:35.530]                         invokeRestart("muffleWarning")
[13:21:35.530]                     }
[13:21:35.530]                     else if (inherits(cond, "condition")) {
[13:21:35.530]                       if (!is.null(pattern)) {
[13:21:35.530]                         computeRestarts <- base::computeRestarts
[13:21:35.530]                         grepl <- base::grepl
[13:21:35.530]                         restarts <- computeRestarts(cond)
[13:21:35.530]                         for (restart in restarts) {
[13:21:35.530]                           name <- restart$name
[13:21:35.530]                           if (is.null(name)) 
[13:21:35.530]                             next
[13:21:35.530]                           if (!grepl(pattern, name)) 
[13:21:35.530]                             next
[13:21:35.530]                           invokeRestart(restart)
[13:21:35.530]                           muffled <- TRUE
[13:21:35.530]                           break
[13:21:35.530]                         }
[13:21:35.530]                       }
[13:21:35.530]                     }
[13:21:35.530]                     invisible(muffled)
[13:21:35.530]                   }
[13:21:35.530]                   muffleCondition(cond)
[13:21:35.530]                 })
[13:21:35.530]             }))
[13:21:35.530]             future::FutureResult(value = ...future.value$value, 
[13:21:35.530]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:35.530]                   ...future.rng), globalenv = if (FALSE) 
[13:21:35.530]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:35.530]                     ...future.globalenv.names))
[13:21:35.530]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:35.530]         }, condition = base::local({
[13:21:35.530]             c <- base::c
[13:21:35.530]             inherits <- base::inherits
[13:21:35.530]             invokeRestart <- base::invokeRestart
[13:21:35.530]             length <- base::length
[13:21:35.530]             list <- base::list
[13:21:35.530]             seq.int <- base::seq.int
[13:21:35.530]             signalCondition <- base::signalCondition
[13:21:35.530]             sys.calls <- base::sys.calls
[13:21:35.530]             `[[` <- base::`[[`
[13:21:35.530]             `+` <- base::`+`
[13:21:35.530]             `<<-` <- base::`<<-`
[13:21:35.530]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:35.530]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:35.530]                   3L)]
[13:21:35.530]             }
[13:21:35.530]             function(cond) {
[13:21:35.530]                 is_error <- inherits(cond, "error")
[13:21:35.530]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:35.530]                   NULL)
[13:21:35.530]                 if (is_error) {
[13:21:35.530]                   sessionInformation <- function() {
[13:21:35.530]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:35.530]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:35.530]                       search = base::search(), system = base::Sys.info())
[13:21:35.530]                   }
[13:21:35.530]                   ...future.conditions[[length(...future.conditions) + 
[13:21:35.530]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:35.530]                     cond$call), session = sessionInformation(), 
[13:21:35.530]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:35.530]                   signalCondition(cond)
[13:21:35.530]                 }
[13:21:35.530]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:35.530]                 "immediateCondition"))) {
[13:21:35.530]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:35.530]                   ...future.conditions[[length(...future.conditions) + 
[13:21:35.530]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:35.530]                   if (TRUE && !signal) {
[13:21:35.530]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:35.530]                     {
[13:21:35.530]                       inherits <- base::inherits
[13:21:35.530]                       invokeRestart <- base::invokeRestart
[13:21:35.530]                       is.null <- base::is.null
[13:21:35.530]                       muffled <- FALSE
[13:21:35.530]                       if (inherits(cond, "message")) {
[13:21:35.530]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:35.530]                         if (muffled) 
[13:21:35.530]                           invokeRestart("muffleMessage")
[13:21:35.530]                       }
[13:21:35.530]                       else if (inherits(cond, "warning")) {
[13:21:35.530]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:35.530]                         if (muffled) 
[13:21:35.530]                           invokeRestart("muffleWarning")
[13:21:35.530]                       }
[13:21:35.530]                       else if (inherits(cond, "condition")) {
[13:21:35.530]                         if (!is.null(pattern)) {
[13:21:35.530]                           computeRestarts <- base::computeRestarts
[13:21:35.530]                           grepl <- base::grepl
[13:21:35.530]                           restarts <- computeRestarts(cond)
[13:21:35.530]                           for (restart in restarts) {
[13:21:35.530]                             name <- restart$name
[13:21:35.530]                             if (is.null(name)) 
[13:21:35.530]                               next
[13:21:35.530]                             if (!grepl(pattern, name)) 
[13:21:35.530]                               next
[13:21:35.530]                             invokeRestart(restart)
[13:21:35.530]                             muffled <- TRUE
[13:21:35.530]                             break
[13:21:35.530]                           }
[13:21:35.530]                         }
[13:21:35.530]                       }
[13:21:35.530]                       invisible(muffled)
[13:21:35.530]                     }
[13:21:35.530]                     muffleCondition(cond, pattern = "^muffle")
[13:21:35.530]                   }
[13:21:35.530]                 }
[13:21:35.530]                 else {
[13:21:35.530]                   if (TRUE) {
[13:21:35.530]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:35.530]                     {
[13:21:35.530]                       inherits <- base::inherits
[13:21:35.530]                       invokeRestart <- base::invokeRestart
[13:21:35.530]                       is.null <- base::is.null
[13:21:35.530]                       muffled <- FALSE
[13:21:35.530]                       if (inherits(cond, "message")) {
[13:21:35.530]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:35.530]                         if (muffled) 
[13:21:35.530]                           invokeRestart("muffleMessage")
[13:21:35.530]                       }
[13:21:35.530]                       else if (inherits(cond, "warning")) {
[13:21:35.530]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:35.530]                         if (muffled) 
[13:21:35.530]                           invokeRestart("muffleWarning")
[13:21:35.530]                       }
[13:21:35.530]                       else if (inherits(cond, "condition")) {
[13:21:35.530]                         if (!is.null(pattern)) {
[13:21:35.530]                           computeRestarts <- base::computeRestarts
[13:21:35.530]                           grepl <- base::grepl
[13:21:35.530]                           restarts <- computeRestarts(cond)
[13:21:35.530]                           for (restart in restarts) {
[13:21:35.530]                             name <- restart$name
[13:21:35.530]                             if (is.null(name)) 
[13:21:35.530]                               next
[13:21:35.530]                             if (!grepl(pattern, name)) 
[13:21:35.530]                               next
[13:21:35.530]                             invokeRestart(restart)
[13:21:35.530]                             muffled <- TRUE
[13:21:35.530]                             break
[13:21:35.530]                           }
[13:21:35.530]                         }
[13:21:35.530]                       }
[13:21:35.530]                       invisible(muffled)
[13:21:35.530]                     }
[13:21:35.530]                     muffleCondition(cond, pattern = "^muffle")
[13:21:35.530]                   }
[13:21:35.530]                 }
[13:21:35.530]             }
[13:21:35.530]         }))
[13:21:35.530]     }, error = function(ex) {
[13:21:35.530]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:35.530]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:35.530]                 ...future.rng), started = ...future.startTime, 
[13:21:35.530]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:35.530]             version = "1.8"), class = "FutureResult")
[13:21:35.530]     }, finally = {
[13:21:35.530]         if (!identical(...future.workdir, getwd())) 
[13:21:35.530]             setwd(...future.workdir)
[13:21:35.530]         {
[13:21:35.530]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:35.530]                 ...future.oldOptions$nwarnings <- NULL
[13:21:35.530]             }
[13:21:35.530]             base::options(...future.oldOptions)
[13:21:35.530]             if (.Platform$OS.type == "windows") {
[13:21:35.530]                 old_names <- names(...future.oldEnvVars)
[13:21:35.530]                 envs <- base::Sys.getenv()
[13:21:35.530]                 names <- names(envs)
[13:21:35.530]                 common <- intersect(names, old_names)
[13:21:35.530]                 added <- setdiff(names, old_names)
[13:21:35.530]                 removed <- setdiff(old_names, names)
[13:21:35.530]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:35.530]                   envs[common]]
[13:21:35.530]                 NAMES <- toupper(changed)
[13:21:35.530]                 args <- list()
[13:21:35.530]                 for (kk in seq_along(NAMES)) {
[13:21:35.530]                   name <- changed[[kk]]
[13:21:35.530]                   NAME <- NAMES[[kk]]
[13:21:35.530]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:35.530]                     next
[13:21:35.530]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:35.530]                 }
[13:21:35.530]                 NAMES <- toupper(added)
[13:21:35.530]                 for (kk in seq_along(NAMES)) {
[13:21:35.530]                   name <- added[[kk]]
[13:21:35.530]                   NAME <- NAMES[[kk]]
[13:21:35.530]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:35.530]                     next
[13:21:35.530]                   args[[name]] <- ""
[13:21:35.530]                 }
[13:21:35.530]                 NAMES <- toupper(removed)
[13:21:35.530]                 for (kk in seq_along(NAMES)) {
[13:21:35.530]                   name <- removed[[kk]]
[13:21:35.530]                   NAME <- NAMES[[kk]]
[13:21:35.530]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:35.530]                     next
[13:21:35.530]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:35.530]                 }
[13:21:35.530]                 if (length(args) > 0) 
[13:21:35.530]                   base::do.call(base::Sys.setenv, args = args)
[13:21:35.530]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:35.530]             }
[13:21:35.530]             else {
[13:21:35.530]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:35.530]             }
[13:21:35.530]             {
[13:21:35.530]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:35.530]                   0L) {
[13:21:35.530]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:35.530]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:35.530]                   base::options(opts)
[13:21:35.530]                 }
[13:21:35.530]                 {
[13:21:35.530]                   {
[13:21:35.530]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:35.530]                     NULL
[13:21:35.530]                   }
[13:21:35.530]                   options(future.plan = NULL)
[13:21:35.530]                   if (is.na(NA_character_)) 
[13:21:35.530]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:35.530]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:35.530]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:35.530]                     envir = parent.frame()) 
[13:21:35.530]                   {
[13:21:35.530]                     default_workers <- missing(workers)
[13:21:35.530]                     if (is.function(workers)) 
[13:21:35.530]                       workers <- workers()
[13:21:35.530]                     workers <- structure(as.integer(workers), 
[13:21:35.530]                       class = class(workers))
[13:21:35.530]                     stop_if_not(is.finite(workers), workers >= 
[13:21:35.530]                       1L)
[13:21:35.530]                     if ((workers == 1L && !inherits(workers, 
[13:21:35.530]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:35.530]                       if (default_workers) 
[13:21:35.530]                         supportsMulticore(warn = TRUE)
[13:21:35.530]                       return(sequential(..., envir = envir))
[13:21:35.530]                     }
[13:21:35.530]                     oopts <- options(mc.cores = workers)
[13:21:35.530]                     on.exit(options(oopts))
[13:21:35.530]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:35.530]                       envir = envir)
[13:21:35.530]                     if (!future$lazy) 
[13:21:35.530]                       future <- run(future)
[13:21:35.530]                     invisible(future)
[13:21:35.530]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:35.530]                 }
[13:21:35.530]             }
[13:21:35.530]         }
[13:21:35.530]     })
[13:21:35.530]     if (TRUE) {
[13:21:35.530]         base::sink(type = "output", split = FALSE)
[13:21:35.530]         if (TRUE) {
[13:21:35.530]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:35.530]         }
[13:21:35.530]         else {
[13:21:35.530]             ...future.result["stdout"] <- base::list(NULL)
[13:21:35.530]         }
[13:21:35.530]         base::close(...future.stdout)
[13:21:35.530]         ...future.stdout <- NULL
[13:21:35.530]     }
[13:21:35.530]     ...future.result$conditions <- ...future.conditions
[13:21:35.530]     ...future.result$finished <- base::Sys.time()
[13:21:35.530]     ...future.result
[13:21:35.530] }
[13:21:35.533] assign_globals() ...
[13:21:35.533] List of 11
[13:21:35.533]  $ ...future.FUN            :function (x, ...)  
[13:21:35.533]  $ x_FUN                    :function (x)  
[13:21:35.533]  $ times                    : int 2
[13:21:35.533]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:35.533]  $ stop_if_not              :function (...)  
[13:21:35.533]  $ dim                      : NULL
[13:21:35.533]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:21:35.533]  $ future.call.arguments    : list()
[13:21:35.533]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:35.533]  $ ...future.elements_ii    :List of 1
[13:21:35.533]   ..$ : int 1
[13:21:35.533]  $ ...future.seeds_ii       : NULL
[13:21:35.533]  $ ...future.globals.maxSize: NULL
[13:21:35.533]  - attr(*, "where")=List of 11
[13:21:35.533]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:35.533]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:35.533]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:35.533]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:35.533]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:35.533]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:35.533]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:35.533]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:35.533]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:35.533]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:35.533]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:35.533]  - attr(*, "resolved")= logi FALSE
[13:21:35.533]  - attr(*, "total_size")= num 95128
[13:21:35.533]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:35.533]  - attr(*, "already-done")= logi TRUE
[13:21:35.545] - copied ‘...future.FUN’ to environment
[13:21:35.545] - copied ‘x_FUN’ to environment
[13:21:35.545] - copied ‘times’ to environment
[13:21:35.546] - copied ‘stopf’ to environment
[13:21:35.546] - copied ‘stop_if_not’ to environment
[13:21:35.546] - copied ‘dim’ to environment
[13:21:35.546] - copied ‘valid_types’ to environment
[13:21:35.546] - copied ‘future.call.arguments’ to environment
[13:21:35.546] - copied ‘...future.elements_ii’ to environment
[13:21:35.546] - copied ‘...future.seeds_ii’ to environment
[13:21:35.546] - copied ‘...future.globals.maxSize’ to environment
[13:21:35.547] assign_globals() ... done
[13:21:35.547] requestCore(): workers = 2
[13:21:35.549] MulticoreFuture started
[13:21:35.550] - Launch lazy future ... done
[13:21:35.550] run() for ‘MulticoreFuture’ ... done
[13:21:35.550] Created future:
[13:21:35.551] plan(): Setting new future strategy stack:
[13:21:35.551] List of future strategies:
[13:21:35.551] 1. sequential:
[13:21:35.551]    - args: function (..., envir = parent.frame())
[13:21:35.551]    - tweaked: FALSE
[13:21:35.551]    - call: NULL
[13:21:35.552] plan(): nbrOfWorkers() = 1
[13:21:35.554] plan(): Setting new future strategy stack:
[13:21:35.555] List of future strategies:
[13:21:35.555] 1. multicore:
[13:21:35.555]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:35.555]    - tweaked: FALSE
[13:21:35.555]    - call: plan(strategy)
[13:21:35.560] plan(): nbrOfWorkers() = 2
[13:21:35.551] MulticoreFuture:
[13:21:35.551] Label: ‘future_vapply-1’
[13:21:35.551] Expression:
[13:21:35.551] {
[13:21:35.551]     do.call(function(...) {
[13:21:35.551]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:35.551]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:35.551]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:35.551]             on.exit(options(oopts), add = TRUE)
[13:21:35.551]         }
[13:21:35.551]         {
[13:21:35.551]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:35.551]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:35.551]                 ...future.FUN(...future.X_jj, ...)
[13:21:35.551]             })
[13:21:35.551]         }
[13:21:35.551]     }, args = future.call.arguments)
[13:21:35.551] }
[13:21:35.551] Lazy evaluation: FALSE
[13:21:35.551] Asynchronous evaluation: TRUE
[13:21:35.551] Local evaluation: TRUE
[13:21:35.551] Environment: R_GlobalEnv
[13:21:35.551] Capture standard output: TRUE
[13:21:35.551] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:35.551] Globals: 11 objects totaling 92.95 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:35.551] Packages: 1 packages (‘future.apply’)
[13:21:35.551] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:35.551] Resolved: FALSE
[13:21:35.551] Value: <not collected>
[13:21:35.551] Conditions captured: <none>
[13:21:35.551] Early signaling: FALSE
[13:21:35.551] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:35.551] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:35.564] Chunk #1 of 2 ... DONE
[13:21:35.565] Chunk #2 of 2 ...
[13:21:35.565]  - Finding globals in 'X' for chunk #2 ...
[13:21:35.565] getGlobalsAndPackages() ...
[13:21:35.565] Searching for globals...
[13:21:35.566] 
[13:21:35.566] Searching for globals ... DONE
[13:21:35.566] - globals: [0] <none>
[13:21:35.566] getGlobalsAndPackages() ... DONE
[13:21:35.566]    + additional globals found: [n=0] 
[13:21:35.567]    + additional namespaces needed: [n=0] 
[13:21:35.567]  - Finding globals in 'X' for chunk #2 ... DONE
[13:21:35.567]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:35.567]  - seeds: <none>
[13:21:35.567]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:35.567] getGlobalsAndPackages() ...
[13:21:35.568] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:35.568] Resolving globals: FALSE
[13:21:35.568] Tweak future expression to call with '...' arguments ...
[13:21:35.568] {
[13:21:35.568]     do.call(function(...) {
[13:21:35.568]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:35.568]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:35.568]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:35.568]             on.exit(options(oopts), add = TRUE)
[13:21:35.568]         }
[13:21:35.568]         {
[13:21:35.568]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:35.568]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:35.568]                 ...future.FUN(...future.X_jj, ...)
[13:21:35.568]             })
[13:21:35.568]         }
[13:21:35.568]     }, args = future.call.arguments)
[13:21:35.568] }
[13:21:35.569] Tweak future expression to call with '...' arguments ... DONE
[13:21:35.569] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:35.570] - packages: [1] ‘future.apply’
[13:21:35.570] getGlobalsAndPackages() ... DONE
[13:21:35.570] run() for ‘Future’ ...
[13:21:35.570] - state: ‘created’
[13:21:35.571] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:35.575] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:35.576] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:35.576]   - Field: ‘label’
[13:21:35.576]   - Field: ‘local’
[13:21:35.576]   - Field: ‘owner’
[13:21:35.576]   - Field: ‘envir’
[13:21:35.576]   - Field: ‘workers’
[13:21:35.577]   - Field: ‘packages’
[13:21:35.577]   - Field: ‘gc’
[13:21:35.577]   - Field: ‘job’
[13:21:35.577]   - Field: ‘conditions’
[13:21:35.577]   - Field: ‘expr’
[13:21:35.577]   - Field: ‘uuid’
[13:21:35.577]   - Field: ‘seed’
[13:21:35.578]   - Field: ‘version’
[13:21:35.578]   - Field: ‘result’
[13:21:35.578]   - Field: ‘asynchronous’
[13:21:35.578]   - Field: ‘calls’
[13:21:35.578]   - Field: ‘globals’
[13:21:35.578]   - Field: ‘stdout’
[13:21:35.579]   - Field: ‘earlySignal’
[13:21:35.579]   - Field: ‘lazy’
[13:21:35.579]   - Field: ‘state’
[13:21:35.579] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:35.579] - Launch lazy future ...
[13:21:35.580] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:35.580] Packages needed by future strategies (n = 0): <none>
[13:21:35.581] {
[13:21:35.581]     {
[13:21:35.581]         {
[13:21:35.581]             ...future.startTime <- base::Sys.time()
[13:21:35.581]             {
[13:21:35.581]                 {
[13:21:35.581]                   {
[13:21:35.581]                     {
[13:21:35.581]                       {
[13:21:35.581]                         base::local({
[13:21:35.581]                           has_future <- base::requireNamespace("future", 
[13:21:35.581]                             quietly = TRUE)
[13:21:35.581]                           if (has_future) {
[13:21:35.581]                             ns <- base::getNamespace("future")
[13:21:35.581]                             version <- ns[[".package"]][["version"]]
[13:21:35.581]                             if (is.null(version)) 
[13:21:35.581]                               version <- utils::packageVersion("future")
[13:21:35.581]                           }
[13:21:35.581]                           else {
[13:21:35.581]                             version <- NULL
[13:21:35.581]                           }
[13:21:35.581]                           if (!has_future || version < "1.8.0") {
[13:21:35.581]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:35.581]                               "", base::R.version$version.string), 
[13:21:35.581]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:35.581]                                 base::R.version$platform, 8 * 
[13:21:35.581]                                   base::.Machine$sizeof.pointer), 
[13:21:35.581]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:35.581]                                 "release", "version")], collapse = " "), 
[13:21:35.581]                               hostname = base::Sys.info()[["nodename"]])
[13:21:35.581]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:35.581]                               info)
[13:21:35.581]                             info <- base::paste(info, collapse = "; ")
[13:21:35.581]                             if (!has_future) {
[13:21:35.581]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:35.581]                                 info)
[13:21:35.581]                             }
[13:21:35.581]                             else {
[13:21:35.581]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:35.581]                                 info, version)
[13:21:35.581]                             }
[13:21:35.581]                             base::stop(msg)
[13:21:35.581]                           }
[13:21:35.581]                         })
[13:21:35.581]                       }
[13:21:35.581]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:35.581]                       base::options(mc.cores = 1L)
[13:21:35.581]                     }
[13:21:35.581]                     base::local({
[13:21:35.581]                       for (pkg in "future.apply") {
[13:21:35.581]                         base::loadNamespace(pkg)
[13:21:35.581]                         base::library(pkg, character.only = TRUE)
[13:21:35.581]                       }
[13:21:35.581]                     })
[13:21:35.581]                   }
[13:21:35.581]                   options(future.plan = NULL)
[13:21:35.581]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:35.581]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:35.581]                 }
[13:21:35.581]                 ...future.workdir <- getwd()
[13:21:35.581]             }
[13:21:35.581]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:35.581]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:35.581]         }
[13:21:35.581]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:35.581]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:35.581]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:35.581]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:35.581]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:35.581]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:35.581]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:35.581]             base::names(...future.oldOptions))
[13:21:35.581]     }
[13:21:35.581]     if (FALSE) {
[13:21:35.581]     }
[13:21:35.581]     else {
[13:21:35.581]         if (TRUE) {
[13:21:35.581]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:35.581]                 open = "w")
[13:21:35.581]         }
[13:21:35.581]         else {
[13:21:35.581]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:35.581]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:35.581]         }
[13:21:35.581]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:35.581]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:35.581]             base::sink(type = "output", split = FALSE)
[13:21:35.581]             base::close(...future.stdout)
[13:21:35.581]         }, add = TRUE)
[13:21:35.581]     }
[13:21:35.581]     ...future.frame <- base::sys.nframe()
[13:21:35.581]     ...future.conditions <- base::list()
[13:21:35.581]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:35.581]     if (FALSE) {
[13:21:35.581]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:35.581]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:35.581]     }
[13:21:35.581]     ...future.result <- base::tryCatch({
[13:21:35.581]         base::withCallingHandlers({
[13:21:35.581]             ...future.value <- base::withVisible(base::local({
[13:21:35.581]                 withCallingHandlers({
[13:21:35.581]                   {
[13:21:35.581]                     do.call(function(...) {
[13:21:35.581]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:35.581]                       if (!identical(...future.globals.maxSize.org, 
[13:21:35.581]                         ...future.globals.maxSize)) {
[13:21:35.581]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:35.581]                         on.exit(options(oopts), add = TRUE)
[13:21:35.581]                       }
[13:21:35.581]                       {
[13:21:35.581]                         lapply(seq_along(...future.elements_ii), 
[13:21:35.581]                           FUN = function(jj) {
[13:21:35.581]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:35.581]                             ...future.FUN(...future.X_jj, ...)
[13:21:35.581]                           })
[13:21:35.581]                       }
[13:21:35.581]                     }, args = future.call.arguments)
[13:21:35.581]                   }
[13:21:35.581]                 }, immediateCondition = function(cond) {
[13:21:35.581]                   save_rds <- function (object, pathname, ...) 
[13:21:35.581]                   {
[13:21:35.581]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:35.581]                     if (file_test("-f", pathname_tmp)) {
[13:21:35.581]                       fi_tmp <- file.info(pathname_tmp)
[13:21:35.581]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:35.581]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:35.581]                         fi_tmp[["mtime"]])
[13:21:35.581]                     }
[13:21:35.581]                     tryCatch({
[13:21:35.581]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:35.581]                     }, error = function(ex) {
[13:21:35.581]                       msg <- conditionMessage(ex)
[13:21:35.581]                       fi_tmp <- file.info(pathname_tmp)
[13:21:35.581]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:35.581]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:35.581]                         fi_tmp[["mtime"]], msg)
[13:21:35.581]                       ex$message <- msg
[13:21:35.581]                       stop(ex)
[13:21:35.581]                     })
[13:21:35.581]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:35.581]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:35.581]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:35.581]                       fi_tmp <- file.info(pathname_tmp)
[13:21:35.581]                       fi <- file.info(pathname)
[13:21:35.581]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:35.581]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:35.581]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:35.581]                         fi[["size"]], fi[["mtime"]])
[13:21:35.581]                       stop(msg)
[13:21:35.581]                     }
[13:21:35.581]                     invisible(pathname)
[13:21:35.581]                   }
[13:21:35.581]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:35.581]                     rootPath = tempdir()) 
[13:21:35.581]                   {
[13:21:35.581]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:35.581]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:35.581]                       tmpdir = path, fileext = ".rds")
[13:21:35.581]                     save_rds(obj, file)
[13:21:35.581]                   }
[13:21:35.581]                   saveImmediateCondition(cond, path = "/tmp/RtmpbpFWGO/.future/immediateConditions")
[13:21:35.581]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:35.581]                   {
[13:21:35.581]                     inherits <- base::inherits
[13:21:35.581]                     invokeRestart <- base::invokeRestart
[13:21:35.581]                     is.null <- base::is.null
[13:21:35.581]                     muffled <- FALSE
[13:21:35.581]                     if (inherits(cond, "message")) {
[13:21:35.581]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:35.581]                       if (muffled) 
[13:21:35.581]                         invokeRestart("muffleMessage")
[13:21:35.581]                     }
[13:21:35.581]                     else if (inherits(cond, "warning")) {
[13:21:35.581]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:35.581]                       if (muffled) 
[13:21:35.581]                         invokeRestart("muffleWarning")
[13:21:35.581]                     }
[13:21:35.581]                     else if (inherits(cond, "condition")) {
[13:21:35.581]                       if (!is.null(pattern)) {
[13:21:35.581]                         computeRestarts <- base::computeRestarts
[13:21:35.581]                         grepl <- base::grepl
[13:21:35.581]                         restarts <- computeRestarts(cond)
[13:21:35.581]                         for (restart in restarts) {
[13:21:35.581]                           name <- restart$name
[13:21:35.581]                           if (is.null(name)) 
[13:21:35.581]                             next
[13:21:35.581]                           if (!grepl(pattern, name)) 
[13:21:35.581]                             next
[13:21:35.581]                           invokeRestart(restart)
[13:21:35.581]                           muffled <- TRUE
[13:21:35.581]                           break
[13:21:35.581]                         }
[13:21:35.581]                       }
[13:21:35.581]                     }
[13:21:35.581]                     invisible(muffled)
[13:21:35.581]                   }
[13:21:35.581]                   muffleCondition(cond)
[13:21:35.581]                 })
[13:21:35.581]             }))
[13:21:35.581]             future::FutureResult(value = ...future.value$value, 
[13:21:35.581]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:35.581]                   ...future.rng), globalenv = if (FALSE) 
[13:21:35.581]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:35.581]                     ...future.globalenv.names))
[13:21:35.581]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:35.581]         }, condition = base::local({
[13:21:35.581]             c <- base::c
[13:21:35.581]             inherits <- base::inherits
[13:21:35.581]             invokeRestart <- base::invokeRestart
[13:21:35.581]             length <- base::length
[13:21:35.581]             list <- base::list
[13:21:35.581]             seq.int <- base::seq.int
[13:21:35.581]             signalCondition <- base::signalCondition
[13:21:35.581]             sys.calls <- base::sys.calls
[13:21:35.581]             `[[` <- base::`[[`
[13:21:35.581]             `+` <- base::`+`
[13:21:35.581]             `<<-` <- base::`<<-`
[13:21:35.581]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:35.581]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:35.581]                   3L)]
[13:21:35.581]             }
[13:21:35.581]             function(cond) {
[13:21:35.581]                 is_error <- inherits(cond, "error")
[13:21:35.581]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:35.581]                   NULL)
[13:21:35.581]                 if (is_error) {
[13:21:35.581]                   sessionInformation <- function() {
[13:21:35.581]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:35.581]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:35.581]                       search = base::search(), system = base::Sys.info())
[13:21:35.581]                   }
[13:21:35.581]                   ...future.conditions[[length(...future.conditions) + 
[13:21:35.581]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:35.581]                     cond$call), session = sessionInformation(), 
[13:21:35.581]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:35.581]                   signalCondition(cond)
[13:21:35.581]                 }
[13:21:35.581]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:35.581]                 "immediateCondition"))) {
[13:21:35.581]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:35.581]                   ...future.conditions[[length(...future.conditions) + 
[13:21:35.581]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:35.581]                   if (TRUE && !signal) {
[13:21:35.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:35.581]                     {
[13:21:35.581]                       inherits <- base::inherits
[13:21:35.581]                       invokeRestart <- base::invokeRestart
[13:21:35.581]                       is.null <- base::is.null
[13:21:35.581]                       muffled <- FALSE
[13:21:35.581]                       if (inherits(cond, "message")) {
[13:21:35.581]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:35.581]                         if (muffled) 
[13:21:35.581]                           invokeRestart("muffleMessage")
[13:21:35.581]                       }
[13:21:35.581]                       else if (inherits(cond, "warning")) {
[13:21:35.581]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:35.581]                         if (muffled) 
[13:21:35.581]                           invokeRestart("muffleWarning")
[13:21:35.581]                       }
[13:21:35.581]                       else if (inherits(cond, "condition")) {
[13:21:35.581]                         if (!is.null(pattern)) {
[13:21:35.581]                           computeRestarts <- base::computeRestarts
[13:21:35.581]                           grepl <- base::grepl
[13:21:35.581]                           restarts <- computeRestarts(cond)
[13:21:35.581]                           for (restart in restarts) {
[13:21:35.581]                             name <- restart$name
[13:21:35.581]                             if (is.null(name)) 
[13:21:35.581]                               next
[13:21:35.581]                             if (!grepl(pattern, name)) 
[13:21:35.581]                               next
[13:21:35.581]                             invokeRestart(restart)
[13:21:35.581]                             muffled <- TRUE
[13:21:35.581]                             break
[13:21:35.581]                           }
[13:21:35.581]                         }
[13:21:35.581]                       }
[13:21:35.581]                       invisible(muffled)
[13:21:35.581]                     }
[13:21:35.581]                     muffleCondition(cond, pattern = "^muffle")
[13:21:35.581]                   }
[13:21:35.581]                 }
[13:21:35.581]                 else {
[13:21:35.581]                   if (TRUE) {
[13:21:35.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:35.581]                     {
[13:21:35.581]                       inherits <- base::inherits
[13:21:35.581]                       invokeRestart <- base::invokeRestart
[13:21:35.581]                       is.null <- base::is.null
[13:21:35.581]                       muffled <- FALSE
[13:21:35.581]                       if (inherits(cond, "message")) {
[13:21:35.581]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:35.581]                         if (muffled) 
[13:21:35.581]                           invokeRestart("muffleMessage")
[13:21:35.581]                       }
[13:21:35.581]                       else if (inherits(cond, "warning")) {
[13:21:35.581]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:35.581]                         if (muffled) 
[13:21:35.581]                           invokeRestart("muffleWarning")
[13:21:35.581]                       }
[13:21:35.581]                       else if (inherits(cond, "condition")) {
[13:21:35.581]                         if (!is.null(pattern)) {
[13:21:35.581]                           computeRestarts <- base::computeRestarts
[13:21:35.581]                           grepl <- base::grepl
[13:21:35.581]                           restarts <- computeRestarts(cond)
[13:21:35.581]                           for (restart in restarts) {
[13:21:35.581]                             name <- restart$name
[13:21:35.581]                             if (is.null(name)) 
[13:21:35.581]                               next
[13:21:35.581]                             if (!grepl(pattern, name)) 
[13:21:35.581]                               next
[13:21:35.581]                             invokeRestart(restart)
[13:21:35.581]                             muffled <- TRUE
[13:21:35.581]                             break
[13:21:35.581]                           }
[13:21:35.581]                         }
[13:21:35.581]                       }
[13:21:35.581]                       invisible(muffled)
[13:21:35.581]                     }
[13:21:35.581]                     muffleCondition(cond, pattern = "^muffle")
[13:21:35.581]                   }
[13:21:35.581]                 }
[13:21:35.581]             }
[13:21:35.581]         }))
[13:21:35.581]     }, error = function(ex) {
[13:21:35.581]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:35.581]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:35.581]                 ...future.rng), started = ...future.startTime, 
[13:21:35.581]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:35.581]             version = "1.8"), class = "FutureResult")
[13:21:35.581]     }, finally = {
[13:21:35.581]         if (!identical(...future.workdir, getwd())) 
[13:21:35.581]             setwd(...future.workdir)
[13:21:35.581]         {
[13:21:35.581]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:35.581]                 ...future.oldOptions$nwarnings <- NULL
[13:21:35.581]             }
[13:21:35.581]             base::options(...future.oldOptions)
[13:21:35.581]             if (.Platform$OS.type == "windows") {
[13:21:35.581]                 old_names <- names(...future.oldEnvVars)
[13:21:35.581]                 envs <- base::Sys.getenv()
[13:21:35.581]                 names <- names(envs)
[13:21:35.581]                 common <- intersect(names, old_names)
[13:21:35.581]                 added <- setdiff(names, old_names)
[13:21:35.581]                 removed <- setdiff(old_names, names)
[13:21:35.581]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:35.581]                   envs[common]]
[13:21:35.581]                 NAMES <- toupper(changed)
[13:21:35.581]                 args <- list()
[13:21:35.581]                 for (kk in seq_along(NAMES)) {
[13:21:35.581]                   name <- changed[[kk]]
[13:21:35.581]                   NAME <- NAMES[[kk]]
[13:21:35.581]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:35.581]                     next
[13:21:35.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:35.581]                 }
[13:21:35.581]                 NAMES <- toupper(added)
[13:21:35.581]                 for (kk in seq_along(NAMES)) {
[13:21:35.581]                   name <- added[[kk]]
[13:21:35.581]                   NAME <- NAMES[[kk]]
[13:21:35.581]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:35.581]                     next
[13:21:35.581]                   args[[name]] <- ""
[13:21:35.581]                 }
[13:21:35.581]                 NAMES <- toupper(removed)
[13:21:35.581]                 for (kk in seq_along(NAMES)) {
[13:21:35.581]                   name <- removed[[kk]]
[13:21:35.581]                   NAME <- NAMES[[kk]]
[13:21:35.581]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:35.581]                     next
[13:21:35.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:35.581]                 }
[13:21:35.581]                 if (length(args) > 0) 
[13:21:35.581]                   base::do.call(base::Sys.setenv, args = args)
[13:21:35.581]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:35.581]             }
[13:21:35.581]             else {
[13:21:35.581]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:35.581]             }
[13:21:35.581]             {
[13:21:35.581]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:35.581]                   0L) {
[13:21:35.581]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:35.581]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:35.581]                   base::options(opts)
[13:21:35.581]                 }
[13:21:35.581]                 {
[13:21:35.581]                   {
[13:21:35.581]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:35.581]                     NULL
[13:21:35.581]                   }
[13:21:35.581]                   options(future.plan = NULL)
[13:21:35.581]                   if (is.na(NA_character_)) 
[13:21:35.581]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:35.581]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:35.581]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:35.581]                     envir = parent.frame()) 
[13:21:35.581]                   {
[13:21:35.581]                     default_workers <- missing(workers)
[13:21:35.581]                     if (is.function(workers)) 
[13:21:35.581]                       workers <- workers()
[13:21:35.581]                     workers <- structure(as.integer(workers), 
[13:21:35.581]                       class = class(workers))
[13:21:35.581]                     stop_if_not(is.finite(workers), workers >= 
[13:21:35.581]                       1L)
[13:21:35.581]                     if ((workers == 1L && !inherits(workers, 
[13:21:35.581]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:35.581]                       if (default_workers) 
[13:21:35.581]                         supportsMulticore(warn = TRUE)
[13:21:35.581]                       return(sequential(..., envir = envir))
[13:21:35.581]                     }
[13:21:35.581]                     oopts <- options(mc.cores = workers)
[13:21:35.581]                     on.exit(options(oopts))
[13:21:35.581]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:35.581]                       envir = envir)
[13:21:35.581]                     if (!future$lazy) 
[13:21:35.581]                       future <- run(future)
[13:21:35.581]                     invisible(future)
[13:21:35.581]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:35.581]                 }
[13:21:35.581]             }
[13:21:35.581]         }
[13:21:35.581]     })
[13:21:35.581]     if (TRUE) {
[13:21:35.581]         base::sink(type = "output", split = FALSE)
[13:21:35.581]         if (TRUE) {
[13:21:35.581]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:35.581]         }
[13:21:35.581]         else {
[13:21:35.581]             ...future.result["stdout"] <- base::list(NULL)
[13:21:35.581]         }
[13:21:35.581]         base::close(...future.stdout)
[13:21:35.581]         ...future.stdout <- NULL
[13:21:35.581]     }
[13:21:35.581]     ...future.result$conditions <- ...future.conditions
[13:21:35.581]     ...future.result$finished <- base::Sys.time()
[13:21:35.581]     ...future.result
[13:21:35.581] }
[13:21:35.587] assign_globals() ...
[13:21:35.588] List of 11
[13:21:35.588]  $ ...future.FUN            :function (x, ...)  
[13:21:35.588]  $ x_FUN                    :function (x)  
[13:21:35.588]  $ times                    : int 2
[13:21:35.588]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:35.588]  $ stop_if_not              :function (...)  
[13:21:35.588]  $ dim                      : NULL
[13:21:35.588]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:21:35.588]  $ future.call.arguments    : list()
[13:21:35.588]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:35.588]  $ ...future.elements_ii    :List of 2
[13:21:35.588]   ..$ : int 2
[13:21:35.588]   ..$ : int 3
[13:21:35.588]  $ ...future.seeds_ii       : NULL
[13:21:35.588]  $ ...future.globals.maxSize: NULL
[13:21:35.588]  - attr(*, "where")=List of 11
[13:21:35.588]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:21:35.588]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:21:35.588]   ..$ times                    :<environment: R_EmptyEnv> 
[13:21:35.588]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:21:35.588]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:21:35.588]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:21:35.588]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:21:35.588]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:21:35.588]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:21:35.588]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:21:35.588]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:21:35.588]  - attr(*, "resolved")= logi FALSE
[13:21:35.588]  - attr(*, "total_size")= num 95128
[13:21:35.588]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:35.588]  - attr(*, "already-done")= logi TRUE
[13:21:35.602] - copied ‘...future.FUN’ to environment
[13:21:35.602] - copied ‘x_FUN’ to environment
[13:21:35.602] - copied ‘times’ to environment
[13:21:35.602] - copied ‘stopf’ to environment
[13:21:35.602] - copied ‘stop_if_not’ to environment
[13:21:35.602] - copied ‘dim’ to environment
[13:21:35.602] - copied ‘valid_types’ to environment
[13:21:35.602] - copied ‘future.call.arguments’ to environment
[13:21:35.603] - copied ‘...future.elements_ii’ to environment
[13:21:35.603] - copied ‘...future.seeds_ii’ to environment
[13:21:35.603] - copied ‘...future.globals.maxSize’ to environment
[13:21:35.603] assign_globals() ... done
[13:21:35.603] requestCore(): workers = 2
[13:21:35.605] MulticoreFuture started
[13:21:35.606] - Launch lazy future ... done
[13:21:35.606] run() for ‘MulticoreFuture’ ... done
[13:21:35.606] Created future:
[13:21:35.607] plan(): Setting new future strategy stack:
[13:21:35.607] List of future strategies:
[13:21:35.607] 1. sequential:
[13:21:35.607]    - args: function (..., envir = parent.frame())
[13:21:35.607]    - tweaked: FALSE
[13:21:35.607]    - call: NULL
[13:21:35.608] plan(): nbrOfWorkers() = 1
[13:21:35.610] plan(): Setting new future strategy stack:
[13:21:35.610] List of future strategies:
[13:21:35.610] 1. multicore:
[13:21:35.610]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:35.610]    - tweaked: FALSE
[13:21:35.610]    - call: plan(strategy)
[13:21:35.616] plan(): nbrOfWorkers() = 2
[13:21:35.607] MulticoreFuture:
[13:21:35.607] Label: ‘future_vapply-2’
[13:21:35.607] Expression:
[13:21:35.607] {
[13:21:35.607]     do.call(function(...) {
[13:21:35.607]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:35.607]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:35.607]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:35.607]             on.exit(options(oopts), add = TRUE)
[13:21:35.607]         }
[13:21:35.607]         {
[13:21:35.607]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:35.607]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:35.607]                 ...future.FUN(...future.X_jj, ...)
[13:21:35.607]             })
[13:21:35.607]         }
[13:21:35.607]     }, args = future.call.arguments)
[13:21:35.607] }
[13:21:35.607] Lazy evaluation: FALSE
[13:21:35.607] Asynchronous evaluation: TRUE
[13:21:35.607] Local evaluation: TRUE
[13:21:35.607] Environment: R_GlobalEnv
[13:21:35.607] Capture standard output: TRUE
[13:21:35.607] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:35.607] Globals: 11 objects totaling 93.01 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:35.607] Packages: 1 packages (‘future.apply’)
[13:21:35.607] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:35.607] Resolved: FALSE
[13:21:35.607] Value: <not collected>
[13:21:35.607] Conditions captured: <none>
[13:21:35.607] Early signaling: FALSE
[13:21:35.607] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:35.607] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:35.620] Chunk #2 of 2 ... DONE
[13:21:35.620] Launching 2 futures (chunks) ... DONE
[13:21:35.621] Resolving 2 futures (chunks) ...
[13:21:35.621] resolve() on list ...
[13:21:35.621]  recursive: 0
[13:21:35.621]  length: 2
[13:21:35.621] 
[13:21:35.622] Future #1
[13:21:35.622] result() for MulticoreFuture ...
[13:21:35.635] result() for MulticoreFuture ...
[13:21:35.636] result() for MulticoreFuture ... done
[13:21:35.636] signalConditions() ...
[13:21:35.636]  - include = ‘immediateCondition’
[13:21:35.636]  - exclude = 
[13:21:35.637]  - resignal = FALSE
[13:21:35.637]  - Number of conditions: 1
[13:21:35.637] signalConditions() ... done
[13:21:35.637] result() for MulticoreFuture ... done
[13:21:35.637] result() for MulticoreFuture ...
[13:21:35.638] result() for MulticoreFuture ... done
[13:21:35.638] signalConditions() ...
[13:21:35.638]  - include = ‘immediateCondition’
[13:21:35.638]  - exclude = 
[13:21:35.638]  - resignal = FALSE
[13:21:35.638]  - Number of conditions: 1
[13:21:35.639] signalConditions() ... done
[13:21:35.639] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:21:35.639] - nx: 2
[13:21:35.639] - relay: TRUE
[13:21:35.639] - stdout: TRUE
[13:21:35.640] - signal: TRUE
[13:21:35.640] - resignal: FALSE
[13:21:35.640] - force: TRUE
[13:21:35.640] - relayed: [n=2] FALSE, FALSE
[13:21:35.641] - queued futures: [n=2] FALSE, FALSE
[13:21:35.641]  - until=1
[13:21:35.641]  - relaying element #1
[13:21:35.641] result() for MulticoreFuture ...
[13:21:35.641] result() for MulticoreFuture ... done
[13:21:35.641] result() for MulticoreFuture ...
[13:21:35.642] result() for MulticoreFuture ... done
[13:21:35.642] signalConditions() ...
[13:21:35.642]  - include = ‘immediateCondition’
[13:21:35.642]  - exclude = 
[13:21:35.642]  - resignal = FALSE
[13:21:35.642]  - Number of conditions: 1
[13:21:35.643] signalConditions() ... done
[13:21:35.643] result() for MulticoreFuture ...
[13:21:35.643] result() for MulticoreFuture ... done
[13:21:35.643] signalConditions() ...
[13:21:35.643]  - include = ‘immediateCondition’
[13:21:35.644]  - exclude = 
[13:21:35.644]  - resignal = FALSE
[13:21:35.644]  - Number of conditions: 1
[13:21:35.644] signalConditions() ... done
[13:21:35.644] result() for MulticoreFuture ...
[13:21:35.645] result() for MulticoreFuture ... done
[13:21:35.645] signalConditions() ...
[13:21:35.645]  - include = ‘condition’
[13:21:35.645]  - exclude = ‘immediateCondition’
[13:21:35.645]  - resignal = TRUE
[13:21:35.645]  - Number of conditions: 1
[13:21:35.646]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:21:35.646] signalConditions() ... done
[13:21:35.646] - relayed: [n=2] FALSE, FALSE
[13:21:35.646] - queued futures: [n=2] TRUE, FALSE
[13:21:35.646] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:21:35.647] plan(): Setting new future strategy stack:
[13:21:35.647] List of future strategies:
[13:21:35.647] 1. sequential:
[13:21:35.647]    - args: function (..., envir = parent.frame())
[13:21:35.647]    - tweaked: FALSE
[13:21:35.647]    - call: plan(sequential)
[13:21:35.647] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[13:21:35.648] plan(): Setting new future strategy stack:
[13:21:35.649] List of future strategies:
[13:21:35.649] 1. multisession:
[13:21:35.649]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:21:35.649]    - tweaked: FALSE
[13:21:35.649]    - call: plan(strategy)
[13:21:35.649] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:21:35.649] multisession:
[13:21:35.649] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:21:35.649] - tweaked: FALSE
[13:21:35.649] - call: plan(strategy)
[13:21:35.657] getGlobalsAndPackages() ...
[13:21:35.657] Not searching for globals
[13:21:35.658] - globals: [0] <none>
[13:21:35.658] getGlobalsAndPackages() ... DONE
[13:21:35.658] [local output] makeClusterPSOCK() ...
[13:21:35.751] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:21:35.753] [local output] Base port: 11656
[13:21:35.753] [local output] Getting setup options for 2 cluster nodes ...
[13:21:35.753] [local output]  - Node 1 of 2 ...
[13:21:35.753] [local output] localMachine=TRUE => revtunnel=FALSE

[13:21:35.754] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpbpFWGO/worker.rank=1.parallelly.parent=78731.1338b44457feb.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpbpFWGO/worker.rank=1.parallelly.parent=78731.1338b44457feb.pid")'’
[13:21:35.949] - Possible to infer worker's PID: TRUE
[13:21:35.949] [local output] Rscript port: 11656

[13:21:35.949] [local output]  - Node 2 of 2 ...
[13:21:35.950] [local output] localMachine=TRUE => revtunnel=FALSE

[13:21:35.950] [local output] Rscript port: 11656

[13:21:35.951] [local output] Getting setup options for 2 cluster nodes ... done
[13:21:35.951] [local output]  - Parallel setup requested for some PSOCK nodes
[13:21:35.951] [local output] Setting up PSOCK nodes in parallel
[13:21:35.952] List of 36
[13:21:35.952]  $ worker          : chr "localhost"
[13:21:35.952]   ..- attr(*, "localhost")= logi TRUE
[13:21:35.952]  $ master          : chr "localhost"
[13:21:35.952]  $ port            : int 11656
[13:21:35.952]  $ connectTimeout  : num 120
[13:21:35.952]  $ timeout         : num 2592000
[13:21:35.952]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:21:35.952]  $ homogeneous     : logi TRUE
[13:21:35.952]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:21:35.952]  $ rscript_envs    : NULL
[13:21:35.952]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:21:35.952]  $ rscript_startup : NULL
[13:21:35.952]  $ rscript_sh      : chr "sh"
[13:21:35.952]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:21:35.952]  $ methods         : logi TRUE
[13:21:35.952]  $ socketOptions   : chr "no-delay"
[13:21:35.952]  $ useXDR          : logi FALSE
[13:21:35.952]  $ outfile         : chr "/dev/null"
[13:21:35.952]  $ renice          : int NA
[13:21:35.952]  $ rshcmd          : NULL
[13:21:35.952]  $ user            : chr(0) 
[13:21:35.952]  $ revtunnel       : logi FALSE
[13:21:35.952]  $ rshlogfile      : NULL
[13:21:35.952]  $ rshopts         : chr(0) 
[13:21:35.952]  $ rank            : int 1
[13:21:35.952]  $ manual          : logi FALSE
[13:21:35.952]  $ dryrun          : logi FALSE
[13:21:35.952]  $ quiet           : logi FALSE
[13:21:35.952]  $ setup_strategy  : chr "parallel"
[13:21:35.952]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:21:35.952]  $ pidfile         : chr "/tmp/RtmpbpFWGO/worker.rank=1.parallelly.parent=78731.1338b44457feb.pid"
[13:21:35.952]  $ rshcmd_label    : NULL
[13:21:35.952]  $ rsh_call        : NULL
[13:21:35.952]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:21:35.952]  $ localMachine    : logi TRUE
[13:21:35.952]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:21:35.952]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:21:35.952]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:21:35.952]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:21:35.952]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:21:35.952]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:21:35.952]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:21:35.952]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:21:35.952]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:21:35.952]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:21:35.952]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:21:35.952]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:21:35.952]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:21:35.952]  $ arguments       :List of 28
[13:21:35.952]   ..$ worker          : chr "localhost"
[13:21:35.952]   ..$ master          : NULL
[13:21:35.952]   ..$ port            : int 11656
[13:21:35.952]   ..$ connectTimeout  : num 120
[13:21:35.952]   ..$ timeout         : num 2592000
[13:21:35.952]   ..$ rscript         : NULL
[13:21:35.952]   ..$ homogeneous     : NULL
[13:21:35.952]   ..$ rscript_args    : NULL
[13:21:35.952]   ..$ rscript_envs    : NULL
[13:21:35.952]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:21:35.952]   ..$ rscript_startup : NULL
[13:21:35.952]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:21:35.952]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:21:35.952]   ..$ methods         : logi TRUE
[13:21:35.952]   ..$ socketOptions   : chr "no-delay"
[13:21:35.952]   ..$ useXDR          : logi FALSE
[13:21:35.952]   ..$ outfile         : chr "/dev/null"
[13:21:35.952]   ..$ renice          : int NA
[13:21:35.952]   ..$ rshcmd          : NULL
[13:21:35.952]   ..$ user            : NULL
[13:21:35.952]   ..$ revtunnel       : logi NA
[13:21:35.952]   ..$ rshlogfile      : NULL
[13:21:35.952]   ..$ rshopts         : NULL
[13:21:35.952]   ..$ rank            : int 1
[13:21:35.952]   ..$ manual          : logi FALSE
[13:21:35.952]   ..$ dryrun          : logi FALSE
[13:21:35.952]   ..$ quiet           : logi FALSE
[13:21:35.952]   ..$ setup_strategy  : chr "parallel"
[13:21:35.952]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:21:35.970] [local output] System call to launch all workers:
[13:21:35.970] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpbpFWGO/worker.rank=1.parallelly.parent=78731.1338b44457feb.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11656 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:21:35.971] [local output] Starting PSOCK main server
[13:21:35.976] [local output] Workers launched
[13:21:35.977] [local output] Waiting for workers to connect back
[13:21:35.977]  - [local output] 0 workers out of 2 ready
[13:21:36.228]  - [local output] 0 workers out of 2 ready
[13:21:36.228]  - [local output] 1 workers out of 2 ready
[13:21:36.229]  - [local output] 2 workers out of 2 ready
[13:21:36.229] [local output] Launching of workers completed
[13:21:36.229] [local output] Collecting session information from workers
[13:21:36.230] [local output]  - Worker #1 of 2
[13:21:36.230] [local output]  - Worker #2 of 2
[13:21:36.231] [local output] makeClusterPSOCK() ... done
[13:21:36.242] Packages needed by the future expression (n = 0): <none>
[13:21:36.242] Packages needed by future strategies (n = 0): <none>
[13:21:36.243] {
[13:21:36.243]     {
[13:21:36.243]         {
[13:21:36.243]             ...future.startTime <- base::Sys.time()
[13:21:36.243]             {
[13:21:36.243]                 {
[13:21:36.243]                   {
[13:21:36.243]                     {
[13:21:36.243]                       base::local({
[13:21:36.243]                         has_future <- base::requireNamespace("future", 
[13:21:36.243]                           quietly = TRUE)
[13:21:36.243]                         if (has_future) {
[13:21:36.243]                           ns <- base::getNamespace("future")
[13:21:36.243]                           version <- ns[[".package"]][["version"]]
[13:21:36.243]                           if (is.null(version)) 
[13:21:36.243]                             version <- utils::packageVersion("future")
[13:21:36.243]                         }
[13:21:36.243]                         else {
[13:21:36.243]                           version <- NULL
[13:21:36.243]                         }
[13:21:36.243]                         if (!has_future || version < "1.8.0") {
[13:21:36.243]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:36.243]                             "", base::R.version$version.string), 
[13:21:36.243]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:36.243]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:36.243]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:36.243]                               "release", "version")], collapse = " "), 
[13:21:36.243]                             hostname = base::Sys.info()[["nodename"]])
[13:21:36.243]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:36.243]                             info)
[13:21:36.243]                           info <- base::paste(info, collapse = "; ")
[13:21:36.243]                           if (!has_future) {
[13:21:36.243]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:36.243]                               info)
[13:21:36.243]                           }
[13:21:36.243]                           else {
[13:21:36.243]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:36.243]                               info, version)
[13:21:36.243]                           }
[13:21:36.243]                           base::stop(msg)
[13:21:36.243]                         }
[13:21:36.243]                       })
[13:21:36.243]                     }
[13:21:36.243]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:36.243]                     base::options(mc.cores = 1L)
[13:21:36.243]                   }
[13:21:36.243]                   options(future.plan = NULL)
[13:21:36.243]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:36.243]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:36.243]                 }
[13:21:36.243]                 ...future.workdir <- getwd()
[13:21:36.243]             }
[13:21:36.243]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:36.243]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:36.243]         }
[13:21:36.243]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:36.243]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:36.243]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:36.243]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:36.243]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:36.243]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:36.243]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:36.243]             base::names(...future.oldOptions))
[13:21:36.243]     }
[13:21:36.243]     if (FALSE) {
[13:21:36.243]     }
[13:21:36.243]     else {
[13:21:36.243]         if (TRUE) {
[13:21:36.243]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:36.243]                 open = "w")
[13:21:36.243]         }
[13:21:36.243]         else {
[13:21:36.243]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:36.243]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:36.243]         }
[13:21:36.243]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:36.243]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:36.243]             base::sink(type = "output", split = FALSE)
[13:21:36.243]             base::close(...future.stdout)
[13:21:36.243]         }, add = TRUE)
[13:21:36.243]     }
[13:21:36.243]     ...future.frame <- base::sys.nframe()
[13:21:36.243]     ...future.conditions <- base::list()
[13:21:36.243]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:36.243]     if (FALSE) {
[13:21:36.243]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:36.243]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:36.243]     }
[13:21:36.243]     ...future.result <- base::tryCatch({
[13:21:36.243]         base::withCallingHandlers({
[13:21:36.243]             ...future.value <- base::withVisible(base::local({
[13:21:36.243]                 ...future.makeSendCondition <- base::local({
[13:21:36.243]                   sendCondition <- NULL
[13:21:36.243]                   function(frame = 1L) {
[13:21:36.243]                     if (is.function(sendCondition)) 
[13:21:36.243]                       return(sendCondition)
[13:21:36.243]                     ns <- getNamespace("parallel")
[13:21:36.243]                     if (exists("sendData", mode = "function", 
[13:21:36.243]                       envir = ns)) {
[13:21:36.243]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:36.243]                         envir = ns)
[13:21:36.243]                       envir <- sys.frame(frame)
[13:21:36.243]                       master <- NULL
[13:21:36.243]                       while (!identical(envir, .GlobalEnv) && 
[13:21:36.243]                         !identical(envir, emptyenv())) {
[13:21:36.243]                         if (exists("master", mode = "list", envir = envir, 
[13:21:36.243]                           inherits = FALSE)) {
[13:21:36.243]                           master <- get("master", mode = "list", 
[13:21:36.243]                             envir = envir, inherits = FALSE)
[13:21:36.243]                           if (inherits(master, c("SOCKnode", 
[13:21:36.243]                             "SOCK0node"))) {
[13:21:36.243]                             sendCondition <<- function(cond) {
[13:21:36.243]                               data <- list(type = "VALUE", value = cond, 
[13:21:36.243]                                 success = TRUE)
[13:21:36.243]                               parallel_sendData(master, data)
[13:21:36.243]                             }
[13:21:36.243]                             return(sendCondition)
[13:21:36.243]                           }
[13:21:36.243]                         }
[13:21:36.243]                         frame <- frame + 1L
[13:21:36.243]                         envir <- sys.frame(frame)
[13:21:36.243]                       }
[13:21:36.243]                     }
[13:21:36.243]                     sendCondition <<- function(cond) NULL
[13:21:36.243]                   }
[13:21:36.243]                 })
[13:21:36.243]                 withCallingHandlers({
[13:21:36.243]                   NA
[13:21:36.243]                 }, immediateCondition = function(cond) {
[13:21:36.243]                   sendCondition <- ...future.makeSendCondition()
[13:21:36.243]                   sendCondition(cond)
[13:21:36.243]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:36.243]                   {
[13:21:36.243]                     inherits <- base::inherits
[13:21:36.243]                     invokeRestart <- base::invokeRestart
[13:21:36.243]                     is.null <- base::is.null
[13:21:36.243]                     muffled <- FALSE
[13:21:36.243]                     if (inherits(cond, "message")) {
[13:21:36.243]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:36.243]                       if (muffled) 
[13:21:36.243]                         invokeRestart("muffleMessage")
[13:21:36.243]                     }
[13:21:36.243]                     else if (inherits(cond, "warning")) {
[13:21:36.243]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:36.243]                       if (muffled) 
[13:21:36.243]                         invokeRestart("muffleWarning")
[13:21:36.243]                     }
[13:21:36.243]                     else if (inherits(cond, "condition")) {
[13:21:36.243]                       if (!is.null(pattern)) {
[13:21:36.243]                         computeRestarts <- base::computeRestarts
[13:21:36.243]                         grepl <- base::grepl
[13:21:36.243]                         restarts <- computeRestarts(cond)
[13:21:36.243]                         for (restart in restarts) {
[13:21:36.243]                           name <- restart$name
[13:21:36.243]                           if (is.null(name)) 
[13:21:36.243]                             next
[13:21:36.243]                           if (!grepl(pattern, name)) 
[13:21:36.243]                             next
[13:21:36.243]                           invokeRestart(restart)
[13:21:36.243]                           muffled <- TRUE
[13:21:36.243]                           break
[13:21:36.243]                         }
[13:21:36.243]                       }
[13:21:36.243]                     }
[13:21:36.243]                     invisible(muffled)
[13:21:36.243]                   }
[13:21:36.243]                   muffleCondition(cond)
[13:21:36.243]                 })
[13:21:36.243]             }))
[13:21:36.243]             future::FutureResult(value = ...future.value$value, 
[13:21:36.243]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:36.243]                   ...future.rng), globalenv = if (FALSE) 
[13:21:36.243]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:36.243]                     ...future.globalenv.names))
[13:21:36.243]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:36.243]         }, condition = base::local({
[13:21:36.243]             c <- base::c
[13:21:36.243]             inherits <- base::inherits
[13:21:36.243]             invokeRestart <- base::invokeRestart
[13:21:36.243]             length <- base::length
[13:21:36.243]             list <- base::list
[13:21:36.243]             seq.int <- base::seq.int
[13:21:36.243]             signalCondition <- base::signalCondition
[13:21:36.243]             sys.calls <- base::sys.calls
[13:21:36.243]             `[[` <- base::`[[`
[13:21:36.243]             `+` <- base::`+`
[13:21:36.243]             `<<-` <- base::`<<-`
[13:21:36.243]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:36.243]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:36.243]                   3L)]
[13:21:36.243]             }
[13:21:36.243]             function(cond) {
[13:21:36.243]                 is_error <- inherits(cond, "error")
[13:21:36.243]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:36.243]                   NULL)
[13:21:36.243]                 if (is_error) {
[13:21:36.243]                   sessionInformation <- function() {
[13:21:36.243]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:36.243]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:36.243]                       search = base::search(), system = base::Sys.info())
[13:21:36.243]                   }
[13:21:36.243]                   ...future.conditions[[length(...future.conditions) + 
[13:21:36.243]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:36.243]                     cond$call), session = sessionInformation(), 
[13:21:36.243]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:36.243]                   signalCondition(cond)
[13:21:36.243]                 }
[13:21:36.243]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:36.243]                 "immediateCondition"))) {
[13:21:36.243]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:36.243]                   ...future.conditions[[length(...future.conditions) + 
[13:21:36.243]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:36.243]                   if (TRUE && !signal) {
[13:21:36.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:36.243]                     {
[13:21:36.243]                       inherits <- base::inherits
[13:21:36.243]                       invokeRestart <- base::invokeRestart
[13:21:36.243]                       is.null <- base::is.null
[13:21:36.243]                       muffled <- FALSE
[13:21:36.243]                       if (inherits(cond, "message")) {
[13:21:36.243]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:36.243]                         if (muffled) 
[13:21:36.243]                           invokeRestart("muffleMessage")
[13:21:36.243]                       }
[13:21:36.243]                       else if (inherits(cond, "warning")) {
[13:21:36.243]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:36.243]                         if (muffled) 
[13:21:36.243]                           invokeRestart("muffleWarning")
[13:21:36.243]                       }
[13:21:36.243]                       else if (inherits(cond, "condition")) {
[13:21:36.243]                         if (!is.null(pattern)) {
[13:21:36.243]                           computeRestarts <- base::computeRestarts
[13:21:36.243]                           grepl <- base::grepl
[13:21:36.243]                           restarts <- computeRestarts(cond)
[13:21:36.243]                           for (restart in restarts) {
[13:21:36.243]                             name <- restart$name
[13:21:36.243]                             if (is.null(name)) 
[13:21:36.243]                               next
[13:21:36.243]                             if (!grepl(pattern, name)) 
[13:21:36.243]                               next
[13:21:36.243]                             invokeRestart(restart)
[13:21:36.243]                             muffled <- TRUE
[13:21:36.243]                             break
[13:21:36.243]                           }
[13:21:36.243]                         }
[13:21:36.243]                       }
[13:21:36.243]                       invisible(muffled)
[13:21:36.243]                     }
[13:21:36.243]                     muffleCondition(cond, pattern = "^muffle")
[13:21:36.243]                   }
[13:21:36.243]                 }
[13:21:36.243]                 else {
[13:21:36.243]                   if (TRUE) {
[13:21:36.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:36.243]                     {
[13:21:36.243]                       inherits <- base::inherits
[13:21:36.243]                       invokeRestart <- base::invokeRestart
[13:21:36.243]                       is.null <- base::is.null
[13:21:36.243]                       muffled <- FALSE
[13:21:36.243]                       if (inherits(cond, "message")) {
[13:21:36.243]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:36.243]                         if (muffled) 
[13:21:36.243]                           invokeRestart("muffleMessage")
[13:21:36.243]                       }
[13:21:36.243]                       else if (inherits(cond, "warning")) {
[13:21:36.243]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:36.243]                         if (muffled) 
[13:21:36.243]                           invokeRestart("muffleWarning")
[13:21:36.243]                       }
[13:21:36.243]                       else if (inherits(cond, "condition")) {
[13:21:36.243]                         if (!is.null(pattern)) {
[13:21:36.243]                           computeRestarts <- base::computeRestarts
[13:21:36.243]                           grepl <- base::grepl
[13:21:36.243]                           restarts <- computeRestarts(cond)
[13:21:36.243]                           for (restart in restarts) {
[13:21:36.243]                             name <- restart$name
[13:21:36.243]                             if (is.null(name)) 
[13:21:36.243]                               next
[13:21:36.243]                             if (!grepl(pattern, name)) 
[13:21:36.243]                               next
[13:21:36.243]                             invokeRestart(restart)
[13:21:36.243]                             muffled <- TRUE
[13:21:36.243]                             break
[13:21:36.243]                           }
[13:21:36.243]                         }
[13:21:36.243]                       }
[13:21:36.243]                       invisible(muffled)
[13:21:36.243]                     }
[13:21:36.243]                     muffleCondition(cond, pattern = "^muffle")
[13:21:36.243]                   }
[13:21:36.243]                 }
[13:21:36.243]             }
[13:21:36.243]         }))
[13:21:36.243]     }, error = function(ex) {
[13:21:36.243]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:36.243]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:36.243]                 ...future.rng), started = ...future.startTime, 
[13:21:36.243]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:36.243]             version = "1.8"), class = "FutureResult")
[13:21:36.243]     }, finally = {
[13:21:36.243]         if (!identical(...future.workdir, getwd())) 
[13:21:36.243]             setwd(...future.workdir)
[13:21:36.243]         {
[13:21:36.243]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:36.243]                 ...future.oldOptions$nwarnings <- NULL
[13:21:36.243]             }
[13:21:36.243]             base::options(...future.oldOptions)
[13:21:36.243]             if (.Platform$OS.type == "windows") {
[13:21:36.243]                 old_names <- names(...future.oldEnvVars)
[13:21:36.243]                 envs <- base::Sys.getenv()
[13:21:36.243]                 names <- names(envs)
[13:21:36.243]                 common <- intersect(names, old_names)
[13:21:36.243]                 added <- setdiff(names, old_names)
[13:21:36.243]                 removed <- setdiff(old_names, names)
[13:21:36.243]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:36.243]                   envs[common]]
[13:21:36.243]                 NAMES <- toupper(changed)
[13:21:36.243]                 args <- list()
[13:21:36.243]                 for (kk in seq_along(NAMES)) {
[13:21:36.243]                   name <- changed[[kk]]
[13:21:36.243]                   NAME <- NAMES[[kk]]
[13:21:36.243]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:36.243]                     next
[13:21:36.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:36.243]                 }
[13:21:36.243]                 NAMES <- toupper(added)
[13:21:36.243]                 for (kk in seq_along(NAMES)) {
[13:21:36.243]                   name <- added[[kk]]
[13:21:36.243]                   NAME <- NAMES[[kk]]
[13:21:36.243]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:36.243]                     next
[13:21:36.243]                   args[[name]] <- ""
[13:21:36.243]                 }
[13:21:36.243]                 NAMES <- toupper(removed)
[13:21:36.243]                 for (kk in seq_along(NAMES)) {
[13:21:36.243]                   name <- removed[[kk]]
[13:21:36.243]                   NAME <- NAMES[[kk]]
[13:21:36.243]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:36.243]                     next
[13:21:36.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:36.243]                 }
[13:21:36.243]                 if (length(args) > 0) 
[13:21:36.243]                   base::do.call(base::Sys.setenv, args = args)
[13:21:36.243]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:36.243]             }
[13:21:36.243]             else {
[13:21:36.243]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:36.243]             }
[13:21:36.243]             {
[13:21:36.243]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:36.243]                   0L) {
[13:21:36.243]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:36.243]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:36.243]                   base::options(opts)
[13:21:36.243]                 }
[13:21:36.243]                 {
[13:21:36.243]                   {
[13:21:36.243]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:36.243]                     NULL
[13:21:36.243]                   }
[13:21:36.243]                   options(future.plan = NULL)
[13:21:36.243]                   if (is.na(NA_character_)) 
[13:21:36.243]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:36.243]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:36.243]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:36.243]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:36.243]                     envir = parent.frame()) 
[13:21:36.243]                   {
[13:21:36.243]                     if (is.function(workers)) 
[13:21:36.243]                       workers <- workers()
[13:21:36.243]                     workers <- structure(as.integer(workers), 
[13:21:36.243]                       class = class(workers))
[13:21:36.243]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:36.243]                       workers >= 1)
[13:21:36.243]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:36.243]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:36.243]                     }
[13:21:36.243]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:36.243]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:36.243]                       envir = envir)
[13:21:36.243]                     if (!future$lazy) 
[13:21:36.243]                       future <- run(future)
[13:21:36.243]                     invisible(future)
[13:21:36.243]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:36.243]                 }
[13:21:36.243]             }
[13:21:36.243]         }
[13:21:36.243]     })
[13:21:36.243]     if (TRUE) {
[13:21:36.243]         base::sink(type = "output", split = FALSE)
[13:21:36.243]         if (TRUE) {
[13:21:36.243]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:36.243]         }
[13:21:36.243]         else {
[13:21:36.243]             ...future.result["stdout"] <- base::list(NULL)
[13:21:36.243]         }
[13:21:36.243]         base::close(...future.stdout)
[13:21:36.243]         ...future.stdout <- NULL
[13:21:36.243]     }
[13:21:36.243]     ...future.result$conditions <- ...future.conditions
[13:21:36.243]     ...future.result$finished <- base::Sys.time()
[13:21:36.243]     ...future.result
[13:21:36.243] }
[13:21:36.298] MultisessionFuture started
[13:21:36.298] result() for ClusterFuture ...
[13:21:36.299] receiveMessageFromWorker() for ClusterFuture ...
[13:21:36.299] - Validating connection of MultisessionFuture
[13:21:36.344] - received message: FutureResult
[13:21:36.345] - Received FutureResult
[13:21:36.345] - Erased future from FutureRegistry
[13:21:36.345] result() for ClusterFuture ...
[13:21:36.345] - result already collected: FutureResult
[13:21:36.345] result() for ClusterFuture ... done
[13:21:36.345] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:36.346] result() for ClusterFuture ... done
[13:21:36.346] result() for ClusterFuture ...
[13:21:36.346] - result already collected: FutureResult
[13:21:36.346] result() for ClusterFuture ... done
[13:21:36.346] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:21:36.350] plan(): nbrOfWorkers() = 2
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[13:21:36.353] future_lapply() ...
[13:21:36.359] Number of chunks: 2
[13:21:36.359] getGlobalsAndPackagesXApply() ...
[13:21:36.360]  - future.globals: TRUE
[13:21:36.360] getGlobalsAndPackages() ...
[13:21:36.360] Searching for globals...
[13:21:36.364] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:21:36.364] Searching for globals ... DONE
[13:21:36.364] Resolving globals: FALSE
[13:21:36.365] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[13:21:36.365] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:36.366] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:36.366] - packages: [1] ‘future.apply’
[13:21:36.366] getGlobalsAndPackages() ... DONE
[13:21:36.366]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:36.366]  - needed namespaces: [n=1] ‘future.apply’
[13:21:36.366] Finding globals ... DONE
[13:21:36.366]  - use_args: TRUE
[13:21:36.367]  - Getting '...' globals ...
[13:21:36.367] resolve() on list ...
[13:21:36.367]  recursive: 0
[13:21:36.367]  length: 1
[13:21:36.367]  elements: ‘...’
[13:21:36.367]  length: 0 (resolved future 1)
[13:21:36.368] resolve() on list ... DONE
[13:21:36.368]    - '...' content: [n=0] 
[13:21:36.368] List of 1
[13:21:36.368]  $ ...: list()
[13:21:36.368]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:36.368]  - attr(*, "where")=List of 1
[13:21:36.368]   ..$ ...:<environment: 0x563b7049d3c0> 
[13:21:36.368]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:36.368]  - attr(*, "resolved")= logi TRUE
[13:21:36.368]  - attr(*, "total_size")= num NA
[13:21:36.371]  - Getting '...' globals ... DONE
[13:21:36.371] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:36.371] List of 8
[13:21:36.371]  $ ...future.FUN:function (x, ...)  
[13:21:36.371]  $ x_FUN        :function (x)  
[13:21:36.371]  $ times        : int 1
[13:21:36.371]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:36.371]  $ stop_if_not  :function (...)  
[13:21:36.371]  $ dim          : NULL
[13:21:36.371]  $ valid_types  : chr "character"
[13:21:36.371]  $ ...          : list()
[13:21:36.371]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:36.371]  - attr(*, "where")=List of 8
[13:21:36.371]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:36.371]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:36.371]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:36.371]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:36.371]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:36.371]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:36.371]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:36.371]   ..$ ...          :<environment: 0x563b7049d3c0> 
[13:21:36.371]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:36.371]  - attr(*, "resolved")= logi FALSE
[13:21:36.371]  - attr(*, "total_size")= num 94208
[13:21:36.378] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:21:36.378] getGlobalsAndPackagesXApply() ... DONE
[13:21:36.378] Number of futures (= number of chunks): 2
[13:21:36.379] Launching 2 futures (chunks) ...
[13:21:36.379] Chunk #1 of 2 ...
[13:21:36.379]  - Finding globals in 'X' for chunk #1 ...
[13:21:36.379] getGlobalsAndPackages() ...
[13:21:36.379] Searching for globals...
[13:21:36.379] 
[13:21:36.379] Searching for globals ... DONE
[13:21:36.380] - globals: [0] <none>
[13:21:36.380] getGlobalsAndPackages() ... DONE
[13:21:36.380]    + additional globals found: [n=0] 
[13:21:36.380]    + additional namespaces needed: [n=0] 
[13:21:36.380]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:36.380]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:36.380]  - seeds: <none>
[13:21:36.380]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:36.381] getGlobalsAndPackages() ...
[13:21:36.381] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:36.381] Resolving globals: FALSE
[13:21:36.381] Tweak future expression to call with '...' arguments ...
[13:21:36.381] {
[13:21:36.381]     do.call(function(...) {
[13:21:36.381]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:36.381]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:36.381]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:36.381]             on.exit(options(oopts), add = TRUE)
[13:21:36.381]         }
[13:21:36.381]         {
[13:21:36.381]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:36.381]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:36.381]                 ...future.FUN(...future.X_jj, ...)
[13:21:36.381]             })
[13:21:36.381]         }
[13:21:36.381]     }, args = future.call.arguments)
[13:21:36.381] }
[13:21:36.381] Tweak future expression to call with '...' arguments ... DONE
[13:21:36.382] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:36.382] - packages: [1] ‘future.apply’
[13:21:36.382] getGlobalsAndPackages() ... DONE
[13:21:36.383] run() for ‘Future’ ...
[13:21:36.383] - state: ‘created’
[13:21:36.383] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:36.398] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:36.398] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:36.398]   - Field: ‘node’
[13:21:36.398]   - Field: ‘label’
[13:21:36.398]   - Field: ‘local’
[13:21:36.398]   - Field: ‘owner’
[13:21:36.399]   - Field: ‘envir’
[13:21:36.399]   - Field: ‘workers’
[13:21:36.399]   - Field: ‘packages’
[13:21:36.399]   - Field: ‘gc’
[13:21:36.399]   - Field: ‘conditions’
[13:21:36.399]   - Field: ‘persistent’
[13:21:36.399]   - Field: ‘expr’
[13:21:36.399]   - Field: ‘uuid’
[13:21:36.399]   - Field: ‘seed’
[13:21:36.400]   - Field: ‘version’
[13:21:36.400]   - Field: ‘result’
[13:21:36.400]   - Field: ‘asynchronous’
[13:21:36.400]   - Field: ‘calls’
[13:21:36.400]   - Field: ‘globals’
[13:21:36.400]   - Field: ‘stdout’
[13:21:36.400]   - Field: ‘earlySignal’
[13:21:36.400]   - Field: ‘lazy’
[13:21:36.401]   - Field: ‘state’
[13:21:36.401] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:36.401] - Launch lazy future ...
[13:21:36.401] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:36.401] Packages needed by future strategies (n = 0): <none>
[13:21:36.402] {
[13:21:36.402]     {
[13:21:36.402]         {
[13:21:36.402]             ...future.startTime <- base::Sys.time()
[13:21:36.402]             {
[13:21:36.402]                 {
[13:21:36.402]                   {
[13:21:36.402]                     {
[13:21:36.402]                       {
[13:21:36.402]                         base::local({
[13:21:36.402]                           has_future <- base::requireNamespace("future", 
[13:21:36.402]                             quietly = TRUE)
[13:21:36.402]                           if (has_future) {
[13:21:36.402]                             ns <- base::getNamespace("future")
[13:21:36.402]                             version <- ns[[".package"]][["version"]]
[13:21:36.402]                             if (is.null(version)) 
[13:21:36.402]                               version <- utils::packageVersion("future")
[13:21:36.402]                           }
[13:21:36.402]                           else {
[13:21:36.402]                             version <- NULL
[13:21:36.402]                           }
[13:21:36.402]                           if (!has_future || version < "1.8.0") {
[13:21:36.402]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:36.402]                               "", base::R.version$version.string), 
[13:21:36.402]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:36.402]                                 base::R.version$platform, 8 * 
[13:21:36.402]                                   base::.Machine$sizeof.pointer), 
[13:21:36.402]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:36.402]                                 "release", "version")], collapse = " "), 
[13:21:36.402]                               hostname = base::Sys.info()[["nodename"]])
[13:21:36.402]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:36.402]                               info)
[13:21:36.402]                             info <- base::paste(info, collapse = "; ")
[13:21:36.402]                             if (!has_future) {
[13:21:36.402]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:36.402]                                 info)
[13:21:36.402]                             }
[13:21:36.402]                             else {
[13:21:36.402]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:36.402]                                 info, version)
[13:21:36.402]                             }
[13:21:36.402]                             base::stop(msg)
[13:21:36.402]                           }
[13:21:36.402]                         })
[13:21:36.402]                       }
[13:21:36.402]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:36.402]                       base::options(mc.cores = 1L)
[13:21:36.402]                     }
[13:21:36.402]                     base::local({
[13:21:36.402]                       for (pkg in "future.apply") {
[13:21:36.402]                         base::loadNamespace(pkg)
[13:21:36.402]                         base::library(pkg, character.only = TRUE)
[13:21:36.402]                       }
[13:21:36.402]                     })
[13:21:36.402]                   }
[13:21:36.402]                   options(future.plan = NULL)
[13:21:36.402]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:36.402]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:36.402]                 }
[13:21:36.402]                 ...future.workdir <- getwd()
[13:21:36.402]             }
[13:21:36.402]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:36.402]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:36.402]         }
[13:21:36.402]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:36.402]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:36.402]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:36.402]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:36.402]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:36.402]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:36.402]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:36.402]             base::names(...future.oldOptions))
[13:21:36.402]     }
[13:21:36.402]     if (FALSE) {
[13:21:36.402]     }
[13:21:36.402]     else {
[13:21:36.402]         if (TRUE) {
[13:21:36.402]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:36.402]                 open = "w")
[13:21:36.402]         }
[13:21:36.402]         else {
[13:21:36.402]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:36.402]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:36.402]         }
[13:21:36.402]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:36.402]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:36.402]             base::sink(type = "output", split = FALSE)
[13:21:36.402]             base::close(...future.stdout)
[13:21:36.402]         }, add = TRUE)
[13:21:36.402]     }
[13:21:36.402]     ...future.frame <- base::sys.nframe()
[13:21:36.402]     ...future.conditions <- base::list()
[13:21:36.402]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:36.402]     if (FALSE) {
[13:21:36.402]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:36.402]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:36.402]     }
[13:21:36.402]     ...future.result <- base::tryCatch({
[13:21:36.402]         base::withCallingHandlers({
[13:21:36.402]             ...future.value <- base::withVisible(base::local({
[13:21:36.402]                 ...future.makeSendCondition <- base::local({
[13:21:36.402]                   sendCondition <- NULL
[13:21:36.402]                   function(frame = 1L) {
[13:21:36.402]                     if (is.function(sendCondition)) 
[13:21:36.402]                       return(sendCondition)
[13:21:36.402]                     ns <- getNamespace("parallel")
[13:21:36.402]                     if (exists("sendData", mode = "function", 
[13:21:36.402]                       envir = ns)) {
[13:21:36.402]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:36.402]                         envir = ns)
[13:21:36.402]                       envir <- sys.frame(frame)
[13:21:36.402]                       master <- NULL
[13:21:36.402]                       while (!identical(envir, .GlobalEnv) && 
[13:21:36.402]                         !identical(envir, emptyenv())) {
[13:21:36.402]                         if (exists("master", mode = "list", envir = envir, 
[13:21:36.402]                           inherits = FALSE)) {
[13:21:36.402]                           master <- get("master", mode = "list", 
[13:21:36.402]                             envir = envir, inherits = FALSE)
[13:21:36.402]                           if (inherits(master, c("SOCKnode", 
[13:21:36.402]                             "SOCK0node"))) {
[13:21:36.402]                             sendCondition <<- function(cond) {
[13:21:36.402]                               data <- list(type = "VALUE", value = cond, 
[13:21:36.402]                                 success = TRUE)
[13:21:36.402]                               parallel_sendData(master, data)
[13:21:36.402]                             }
[13:21:36.402]                             return(sendCondition)
[13:21:36.402]                           }
[13:21:36.402]                         }
[13:21:36.402]                         frame <- frame + 1L
[13:21:36.402]                         envir <- sys.frame(frame)
[13:21:36.402]                       }
[13:21:36.402]                     }
[13:21:36.402]                     sendCondition <<- function(cond) NULL
[13:21:36.402]                   }
[13:21:36.402]                 })
[13:21:36.402]                 withCallingHandlers({
[13:21:36.402]                   {
[13:21:36.402]                     do.call(function(...) {
[13:21:36.402]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:36.402]                       if (!identical(...future.globals.maxSize.org, 
[13:21:36.402]                         ...future.globals.maxSize)) {
[13:21:36.402]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:36.402]                         on.exit(options(oopts), add = TRUE)
[13:21:36.402]                       }
[13:21:36.402]                       {
[13:21:36.402]                         lapply(seq_along(...future.elements_ii), 
[13:21:36.402]                           FUN = function(jj) {
[13:21:36.402]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:36.402]                             ...future.FUN(...future.X_jj, ...)
[13:21:36.402]                           })
[13:21:36.402]                       }
[13:21:36.402]                     }, args = future.call.arguments)
[13:21:36.402]                   }
[13:21:36.402]                 }, immediateCondition = function(cond) {
[13:21:36.402]                   sendCondition <- ...future.makeSendCondition()
[13:21:36.402]                   sendCondition(cond)
[13:21:36.402]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:36.402]                   {
[13:21:36.402]                     inherits <- base::inherits
[13:21:36.402]                     invokeRestart <- base::invokeRestart
[13:21:36.402]                     is.null <- base::is.null
[13:21:36.402]                     muffled <- FALSE
[13:21:36.402]                     if (inherits(cond, "message")) {
[13:21:36.402]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:36.402]                       if (muffled) 
[13:21:36.402]                         invokeRestart("muffleMessage")
[13:21:36.402]                     }
[13:21:36.402]                     else if (inherits(cond, "warning")) {
[13:21:36.402]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:36.402]                       if (muffled) 
[13:21:36.402]                         invokeRestart("muffleWarning")
[13:21:36.402]                     }
[13:21:36.402]                     else if (inherits(cond, "condition")) {
[13:21:36.402]                       if (!is.null(pattern)) {
[13:21:36.402]                         computeRestarts <- base::computeRestarts
[13:21:36.402]                         grepl <- base::grepl
[13:21:36.402]                         restarts <- computeRestarts(cond)
[13:21:36.402]                         for (restart in restarts) {
[13:21:36.402]                           name <- restart$name
[13:21:36.402]                           if (is.null(name)) 
[13:21:36.402]                             next
[13:21:36.402]                           if (!grepl(pattern, name)) 
[13:21:36.402]                             next
[13:21:36.402]                           invokeRestart(restart)
[13:21:36.402]                           muffled <- TRUE
[13:21:36.402]                           break
[13:21:36.402]                         }
[13:21:36.402]                       }
[13:21:36.402]                     }
[13:21:36.402]                     invisible(muffled)
[13:21:36.402]                   }
[13:21:36.402]                   muffleCondition(cond)
[13:21:36.402]                 })
[13:21:36.402]             }))
[13:21:36.402]             future::FutureResult(value = ...future.value$value, 
[13:21:36.402]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:36.402]                   ...future.rng), globalenv = if (FALSE) 
[13:21:36.402]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:36.402]                     ...future.globalenv.names))
[13:21:36.402]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:36.402]         }, condition = base::local({
[13:21:36.402]             c <- base::c
[13:21:36.402]             inherits <- base::inherits
[13:21:36.402]             invokeRestart <- base::invokeRestart
[13:21:36.402]             length <- base::length
[13:21:36.402]             list <- base::list
[13:21:36.402]             seq.int <- base::seq.int
[13:21:36.402]             signalCondition <- base::signalCondition
[13:21:36.402]             sys.calls <- base::sys.calls
[13:21:36.402]             `[[` <- base::`[[`
[13:21:36.402]             `+` <- base::`+`
[13:21:36.402]             `<<-` <- base::`<<-`
[13:21:36.402]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:36.402]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:36.402]                   3L)]
[13:21:36.402]             }
[13:21:36.402]             function(cond) {
[13:21:36.402]                 is_error <- inherits(cond, "error")
[13:21:36.402]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:36.402]                   NULL)
[13:21:36.402]                 if (is_error) {
[13:21:36.402]                   sessionInformation <- function() {
[13:21:36.402]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:36.402]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:36.402]                       search = base::search(), system = base::Sys.info())
[13:21:36.402]                   }
[13:21:36.402]                   ...future.conditions[[length(...future.conditions) + 
[13:21:36.402]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:36.402]                     cond$call), session = sessionInformation(), 
[13:21:36.402]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:36.402]                   signalCondition(cond)
[13:21:36.402]                 }
[13:21:36.402]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:36.402]                 "immediateCondition"))) {
[13:21:36.402]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:36.402]                   ...future.conditions[[length(...future.conditions) + 
[13:21:36.402]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:36.402]                   if (TRUE && !signal) {
[13:21:36.402]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:36.402]                     {
[13:21:36.402]                       inherits <- base::inherits
[13:21:36.402]                       invokeRestart <- base::invokeRestart
[13:21:36.402]                       is.null <- base::is.null
[13:21:36.402]                       muffled <- FALSE
[13:21:36.402]                       if (inherits(cond, "message")) {
[13:21:36.402]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:36.402]                         if (muffled) 
[13:21:36.402]                           invokeRestart("muffleMessage")
[13:21:36.402]                       }
[13:21:36.402]                       else if (inherits(cond, "warning")) {
[13:21:36.402]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:36.402]                         if (muffled) 
[13:21:36.402]                           invokeRestart("muffleWarning")
[13:21:36.402]                       }
[13:21:36.402]                       else if (inherits(cond, "condition")) {
[13:21:36.402]                         if (!is.null(pattern)) {
[13:21:36.402]                           computeRestarts <- base::computeRestarts
[13:21:36.402]                           grepl <- base::grepl
[13:21:36.402]                           restarts <- computeRestarts(cond)
[13:21:36.402]                           for (restart in restarts) {
[13:21:36.402]                             name <- restart$name
[13:21:36.402]                             if (is.null(name)) 
[13:21:36.402]                               next
[13:21:36.402]                             if (!grepl(pattern, name)) 
[13:21:36.402]                               next
[13:21:36.402]                             invokeRestart(restart)
[13:21:36.402]                             muffled <- TRUE
[13:21:36.402]                             break
[13:21:36.402]                           }
[13:21:36.402]                         }
[13:21:36.402]                       }
[13:21:36.402]                       invisible(muffled)
[13:21:36.402]                     }
[13:21:36.402]                     muffleCondition(cond, pattern = "^muffle")
[13:21:36.402]                   }
[13:21:36.402]                 }
[13:21:36.402]                 else {
[13:21:36.402]                   if (TRUE) {
[13:21:36.402]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:36.402]                     {
[13:21:36.402]                       inherits <- base::inherits
[13:21:36.402]                       invokeRestart <- base::invokeRestart
[13:21:36.402]                       is.null <- base::is.null
[13:21:36.402]                       muffled <- FALSE
[13:21:36.402]                       if (inherits(cond, "message")) {
[13:21:36.402]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:36.402]                         if (muffled) 
[13:21:36.402]                           invokeRestart("muffleMessage")
[13:21:36.402]                       }
[13:21:36.402]                       else if (inherits(cond, "warning")) {
[13:21:36.402]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:36.402]                         if (muffled) 
[13:21:36.402]                           invokeRestart("muffleWarning")
[13:21:36.402]                       }
[13:21:36.402]                       else if (inherits(cond, "condition")) {
[13:21:36.402]                         if (!is.null(pattern)) {
[13:21:36.402]                           computeRestarts <- base::computeRestarts
[13:21:36.402]                           grepl <- base::grepl
[13:21:36.402]                           restarts <- computeRestarts(cond)
[13:21:36.402]                           for (restart in restarts) {
[13:21:36.402]                             name <- restart$name
[13:21:36.402]                             if (is.null(name)) 
[13:21:36.402]                               next
[13:21:36.402]                             if (!grepl(pattern, name)) 
[13:21:36.402]                               next
[13:21:36.402]                             invokeRestart(restart)
[13:21:36.402]                             muffled <- TRUE
[13:21:36.402]                             break
[13:21:36.402]                           }
[13:21:36.402]                         }
[13:21:36.402]                       }
[13:21:36.402]                       invisible(muffled)
[13:21:36.402]                     }
[13:21:36.402]                     muffleCondition(cond, pattern = "^muffle")
[13:21:36.402]                   }
[13:21:36.402]                 }
[13:21:36.402]             }
[13:21:36.402]         }))
[13:21:36.402]     }, error = function(ex) {
[13:21:36.402]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:36.402]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:36.402]                 ...future.rng), started = ...future.startTime, 
[13:21:36.402]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:36.402]             version = "1.8"), class = "FutureResult")
[13:21:36.402]     }, finally = {
[13:21:36.402]         if (!identical(...future.workdir, getwd())) 
[13:21:36.402]             setwd(...future.workdir)
[13:21:36.402]         {
[13:21:36.402]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:36.402]                 ...future.oldOptions$nwarnings <- NULL
[13:21:36.402]             }
[13:21:36.402]             base::options(...future.oldOptions)
[13:21:36.402]             if (.Platform$OS.type == "windows") {
[13:21:36.402]                 old_names <- names(...future.oldEnvVars)
[13:21:36.402]                 envs <- base::Sys.getenv()
[13:21:36.402]                 names <- names(envs)
[13:21:36.402]                 common <- intersect(names, old_names)
[13:21:36.402]                 added <- setdiff(names, old_names)
[13:21:36.402]                 removed <- setdiff(old_names, names)
[13:21:36.402]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:36.402]                   envs[common]]
[13:21:36.402]                 NAMES <- toupper(changed)
[13:21:36.402]                 args <- list()
[13:21:36.402]                 for (kk in seq_along(NAMES)) {
[13:21:36.402]                   name <- changed[[kk]]
[13:21:36.402]                   NAME <- NAMES[[kk]]
[13:21:36.402]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:36.402]                     next
[13:21:36.402]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:36.402]                 }
[13:21:36.402]                 NAMES <- toupper(added)
[13:21:36.402]                 for (kk in seq_along(NAMES)) {
[13:21:36.402]                   name <- added[[kk]]
[13:21:36.402]                   NAME <- NAMES[[kk]]
[13:21:36.402]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:36.402]                     next
[13:21:36.402]                   args[[name]] <- ""
[13:21:36.402]                 }
[13:21:36.402]                 NAMES <- toupper(removed)
[13:21:36.402]                 for (kk in seq_along(NAMES)) {
[13:21:36.402]                   name <- removed[[kk]]
[13:21:36.402]                   NAME <- NAMES[[kk]]
[13:21:36.402]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:36.402]                     next
[13:21:36.402]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:36.402]                 }
[13:21:36.402]                 if (length(args) > 0) 
[13:21:36.402]                   base::do.call(base::Sys.setenv, args = args)
[13:21:36.402]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:36.402]             }
[13:21:36.402]             else {
[13:21:36.402]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:36.402]             }
[13:21:36.402]             {
[13:21:36.402]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:36.402]                   0L) {
[13:21:36.402]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:36.402]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:36.402]                   base::options(opts)
[13:21:36.402]                 }
[13:21:36.402]                 {
[13:21:36.402]                   {
[13:21:36.402]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:36.402]                     NULL
[13:21:36.402]                   }
[13:21:36.402]                   options(future.plan = NULL)
[13:21:36.402]                   if (is.na(NA_character_)) 
[13:21:36.402]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:36.402]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:36.402]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:36.402]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:36.402]                     envir = parent.frame()) 
[13:21:36.402]                   {
[13:21:36.402]                     if (is.function(workers)) 
[13:21:36.402]                       workers <- workers()
[13:21:36.402]                     workers <- structure(as.integer(workers), 
[13:21:36.402]                       class = class(workers))
[13:21:36.402]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:36.402]                       workers >= 1)
[13:21:36.402]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:36.402]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:36.402]                     }
[13:21:36.402]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:36.402]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:36.402]                       envir = envir)
[13:21:36.402]                     if (!future$lazy) 
[13:21:36.402]                       future <- run(future)
[13:21:36.402]                     invisible(future)
[13:21:36.402]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:36.402]                 }
[13:21:36.402]             }
[13:21:36.402]         }
[13:21:36.402]     })
[13:21:36.402]     if (TRUE) {
[13:21:36.402]         base::sink(type = "output", split = FALSE)
[13:21:36.402]         if (TRUE) {
[13:21:36.402]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:36.402]         }
[13:21:36.402]         else {
[13:21:36.402]             ...future.result["stdout"] <- base::list(NULL)
[13:21:36.402]         }
[13:21:36.402]         base::close(...future.stdout)
[13:21:36.402]         ...future.stdout <- NULL
[13:21:36.402]     }
[13:21:36.402]     ...future.result$conditions <- ...future.conditions
[13:21:36.402]     ...future.result$finished <- base::Sys.time()
[13:21:36.402]     ...future.result
[13:21:36.402] }
[13:21:36.405] Exporting 11 global objects (92.00 KiB) to cluster node #1 ...
[13:21:36.406] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:21:36.448] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:21:36.449] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[13:21:36.449] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[13:21:36.449] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:21:36.450] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:21:36.450] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:21:36.492] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:21:36.492] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:21:36.536] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:21:36.536] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[13:21:36.537] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[13:21:36.537] Exporting ‘valid_types’ (120 bytes) to cluster node #1 ...
[13:21:36.537] Exporting ‘valid_types’ (120 bytes) to cluster node #1 ... DONE
[13:21:36.538] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:21:36.538] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:21:36.538] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ...
[13:21:36.539] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ... DONE
[13:21:36.539] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:21:36.539] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:21:36.539] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:21:36.540] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:21:36.540] Exporting 11 global objects (92.00 KiB) to cluster node #1 ... DONE
[13:21:36.541] MultisessionFuture started
[13:21:36.541] - Launch lazy future ... done
[13:21:36.541] run() for ‘MultisessionFuture’ ... done
[13:21:36.541] Created future:
[13:21:36.541] MultisessionFuture:
[13:21:36.541] Label: ‘future_vapply-1’
[13:21:36.541] Expression:
[13:21:36.541] {
[13:21:36.541]     do.call(function(...) {
[13:21:36.541]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:36.541]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:36.541]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:36.541]             on.exit(options(oopts), add = TRUE)
[13:21:36.541]         }
[13:21:36.541]         {
[13:21:36.541]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:36.541]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:36.541]                 ...future.FUN(...future.X_jj, ...)
[13:21:36.541]             })
[13:21:36.541]         }
[13:21:36.541]     }, args = future.call.arguments)
[13:21:36.541] }
[13:21:36.541] Lazy evaluation: FALSE
[13:21:36.541] Asynchronous evaluation: TRUE
[13:21:36.541] Local evaluation: TRUE
[13:21:36.541] Environment: R_GlobalEnv
[13:21:36.541] Capture standard output: TRUE
[13:21:36.541] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:36.541] Globals: 11 objects totaling 92.09 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:36.541] Packages: 1 packages (‘future.apply’)
[13:21:36.541] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:36.541] Resolved: FALSE
[13:21:36.541] Value: <not collected>
[13:21:36.541] Conditions captured: <none>
[13:21:36.541] Early signaling: FALSE
[13:21:36.541] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:36.541] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:36.554] Chunk #1 of 2 ... DONE
[13:21:36.554] Chunk #2 of 2 ...
[13:21:36.554]  - Finding globals in 'X' for chunk #2 ...
[13:21:36.554] getGlobalsAndPackages() ...
[13:21:36.554] Searching for globals...
[13:21:36.555] 
[13:21:36.555] Searching for globals ... DONE
[13:21:36.555] - globals: [0] <none>
[13:21:36.555] getGlobalsAndPackages() ... DONE
[13:21:36.555]    + additional globals found: [n=0] 
[13:21:36.555]    + additional namespaces needed: [n=0] 
[13:21:36.555]  - Finding globals in 'X' for chunk #2 ... DONE
[13:21:36.555]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:36.556]  - seeds: <none>
[13:21:36.556]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:36.556] getGlobalsAndPackages() ...
[13:21:36.556] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:36.556] Resolving globals: FALSE
[13:21:36.556] Tweak future expression to call with '...' arguments ...
[13:21:36.556] {
[13:21:36.556]     do.call(function(...) {
[13:21:36.556]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:36.556]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:36.556]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:36.556]             on.exit(options(oopts), add = TRUE)
[13:21:36.556]         }
[13:21:36.556]         {
[13:21:36.556]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:36.556]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:36.556]                 ...future.FUN(...future.X_jj, ...)
[13:21:36.556]             })
[13:21:36.556]         }
[13:21:36.556]     }, args = future.call.arguments)
[13:21:36.556] }
[13:21:36.557] Tweak future expression to call with '...' arguments ... DONE
[13:21:36.557] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:36.558] - packages: [1] ‘future.apply’
[13:21:36.558] getGlobalsAndPackages() ... DONE
[13:21:36.558] run() for ‘Future’ ...
[13:21:36.558] - state: ‘created’
[13:21:36.558] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:36.573] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:36.573] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:36.574]   - Field: ‘node’
[13:21:36.574]   - Field: ‘label’
[13:21:36.574]   - Field: ‘local’
[13:21:36.574]   - Field: ‘owner’
[13:21:36.574]   - Field: ‘envir’
[13:21:36.574]   - Field: ‘workers’
[13:21:36.574]   - Field: ‘packages’
[13:21:36.574]   - Field: ‘gc’
[13:21:36.574]   - Field: ‘conditions’
[13:21:36.574]   - Field: ‘persistent’
[13:21:36.575]   - Field: ‘expr’
[13:21:36.575]   - Field: ‘uuid’
[13:21:36.575]   - Field: ‘seed’
[13:21:36.575]   - Field: ‘version’
[13:21:36.575]   - Field: ‘result’
[13:21:36.575]   - Field: ‘asynchronous’
[13:21:36.575]   - Field: ‘calls’
[13:21:36.575]   - Field: ‘globals’
[13:21:36.575]   - Field: ‘stdout’
[13:21:36.576]   - Field: ‘earlySignal’
[13:21:36.576]   - Field: ‘lazy’
[13:21:36.576]   - Field: ‘state’
[13:21:36.576] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:36.576] - Launch lazy future ...
[13:21:36.576] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:36.577] Packages needed by future strategies (n = 0): <none>
[13:21:36.577] {
[13:21:36.577]     {
[13:21:36.577]         {
[13:21:36.577]             ...future.startTime <- base::Sys.time()
[13:21:36.577]             {
[13:21:36.577]                 {
[13:21:36.577]                   {
[13:21:36.577]                     {
[13:21:36.577]                       {
[13:21:36.577]                         base::local({
[13:21:36.577]                           has_future <- base::requireNamespace("future", 
[13:21:36.577]                             quietly = TRUE)
[13:21:36.577]                           if (has_future) {
[13:21:36.577]                             ns <- base::getNamespace("future")
[13:21:36.577]                             version <- ns[[".package"]][["version"]]
[13:21:36.577]                             if (is.null(version)) 
[13:21:36.577]                               version <- utils::packageVersion("future")
[13:21:36.577]                           }
[13:21:36.577]                           else {
[13:21:36.577]                             version <- NULL
[13:21:36.577]                           }
[13:21:36.577]                           if (!has_future || version < "1.8.0") {
[13:21:36.577]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:36.577]                               "", base::R.version$version.string), 
[13:21:36.577]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:36.577]                                 base::R.version$platform, 8 * 
[13:21:36.577]                                   base::.Machine$sizeof.pointer), 
[13:21:36.577]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:36.577]                                 "release", "version")], collapse = " "), 
[13:21:36.577]                               hostname = base::Sys.info()[["nodename"]])
[13:21:36.577]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:36.577]                               info)
[13:21:36.577]                             info <- base::paste(info, collapse = "; ")
[13:21:36.577]                             if (!has_future) {
[13:21:36.577]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:36.577]                                 info)
[13:21:36.577]                             }
[13:21:36.577]                             else {
[13:21:36.577]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:36.577]                                 info, version)
[13:21:36.577]                             }
[13:21:36.577]                             base::stop(msg)
[13:21:36.577]                           }
[13:21:36.577]                         })
[13:21:36.577]                       }
[13:21:36.577]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:36.577]                       base::options(mc.cores = 1L)
[13:21:36.577]                     }
[13:21:36.577]                     base::local({
[13:21:36.577]                       for (pkg in "future.apply") {
[13:21:36.577]                         base::loadNamespace(pkg)
[13:21:36.577]                         base::library(pkg, character.only = TRUE)
[13:21:36.577]                       }
[13:21:36.577]                     })
[13:21:36.577]                   }
[13:21:36.577]                   options(future.plan = NULL)
[13:21:36.577]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:36.577]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:36.577]                 }
[13:21:36.577]                 ...future.workdir <- getwd()
[13:21:36.577]             }
[13:21:36.577]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:36.577]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:36.577]         }
[13:21:36.577]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:36.577]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:36.577]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:36.577]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:36.577]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:36.577]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:36.577]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:36.577]             base::names(...future.oldOptions))
[13:21:36.577]     }
[13:21:36.577]     if (FALSE) {
[13:21:36.577]     }
[13:21:36.577]     else {
[13:21:36.577]         if (TRUE) {
[13:21:36.577]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:36.577]                 open = "w")
[13:21:36.577]         }
[13:21:36.577]         else {
[13:21:36.577]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:36.577]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:36.577]         }
[13:21:36.577]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:36.577]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:36.577]             base::sink(type = "output", split = FALSE)
[13:21:36.577]             base::close(...future.stdout)
[13:21:36.577]         }, add = TRUE)
[13:21:36.577]     }
[13:21:36.577]     ...future.frame <- base::sys.nframe()
[13:21:36.577]     ...future.conditions <- base::list()
[13:21:36.577]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:36.577]     if (FALSE) {
[13:21:36.577]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:36.577]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:36.577]     }
[13:21:36.577]     ...future.result <- base::tryCatch({
[13:21:36.577]         base::withCallingHandlers({
[13:21:36.577]             ...future.value <- base::withVisible(base::local({
[13:21:36.577]                 ...future.makeSendCondition <- base::local({
[13:21:36.577]                   sendCondition <- NULL
[13:21:36.577]                   function(frame = 1L) {
[13:21:36.577]                     if (is.function(sendCondition)) 
[13:21:36.577]                       return(sendCondition)
[13:21:36.577]                     ns <- getNamespace("parallel")
[13:21:36.577]                     if (exists("sendData", mode = "function", 
[13:21:36.577]                       envir = ns)) {
[13:21:36.577]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:36.577]                         envir = ns)
[13:21:36.577]                       envir <- sys.frame(frame)
[13:21:36.577]                       master <- NULL
[13:21:36.577]                       while (!identical(envir, .GlobalEnv) && 
[13:21:36.577]                         !identical(envir, emptyenv())) {
[13:21:36.577]                         if (exists("master", mode = "list", envir = envir, 
[13:21:36.577]                           inherits = FALSE)) {
[13:21:36.577]                           master <- get("master", mode = "list", 
[13:21:36.577]                             envir = envir, inherits = FALSE)
[13:21:36.577]                           if (inherits(master, c("SOCKnode", 
[13:21:36.577]                             "SOCK0node"))) {
[13:21:36.577]                             sendCondition <<- function(cond) {
[13:21:36.577]                               data <- list(type = "VALUE", value = cond, 
[13:21:36.577]                                 success = TRUE)
[13:21:36.577]                               parallel_sendData(master, data)
[13:21:36.577]                             }
[13:21:36.577]                             return(sendCondition)
[13:21:36.577]                           }
[13:21:36.577]                         }
[13:21:36.577]                         frame <- frame + 1L
[13:21:36.577]                         envir <- sys.frame(frame)
[13:21:36.577]                       }
[13:21:36.577]                     }
[13:21:36.577]                     sendCondition <<- function(cond) NULL
[13:21:36.577]                   }
[13:21:36.577]                 })
[13:21:36.577]                 withCallingHandlers({
[13:21:36.577]                   {
[13:21:36.577]                     do.call(function(...) {
[13:21:36.577]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:36.577]                       if (!identical(...future.globals.maxSize.org, 
[13:21:36.577]                         ...future.globals.maxSize)) {
[13:21:36.577]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:36.577]                         on.exit(options(oopts), add = TRUE)
[13:21:36.577]                       }
[13:21:36.577]                       {
[13:21:36.577]                         lapply(seq_along(...future.elements_ii), 
[13:21:36.577]                           FUN = function(jj) {
[13:21:36.577]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:36.577]                             ...future.FUN(...future.X_jj, ...)
[13:21:36.577]                           })
[13:21:36.577]                       }
[13:21:36.577]                     }, args = future.call.arguments)
[13:21:36.577]                   }
[13:21:36.577]                 }, immediateCondition = function(cond) {
[13:21:36.577]                   sendCondition <- ...future.makeSendCondition()
[13:21:36.577]                   sendCondition(cond)
[13:21:36.577]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:36.577]                   {
[13:21:36.577]                     inherits <- base::inherits
[13:21:36.577]                     invokeRestart <- base::invokeRestart
[13:21:36.577]                     is.null <- base::is.null
[13:21:36.577]                     muffled <- FALSE
[13:21:36.577]                     if (inherits(cond, "message")) {
[13:21:36.577]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:36.577]                       if (muffled) 
[13:21:36.577]                         invokeRestart("muffleMessage")
[13:21:36.577]                     }
[13:21:36.577]                     else if (inherits(cond, "warning")) {
[13:21:36.577]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:36.577]                       if (muffled) 
[13:21:36.577]                         invokeRestart("muffleWarning")
[13:21:36.577]                     }
[13:21:36.577]                     else if (inherits(cond, "condition")) {
[13:21:36.577]                       if (!is.null(pattern)) {
[13:21:36.577]                         computeRestarts <- base::computeRestarts
[13:21:36.577]                         grepl <- base::grepl
[13:21:36.577]                         restarts <- computeRestarts(cond)
[13:21:36.577]                         for (restart in restarts) {
[13:21:36.577]                           name <- restart$name
[13:21:36.577]                           if (is.null(name)) 
[13:21:36.577]                             next
[13:21:36.577]                           if (!grepl(pattern, name)) 
[13:21:36.577]                             next
[13:21:36.577]                           invokeRestart(restart)
[13:21:36.577]                           muffled <- TRUE
[13:21:36.577]                           break
[13:21:36.577]                         }
[13:21:36.577]                       }
[13:21:36.577]                     }
[13:21:36.577]                     invisible(muffled)
[13:21:36.577]                   }
[13:21:36.577]                   muffleCondition(cond)
[13:21:36.577]                 })
[13:21:36.577]             }))
[13:21:36.577]             future::FutureResult(value = ...future.value$value, 
[13:21:36.577]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:36.577]                   ...future.rng), globalenv = if (FALSE) 
[13:21:36.577]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:36.577]                     ...future.globalenv.names))
[13:21:36.577]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:36.577]         }, condition = base::local({
[13:21:36.577]             c <- base::c
[13:21:36.577]             inherits <- base::inherits
[13:21:36.577]             invokeRestart <- base::invokeRestart
[13:21:36.577]             length <- base::length
[13:21:36.577]             list <- base::list
[13:21:36.577]             seq.int <- base::seq.int
[13:21:36.577]             signalCondition <- base::signalCondition
[13:21:36.577]             sys.calls <- base::sys.calls
[13:21:36.577]             `[[` <- base::`[[`
[13:21:36.577]             `+` <- base::`+`
[13:21:36.577]             `<<-` <- base::`<<-`
[13:21:36.577]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:36.577]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:36.577]                   3L)]
[13:21:36.577]             }
[13:21:36.577]             function(cond) {
[13:21:36.577]                 is_error <- inherits(cond, "error")
[13:21:36.577]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:36.577]                   NULL)
[13:21:36.577]                 if (is_error) {
[13:21:36.577]                   sessionInformation <- function() {
[13:21:36.577]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:36.577]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:36.577]                       search = base::search(), system = base::Sys.info())
[13:21:36.577]                   }
[13:21:36.577]                   ...future.conditions[[length(...future.conditions) + 
[13:21:36.577]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:36.577]                     cond$call), session = sessionInformation(), 
[13:21:36.577]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:36.577]                   signalCondition(cond)
[13:21:36.577]                 }
[13:21:36.577]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:36.577]                 "immediateCondition"))) {
[13:21:36.577]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:36.577]                   ...future.conditions[[length(...future.conditions) + 
[13:21:36.577]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:36.577]                   if (TRUE && !signal) {
[13:21:36.577]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:36.577]                     {
[13:21:36.577]                       inherits <- base::inherits
[13:21:36.577]                       invokeRestart <- base::invokeRestart
[13:21:36.577]                       is.null <- base::is.null
[13:21:36.577]                       muffled <- FALSE
[13:21:36.577]                       if (inherits(cond, "message")) {
[13:21:36.577]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:36.577]                         if (muffled) 
[13:21:36.577]                           invokeRestart("muffleMessage")
[13:21:36.577]                       }
[13:21:36.577]                       else if (inherits(cond, "warning")) {
[13:21:36.577]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:36.577]                         if (muffled) 
[13:21:36.577]                           invokeRestart("muffleWarning")
[13:21:36.577]                       }
[13:21:36.577]                       else if (inherits(cond, "condition")) {
[13:21:36.577]                         if (!is.null(pattern)) {
[13:21:36.577]                           computeRestarts <- base::computeRestarts
[13:21:36.577]                           grepl <- base::grepl
[13:21:36.577]                           restarts <- computeRestarts(cond)
[13:21:36.577]                           for (restart in restarts) {
[13:21:36.577]                             name <- restart$name
[13:21:36.577]                             if (is.null(name)) 
[13:21:36.577]                               next
[13:21:36.577]                             if (!grepl(pattern, name)) 
[13:21:36.577]                               next
[13:21:36.577]                             invokeRestart(restart)
[13:21:36.577]                             muffled <- TRUE
[13:21:36.577]                             break
[13:21:36.577]                           }
[13:21:36.577]                         }
[13:21:36.577]                       }
[13:21:36.577]                       invisible(muffled)
[13:21:36.577]                     }
[13:21:36.577]                     muffleCondition(cond, pattern = "^muffle")
[13:21:36.577]                   }
[13:21:36.577]                 }
[13:21:36.577]                 else {
[13:21:36.577]                   if (TRUE) {
[13:21:36.577]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:36.577]                     {
[13:21:36.577]                       inherits <- base::inherits
[13:21:36.577]                       invokeRestart <- base::invokeRestart
[13:21:36.577]                       is.null <- base::is.null
[13:21:36.577]                       muffled <- FALSE
[13:21:36.577]                       if (inherits(cond, "message")) {
[13:21:36.577]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:36.577]                         if (muffled) 
[13:21:36.577]                           invokeRestart("muffleMessage")
[13:21:36.577]                       }
[13:21:36.577]                       else if (inherits(cond, "warning")) {
[13:21:36.577]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:36.577]                         if (muffled) 
[13:21:36.577]                           invokeRestart("muffleWarning")
[13:21:36.577]                       }
[13:21:36.577]                       else if (inherits(cond, "condition")) {
[13:21:36.577]                         if (!is.null(pattern)) {
[13:21:36.577]                           computeRestarts <- base::computeRestarts
[13:21:36.577]                           grepl <- base::grepl
[13:21:36.577]                           restarts <- computeRestarts(cond)
[13:21:36.577]                           for (restart in restarts) {
[13:21:36.577]                             name <- restart$name
[13:21:36.577]                             if (is.null(name)) 
[13:21:36.577]                               next
[13:21:36.577]                             if (!grepl(pattern, name)) 
[13:21:36.577]                               next
[13:21:36.577]                             invokeRestart(restart)
[13:21:36.577]                             muffled <- TRUE
[13:21:36.577]                             break
[13:21:36.577]                           }
[13:21:36.577]                         }
[13:21:36.577]                       }
[13:21:36.577]                       invisible(muffled)
[13:21:36.577]                     }
[13:21:36.577]                     muffleCondition(cond, pattern = "^muffle")
[13:21:36.577]                   }
[13:21:36.577]                 }
[13:21:36.577]             }
[13:21:36.577]         }))
[13:21:36.577]     }, error = function(ex) {
[13:21:36.577]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:36.577]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:36.577]                 ...future.rng), started = ...future.startTime, 
[13:21:36.577]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:36.577]             version = "1.8"), class = "FutureResult")
[13:21:36.577]     }, finally = {
[13:21:36.577]         if (!identical(...future.workdir, getwd())) 
[13:21:36.577]             setwd(...future.workdir)
[13:21:36.577]         {
[13:21:36.577]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:36.577]                 ...future.oldOptions$nwarnings <- NULL
[13:21:36.577]             }
[13:21:36.577]             base::options(...future.oldOptions)
[13:21:36.577]             if (.Platform$OS.type == "windows") {
[13:21:36.577]                 old_names <- names(...future.oldEnvVars)
[13:21:36.577]                 envs <- base::Sys.getenv()
[13:21:36.577]                 names <- names(envs)
[13:21:36.577]                 common <- intersect(names, old_names)
[13:21:36.577]                 added <- setdiff(names, old_names)
[13:21:36.577]                 removed <- setdiff(old_names, names)
[13:21:36.577]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:36.577]                   envs[common]]
[13:21:36.577]                 NAMES <- toupper(changed)
[13:21:36.577]                 args <- list()
[13:21:36.577]                 for (kk in seq_along(NAMES)) {
[13:21:36.577]                   name <- changed[[kk]]
[13:21:36.577]                   NAME <- NAMES[[kk]]
[13:21:36.577]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:36.577]                     next
[13:21:36.577]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:36.577]                 }
[13:21:36.577]                 NAMES <- toupper(added)
[13:21:36.577]                 for (kk in seq_along(NAMES)) {
[13:21:36.577]                   name <- added[[kk]]
[13:21:36.577]                   NAME <- NAMES[[kk]]
[13:21:36.577]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:36.577]                     next
[13:21:36.577]                   args[[name]] <- ""
[13:21:36.577]                 }
[13:21:36.577]                 NAMES <- toupper(removed)
[13:21:36.577]                 for (kk in seq_along(NAMES)) {
[13:21:36.577]                   name <- removed[[kk]]
[13:21:36.577]                   NAME <- NAMES[[kk]]
[13:21:36.577]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:36.577]                     next
[13:21:36.577]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:36.577]                 }
[13:21:36.577]                 if (length(args) > 0) 
[13:21:36.577]                   base::do.call(base::Sys.setenv, args = args)
[13:21:36.577]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:36.577]             }
[13:21:36.577]             else {
[13:21:36.577]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:36.577]             }
[13:21:36.577]             {
[13:21:36.577]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:36.577]                   0L) {
[13:21:36.577]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:36.577]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:36.577]                   base::options(opts)
[13:21:36.577]                 }
[13:21:36.577]                 {
[13:21:36.577]                   {
[13:21:36.577]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:36.577]                     NULL
[13:21:36.577]                   }
[13:21:36.577]                   options(future.plan = NULL)
[13:21:36.577]                   if (is.na(NA_character_)) 
[13:21:36.577]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:36.577]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:36.577]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:36.577]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:36.577]                     envir = parent.frame()) 
[13:21:36.577]                   {
[13:21:36.577]                     if (is.function(workers)) 
[13:21:36.577]                       workers <- workers()
[13:21:36.577]                     workers <- structure(as.integer(workers), 
[13:21:36.577]                       class = class(workers))
[13:21:36.577]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:36.577]                       workers >= 1)
[13:21:36.577]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:36.577]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:36.577]                     }
[13:21:36.577]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:36.577]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:36.577]                       envir = envir)
[13:21:36.577]                     if (!future$lazy) 
[13:21:36.577]                       future <- run(future)
[13:21:36.577]                     invisible(future)
[13:21:36.577]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:36.577]                 }
[13:21:36.577]             }
[13:21:36.577]         }
[13:21:36.577]     })
[13:21:36.577]     if (TRUE) {
[13:21:36.577]         base::sink(type = "output", split = FALSE)
[13:21:36.577]         if (TRUE) {
[13:21:36.577]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:36.577]         }
[13:21:36.577]         else {
[13:21:36.577]             ...future.result["stdout"] <- base::list(NULL)
[13:21:36.577]         }
[13:21:36.577]         base::close(...future.stdout)
[13:21:36.577]         ...future.stdout <- NULL
[13:21:36.577]     }
[13:21:36.577]     ...future.result$conditions <- ...future.conditions
[13:21:36.577]     ...future.result$finished <- base::Sys.time()
[13:21:36.577]     ...future.result
[13:21:36.577] }
[13:21:36.633] Exporting 11 global objects (92.00 KiB) to cluster node #2 ...
[13:21:36.633] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[13:21:36.637] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[13:21:36.638] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[13:21:36.638] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[13:21:36.638] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[13:21:36.638] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[13:21:36.639] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[13:21:36.680] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[13:21:36.681] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[13:21:36.724] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[13:21:36.724] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[13:21:36.725] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[13:21:36.725] Exporting ‘valid_types’ (120 bytes) to cluster node #2 ...
[13:21:36.725] Exporting ‘valid_types’ (120 bytes) to cluster node #2 ... DONE
[13:21:36.726] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:21:36.726] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:21:36.726] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #2 ...
[13:21:36.727] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #2 ... DONE
[13:21:36.727] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:21:36.727] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:21:36.727] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:21:36.730] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:21:36.730] Exporting 11 global objects (92.00 KiB) to cluster node #2 ... DONE
[13:21:36.731] MultisessionFuture started
[13:21:36.731] - Launch lazy future ... done
[13:21:36.731] run() for ‘MultisessionFuture’ ... done
[13:21:36.731] Created future:
[13:21:36.731] MultisessionFuture:
[13:21:36.731] Label: ‘future_vapply-2’
[13:21:36.731] Expression:
[13:21:36.731] {
[13:21:36.731]     do.call(function(...) {
[13:21:36.731]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:36.731]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:36.731]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:36.731]             on.exit(options(oopts), add = TRUE)
[13:21:36.731]         }
[13:21:36.731]         {
[13:21:36.731]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:36.731]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:36.731]                 ...future.FUN(...future.X_jj, ...)
[13:21:36.731]             })
[13:21:36.731]         }
[13:21:36.731]     }, args = future.call.arguments)
[13:21:36.731] }
[13:21:36.731] Lazy evaluation: FALSE
[13:21:36.731] Asynchronous evaluation: TRUE
[13:21:36.731] Local evaluation: TRUE
[13:21:36.731] Environment: R_GlobalEnv
[13:21:36.731] Capture standard output: TRUE
[13:21:36.731] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:36.731] Globals: 11 objects totaling 92.72 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:36.731] Packages: 1 packages (‘future.apply’)
[13:21:36.731] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:36.731] Resolved: FALSE
[13:21:36.731] Value: <not collected>
[13:21:36.731] Conditions captured: <none>
[13:21:36.731] Early signaling: FALSE
[13:21:36.731] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:36.731] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:36.743] Chunk #2 of 2 ... DONE
[13:21:36.743] Launching 2 futures (chunks) ... DONE
[13:21:36.743] Resolving 2 futures (chunks) ...
[13:21:36.743] resolve() on list ...
[13:21:36.744]  recursive: 0
[13:21:36.744]  length: 2
[13:21:36.744] 
[13:21:36.744] receiveMessageFromWorker() for ClusterFuture ...
[13:21:36.744] - Validating connection of MultisessionFuture
[13:21:36.745] - received message: FutureResult
[13:21:36.745] - Received FutureResult
[13:21:36.745] - Erased future from FutureRegistry
[13:21:36.745] result() for ClusterFuture ...
[13:21:36.745] - result already collected: FutureResult
[13:21:36.745] result() for ClusterFuture ... done
[13:21:36.745] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:36.745] Future #1
[13:21:36.745] result() for ClusterFuture ...
[13:21:36.745] - result already collected: FutureResult
[13:21:36.746] result() for ClusterFuture ... done
[13:21:36.746] result() for ClusterFuture ...
[13:21:36.746] - result already collected: FutureResult
[13:21:36.746] result() for ClusterFuture ... done
[13:21:36.746] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:21:36.746] - nx: 2
[13:21:36.746] - relay: TRUE
[13:21:36.746] - stdout: TRUE
[13:21:36.746] - signal: TRUE
[13:21:36.746] - resignal: FALSE
[13:21:36.746] - force: TRUE
[13:21:36.747] - relayed: [n=2] FALSE, FALSE
[13:21:36.747] - queued futures: [n=2] FALSE, FALSE
[13:21:36.747]  - until=1
[13:21:36.747]  - relaying element #1
[13:21:36.747] result() for ClusterFuture ...
[13:21:36.747] - result already collected: FutureResult
[13:21:36.747] result() for ClusterFuture ... done
[13:21:36.747] result() for ClusterFuture ...
[13:21:36.747] - result already collected: FutureResult
[13:21:36.747] result() for ClusterFuture ... done
[13:21:36.748] result() for ClusterFuture ...
[13:21:36.748] - result already collected: FutureResult
[13:21:36.748] result() for ClusterFuture ... done
[13:21:36.748] result() for ClusterFuture ...
[13:21:36.748] - result already collected: FutureResult
[13:21:36.748] result() for ClusterFuture ... done
[13:21:36.748] - relayed: [n=2] TRUE, FALSE
[13:21:36.748] - queued futures: [n=2] TRUE, FALSE
[13:21:36.748] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:21:36.748]  length: 1 (resolved future 1)
[13:21:36.832] receiveMessageFromWorker() for ClusterFuture ...
[13:21:36.832] - Validating connection of MultisessionFuture
[13:21:36.832] - received message: FutureResult
[13:21:36.833] - Received FutureResult
[13:21:36.833] - Erased future from FutureRegistry
[13:21:36.833] result() for ClusterFuture ...
[13:21:36.833] - result already collected: FutureResult
[13:21:36.833] result() for ClusterFuture ... done
[13:21:36.833] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:36.833] Future #2
[13:21:36.833] result() for ClusterFuture ...
[13:21:36.833] - result already collected: FutureResult
[13:21:36.833] result() for ClusterFuture ... done
[13:21:36.834] result() for ClusterFuture ...
[13:21:36.834] - result already collected: FutureResult
[13:21:36.834] result() for ClusterFuture ... done
[13:21:36.834] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:21:36.834] - nx: 2
[13:21:36.834] - relay: TRUE
[13:21:36.834] - stdout: TRUE
[13:21:36.834] - signal: TRUE
[13:21:36.834] - resignal: FALSE
[13:21:36.834] - force: TRUE
[13:21:36.834] - relayed: [n=2] TRUE, FALSE
[13:21:36.835] - queued futures: [n=2] TRUE, FALSE
[13:21:36.835]  - until=2
[13:21:36.835]  - relaying element #2
[13:21:36.835] result() for ClusterFuture ...
[13:21:36.835] - result already collected: FutureResult
[13:21:36.835] result() for ClusterFuture ... done
[13:21:36.835] result() for ClusterFuture ...
[13:21:36.835] - result already collected: FutureResult
[13:21:36.835] result() for ClusterFuture ... done
[13:21:36.835] result() for ClusterFuture ...
[13:21:36.836] - result already collected: FutureResult
[13:21:36.836] result() for ClusterFuture ... done
[13:21:36.836] result() for ClusterFuture ...
[13:21:36.836] - result already collected: FutureResult
[13:21:36.836] result() for ClusterFuture ... done
[13:21:36.836] - relayed: [n=2] TRUE, TRUE
[13:21:36.836] - queued futures: [n=2] TRUE, TRUE
[13:21:36.836] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:21:36.836]  length: 0 (resolved future 2)
[13:21:36.836] Relaying remaining futures
[13:21:36.837] signalConditionsASAP(NULL, pos=0) ...
[13:21:36.837] - nx: 2
[13:21:36.837] - relay: TRUE
[13:21:36.837] - stdout: TRUE
[13:21:36.837] - signal: TRUE
[13:21:36.837] - resignal: FALSE
[13:21:36.837] - force: TRUE
[13:21:36.837] - relayed: [n=2] TRUE, TRUE
[13:21:36.837] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:21:36.837] - relayed: [n=2] TRUE, TRUE
[13:21:36.838] - queued futures: [n=2] TRUE, TRUE
[13:21:36.838] signalConditionsASAP(NULL, pos=0) ... done
[13:21:36.838] resolve() on list ... DONE
[13:21:36.838] result() for ClusterFuture ...
[13:21:36.838] - result already collected: FutureResult
[13:21:36.838] result() for ClusterFuture ... done
[13:21:36.838] result() for ClusterFuture ...
[13:21:36.838] - result already collected: FutureResult
[13:21:36.838] result() for ClusterFuture ... done
[13:21:36.838] result() for ClusterFuture ...
[13:21:36.839] - result already collected: FutureResult
[13:21:36.839] result() for ClusterFuture ... done
[13:21:36.839] result() for ClusterFuture ...
[13:21:36.839] - result already collected: FutureResult
[13:21:36.839] result() for ClusterFuture ... done
[13:21:36.839]  - Number of value chunks collected: 2
[13:21:36.839] Resolving 2 futures (chunks) ... DONE
[13:21:36.839] Reducing values from 2 chunks ...
[13:21:36.839]  - Number of values collected after concatenation: 2
[13:21:36.839]  - Number of values expected: 2
[13:21:36.839] Reducing values from 2 chunks ... DONE
[13:21:36.840] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[13:21:36.841] future_lapply() ...
[13:21:36.847] Number of chunks: 2
[13:21:36.847] getGlobalsAndPackagesXApply() ...
[13:21:36.847]  - future.globals: TRUE
[13:21:36.847] getGlobalsAndPackages() ...
[13:21:36.847] Searching for globals...
[13:21:36.851] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[13:21:36.851] Searching for globals ... DONE
[13:21:36.851] Resolving globals: FALSE
[13:21:36.852] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[13:21:36.852] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:36.853] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:36.853] - packages: [1] ‘future.apply’
[13:21:36.853] getGlobalsAndPackages() ... DONE
[13:21:36.853]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:36.853]  - needed namespaces: [n=1] ‘future.apply’
[13:21:36.853] Finding globals ... DONE
[13:21:36.853]  - use_args: TRUE
[13:21:36.853]  - Getting '...' globals ...
[13:21:36.854] resolve() on list ...
[13:21:36.854]  recursive: 0
[13:21:36.854]  length: 1
[13:21:36.854]  elements: ‘...’
[13:21:36.854]  length: 0 (resolved future 1)
[13:21:36.854] resolve() on list ... DONE
[13:21:36.854]    - '...' content: [n=0] 
[13:21:36.854] List of 1
[13:21:36.854]  $ ...: list()
[13:21:36.854]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:36.854]  - attr(*, "where")=List of 1
[13:21:36.854]   ..$ ...:<environment: 0x563b6e322cd8> 
[13:21:36.854]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:36.854]  - attr(*, "resolved")= logi TRUE
[13:21:36.854]  - attr(*, "total_size")= num NA
[13:21:36.857]  - Getting '...' globals ... DONE
[13:21:36.857] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:36.857] List of 8
[13:21:36.857]  $ ...future.FUN:function (x, ...)  
[13:21:36.857]  $ x_FUN        :function (x)  
[13:21:36.857]  $ times        : int 0
[13:21:36.857]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:36.857]  $ stop_if_not  :function (...)  
[13:21:36.857]  $ dim          : NULL
[13:21:36.857]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:21:36.857]  $ ...          : list()
[13:21:36.857]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:36.857]  - attr(*, "where")=List of 8
[13:21:36.857]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:36.857]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:36.857]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:36.857]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:36.857]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:36.857]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:36.857]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:36.857]   ..$ ...          :<environment: 0x563b6e322cd8> 
[13:21:36.857]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:36.857]  - attr(*, "resolved")= logi FALSE
[13:21:36.857]  - attr(*, "total_size")= num 95472
[13:21:36.862] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:21:36.863] getGlobalsAndPackagesXApply() ... DONE
[13:21:36.863] Number of futures (= number of chunks): 2
[13:21:36.863] Launching 2 futures (chunks) ...
[13:21:36.863] Chunk #1 of 2 ...
[13:21:36.863]  - Finding globals in 'X' for chunk #1 ...
[13:21:36.863] getGlobalsAndPackages() ...
[13:21:36.863] Searching for globals...
[13:21:36.864] 
[13:21:36.864] Searching for globals ... DONE
[13:21:36.864] - globals: [0] <none>
[13:21:36.864] getGlobalsAndPackages() ... DONE
[13:21:36.864]    + additional globals found: [n=0] 
[13:21:36.864]    + additional namespaces needed: [n=0] 
[13:21:36.864]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:36.864]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:36.864]  - seeds: <none>
[13:21:36.864]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:36.865] getGlobalsAndPackages() ...
[13:21:36.865] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:36.865] Resolving globals: FALSE
[13:21:36.865] Tweak future expression to call with '...' arguments ...
[13:21:36.865] {
[13:21:36.865]     do.call(function(...) {
[13:21:36.865]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:36.865]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:36.865]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:36.865]             on.exit(options(oopts), add = TRUE)
[13:21:36.865]         }
[13:21:36.865]         {
[13:21:36.865]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:36.865]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:36.865]                 ...future.FUN(...future.X_jj, ...)
[13:21:36.865]             })
[13:21:36.865]         }
[13:21:36.865]     }, args = future.call.arguments)
[13:21:36.865] }
[13:21:36.865] Tweak future expression to call with '...' arguments ... DONE
[13:21:36.866] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:36.866] - packages: [1] ‘future.apply’
[13:21:36.866] getGlobalsAndPackages() ... DONE
[13:21:36.866] run() for ‘Future’ ...
[13:21:36.866] - state: ‘created’
[13:21:36.867] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:36.880] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:36.881] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:36.881]   - Field: ‘node’
[13:21:36.881]   - Field: ‘label’
[13:21:36.881]   - Field: ‘local’
[13:21:36.881]   - Field: ‘owner’
[13:21:36.881]   - Field: ‘envir’
[13:21:36.881]   - Field: ‘workers’
[13:21:36.881]   - Field: ‘packages’
[13:21:36.881]   - Field: ‘gc’
[13:21:36.882]   - Field: ‘conditions’
[13:21:36.882]   - Field: ‘persistent’
[13:21:36.882]   - Field: ‘expr’
[13:21:36.882]   - Field: ‘uuid’
[13:21:36.882]   - Field: ‘seed’
[13:21:36.882]   - Field: ‘version’
[13:21:36.882]   - Field: ‘result’
[13:21:36.882]   - Field: ‘asynchronous’
[13:21:36.882]   - Field: ‘calls’
[13:21:36.882]   - Field: ‘globals’
[13:21:36.882]   - Field: ‘stdout’
[13:21:36.883]   - Field: ‘earlySignal’
[13:21:36.883]   - Field: ‘lazy’
[13:21:36.883]   - Field: ‘state’
[13:21:36.883] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:36.883] - Launch lazy future ...
[13:21:36.883] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:36.883] Packages needed by future strategies (n = 0): <none>
[13:21:36.884] {
[13:21:36.884]     {
[13:21:36.884]         {
[13:21:36.884]             ...future.startTime <- base::Sys.time()
[13:21:36.884]             {
[13:21:36.884]                 {
[13:21:36.884]                   {
[13:21:36.884]                     {
[13:21:36.884]                       {
[13:21:36.884]                         base::local({
[13:21:36.884]                           has_future <- base::requireNamespace("future", 
[13:21:36.884]                             quietly = TRUE)
[13:21:36.884]                           if (has_future) {
[13:21:36.884]                             ns <- base::getNamespace("future")
[13:21:36.884]                             version <- ns[[".package"]][["version"]]
[13:21:36.884]                             if (is.null(version)) 
[13:21:36.884]                               version <- utils::packageVersion("future")
[13:21:36.884]                           }
[13:21:36.884]                           else {
[13:21:36.884]                             version <- NULL
[13:21:36.884]                           }
[13:21:36.884]                           if (!has_future || version < "1.8.0") {
[13:21:36.884]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:36.884]                               "", base::R.version$version.string), 
[13:21:36.884]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:36.884]                                 base::R.version$platform, 8 * 
[13:21:36.884]                                   base::.Machine$sizeof.pointer), 
[13:21:36.884]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:36.884]                                 "release", "version")], collapse = " "), 
[13:21:36.884]                               hostname = base::Sys.info()[["nodename"]])
[13:21:36.884]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:36.884]                               info)
[13:21:36.884]                             info <- base::paste(info, collapse = "; ")
[13:21:36.884]                             if (!has_future) {
[13:21:36.884]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:36.884]                                 info)
[13:21:36.884]                             }
[13:21:36.884]                             else {
[13:21:36.884]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:36.884]                                 info, version)
[13:21:36.884]                             }
[13:21:36.884]                             base::stop(msg)
[13:21:36.884]                           }
[13:21:36.884]                         })
[13:21:36.884]                       }
[13:21:36.884]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:36.884]                       base::options(mc.cores = 1L)
[13:21:36.884]                     }
[13:21:36.884]                     base::local({
[13:21:36.884]                       for (pkg in "future.apply") {
[13:21:36.884]                         base::loadNamespace(pkg)
[13:21:36.884]                         base::library(pkg, character.only = TRUE)
[13:21:36.884]                       }
[13:21:36.884]                     })
[13:21:36.884]                   }
[13:21:36.884]                   options(future.plan = NULL)
[13:21:36.884]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:36.884]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:36.884]                 }
[13:21:36.884]                 ...future.workdir <- getwd()
[13:21:36.884]             }
[13:21:36.884]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:36.884]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:36.884]         }
[13:21:36.884]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:36.884]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:36.884]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:36.884]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:36.884]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:36.884]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:36.884]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:36.884]             base::names(...future.oldOptions))
[13:21:36.884]     }
[13:21:36.884]     if (FALSE) {
[13:21:36.884]     }
[13:21:36.884]     else {
[13:21:36.884]         if (TRUE) {
[13:21:36.884]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:36.884]                 open = "w")
[13:21:36.884]         }
[13:21:36.884]         else {
[13:21:36.884]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:36.884]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:36.884]         }
[13:21:36.884]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:36.884]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:36.884]             base::sink(type = "output", split = FALSE)
[13:21:36.884]             base::close(...future.stdout)
[13:21:36.884]         }, add = TRUE)
[13:21:36.884]     }
[13:21:36.884]     ...future.frame <- base::sys.nframe()
[13:21:36.884]     ...future.conditions <- base::list()
[13:21:36.884]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:36.884]     if (FALSE) {
[13:21:36.884]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:36.884]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:36.884]     }
[13:21:36.884]     ...future.result <- base::tryCatch({
[13:21:36.884]         base::withCallingHandlers({
[13:21:36.884]             ...future.value <- base::withVisible(base::local({
[13:21:36.884]                 ...future.makeSendCondition <- base::local({
[13:21:36.884]                   sendCondition <- NULL
[13:21:36.884]                   function(frame = 1L) {
[13:21:36.884]                     if (is.function(sendCondition)) 
[13:21:36.884]                       return(sendCondition)
[13:21:36.884]                     ns <- getNamespace("parallel")
[13:21:36.884]                     if (exists("sendData", mode = "function", 
[13:21:36.884]                       envir = ns)) {
[13:21:36.884]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:36.884]                         envir = ns)
[13:21:36.884]                       envir <- sys.frame(frame)
[13:21:36.884]                       master <- NULL
[13:21:36.884]                       while (!identical(envir, .GlobalEnv) && 
[13:21:36.884]                         !identical(envir, emptyenv())) {
[13:21:36.884]                         if (exists("master", mode = "list", envir = envir, 
[13:21:36.884]                           inherits = FALSE)) {
[13:21:36.884]                           master <- get("master", mode = "list", 
[13:21:36.884]                             envir = envir, inherits = FALSE)
[13:21:36.884]                           if (inherits(master, c("SOCKnode", 
[13:21:36.884]                             "SOCK0node"))) {
[13:21:36.884]                             sendCondition <<- function(cond) {
[13:21:36.884]                               data <- list(type = "VALUE", value = cond, 
[13:21:36.884]                                 success = TRUE)
[13:21:36.884]                               parallel_sendData(master, data)
[13:21:36.884]                             }
[13:21:36.884]                             return(sendCondition)
[13:21:36.884]                           }
[13:21:36.884]                         }
[13:21:36.884]                         frame <- frame + 1L
[13:21:36.884]                         envir <- sys.frame(frame)
[13:21:36.884]                       }
[13:21:36.884]                     }
[13:21:36.884]                     sendCondition <<- function(cond) NULL
[13:21:36.884]                   }
[13:21:36.884]                 })
[13:21:36.884]                 withCallingHandlers({
[13:21:36.884]                   {
[13:21:36.884]                     do.call(function(...) {
[13:21:36.884]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:36.884]                       if (!identical(...future.globals.maxSize.org, 
[13:21:36.884]                         ...future.globals.maxSize)) {
[13:21:36.884]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:36.884]                         on.exit(options(oopts), add = TRUE)
[13:21:36.884]                       }
[13:21:36.884]                       {
[13:21:36.884]                         lapply(seq_along(...future.elements_ii), 
[13:21:36.884]                           FUN = function(jj) {
[13:21:36.884]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:36.884]                             ...future.FUN(...future.X_jj, ...)
[13:21:36.884]                           })
[13:21:36.884]                       }
[13:21:36.884]                     }, args = future.call.arguments)
[13:21:36.884]                   }
[13:21:36.884]                 }, immediateCondition = function(cond) {
[13:21:36.884]                   sendCondition <- ...future.makeSendCondition()
[13:21:36.884]                   sendCondition(cond)
[13:21:36.884]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:36.884]                   {
[13:21:36.884]                     inherits <- base::inherits
[13:21:36.884]                     invokeRestart <- base::invokeRestart
[13:21:36.884]                     is.null <- base::is.null
[13:21:36.884]                     muffled <- FALSE
[13:21:36.884]                     if (inherits(cond, "message")) {
[13:21:36.884]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:36.884]                       if (muffled) 
[13:21:36.884]                         invokeRestart("muffleMessage")
[13:21:36.884]                     }
[13:21:36.884]                     else if (inherits(cond, "warning")) {
[13:21:36.884]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:36.884]                       if (muffled) 
[13:21:36.884]                         invokeRestart("muffleWarning")
[13:21:36.884]                     }
[13:21:36.884]                     else if (inherits(cond, "condition")) {
[13:21:36.884]                       if (!is.null(pattern)) {
[13:21:36.884]                         computeRestarts <- base::computeRestarts
[13:21:36.884]                         grepl <- base::grepl
[13:21:36.884]                         restarts <- computeRestarts(cond)
[13:21:36.884]                         for (restart in restarts) {
[13:21:36.884]                           name <- restart$name
[13:21:36.884]                           if (is.null(name)) 
[13:21:36.884]                             next
[13:21:36.884]                           if (!grepl(pattern, name)) 
[13:21:36.884]                             next
[13:21:36.884]                           invokeRestart(restart)
[13:21:36.884]                           muffled <- TRUE
[13:21:36.884]                           break
[13:21:36.884]                         }
[13:21:36.884]                       }
[13:21:36.884]                     }
[13:21:36.884]                     invisible(muffled)
[13:21:36.884]                   }
[13:21:36.884]                   muffleCondition(cond)
[13:21:36.884]                 })
[13:21:36.884]             }))
[13:21:36.884]             future::FutureResult(value = ...future.value$value, 
[13:21:36.884]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:36.884]                   ...future.rng), globalenv = if (FALSE) 
[13:21:36.884]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:36.884]                     ...future.globalenv.names))
[13:21:36.884]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:36.884]         }, condition = base::local({
[13:21:36.884]             c <- base::c
[13:21:36.884]             inherits <- base::inherits
[13:21:36.884]             invokeRestart <- base::invokeRestart
[13:21:36.884]             length <- base::length
[13:21:36.884]             list <- base::list
[13:21:36.884]             seq.int <- base::seq.int
[13:21:36.884]             signalCondition <- base::signalCondition
[13:21:36.884]             sys.calls <- base::sys.calls
[13:21:36.884]             `[[` <- base::`[[`
[13:21:36.884]             `+` <- base::`+`
[13:21:36.884]             `<<-` <- base::`<<-`
[13:21:36.884]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:36.884]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:36.884]                   3L)]
[13:21:36.884]             }
[13:21:36.884]             function(cond) {
[13:21:36.884]                 is_error <- inherits(cond, "error")
[13:21:36.884]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:36.884]                   NULL)
[13:21:36.884]                 if (is_error) {
[13:21:36.884]                   sessionInformation <- function() {
[13:21:36.884]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:36.884]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:36.884]                       search = base::search(), system = base::Sys.info())
[13:21:36.884]                   }
[13:21:36.884]                   ...future.conditions[[length(...future.conditions) + 
[13:21:36.884]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:36.884]                     cond$call), session = sessionInformation(), 
[13:21:36.884]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:36.884]                   signalCondition(cond)
[13:21:36.884]                 }
[13:21:36.884]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:36.884]                 "immediateCondition"))) {
[13:21:36.884]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:36.884]                   ...future.conditions[[length(...future.conditions) + 
[13:21:36.884]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:36.884]                   if (TRUE && !signal) {
[13:21:36.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:36.884]                     {
[13:21:36.884]                       inherits <- base::inherits
[13:21:36.884]                       invokeRestart <- base::invokeRestart
[13:21:36.884]                       is.null <- base::is.null
[13:21:36.884]                       muffled <- FALSE
[13:21:36.884]                       if (inherits(cond, "message")) {
[13:21:36.884]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:36.884]                         if (muffled) 
[13:21:36.884]                           invokeRestart("muffleMessage")
[13:21:36.884]                       }
[13:21:36.884]                       else if (inherits(cond, "warning")) {
[13:21:36.884]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:36.884]                         if (muffled) 
[13:21:36.884]                           invokeRestart("muffleWarning")
[13:21:36.884]                       }
[13:21:36.884]                       else if (inherits(cond, "condition")) {
[13:21:36.884]                         if (!is.null(pattern)) {
[13:21:36.884]                           computeRestarts <- base::computeRestarts
[13:21:36.884]                           grepl <- base::grepl
[13:21:36.884]                           restarts <- computeRestarts(cond)
[13:21:36.884]                           for (restart in restarts) {
[13:21:36.884]                             name <- restart$name
[13:21:36.884]                             if (is.null(name)) 
[13:21:36.884]                               next
[13:21:36.884]                             if (!grepl(pattern, name)) 
[13:21:36.884]                               next
[13:21:36.884]                             invokeRestart(restart)
[13:21:36.884]                             muffled <- TRUE
[13:21:36.884]                             break
[13:21:36.884]                           }
[13:21:36.884]                         }
[13:21:36.884]                       }
[13:21:36.884]                       invisible(muffled)
[13:21:36.884]                     }
[13:21:36.884]                     muffleCondition(cond, pattern = "^muffle")
[13:21:36.884]                   }
[13:21:36.884]                 }
[13:21:36.884]                 else {
[13:21:36.884]                   if (TRUE) {
[13:21:36.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:36.884]                     {
[13:21:36.884]                       inherits <- base::inherits
[13:21:36.884]                       invokeRestart <- base::invokeRestart
[13:21:36.884]                       is.null <- base::is.null
[13:21:36.884]                       muffled <- FALSE
[13:21:36.884]                       if (inherits(cond, "message")) {
[13:21:36.884]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:36.884]                         if (muffled) 
[13:21:36.884]                           invokeRestart("muffleMessage")
[13:21:36.884]                       }
[13:21:36.884]                       else if (inherits(cond, "warning")) {
[13:21:36.884]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:36.884]                         if (muffled) 
[13:21:36.884]                           invokeRestart("muffleWarning")
[13:21:36.884]                       }
[13:21:36.884]                       else if (inherits(cond, "condition")) {
[13:21:36.884]                         if (!is.null(pattern)) {
[13:21:36.884]                           computeRestarts <- base::computeRestarts
[13:21:36.884]                           grepl <- base::grepl
[13:21:36.884]                           restarts <- computeRestarts(cond)
[13:21:36.884]                           for (restart in restarts) {
[13:21:36.884]                             name <- restart$name
[13:21:36.884]                             if (is.null(name)) 
[13:21:36.884]                               next
[13:21:36.884]                             if (!grepl(pattern, name)) 
[13:21:36.884]                               next
[13:21:36.884]                             invokeRestart(restart)
[13:21:36.884]                             muffled <- TRUE
[13:21:36.884]                             break
[13:21:36.884]                           }
[13:21:36.884]                         }
[13:21:36.884]                       }
[13:21:36.884]                       invisible(muffled)
[13:21:36.884]                     }
[13:21:36.884]                     muffleCondition(cond, pattern = "^muffle")
[13:21:36.884]                   }
[13:21:36.884]                 }
[13:21:36.884]             }
[13:21:36.884]         }))
[13:21:36.884]     }, error = function(ex) {
[13:21:36.884]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:36.884]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:36.884]                 ...future.rng), started = ...future.startTime, 
[13:21:36.884]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:36.884]             version = "1.8"), class = "FutureResult")
[13:21:36.884]     }, finally = {
[13:21:36.884]         if (!identical(...future.workdir, getwd())) 
[13:21:36.884]             setwd(...future.workdir)
[13:21:36.884]         {
[13:21:36.884]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:36.884]                 ...future.oldOptions$nwarnings <- NULL
[13:21:36.884]             }
[13:21:36.884]             base::options(...future.oldOptions)
[13:21:36.884]             if (.Platform$OS.type == "windows") {
[13:21:36.884]                 old_names <- names(...future.oldEnvVars)
[13:21:36.884]                 envs <- base::Sys.getenv()
[13:21:36.884]                 names <- names(envs)
[13:21:36.884]                 common <- intersect(names, old_names)
[13:21:36.884]                 added <- setdiff(names, old_names)
[13:21:36.884]                 removed <- setdiff(old_names, names)
[13:21:36.884]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:36.884]                   envs[common]]
[13:21:36.884]                 NAMES <- toupper(changed)
[13:21:36.884]                 args <- list()
[13:21:36.884]                 for (kk in seq_along(NAMES)) {
[13:21:36.884]                   name <- changed[[kk]]
[13:21:36.884]                   NAME <- NAMES[[kk]]
[13:21:36.884]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:36.884]                     next
[13:21:36.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:36.884]                 }
[13:21:36.884]                 NAMES <- toupper(added)
[13:21:36.884]                 for (kk in seq_along(NAMES)) {
[13:21:36.884]                   name <- added[[kk]]
[13:21:36.884]                   NAME <- NAMES[[kk]]
[13:21:36.884]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:36.884]                     next
[13:21:36.884]                   args[[name]] <- ""
[13:21:36.884]                 }
[13:21:36.884]                 NAMES <- toupper(removed)
[13:21:36.884]                 for (kk in seq_along(NAMES)) {
[13:21:36.884]                   name <- removed[[kk]]
[13:21:36.884]                   NAME <- NAMES[[kk]]
[13:21:36.884]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:36.884]                     next
[13:21:36.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:36.884]                 }
[13:21:36.884]                 if (length(args) > 0) 
[13:21:36.884]                   base::do.call(base::Sys.setenv, args = args)
[13:21:36.884]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:36.884]             }
[13:21:36.884]             else {
[13:21:36.884]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:36.884]             }
[13:21:36.884]             {
[13:21:36.884]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:36.884]                   0L) {
[13:21:36.884]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:36.884]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:36.884]                   base::options(opts)
[13:21:36.884]                 }
[13:21:36.884]                 {
[13:21:36.884]                   {
[13:21:36.884]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:36.884]                     NULL
[13:21:36.884]                   }
[13:21:36.884]                   options(future.plan = NULL)
[13:21:36.884]                   if (is.na(NA_character_)) 
[13:21:36.884]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:36.884]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:36.884]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:36.884]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:36.884]                     envir = parent.frame()) 
[13:21:36.884]                   {
[13:21:36.884]                     if (is.function(workers)) 
[13:21:36.884]                       workers <- workers()
[13:21:36.884]                     workers <- structure(as.integer(workers), 
[13:21:36.884]                       class = class(workers))
[13:21:36.884]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:36.884]                       workers >= 1)
[13:21:36.884]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:36.884]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:36.884]                     }
[13:21:36.884]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:36.884]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:36.884]                       envir = envir)
[13:21:36.884]                     if (!future$lazy) 
[13:21:36.884]                       future <- run(future)
[13:21:36.884]                     invisible(future)
[13:21:36.884]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:36.884]                 }
[13:21:36.884]             }
[13:21:36.884]         }
[13:21:36.884]     })
[13:21:36.884]     if (TRUE) {
[13:21:36.884]         base::sink(type = "output", split = FALSE)
[13:21:36.884]         if (TRUE) {
[13:21:36.884]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:36.884]         }
[13:21:36.884]         else {
[13:21:36.884]             ...future.result["stdout"] <- base::list(NULL)
[13:21:36.884]         }
[13:21:36.884]         base::close(...future.stdout)
[13:21:36.884]         ...future.stdout <- NULL
[13:21:36.884]     }
[13:21:36.884]     ...future.result$conditions <- ...future.conditions
[13:21:36.884]     ...future.result$finished <- base::Sys.time()
[13:21:36.884]     ...future.result
[13:21:36.884] }
[13:21:36.887] Exporting 11 global objects (93.23 KiB) to cluster node #1 ...
[13:21:36.887] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:21:36.928] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:21:36.929] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ...
[13:21:36.929] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ... DONE
[13:21:36.929] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:21:36.929] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:21:36.930] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:21:36.972] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:21:36.972] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:21:37.016] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:21:37.016] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[13:21:37.017] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[13:21:37.017] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[13:21:37.017] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[13:21:37.018] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:21:37.018] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:21:37.018] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[13:21:37.019] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[13:21:37.019] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:21:37.019] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:21:37.019] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:21:37.020] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:21:37.020] Exporting 11 global objects (93.23 KiB) to cluster node #1 ... DONE
[13:21:37.020] MultisessionFuture started
[13:21:37.021] - Launch lazy future ... done
[13:21:37.021] run() for ‘MultisessionFuture’ ... done
[13:21:37.021] Created future:
[13:21:37.021] MultisessionFuture:
[13:21:37.021] Label: ‘future_vapply-1’
[13:21:37.021] Expression:
[13:21:37.021] {
[13:21:37.021]     do.call(function(...) {
[13:21:37.021]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:37.021]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:37.021]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:37.021]             on.exit(options(oopts), add = TRUE)
[13:21:37.021]         }
[13:21:37.021]         {
[13:21:37.021]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:37.021]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:37.021]                 ...future.FUN(...future.X_jj, ...)
[13:21:37.021]             })
[13:21:37.021]         }
[13:21:37.021]     }, args = future.call.arguments)
[13:21:37.021] }
[13:21:37.021] Lazy evaluation: FALSE
[13:21:37.021] Asynchronous evaluation: TRUE
[13:21:37.021] Local evaluation: TRUE
[13:21:37.021] Environment: R_GlobalEnv
[13:21:37.021] Capture standard output: TRUE
[13:21:37.021] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:37.021] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:37.021] Packages: 1 packages (‘future.apply’)
[13:21:37.021] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:37.021] Resolved: FALSE
[13:21:37.021] Value: <not collected>
[13:21:37.021] Conditions captured: <none>
[13:21:37.021] Early signaling: FALSE
[13:21:37.021] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:37.021] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:37.033] Chunk #1 of 2 ... DONE
[13:21:37.033] Chunk #2 of 2 ...
[13:21:37.033]  - Finding globals in 'X' for chunk #2 ...
[13:21:37.033] getGlobalsAndPackages() ...
[13:21:37.033] Searching for globals...
[13:21:37.033] 
[13:21:37.034] Searching for globals ... DONE
[13:21:37.034] - globals: [0] <none>
[13:21:37.034] getGlobalsAndPackages() ... DONE
[13:21:37.034]    + additional globals found: [n=0] 
[13:21:37.034]    + additional namespaces needed: [n=0] 
[13:21:37.034]  - Finding globals in 'X' for chunk #2 ... DONE
[13:21:37.034]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:37.034]  - seeds: <none>
[13:21:37.034]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:37.034] getGlobalsAndPackages() ...
[13:21:37.034] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:37.035] Resolving globals: FALSE
[13:21:37.035] Tweak future expression to call with '...' arguments ...
[13:21:37.035] {
[13:21:37.035]     do.call(function(...) {
[13:21:37.035]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:37.035]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:37.035]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:37.035]             on.exit(options(oopts), add = TRUE)
[13:21:37.035]         }
[13:21:37.035]         {
[13:21:37.035]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:37.035]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:37.035]                 ...future.FUN(...future.X_jj, ...)
[13:21:37.035]             })
[13:21:37.035]         }
[13:21:37.035]     }, args = future.call.arguments)
[13:21:37.035] }
[13:21:37.035] Tweak future expression to call with '...' arguments ... DONE
[13:21:37.036] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:37.036] - packages: [1] ‘future.apply’
[13:21:37.036] getGlobalsAndPackages() ... DONE
[13:21:37.036] run() for ‘Future’ ...
[13:21:37.036] - state: ‘created’
[13:21:37.036] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:37.050] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:37.051] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:37.051]   - Field: ‘node’
[13:21:37.051]   - Field: ‘label’
[13:21:37.051]   - Field: ‘local’
[13:21:37.051]   - Field: ‘owner’
[13:21:37.051]   - Field: ‘envir’
[13:21:37.051]   - Field: ‘workers’
[13:21:37.051]   - Field: ‘packages’
[13:21:37.051]   - Field: ‘gc’
[13:21:37.051]   - Field: ‘conditions’
[13:21:37.051]   - Field: ‘persistent’
[13:21:37.052]   - Field: ‘expr’
[13:21:37.052]   - Field: ‘uuid’
[13:21:37.052]   - Field: ‘seed’
[13:21:37.052]   - Field: ‘version’
[13:21:37.052]   - Field: ‘result’
[13:21:37.052]   - Field: ‘asynchronous’
[13:21:37.052]   - Field: ‘calls’
[13:21:37.052]   - Field: ‘globals’
[13:21:37.052]   - Field: ‘stdout’
[13:21:37.052]   - Field: ‘earlySignal’
[13:21:37.053]   - Field: ‘lazy’
[13:21:37.053]   - Field: ‘state’
[13:21:37.053] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:37.053] - Launch lazy future ...
[13:21:37.053] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:37.053] Packages needed by future strategies (n = 0): <none>
[13:21:37.054] {
[13:21:37.054]     {
[13:21:37.054]         {
[13:21:37.054]             ...future.startTime <- base::Sys.time()
[13:21:37.054]             {
[13:21:37.054]                 {
[13:21:37.054]                   {
[13:21:37.054]                     {
[13:21:37.054]                       {
[13:21:37.054]                         base::local({
[13:21:37.054]                           has_future <- base::requireNamespace("future", 
[13:21:37.054]                             quietly = TRUE)
[13:21:37.054]                           if (has_future) {
[13:21:37.054]                             ns <- base::getNamespace("future")
[13:21:37.054]                             version <- ns[[".package"]][["version"]]
[13:21:37.054]                             if (is.null(version)) 
[13:21:37.054]                               version <- utils::packageVersion("future")
[13:21:37.054]                           }
[13:21:37.054]                           else {
[13:21:37.054]                             version <- NULL
[13:21:37.054]                           }
[13:21:37.054]                           if (!has_future || version < "1.8.0") {
[13:21:37.054]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:37.054]                               "", base::R.version$version.string), 
[13:21:37.054]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:37.054]                                 base::R.version$platform, 8 * 
[13:21:37.054]                                   base::.Machine$sizeof.pointer), 
[13:21:37.054]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:37.054]                                 "release", "version")], collapse = " "), 
[13:21:37.054]                               hostname = base::Sys.info()[["nodename"]])
[13:21:37.054]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:37.054]                               info)
[13:21:37.054]                             info <- base::paste(info, collapse = "; ")
[13:21:37.054]                             if (!has_future) {
[13:21:37.054]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:37.054]                                 info)
[13:21:37.054]                             }
[13:21:37.054]                             else {
[13:21:37.054]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:37.054]                                 info, version)
[13:21:37.054]                             }
[13:21:37.054]                             base::stop(msg)
[13:21:37.054]                           }
[13:21:37.054]                         })
[13:21:37.054]                       }
[13:21:37.054]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:37.054]                       base::options(mc.cores = 1L)
[13:21:37.054]                     }
[13:21:37.054]                     base::local({
[13:21:37.054]                       for (pkg in "future.apply") {
[13:21:37.054]                         base::loadNamespace(pkg)
[13:21:37.054]                         base::library(pkg, character.only = TRUE)
[13:21:37.054]                       }
[13:21:37.054]                     })
[13:21:37.054]                   }
[13:21:37.054]                   options(future.plan = NULL)
[13:21:37.054]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:37.054]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:37.054]                 }
[13:21:37.054]                 ...future.workdir <- getwd()
[13:21:37.054]             }
[13:21:37.054]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:37.054]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:37.054]         }
[13:21:37.054]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:37.054]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:37.054]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:37.054]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:37.054]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:37.054]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:37.054]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:37.054]             base::names(...future.oldOptions))
[13:21:37.054]     }
[13:21:37.054]     if (FALSE) {
[13:21:37.054]     }
[13:21:37.054]     else {
[13:21:37.054]         if (TRUE) {
[13:21:37.054]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:37.054]                 open = "w")
[13:21:37.054]         }
[13:21:37.054]         else {
[13:21:37.054]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:37.054]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:37.054]         }
[13:21:37.054]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:37.054]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:37.054]             base::sink(type = "output", split = FALSE)
[13:21:37.054]             base::close(...future.stdout)
[13:21:37.054]         }, add = TRUE)
[13:21:37.054]     }
[13:21:37.054]     ...future.frame <- base::sys.nframe()
[13:21:37.054]     ...future.conditions <- base::list()
[13:21:37.054]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:37.054]     if (FALSE) {
[13:21:37.054]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:37.054]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:37.054]     }
[13:21:37.054]     ...future.result <- base::tryCatch({
[13:21:37.054]         base::withCallingHandlers({
[13:21:37.054]             ...future.value <- base::withVisible(base::local({
[13:21:37.054]                 ...future.makeSendCondition <- base::local({
[13:21:37.054]                   sendCondition <- NULL
[13:21:37.054]                   function(frame = 1L) {
[13:21:37.054]                     if (is.function(sendCondition)) 
[13:21:37.054]                       return(sendCondition)
[13:21:37.054]                     ns <- getNamespace("parallel")
[13:21:37.054]                     if (exists("sendData", mode = "function", 
[13:21:37.054]                       envir = ns)) {
[13:21:37.054]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:37.054]                         envir = ns)
[13:21:37.054]                       envir <- sys.frame(frame)
[13:21:37.054]                       master <- NULL
[13:21:37.054]                       while (!identical(envir, .GlobalEnv) && 
[13:21:37.054]                         !identical(envir, emptyenv())) {
[13:21:37.054]                         if (exists("master", mode = "list", envir = envir, 
[13:21:37.054]                           inherits = FALSE)) {
[13:21:37.054]                           master <- get("master", mode = "list", 
[13:21:37.054]                             envir = envir, inherits = FALSE)
[13:21:37.054]                           if (inherits(master, c("SOCKnode", 
[13:21:37.054]                             "SOCK0node"))) {
[13:21:37.054]                             sendCondition <<- function(cond) {
[13:21:37.054]                               data <- list(type = "VALUE", value = cond, 
[13:21:37.054]                                 success = TRUE)
[13:21:37.054]                               parallel_sendData(master, data)
[13:21:37.054]                             }
[13:21:37.054]                             return(sendCondition)
[13:21:37.054]                           }
[13:21:37.054]                         }
[13:21:37.054]                         frame <- frame + 1L
[13:21:37.054]                         envir <- sys.frame(frame)
[13:21:37.054]                       }
[13:21:37.054]                     }
[13:21:37.054]                     sendCondition <<- function(cond) NULL
[13:21:37.054]                   }
[13:21:37.054]                 })
[13:21:37.054]                 withCallingHandlers({
[13:21:37.054]                   {
[13:21:37.054]                     do.call(function(...) {
[13:21:37.054]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:37.054]                       if (!identical(...future.globals.maxSize.org, 
[13:21:37.054]                         ...future.globals.maxSize)) {
[13:21:37.054]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:37.054]                         on.exit(options(oopts), add = TRUE)
[13:21:37.054]                       }
[13:21:37.054]                       {
[13:21:37.054]                         lapply(seq_along(...future.elements_ii), 
[13:21:37.054]                           FUN = function(jj) {
[13:21:37.054]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:37.054]                             ...future.FUN(...future.X_jj, ...)
[13:21:37.054]                           })
[13:21:37.054]                       }
[13:21:37.054]                     }, args = future.call.arguments)
[13:21:37.054]                   }
[13:21:37.054]                 }, immediateCondition = function(cond) {
[13:21:37.054]                   sendCondition <- ...future.makeSendCondition()
[13:21:37.054]                   sendCondition(cond)
[13:21:37.054]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:37.054]                   {
[13:21:37.054]                     inherits <- base::inherits
[13:21:37.054]                     invokeRestart <- base::invokeRestart
[13:21:37.054]                     is.null <- base::is.null
[13:21:37.054]                     muffled <- FALSE
[13:21:37.054]                     if (inherits(cond, "message")) {
[13:21:37.054]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:37.054]                       if (muffled) 
[13:21:37.054]                         invokeRestart("muffleMessage")
[13:21:37.054]                     }
[13:21:37.054]                     else if (inherits(cond, "warning")) {
[13:21:37.054]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:37.054]                       if (muffled) 
[13:21:37.054]                         invokeRestart("muffleWarning")
[13:21:37.054]                     }
[13:21:37.054]                     else if (inherits(cond, "condition")) {
[13:21:37.054]                       if (!is.null(pattern)) {
[13:21:37.054]                         computeRestarts <- base::computeRestarts
[13:21:37.054]                         grepl <- base::grepl
[13:21:37.054]                         restarts <- computeRestarts(cond)
[13:21:37.054]                         for (restart in restarts) {
[13:21:37.054]                           name <- restart$name
[13:21:37.054]                           if (is.null(name)) 
[13:21:37.054]                             next
[13:21:37.054]                           if (!grepl(pattern, name)) 
[13:21:37.054]                             next
[13:21:37.054]                           invokeRestart(restart)
[13:21:37.054]                           muffled <- TRUE
[13:21:37.054]                           break
[13:21:37.054]                         }
[13:21:37.054]                       }
[13:21:37.054]                     }
[13:21:37.054]                     invisible(muffled)
[13:21:37.054]                   }
[13:21:37.054]                   muffleCondition(cond)
[13:21:37.054]                 })
[13:21:37.054]             }))
[13:21:37.054]             future::FutureResult(value = ...future.value$value, 
[13:21:37.054]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:37.054]                   ...future.rng), globalenv = if (FALSE) 
[13:21:37.054]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:37.054]                     ...future.globalenv.names))
[13:21:37.054]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:37.054]         }, condition = base::local({
[13:21:37.054]             c <- base::c
[13:21:37.054]             inherits <- base::inherits
[13:21:37.054]             invokeRestart <- base::invokeRestart
[13:21:37.054]             length <- base::length
[13:21:37.054]             list <- base::list
[13:21:37.054]             seq.int <- base::seq.int
[13:21:37.054]             signalCondition <- base::signalCondition
[13:21:37.054]             sys.calls <- base::sys.calls
[13:21:37.054]             `[[` <- base::`[[`
[13:21:37.054]             `+` <- base::`+`
[13:21:37.054]             `<<-` <- base::`<<-`
[13:21:37.054]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:37.054]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:37.054]                   3L)]
[13:21:37.054]             }
[13:21:37.054]             function(cond) {
[13:21:37.054]                 is_error <- inherits(cond, "error")
[13:21:37.054]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:37.054]                   NULL)
[13:21:37.054]                 if (is_error) {
[13:21:37.054]                   sessionInformation <- function() {
[13:21:37.054]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:37.054]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:37.054]                       search = base::search(), system = base::Sys.info())
[13:21:37.054]                   }
[13:21:37.054]                   ...future.conditions[[length(...future.conditions) + 
[13:21:37.054]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:37.054]                     cond$call), session = sessionInformation(), 
[13:21:37.054]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:37.054]                   signalCondition(cond)
[13:21:37.054]                 }
[13:21:37.054]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:37.054]                 "immediateCondition"))) {
[13:21:37.054]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:37.054]                   ...future.conditions[[length(...future.conditions) + 
[13:21:37.054]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:37.054]                   if (TRUE && !signal) {
[13:21:37.054]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:37.054]                     {
[13:21:37.054]                       inherits <- base::inherits
[13:21:37.054]                       invokeRestart <- base::invokeRestart
[13:21:37.054]                       is.null <- base::is.null
[13:21:37.054]                       muffled <- FALSE
[13:21:37.054]                       if (inherits(cond, "message")) {
[13:21:37.054]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:37.054]                         if (muffled) 
[13:21:37.054]                           invokeRestart("muffleMessage")
[13:21:37.054]                       }
[13:21:37.054]                       else if (inherits(cond, "warning")) {
[13:21:37.054]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:37.054]                         if (muffled) 
[13:21:37.054]                           invokeRestart("muffleWarning")
[13:21:37.054]                       }
[13:21:37.054]                       else if (inherits(cond, "condition")) {
[13:21:37.054]                         if (!is.null(pattern)) {
[13:21:37.054]                           computeRestarts <- base::computeRestarts
[13:21:37.054]                           grepl <- base::grepl
[13:21:37.054]                           restarts <- computeRestarts(cond)
[13:21:37.054]                           for (restart in restarts) {
[13:21:37.054]                             name <- restart$name
[13:21:37.054]                             if (is.null(name)) 
[13:21:37.054]                               next
[13:21:37.054]                             if (!grepl(pattern, name)) 
[13:21:37.054]                               next
[13:21:37.054]                             invokeRestart(restart)
[13:21:37.054]                             muffled <- TRUE
[13:21:37.054]                             break
[13:21:37.054]                           }
[13:21:37.054]                         }
[13:21:37.054]                       }
[13:21:37.054]                       invisible(muffled)
[13:21:37.054]                     }
[13:21:37.054]                     muffleCondition(cond, pattern = "^muffle")
[13:21:37.054]                   }
[13:21:37.054]                 }
[13:21:37.054]                 else {
[13:21:37.054]                   if (TRUE) {
[13:21:37.054]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:37.054]                     {
[13:21:37.054]                       inherits <- base::inherits
[13:21:37.054]                       invokeRestart <- base::invokeRestart
[13:21:37.054]                       is.null <- base::is.null
[13:21:37.054]                       muffled <- FALSE
[13:21:37.054]                       if (inherits(cond, "message")) {
[13:21:37.054]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:37.054]                         if (muffled) 
[13:21:37.054]                           invokeRestart("muffleMessage")
[13:21:37.054]                       }
[13:21:37.054]                       else if (inherits(cond, "warning")) {
[13:21:37.054]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:37.054]                         if (muffled) 
[13:21:37.054]                           invokeRestart("muffleWarning")
[13:21:37.054]                       }
[13:21:37.054]                       else if (inherits(cond, "condition")) {
[13:21:37.054]                         if (!is.null(pattern)) {
[13:21:37.054]                           computeRestarts <- base::computeRestarts
[13:21:37.054]                           grepl <- base::grepl
[13:21:37.054]                           restarts <- computeRestarts(cond)
[13:21:37.054]                           for (restart in restarts) {
[13:21:37.054]                             name <- restart$name
[13:21:37.054]                             if (is.null(name)) 
[13:21:37.054]                               next
[13:21:37.054]                             if (!grepl(pattern, name)) 
[13:21:37.054]                               next
[13:21:37.054]                             invokeRestart(restart)
[13:21:37.054]                             muffled <- TRUE
[13:21:37.054]                             break
[13:21:37.054]                           }
[13:21:37.054]                         }
[13:21:37.054]                       }
[13:21:37.054]                       invisible(muffled)
[13:21:37.054]                     }
[13:21:37.054]                     muffleCondition(cond, pattern = "^muffle")
[13:21:37.054]                   }
[13:21:37.054]                 }
[13:21:37.054]             }
[13:21:37.054]         }))
[13:21:37.054]     }, error = function(ex) {
[13:21:37.054]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:37.054]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:37.054]                 ...future.rng), started = ...future.startTime, 
[13:21:37.054]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:37.054]             version = "1.8"), class = "FutureResult")
[13:21:37.054]     }, finally = {
[13:21:37.054]         if (!identical(...future.workdir, getwd())) 
[13:21:37.054]             setwd(...future.workdir)
[13:21:37.054]         {
[13:21:37.054]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:37.054]                 ...future.oldOptions$nwarnings <- NULL
[13:21:37.054]             }
[13:21:37.054]             base::options(...future.oldOptions)
[13:21:37.054]             if (.Platform$OS.type == "windows") {
[13:21:37.054]                 old_names <- names(...future.oldEnvVars)
[13:21:37.054]                 envs <- base::Sys.getenv()
[13:21:37.054]                 names <- names(envs)
[13:21:37.054]                 common <- intersect(names, old_names)
[13:21:37.054]                 added <- setdiff(names, old_names)
[13:21:37.054]                 removed <- setdiff(old_names, names)
[13:21:37.054]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:37.054]                   envs[common]]
[13:21:37.054]                 NAMES <- toupper(changed)
[13:21:37.054]                 args <- list()
[13:21:37.054]                 for (kk in seq_along(NAMES)) {
[13:21:37.054]                   name <- changed[[kk]]
[13:21:37.054]                   NAME <- NAMES[[kk]]
[13:21:37.054]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:37.054]                     next
[13:21:37.054]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:37.054]                 }
[13:21:37.054]                 NAMES <- toupper(added)
[13:21:37.054]                 for (kk in seq_along(NAMES)) {
[13:21:37.054]                   name <- added[[kk]]
[13:21:37.054]                   NAME <- NAMES[[kk]]
[13:21:37.054]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:37.054]                     next
[13:21:37.054]                   args[[name]] <- ""
[13:21:37.054]                 }
[13:21:37.054]                 NAMES <- toupper(removed)
[13:21:37.054]                 for (kk in seq_along(NAMES)) {
[13:21:37.054]                   name <- removed[[kk]]
[13:21:37.054]                   NAME <- NAMES[[kk]]
[13:21:37.054]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:37.054]                     next
[13:21:37.054]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:37.054]                 }
[13:21:37.054]                 if (length(args) > 0) 
[13:21:37.054]                   base::do.call(base::Sys.setenv, args = args)
[13:21:37.054]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:37.054]             }
[13:21:37.054]             else {
[13:21:37.054]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:37.054]             }
[13:21:37.054]             {
[13:21:37.054]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:37.054]                   0L) {
[13:21:37.054]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:37.054]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:37.054]                   base::options(opts)
[13:21:37.054]                 }
[13:21:37.054]                 {
[13:21:37.054]                   {
[13:21:37.054]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:37.054]                     NULL
[13:21:37.054]                   }
[13:21:37.054]                   options(future.plan = NULL)
[13:21:37.054]                   if (is.na(NA_character_)) 
[13:21:37.054]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:37.054]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:37.054]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:37.054]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:37.054]                     envir = parent.frame()) 
[13:21:37.054]                   {
[13:21:37.054]                     if (is.function(workers)) 
[13:21:37.054]                       workers <- workers()
[13:21:37.054]                     workers <- structure(as.integer(workers), 
[13:21:37.054]                       class = class(workers))
[13:21:37.054]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:37.054]                       workers >= 1)
[13:21:37.054]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:37.054]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:37.054]                     }
[13:21:37.054]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:37.054]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:37.054]                       envir = envir)
[13:21:37.054]                     if (!future$lazy) 
[13:21:37.054]                       future <- run(future)
[13:21:37.054]                     invisible(future)
[13:21:37.054]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:37.054]                 }
[13:21:37.054]             }
[13:21:37.054]         }
[13:21:37.054]     })
[13:21:37.054]     if (TRUE) {
[13:21:37.054]         base::sink(type = "output", split = FALSE)
[13:21:37.054]         if (TRUE) {
[13:21:37.054]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:37.054]         }
[13:21:37.054]         else {
[13:21:37.054]             ...future.result["stdout"] <- base::list(NULL)
[13:21:37.054]         }
[13:21:37.054]         base::close(...future.stdout)
[13:21:37.054]         ...future.stdout <- NULL
[13:21:37.054]     }
[13:21:37.054]     ...future.result$conditions <- ...future.conditions
[13:21:37.054]     ...future.result$finished <- base::Sys.time()
[13:21:37.054]     ...future.result
[13:21:37.054] }
[13:21:37.057] Exporting 11 global objects (93.23 KiB) to cluster node #2 ...
[13:21:37.057] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[13:21:37.104] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[13:21:37.104] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ...
[13:21:37.105] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ... DONE
[13:21:37.105] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[13:21:37.105] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[13:21:37.105] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[13:21:37.148] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[13:21:37.148] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[13:21:37.192] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[13:21:37.193] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[13:21:37.193] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[13:21:37.193] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[13:21:37.194] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[13:21:37.194] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:21:37.194] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:21:37.194] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[13:21:37.195] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[13:21:37.195] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:21:37.195] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:21:37.195] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:21:37.196] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:21:37.196] Exporting 11 global objects (93.23 KiB) to cluster node #2 ... DONE
[13:21:37.196] MultisessionFuture started
[13:21:37.197] - Launch lazy future ... done
[13:21:37.197] run() for ‘MultisessionFuture’ ... done
[13:21:37.197] Created future:
[13:21:37.197] MultisessionFuture:
[13:21:37.197] Label: ‘future_vapply-2’
[13:21:37.197] Expression:
[13:21:37.197] {
[13:21:37.197]     do.call(function(...) {
[13:21:37.197]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:37.197]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:37.197]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:37.197]             on.exit(options(oopts), add = TRUE)
[13:21:37.197]         }
[13:21:37.197]         {
[13:21:37.197]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:37.197]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:37.197]                 ...future.FUN(...future.X_jj, ...)
[13:21:37.197]             })
[13:21:37.197]         }
[13:21:37.197]     }, args = future.call.arguments)
[13:21:37.197] }
[13:21:37.197] Lazy evaluation: FALSE
[13:21:37.197] Asynchronous evaluation: TRUE
[13:21:37.197] Local evaluation: TRUE
[13:21:37.197] Environment: R_GlobalEnv
[13:21:37.197] Capture standard output: TRUE
[13:21:37.197] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:37.197] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:37.197] Packages: 1 packages (‘future.apply’)
[13:21:37.197] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:37.197] Resolved: FALSE
[13:21:37.197] Value: <not collected>
[13:21:37.197] Conditions captured: <none>
[13:21:37.197] Early signaling: FALSE
[13:21:37.197] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:37.197] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:37.209] Chunk #2 of 2 ... DONE
[13:21:37.209] Launching 2 futures (chunks) ... DONE
[13:21:37.209] Resolving 2 futures (chunks) ...
[13:21:37.209] resolve() on list ...
[13:21:37.209]  recursive: 0
[13:21:37.209]  length: 2
[13:21:37.209] 
[13:21:37.210] receiveMessageFromWorker() for ClusterFuture ...
[13:21:37.210] - Validating connection of MultisessionFuture
[13:21:37.210] - received message: FutureResult
[13:21:37.210] - Received FutureResult
[13:21:37.210] - Erased future from FutureRegistry
[13:21:37.211] result() for ClusterFuture ...
[13:21:37.211] - result already collected: FutureResult
[13:21:37.211] result() for ClusterFuture ... done
[13:21:37.211] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:37.211] Future #1
[13:21:37.211] result() for ClusterFuture ...
[13:21:37.211] - result already collected: FutureResult
[13:21:37.211] result() for ClusterFuture ... done
[13:21:37.211] result() for ClusterFuture ...
[13:21:37.211] - result already collected: FutureResult
[13:21:37.211] result() for ClusterFuture ... done
[13:21:37.212] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:21:37.212] - nx: 2
[13:21:37.212] - relay: TRUE
[13:21:37.212] - stdout: TRUE
[13:21:37.212] - signal: TRUE
[13:21:37.212] - resignal: FALSE
[13:21:37.212] - force: TRUE
[13:21:37.212] - relayed: [n=2] FALSE, FALSE
[13:21:37.212] - queued futures: [n=2] FALSE, FALSE
[13:21:37.212]  - until=1
[13:21:37.212]  - relaying element #1
[13:21:37.213] result() for ClusterFuture ...
[13:21:37.213] - result already collected: FutureResult
[13:21:37.213] result() for ClusterFuture ... done
[13:21:37.213] result() for ClusterFuture ...
[13:21:37.213] - result already collected: FutureResult
[13:21:37.213] result() for ClusterFuture ... done
[13:21:37.213] result() for ClusterFuture ...
[13:21:37.213] - result already collected: FutureResult
[13:21:37.213] result() for ClusterFuture ... done
[13:21:37.213] result() for ClusterFuture ...
[13:21:37.213] - result already collected: FutureResult
[13:21:37.214] result() for ClusterFuture ... done
[13:21:37.214] - relayed: [n=2] TRUE, FALSE
[13:21:37.214] - queued futures: [n=2] TRUE, FALSE
[13:21:37.214] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:21:37.214]  length: 1 (resolved future 1)
[13:21:37.245] receiveMessageFromWorker() for ClusterFuture ...
[13:21:37.245] - Validating connection of MultisessionFuture
[13:21:37.245] - received message: FutureResult
[13:21:37.246] - Received FutureResult
[13:21:37.246] - Erased future from FutureRegistry
[13:21:37.246] result() for ClusterFuture ...
[13:21:37.246] - result already collected: FutureResult
[13:21:37.246] result() for ClusterFuture ... done
[13:21:37.246] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:37.246] Future #2
[13:21:37.246] result() for ClusterFuture ...
[13:21:37.246] - result already collected: FutureResult
[13:21:37.247] result() for ClusterFuture ... done
[13:21:37.247] result() for ClusterFuture ...
[13:21:37.247] - result already collected: FutureResult
[13:21:37.247] result() for ClusterFuture ... done
[13:21:37.247] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:21:37.247] - nx: 2
[13:21:37.247] - relay: TRUE
[13:21:37.247] - stdout: TRUE
[13:21:37.247] - signal: TRUE
[13:21:37.247] - resignal: FALSE
[13:21:37.247] - force: TRUE
[13:21:37.247] - relayed: [n=2] TRUE, FALSE
[13:21:37.248] - queued futures: [n=2] TRUE, FALSE
[13:21:37.248]  - until=2
[13:21:37.248]  - relaying element #2
[13:21:37.248] result() for ClusterFuture ...
[13:21:37.248] - result already collected: FutureResult
[13:21:37.248] result() for ClusterFuture ... done
[13:21:37.248] result() for ClusterFuture ...
[13:21:37.248] - result already collected: FutureResult
[13:21:37.248] result() for ClusterFuture ... done
[13:21:37.248] result() for ClusterFuture ...
[13:21:37.249] - result already collected: FutureResult
[13:21:37.249] result() for ClusterFuture ... done
[13:21:37.249] result() for ClusterFuture ...
[13:21:37.249] - result already collected: FutureResult
[13:21:37.249] result() for ClusterFuture ... done
[13:21:37.249] - relayed: [n=2] TRUE, TRUE
[13:21:37.249] - queued futures: [n=2] TRUE, TRUE
[13:21:37.249] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:21:37.249]  length: 0 (resolved future 2)
[13:21:37.249] Relaying remaining futures
[13:21:37.249] signalConditionsASAP(NULL, pos=0) ...
[13:21:37.250] - nx: 2
[13:21:37.250] - relay: TRUE
[13:21:37.250] - stdout: TRUE
[13:21:37.250] - signal: TRUE
[13:21:37.250] - resignal: FALSE
[13:21:37.250] - force: TRUE
[13:21:37.250] - relayed: [n=2] TRUE, TRUE
[13:21:37.250] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:21:37.250] - relayed: [n=2] TRUE, TRUE
[13:21:37.250] - queued futures: [n=2] TRUE, TRUE
[13:21:37.250] signalConditionsASAP(NULL, pos=0) ... done
[13:21:37.250] resolve() on list ... DONE
[13:21:37.251] result() for ClusterFuture ...
[13:21:37.251] - result already collected: FutureResult
[13:21:37.251] result() for ClusterFuture ... done
[13:21:37.251] result() for ClusterFuture ...
[13:21:37.251] - result already collected: FutureResult
[13:21:37.251] result() for ClusterFuture ... done
[13:21:37.251] result() for ClusterFuture ...
[13:21:37.251] - result already collected: FutureResult
[13:21:37.251] result() for ClusterFuture ... done
[13:21:37.251] result() for ClusterFuture ...
[13:21:37.251] - result already collected: FutureResult
[13:21:37.252] result() for ClusterFuture ... done
[13:21:37.252]  - Number of value chunks collected: 2
[13:21:37.252] Resolving 2 futures (chunks) ... DONE
[13:21:37.252] Reducing values from 2 chunks ...
[13:21:37.252]  - Number of values collected after concatenation: 10
[13:21:37.252]  - Number of values expected: 10
[13:21:37.252] Reducing values from 2 chunks ... DONE
[13:21:37.252] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[13:21:37.253] future_lapply() ...
[13:21:37.265] Number of chunks: 2
[13:21:37.265] getGlobalsAndPackagesXApply() ...
[13:21:37.265]  - future.globals: TRUE
[13:21:37.266] getGlobalsAndPackages() ...
[13:21:37.266] Searching for globals...
[13:21:37.269] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[13:21:37.270] Searching for globals ... DONE
[13:21:37.270] Resolving globals: FALSE
[13:21:37.270] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[13:21:37.271] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:37.271] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:37.271] - packages: [1] ‘future.apply’
[13:21:37.271] getGlobalsAndPackages() ... DONE
[13:21:37.271]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:37.271]  - needed namespaces: [n=1] ‘future.apply’
[13:21:37.272] Finding globals ... DONE
[13:21:37.272]  - use_args: TRUE
[13:21:37.272]  - Getting '...' globals ...
[13:21:37.272] resolve() on list ...
[13:21:37.272]  recursive: 0
[13:21:37.272]  length: 1
[13:21:37.272]  elements: ‘...’
[13:21:37.273]  length: 0 (resolved future 1)
[13:21:37.273] resolve() on list ... DONE
[13:21:37.273]    - '...' content: [n=0] 
[13:21:37.273] List of 1
[13:21:37.273]  $ ...: list()
[13:21:37.273]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:37.273]  - attr(*, "where")=List of 1
[13:21:37.273]   ..$ ...:<environment: 0x563b71b13528> 
[13:21:37.273]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:37.273]  - attr(*, "resolved")= logi TRUE
[13:21:37.273]  - attr(*, "total_size")= num NA
[13:21:37.275]  - Getting '...' globals ... DONE
[13:21:37.276] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:37.276] List of 8
[13:21:37.276]  $ ...future.FUN:function (x, ...)  
[13:21:37.276]  $ x_FUN        :function (x)  
[13:21:37.276]  $ times        : int 0
[13:21:37.276]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:37.276]  $ stop_if_not  :function (...)  
[13:21:37.276]  $ dim          : NULL
[13:21:37.276]  $ valid_types  : chr [1:2] "logical" "integer"
[13:21:37.276]  $ ...          : list()
[13:21:37.276]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:37.276]  - attr(*, "where")=List of 8
[13:21:37.276]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:37.276]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:37.276]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:37.276]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:37.276]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:37.276]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:37.276]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:37.276]   ..$ ...          :<environment: 0x563b71b13528> 
[13:21:37.276]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:37.276]  - attr(*, "resolved")= logi FALSE
[13:21:37.276]  - attr(*, "total_size")= num 95400
[13:21:37.281] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:21:37.281] getGlobalsAndPackagesXApply() ... DONE
[13:21:37.282] Number of futures (= number of chunks): 2
[13:21:37.282] Launching 2 futures (chunks) ...
[13:21:37.282] Chunk #1 of 2 ...
[13:21:37.282]  - Finding globals in 'X' for chunk #1 ...
[13:21:37.282] getGlobalsAndPackages() ...
[13:21:37.282] Searching for globals...
[13:21:37.282] 
[13:21:37.283] Searching for globals ... DONE
[13:21:37.283] - globals: [0] <none>
[13:21:37.283] getGlobalsAndPackages() ... DONE
[13:21:37.283]    + additional globals found: [n=0] 
[13:21:37.283]    + additional namespaces needed: [n=0] 
[13:21:37.283]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:37.283]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:37.283]  - seeds: <none>
[13:21:37.283]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:37.283] getGlobalsAndPackages() ...
[13:21:37.283] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:37.284] Resolving globals: FALSE
[13:21:37.284] Tweak future expression to call with '...' arguments ...
[13:21:37.284] {
[13:21:37.284]     do.call(function(...) {
[13:21:37.284]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:37.284]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:37.284]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:37.284]             on.exit(options(oopts), add = TRUE)
[13:21:37.284]         }
[13:21:37.284]         {
[13:21:37.284]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:37.284]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:37.284]                 ...future.FUN(...future.X_jj, ...)
[13:21:37.284]             })
[13:21:37.284]         }
[13:21:37.284]     }, args = future.call.arguments)
[13:21:37.284] }
[13:21:37.284] Tweak future expression to call with '...' arguments ... DONE
[13:21:37.285] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:37.285] - packages: [1] ‘future.apply’
[13:21:37.285] getGlobalsAndPackages() ... DONE
[13:21:37.285] run() for ‘Future’ ...
[13:21:37.285] - state: ‘created’
[13:21:37.285] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:37.300] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:37.300] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:37.300]   - Field: ‘node’
[13:21:37.300]   - Field: ‘label’
[13:21:37.300]   - Field: ‘local’
[13:21:37.300]   - Field: ‘owner’
[13:21:37.300]   - Field: ‘envir’
[13:21:37.300]   - Field: ‘workers’
[13:21:37.301]   - Field: ‘packages’
[13:21:37.301]   - Field: ‘gc’
[13:21:37.301]   - Field: ‘conditions’
[13:21:37.301]   - Field: ‘persistent’
[13:21:37.301]   - Field: ‘expr’
[13:21:37.301]   - Field: ‘uuid’
[13:21:37.301]   - Field: ‘seed’
[13:21:37.301]   - Field: ‘version’
[13:21:37.301]   - Field: ‘result’
[13:21:37.301]   - Field: ‘asynchronous’
[13:21:37.302]   - Field: ‘calls’
[13:21:37.302]   - Field: ‘globals’
[13:21:37.302]   - Field: ‘stdout’
[13:21:37.302]   - Field: ‘earlySignal’
[13:21:37.302]   - Field: ‘lazy’
[13:21:37.302]   - Field: ‘state’
[13:21:37.302] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:37.302] - Launch lazy future ...
[13:21:37.303] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:37.303] Packages needed by future strategies (n = 0): <none>
[13:21:37.303] {
[13:21:37.303]     {
[13:21:37.303]         {
[13:21:37.303]             ...future.startTime <- base::Sys.time()
[13:21:37.303]             {
[13:21:37.303]                 {
[13:21:37.303]                   {
[13:21:37.303]                     {
[13:21:37.303]                       {
[13:21:37.303]                         base::local({
[13:21:37.303]                           has_future <- base::requireNamespace("future", 
[13:21:37.303]                             quietly = TRUE)
[13:21:37.303]                           if (has_future) {
[13:21:37.303]                             ns <- base::getNamespace("future")
[13:21:37.303]                             version <- ns[[".package"]][["version"]]
[13:21:37.303]                             if (is.null(version)) 
[13:21:37.303]                               version <- utils::packageVersion("future")
[13:21:37.303]                           }
[13:21:37.303]                           else {
[13:21:37.303]                             version <- NULL
[13:21:37.303]                           }
[13:21:37.303]                           if (!has_future || version < "1.8.0") {
[13:21:37.303]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:37.303]                               "", base::R.version$version.string), 
[13:21:37.303]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:37.303]                                 base::R.version$platform, 8 * 
[13:21:37.303]                                   base::.Machine$sizeof.pointer), 
[13:21:37.303]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:37.303]                                 "release", "version")], collapse = " "), 
[13:21:37.303]                               hostname = base::Sys.info()[["nodename"]])
[13:21:37.303]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:37.303]                               info)
[13:21:37.303]                             info <- base::paste(info, collapse = "; ")
[13:21:37.303]                             if (!has_future) {
[13:21:37.303]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:37.303]                                 info)
[13:21:37.303]                             }
[13:21:37.303]                             else {
[13:21:37.303]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:37.303]                                 info, version)
[13:21:37.303]                             }
[13:21:37.303]                             base::stop(msg)
[13:21:37.303]                           }
[13:21:37.303]                         })
[13:21:37.303]                       }
[13:21:37.303]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:37.303]                       base::options(mc.cores = 1L)
[13:21:37.303]                     }
[13:21:37.303]                     base::local({
[13:21:37.303]                       for (pkg in "future.apply") {
[13:21:37.303]                         base::loadNamespace(pkg)
[13:21:37.303]                         base::library(pkg, character.only = TRUE)
[13:21:37.303]                       }
[13:21:37.303]                     })
[13:21:37.303]                   }
[13:21:37.303]                   options(future.plan = NULL)
[13:21:37.303]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:37.303]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:37.303]                 }
[13:21:37.303]                 ...future.workdir <- getwd()
[13:21:37.303]             }
[13:21:37.303]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:37.303]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:37.303]         }
[13:21:37.303]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:37.303]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:37.303]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:37.303]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:37.303]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:37.303]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:37.303]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:37.303]             base::names(...future.oldOptions))
[13:21:37.303]     }
[13:21:37.303]     if (FALSE) {
[13:21:37.303]     }
[13:21:37.303]     else {
[13:21:37.303]         if (TRUE) {
[13:21:37.303]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:37.303]                 open = "w")
[13:21:37.303]         }
[13:21:37.303]         else {
[13:21:37.303]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:37.303]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:37.303]         }
[13:21:37.303]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:37.303]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:37.303]             base::sink(type = "output", split = FALSE)
[13:21:37.303]             base::close(...future.stdout)
[13:21:37.303]         }, add = TRUE)
[13:21:37.303]     }
[13:21:37.303]     ...future.frame <- base::sys.nframe()
[13:21:37.303]     ...future.conditions <- base::list()
[13:21:37.303]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:37.303]     if (FALSE) {
[13:21:37.303]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:37.303]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:37.303]     }
[13:21:37.303]     ...future.result <- base::tryCatch({
[13:21:37.303]         base::withCallingHandlers({
[13:21:37.303]             ...future.value <- base::withVisible(base::local({
[13:21:37.303]                 ...future.makeSendCondition <- base::local({
[13:21:37.303]                   sendCondition <- NULL
[13:21:37.303]                   function(frame = 1L) {
[13:21:37.303]                     if (is.function(sendCondition)) 
[13:21:37.303]                       return(sendCondition)
[13:21:37.303]                     ns <- getNamespace("parallel")
[13:21:37.303]                     if (exists("sendData", mode = "function", 
[13:21:37.303]                       envir = ns)) {
[13:21:37.303]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:37.303]                         envir = ns)
[13:21:37.303]                       envir <- sys.frame(frame)
[13:21:37.303]                       master <- NULL
[13:21:37.303]                       while (!identical(envir, .GlobalEnv) && 
[13:21:37.303]                         !identical(envir, emptyenv())) {
[13:21:37.303]                         if (exists("master", mode = "list", envir = envir, 
[13:21:37.303]                           inherits = FALSE)) {
[13:21:37.303]                           master <- get("master", mode = "list", 
[13:21:37.303]                             envir = envir, inherits = FALSE)
[13:21:37.303]                           if (inherits(master, c("SOCKnode", 
[13:21:37.303]                             "SOCK0node"))) {
[13:21:37.303]                             sendCondition <<- function(cond) {
[13:21:37.303]                               data <- list(type = "VALUE", value = cond, 
[13:21:37.303]                                 success = TRUE)
[13:21:37.303]                               parallel_sendData(master, data)
[13:21:37.303]                             }
[13:21:37.303]                             return(sendCondition)
[13:21:37.303]                           }
[13:21:37.303]                         }
[13:21:37.303]                         frame <- frame + 1L
[13:21:37.303]                         envir <- sys.frame(frame)
[13:21:37.303]                       }
[13:21:37.303]                     }
[13:21:37.303]                     sendCondition <<- function(cond) NULL
[13:21:37.303]                   }
[13:21:37.303]                 })
[13:21:37.303]                 withCallingHandlers({
[13:21:37.303]                   {
[13:21:37.303]                     do.call(function(...) {
[13:21:37.303]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:37.303]                       if (!identical(...future.globals.maxSize.org, 
[13:21:37.303]                         ...future.globals.maxSize)) {
[13:21:37.303]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:37.303]                         on.exit(options(oopts), add = TRUE)
[13:21:37.303]                       }
[13:21:37.303]                       {
[13:21:37.303]                         lapply(seq_along(...future.elements_ii), 
[13:21:37.303]                           FUN = function(jj) {
[13:21:37.303]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:37.303]                             ...future.FUN(...future.X_jj, ...)
[13:21:37.303]                           })
[13:21:37.303]                       }
[13:21:37.303]                     }, args = future.call.arguments)
[13:21:37.303]                   }
[13:21:37.303]                 }, immediateCondition = function(cond) {
[13:21:37.303]                   sendCondition <- ...future.makeSendCondition()
[13:21:37.303]                   sendCondition(cond)
[13:21:37.303]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:37.303]                   {
[13:21:37.303]                     inherits <- base::inherits
[13:21:37.303]                     invokeRestart <- base::invokeRestart
[13:21:37.303]                     is.null <- base::is.null
[13:21:37.303]                     muffled <- FALSE
[13:21:37.303]                     if (inherits(cond, "message")) {
[13:21:37.303]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:37.303]                       if (muffled) 
[13:21:37.303]                         invokeRestart("muffleMessage")
[13:21:37.303]                     }
[13:21:37.303]                     else if (inherits(cond, "warning")) {
[13:21:37.303]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:37.303]                       if (muffled) 
[13:21:37.303]                         invokeRestart("muffleWarning")
[13:21:37.303]                     }
[13:21:37.303]                     else if (inherits(cond, "condition")) {
[13:21:37.303]                       if (!is.null(pattern)) {
[13:21:37.303]                         computeRestarts <- base::computeRestarts
[13:21:37.303]                         grepl <- base::grepl
[13:21:37.303]                         restarts <- computeRestarts(cond)
[13:21:37.303]                         for (restart in restarts) {
[13:21:37.303]                           name <- restart$name
[13:21:37.303]                           if (is.null(name)) 
[13:21:37.303]                             next
[13:21:37.303]                           if (!grepl(pattern, name)) 
[13:21:37.303]                             next
[13:21:37.303]                           invokeRestart(restart)
[13:21:37.303]                           muffled <- TRUE
[13:21:37.303]                           break
[13:21:37.303]                         }
[13:21:37.303]                       }
[13:21:37.303]                     }
[13:21:37.303]                     invisible(muffled)
[13:21:37.303]                   }
[13:21:37.303]                   muffleCondition(cond)
[13:21:37.303]                 })
[13:21:37.303]             }))
[13:21:37.303]             future::FutureResult(value = ...future.value$value, 
[13:21:37.303]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:37.303]                   ...future.rng), globalenv = if (FALSE) 
[13:21:37.303]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:37.303]                     ...future.globalenv.names))
[13:21:37.303]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:37.303]         }, condition = base::local({
[13:21:37.303]             c <- base::c
[13:21:37.303]             inherits <- base::inherits
[13:21:37.303]             invokeRestart <- base::invokeRestart
[13:21:37.303]             length <- base::length
[13:21:37.303]             list <- base::list
[13:21:37.303]             seq.int <- base::seq.int
[13:21:37.303]             signalCondition <- base::signalCondition
[13:21:37.303]             sys.calls <- base::sys.calls
[13:21:37.303]             `[[` <- base::`[[`
[13:21:37.303]             `+` <- base::`+`
[13:21:37.303]             `<<-` <- base::`<<-`
[13:21:37.303]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:37.303]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:37.303]                   3L)]
[13:21:37.303]             }
[13:21:37.303]             function(cond) {
[13:21:37.303]                 is_error <- inherits(cond, "error")
[13:21:37.303]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:37.303]                   NULL)
[13:21:37.303]                 if (is_error) {
[13:21:37.303]                   sessionInformation <- function() {
[13:21:37.303]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:37.303]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:37.303]                       search = base::search(), system = base::Sys.info())
[13:21:37.303]                   }
[13:21:37.303]                   ...future.conditions[[length(...future.conditions) + 
[13:21:37.303]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:37.303]                     cond$call), session = sessionInformation(), 
[13:21:37.303]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:37.303]                   signalCondition(cond)
[13:21:37.303]                 }
[13:21:37.303]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:37.303]                 "immediateCondition"))) {
[13:21:37.303]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:37.303]                   ...future.conditions[[length(...future.conditions) + 
[13:21:37.303]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:37.303]                   if (TRUE && !signal) {
[13:21:37.303]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:37.303]                     {
[13:21:37.303]                       inherits <- base::inherits
[13:21:37.303]                       invokeRestart <- base::invokeRestart
[13:21:37.303]                       is.null <- base::is.null
[13:21:37.303]                       muffled <- FALSE
[13:21:37.303]                       if (inherits(cond, "message")) {
[13:21:37.303]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:37.303]                         if (muffled) 
[13:21:37.303]                           invokeRestart("muffleMessage")
[13:21:37.303]                       }
[13:21:37.303]                       else if (inherits(cond, "warning")) {
[13:21:37.303]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:37.303]                         if (muffled) 
[13:21:37.303]                           invokeRestart("muffleWarning")
[13:21:37.303]                       }
[13:21:37.303]                       else if (inherits(cond, "condition")) {
[13:21:37.303]                         if (!is.null(pattern)) {
[13:21:37.303]                           computeRestarts <- base::computeRestarts
[13:21:37.303]                           grepl <- base::grepl
[13:21:37.303]                           restarts <- computeRestarts(cond)
[13:21:37.303]                           for (restart in restarts) {
[13:21:37.303]                             name <- restart$name
[13:21:37.303]                             if (is.null(name)) 
[13:21:37.303]                               next
[13:21:37.303]                             if (!grepl(pattern, name)) 
[13:21:37.303]                               next
[13:21:37.303]                             invokeRestart(restart)
[13:21:37.303]                             muffled <- TRUE
[13:21:37.303]                             break
[13:21:37.303]                           }
[13:21:37.303]                         }
[13:21:37.303]                       }
[13:21:37.303]                       invisible(muffled)
[13:21:37.303]                     }
[13:21:37.303]                     muffleCondition(cond, pattern = "^muffle")
[13:21:37.303]                   }
[13:21:37.303]                 }
[13:21:37.303]                 else {
[13:21:37.303]                   if (TRUE) {
[13:21:37.303]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:37.303]                     {
[13:21:37.303]                       inherits <- base::inherits
[13:21:37.303]                       invokeRestart <- base::invokeRestart
[13:21:37.303]                       is.null <- base::is.null
[13:21:37.303]                       muffled <- FALSE
[13:21:37.303]                       if (inherits(cond, "message")) {
[13:21:37.303]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:37.303]                         if (muffled) 
[13:21:37.303]                           invokeRestart("muffleMessage")
[13:21:37.303]                       }
[13:21:37.303]                       else if (inherits(cond, "warning")) {
[13:21:37.303]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:37.303]                         if (muffled) 
[13:21:37.303]                           invokeRestart("muffleWarning")
[13:21:37.303]                       }
[13:21:37.303]                       else if (inherits(cond, "condition")) {
[13:21:37.303]                         if (!is.null(pattern)) {
[13:21:37.303]                           computeRestarts <- base::computeRestarts
[13:21:37.303]                           grepl <- base::grepl
[13:21:37.303]                           restarts <- computeRestarts(cond)
[13:21:37.303]                           for (restart in restarts) {
[13:21:37.303]                             name <- restart$name
[13:21:37.303]                             if (is.null(name)) 
[13:21:37.303]                               next
[13:21:37.303]                             if (!grepl(pattern, name)) 
[13:21:37.303]                               next
[13:21:37.303]                             invokeRestart(restart)
[13:21:37.303]                             muffled <- TRUE
[13:21:37.303]                             break
[13:21:37.303]                           }
[13:21:37.303]                         }
[13:21:37.303]                       }
[13:21:37.303]                       invisible(muffled)
[13:21:37.303]                     }
[13:21:37.303]                     muffleCondition(cond, pattern = "^muffle")
[13:21:37.303]                   }
[13:21:37.303]                 }
[13:21:37.303]             }
[13:21:37.303]         }))
[13:21:37.303]     }, error = function(ex) {
[13:21:37.303]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:37.303]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:37.303]                 ...future.rng), started = ...future.startTime, 
[13:21:37.303]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:37.303]             version = "1.8"), class = "FutureResult")
[13:21:37.303]     }, finally = {
[13:21:37.303]         if (!identical(...future.workdir, getwd())) 
[13:21:37.303]             setwd(...future.workdir)
[13:21:37.303]         {
[13:21:37.303]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:37.303]                 ...future.oldOptions$nwarnings <- NULL
[13:21:37.303]             }
[13:21:37.303]             base::options(...future.oldOptions)
[13:21:37.303]             if (.Platform$OS.type == "windows") {
[13:21:37.303]                 old_names <- names(...future.oldEnvVars)
[13:21:37.303]                 envs <- base::Sys.getenv()
[13:21:37.303]                 names <- names(envs)
[13:21:37.303]                 common <- intersect(names, old_names)
[13:21:37.303]                 added <- setdiff(names, old_names)
[13:21:37.303]                 removed <- setdiff(old_names, names)
[13:21:37.303]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:37.303]                   envs[common]]
[13:21:37.303]                 NAMES <- toupper(changed)
[13:21:37.303]                 args <- list()
[13:21:37.303]                 for (kk in seq_along(NAMES)) {
[13:21:37.303]                   name <- changed[[kk]]
[13:21:37.303]                   NAME <- NAMES[[kk]]
[13:21:37.303]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:37.303]                     next
[13:21:37.303]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:37.303]                 }
[13:21:37.303]                 NAMES <- toupper(added)
[13:21:37.303]                 for (kk in seq_along(NAMES)) {
[13:21:37.303]                   name <- added[[kk]]
[13:21:37.303]                   NAME <- NAMES[[kk]]
[13:21:37.303]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:37.303]                     next
[13:21:37.303]                   args[[name]] <- ""
[13:21:37.303]                 }
[13:21:37.303]                 NAMES <- toupper(removed)
[13:21:37.303]                 for (kk in seq_along(NAMES)) {
[13:21:37.303]                   name <- removed[[kk]]
[13:21:37.303]                   NAME <- NAMES[[kk]]
[13:21:37.303]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:37.303]                     next
[13:21:37.303]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:37.303]                 }
[13:21:37.303]                 if (length(args) > 0) 
[13:21:37.303]                   base::do.call(base::Sys.setenv, args = args)
[13:21:37.303]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:37.303]             }
[13:21:37.303]             else {
[13:21:37.303]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:37.303]             }
[13:21:37.303]             {
[13:21:37.303]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:37.303]                   0L) {
[13:21:37.303]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:37.303]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:37.303]                   base::options(opts)
[13:21:37.303]                 }
[13:21:37.303]                 {
[13:21:37.303]                   {
[13:21:37.303]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:37.303]                     NULL
[13:21:37.303]                   }
[13:21:37.303]                   options(future.plan = NULL)
[13:21:37.303]                   if (is.na(NA_character_)) 
[13:21:37.303]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:37.303]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:37.303]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:37.303]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:37.303]                     envir = parent.frame()) 
[13:21:37.303]                   {
[13:21:37.303]                     if (is.function(workers)) 
[13:21:37.303]                       workers <- workers()
[13:21:37.303]                     workers <- structure(as.integer(workers), 
[13:21:37.303]                       class = class(workers))
[13:21:37.303]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:37.303]                       workers >= 1)
[13:21:37.303]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:37.303]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:37.303]                     }
[13:21:37.303]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:37.303]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:37.303]                       envir = envir)
[13:21:37.303]                     if (!future$lazy) 
[13:21:37.303]                       future <- run(future)
[13:21:37.303]                     invisible(future)
[13:21:37.303]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:37.303]                 }
[13:21:37.303]             }
[13:21:37.303]         }
[13:21:37.303]     })
[13:21:37.303]     if (TRUE) {
[13:21:37.303]         base::sink(type = "output", split = FALSE)
[13:21:37.303]         if (TRUE) {
[13:21:37.303]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:37.303]         }
[13:21:37.303]         else {
[13:21:37.303]             ...future.result["stdout"] <- base::list(NULL)
[13:21:37.303]         }
[13:21:37.303]         base::close(...future.stdout)
[13:21:37.303]         ...future.stdout <- NULL
[13:21:37.303]     }
[13:21:37.303]     ...future.result$conditions <- ...future.conditions
[13:21:37.303]     ...future.result$finished <- base::Sys.time()
[13:21:37.303]     ...future.result
[13:21:37.303] }
[13:21:37.306] Exporting 11 global objects (93.16 KiB) to cluster node #1 ...
[13:21:37.306] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:21:37.352] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:21:37.353] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ...
[13:21:37.353] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ... DONE
[13:21:37.353] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:21:37.354] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:21:37.354] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:21:37.396] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:21:37.397] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:21:37.440] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:21:37.440] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[13:21:37.441] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[13:21:37.441] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[13:21:37.441] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[13:21:37.442] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:21:37.442] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:21:37.442] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[13:21:37.443] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[13:21:37.443] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:21:37.443] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:21:37.443] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:21:37.444] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:21:37.444] Exporting 11 global objects (93.16 KiB) to cluster node #1 ... DONE
[13:21:37.445] MultisessionFuture started
[13:21:37.445] - Launch lazy future ... done
[13:21:37.445] run() for ‘MultisessionFuture’ ... done
[13:21:37.445] Created future:
[13:21:37.445] MultisessionFuture:
[13:21:37.445] Label: ‘future_vapply-1’
[13:21:37.445] Expression:
[13:21:37.445] {
[13:21:37.445]     do.call(function(...) {
[13:21:37.445]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:37.445]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:37.445]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:37.445]             on.exit(options(oopts), add = TRUE)
[13:21:37.445]         }
[13:21:37.445]         {
[13:21:37.445]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:37.445]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:37.445]                 ...future.FUN(...future.X_jj, ...)
[13:21:37.445]             })
[13:21:37.445]         }
[13:21:37.445]     }, args = future.call.arguments)
[13:21:37.445] }
[13:21:37.445] Lazy evaluation: FALSE
[13:21:37.445] Asynchronous evaluation: TRUE
[13:21:37.445] Local evaluation: TRUE
[13:21:37.445] Environment: R_GlobalEnv
[13:21:37.445] Capture standard output: TRUE
[13:21:37.445] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:37.445] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:37.445] Packages: 1 packages (‘future.apply’)
[13:21:37.445] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:37.445] Resolved: FALSE
[13:21:37.445] Value: <not collected>
[13:21:37.445] Conditions captured: <none>
[13:21:37.445] Early signaling: FALSE
[13:21:37.445] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:37.445] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:37.457] Chunk #1 of 2 ... DONE
[13:21:37.457] Chunk #2 of 2 ...
[13:21:37.457]  - Finding globals in 'X' for chunk #2 ...
[13:21:37.457] getGlobalsAndPackages() ...
[13:21:37.457] Searching for globals...
[13:21:37.458] 
[13:21:37.458] Searching for globals ... DONE
[13:21:37.458] - globals: [0] <none>
[13:21:37.458] getGlobalsAndPackages() ... DONE
[13:21:37.458]    + additional globals found: [n=0] 
[13:21:37.458]    + additional namespaces needed: [n=0] 
[13:21:37.458]  - Finding globals in 'X' for chunk #2 ... DONE
[13:21:37.458]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:37.458]  - seeds: <none>
[13:21:37.459]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:37.459] getGlobalsAndPackages() ...
[13:21:37.459] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:37.459] Resolving globals: FALSE
[13:21:37.459] Tweak future expression to call with '...' arguments ...
[13:21:37.459] {
[13:21:37.459]     do.call(function(...) {
[13:21:37.459]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:37.459]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:37.459]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:37.459]             on.exit(options(oopts), add = TRUE)
[13:21:37.459]         }
[13:21:37.459]         {
[13:21:37.459]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:37.459]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:37.459]                 ...future.FUN(...future.X_jj, ...)
[13:21:37.459]             })
[13:21:37.459]         }
[13:21:37.459]     }, args = future.call.arguments)
[13:21:37.459] }
[13:21:37.459] Tweak future expression to call with '...' arguments ... DONE
[13:21:37.460] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:37.460] - packages: [1] ‘future.apply’
[13:21:37.460] getGlobalsAndPackages() ... DONE
[13:21:37.461] run() for ‘Future’ ...
[13:21:37.461] - state: ‘created’
[13:21:37.461] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:37.475] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:37.475] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:37.476]   - Field: ‘node’
[13:21:37.476]   - Field: ‘label’
[13:21:37.476]   - Field: ‘local’
[13:21:37.476]   - Field: ‘owner’
[13:21:37.476]   - Field: ‘envir’
[13:21:37.476]   - Field: ‘workers’
[13:21:37.476]   - Field: ‘packages’
[13:21:37.476]   - Field: ‘gc’
[13:21:37.476]   - Field: ‘conditions’
[13:21:37.477]   - Field: ‘persistent’
[13:21:37.477]   - Field: ‘expr’
[13:21:37.477]   - Field: ‘uuid’
[13:21:37.477]   - Field: ‘seed’
[13:21:37.477]   - Field: ‘version’
[13:21:37.477]   - Field: ‘result’
[13:21:37.477]   - Field: ‘asynchronous’
[13:21:37.477]   - Field: ‘calls’
[13:21:37.477]   - Field: ‘globals’
[13:21:37.477]   - Field: ‘stdout’
[13:21:37.477]   - Field: ‘earlySignal’
[13:21:37.478]   - Field: ‘lazy’
[13:21:37.478]   - Field: ‘state’
[13:21:37.478] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:37.478] - Launch lazy future ...
[13:21:37.478] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:37.478] Packages needed by future strategies (n = 0): <none>
[13:21:37.479] {
[13:21:37.479]     {
[13:21:37.479]         {
[13:21:37.479]             ...future.startTime <- base::Sys.time()
[13:21:37.479]             {
[13:21:37.479]                 {
[13:21:37.479]                   {
[13:21:37.479]                     {
[13:21:37.479]                       {
[13:21:37.479]                         base::local({
[13:21:37.479]                           has_future <- base::requireNamespace("future", 
[13:21:37.479]                             quietly = TRUE)
[13:21:37.479]                           if (has_future) {
[13:21:37.479]                             ns <- base::getNamespace("future")
[13:21:37.479]                             version <- ns[[".package"]][["version"]]
[13:21:37.479]                             if (is.null(version)) 
[13:21:37.479]                               version <- utils::packageVersion("future")
[13:21:37.479]                           }
[13:21:37.479]                           else {
[13:21:37.479]                             version <- NULL
[13:21:37.479]                           }
[13:21:37.479]                           if (!has_future || version < "1.8.0") {
[13:21:37.479]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:37.479]                               "", base::R.version$version.string), 
[13:21:37.479]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:37.479]                                 base::R.version$platform, 8 * 
[13:21:37.479]                                   base::.Machine$sizeof.pointer), 
[13:21:37.479]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:37.479]                                 "release", "version")], collapse = " "), 
[13:21:37.479]                               hostname = base::Sys.info()[["nodename"]])
[13:21:37.479]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:37.479]                               info)
[13:21:37.479]                             info <- base::paste(info, collapse = "; ")
[13:21:37.479]                             if (!has_future) {
[13:21:37.479]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:37.479]                                 info)
[13:21:37.479]                             }
[13:21:37.479]                             else {
[13:21:37.479]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:37.479]                                 info, version)
[13:21:37.479]                             }
[13:21:37.479]                             base::stop(msg)
[13:21:37.479]                           }
[13:21:37.479]                         })
[13:21:37.479]                       }
[13:21:37.479]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:37.479]                       base::options(mc.cores = 1L)
[13:21:37.479]                     }
[13:21:37.479]                     base::local({
[13:21:37.479]                       for (pkg in "future.apply") {
[13:21:37.479]                         base::loadNamespace(pkg)
[13:21:37.479]                         base::library(pkg, character.only = TRUE)
[13:21:37.479]                       }
[13:21:37.479]                     })
[13:21:37.479]                   }
[13:21:37.479]                   options(future.plan = NULL)
[13:21:37.479]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:37.479]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:37.479]                 }
[13:21:37.479]                 ...future.workdir <- getwd()
[13:21:37.479]             }
[13:21:37.479]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:37.479]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:37.479]         }
[13:21:37.479]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:37.479]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:37.479]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:37.479]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:37.479]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:37.479]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:37.479]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:37.479]             base::names(...future.oldOptions))
[13:21:37.479]     }
[13:21:37.479]     if (FALSE) {
[13:21:37.479]     }
[13:21:37.479]     else {
[13:21:37.479]         if (TRUE) {
[13:21:37.479]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:37.479]                 open = "w")
[13:21:37.479]         }
[13:21:37.479]         else {
[13:21:37.479]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:37.479]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:37.479]         }
[13:21:37.479]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:37.479]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:37.479]             base::sink(type = "output", split = FALSE)
[13:21:37.479]             base::close(...future.stdout)
[13:21:37.479]         }, add = TRUE)
[13:21:37.479]     }
[13:21:37.479]     ...future.frame <- base::sys.nframe()
[13:21:37.479]     ...future.conditions <- base::list()
[13:21:37.479]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:37.479]     if (FALSE) {
[13:21:37.479]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:37.479]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:37.479]     }
[13:21:37.479]     ...future.result <- base::tryCatch({
[13:21:37.479]         base::withCallingHandlers({
[13:21:37.479]             ...future.value <- base::withVisible(base::local({
[13:21:37.479]                 ...future.makeSendCondition <- base::local({
[13:21:37.479]                   sendCondition <- NULL
[13:21:37.479]                   function(frame = 1L) {
[13:21:37.479]                     if (is.function(sendCondition)) 
[13:21:37.479]                       return(sendCondition)
[13:21:37.479]                     ns <- getNamespace("parallel")
[13:21:37.479]                     if (exists("sendData", mode = "function", 
[13:21:37.479]                       envir = ns)) {
[13:21:37.479]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:37.479]                         envir = ns)
[13:21:37.479]                       envir <- sys.frame(frame)
[13:21:37.479]                       master <- NULL
[13:21:37.479]                       while (!identical(envir, .GlobalEnv) && 
[13:21:37.479]                         !identical(envir, emptyenv())) {
[13:21:37.479]                         if (exists("master", mode = "list", envir = envir, 
[13:21:37.479]                           inherits = FALSE)) {
[13:21:37.479]                           master <- get("master", mode = "list", 
[13:21:37.479]                             envir = envir, inherits = FALSE)
[13:21:37.479]                           if (inherits(master, c("SOCKnode", 
[13:21:37.479]                             "SOCK0node"))) {
[13:21:37.479]                             sendCondition <<- function(cond) {
[13:21:37.479]                               data <- list(type = "VALUE", value = cond, 
[13:21:37.479]                                 success = TRUE)
[13:21:37.479]                               parallel_sendData(master, data)
[13:21:37.479]                             }
[13:21:37.479]                             return(sendCondition)
[13:21:37.479]                           }
[13:21:37.479]                         }
[13:21:37.479]                         frame <- frame + 1L
[13:21:37.479]                         envir <- sys.frame(frame)
[13:21:37.479]                       }
[13:21:37.479]                     }
[13:21:37.479]                     sendCondition <<- function(cond) NULL
[13:21:37.479]                   }
[13:21:37.479]                 })
[13:21:37.479]                 withCallingHandlers({
[13:21:37.479]                   {
[13:21:37.479]                     do.call(function(...) {
[13:21:37.479]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:37.479]                       if (!identical(...future.globals.maxSize.org, 
[13:21:37.479]                         ...future.globals.maxSize)) {
[13:21:37.479]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:37.479]                         on.exit(options(oopts), add = TRUE)
[13:21:37.479]                       }
[13:21:37.479]                       {
[13:21:37.479]                         lapply(seq_along(...future.elements_ii), 
[13:21:37.479]                           FUN = function(jj) {
[13:21:37.479]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:37.479]                             ...future.FUN(...future.X_jj, ...)
[13:21:37.479]                           })
[13:21:37.479]                       }
[13:21:37.479]                     }, args = future.call.arguments)
[13:21:37.479]                   }
[13:21:37.479]                 }, immediateCondition = function(cond) {
[13:21:37.479]                   sendCondition <- ...future.makeSendCondition()
[13:21:37.479]                   sendCondition(cond)
[13:21:37.479]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:37.479]                   {
[13:21:37.479]                     inherits <- base::inherits
[13:21:37.479]                     invokeRestart <- base::invokeRestart
[13:21:37.479]                     is.null <- base::is.null
[13:21:37.479]                     muffled <- FALSE
[13:21:37.479]                     if (inherits(cond, "message")) {
[13:21:37.479]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:37.479]                       if (muffled) 
[13:21:37.479]                         invokeRestart("muffleMessage")
[13:21:37.479]                     }
[13:21:37.479]                     else if (inherits(cond, "warning")) {
[13:21:37.479]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:37.479]                       if (muffled) 
[13:21:37.479]                         invokeRestart("muffleWarning")
[13:21:37.479]                     }
[13:21:37.479]                     else if (inherits(cond, "condition")) {
[13:21:37.479]                       if (!is.null(pattern)) {
[13:21:37.479]                         computeRestarts <- base::computeRestarts
[13:21:37.479]                         grepl <- base::grepl
[13:21:37.479]                         restarts <- computeRestarts(cond)
[13:21:37.479]                         for (restart in restarts) {
[13:21:37.479]                           name <- restart$name
[13:21:37.479]                           if (is.null(name)) 
[13:21:37.479]                             next
[13:21:37.479]                           if (!grepl(pattern, name)) 
[13:21:37.479]                             next
[13:21:37.479]                           invokeRestart(restart)
[13:21:37.479]                           muffled <- TRUE
[13:21:37.479]                           break
[13:21:37.479]                         }
[13:21:37.479]                       }
[13:21:37.479]                     }
[13:21:37.479]                     invisible(muffled)
[13:21:37.479]                   }
[13:21:37.479]                   muffleCondition(cond)
[13:21:37.479]                 })
[13:21:37.479]             }))
[13:21:37.479]             future::FutureResult(value = ...future.value$value, 
[13:21:37.479]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:37.479]                   ...future.rng), globalenv = if (FALSE) 
[13:21:37.479]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:37.479]                     ...future.globalenv.names))
[13:21:37.479]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:37.479]         }, condition = base::local({
[13:21:37.479]             c <- base::c
[13:21:37.479]             inherits <- base::inherits
[13:21:37.479]             invokeRestart <- base::invokeRestart
[13:21:37.479]             length <- base::length
[13:21:37.479]             list <- base::list
[13:21:37.479]             seq.int <- base::seq.int
[13:21:37.479]             signalCondition <- base::signalCondition
[13:21:37.479]             sys.calls <- base::sys.calls
[13:21:37.479]             `[[` <- base::`[[`
[13:21:37.479]             `+` <- base::`+`
[13:21:37.479]             `<<-` <- base::`<<-`
[13:21:37.479]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:37.479]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:37.479]                   3L)]
[13:21:37.479]             }
[13:21:37.479]             function(cond) {
[13:21:37.479]                 is_error <- inherits(cond, "error")
[13:21:37.479]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:37.479]                   NULL)
[13:21:37.479]                 if (is_error) {
[13:21:37.479]                   sessionInformation <- function() {
[13:21:37.479]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:37.479]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:37.479]                       search = base::search(), system = base::Sys.info())
[13:21:37.479]                   }
[13:21:37.479]                   ...future.conditions[[length(...future.conditions) + 
[13:21:37.479]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:37.479]                     cond$call), session = sessionInformation(), 
[13:21:37.479]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:37.479]                   signalCondition(cond)
[13:21:37.479]                 }
[13:21:37.479]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:37.479]                 "immediateCondition"))) {
[13:21:37.479]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:37.479]                   ...future.conditions[[length(...future.conditions) + 
[13:21:37.479]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:37.479]                   if (TRUE && !signal) {
[13:21:37.479]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:37.479]                     {
[13:21:37.479]                       inherits <- base::inherits
[13:21:37.479]                       invokeRestart <- base::invokeRestart
[13:21:37.479]                       is.null <- base::is.null
[13:21:37.479]                       muffled <- FALSE
[13:21:37.479]                       if (inherits(cond, "message")) {
[13:21:37.479]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:37.479]                         if (muffled) 
[13:21:37.479]                           invokeRestart("muffleMessage")
[13:21:37.479]                       }
[13:21:37.479]                       else if (inherits(cond, "warning")) {
[13:21:37.479]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:37.479]                         if (muffled) 
[13:21:37.479]                           invokeRestart("muffleWarning")
[13:21:37.479]                       }
[13:21:37.479]                       else if (inherits(cond, "condition")) {
[13:21:37.479]                         if (!is.null(pattern)) {
[13:21:37.479]                           computeRestarts <- base::computeRestarts
[13:21:37.479]                           grepl <- base::grepl
[13:21:37.479]                           restarts <- computeRestarts(cond)
[13:21:37.479]                           for (restart in restarts) {
[13:21:37.479]                             name <- restart$name
[13:21:37.479]                             if (is.null(name)) 
[13:21:37.479]                               next
[13:21:37.479]                             if (!grepl(pattern, name)) 
[13:21:37.479]                               next
[13:21:37.479]                             invokeRestart(restart)
[13:21:37.479]                             muffled <- TRUE
[13:21:37.479]                             break
[13:21:37.479]                           }
[13:21:37.479]                         }
[13:21:37.479]                       }
[13:21:37.479]                       invisible(muffled)
[13:21:37.479]                     }
[13:21:37.479]                     muffleCondition(cond, pattern = "^muffle")
[13:21:37.479]                   }
[13:21:37.479]                 }
[13:21:37.479]                 else {
[13:21:37.479]                   if (TRUE) {
[13:21:37.479]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:37.479]                     {
[13:21:37.479]                       inherits <- base::inherits
[13:21:37.479]                       invokeRestart <- base::invokeRestart
[13:21:37.479]                       is.null <- base::is.null
[13:21:37.479]                       muffled <- FALSE
[13:21:37.479]                       if (inherits(cond, "message")) {
[13:21:37.479]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:37.479]                         if (muffled) 
[13:21:37.479]                           invokeRestart("muffleMessage")
[13:21:37.479]                       }
[13:21:37.479]                       else if (inherits(cond, "warning")) {
[13:21:37.479]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:37.479]                         if (muffled) 
[13:21:37.479]                           invokeRestart("muffleWarning")
[13:21:37.479]                       }
[13:21:37.479]                       else if (inherits(cond, "condition")) {
[13:21:37.479]                         if (!is.null(pattern)) {
[13:21:37.479]                           computeRestarts <- base::computeRestarts
[13:21:37.479]                           grepl <- base::grepl
[13:21:37.479]                           restarts <- computeRestarts(cond)
[13:21:37.479]                           for (restart in restarts) {
[13:21:37.479]                             name <- restart$name
[13:21:37.479]                             if (is.null(name)) 
[13:21:37.479]                               next
[13:21:37.479]                             if (!grepl(pattern, name)) 
[13:21:37.479]                               next
[13:21:37.479]                             invokeRestart(restart)
[13:21:37.479]                             muffled <- TRUE
[13:21:37.479]                             break
[13:21:37.479]                           }
[13:21:37.479]                         }
[13:21:37.479]                       }
[13:21:37.479]                       invisible(muffled)
[13:21:37.479]                     }
[13:21:37.479]                     muffleCondition(cond, pattern = "^muffle")
[13:21:37.479]                   }
[13:21:37.479]                 }
[13:21:37.479]             }
[13:21:37.479]         }))
[13:21:37.479]     }, error = function(ex) {
[13:21:37.479]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:37.479]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:37.479]                 ...future.rng), started = ...future.startTime, 
[13:21:37.479]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:37.479]             version = "1.8"), class = "FutureResult")
[13:21:37.479]     }, finally = {
[13:21:37.479]         if (!identical(...future.workdir, getwd())) 
[13:21:37.479]             setwd(...future.workdir)
[13:21:37.479]         {
[13:21:37.479]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:37.479]                 ...future.oldOptions$nwarnings <- NULL
[13:21:37.479]             }
[13:21:37.479]             base::options(...future.oldOptions)
[13:21:37.479]             if (.Platform$OS.type == "windows") {
[13:21:37.479]                 old_names <- names(...future.oldEnvVars)
[13:21:37.479]                 envs <- base::Sys.getenv()
[13:21:37.479]                 names <- names(envs)
[13:21:37.479]                 common <- intersect(names, old_names)
[13:21:37.479]                 added <- setdiff(names, old_names)
[13:21:37.479]                 removed <- setdiff(old_names, names)
[13:21:37.479]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:37.479]                   envs[common]]
[13:21:37.479]                 NAMES <- toupper(changed)
[13:21:37.479]                 args <- list()
[13:21:37.479]                 for (kk in seq_along(NAMES)) {
[13:21:37.479]                   name <- changed[[kk]]
[13:21:37.479]                   NAME <- NAMES[[kk]]
[13:21:37.479]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:37.479]                     next
[13:21:37.479]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:37.479]                 }
[13:21:37.479]                 NAMES <- toupper(added)
[13:21:37.479]                 for (kk in seq_along(NAMES)) {
[13:21:37.479]                   name <- added[[kk]]
[13:21:37.479]                   NAME <- NAMES[[kk]]
[13:21:37.479]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:37.479]                     next
[13:21:37.479]                   args[[name]] <- ""
[13:21:37.479]                 }
[13:21:37.479]                 NAMES <- toupper(removed)
[13:21:37.479]                 for (kk in seq_along(NAMES)) {
[13:21:37.479]                   name <- removed[[kk]]
[13:21:37.479]                   NAME <- NAMES[[kk]]
[13:21:37.479]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:37.479]                     next
[13:21:37.479]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:37.479]                 }
[13:21:37.479]                 if (length(args) > 0) 
[13:21:37.479]                   base::do.call(base::Sys.setenv, args = args)
[13:21:37.479]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:37.479]             }
[13:21:37.479]             else {
[13:21:37.479]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:37.479]             }
[13:21:37.479]             {
[13:21:37.479]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:37.479]                   0L) {
[13:21:37.479]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:37.479]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:37.479]                   base::options(opts)
[13:21:37.479]                 }
[13:21:37.479]                 {
[13:21:37.479]                   {
[13:21:37.479]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:37.479]                     NULL
[13:21:37.479]                   }
[13:21:37.479]                   options(future.plan = NULL)
[13:21:37.479]                   if (is.na(NA_character_)) 
[13:21:37.479]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:37.479]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:37.479]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:37.479]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:37.479]                     envir = parent.frame()) 
[13:21:37.479]                   {
[13:21:37.479]                     if (is.function(workers)) 
[13:21:37.479]                       workers <- workers()
[13:21:37.479]                     workers <- structure(as.integer(workers), 
[13:21:37.479]                       class = class(workers))
[13:21:37.479]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:37.479]                       workers >= 1)
[13:21:37.479]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:37.479]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:37.479]                     }
[13:21:37.479]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:37.479]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:37.479]                       envir = envir)
[13:21:37.479]                     if (!future$lazy) 
[13:21:37.479]                       future <- run(future)
[13:21:37.479]                     invisible(future)
[13:21:37.479]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:37.479]                 }
[13:21:37.479]             }
[13:21:37.479]         }
[13:21:37.479]     })
[13:21:37.479]     if (TRUE) {
[13:21:37.479]         base::sink(type = "output", split = FALSE)
[13:21:37.479]         if (TRUE) {
[13:21:37.479]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:37.479]         }
[13:21:37.479]         else {
[13:21:37.479]             ...future.result["stdout"] <- base::list(NULL)
[13:21:37.479]         }
[13:21:37.479]         base::close(...future.stdout)
[13:21:37.479]         ...future.stdout <- NULL
[13:21:37.479]     }
[13:21:37.479]     ...future.result$conditions <- ...future.conditions
[13:21:37.479]     ...future.result$finished <- base::Sys.time()
[13:21:37.479]     ...future.result
[13:21:37.479] }
[13:21:37.482] Exporting 11 global objects (93.16 KiB) to cluster node #2 ...
[13:21:37.482] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[13:21:37.524] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[13:21:37.525] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ...
[13:21:37.525] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ... DONE
[13:21:37.525] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[13:21:37.526] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[13:21:37.526] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[13:21:37.568] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[13:21:37.569] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[13:21:37.612] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[13:21:37.613] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[13:21:37.613] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[13:21:37.613] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ...
[13:21:37.614] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ... DONE
[13:21:37.614] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:21:37.614] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:21:37.614] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[13:21:37.615] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[13:21:37.615] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:21:37.615] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:21:37.615] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:21:37.616] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:21:37.616] Exporting 11 global objects (93.16 KiB) to cluster node #2 ... DONE
[13:21:37.617] MultisessionFuture started
[13:21:37.617] - Launch lazy future ... done
[13:21:37.617] run() for ‘MultisessionFuture’ ... done
[13:21:37.617] Created future:
[13:21:37.617] MultisessionFuture:
[13:21:37.617] Label: ‘future_vapply-2’
[13:21:37.617] Expression:
[13:21:37.617] {
[13:21:37.617]     do.call(function(...) {
[13:21:37.617]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:37.617]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:37.617]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:37.617]             on.exit(options(oopts), add = TRUE)
[13:21:37.617]         }
[13:21:37.617]         {
[13:21:37.617]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:37.617]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:37.617]                 ...future.FUN(...future.X_jj, ...)
[13:21:37.617]             })
[13:21:37.617]         }
[13:21:37.617]     }, args = future.call.arguments)
[13:21:37.617] }
[13:21:37.617] Lazy evaluation: FALSE
[13:21:37.617] Asynchronous evaluation: TRUE
[13:21:37.617] Local evaluation: TRUE
[13:21:37.617] Environment: R_GlobalEnv
[13:21:37.617] Capture standard output: TRUE
[13:21:37.617] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:37.617] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:37.617] Packages: 1 packages (‘future.apply’)
[13:21:37.617] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:37.617] Resolved: FALSE
[13:21:37.617] Value: <not collected>
[13:21:37.617] Conditions captured: <none>
[13:21:37.617] Early signaling: FALSE
[13:21:37.617] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:37.617] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:37.629] Chunk #2 of 2 ... DONE
[13:21:37.629] Launching 2 futures (chunks) ... DONE
[13:21:37.629] Resolving 2 futures (chunks) ...
[13:21:37.629] resolve() on list ...
[13:21:37.629]  recursive: 0
[13:21:37.629]  length: 2
[13:21:37.630] 
[13:21:37.630] receiveMessageFromWorker() for ClusterFuture ...
[13:21:37.630] - Validating connection of MultisessionFuture
[13:21:37.630] - received message: FutureResult
[13:21:37.630] - Received FutureResult
[13:21:37.631] - Erased future from FutureRegistry
[13:21:37.631] result() for ClusterFuture ...
[13:21:37.631] - result already collected: FutureResult
[13:21:37.631] result() for ClusterFuture ... done
[13:21:37.631] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:37.631] Future #1
[13:21:37.631] result() for ClusterFuture ...
[13:21:37.631] - result already collected: FutureResult
[13:21:37.631] result() for ClusterFuture ... done
[13:21:37.631] result() for ClusterFuture ...
[13:21:37.631] - result already collected: FutureResult
[13:21:37.632] result() for ClusterFuture ... done
[13:21:37.632] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:21:37.632] - nx: 2
[13:21:37.632] - relay: TRUE
[13:21:37.632] - stdout: TRUE
[13:21:37.632] - signal: TRUE
[13:21:37.632] - resignal: FALSE
[13:21:37.632] - force: TRUE
[13:21:37.632] - relayed: [n=2] FALSE, FALSE
[13:21:37.632] - queued futures: [n=2] FALSE, FALSE
[13:21:37.633]  - until=1
[13:21:37.633]  - relaying element #1
[13:21:37.633] result() for ClusterFuture ...
[13:21:37.633] - result already collected: FutureResult
[13:21:37.633] result() for ClusterFuture ... done
[13:21:37.633] result() for ClusterFuture ...
[13:21:37.633] - result already collected: FutureResult
[13:21:37.633] result() for ClusterFuture ... done
[13:21:37.633] result() for ClusterFuture ...
[13:21:37.633] - result already collected: FutureResult
[13:21:37.633] result() for ClusterFuture ... done
[13:21:37.634] result() for ClusterFuture ...
[13:21:37.634] - result already collected: FutureResult
[13:21:37.634] result() for ClusterFuture ... done
[13:21:37.634] - relayed: [n=2] TRUE, FALSE
[13:21:37.634] - queued futures: [n=2] TRUE, FALSE
[13:21:37.634] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:21:37.634]  length: 1 (resolved future 1)
[13:21:37.665] receiveMessageFromWorker() for ClusterFuture ...
[13:21:37.665] - Validating connection of MultisessionFuture
[13:21:37.666] - received message: FutureResult
[13:21:37.666] - Received FutureResult
[13:21:37.666] - Erased future from FutureRegistry
[13:21:37.666] result() for ClusterFuture ...
[13:21:37.666] - result already collected: FutureResult
[13:21:37.666] result() for ClusterFuture ... done
[13:21:37.666] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:37.666] Future #2
[13:21:37.667] result() for ClusterFuture ...
[13:21:37.667] - result already collected: FutureResult
[13:21:37.667] result() for ClusterFuture ... done
[13:21:37.667] result() for ClusterFuture ...
[13:21:37.667] - result already collected: FutureResult
[13:21:37.667] result() for ClusterFuture ... done
[13:21:37.667] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:21:37.667] - nx: 2
[13:21:37.667] - relay: TRUE
[13:21:37.667] - stdout: TRUE
[13:21:37.667] - signal: TRUE
[13:21:37.668] - resignal: FALSE
[13:21:37.668] - force: TRUE
[13:21:37.668] - relayed: [n=2] TRUE, FALSE
[13:21:37.668] - queued futures: [n=2] TRUE, FALSE
[13:21:37.668]  - until=2
[13:21:37.668]  - relaying element #2
[13:21:37.668] result() for ClusterFuture ...
[13:21:37.668] - result already collected: FutureResult
[13:21:37.668] result() for ClusterFuture ... done
[13:21:37.668] result() for ClusterFuture ...
[13:21:37.668] - result already collected: FutureResult
[13:21:37.669] result() for ClusterFuture ... done
[13:21:37.669] result() for ClusterFuture ...
[13:21:37.669] - result already collected: FutureResult
[13:21:37.669] result() for ClusterFuture ... done
[13:21:37.669] result() for ClusterFuture ...
[13:21:37.669] - result already collected: FutureResult
[13:21:37.669] result() for ClusterFuture ... done
[13:21:37.669] - relayed: [n=2] TRUE, TRUE
[13:21:37.669] - queued futures: [n=2] TRUE, TRUE
[13:21:37.669] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:21:37.669]  length: 0 (resolved future 2)
[13:21:37.670] Relaying remaining futures
[13:21:37.670] signalConditionsASAP(NULL, pos=0) ...
[13:21:37.670] - nx: 2
[13:21:37.670] - relay: TRUE
[13:21:37.670] - stdout: TRUE
[13:21:37.670] - signal: TRUE
[13:21:37.670] - resignal: FALSE
[13:21:37.670] - force: TRUE
[13:21:37.670] - relayed: [n=2] TRUE, TRUE
[13:21:37.670] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:21:37.670] - relayed: [n=2] TRUE, TRUE
[13:21:37.671] - queued futures: [n=2] TRUE, TRUE
[13:21:37.671] signalConditionsASAP(NULL, pos=0) ... done
[13:21:37.671] resolve() on list ... DONE
[13:21:37.671] result() for ClusterFuture ...
[13:21:37.671] - result already collected: FutureResult
[13:21:37.671] result() for ClusterFuture ... done
[13:21:37.671] result() for ClusterFuture ...
[13:21:37.671] - result already collected: FutureResult
[13:21:37.671] result() for ClusterFuture ... done
[13:21:37.671] result() for ClusterFuture ...
[13:21:37.671] - result already collected: FutureResult
[13:21:37.671] result() for ClusterFuture ... done
[13:21:37.672] result() for ClusterFuture ...
[13:21:37.672] - result already collected: FutureResult
[13:21:37.672] result() for ClusterFuture ... done
[13:21:37.672]  - Number of value chunks collected: 2
[13:21:37.672] Resolving 2 futures (chunks) ... DONE
[13:21:37.672] Reducing values from 2 chunks ...
[13:21:37.672]  - Number of values collected after concatenation: 10
[13:21:37.672]  - Number of values expected: 10
[13:21:37.672] Reducing values from 2 chunks ... DONE
[13:21:37.672] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[13:21:37.673] future_lapply() ...
[13:21:37.679] Number of chunks: 2
[13:21:37.679] getGlobalsAndPackagesXApply() ...
[13:21:37.679]  - future.globals: TRUE
[13:21:37.679] getGlobalsAndPackages() ...
[13:21:37.679] Searching for globals...
[13:21:37.682] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:21:37.683] Searching for globals ... DONE
[13:21:37.683] Resolving globals: FALSE
[13:21:37.684] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[13:21:37.684] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:37.684] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:37.684] - packages: [1] ‘future.apply’
[13:21:37.684] getGlobalsAndPackages() ... DONE
[13:21:37.684]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:37.685]  - needed namespaces: [n=1] ‘future.apply’
[13:21:37.685] Finding globals ... DONE
[13:21:37.685]  - use_args: TRUE
[13:21:37.685]  - Getting '...' globals ...
[13:21:37.685] resolve() on list ...
[13:21:37.685]  recursive: 0
[13:21:37.685]  length: 1
[13:21:37.685]  elements: ‘...’
[13:21:37.686]  length: 0 (resolved future 1)
[13:21:37.686] resolve() on list ... DONE
[13:21:37.686]    - '...' content: [n=0] 
[13:21:37.686] List of 1
[13:21:37.686]  $ ...: list()
[13:21:37.686]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:37.686]  - attr(*, "where")=List of 1
[13:21:37.686]   ..$ ...:<environment: 0x563b70c66ce0> 
[13:21:37.686]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:37.686]  - attr(*, "resolved")= logi TRUE
[13:21:37.686]  - attr(*, "total_size")= num NA
[13:21:37.688]  - Getting '...' globals ... DONE
[13:21:37.689] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:37.689] List of 8
[13:21:37.689]  $ ...future.FUN:function (x, ...)  
[13:21:37.689]  $ x_FUN        :function (x)  
[13:21:37.689]  $ times        : int 1
[13:21:37.689]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:37.689]  $ stop_if_not  :function (...)  
[13:21:37.689]  $ dim          : NULL
[13:21:37.689]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:21:37.689]  $ ...          : list()
[13:21:37.689]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:37.689]  - attr(*, "where")=List of 8
[13:21:37.689]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:37.689]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:37.689]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:37.689]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:37.689]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:37.689]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:37.689]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:37.689]   ..$ ...          :<environment: 0x563b70c66ce0> 
[13:21:37.689]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:37.689]  - attr(*, "resolved")= logi FALSE
[13:21:37.689]  - attr(*, "total_size")= num 94336
[13:21:37.696] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:21:37.696] getGlobalsAndPackagesXApply() ... DONE
[13:21:37.697] Number of futures (= number of chunks): 2
[13:21:37.697] Launching 2 futures (chunks) ...
[13:21:37.697] Chunk #1 of 2 ...
[13:21:37.697]  - Finding globals in 'X' for chunk #1 ...
[13:21:37.697] getGlobalsAndPackages() ...
[13:21:37.697] Searching for globals...
[13:21:37.697] 
[13:21:37.697] Searching for globals ... DONE
[13:21:37.698] - globals: [0] <none>
[13:21:37.698] getGlobalsAndPackages() ... DONE
[13:21:37.698]    + additional globals found: [n=0] 
[13:21:37.698]    + additional namespaces needed: [n=0] 
[13:21:37.698]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:37.698]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:37.698]  - seeds: <none>
[13:21:37.698]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:37.698] getGlobalsAndPackages() ...
[13:21:37.698] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:37.698] Resolving globals: FALSE
[13:21:37.699] Tweak future expression to call with '...' arguments ...
[13:21:37.699] {
[13:21:37.699]     do.call(function(...) {
[13:21:37.699]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:37.699]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:37.699]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:37.699]             on.exit(options(oopts), add = TRUE)
[13:21:37.699]         }
[13:21:37.699]         {
[13:21:37.699]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:37.699]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:37.699]                 ...future.FUN(...future.X_jj, ...)
[13:21:37.699]             })
[13:21:37.699]         }
[13:21:37.699]     }, args = future.call.arguments)
[13:21:37.699] }
[13:21:37.699] Tweak future expression to call with '...' arguments ... DONE
[13:21:37.699] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:37.700] - packages: [1] ‘future.apply’
[13:21:37.700] getGlobalsAndPackages() ... DONE
[13:21:37.700] run() for ‘Future’ ...
[13:21:37.700] - state: ‘created’
[13:21:37.700] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:37.714] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:37.714] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:37.715]   - Field: ‘node’
[13:21:37.715]   - Field: ‘label’
[13:21:37.715]   - Field: ‘local’
[13:21:37.715]   - Field: ‘owner’
[13:21:37.715]   - Field: ‘envir’
[13:21:37.715]   - Field: ‘workers’
[13:21:37.715]   - Field: ‘packages’
[13:21:37.715]   - Field: ‘gc’
[13:21:37.715]   - Field: ‘conditions’
[13:21:37.715]   - Field: ‘persistent’
[13:21:37.715]   - Field: ‘expr’
[13:21:37.716]   - Field: ‘uuid’
[13:21:37.716]   - Field: ‘seed’
[13:21:37.716]   - Field: ‘version’
[13:21:37.716]   - Field: ‘result’
[13:21:37.716]   - Field: ‘asynchronous’
[13:21:37.716]   - Field: ‘calls’
[13:21:37.716]   - Field: ‘globals’
[13:21:37.716]   - Field: ‘stdout’
[13:21:37.716]   - Field: ‘earlySignal’
[13:21:37.716]   - Field: ‘lazy’
[13:21:37.717]   - Field: ‘state’
[13:21:37.717] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:37.717] - Launch lazy future ...
[13:21:37.717] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:37.717] Packages needed by future strategies (n = 0): <none>
[13:21:37.718] {
[13:21:37.718]     {
[13:21:37.718]         {
[13:21:37.718]             ...future.startTime <- base::Sys.time()
[13:21:37.718]             {
[13:21:37.718]                 {
[13:21:37.718]                   {
[13:21:37.718]                     {
[13:21:37.718]                       {
[13:21:37.718]                         base::local({
[13:21:37.718]                           has_future <- base::requireNamespace("future", 
[13:21:37.718]                             quietly = TRUE)
[13:21:37.718]                           if (has_future) {
[13:21:37.718]                             ns <- base::getNamespace("future")
[13:21:37.718]                             version <- ns[[".package"]][["version"]]
[13:21:37.718]                             if (is.null(version)) 
[13:21:37.718]                               version <- utils::packageVersion("future")
[13:21:37.718]                           }
[13:21:37.718]                           else {
[13:21:37.718]                             version <- NULL
[13:21:37.718]                           }
[13:21:37.718]                           if (!has_future || version < "1.8.0") {
[13:21:37.718]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:37.718]                               "", base::R.version$version.string), 
[13:21:37.718]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:37.718]                                 base::R.version$platform, 8 * 
[13:21:37.718]                                   base::.Machine$sizeof.pointer), 
[13:21:37.718]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:37.718]                                 "release", "version")], collapse = " "), 
[13:21:37.718]                               hostname = base::Sys.info()[["nodename"]])
[13:21:37.718]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:37.718]                               info)
[13:21:37.718]                             info <- base::paste(info, collapse = "; ")
[13:21:37.718]                             if (!has_future) {
[13:21:37.718]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:37.718]                                 info)
[13:21:37.718]                             }
[13:21:37.718]                             else {
[13:21:37.718]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:37.718]                                 info, version)
[13:21:37.718]                             }
[13:21:37.718]                             base::stop(msg)
[13:21:37.718]                           }
[13:21:37.718]                         })
[13:21:37.718]                       }
[13:21:37.718]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:37.718]                       base::options(mc.cores = 1L)
[13:21:37.718]                     }
[13:21:37.718]                     base::local({
[13:21:37.718]                       for (pkg in "future.apply") {
[13:21:37.718]                         base::loadNamespace(pkg)
[13:21:37.718]                         base::library(pkg, character.only = TRUE)
[13:21:37.718]                       }
[13:21:37.718]                     })
[13:21:37.718]                   }
[13:21:37.718]                   options(future.plan = NULL)
[13:21:37.718]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:37.718]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:37.718]                 }
[13:21:37.718]                 ...future.workdir <- getwd()
[13:21:37.718]             }
[13:21:37.718]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:37.718]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:37.718]         }
[13:21:37.718]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:37.718]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:37.718]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:37.718]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:37.718]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:37.718]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:37.718]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:37.718]             base::names(...future.oldOptions))
[13:21:37.718]     }
[13:21:37.718]     if (FALSE) {
[13:21:37.718]     }
[13:21:37.718]     else {
[13:21:37.718]         if (TRUE) {
[13:21:37.718]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:37.718]                 open = "w")
[13:21:37.718]         }
[13:21:37.718]         else {
[13:21:37.718]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:37.718]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:37.718]         }
[13:21:37.718]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:37.718]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:37.718]             base::sink(type = "output", split = FALSE)
[13:21:37.718]             base::close(...future.stdout)
[13:21:37.718]         }, add = TRUE)
[13:21:37.718]     }
[13:21:37.718]     ...future.frame <- base::sys.nframe()
[13:21:37.718]     ...future.conditions <- base::list()
[13:21:37.718]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:37.718]     if (FALSE) {
[13:21:37.718]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:37.718]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:37.718]     }
[13:21:37.718]     ...future.result <- base::tryCatch({
[13:21:37.718]         base::withCallingHandlers({
[13:21:37.718]             ...future.value <- base::withVisible(base::local({
[13:21:37.718]                 ...future.makeSendCondition <- base::local({
[13:21:37.718]                   sendCondition <- NULL
[13:21:37.718]                   function(frame = 1L) {
[13:21:37.718]                     if (is.function(sendCondition)) 
[13:21:37.718]                       return(sendCondition)
[13:21:37.718]                     ns <- getNamespace("parallel")
[13:21:37.718]                     if (exists("sendData", mode = "function", 
[13:21:37.718]                       envir = ns)) {
[13:21:37.718]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:37.718]                         envir = ns)
[13:21:37.718]                       envir <- sys.frame(frame)
[13:21:37.718]                       master <- NULL
[13:21:37.718]                       while (!identical(envir, .GlobalEnv) && 
[13:21:37.718]                         !identical(envir, emptyenv())) {
[13:21:37.718]                         if (exists("master", mode = "list", envir = envir, 
[13:21:37.718]                           inherits = FALSE)) {
[13:21:37.718]                           master <- get("master", mode = "list", 
[13:21:37.718]                             envir = envir, inherits = FALSE)
[13:21:37.718]                           if (inherits(master, c("SOCKnode", 
[13:21:37.718]                             "SOCK0node"))) {
[13:21:37.718]                             sendCondition <<- function(cond) {
[13:21:37.718]                               data <- list(type = "VALUE", value = cond, 
[13:21:37.718]                                 success = TRUE)
[13:21:37.718]                               parallel_sendData(master, data)
[13:21:37.718]                             }
[13:21:37.718]                             return(sendCondition)
[13:21:37.718]                           }
[13:21:37.718]                         }
[13:21:37.718]                         frame <- frame + 1L
[13:21:37.718]                         envir <- sys.frame(frame)
[13:21:37.718]                       }
[13:21:37.718]                     }
[13:21:37.718]                     sendCondition <<- function(cond) NULL
[13:21:37.718]                   }
[13:21:37.718]                 })
[13:21:37.718]                 withCallingHandlers({
[13:21:37.718]                   {
[13:21:37.718]                     do.call(function(...) {
[13:21:37.718]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:37.718]                       if (!identical(...future.globals.maxSize.org, 
[13:21:37.718]                         ...future.globals.maxSize)) {
[13:21:37.718]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:37.718]                         on.exit(options(oopts), add = TRUE)
[13:21:37.718]                       }
[13:21:37.718]                       {
[13:21:37.718]                         lapply(seq_along(...future.elements_ii), 
[13:21:37.718]                           FUN = function(jj) {
[13:21:37.718]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:37.718]                             ...future.FUN(...future.X_jj, ...)
[13:21:37.718]                           })
[13:21:37.718]                       }
[13:21:37.718]                     }, args = future.call.arguments)
[13:21:37.718]                   }
[13:21:37.718]                 }, immediateCondition = function(cond) {
[13:21:37.718]                   sendCondition <- ...future.makeSendCondition()
[13:21:37.718]                   sendCondition(cond)
[13:21:37.718]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:37.718]                   {
[13:21:37.718]                     inherits <- base::inherits
[13:21:37.718]                     invokeRestart <- base::invokeRestart
[13:21:37.718]                     is.null <- base::is.null
[13:21:37.718]                     muffled <- FALSE
[13:21:37.718]                     if (inherits(cond, "message")) {
[13:21:37.718]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:37.718]                       if (muffled) 
[13:21:37.718]                         invokeRestart("muffleMessage")
[13:21:37.718]                     }
[13:21:37.718]                     else if (inherits(cond, "warning")) {
[13:21:37.718]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:37.718]                       if (muffled) 
[13:21:37.718]                         invokeRestart("muffleWarning")
[13:21:37.718]                     }
[13:21:37.718]                     else if (inherits(cond, "condition")) {
[13:21:37.718]                       if (!is.null(pattern)) {
[13:21:37.718]                         computeRestarts <- base::computeRestarts
[13:21:37.718]                         grepl <- base::grepl
[13:21:37.718]                         restarts <- computeRestarts(cond)
[13:21:37.718]                         for (restart in restarts) {
[13:21:37.718]                           name <- restart$name
[13:21:37.718]                           if (is.null(name)) 
[13:21:37.718]                             next
[13:21:37.718]                           if (!grepl(pattern, name)) 
[13:21:37.718]                             next
[13:21:37.718]                           invokeRestart(restart)
[13:21:37.718]                           muffled <- TRUE
[13:21:37.718]                           break
[13:21:37.718]                         }
[13:21:37.718]                       }
[13:21:37.718]                     }
[13:21:37.718]                     invisible(muffled)
[13:21:37.718]                   }
[13:21:37.718]                   muffleCondition(cond)
[13:21:37.718]                 })
[13:21:37.718]             }))
[13:21:37.718]             future::FutureResult(value = ...future.value$value, 
[13:21:37.718]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:37.718]                   ...future.rng), globalenv = if (FALSE) 
[13:21:37.718]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:37.718]                     ...future.globalenv.names))
[13:21:37.718]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:37.718]         }, condition = base::local({
[13:21:37.718]             c <- base::c
[13:21:37.718]             inherits <- base::inherits
[13:21:37.718]             invokeRestart <- base::invokeRestart
[13:21:37.718]             length <- base::length
[13:21:37.718]             list <- base::list
[13:21:37.718]             seq.int <- base::seq.int
[13:21:37.718]             signalCondition <- base::signalCondition
[13:21:37.718]             sys.calls <- base::sys.calls
[13:21:37.718]             `[[` <- base::`[[`
[13:21:37.718]             `+` <- base::`+`
[13:21:37.718]             `<<-` <- base::`<<-`
[13:21:37.718]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:37.718]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:37.718]                   3L)]
[13:21:37.718]             }
[13:21:37.718]             function(cond) {
[13:21:37.718]                 is_error <- inherits(cond, "error")
[13:21:37.718]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:37.718]                   NULL)
[13:21:37.718]                 if (is_error) {
[13:21:37.718]                   sessionInformation <- function() {
[13:21:37.718]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:37.718]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:37.718]                       search = base::search(), system = base::Sys.info())
[13:21:37.718]                   }
[13:21:37.718]                   ...future.conditions[[length(...future.conditions) + 
[13:21:37.718]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:37.718]                     cond$call), session = sessionInformation(), 
[13:21:37.718]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:37.718]                   signalCondition(cond)
[13:21:37.718]                 }
[13:21:37.718]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:37.718]                 "immediateCondition"))) {
[13:21:37.718]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:37.718]                   ...future.conditions[[length(...future.conditions) + 
[13:21:37.718]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:37.718]                   if (TRUE && !signal) {
[13:21:37.718]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:37.718]                     {
[13:21:37.718]                       inherits <- base::inherits
[13:21:37.718]                       invokeRestart <- base::invokeRestart
[13:21:37.718]                       is.null <- base::is.null
[13:21:37.718]                       muffled <- FALSE
[13:21:37.718]                       if (inherits(cond, "message")) {
[13:21:37.718]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:37.718]                         if (muffled) 
[13:21:37.718]                           invokeRestart("muffleMessage")
[13:21:37.718]                       }
[13:21:37.718]                       else if (inherits(cond, "warning")) {
[13:21:37.718]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:37.718]                         if (muffled) 
[13:21:37.718]                           invokeRestart("muffleWarning")
[13:21:37.718]                       }
[13:21:37.718]                       else if (inherits(cond, "condition")) {
[13:21:37.718]                         if (!is.null(pattern)) {
[13:21:37.718]                           computeRestarts <- base::computeRestarts
[13:21:37.718]                           grepl <- base::grepl
[13:21:37.718]                           restarts <- computeRestarts(cond)
[13:21:37.718]                           for (restart in restarts) {
[13:21:37.718]                             name <- restart$name
[13:21:37.718]                             if (is.null(name)) 
[13:21:37.718]                               next
[13:21:37.718]                             if (!grepl(pattern, name)) 
[13:21:37.718]                               next
[13:21:37.718]                             invokeRestart(restart)
[13:21:37.718]                             muffled <- TRUE
[13:21:37.718]                             break
[13:21:37.718]                           }
[13:21:37.718]                         }
[13:21:37.718]                       }
[13:21:37.718]                       invisible(muffled)
[13:21:37.718]                     }
[13:21:37.718]                     muffleCondition(cond, pattern = "^muffle")
[13:21:37.718]                   }
[13:21:37.718]                 }
[13:21:37.718]                 else {
[13:21:37.718]                   if (TRUE) {
[13:21:37.718]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:37.718]                     {
[13:21:37.718]                       inherits <- base::inherits
[13:21:37.718]                       invokeRestart <- base::invokeRestart
[13:21:37.718]                       is.null <- base::is.null
[13:21:37.718]                       muffled <- FALSE
[13:21:37.718]                       if (inherits(cond, "message")) {
[13:21:37.718]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:37.718]                         if (muffled) 
[13:21:37.718]                           invokeRestart("muffleMessage")
[13:21:37.718]                       }
[13:21:37.718]                       else if (inherits(cond, "warning")) {
[13:21:37.718]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:37.718]                         if (muffled) 
[13:21:37.718]                           invokeRestart("muffleWarning")
[13:21:37.718]                       }
[13:21:37.718]                       else if (inherits(cond, "condition")) {
[13:21:37.718]                         if (!is.null(pattern)) {
[13:21:37.718]                           computeRestarts <- base::computeRestarts
[13:21:37.718]                           grepl <- base::grepl
[13:21:37.718]                           restarts <- computeRestarts(cond)
[13:21:37.718]                           for (restart in restarts) {
[13:21:37.718]                             name <- restart$name
[13:21:37.718]                             if (is.null(name)) 
[13:21:37.718]                               next
[13:21:37.718]                             if (!grepl(pattern, name)) 
[13:21:37.718]                               next
[13:21:37.718]                             invokeRestart(restart)
[13:21:37.718]                             muffled <- TRUE
[13:21:37.718]                             break
[13:21:37.718]                           }
[13:21:37.718]                         }
[13:21:37.718]                       }
[13:21:37.718]                       invisible(muffled)
[13:21:37.718]                     }
[13:21:37.718]                     muffleCondition(cond, pattern = "^muffle")
[13:21:37.718]                   }
[13:21:37.718]                 }
[13:21:37.718]             }
[13:21:37.718]         }))
[13:21:37.718]     }, error = function(ex) {
[13:21:37.718]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:37.718]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:37.718]                 ...future.rng), started = ...future.startTime, 
[13:21:37.718]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:37.718]             version = "1.8"), class = "FutureResult")
[13:21:37.718]     }, finally = {
[13:21:37.718]         if (!identical(...future.workdir, getwd())) 
[13:21:37.718]             setwd(...future.workdir)
[13:21:37.718]         {
[13:21:37.718]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:37.718]                 ...future.oldOptions$nwarnings <- NULL
[13:21:37.718]             }
[13:21:37.718]             base::options(...future.oldOptions)
[13:21:37.718]             if (.Platform$OS.type == "windows") {
[13:21:37.718]                 old_names <- names(...future.oldEnvVars)
[13:21:37.718]                 envs <- base::Sys.getenv()
[13:21:37.718]                 names <- names(envs)
[13:21:37.718]                 common <- intersect(names, old_names)
[13:21:37.718]                 added <- setdiff(names, old_names)
[13:21:37.718]                 removed <- setdiff(old_names, names)
[13:21:37.718]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:37.718]                   envs[common]]
[13:21:37.718]                 NAMES <- toupper(changed)
[13:21:37.718]                 args <- list()
[13:21:37.718]                 for (kk in seq_along(NAMES)) {
[13:21:37.718]                   name <- changed[[kk]]
[13:21:37.718]                   NAME <- NAMES[[kk]]
[13:21:37.718]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:37.718]                     next
[13:21:37.718]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:37.718]                 }
[13:21:37.718]                 NAMES <- toupper(added)
[13:21:37.718]                 for (kk in seq_along(NAMES)) {
[13:21:37.718]                   name <- added[[kk]]
[13:21:37.718]                   NAME <- NAMES[[kk]]
[13:21:37.718]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:37.718]                     next
[13:21:37.718]                   args[[name]] <- ""
[13:21:37.718]                 }
[13:21:37.718]                 NAMES <- toupper(removed)
[13:21:37.718]                 for (kk in seq_along(NAMES)) {
[13:21:37.718]                   name <- removed[[kk]]
[13:21:37.718]                   NAME <- NAMES[[kk]]
[13:21:37.718]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:37.718]                     next
[13:21:37.718]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:37.718]                 }
[13:21:37.718]                 if (length(args) > 0) 
[13:21:37.718]                   base::do.call(base::Sys.setenv, args = args)
[13:21:37.718]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:37.718]             }
[13:21:37.718]             else {
[13:21:37.718]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:37.718]             }
[13:21:37.718]             {
[13:21:37.718]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:37.718]                   0L) {
[13:21:37.718]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:37.718]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:37.718]                   base::options(opts)
[13:21:37.718]                 }
[13:21:37.718]                 {
[13:21:37.718]                   {
[13:21:37.718]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:37.718]                     NULL
[13:21:37.718]                   }
[13:21:37.718]                   options(future.plan = NULL)
[13:21:37.718]                   if (is.na(NA_character_)) 
[13:21:37.718]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:37.718]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:37.718]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:37.718]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:37.718]                     envir = parent.frame()) 
[13:21:37.718]                   {
[13:21:37.718]                     if (is.function(workers)) 
[13:21:37.718]                       workers <- workers()
[13:21:37.718]                     workers <- structure(as.integer(workers), 
[13:21:37.718]                       class = class(workers))
[13:21:37.718]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:37.718]                       workers >= 1)
[13:21:37.718]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:37.718]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:37.718]                     }
[13:21:37.718]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:37.718]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:37.718]                       envir = envir)
[13:21:37.718]                     if (!future$lazy) 
[13:21:37.718]                       future <- run(future)
[13:21:37.718]                     invisible(future)
[13:21:37.718]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:37.718]                 }
[13:21:37.718]             }
[13:21:37.718]         }
[13:21:37.718]     })
[13:21:37.718]     if (TRUE) {
[13:21:37.718]         base::sink(type = "output", split = FALSE)
[13:21:37.718]         if (TRUE) {
[13:21:37.718]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:37.718]         }
[13:21:37.718]         else {
[13:21:37.718]             ...future.result["stdout"] <- base::list(NULL)
[13:21:37.718]         }
[13:21:37.718]         base::close(...future.stdout)
[13:21:37.718]         ...future.stdout <- NULL
[13:21:37.718]     }
[13:21:37.718]     ...future.result$conditions <- ...future.conditions
[13:21:37.718]     ...future.result$finished <- base::Sys.time()
[13:21:37.718]     ...future.result
[13:21:37.718] }
[13:21:37.721] Exporting 11 global objects (92.12 KiB) to cluster node #1 ...
[13:21:37.721] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:21:37.764] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:21:37.765] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[13:21:37.765] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[13:21:37.765] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:21:37.766] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:21:37.766] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:21:37.808] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:21:37.809] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:21:37.856] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:21:37.857] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[13:21:37.857] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[13:21:37.857] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[13:21:37.858] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[13:21:37.858] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:21:37.858] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:21:37.858] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[13:21:37.859] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[13:21:37.859] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:21:37.859] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:21:37.860] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:21:37.860] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:21:37.860] Exporting 11 global objects (92.12 KiB) to cluster node #1 ... DONE
[13:21:37.861] MultisessionFuture started
[13:21:37.861] - Launch lazy future ... done
[13:21:37.861] run() for ‘MultisessionFuture’ ... done
[13:21:37.861] Created future:
[13:21:37.861] MultisessionFuture:
[13:21:37.861] Label: ‘future_vapply-1’
[13:21:37.861] Expression:
[13:21:37.861] {
[13:21:37.861]     do.call(function(...) {
[13:21:37.861]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:37.861]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:37.861]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:37.861]             on.exit(options(oopts), add = TRUE)
[13:21:37.861]         }
[13:21:37.861]         {
[13:21:37.861]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:37.861]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:37.861]                 ...future.FUN(...future.X_jj, ...)
[13:21:37.861]             })
[13:21:37.861]         }
[13:21:37.861]     }, args = future.call.arguments)
[13:21:37.861] }
[13:21:37.861] Lazy evaluation: FALSE
[13:21:37.861] Asynchronous evaluation: TRUE
[13:21:37.861] Local evaluation: TRUE
[13:21:37.861] Environment: R_GlobalEnv
[13:21:37.861] Capture standard output: TRUE
[13:21:37.861] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:37.861] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:37.861] Packages: 1 packages (‘future.apply’)
[13:21:37.861] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:37.861] Resolved: FALSE
[13:21:37.861] Value: <not collected>
[13:21:37.861] Conditions captured: <none>
[13:21:37.861] Early signaling: FALSE
[13:21:37.861] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:37.861] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:37.873] Chunk #1 of 2 ... DONE
[13:21:37.873] Chunk #2 of 2 ...
[13:21:37.873]  - Finding globals in 'X' for chunk #2 ...
[13:21:37.873] getGlobalsAndPackages() ...
[13:21:37.873] Searching for globals...
[13:21:37.874] 
[13:21:37.874] Searching for globals ... DONE
[13:21:37.874] - globals: [0] <none>
[13:21:37.874] getGlobalsAndPackages() ... DONE
[13:21:37.874]    + additional globals found: [n=0] 
[13:21:37.874]    + additional namespaces needed: [n=0] 
[13:21:37.874]  - Finding globals in 'X' for chunk #2 ... DONE
[13:21:37.874]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:37.875]  - seeds: <none>
[13:21:37.875]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:37.875] getGlobalsAndPackages() ...
[13:21:37.875] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:37.875] Resolving globals: FALSE
[13:21:37.875] Tweak future expression to call with '...' arguments ...
[13:21:37.875] {
[13:21:37.875]     do.call(function(...) {
[13:21:37.875]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:37.875]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:37.875]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:37.875]             on.exit(options(oopts), add = TRUE)
[13:21:37.875]         }
[13:21:37.875]         {
[13:21:37.875]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:37.875]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:37.875]                 ...future.FUN(...future.X_jj, ...)
[13:21:37.875]             })
[13:21:37.875]         }
[13:21:37.875]     }, args = future.call.arguments)
[13:21:37.875] }
[13:21:37.875] Tweak future expression to call with '...' arguments ... DONE
[13:21:37.876] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:37.876] - packages: [1] ‘future.apply’
[13:21:37.876] getGlobalsAndPackages() ... DONE
[13:21:37.877] run() for ‘Future’ ...
[13:21:37.877] - state: ‘created’
[13:21:37.877] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:37.891] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:37.892] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:37.892]   - Field: ‘node’
[13:21:37.892]   - Field: ‘label’
[13:21:37.892]   - Field: ‘local’
[13:21:37.892]   - Field: ‘owner’
[13:21:37.892]   - Field: ‘envir’
[13:21:37.892]   - Field: ‘workers’
[13:21:37.892]   - Field: ‘packages’
[13:21:37.893]   - Field: ‘gc’
[13:21:37.893]   - Field: ‘conditions’
[13:21:37.893]   - Field: ‘persistent’
[13:21:37.893]   - Field: ‘expr’
[13:21:37.893]   - Field: ‘uuid’
[13:21:37.893]   - Field: ‘seed’
[13:21:37.893]   - Field: ‘version’
[13:21:37.893]   - Field: ‘result’
[13:21:37.893]   - Field: ‘asynchronous’
[13:21:37.893]   - Field: ‘calls’
[13:21:37.894]   - Field: ‘globals’
[13:21:37.894]   - Field: ‘stdout’
[13:21:37.894]   - Field: ‘earlySignal’
[13:21:37.894]   - Field: ‘lazy’
[13:21:37.894]   - Field: ‘state’
[13:21:37.894] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:37.894] - Launch lazy future ...
[13:21:37.894] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:37.895] Packages needed by future strategies (n = 0): <none>
[13:21:37.895] {
[13:21:37.895]     {
[13:21:37.895]         {
[13:21:37.895]             ...future.startTime <- base::Sys.time()
[13:21:37.895]             {
[13:21:37.895]                 {
[13:21:37.895]                   {
[13:21:37.895]                     {
[13:21:37.895]                       {
[13:21:37.895]                         base::local({
[13:21:37.895]                           has_future <- base::requireNamespace("future", 
[13:21:37.895]                             quietly = TRUE)
[13:21:37.895]                           if (has_future) {
[13:21:37.895]                             ns <- base::getNamespace("future")
[13:21:37.895]                             version <- ns[[".package"]][["version"]]
[13:21:37.895]                             if (is.null(version)) 
[13:21:37.895]                               version <- utils::packageVersion("future")
[13:21:37.895]                           }
[13:21:37.895]                           else {
[13:21:37.895]                             version <- NULL
[13:21:37.895]                           }
[13:21:37.895]                           if (!has_future || version < "1.8.0") {
[13:21:37.895]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:37.895]                               "", base::R.version$version.string), 
[13:21:37.895]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:37.895]                                 base::R.version$platform, 8 * 
[13:21:37.895]                                   base::.Machine$sizeof.pointer), 
[13:21:37.895]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:37.895]                                 "release", "version")], collapse = " "), 
[13:21:37.895]                               hostname = base::Sys.info()[["nodename"]])
[13:21:37.895]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:37.895]                               info)
[13:21:37.895]                             info <- base::paste(info, collapse = "; ")
[13:21:37.895]                             if (!has_future) {
[13:21:37.895]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:37.895]                                 info)
[13:21:37.895]                             }
[13:21:37.895]                             else {
[13:21:37.895]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:37.895]                                 info, version)
[13:21:37.895]                             }
[13:21:37.895]                             base::stop(msg)
[13:21:37.895]                           }
[13:21:37.895]                         })
[13:21:37.895]                       }
[13:21:37.895]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:37.895]                       base::options(mc.cores = 1L)
[13:21:37.895]                     }
[13:21:37.895]                     base::local({
[13:21:37.895]                       for (pkg in "future.apply") {
[13:21:37.895]                         base::loadNamespace(pkg)
[13:21:37.895]                         base::library(pkg, character.only = TRUE)
[13:21:37.895]                       }
[13:21:37.895]                     })
[13:21:37.895]                   }
[13:21:37.895]                   options(future.plan = NULL)
[13:21:37.895]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:37.895]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:37.895]                 }
[13:21:37.895]                 ...future.workdir <- getwd()
[13:21:37.895]             }
[13:21:37.895]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:37.895]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:37.895]         }
[13:21:37.895]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:37.895]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:37.895]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:37.895]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:37.895]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:37.895]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:37.895]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:37.895]             base::names(...future.oldOptions))
[13:21:37.895]     }
[13:21:37.895]     if (FALSE) {
[13:21:37.895]     }
[13:21:37.895]     else {
[13:21:37.895]         if (TRUE) {
[13:21:37.895]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:37.895]                 open = "w")
[13:21:37.895]         }
[13:21:37.895]         else {
[13:21:37.895]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:37.895]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:37.895]         }
[13:21:37.895]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:37.895]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:37.895]             base::sink(type = "output", split = FALSE)
[13:21:37.895]             base::close(...future.stdout)
[13:21:37.895]         }, add = TRUE)
[13:21:37.895]     }
[13:21:37.895]     ...future.frame <- base::sys.nframe()
[13:21:37.895]     ...future.conditions <- base::list()
[13:21:37.895]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:37.895]     if (FALSE) {
[13:21:37.895]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:37.895]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:37.895]     }
[13:21:37.895]     ...future.result <- base::tryCatch({
[13:21:37.895]         base::withCallingHandlers({
[13:21:37.895]             ...future.value <- base::withVisible(base::local({
[13:21:37.895]                 ...future.makeSendCondition <- base::local({
[13:21:37.895]                   sendCondition <- NULL
[13:21:37.895]                   function(frame = 1L) {
[13:21:37.895]                     if (is.function(sendCondition)) 
[13:21:37.895]                       return(sendCondition)
[13:21:37.895]                     ns <- getNamespace("parallel")
[13:21:37.895]                     if (exists("sendData", mode = "function", 
[13:21:37.895]                       envir = ns)) {
[13:21:37.895]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:37.895]                         envir = ns)
[13:21:37.895]                       envir <- sys.frame(frame)
[13:21:37.895]                       master <- NULL
[13:21:37.895]                       while (!identical(envir, .GlobalEnv) && 
[13:21:37.895]                         !identical(envir, emptyenv())) {
[13:21:37.895]                         if (exists("master", mode = "list", envir = envir, 
[13:21:37.895]                           inherits = FALSE)) {
[13:21:37.895]                           master <- get("master", mode = "list", 
[13:21:37.895]                             envir = envir, inherits = FALSE)
[13:21:37.895]                           if (inherits(master, c("SOCKnode", 
[13:21:37.895]                             "SOCK0node"))) {
[13:21:37.895]                             sendCondition <<- function(cond) {
[13:21:37.895]                               data <- list(type = "VALUE", value = cond, 
[13:21:37.895]                                 success = TRUE)
[13:21:37.895]                               parallel_sendData(master, data)
[13:21:37.895]                             }
[13:21:37.895]                             return(sendCondition)
[13:21:37.895]                           }
[13:21:37.895]                         }
[13:21:37.895]                         frame <- frame + 1L
[13:21:37.895]                         envir <- sys.frame(frame)
[13:21:37.895]                       }
[13:21:37.895]                     }
[13:21:37.895]                     sendCondition <<- function(cond) NULL
[13:21:37.895]                   }
[13:21:37.895]                 })
[13:21:37.895]                 withCallingHandlers({
[13:21:37.895]                   {
[13:21:37.895]                     do.call(function(...) {
[13:21:37.895]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:37.895]                       if (!identical(...future.globals.maxSize.org, 
[13:21:37.895]                         ...future.globals.maxSize)) {
[13:21:37.895]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:37.895]                         on.exit(options(oopts), add = TRUE)
[13:21:37.895]                       }
[13:21:37.895]                       {
[13:21:37.895]                         lapply(seq_along(...future.elements_ii), 
[13:21:37.895]                           FUN = function(jj) {
[13:21:37.895]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:37.895]                             ...future.FUN(...future.X_jj, ...)
[13:21:37.895]                           })
[13:21:37.895]                       }
[13:21:37.895]                     }, args = future.call.arguments)
[13:21:37.895]                   }
[13:21:37.895]                 }, immediateCondition = function(cond) {
[13:21:37.895]                   sendCondition <- ...future.makeSendCondition()
[13:21:37.895]                   sendCondition(cond)
[13:21:37.895]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:37.895]                   {
[13:21:37.895]                     inherits <- base::inherits
[13:21:37.895]                     invokeRestart <- base::invokeRestart
[13:21:37.895]                     is.null <- base::is.null
[13:21:37.895]                     muffled <- FALSE
[13:21:37.895]                     if (inherits(cond, "message")) {
[13:21:37.895]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:37.895]                       if (muffled) 
[13:21:37.895]                         invokeRestart("muffleMessage")
[13:21:37.895]                     }
[13:21:37.895]                     else if (inherits(cond, "warning")) {
[13:21:37.895]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:37.895]                       if (muffled) 
[13:21:37.895]                         invokeRestart("muffleWarning")
[13:21:37.895]                     }
[13:21:37.895]                     else if (inherits(cond, "condition")) {
[13:21:37.895]                       if (!is.null(pattern)) {
[13:21:37.895]                         computeRestarts <- base::computeRestarts
[13:21:37.895]                         grepl <- base::grepl
[13:21:37.895]                         restarts <- computeRestarts(cond)
[13:21:37.895]                         for (restart in restarts) {
[13:21:37.895]                           name <- restart$name
[13:21:37.895]                           if (is.null(name)) 
[13:21:37.895]                             next
[13:21:37.895]                           if (!grepl(pattern, name)) 
[13:21:37.895]                             next
[13:21:37.895]                           invokeRestart(restart)
[13:21:37.895]                           muffled <- TRUE
[13:21:37.895]                           break
[13:21:37.895]                         }
[13:21:37.895]                       }
[13:21:37.895]                     }
[13:21:37.895]                     invisible(muffled)
[13:21:37.895]                   }
[13:21:37.895]                   muffleCondition(cond)
[13:21:37.895]                 })
[13:21:37.895]             }))
[13:21:37.895]             future::FutureResult(value = ...future.value$value, 
[13:21:37.895]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:37.895]                   ...future.rng), globalenv = if (FALSE) 
[13:21:37.895]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:37.895]                     ...future.globalenv.names))
[13:21:37.895]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:37.895]         }, condition = base::local({
[13:21:37.895]             c <- base::c
[13:21:37.895]             inherits <- base::inherits
[13:21:37.895]             invokeRestart <- base::invokeRestart
[13:21:37.895]             length <- base::length
[13:21:37.895]             list <- base::list
[13:21:37.895]             seq.int <- base::seq.int
[13:21:37.895]             signalCondition <- base::signalCondition
[13:21:37.895]             sys.calls <- base::sys.calls
[13:21:37.895]             `[[` <- base::`[[`
[13:21:37.895]             `+` <- base::`+`
[13:21:37.895]             `<<-` <- base::`<<-`
[13:21:37.895]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:37.895]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:37.895]                   3L)]
[13:21:37.895]             }
[13:21:37.895]             function(cond) {
[13:21:37.895]                 is_error <- inherits(cond, "error")
[13:21:37.895]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:37.895]                   NULL)
[13:21:37.895]                 if (is_error) {
[13:21:37.895]                   sessionInformation <- function() {
[13:21:37.895]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:37.895]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:37.895]                       search = base::search(), system = base::Sys.info())
[13:21:37.895]                   }
[13:21:37.895]                   ...future.conditions[[length(...future.conditions) + 
[13:21:37.895]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:37.895]                     cond$call), session = sessionInformation(), 
[13:21:37.895]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:37.895]                   signalCondition(cond)
[13:21:37.895]                 }
[13:21:37.895]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:37.895]                 "immediateCondition"))) {
[13:21:37.895]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:37.895]                   ...future.conditions[[length(...future.conditions) + 
[13:21:37.895]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:37.895]                   if (TRUE && !signal) {
[13:21:37.895]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:37.895]                     {
[13:21:37.895]                       inherits <- base::inherits
[13:21:37.895]                       invokeRestart <- base::invokeRestart
[13:21:37.895]                       is.null <- base::is.null
[13:21:37.895]                       muffled <- FALSE
[13:21:37.895]                       if (inherits(cond, "message")) {
[13:21:37.895]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:37.895]                         if (muffled) 
[13:21:37.895]                           invokeRestart("muffleMessage")
[13:21:37.895]                       }
[13:21:37.895]                       else if (inherits(cond, "warning")) {
[13:21:37.895]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:37.895]                         if (muffled) 
[13:21:37.895]                           invokeRestart("muffleWarning")
[13:21:37.895]                       }
[13:21:37.895]                       else if (inherits(cond, "condition")) {
[13:21:37.895]                         if (!is.null(pattern)) {
[13:21:37.895]                           computeRestarts <- base::computeRestarts
[13:21:37.895]                           grepl <- base::grepl
[13:21:37.895]                           restarts <- computeRestarts(cond)
[13:21:37.895]                           for (restart in restarts) {
[13:21:37.895]                             name <- restart$name
[13:21:37.895]                             if (is.null(name)) 
[13:21:37.895]                               next
[13:21:37.895]                             if (!grepl(pattern, name)) 
[13:21:37.895]                               next
[13:21:37.895]                             invokeRestart(restart)
[13:21:37.895]                             muffled <- TRUE
[13:21:37.895]                             break
[13:21:37.895]                           }
[13:21:37.895]                         }
[13:21:37.895]                       }
[13:21:37.895]                       invisible(muffled)
[13:21:37.895]                     }
[13:21:37.895]                     muffleCondition(cond, pattern = "^muffle")
[13:21:37.895]                   }
[13:21:37.895]                 }
[13:21:37.895]                 else {
[13:21:37.895]                   if (TRUE) {
[13:21:37.895]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:37.895]                     {
[13:21:37.895]                       inherits <- base::inherits
[13:21:37.895]                       invokeRestart <- base::invokeRestart
[13:21:37.895]                       is.null <- base::is.null
[13:21:37.895]                       muffled <- FALSE
[13:21:37.895]                       if (inherits(cond, "message")) {
[13:21:37.895]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:37.895]                         if (muffled) 
[13:21:37.895]                           invokeRestart("muffleMessage")
[13:21:37.895]                       }
[13:21:37.895]                       else if (inherits(cond, "warning")) {
[13:21:37.895]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:37.895]                         if (muffled) 
[13:21:37.895]                           invokeRestart("muffleWarning")
[13:21:37.895]                       }
[13:21:37.895]                       else if (inherits(cond, "condition")) {
[13:21:37.895]                         if (!is.null(pattern)) {
[13:21:37.895]                           computeRestarts <- base::computeRestarts
[13:21:37.895]                           grepl <- base::grepl
[13:21:37.895]                           restarts <- computeRestarts(cond)
[13:21:37.895]                           for (restart in restarts) {
[13:21:37.895]                             name <- restart$name
[13:21:37.895]                             if (is.null(name)) 
[13:21:37.895]                               next
[13:21:37.895]                             if (!grepl(pattern, name)) 
[13:21:37.895]                               next
[13:21:37.895]                             invokeRestart(restart)
[13:21:37.895]                             muffled <- TRUE
[13:21:37.895]                             break
[13:21:37.895]                           }
[13:21:37.895]                         }
[13:21:37.895]                       }
[13:21:37.895]                       invisible(muffled)
[13:21:37.895]                     }
[13:21:37.895]                     muffleCondition(cond, pattern = "^muffle")
[13:21:37.895]                   }
[13:21:37.895]                 }
[13:21:37.895]             }
[13:21:37.895]         }))
[13:21:37.895]     }, error = function(ex) {
[13:21:37.895]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:37.895]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:37.895]                 ...future.rng), started = ...future.startTime, 
[13:21:37.895]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:37.895]             version = "1.8"), class = "FutureResult")
[13:21:37.895]     }, finally = {
[13:21:37.895]         if (!identical(...future.workdir, getwd())) 
[13:21:37.895]             setwd(...future.workdir)
[13:21:37.895]         {
[13:21:37.895]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:37.895]                 ...future.oldOptions$nwarnings <- NULL
[13:21:37.895]             }
[13:21:37.895]             base::options(...future.oldOptions)
[13:21:37.895]             if (.Platform$OS.type == "windows") {
[13:21:37.895]                 old_names <- names(...future.oldEnvVars)
[13:21:37.895]                 envs <- base::Sys.getenv()
[13:21:37.895]                 names <- names(envs)
[13:21:37.895]                 common <- intersect(names, old_names)
[13:21:37.895]                 added <- setdiff(names, old_names)
[13:21:37.895]                 removed <- setdiff(old_names, names)
[13:21:37.895]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:37.895]                   envs[common]]
[13:21:37.895]                 NAMES <- toupper(changed)
[13:21:37.895]                 args <- list()
[13:21:37.895]                 for (kk in seq_along(NAMES)) {
[13:21:37.895]                   name <- changed[[kk]]
[13:21:37.895]                   NAME <- NAMES[[kk]]
[13:21:37.895]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:37.895]                     next
[13:21:37.895]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:37.895]                 }
[13:21:37.895]                 NAMES <- toupper(added)
[13:21:37.895]                 for (kk in seq_along(NAMES)) {
[13:21:37.895]                   name <- added[[kk]]
[13:21:37.895]                   NAME <- NAMES[[kk]]
[13:21:37.895]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:37.895]                     next
[13:21:37.895]                   args[[name]] <- ""
[13:21:37.895]                 }
[13:21:37.895]                 NAMES <- toupper(removed)
[13:21:37.895]                 for (kk in seq_along(NAMES)) {
[13:21:37.895]                   name <- removed[[kk]]
[13:21:37.895]                   NAME <- NAMES[[kk]]
[13:21:37.895]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:37.895]                     next
[13:21:37.895]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:37.895]                 }
[13:21:37.895]                 if (length(args) > 0) 
[13:21:37.895]                   base::do.call(base::Sys.setenv, args = args)
[13:21:37.895]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:37.895]             }
[13:21:37.895]             else {
[13:21:37.895]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:37.895]             }
[13:21:37.895]             {
[13:21:37.895]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:37.895]                   0L) {
[13:21:37.895]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:37.895]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:37.895]                   base::options(opts)
[13:21:37.895]                 }
[13:21:37.895]                 {
[13:21:37.895]                   {
[13:21:37.895]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:37.895]                     NULL
[13:21:37.895]                   }
[13:21:37.895]                   options(future.plan = NULL)
[13:21:37.895]                   if (is.na(NA_character_)) 
[13:21:37.895]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:37.895]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:37.895]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:37.895]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:37.895]                     envir = parent.frame()) 
[13:21:37.895]                   {
[13:21:37.895]                     if (is.function(workers)) 
[13:21:37.895]                       workers <- workers()
[13:21:37.895]                     workers <- structure(as.integer(workers), 
[13:21:37.895]                       class = class(workers))
[13:21:37.895]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:37.895]                       workers >= 1)
[13:21:37.895]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:37.895]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:37.895]                     }
[13:21:37.895]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:37.895]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:37.895]                       envir = envir)
[13:21:37.895]                     if (!future$lazy) 
[13:21:37.895]                       future <- run(future)
[13:21:37.895]                     invisible(future)
[13:21:37.895]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:37.895]                 }
[13:21:37.895]             }
[13:21:37.895]         }
[13:21:37.895]     })
[13:21:37.895]     if (TRUE) {
[13:21:37.895]         base::sink(type = "output", split = FALSE)
[13:21:37.895]         if (TRUE) {
[13:21:37.895]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:37.895]         }
[13:21:37.895]         else {
[13:21:37.895]             ...future.result["stdout"] <- base::list(NULL)
[13:21:37.895]         }
[13:21:37.895]         base::close(...future.stdout)
[13:21:37.895]         ...future.stdout <- NULL
[13:21:37.895]     }
[13:21:37.895]     ...future.result$conditions <- ...future.conditions
[13:21:37.895]     ...future.result$finished <- base::Sys.time()
[13:21:37.895]     ...future.result
[13:21:37.895] }
[13:21:37.898] Exporting 11 global objects (92.12 KiB) to cluster node #2 ...
[13:21:37.898] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[13:21:37.944] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[13:21:37.945] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[13:21:37.945] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[13:21:37.945] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[13:21:37.946] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[13:21:37.946] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[13:21:37.988] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[13:21:37.989] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[13:21:38.032] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[13:21:38.033] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[13:21:38.033] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[13:21:38.033] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[13:21:38.034] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[13:21:38.034] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:21:38.034] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:21:38.034] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[13:21:38.035] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[13:21:38.035] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:21:38.035] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:21:38.035] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:21:38.036] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:21:38.036] Exporting 11 global objects (92.12 KiB) to cluster node #2 ... DONE
[13:21:38.037] MultisessionFuture started
[13:21:38.037] - Launch lazy future ... done
[13:21:38.037] run() for ‘MultisessionFuture’ ... done
[13:21:38.037] Created future:
[13:21:38.037] MultisessionFuture:
[13:21:38.037] Label: ‘future_vapply-2’
[13:21:38.037] Expression:
[13:21:38.037] {
[13:21:38.037]     do.call(function(...) {
[13:21:38.037]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:38.037]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:38.037]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:38.037]             on.exit(options(oopts), add = TRUE)
[13:21:38.037]         }
[13:21:38.037]         {
[13:21:38.037]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:38.037]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:38.037]                 ...future.FUN(...future.X_jj, ...)
[13:21:38.037]             })
[13:21:38.037]         }
[13:21:38.037]     }, args = future.call.arguments)
[13:21:38.037] }
[13:21:38.037] Lazy evaluation: FALSE
[13:21:38.037] Asynchronous evaluation: TRUE
[13:21:38.037] Local evaluation: TRUE
[13:21:38.037] Environment: R_GlobalEnv
[13:21:38.037] Capture standard output: TRUE
[13:21:38.037] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:38.037] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:38.037] Packages: 1 packages (‘future.apply’)
[13:21:38.037] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:38.037] Resolved: FALSE
[13:21:38.037] Value: <not collected>
[13:21:38.037] Conditions captured: <none>
[13:21:38.037] Early signaling: FALSE
[13:21:38.037] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:38.037] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:38.049] Chunk #2 of 2 ... DONE
[13:21:38.049] Launching 2 futures (chunks) ... DONE
[13:21:38.049] Resolving 2 futures (chunks) ...
[13:21:38.049] resolve() on list ...
[13:21:38.050]  recursive: 0
[13:21:38.050]  length: 2
[13:21:38.050] 
[13:21:38.050] receiveMessageFromWorker() for ClusterFuture ...
[13:21:38.051] - Validating connection of MultisessionFuture
[13:21:38.051] - received message: FutureResult
[13:21:38.051] - Received FutureResult
[13:21:38.051] - Erased future from FutureRegistry
[13:21:38.051] result() for ClusterFuture ...
[13:21:38.051] - result already collected: FutureResult
[13:21:38.051] result() for ClusterFuture ... done
[13:21:38.051] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:38.051] Future #1
[13:21:38.052] result() for ClusterFuture ...
[13:21:38.052] - result already collected: FutureResult
[13:21:38.052] result() for ClusterFuture ... done
[13:21:38.052] result() for ClusterFuture ...
[13:21:38.052] - result already collected: FutureResult
[13:21:38.052] result() for ClusterFuture ... done
[13:21:38.052] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:21:38.052] - nx: 2
[13:21:38.052] - relay: TRUE
[13:21:38.052] - stdout: TRUE
[13:21:38.052] - signal: TRUE
[13:21:38.053] - resignal: FALSE
[13:21:38.053] - force: TRUE
[13:21:38.053] - relayed: [n=2] FALSE, FALSE
[13:21:38.053] - queued futures: [n=2] FALSE, FALSE
[13:21:38.053]  - until=1
[13:21:38.053]  - relaying element #1
[13:21:38.053] result() for ClusterFuture ...
[13:21:38.053] - result already collected: FutureResult
[13:21:38.053] result() for ClusterFuture ... done
[13:21:38.053] result() for ClusterFuture ...
[13:21:38.053] - result already collected: FutureResult
[13:21:38.053] result() for ClusterFuture ... done
[13:21:38.054] result() for ClusterFuture ...
[13:21:38.054] - result already collected: FutureResult
[13:21:38.054] result() for ClusterFuture ... done
[13:21:38.054] result() for ClusterFuture ...
[13:21:38.054] - result already collected: FutureResult
[13:21:38.054] result() for ClusterFuture ... done
[13:21:38.054] - relayed: [n=2] TRUE, FALSE
[13:21:38.054] - queued futures: [n=2] TRUE, FALSE
[13:21:38.054] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:21:38.054]  length: 1 (resolved future 1)
[13:21:38.086] receiveMessageFromWorker() for ClusterFuture ...
[13:21:38.086] - Validating connection of MultisessionFuture
[13:21:38.086] - received message: FutureResult
[13:21:38.086] - Received FutureResult
[13:21:38.086] - Erased future from FutureRegistry
[13:21:38.086] result() for ClusterFuture ...
[13:21:38.087] - result already collected: FutureResult
[13:21:38.087] result() for ClusterFuture ... done
[13:21:38.087] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:38.087] Future #2
[13:21:38.087] result() for ClusterFuture ...
[13:21:38.087] - result already collected: FutureResult
[13:21:38.087] result() for ClusterFuture ... done
[13:21:38.087] result() for ClusterFuture ...
[13:21:38.087] - result already collected: FutureResult
[13:21:38.087] result() for ClusterFuture ... done
[13:21:38.088] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:21:38.088] - nx: 2
[13:21:38.088] - relay: TRUE
[13:21:38.088] - stdout: TRUE
[13:21:38.088] - signal: TRUE
[13:21:38.088] - resignal: FALSE
[13:21:38.088] - force: TRUE
[13:21:38.088] - relayed: [n=2] TRUE, FALSE
[13:21:38.088] - queued futures: [n=2] TRUE, FALSE
[13:21:38.088]  - until=2
[13:21:38.088]  - relaying element #2
[13:21:38.089] result() for ClusterFuture ...
[13:21:38.089] - result already collected: FutureResult
[13:21:38.089] result() for ClusterFuture ... done
[13:21:38.089] result() for ClusterFuture ...
[13:21:38.089] - result already collected: FutureResult
[13:21:38.089] result() for ClusterFuture ... done
[13:21:38.089] result() for ClusterFuture ...
[13:21:38.089] - result already collected: FutureResult
[13:21:38.089] result() for ClusterFuture ... done
[13:21:38.089] result() for ClusterFuture ...
[13:21:38.089] - result already collected: FutureResult
[13:21:38.090] result() for ClusterFuture ... done
[13:21:38.090] - relayed: [n=2] TRUE, TRUE
[13:21:38.090] - queued futures: [n=2] TRUE, TRUE
[13:21:38.090] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:21:38.090]  length: 0 (resolved future 2)
[13:21:38.090] Relaying remaining futures
[13:21:38.090] signalConditionsASAP(NULL, pos=0) ...
[13:21:38.090] - nx: 2
[13:21:38.090] - relay: TRUE
[13:21:38.090] - stdout: TRUE
[13:21:38.090] - signal: TRUE
[13:21:38.091] - resignal: FALSE
[13:21:38.091] - force: TRUE
[13:21:38.091] - relayed: [n=2] TRUE, TRUE
[13:21:38.091] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:21:38.091] - relayed: [n=2] TRUE, TRUE
[13:21:38.091] - queued futures: [n=2] TRUE, TRUE
[13:21:38.091] signalConditionsASAP(NULL, pos=0) ... done
[13:21:38.091] resolve() on list ... DONE
[13:21:38.091] result() for ClusterFuture ...
[13:21:38.091] - result already collected: FutureResult
[13:21:38.091] result() for ClusterFuture ... done
[13:21:38.092] result() for ClusterFuture ...
[13:21:38.092] - result already collected: FutureResult
[13:21:38.092] result() for ClusterFuture ... done
[13:21:38.092] result() for ClusterFuture ...
[13:21:38.092] - result already collected: FutureResult
[13:21:38.092] result() for ClusterFuture ... done
[13:21:38.092] result() for ClusterFuture ...
[13:21:38.092] - result already collected: FutureResult
[13:21:38.092] result() for ClusterFuture ... done
[13:21:38.092]  - Number of value chunks collected: 2
[13:21:38.093] Resolving 2 futures (chunks) ... DONE
[13:21:38.093] Reducing values from 2 chunks ...
[13:21:38.093]  - Number of values collected after concatenation: 10
[13:21:38.093]  - Number of values expected: 10
[13:21:38.093] Reducing values from 2 chunks ... DONE
[13:21:38.093] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[13:21:38.094] future_lapply() ...
[13:21:38.099] Number of chunks: 2
[13:21:38.099] getGlobalsAndPackagesXApply() ...
[13:21:38.099]  - future.globals: TRUE
[13:21:38.100] getGlobalsAndPackages() ...
[13:21:38.100] Searching for globals...
[13:21:38.103] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[13:21:38.103] Searching for globals ... DONE
[13:21:38.104] Resolving globals: FALSE
[13:21:38.104] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[13:21:38.105] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:38.105] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:38.105] - packages: [1] ‘future.apply’
[13:21:38.105] getGlobalsAndPackages() ... DONE
[13:21:38.105]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:38.105]  - needed namespaces: [n=1] ‘future.apply’
[13:21:38.106] Finding globals ... DONE
[13:21:38.106]  - use_args: TRUE
[13:21:38.106]  - Getting '...' globals ...
[13:21:38.106] resolve() on list ...
[13:21:38.106]  recursive: 0
[13:21:38.106]  length: 1
[13:21:38.106]  elements: ‘...’
[13:21:38.106]  length: 0 (resolved future 1)
[13:21:38.107] resolve() on list ... DONE
[13:21:38.107]    - '...' content: [n=0] 
[13:21:38.107] List of 1
[13:21:38.107]  $ ...: list()
[13:21:38.107]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:38.107]  - attr(*, "where")=List of 1
[13:21:38.107]   ..$ ...:<environment: 0x563b7093c5e0> 
[13:21:38.107]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:38.107]  - attr(*, "resolved")= logi TRUE
[13:21:38.107]  - attr(*, "total_size")= num NA
[13:21:38.109]  - Getting '...' globals ... DONE
[13:21:38.109] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:38.110] List of 8
[13:21:38.110]  $ ...future.FUN:function (x, ...)  
[13:21:38.110]  $ x_FUN        :function (x)  
[13:21:38.110]  $ times        : int 2
[13:21:38.110]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:38.110]  $ stop_if_not  :function (...)  
[13:21:38.110]  $ dim          : NULL
[13:21:38.110]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:21:38.110]  $ ...          : list()
[13:21:38.110]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:38.110]  - attr(*, "where")=List of 8
[13:21:38.110]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:38.110]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:38.110]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:38.110]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:38.110]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:38.110]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:38.110]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:38.110]   ..$ ...          :<environment: 0x563b7093c5e0> 
[13:21:38.110]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:38.110]  - attr(*, "resolved")= logi FALSE
[13:21:38.110]  - attr(*, "total_size")= num 96456
[13:21:38.115] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:21:38.115] getGlobalsAndPackagesXApply() ... DONE
[13:21:38.115] Number of futures (= number of chunks): 2
[13:21:38.115] Launching 2 futures (chunks) ...
[13:21:38.115] Chunk #1 of 2 ...
[13:21:38.115]  - Finding globals in 'X' for chunk #1 ...
[13:21:38.116] getGlobalsAndPackages() ...
[13:21:38.116] Searching for globals...
[13:21:38.116] 
[13:21:38.116] Searching for globals ... DONE
[13:21:38.116] - globals: [0] <none>
[13:21:38.116] getGlobalsAndPackages() ... DONE
[13:21:38.116]    + additional globals found: [n=0] 
[13:21:38.116]    + additional namespaces needed: [n=0] 
[13:21:38.116]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:38.117]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:38.117]  - seeds: <none>
[13:21:38.117]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:38.117] getGlobalsAndPackages() ...
[13:21:38.117] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:38.117] Resolving globals: FALSE
[13:21:38.117] Tweak future expression to call with '...' arguments ...
[13:21:38.117] {
[13:21:38.117]     do.call(function(...) {
[13:21:38.117]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:38.117]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:38.117]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:38.117]             on.exit(options(oopts), add = TRUE)
[13:21:38.117]         }
[13:21:38.117]         {
[13:21:38.117]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:38.117]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:38.117]                 ...future.FUN(...future.X_jj, ...)
[13:21:38.117]             })
[13:21:38.117]         }
[13:21:38.117]     }, args = future.call.arguments)
[13:21:38.117] }
[13:21:38.118] Tweak future expression to call with '...' arguments ... DONE
[13:21:38.118] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:38.118] - packages: [1] ‘future.apply’
[13:21:38.118] getGlobalsAndPackages() ... DONE
[13:21:38.119] run() for ‘Future’ ...
[13:21:38.119] - state: ‘created’
[13:21:38.119] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:38.134] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:38.134] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:38.134]   - Field: ‘node’
[13:21:38.134]   - Field: ‘label’
[13:21:38.134]   - Field: ‘local’
[13:21:38.134]   - Field: ‘owner’
[13:21:38.135]   - Field: ‘envir’
[13:21:38.135]   - Field: ‘workers’
[13:21:38.135]   - Field: ‘packages’
[13:21:38.135]   - Field: ‘gc’
[13:21:38.135]   - Field: ‘conditions’
[13:21:38.135]   - Field: ‘persistent’
[13:21:38.135]   - Field: ‘expr’
[13:21:38.135]   - Field: ‘uuid’
[13:21:38.135]   - Field: ‘seed’
[13:21:38.135]   - Field: ‘version’
[13:21:38.135]   - Field: ‘result’
[13:21:38.136]   - Field: ‘asynchronous’
[13:21:38.136]   - Field: ‘calls’
[13:21:38.136]   - Field: ‘globals’
[13:21:38.136]   - Field: ‘stdout’
[13:21:38.136]   - Field: ‘earlySignal’
[13:21:38.136]   - Field: ‘lazy’
[13:21:38.136]   - Field: ‘state’
[13:21:38.136] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:38.136] - Launch lazy future ...
[13:21:38.137] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:38.137] Packages needed by future strategies (n = 0): <none>
[13:21:38.137] {
[13:21:38.137]     {
[13:21:38.137]         {
[13:21:38.137]             ...future.startTime <- base::Sys.time()
[13:21:38.137]             {
[13:21:38.137]                 {
[13:21:38.137]                   {
[13:21:38.137]                     {
[13:21:38.137]                       {
[13:21:38.137]                         base::local({
[13:21:38.137]                           has_future <- base::requireNamespace("future", 
[13:21:38.137]                             quietly = TRUE)
[13:21:38.137]                           if (has_future) {
[13:21:38.137]                             ns <- base::getNamespace("future")
[13:21:38.137]                             version <- ns[[".package"]][["version"]]
[13:21:38.137]                             if (is.null(version)) 
[13:21:38.137]                               version <- utils::packageVersion("future")
[13:21:38.137]                           }
[13:21:38.137]                           else {
[13:21:38.137]                             version <- NULL
[13:21:38.137]                           }
[13:21:38.137]                           if (!has_future || version < "1.8.0") {
[13:21:38.137]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:38.137]                               "", base::R.version$version.string), 
[13:21:38.137]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:38.137]                                 base::R.version$platform, 8 * 
[13:21:38.137]                                   base::.Machine$sizeof.pointer), 
[13:21:38.137]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:38.137]                                 "release", "version")], collapse = " "), 
[13:21:38.137]                               hostname = base::Sys.info()[["nodename"]])
[13:21:38.137]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:38.137]                               info)
[13:21:38.137]                             info <- base::paste(info, collapse = "; ")
[13:21:38.137]                             if (!has_future) {
[13:21:38.137]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:38.137]                                 info)
[13:21:38.137]                             }
[13:21:38.137]                             else {
[13:21:38.137]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:38.137]                                 info, version)
[13:21:38.137]                             }
[13:21:38.137]                             base::stop(msg)
[13:21:38.137]                           }
[13:21:38.137]                         })
[13:21:38.137]                       }
[13:21:38.137]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:38.137]                       base::options(mc.cores = 1L)
[13:21:38.137]                     }
[13:21:38.137]                     base::local({
[13:21:38.137]                       for (pkg in "future.apply") {
[13:21:38.137]                         base::loadNamespace(pkg)
[13:21:38.137]                         base::library(pkg, character.only = TRUE)
[13:21:38.137]                       }
[13:21:38.137]                     })
[13:21:38.137]                   }
[13:21:38.137]                   options(future.plan = NULL)
[13:21:38.137]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:38.137]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:38.137]                 }
[13:21:38.137]                 ...future.workdir <- getwd()
[13:21:38.137]             }
[13:21:38.137]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:38.137]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:38.137]         }
[13:21:38.137]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:38.137]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:38.137]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:38.137]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:38.137]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:38.137]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:38.137]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:38.137]             base::names(...future.oldOptions))
[13:21:38.137]     }
[13:21:38.137]     if (FALSE) {
[13:21:38.137]     }
[13:21:38.137]     else {
[13:21:38.137]         if (TRUE) {
[13:21:38.137]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:38.137]                 open = "w")
[13:21:38.137]         }
[13:21:38.137]         else {
[13:21:38.137]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:38.137]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:38.137]         }
[13:21:38.137]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:38.137]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:38.137]             base::sink(type = "output", split = FALSE)
[13:21:38.137]             base::close(...future.stdout)
[13:21:38.137]         }, add = TRUE)
[13:21:38.137]     }
[13:21:38.137]     ...future.frame <- base::sys.nframe()
[13:21:38.137]     ...future.conditions <- base::list()
[13:21:38.137]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:38.137]     if (FALSE) {
[13:21:38.137]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:38.137]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:38.137]     }
[13:21:38.137]     ...future.result <- base::tryCatch({
[13:21:38.137]         base::withCallingHandlers({
[13:21:38.137]             ...future.value <- base::withVisible(base::local({
[13:21:38.137]                 ...future.makeSendCondition <- base::local({
[13:21:38.137]                   sendCondition <- NULL
[13:21:38.137]                   function(frame = 1L) {
[13:21:38.137]                     if (is.function(sendCondition)) 
[13:21:38.137]                       return(sendCondition)
[13:21:38.137]                     ns <- getNamespace("parallel")
[13:21:38.137]                     if (exists("sendData", mode = "function", 
[13:21:38.137]                       envir = ns)) {
[13:21:38.137]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:38.137]                         envir = ns)
[13:21:38.137]                       envir <- sys.frame(frame)
[13:21:38.137]                       master <- NULL
[13:21:38.137]                       while (!identical(envir, .GlobalEnv) && 
[13:21:38.137]                         !identical(envir, emptyenv())) {
[13:21:38.137]                         if (exists("master", mode = "list", envir = envir, 
[13:21:38.137]                           inherits = FALSE)) {
[13:21:38.137]                           master <- get("master", mode = "list", 
[13:21:38.137]                             envir = envir, inherits = FALSE)
[13:21:38.137]                           if (inherits(master, c("SOCKnode", 
[13:21:38.137]                             "SOCK0node"))) {
[13:21:38.137]                             sendCondition <<- function(cond) {
[13:21:38.137]                               data <- list(type = "VALUE", value = cond, 
[13:21:38.137]                                 success = TRUE)
[13:21:38.137]                               parallel_sendData(master, data)
[13:21:38.137]                             }
[13:21:38.137]                             return(sendCondition)
[13:21:38.137]                           }
[13:21:38.137]                         }
[13:21:38.137]                         frame <- frame + 1L
[13:21:38.137]                         envir <- sys.frame(frame)
[13:21:38.137]                       }
[13:21:38.137]                     }
[13:21:38.137]                     sendCondition <<- function(cond) NULL
[13:21:38.137]                   }
[13:21:38.137]                 })
[13:21:38.137]                 withCallingHandlers({
[13:21:38.137]                   {
[13:21:38.137]                     do.call(function(...) {
[13:21:38.137]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:38.137]                       if (!identical(...future.globals.maxSize.org, 
[13:21:38.137]                         ...future.globals.maxSize)) {
[13:21:38.137]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:38.137]                         on.exit(options(oopts), add = TRUE)
[13:21:38.137]                       }
[13:21:38.137]                       {
[13:21:38.137]                         lapply(seq_along(...future.elements_ii), 
[13:21:38.137]                           FUN = function(jj) {
[13:21:38.137]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:38.137]                             ...future.FUN(...future.X_jj, ...)
[13:21:38.137]                           })
[13:21:38.137]                       }
[13:21:38.137]                     }, args = future.call.arguments)
[13:21:38.137]                   }
[13:21:38.137]                 }, immediateCondition = function(cond) {
[13:21:38.137]                   sendCondition <- ...future.makeSendCondition()
[13:21:38.137]                   sendCondition(cond)
[13:21:38.137]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:38.137]                   {
[13:21:38.137]                     inherits <- base::inherits
[13:21:38.137]                     invokeRestart <- base::invokeRestart
[13:21:38.137]                     is.null <- base::is.null
[13:21:38.137]                     muffled <- FALSE
[13:21:38.137]                     if (inherits(cond, "message")) {
[13:21:38.137]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:38.137]                       if (muffled) 
[13:21:38.137]                         invokeRestart("muffleMessage")
[13:21:38.137]                     }
[13:21:38.137]                     else if (inherits(cond, "warning")) {
[13:21:38.137]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:38.137]                       if (muffled) 
[13:21:38.137]                         invokeRestart("muffleWarning")
[13:21:38.137]                     }
[13:21:38.137]                     else if (inherits(cond, "condition")) {
[13:21:38.137]                       if (!is.null(pattern)) {
[13:21:38.137]                         computeRestarts <- base::computeRestarts
[13:21:38.137]                         grepl <- base::grepl
[13:21:38.137]                         restarts <- computeRestarts(cond)
[13:21:38.137]                         for (restart in restarts) {
[13:21:38.137]                           name <- restart$name
[13:21:38.137]                           if (is.null(name)) 
[13:21:38.137]                             next
[13:21:38.137]                           if (!grepl(pattern, name)) 
[13:21:38.137]                             next
[13:21:38.137]                           invokeRestart(restart)
[13:21:38.137]                           muffled <- TRUE
[13:21:38.137]                           break
[13:21:38.137]                         }
[13:21:38.137]                       }
[13:21:38.137]                     }
[13:21:38.137]                     invisible(muffled)
[13:21:38.137]                   }
[13:21:38.137]                   muffleCondition(cond)
[13:21:38.137]                 })
[13:21:38.137]             }))
[13:21:38.137]             future::FutureResult(value = ...future.value$value, 
[13:21:38.137]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:38.137]                   ...future.rng), globalenv = if (FALSE) 
[13:21:38.137]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:38.137]                     ...future.globalenv.names))
[13:21:38.137]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:38.137]         }, condition = base::local({
[13:21:38.137]             c <- base::c
[13:21:38.137]             inherits <- base::inherits
[13:21:38.137]             invokeRestart <- base::invokeRestart
[13:21:38.137]             length <- base::length
[13:21:38.137]             list <- base::list
[13:21:38.137]             seq.int <- base::seq.int
[13:21:38.137]             signalCondition <- base::signalCondition
[13:21:38.137]             sys.calls <- base::sys.calls
[13:21:38.137]             `[[` <- base::`[[`
[13:21:38.137]             `+` <- base::`+`
[13:21:38.137]             `<<-` <- base::`<<-`
[13:21:38.137]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:38.137]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:38.137]                   3L)]
[13:21:38.137]             }
[13:21:38.137]             function(cond) {
[13:21:38.137]                 is_error <- inherits(cond, "error")
[13:21:38.137]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:38.137]                   NULL)
[13:21:38.137]                 if (is_error) {
[13:21:38.137]                   sessionInformation <- function() {
[13:21:38.137]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:38.137]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:38.137]                       search = base::search(), system = base::Sys.info())
[13:21:38.137]                   }
[13:21:38.137]                   ...future.conditions[[length(...future.conditions) + 
[13:21:38.137]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:38.137]                     cond$call), session = sessionInformation(), 
[13:21:38.137]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:38.137]                   signalCondition(cond)
[13:21:38.137]                 }
[13:21:38.137]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:38.137]                 "immediateCondition"))) {
[13:21:38.137]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:38.137]                   ...future.conditions[[length(...future.conditions) + 
[13:21:38.137]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:38.137]                   if (TRUE && !signal) {
[13:21:38.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:38.137]                     {
[13:21:38.137]                       inherits <- base::inherits
[13:21:38.137]                       invokeRestart <- base::invokeRestart
[13:21:38.137]                       is.null <- base::is.null
[13:21:38.137]                       muffled <- FALSE
[13:21:38.137]                       if (inherits(cond, "message")) {
[13:21:38.137]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:38.137]                         if (muffled) 
[13:21:38.137]                           invokeRestart("muffleMessage")
[13:21:38.137]                       }
[13:21:38.137]                       else if (inherits(cond, "warning")) {
[13:21:38.137]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:38.137]                         if (muffled) 
[13:21:38.137]                           invokeRestart("muffleWarning")
[13:21:38.137]                       }
[13:21:38.137]                       else if (inherits(cond, "condition")) {
[13:21:38.137]                         if (!is.null(pattern)) {
[13:21:38.137]                           computeRestarts <- base::computeRestarts
[13:21:38.137]                           grepl <- base::grepl
[13:21:38.137]                           restarts <- computeRestarts(cond)
[13:21:38.137]                           for (restart in restarts) {
[13:21:38.137]                             name <- restart$name
[13:21:38.137]                             if (is.null(name)) 
[13:21:38.137]                               next
[13:21:38.137]                             if (!grepl(pattern, name)) 
[13:21:38.137]                               next
[13:21:38.137]                             invokeRestart(restart)
[13:21:38.137]                             muffled <- TRUE
[13:21:38.137]                             break
[13:21:38.137]                           }
[13:21:38.137]                         }
[13:21:38.137]                       }
[13:21:38.137]                       invisible(muffled)
[13:21:38.137]                     }
[13:21:38.137]                     muffleCondition(cond, pattern = "^muffle")
[13:21:38.137]                   }
[13:21:38.137]                 }
[13:21:38.137]                 else {
[13:21:38.137]                   if (TRUE) {
[13:21:38.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:38.137]                     {
[13:21:38.137]                       inherits <- base::inherits
[13:21:38.137]                       invokeRestart <- base::invokeRestart
[13:21:38.137]                       is.null <- base::is.null
[13:21:38.137]                       muffled <- FALSE
[13:21:38.137]                       if (inherits(cond, "message")) {
[13:21:38.137]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:38.137]                         if (muffled) 
[13:21:38.137]                           invokeRestart("muffleMessage")
[13:21:38.137]                       }
[13:21:38.137]                       else if (inherits(cond, "warning")) {
[13:21:38.137]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:38.137]                         if (muffled) 
[13:21:38.137]                           invokeRestart("muffleWarning")
[13:21:38.137]                       }
[13:21:38.137]                       else if (inherits(cond, "condition")) {
[13:21:38.137]                         if (!is.null(pattern)) {
[13:21:38.137]                           computeRestarts <- base::computeRestarts
[13:21:38.137]                           grepl <- base::grepl
[13:21:38.137]                           restarts <- computeRestarts(cond)
[13:21:38.137]                           for (restart in restarts) {
[13:21:38.137]                             name <- restart$name
[13:21:38.137]                             if (is.null(name)) 
[13:21:38.137]                               next
[13:21:38.137]                             if (!grepl(pattern, name)) 
[13:21:38.137]                               next
[13:21:38.137]                             invokeRestart(restart)
[13:21:38.137]                             muffled <- TRUE
[13:21:38.137]                             break
[13:21:38.137]                           }
[13:21:38.137]                         }
[13:21:38.137]                       }
[13:21:38.137]                       invisible(muffled)
[13:21:38.137]                     }
[13:21:38.137]                     muffleCondition(cond, pattern = "^muffle")
[13:21:38.137]                   }
[13:21:38.137]                 }
[13:21:38.137]             }
[13:21:38.137]         }))
[13:21:38.137]     }, error = function(ex) {
[13:21:38.137]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:38.137]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:38.137]                 ...future.rng), started = ...future.startTime, 
[13:21:38.137]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:38.137]             version = "1.8"), class = "FutureResult")
[13:21:38.137]     }, finally = {
[13:21:38.137]         if (!identical(...future.workdir, getwd())) 
[13:21:38.137]             setwd(...future.workdir)
[13:21:38.137]         {
[13:21:38.137]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:38.137]                 ...future.oldOptions$nwarnings <- NULL
[13:21:38.137]             }
[13:21:38.137]             base::options(...future.oldOptions)
[13:21:38.137]             if (.Platform$OS.type == "windows") {
[13:21:38.137]                 old_names <- names(...future.oldEnvVars)
[13:21:38.137]                 envs <- base::Sys.getenv()
[13:21:38.137]                 names <- names(envs)
[13:21:38.137]                 common <- intersect(names, old_names)
[13:21:38.137]                 added <- setdiff(names, old_names)
[13:21:38.137]                 removed <- setdiff(old_names, names)
[13:21:38.137]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:38.137]                   envs[common]]
[13:21:38.137]                 NAMES <- toupper(changed)
[13:21:38.137]                 args <- list()
[13:21:38.137]                 for (kk in seq_along(NAMES)) {
[13:21:38.137]                   name <- changed[[kk]]
[13:21:38.137]                   NAME <- NAMES[[kk]]
[13:21:38.137]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.137]                     next
[13:21:38.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:38.137]                 }
[13:21:38.137]                 NAMES <- toupper(added)
[13:21:38.137]                 for (kk in seq_along(NAMES)) {
[13:21:38.137]                   name <- added[[kk]]
[13:21:38.137]                   NAME <- NAMES[[kk]]
[13:21:38.137]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.137]                     next
[13:21:38.137]                   args[[name]] <- ""
[13:21:38.137]                 }
[13:21:38.137]                 NAMES <- toupper(removed)
[13:21:38.137]                 for (kk in seq_along(NAMES)) {
[13:21:38.137]                   name <- removed[[kk]]
[13:21:38.137]                   NAME <- NAMES[[kk]]
[13:21:38.137]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.137]                     next
[13:21:38.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:38.137]                 }
[13:21:38.137]                 if (length(args) > 0) 
[13:21:38.137]                   base::do.call(base::Sys.setenv, args = args)
[13:21:38.137]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:38.137]             }
[13:21:38.137]             else {
[13:21:38.137]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:38.137]             }
[13:21:38.137]             {
[13:21:38.137]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:38.137]                   0L) {
[13:21:38.137]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:38.137]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:38.137]                   base::options(opts)
[13:21:38.137]                 }
[13:21:38.137]                 {
[13:21:38.137]                   {
[13:21:38.137]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:38.137]                     NULL
[13:21:38.137]                   }
[13:21:38.137]                   options(future.plan = NULL)
[13:21:38.137]                   if (is.na(NA_character_)) 
[13:21:38.137]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:38.137]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:38.137]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:38.137]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:38.137]                     envir = parent.frame()) 
[13:21:38.137]                   {
[13:21:38.137]                     if (is.function(workers)) 
[13:21:38.137]                       workers <- workers()
[13:21:38.137]                     workers <- structure(as.integer(workers), 
[13:21:38.137]                       class = class(workers))
[13:21:38.137]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:38.137]                       workers >= 1)
[13:21:38.137]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:38.137]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:38.137]                     }
[13:21:38.137]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:38.137]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:38.137]                       envir = envir)
[13:21:38.137]                     if (!future$lazy) 
[13:21:38.137]                       future <- run(future)
[13:21:38.137]                     invisible(future)
[13:21:38.137]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:38.137]                 }
[13:21:38.137]             }
[13:21:38.137]         }
[13:21:38.137]     })
[13:21:38.137]     if (TRUE) {
[13:21:38.137]         base::sink(type = "output", split = FALSE)
[13:21:38.137]         if (TRUE) {
[13:21:38.137]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:38.137]         }
[13:21:38.137]         else {
[13:21:38.137]             ...future.result["stdout"] <- base::list(NULL)
[13:21:38.137]         }
[13:21:38.137]         base::close(...future.stdout)
[13:21:38.137]         ...future.stdout <- NULL
[13:21:38.137]     }
[13:21:38.137]     ...future.result$conditions <- ...future.conditions
[13:21:38.137]     ...future.result$finished <- base::Sys.time()
[13:21:38.137]     ...future.result
[13:21:38.137] }
[13:21:38.140] Exporting 11 global objects (94.20 KiB) to cluster node #1 ...
[13:21:38.141] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:21:38.184] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:21:38.185] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #1 ...
[13:21:38.185] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #1 ... DONE
[13:21:38.185] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:21:38.186] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:21:38.186] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:21:38.228] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:21:38.228] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:21:38.272] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:21:38.273] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[13:21:38.273] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[13:21:38.273] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[13:21:38.274] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[13:21:38.274] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:21:38.274] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:21:38.274] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[13:21:38.275] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[13:21:38.275] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:21:38.275] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:21:38.276] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:21:38.276] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:21:38.276] Exporting 11 global objects (94.20 KiB) to cluster node #1 ... DONE
[13:21:38.277] MultisessionFuture started
[13:21:38.277] - Launch lazy future ... done
[13:21:38.277] run() for ‘MultisessionFuture’ ... done
[13:21:38.277] Created future:
[13:21:38.277] MultisessionFuture:
[13:21:38.277] Label: ‘future_vapply-1’
[13:21:38.277] Expression:
[13:21:38.277] {
[13:21:38.277]     do.call(function(...) {
[13:21:38.277]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:38.277]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:38.277]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:38.277]             on.exit(options(oopts), add = TRUE)
[13:21:38.277]         }
[13:21:38.277]         {
[13:21:38.277]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:38.277]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:38.277]                 ...future.FUN(...future.X_jj, ...)
[13:21:38.277]             })
[13:21:38.277]         }
[13:21:38.277]     }, args = future.call.arguments)
[13:21:38.277] }
[13:21:38.277] Lazy evaluation: FALSE
[13:21:38.277] Asynchronous evaluation: TRUE
[13:21:38.277] Local evaluation: TRUE
[13:21:38.277] Environment: R_GlobalEnv
[13:21:38.277] Capture standard output: TRUE
[13:21:38.277] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:38.277] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:38.277] Packages: 1 packages (‘future.apply’)
[13:21:38.277] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:38.277] Resolved: FALSE
[13:21:38.277] Value: <not collected>
[13:21:38.277] Conditions captured: <none>
[13:21:38.277] Early signaling: FALSE
[13:21:38.277] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:38.277] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:38.289] Chunk #1 of 2 ... DONE
[13:21:38.289] Chunk #2 of 2 ...
[13:21:38.289]  - Finding globals in 'X' for chunk #2 ...
[13:21:38.290] getGlobalsAndPackages() ...
[13:21:38.290] Searching for globals...
[13:21:38.290] 
[13:21:38.290] Searching for globals ... DONE
[13:21:38.290] - globals: [0] <none>
[13:21:38.290] getGlobalsAndPackages() ... DONE
[13:21:38.290]    + additional globals found: [n=0] 
[13:21:38.290]    + additional namespaces needed: [n=0] 
[13:21:38.291]  - Finding globals in 'X' for chunk #2 ... DONE
[13:21:38.293]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:38.293]  - seeds: <none>
[13:21:38.293]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:38.293] getGlobalsAndPackages() ...
[13:21:38.293] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:38.293] Resolving globals: FALSE
[13:21:38.294] Tweak future expression to call with '...' arguments ...
[13:21:38.294] {
[13:21:38.294]     do.call(function(...) {
[13:21:38.294]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:38.294]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:38.294]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:38.294]             on.exit(options(oopts), add = TRUE)
[13:21:38.294]         }
[13:21:38.294]         {
[13:21:38.294]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:38.294]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:38.294]                 ...future.FUN(...future.X_jj, ...)
[13:21:38.294]             })
[13:21:38.294]         }
[13:21:38.294]     }, args = future.call.arguments)
[13:21:38.294] }
[13:21:38.294] Tweak future expression to call with '...' arguments ... DONE
[13:21:38.295] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:38.295] - packages: [1] ‘future.apply’
[13:21:38.295] getGlobalsAndPackages() ... DONE
[13:21:38.295] run() for ‘Future’ ...
[13:21:38.295] - state: ‘created’
[13:21:38.295] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:38.310] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:38.310] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:38.310]   - Field: ‘node’
[13:21:38.310]   - Field: ‘label’
[13:21:38.311]   - Field: ‘local’
[13:21:38.311]   - Field: ‘owner’
[13:21:38.311]   - Field: ‘envir’
[13:21:38.311]   - Field: ‘workers’
[13:21:38.311]   - Field: ‘packages’
[13:21:38.311]   - Field: ‘gc’
[13:21:38.311]   - Field: ‘conditions’
[13:21:38.311]   - Field: ‘persistent’
[13:21:38.311]   - Field: ‘expr’
[13:21:38.311]   - Field: ‘uuid’
[13:21:38.311]   - Field: ‘seed’
[13:21:38.312]   - Field: ‘version’
[13:21:38.312]   - Field: ‘result’
[13:21:38.312]   - Field: ‘asynchronous’
[13:21:38.312]   - Field: ‘calls’
[13:21:38.312]   - Field: ‘globals’
[13:21:38.312]   - Field: ‘stdout’
[13:21:38.312]   - Field: ‘earlySignal’
[13:21:38.312]   - Field: ‘lazy’
[13:21:38.312]   - Field: ‘state’
[13:21:38.312] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:38.313] - Launch lazy future ...
[13:21:38.313] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:38.313] Packages needed by future strategies (n = 0): <none>
[13:21:38.314] {
[13:21:38.314]     {
[13:21:38.314]         {
[13:21:38.314]             ...future.startTime <- base::Sys.time()
[13:21:38.314]             {
[13:21:38.314]                 {
[13:21:38.314]                   {
[13:21:38.314]                     {
[13:21:38.314]                       {
[13:21:38.314]                         base::local({
[13:21:38.314]                           has_future <- base::requireNamespace("future", 
[13:21:38.314]                             quietly = TRUE)
[13:21:38.314]                           if (has_future) {
[13:21:38.314]                             ns <- base::getNamespace("future")
[13:21:38.314]                             version <- ns[[".package"]][["version"]]
[13:21:38.314]                             if (is.null(version)) 
[13:21:38.314]                               version <- utils::packageVersion("future")
[13:21:38.314]                           }
[13:21:38.314]                           else {
[13:21:38.314]                             version <- NULL
[13:21:38.314]                           }
[13:21:38.314]                           if (!has_future || version < "1.8.0") {
[13:21:38.314]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:38.314]                               "", base::R.version$version.string), 
[13:21:38.314]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:38.314]                                 base::R.version$platform, 8 * 
[13:21:38.314]                                   base::.Machine$sizeof.pointer), 
[13:21:38.314]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:38.314]                                 "release", "version")], collapse = " "), 
[13:21:38.314]                               hostname = base::Sys.info()[["nodename"]])
[13:21:38.314]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:38.314]                               info)
[13:21:38.314]                             info <- base::paste(info, collapse = "; ")
[13:21:38.314]                             if (!has_future) {
[13:21:38.314]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:38.314]                                 info)
[13:21:38.314]                             }
[13:21:38.314]                             else {
[13:21:38.314]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:38.314]                                 info, version)
[13:21:38.314]                             }
[13:21:38.314]                             base::stop(msg)
[13:21:38.314]                           }
[13:21:38.314]                         })
[13:21:38.314]                       }
[13:21:38.314]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:38.314]                       base::options(mc.cores = 1L)
[13:21:38.314]                     }
[13:21:38.314]                     base::local({
[13:21:38.314]                       for (pkg in "future.apply") {
[13:21:38.314]                         base::loadNamespace(pkg)
[13:21:38.314]                         base::library(pkg, character.only = TRUE)
[13:21:38.314]                       }
[13:21:38.314]                     })
[13:21:38.314]                   }
[13:21:38.314]                   options(future.plan = NULL)
[13:21:38.314]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:38.314]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:38.314]                 }
[13:21:38.314]                 ...future.workdir <- getwd()
[13:21:38.314]             }
[13:21:38.314]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:38.314]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:38.314]         }
[13:21:38.314]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:38.314]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:38.314]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:38.314]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:38.314]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:38.314]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:38.314]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:38.314]             base::names(...future.oldOptions))
[13:21:38.314]     }
[13:21:38.314]     if (FALSE) {
[13:21:38.314]     }
[13:21:38.314]     else {
[13:21:38.314]         if (TRUE) {
[13:21:38.314]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:38.314]                 open = "w")
[13:21:38.314]         }
[13:21:38.314]         else {
[13:21:38.314]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:38.314]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:38.314]         }
[13:21:38.314]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:38.314]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:38.314]             base::sink(type = "output", split = FALSE)
[13:21:38.314]             base::close(...future.stdout)
[13:21:38.314]         }, add = TRUE)
[13:21:38.314]     }
[13:21:38.314]     ...future.frame <- base::sys.nframe()
[13:21:38.314]     ...future.conditions <- base::list()
[13:21:38.314]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:38.314]     if (FALSE) {
[13:21:38.314]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:38.314]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:38.314]     }
[13:21:38.314]     ...future.result <- base::tryCatch({
[13:21:38.314]         base::withCallingHandlers({
[13:21:38.314]             ...future.value <- base::withVisible(base::local({
[13:21:38.314]                 ...future.makeSendCondition <- base::local({
[13:21:38.314]                   sendCondition <- NULL
[13:21:38.314]                   function(frame = 1L) {
[13:21:38.314]                     if (is.function(sendCondition)) 
[13:21:38.314]                       return(sendCondition)
[13:21:38.314]                     ns <- getNamespace("parallel")
[13:21:38.314]                     if (exists("sendData", mode = "function", 
[13:21:38.314]                       envir = ns)) {
[13:21:38.314]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:38.314]                         envir = ns)
[13:21:38.314]                       envir <- sys.frame(frame)
[13:21:38.314]                       master <- NULL
[13:21:38.314]                       while (!identical(envir, .GlobalEnv) && 
[13:21:38.314]                         !identical(envir, emptyenv())) {
[13:21:38.314]                         if (exists("master", mode = "list", envir = envir, 
[13:21:38.314]                           inherits = FALSE)) {
[13:21:38.314]                           master <- get("master", mode = "list", 
[13:21:38.314]                             envir = envir, inherits = FALSE)
[13:21:38.314]                           if (inherits(master, c("SOCKnode", 
[13:21:38.314]                             "SOCK0node"))) {
[13:21:38.314]                             sendCondition <<- function(cond) {
[13:21:38.314]                               data <- list(type = "VALUE", value = cond, 
[13:21:38.314]                                 success = TRUE)
[13:21:38.314]                               parallel_sendData(master, data)
[13:21:38.314]                             }
[13:21:38.314]                             return(sendCondition)
[13:21:38.314]                           }
[13:21:38.314]                         }
[13:21:38.314]                         frame <- frame + 1L
[13:21:38.314]                         envir <- sys.frame(frame)
[13:21:38.314]                       }
[13:21:38.314]                     }
[13:21:38.314]                     sendCondition <<- function(cond) NULL
[13:21:38.314]                   }
[13:21:38.314]                 })
[13:21:38.314]                 withCallingHandlers({
[13:21:38.314]                   {
[13:21:38.314]                     do.call(function(...) {
[13:21:38.314]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:38.314]                       if (!identical(...future.globals.maxSize.org, 
[13:21:38.314]                         ...future.globals.maxSize)) {
[13:21:38.314]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:38.314]                         on.exit(options(oopts), add = TRUE)
[13:21:38.314]                       }
[13:21:38.314]                       {
[13:21:38.314]                         lapply(seq_along(...future.elements_ii), 
[13:21:38.314]                           FUN = function(jj) {
[13:21:38.314]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:38.314]                             ...future.FUN(...future.X_jj, ...)
[13:21:38.314]                           })
[13:21:38.314]                       }
[13:21:38.314]                     }, args = future.call.arguments)
[13:21:38.314]                   }
[13:21:38.314]                 }, immediateCondition = function(cond) {
[13:21:38.314]                   sendCondition <- ...future.makeSendCondition()
[13:21:38.314]                   sendCondition(cond)
[13:21:38.314]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:38.314]                   {
[13:21:38.314]                     inherits <- base::inherits
[13:21:38.314]                     invokeRestart <- base::invokeRestart
[13:21:38.314]                     is.null <- base::is.null
[13:21:38.314]                     muffled <- FALSE
[13:21:38.314]                     if (inherits(cond, "message")) {
[13:21:38.314]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:38.314]                       if (muffled) 
[13:21:38.314]                         invokeRestart("muffleMessage")
[13:21:38.314]                     }
[13:21:38.314]                     else if (inherits(cond, "warning")) {
[13:21:38.314]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:38.314]                       if (muffled) 
[13:21:38.314]                         invokeRestart("muffleWarning")
[13:21:38.314]                     }
[13:21:38.314]                     else if (inherits(cond, "condition")) {
[13:21:38.314]                       if (!is.null(pattern)) {
[13:21:38.314]                         computeRestarts <- base::computeRestarts
[13:21:38.314]                         grepl <- base::grepl
[13:21:38.314]                         restarts <- computeRestarts(cond)
[13:21:38.314]                         for (restart in restarts) {
[13:21:38.314]                           name <- restart$name
[13:21:38.314]                           if (is.null(name)) 
[13:21:38.314]                             next
[13:21:38.314]                           if (!grepl(pattern, name)) 
[13:21:38.314]                             next
[13:21:38.314]                           invokeRestart(restart)
[13:21:38.314]                           muffled <- TRUE
[13:21:38.314]                           break
[13:21:38.314]                         }
[13:21:38.314]                       }
[13:21:38.314]                     }
[13:21:38.314]                     invisible(muffled)
[13:21:38.314]                   }
[13:21:38.314]                   muffleCondition(cond)
[13:21:38.314]                 })
[13:21:38.314]             }))
[13:21:38.314]             future::FutureResult(value = ...future.value$value, 
[13:21:38.314]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:38.314]                   ...future.rng), globalenv = if (FALSE) 
[13:21:38.314]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:38.314]                     ...future.globalenv.names))
[13:21:38.314]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:38.314]         }, condition = base::local({
[13:21:38.314]             c <- base::c
[13:21:38.314]             inherits <- base::inherits
[13:21:38.314]             invokeRestart <- base::invokeRestart
[13:21:38.314]             length <- base::length
[13:21:38.314]             list <- base::list
[13:21:38.314]             seq.int <- base::seq.int
[13:21:38.314]             signalCondition <- base::signalCondition
[13:21:38.314]             sys.calls <- base::sys.calls
[13:21:38.314]             `[[` <- base::`[[`
[13:21:38.314]             `+` <- base::`+`
[13:21:38.314]             `<<-` <- base::`<<-`
[13:21:38.314]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:38.314]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:38.314]                   3L)]
[13:21:38.314]             }
[13:21:38.314]             function(cond) {
[13:21:38.314]                 is_error <- inherits(cond, "error")
[13:21:38.314]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:38.314]                   NULL)
[13:21:38.314]                 if (is_error) {
[13:21:38.314]                   sessionInformation <- function() {
[13:21:38.314]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:38.314]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:38.314]                       search = base::search(), system = base::Sys.info())
[13:21:38.314]                   }
[13:21:38.314]                   ...future.conditions[[length(...future.conditions) + 
[13:21:38.314]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:38.314]                     cond$call), session = sessionInformation(), 
[13:21:38.314]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:38.314]                   signalCondition(cond)
[13:21:38.314]                 }
[13:21:38.314]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:38.314]                 "immediateCondition"))) {
[13:21:38.314]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:38.314]                   ...future.conditions[[length(...future.conditions) + 
[13:21:38.314]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:38.314]                   if (TRUE && !signal) {
[13:21:38.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:38.314]                     {
[13:21:38.314]                       inherits <- base::inherits
[13:21:38.314]                       invokeRestart <- base::invokeRestart
[13:21:38.314]                       is.null <- base::is.null
[13:21:38.314]                       muffled <- FALSE
[13:21:38.314]                       if (inherits(cond, "message")) {
[13:21:38.314]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:38.314]                         if (muffled) 
[13:21:38.314]                           invokeRestart("muffleMessage")
[13:21:38.314]                       }
[13:21:38.314]                       else if (inherits(cond, "warning")) {
[13:21:38.314]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:38.314]                         if (muffled) 
[13:21:38.314]                           invokeRestart("muffleWarning")
[13:21:38.314]                       }
[13:21:38.314]                       else if (inherits(cond, "condition")) {
[13:21:38.314]                         if (!is.null(pattern)) {
[13:21:38.314]                           computeRestarts <- base::computeRestarts
[13:21:38.314]                           grepl <- base::grepl
[13:21:38.314]                           restarts <- computeRestarts(cond)
[13:21:38.314]                           for (restart in restarts) {
[13:21:38.314]                             name <- restart$name
[13:21:38.314]                             if (is.null(name)) 
[13:21:38.314]                               next
[13:21:38.314]                             if (!grepl(pattern, name)) 
[13:21:38.314]                               next
[13:21:38.314]                             invokeRestart(restart)
[13:21:38.314]                             muffled <- TRUE
[13:21:38.314]                             break
[13:21:38.314]                           }
[13:21:38.314]                         }
[13:21:38.314]                       }
[13:21:38.314]                       invisible(muffled)
[13:21:38.314]                     }
[13:21:38.314]                     muffleCondition(cond, pattern = "^muffle")
[13:21:38.314]                   }
[13:21:38.314]                 }
[13:21:38.314]                 else {
[13:21:38.314]                   if (TRUE) {
[13:21:38.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:38.314]                     {
[13:21:38.314]                       inherits <- base::inherits
[13:21:38.314]                       invokeRestart <- base::invokeRestart
[13:21:38.314]                       is.null <- base::is.null
[13:21:38.314]                       muffled <- FALSE
[13:21:38.314]                       if (inherits(cond, "message")) {
[13:21:38.314]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:38.314]                         if (muffled) 
[13:21:38.314]                           invokeRestart("muffleMessage")
[13:21:38.314]                       }
[13:21:38.314]                       else if (inherits(cond, "warning")) {
[13:21:38.314]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:38.314]                         if (muffled) 
[13:21:38.314]                           invokeRestart("muffleWarning")
[13:21:38.314]                       }
[13:21:38.314]                       else if (inherits(cond, "condition")) {
[13:21:38.314]                         if (!is.null(pattern)) {
[13:21:38.314]                           computeRestarts <- base::computeRestarts
[13:21:38.314]                           grepl <- base::grepl
[13:21:38.314]                           restarts <- computeRestarts(cond)
[13:21:38.314]                           for (restart in restarts) {
[13:21:38.314]                             name <- restart$name
[13:21:38.314]                             if (is.null(name)) 
[13:21:38.314]                               next
[13:21:38.314]                             if (!grepl(pattern, name)) 
[13:21:38.314]                               next
[13:21:38.314]                             invokeRestart(restart)
[13:21:38.314]                             muffled <- TRUE
[13:21:38.314]                             break
[13:21:38.314]                           }
[13:21:38.314]                         }
[13:21:38.314]                       }
[13:21:38.314]                       invisible(muffled)
[13:21:38.314]                     }
[13:21:38.314]                     muffleCondition(cond, pattern = "^muffle")
[13:21:38.314]                   }
[13:21:38.314]                 }
[13:21:38.314]             }
[13:21:38.314]         }))
[13:21:38.314]     }, error = function(ex) {
[13:21:38.314]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:38.314]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:38.314]                 ...future.rng), started = ...future.startTime, 
[13:21:38.314]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:38.314]             version = "1.8"), class = "FutureResult")
[13:21:38.314]     }, finally = {
[13:21:38.314]         if (!identical(...future.workdir, getwd())) 
[13:21:38.314]             setwd(...future.workdir)
[13:21:38.314]         {
[13:21:38.314]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:38.314]                 ...future.oldOptions$nwarnings <- NULL
[13:21:38.314]             }
[13:21:38.314]             base::options(...future.oldOptions)
[13:21:38.314]             if (.Platform$OS.type == "windows") {
[13:21:38.314]                 old_names <- names(...future.oldEnvVars)
[13:21:38.314]                 envs <- base::Sys.getenv()
[13:21:38.314]                 names <- names(envs)
[13:21:38.314]                 common <- intersect(names, old_names)
[13:21:38.314]                 added <- setdiff(names, old_names)
[13:21:38.314]                 removed <- setdiff(old_names, names)
[13:21:38.314]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:38.314]                   envs[common]]
[13:21:38.314]                 NAMES <- toupper(changed)
[13:21:38.314]                 args <- list()
[13:21:38.314]                 for (kk in seq_along(NAMES)) {
[13:21:38.314]                   name <- changed[[kk]]
[13:21:38.314]                   NAME <- NAMES[[kk]]
[13:21:38.314]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.314]                     next
[13:21:38.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:38.314]                 }
[13:21:38.314]                 NAMES <- toupper(added)
[13:21:38.314]                 for (kk in seq_along(NAMES)) {
[13:21:38.314]                   name <- added[[kk]]
[13:21:38.314]                   NAME <- NAMES[[kk]]
[13:21:38.314]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.314]                     next
[13:21:38.314]                   args[[name]] <- ""
[13:21:38.314]                 }
[13:21:38.314]                 NAMES <- toupper(removed)
[13:21:38.314]                 for (kk in seq_along(NAMES)) {
[13:21:38.314]                   name <- removed[[kk]]
[13:21:38.314]                   NAME <- NAMES[[kk]]
[13:21:38.314]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.314]                     next
[13:21:38.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:38.314]                 }
[13:21:38.314]                 if (length(args) > 0) 
[13:21:38.314]                   base::do.call(base::Sys.setenv, args = args)
[13:21:38.314]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:38.314]             }
[13:21:38.314]             else {
[13:21:38.314]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:38.314]             }
[13:21:38.314]             {
[13:21:38.314]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:38.314]                   0L) {
[13:21:38.314]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:38.314]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:38.314]                   base::options(opts)
[13:21:38.314]                 }
[13:21:38.314]                 {
[13:21:38.314]                   {
[13:21:38.314]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:38.314]                     NULL
[13:21:38.314]                   }
[13:21:38.314]                   options(future.plan = NULL)
[13:21:38.314]                   if (is.na(NA_character_)) 
[13:21:38.314]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:38.314]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:38.314]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:38.314]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:38.314]                     envir = parent.frame()) 
[13:21:38.314]                   {
[13:21:38.314]                     if (is.function(workers)) 
[13:21:38.314]                       workers <- workers()
[13:21:38.314]                     workers <- structure(as.integer(workers), 
[13:21:38.314]                       class = class(workers))
[13:21:38.314]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:38.314]                       workers >= 1)
[13:21:38.314]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:38.314]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:38.314]                     }
[13:21:38.314]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:38.314]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:38.314]                       envir = envir)
[13:21:38.314]                     if (!future$lazy) 
[13:21:38.314]                       future <- run(future)
[13:21:38.314]                     invisible(future)
[13:21:38.314]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:38.314]                 }
[13:21:38.314]             }
[13:21:38.314]         }
[13:21:38.314]     })
[13:21:38.314]     if (TRUE) {
[13:21:38.314]         base::sink(type = "output", split = FALSE)
[13:21:38.314]         if (TRUE) {
[13:21:38.314]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:38.314]         }
[13:21:38.314]         else {
[13:21:38.314]             ...future.result["stdout"] <- base::list(NULL)
[13:21:38.314]         }
[13:21:38.314]         base::close(...future.stdout)
[13:21:38.314]         ...future.stdout <- NULL
[13:21:38.314]     }
[13:21:38.314]     ...future.result$conditions <- ...future.conditions
[13:21:38.314]     ...future.result$finished <- base::Sys.time()
[13:21:38.314]     ...future.result
[13:21:38.314] }
[13:21:38.317] Exporting 11 global objects (94.20 KiB) to cluster node #2 ...
[13:21:38.317] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[13:21:38.360] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[13:21:38.361] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #2 ...
[13:21:38.361] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #2 ... DONE
[13:21:38.361] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[13:21:38.362] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[13:21:38.362] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[13:21:38.404] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[13:21:38.405] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[13:21:38.448] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[13:21:38.449] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[13:21:38.449] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[13:21:38.449] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[13:21:38.450] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[13:21:38.450] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:21:38.450] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:21:38.450] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[13:21:38.451] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[13:21:38.451] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:21:38.451] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:21:38.452] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:21:38.452] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:21:38.452] Exporting 11 global objects (94.20 KiB) to cluster node #2 ... DONE
[13:21:38.453] MultisessionFuture started
[13:21:38.453] - Launch lazy future ... done
[13:21:38.453] run() for ‘MultisessionFuture’ ... done
[13:21:38.453] Created future:
[13:21:38.454] MultisessionFuture:
[13:21:38.454] Label: ‘future_vapply-2’
[13:21:38.454] Expression:
[13:21:38.454] {
[13:21:38.454]     do.call(function(...) {
[13:21:38.454]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:38.454]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:38.454]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:38.454]             on.exit(options(oopts), add = TRUE)
[13:21:38.454]         }
[13:21:38.454]         {
[13:21:38.454]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:38.454]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:38.454]                 ...future.FUN(...future.X_jj, ...)
[13:21:38.454]             })
[13:21:38.454]         }
[13:21:38.454]     }, args = future.call.arguments)
[13:21:38.454] }
[13:21:38.454] Lazy evaluation: FALSE
[13:21:38.454] Asynchronous evaluation: TRUE
[13:21:38.454] Local evaluation: TRUE
[13:21:38.454] Environment: R_GlobalEnv
[13:21:38.454] Capture standard output: TRUE
[13:21:38.454] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:38.454] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:38.454] Packages: 1 packages (‘future.apply’)
[13:21:38.454] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:38.454] Resolved: FALSE
[13:21:38.454] Value: <not collected>
[13:21:38.454] Conditions captured: <none>
[13:21:38.454] Early signaling: FALSE
[13:21:38.454] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:38.454] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:38.466] Chunk #2 of 2 ... DONE
[13:21:38.466] Launching 2 futures (chunks) ... DONE
[13:21:38.466] Resolving 2 futures (chunks) ...
[13:21:38.466] resolve() on list ...
[13:21:38.466]  recursive: 0
[13:21:38.466]  length: 2
[13:21:38.466] 
[13:21:38.467] receiveMessageFromWorker() for ClusterFuture ...
[13:21:38.467] - Validating connection of MultisessionFuture
[13:21:38.467] - received message: FutureResult
[13:21:38.467] - Received FutureResult
[13:21:38.467] - Erased future from FutureRegistry
[13:21:38.467] result() for ClusterFuture ...
[13:21:38.468] - result already collected: FutureResult
[13:21:38.468] result() for ClusterFuture ... done
[13:21:38.468] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:38.468] Future #1
[13:21:38.468] result() for ClusterFuture ...
[13:21:38.468] - result already collected: FutureResult
[13:21:38.468] result() for ClusterFuture ... done
[13:21:38.468] result() for ClusterFuture ...
[13:21:38.468] - result already collected: FutureResult
[13:21:38.468] result() for ClusterFuture ... done
[13:21:38.469] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:21:38.469] - nx: 2
[13:21:38.469] - relay: TRUE
[13:21:38.469] - stdout: TRUE
[13:21:38.469] - signal: TRUE
[13:21:38.469] - resignal: FALSE
[13:21:38.469] - force: TRUE
[13:21:38.469] - relayed: [n=2] FALSE, FALSE
[13:21:38.469] - queued futures: [n=2] FALSE, FALSE
[13:21:38.469]  - until=1
[13:21:38.469]  - relaying element #1
[13:21:38.469] result() for ClusterFuture ...
[13:21:38.470] - result already collected: FutureResult
[13:21:38.470] result() for ClusterFuture ... done
[13:21:38.470] result() for ClusterFuture ...
[13:21:38.470] - result already collected: FutureResult
[13:21:38.470] result() for ClusterFuture ... done
[13:21:38.470] result() for ClusterFuture ...
[13:21:38.470] - result already collected: FutureResult
[13:21:38.470] result() for ClusterFuture ... done
[13:21:38.470] result() for ClusterFuture ...
[13:21:38.470] - result already collected: FutureResult
[13:21:38.471] result() for ClusterFuture ... done
[13:21:38.471] - relayed: [n=2] TRUE, FALSE
[13:21:38.471] - queued futures: [n=2] TRUE, FALSE
[13:21:38.471] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:21:38.471]  length: 1 (resolved future 1)
[13:21:38.501] receiveMessageFromWorker() for ClusterFuture ...
[13:21:38.502] - Validating connection of MultisessionFuture
[13:21:38.502] - received message: FutureResult
[13:21:38.502] - Received FutureResult
[13:21:38.502] - Erased future from FutureRegistry
[13:21:38.502] result() for ClusterFuture ...
[13:21:38.502] - result already collected: FutureResult
[13:21:38.502] result() for ClusterFuture ... done
[13:21:38.503] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:38.503] Future #2
[13:21:38.503] result() for ClusterFuture ...
[13:21:38.503] - result already collected: FutureResult
[13:21:38.503] result() for ClusterFuture ... done
[13:21:38.503] result() for ClusterFuture ...
[13:21:38.503] - result already collected: FutureResult
[13:21:38.503] result() for ClusterFuture ... done
[13:21:38.503] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:21:38.503] - nx: 2
[13:21:38.503] - relay: TRUE
[13:21:38.504] - stdout: TRUE
[13:21:38.504] - signal: TRUE
[13:21:38.504] - resignal: FALSE
[13:21:38.504] - force: TRUE
[13:21:38.504] - relayed: [n=2] TRUE, FALSE
[13:21:38.504] - queued futures: [n=2] TRUE, FALSE
[13:21:38.504]  - until=2
[13:21:38.504]  - relaying element #2
[13:21:38.504] result() for ClusterFuture ...
[13:21:38.504] - result already collected: FutureResult
[13:21:38.505] result() for ClusterFuture ... done
[13:21:38.505] result() for ClusterFuture ...
[13:21:38.505] - result already collected: FutureResult
[13:21:38.505] result() for ClusterFuture ... done
[13:21:38.505] result() for ClusterFuture ...
[13:21:38.505] - result already collected: FutureResult
[13:21:38.505] result() for ClusterFuture ... done
[13:21:38.505] result() for ClusterFuture ...
[13:21:38.505] - result already collected: FutureResult
[13:21:38.505] result() for ClusterFuture ... done
[13:21:38.505] - relayed: [n=2] TRUE, TRUE
[13:21:38.506] - queued futures: [n=2] TRUE, TRUE
[13:21:38.506] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:21:38.506]  length: 0 (resolved future 2)
[13:21:38.506] Relaying remaining futures
[13:21:38.506] signalConditionsASAP(NULL, pos=0) ...
[13:21:38.506] - nx: 2
[13:21:38.506] - relay: TRUE
[13:21:38.506] - stdout: TRUE
[13:21:38.506] - signal: TRUE
[13:21:38.506] - resignal: FALSE
[13:21:38.506] - force: TRUE
[13:21:38.506] - relayed: [n=2] TRUE, TRUE
[13:21:38.507] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:21:38.507] - relayed: [n=2] TRUE, TRUE
[13:21:38.507] - queued futures: [n=2] TRUE, TRUE
[13:21:38.507] signalConditionsASAP(NULL, pos=0) ... done
[13:21:38.507] resolve() on list ... DONE
[13:21:38.507] result() for ClusterFuture ...
[13:21:38.507] - result already collected: FutureResult
[13:21:38.507] result() for ClusterFuture ... done
[13:21:38.507] result() for ClusterFuture ...
[13:21:38.507] - result already collected: FutureResult
[13:21:38.508] result() for ClusterFuture ... done
[13:21:38.508] result() for ClusterFuture ...
[13:21:38.508] - result already collected: FutureResult
[13:21:38.508] result() for ClusterFuture ... done
[13:21:38.508] result() for ClusterFuture ...
[13:21:38.508] - result already collected: FutureResult
[13:21:38.508] result() for ClusterFuture ... done
[13:21:38.508]  - Number of value chunks collected: 2
[13:21:38.508] Resolving 2 futures (chunks) ... DONE
[13:21:38.508] Reducing values from 2 chunks ...
[13:21:38.509]  - Number of values collected after concatenation: 10
[13:21:38.509]  - Number of values expected: 10
[13:21:38.509] Reducing values from 2 chunks ... DONE
[13:21:38.509] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[13:21:38.510] future_lapply() ...
[13:21:38.515] Number of chunks: 2
[13:21:38.516] getGlobalsAndPackagesXApply() ...
[13:21:38.516]  - future.globals: TRUE
[13:21:38.516] getGlobalsAndPackages() ...
[13:21:38.516] Searching for globals...
[13:21:38.520] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[13:21:38.520] Searching for globals ... DONE
[13:21:38.520] Resolving globals: FALSE
[13:21:38.521] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[13:21:38.521] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:38.521] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:38.521] - packages: [1] ‘future.apply’
[13:21:38.522] getGlobalsAndPackages() ... DONE
[13:21:38.522]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:38.522]  - needed namespaces: [n=1] ‘future.apply’
[13:21:38.522] Finding globals ... DONE
[13:21:38.522]  - use_args: TRUE
[13:21:38.522]  - Getting '...' globals ...
[13:21:38.522] resolve() on list ...
[13:21:38.522]  recursive: 0
[13:21:38.523]  length: 1
[13:21:38.523]  elements: ‘...’
[13:21:38.523]  length: 0 (resolved future 1)
[13:21:38.523] resolve() on list ... DONE
[13:21:38.523]    - '...' content: [n=0] 
[13:21:38.523] List of 1
[13:21:38.523]  $ ...: list()
[13:21:38.523]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:38.523]  - attr(*, "where")=List of 1
[13:21:38.523]   ..$ ...:<environment: 0x563b700d97f8> 
[13:21:38.523]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:38.523]  - attr(*, "resolved")= logi TRUE
[13:21:38.523]  - attr(*, "total_size")= num NA
[13:21:38.526]  - Getting '...' globals ... DONE
[13:21:38.526] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:38.526] List of 8
[13:21:38.526]  $ ...future.FUN:function (x, ...)  
[13:21:38.526]  $ x_FUN        :function (x)  
[13:21:38.526]  $ times        : int 4
[13:21:38.526]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:38.526]  $ stop_if_not  :function (...)  
[13:21:38.526]  $ dim          : int [1:2] 2 2
[13:21:38.526]  $ valid_types  : chr [1:2] "logical" "integer"
[13:21:38.526]  $ ...          : list()
[13:21:38.526]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:38.526]  - attr(*, "where")=List of 8
[13:21:38.526]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:38.526]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:38.526]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:38.526]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:38.526]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:38.526]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:38.526]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:38.526]   ..$ ...          :<environment: 0x563b700d97f8> 
[13:21:38.526]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:38.526]  - attr(*, "resolved")= logi FALSE
[13:21:38.526]  - attr(*, "total_size")= num 97232
[13:21:38.531] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:21:38.532] getGlobalsAndPackagesXApply() ... DONE
[13:21:38.532] Number of futures (= number of chunks): 2
[13:21:38.532] Launching 2 futures (chunks) ...
[13:21:38.532] Chunk #1 of 2 ...
[13:21:38.532]  - Finding globals in 'X' for chunk #1 ...
[13:21:38.532] getGlobalsAndPackages() ...
[13:21:38.532] Searching for globals...
[13:21:38.533] 
[13:21:38.533] Searching for globals ... DONE
[13:21:38.533] - globals: [0] <none>
[13:21:38.533] getGlobalsAndPackages() ... DONE
[13:21:38.533]    + additional globals found: [n=0] 
[13:21:38.533]    + additional namespaces needed: [n=0] 
[13:21:38.533]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:38.533]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:38.533]  - seeds: <none>
[13:21:38.534]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:38.534] getGlobalsAndPackages() ...
[13:21:38.534] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:38.534] Resolving globals: FALSE
[13:21:38.534] Tweak future expression to call with '...' arguments ...
[13:21:38.534] {
[13:21:38.534]     do.call(function(...) {
[13:21:38.534]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:38.534]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:38.534]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:38.534]             on.exit(options(oopts), add = TRUE)
[13:21:38.534]         }
[13:21:38.534]         {
[13:21:38.534]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:38.534]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:38.534]                 ...future.FUN(...future.X_jj, ...)
[13:21:38.534]             })
[13:21:38.534]         }
[13:21:38.534]     }, args = future.call.arguments)
[13:21:38.534] }
[13:21:38.534] Tweak future expression to call with '...' arguments ... DONE
[13:21:38.535] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:38.535] - packages: [1] ‘future.apply’
[13:21:38.535] getGlobalsAndPackages() ... DONE
[13:21:38.536] run() for ‘Future’ ...
[13:21:38.536] - state: ‘created’
[13:21:38.536] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:38.550] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:38.550] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:38.550]   - Field: ‘node’
[13:21:38.550]   - Field: ‘label’
[13:21:38.551]   - Field: ‘local’
[13:21:38.551]   - Field: ‘owner’
[13:21:38.551]   - Field: ‘envir’
[13:21:38.551]   - Field: ‘workers’
[13:21:38.551]   - Field: ‘packages’
[13:21:38.551]   - Field: ‘gc’
[13:21:38.551]   - Field: ‘conditions’
[13:21:38.551]   - Field: ‘persistent’
[13:21:38.551]   - Field: ‘expr’
[13:21:38.551]   - Field: ‘uuid’
[13:21:38.552]   - Field: ‘seed’
[13:21:38.552]   - Field: ‘version’
[13:21:38.552]   - Field: ‘result’
[13:21:38.552]   - Field: ‘asynchronous’
[13:21:38.552]   - Field: ‘calls’
[13:21:38.552]   - Field: ‘globals’
[13:21:38.552]   - Field: ‘stdout’
[13:21:38.552]   - Field: ‘earlySignal’
[13:21:38.552]   - Field: ‘lazy’
[13:21:38.552]   - Field: ‘state’
[13:21:38.552] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:38.553] - Launch lazy future ...
[13:21:38.553] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:38.553] Packages needed by future strategies (n = 0): <none>
[13:21:38.554] {
[13:21:38.554]     {
[13:21:38.554]         {
[13:21:38.554]             ...future.startTime <- base::Sys.time()
[13:21:38.554]             {
[13:21:38.554]                 {
[13:21:38.554]                   {
[13:21:38.554]                     {
[13:21:38.554]                       {
[13:21:38.554]                         base::local({
[13:21:38.554]                           has_future <- base::requireNamespace("future", 
[13:21:38.554]                             quietly = TRUE)
[13:21:38.554]                           if (has_future) {
[13:21:38.554]                             ns <- base::getNamespace("future")
[13:21:38.554]                             version <- ns[[".package"]][["version"]]
[13:21:38.554]                             if (is.null(version)) 
[13:21:38.554]                               version <- utils::packageVersion("future")
[13:21:38.554]                           }
[13:21:38.554]                           else {
[13:21:38.554]                             version <- NULL
[13:21:38.554]                           }
[13:21:38.554]                           if (!has_future || version < "1.8.0") {
[13:21:38.554]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:38.554]                               "", base::R.version$version.string), 
[13:21:38.554]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:38.554]                                 base::R.version$platform, 8 * 
[13:21:38.554]                                   base::.Machine$sizeof.pointer), 
[13:21:38.554]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:38.554]                                 "release", "version")], collapse = " "), 
[13:21:38.554]                               hostname = base::Sys.info()[["nodename"]])
[13:21:38.554]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:38.554]                               info)
[13:21:38.554]                             info <- base::paste(info, collapse = "; ")
[13:21:38.554]                             if (!has_future) {
[13:21:38.554]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:38.554]                                 info)
[13:21:38.554]                             }
[13:21:38.554]                             else {
[13:21:38.554]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:38.554]                                 info, version)
[13:21:38.554]                             }
[13:21:38.554]                             base::stop(msg)
[13:21:38.554]                           }
[13:21:38.554]                         })
[13:21:38.554]                       }
[13:21:38.554]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:38.554]                       base::options(mc.cores = 1L)
[13:21:38.554]                     }
[13:21:38.554]                     base::local({
[13:21:38.554]                       for (pkg in "future.apply") {
[13:21:38.554]                         base::loadNamespace(pkg)
[13:21:38.554]                         base::library(pkg, character.only = TRUE)
[13:21:38.554]                       }
[13:21:38.554]                     })
[13:21:38.554]                   }
[13:21:38.554]                   options(future.plan = NULL)
[13:21:38.554]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:38.554]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:38.554]                 }
[13:21:38.554]                 ...future.workdir <- getwd()
[13:21:38.554]             }
[13:21:38.554]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:38.554]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:38.554]         }
[13:21:38.554]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:38.554]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:38.554]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:38.554]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:38.554]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:38.554]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:38.554]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:38.554]             base::names(...future.oldOptions))
[13:21:38.554]     }
[13:21:38.554]     if (FALSE) {
[13:21:38.554]     }
[13:21:38.554]     else {
[13:21:38.554]         if (TRUE) {
[13:21:38.554]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:38.554]                 open = "w")
[13:21:38.554]         }
[13:21:38.554]         else {
[13:21:38.554]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:38.554]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:38.554]         }
[13:21:38.554]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:38.554]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:38.554]             base::sink(type = "output", split = FALSE)
[13:21:38.554]             base::close(...future.stdout)
[13:21:38.554]         }, add = TRUE)
[13:21:38.554]     }
[13:21:38.554]     ...future.frame <- base::sys.nframe()
[13:21:38.554]     ...future.conditions <- base::list()
[13:21:38.554]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:38.554]     if (FALSE) {
[13:21:38.554]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:38.554]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:38.554]     }
[13:21:38.554]     ...future.result <- base::tryCatch({
[13:21:38.554]         base::withCallingHandlers({
[13:21:38.554]             ...future.value <- base::withVisible(base::local({
[13:21:38.554]                 ...future.makeSendCondition <- base::local({
[13:21:38.554]                   sendCondition <- NULL
[13:21:38.554]                   function(frame = 1L) {
[13:21:38.554]                     if (is.function(sendCondition)) 
[13:21:38.554]                       return(sendCondition)
[13:21:38.554]                     ns <- getNamespace("parallel")
[13:21:38.554]                     if (exists("sendData", mode = "function", 
[13:21:38.554]                       envir = ns)) {
[13:21:38.554]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:38.554]                         envir = ns)
[13:21:38.554]                       envir <- sys.frame(frame)
[13:21:38.554]                       master <- NULL
[13:21:38.554]                       while (!identical(envir, .GlobalEnv) && 
[13:21:38.554]                         !identical(envir, emptyenv())) {
[13:21:38.554]                         if (exists("master", mode = "list", envir = envir, 
[13:21:38.554]                           inherits = FALSE)) {
[13:21:38.554]                           master <- get("master", mode = "list", 
[13:21:38.554]                             envir = envir, inherits = FALSE)
[13:21:38.554]                           if (inherits(master, c("SOCKnode", 
[13:21:38.554]                             "SOCK0node"))) {
[13:21:38.554]                             sendCondition <<- function(cond) {
[13:21:38.554]                               data <- list(type = "VALUE", value = cond, 
[13:21:38.554]                                 success = TRUE)
[13:21:38.554]                               parallel_sendData(master, data)
[13:21:38.554]                             }
[13:21:38.554]                             return(sendCondition)
[13:21:38.554]                           }
[13:21:38.554]                         }
[13:21:38.554]                         frame <- frame + 1L
[13:21:38.554]                         envir <- sys.frame(frame)
[13:21:38.554]                       }
[13:21:38.554]                     }
[13:21:38.554]                     sendCondition <<- function(cond) NULL
[13:21:38.554]                   }
[13:21:38.554]                 })
[13:21:38.554]                 withCallingHandlers({
[13:21:38.554]                   {
[13:21:38.554]                     do.call(function(...) {
[13:21:38.554]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:38.554]                       if (!identical(...future.globals.maxSize.org, 
[13:21:38.554]                         ...future.globals.maxSize)) {
[13:21:38.554]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:38.554]                         on.exit(options(oopts), add = TRUE)
[13:21:38.554]                       }
[13:21:38.554]                       {
[13:21:38.554]                         lapply(seq_along(...future.elements_ii), 
[13:21:38.554]                           FUN = function(jj) {
[13:21:38.554]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:38.554]                             ...future.FUN(...future.X_jj, ...)
[13:21:38.554]                           })
[13:21:38.554]                       }
[13:21:38.554]                     }, args = future.call.arguments)
[13:21:38.554]                   }
[13:21:38.554]                 }, immediateCondition = function(cond) {
[13:21:38.554]                   sendCondition <- ...future.makeSendCondition()
[13:21:38.554]                   sendCondition(cond)
[13:21:38.554]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:38.554]                   {
[13:21:38.554]                     inherits <- base::inherits
[13:21:38.554]                     invokeRestart <- base::invokeRestart
[13:21:38.554]                     is.null <- base::is.null
[13:21:38.554]                     muffled <- FALSE
[13:21:38.554]                     if (inherits(cond, "message")) {
[13:21:38.554]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:38.554]                       if (muffled) 
[13:21:38.554]                         invokeRestart("muffleMessage")
[13:21:38.554]                     }
[13:21:38.554]                     else if (inherits(cond, "warning")) {
[13:21:38.554]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:38.554]                       if (muffled) 
[13:21:38.554]                         invokeRestart("muffleWarning")
[13:21:38.554]                     }
[13:21:38.554]                     else if (inherits(cond, "condition")) {
[13:21:38.554]                       if (!is.null(pattern)) {
[13:21:38.554]                         computeRestarts <- base::computeRestarts
[13:21:38.554]                         grepl <- base::grepl
[13:21:38.554]                         restarts <- computeRestarts(cond)
[13:21:38.554]                         for (restart in restarts) {
[13:21:38.554]                           name <- restart$name
[13:21:38.554]                           if (is.null(name)) 
[13:21:38.554]                             next
[13:21:38.554]                           if (!grepl(pattern, name)) 
[13:21:38.554]                             next
[13:21:38.554]                           invokeRestart(restart)
[13:21:38.554]                           muffled <- TRUE
[13:21:38.554]                           break
[13:21:38.554]                         }
[13:21:38.554]                       }
[13:21:38.554]                     }
[13:21:38.554]                     invisible(muffled)
[13:21:38.554]                   }
[13:21:38.554]                   muffleCondition(cond)
[13:21:38.554]                 })
[13:21:38.554]             }))
[13:21:38.554]             future::FutureResult(value = ...future.value$value, 
[13:21:38.554]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:38.554]                   ...future.rng), globalenv = if (FALSE) 
[13:21:38.554]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:38.554]                     ...future.globalenv.names))
[13:21:38.554]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:38.554]         }, condition = base::local({
[13:21:38.554]             c <- base::c
[13:21:38.554]             inherits <- base::inherits
[13:21:38.554]             invokeRestart <- base::invokeRestart
[13:21:38.554]             length <- base::length
[13:21:38.554]             list <- base::list
[13:21:38.554]             seq.int <- base::seq.int
[13:21:38.554]             signalCondition <- base::signalCondition
[13:21:38.554]             sys.calls <- base::sys.calls
[13:21:38.554]             `[[` <- base::`[[`
[13:21:38.554]             `+` <- base::`+`
[13:21:38.554]             `<<-` <- base::`<<-`
[13:21:38.554]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:38.554]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:38.554]                   3L)]
[13:21:38.554]             }
[13:21:38.554]             function(cond) {
[13:21:38.554]                 is_error <- inherits(cond, "error")
[13:21:38.554]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:38.554]                   NULL)
[13:21:38.554]                 if (is_error) {
[13:21:38.554]                   sessionInformation <- function() {
[13:21:38.554]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:38.554]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:38.554]                       search = base::search(), system = base::Sys.info())
[13:21:38.554]                   }
[13:21:38.554]                   ...future.conditions[[length(...future.conditions) + 
[13:21:38.554]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:38.554]                     cond$call), session = sessionInformation(), 
[13:21:38.554]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:38.554]                   signalCondition(cond)
[13:21:38.554]                 }
[13:21:38.554]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:38.554]                 "immediateCondition"))) {
[13:21:38.554]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:38.554]                   ...future.conditions[[length(...future.conditions) + 
[13:21:38.554]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:38.554]                   if (TRUE && !signal) {
[13:21:38.554]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:38.554]                     {
[13:21:38.554]                       inherits <- base::inherits
[13:21:38.554]                       invokeRestart <- base::invokeRestart
[13:21:38.554]                       is.null <- base::is.null
[13:21:38.554]                       muffled <- FALSE
[13:21:38.554]                       if (inherits(cond, "message")) {
[13:21:38.554]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:38.554]                         if (muffled) 
[13:21:38.554]                           invokeRestart("muffleMessage")
[13:21:38.554]                       }
[13:21:38.554]                       else if (inherits(cond, "warning")) {
[13:21:38.554]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:38.554]                         if (muffled) 
[13:21:38.554]                           invokeRestart("muffleWarning")
[13:21:38.554]                       }
[13:21:38.554]                       else if (inherits(cond, "condition")) {
[13:21:38.554]                         if (!is.null(pattern)) {
[13:21:38.554]                           computeRestarts <- base::computeRestarts
[13:21:38.554]                           grepl <- base::grepl
[13:21:38.554]                           restarts <- computeRestarts(cond)
[13:21:38.554]                           for (restart in restarts) {
[13:21:38.554]                             name <- restart$name
[13:21:38.554]                             if (is.null(name)) 
[13:21:38.554]                               next
[13:21:38.554]                             if (!grepl(pattern, name)) 
[13:21:38.554]                               next
[13:21:38.554]                             invokeRestart(restart)
[13:21:38.554]                             muffled <- TRUE
[13:21:38.554]                             break
[13:21:38.554]                           }
[13:21:38.554]                         }
[13:21:38.554]                       }
[13:21:38.554]                       invisible(muffled)
[13:21:38.554]                     }
[13:21:38.554]                     muffleCondition(cond, pattern = "^muffle")
[13:21:38.554]                   }
[13:21:38.554]                 }
[13:21:38.554]                 else {
[13:21:38.554]                   if (TRUE) {
[13:21:38.554]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:38.554]                     {
[13:21:38.554]                       inherits <- base::inherits
[13:21:38.554]                       invokeRestart <- base::invokeRestart
[13:21:38.554]                       is.null <- base::is.null
[13:21:38.554]                       muffled <- FALSE
[13:21:38.554]                       if (inherits(cond, "message")) {
[13:21:38.554]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:38.554]                         if (muffled) 
[13:21:38.554]                           invokeRestart("muffleMessage")
[13:21:38.554]                       }
[13:21:38.554]                       else if (inherits(cond, "warning")) {
[13:21:38.554]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:38.554]                         if (muffled) 
[13:21:38.554]                           invokeRestart("muffleWarning")
[13:21:38.554]                       }
[13:21:38.554]                       else if (inherits(cond, "condition")) {
[13:21:38.554]                         if (!is.null(pattern)) {
[13:21:38.554]                           computeRestarts <- base::computeRestarts
[13:21:38.554]                           grepl <- base::grepl
[13:21:38.554]                           restarts <- computeRestarts(cond)
[13:21:38.554]                           for (restart in restarts) {
[13:21:38.554]                             name <- restart$name
[13:21:38.554]                             if (is.null(name)) 
[13:21:38.554]                               next
[13:21:38.554]                             if (!grepl(pattern, name)) 
[13:21:38.554]                               next
[13:21:38.554]                             invokeRestart(restart)
[13:21:38.554]                             muffled <- TRUE
[13:21:38.554]                             break
[13:21:38.554]                           }
[13:21:38.554]                         }
[13:21:38.554]                       }
[13:21:38.554]                       invisible(muffled)
[13:21:38.554]                     }
[13:21:38.554]                     muffleCondition(cond, pattern = "^muffle")
[13:21:38.554]                   }
[13:21:38.554]                 }
[13:21:38.554]             }
[13:21:38.554]         }))
[13:21:38.554]     }, error = function(ex) {
[13:21:38.554]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:38.554]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:38.554]                 ...future.rng), started = ...future.startTime, 
[13:21:38.554]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:38.554]             version = "1.8"), class = "FutureResult")
[13:21:38.554]     }, finally = {
[13:21:38.554]         if (!identical(...future.workdir, getwd())) 
[13:21:38.554]             setwd(...future.workdir)
[13:21:38.554]         {
[13:21:38.554]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:38.554]                 ...future.oldOptions$nwarnings <- NULL
[13:21:38.554]             }
[13:21:38.554]             base::options(...future.oldOptions)
[13:21:38.554]             if (.Platform$OS.type == "windows") {
[13:21:38.554]                 old_names <- names(...future.oldEnvVars)
[13:21:38.554]                 envs <- base::Sys.getenv()
[13:21:38.554]                 names <- names(envs)
[13:21:38.554]                 common <- intersect(names, old_names)
[13:21:38.554]                 added <- setdiff(names, old_names)
[13:21:38.554]                 removed <- setdiff(old_names, names)
[13:21:38.554]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:38.554]                   envs[common]]
[13:21:38.554]                 NAMES <- toupper(changed)
[13:21:38.554]                 args <- list()
[13:21:38.554]                 for (kk in seq_along(NAMES)) {
[13:21:38.554]                   name <- changed[[kk]]
[13:21:38.554]                   NAME <- NAMES[[kk]]
[13:21:38.554]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.554]                     next
[13:21:38.554]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:38.554]                 }
[13:21:38.554]                 NAMES <- toupper(added)
[13:21:38.554]                 for (kk in seq_along(NAMES)) {
[13:21:38.554]                   name <- added[[kk]]
[13:21:38.554]                   NAME <- NAMES[[kk]]
[13:21:38.554]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.554]                     next
[13:21:38.554]                   args[[name]] <- ""
[13:21:38.554]                 }
[13:21:38.554]                 NAMES <- toupper(removed)
[13:21:38.554]                 for (kk in seq_along(NAMES)) {
[13:21:38.554]                   name <- removed[[kk]]
[13:21:38.554]                   NAME <- NAMES[[kk]]
[13:21:38.554]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.554]                     next
[13:21:38.554]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:38.554]                 }
[13:21:38.554]                 if (length(args) > 0) 
[13:21:38.554]                   base::do.call(base::Sys.setenv, args = args)
[13:21:38.554]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:38.554]             }
[13:21:38.554]             else {
[13:21:38.554]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:38.554]             }
[13:21:38.554]             {
[13:21:38.554]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:38.554]                   0L) {
[13:21:38.554]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:38.554]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:38.554]                   base::options(opts)
[13:21:38.554]                 }
[13:21:38.554]                 {
[13:21:38.554]                   {
[13:21:38.554]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:38.554]                     NULL
[13:21:38.554]                   }
[13:21:38.554]                   options(future.plan = NULL)
[13:21:38.554]                   if (is.na(NA_character_)) 
[13:21:38.554]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:38.554]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:38.554]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:38.554]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:38.554]                     envir = parent.frame()) 
[13:21:38.554]                   {
[13:21:38.554]                     if (is.function(workers)) 
[13:21:38.554]                       workers <- workers()
[13:21:38.554]                     workers <- structure(as.integer(workers), 
[13:21:38.554]                       class = class(workers))
[13:21:38.554]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:38.554]                       workers >= 1)
[13:21:38.554]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:38.554]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:38.554]                     }
[13:21:38.554]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:38.554]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:38.554]                       envir = envir)
[13:21:38.554]                     if (!future$lazy) 
[13:21:38.554]                       future <- run(future)
[13:21:38.554]                     invisible(future)
[13:21:38.554]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:38.554]                 }
[13:21:38.554]             }
[13:21:38.554]         }
[13:21:38.554]     })
[13:21:38.554]     if (TRUE) {
[13:21:38.554]         base::sink(type = "output", split = FALSE)
[13:21:38.554]         if (TRUE) {
[13:21:38.554]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:38.554]         }
[13:21:38.554]         else {
[13:21:38.554]             ...future.result["stdout"] <- base::list(NULL)
[13:21:38.554]         }
[13:21:38.554]         base::close(...future.stdout)
[13:21:38.554]         ...future.stdout <- NULL
[13:21:38.554]     }
[13:21:38.554]     ...future.result$conditions <- ...future.conditions
[13:21:38.554]     ...future.result$finished <- base::Sys.time()
[13:21:38.554]     ...future.result
[13:21:38.554] }
[13:21:38.557] Exporting 11 global objects (94.95 KiB) to cluster node #1 ...
[13:21:38.557] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:21:38.600] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:21:38.601] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ...
[13:21:38.601] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ... DONE
[13:21:38.601] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:21:38.602] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:21:38.602] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:21:38.644] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:21:38.645] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:21:38.688] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:21:38.689] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[13:21:38.689] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[13:21:38.689] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[13:21:38.690] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[13:21:38.690] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:21:38.690] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:21:38.690] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[13:21:38.691] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[13:21:38.691] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:21:38.691] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:21:38.691] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:21:38.692] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:21:38.692] Exporting 11 global objects (94.95 KiB) to cluster node #1 ... DONE
[13:21:38.693] MultisessionFuture started
[13:21:38.693] - Launch lazy future ... done
[13:21:38.693] run() for ‘MultisessionFuture’ ... done
[13:21:38.693] Created future:
[13:21:38.693] MultisessionFuture:
[13:21:38.693] Label: ‘future_vapply-1’
[13:21:38.693] Expression:
[13:21:38.693] {
[13:21:38.693]     do.call(function(...) {
[13:21:38.693]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:38.693]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:38.693]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:38.693]             on.exit(options(oopts), add = TRUE)
[13:21:38.693]         }
[13:21:38.693]         {
[13:21:38.693]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:38.693]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:38.693]                 ...future.FUN(...future.X_jj, ...)
[13:21:38.693]             })
[13:21:38.693]         }
[13:21:38.693]     }, args = future.call.arguments)
[13:21:38.693] }
[13:21:38.693] Lazy evaluation: FALSE
[13:21:38.693] Asynchronous evaluation: TRUE
[13:21:38.693] Local evaluation: TRUE
[13:21:38.693] Environment: R_GlobalEnv
[13:21:38.693] Capture standard output: TRUE
[13:21:38.693] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:38.693] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:38.693] Packages: 1 packages (‘future.apply’)
[13:21:38.693] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:38.693] Resolved: FALSE
[13:21:38.693] Value: <not collected>
[13:21:38.693] Conditions captured: <none>
[13:21:38.693] Early signaling: FALSE
[13:21:38.693] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:38.693] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:38.705] Chunk #1 of 2 ... DONE
[13:21:38.705] Chunk #2 of 2 ...
[13:21:38.705]  - Finding globals in 'X' for chunk #2 ...
[13:21:38.705] getGlobalsAndPackages() ...
[13:21:38.706] Searching for globals...
[13:21:38.706] 
[13:21:38.706] Searching for globals ... DONE
[13:21:38.706] - globals: [0] <none>
[13:21:38.706] getGlobalsAndPackages() ... DONE
[13:21:38.706]    + additional globals found: [n=0] 
[13:21:38.706]    + additional namespaces needed: [n=0] 
[13:21:38.706]  - Finding globals in 'X' for chunk #2 ... DONE
[13:21:38.707]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:38.707]  - seeds: <none>
[13:21:38.707]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:38.707] getGlobalsAndPackages() ...
[13:21:38.707] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:38.707] Resolving globals: FALSE
[13:21:38.707] Tweak future expression to call with '...' arguments ...
[13:21:38.707] {
[13:21:38.707]     do.call(function(...) {
[13:21:38.707]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:38.707]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:38.707]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:38.707]             on.exit(options(oopts), add = TRUE)
[13:21:38.707]         }
[13:21:38.707]         {
[13:21:38.707]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:38.707]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:38.707]                 ...future.FUN(...future.X_jj, ...)
[13:21:38.707]             })
[13:21:38.707]         }
[13:21:38.707]     }, args = future.call.arguments)
[13:21:38.707] }
[13:21:38.708] Tweak future expression to call with '...' arguments ... DONE
[13:21:38.708] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:38.708] - packages: [1] ‘future.apply’
[13:21:38.708] getGlobalsAndPackages() ... DONE
[13:21:38.709] run() for ‘Future’ ...
[13:21:38.709] - state: ‘created’
[13:21:38.709] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:38.723] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:38.723] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:38.723]   - Field: ‘node’
[13:21:38.724]   - Field: ‘label’
[13:21:38.724]   - Field: ‘local’
[13:21:38.724]   - Field: ‘owner’
[13:21:38.724]   - Field: ‘envir’
[13:21:38.724]   - Field: ‘workers’
[13:21:38.724]   - Field: ‘packages’
[13:21:38.724]   - Field: ‘gc’
[13:21:38.724]   - Field: ‘conditions’
[13:21:38.724]   - Field: ‘persistent’
[13:21:38.725]   - Field: ‘expr’
[13:21:38.725]   - Field: ‘uuid’
[13:21:38.725]   - Field: ‘seed’
[13:21:38.725]   - Field: ‘version’
[13:21:38.725]   - Field: ‘result’
[13:21:38.725]   - Field: ‘asynchronous’
[13:21:38.725]   - Field: ‘calls’
[13:21:38.725]   - Field: ‘globals’
[13:21:38.725]   - Field: ‘stdout’
[13:21:38.725]   - Field: ‘earlySignal’
[13:21:38.725]   - Field: ‘lazy’
[13:21:38.725]   - Field: ‘state’
[13:21:38.726] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:38.726] - Launch lazy future ...
[13:21:38.726] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:38.726] Packages needed by future strategies (n = 0): <none>
[13:21:38.727] {
[13:21:38.727]     {
[13:21:38.727]         {
[13:21:38.727]             ...future.startTime <- base::Sys.time()
[13:21:38.727]             {
[13:21:38.727]                 {
[13:21:38.727]                   {
[13:21:38.727]                     {
[13:21:38.727]                       {
[13:21:38.727]                         base::local({
[13:21:38.727]                           has_future <- base::requireNamespace("future", 
[13:21:38.727]                             quietly = TRUE)
[13:21:38.727]                           if (has_future) {
[13:21:38.727]                             ns <- base::getNamespace("future")
[13:21:38.727]                             version <- ns[[".package"]][["version"]]
[13:21:38.727]                             if (is.null(version)) 
[13:21:38.727]                               version <- utils::packageVersion("future")
[13:21:38.727]                           }
[13:21:38.727]                           else {
[13:21:38.727]                             version <- NULL
[13:21:38.727]                           }
[13:21:38.727]                           if (!has_future || version < "1.8.0") {
[13:21:38.727]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:38.727]                               "", base::R.version$version.string), 
[13:21:38.727]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:38.727]                                 base::R.version$platform, 8 * 
[13:21:38.727]                                   base::.Machine$sizeof.pointer), 
[13:21:38.727]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:38.727]                                 "release", "version")], collapse = " "), 
[13:21:38.727]                               hostname = base::Sys.info()[["nodename"]])
[13:21:38.727]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:38.727]                               info)
[13:21:38.727]                             info <- base::paste(info, collapse = "; ")
[13:21:38.727]                             if (!has_future) {
[13:21:38.727]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:38.727]                                 info)
[13:21:38.727]                             }
[13:21:38.727]                             else {
[13:21:38.727]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:38.727]                                 info, version)
[13:21:38.727]                             }
[13:21:38.727]                             base::stop(msg)
[13:21:38.727]                           }
[13:21:38.727]                         })
[13:21:38.727]                       }
[13:21:38.727]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:38.727]                       base::options(mc.cores = 1L)
[13:21:38.727]                     }
[13:21:38.727]                     base::local({
[13:21:38.727]                       for (pkg in "future.apply") {
[13:21:38.727]                         base::loadNamespace(pkg)
[13:21:38.727]                         base::library(pkg, character.only = TRUE)
[13:21:38.727]                       }
[13:21:38.727]                     })
[13:21:38.727]                   }
[13:21:38.727]                   options(future.plan = NULL)
[13:21:38.727]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:38.727]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:38.727]                 }
[13:21:38.727]                 ...future.workdir <- getwd()
[13:21:38.727]             }
[13:21:38.727]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:38.727]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:38.727]         }
[13:21:38.727]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:38.727]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:38.727]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:38.727]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:38.727]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:38.727]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:38.727]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:38.727]             base::names(...future.oldOptions))
[13:21:38.727]     }
[13:21:38.727]     if (FALSE) {
[13:21:38.727]     }
[13:21:38.727]     else {
[13:21:38.727]         if (TRUE) {
[13:21:38.727]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:38.727]                 open = "w")
[13:21:38.727]         }
[13:21:38.727]         else {
[13:21:38.727]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:38.727]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:38.727]         }
[13:21:38.727]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:38.727]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:38.727]             base::sink(type = "output", split = FALSE)
[13:21:38.727]             base::close(...future.stdout)
[13:21:38.727]         }, add = TRUE)
[13:21:38.727]     }
[13:21:38.727]     ...future.frame <- base::sys.nframe()
[13:21:38.727]     ...future.conditions <- base::list()
[13:21:38.727]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:38.727]     if (FALSE) {
[13:21:38.727]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:38.727]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:38.727]     }
[13:21:38.727]     ...future.result <- base::tryCatch({
[13:21:38.727]         base::withCallingHandlers({
[13:21:38.727]             ...future.value <- base::withVisible(base::local({
[13:21:38.727]                 ...future.makeSendCondition <- base::local({
[13:21:38.727]                   sendCondition <- NULL
[13:21:38.727]                   function(frame = 1L) {
[13:21:38.727]                     if (is.function(sendCondition)) 
[13:21:38.727]                       return(sendCondition)
[13:21:38.727]                     ns <- getNamespace("parallel")
[13:21:38.727]                     if (exists("sendData", mode = "function", 
[13:21:38.727]                       envir = ns)) {
[13:21:38.727]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:38.727]                         envir = ns)
[13:21:38.727]                       envir <- sys.frame(frame)
[13:21:38.727]                       master <- NULL
[13:21:38.727]                       while (!identical(envir, .GlobalEnv) && 
[13:21:38.727]                         !identical(envir, emptyenv())) {
[13:21:38.727]                         if (exists("master", mode = "list", envir = envir, 
[13:21:38.727]                           inherits = FALSE)) {
[13:21:38.727]                           master <- get("master", mode = "list", 
[13:21:38.727]                             envir = envir, inherits = FALSE)
[13:21:38.727]                           if (inherits(master, c("SOCKnode", 
[13:21:38.727]                             "SOCK0node"))) {
[13:21:38.727]                             sendCondition <<- function(cond) {
[13:21:38.727]                               data <- list(type = "VALUE", value = cond, 
[13:21:38.727]                                 success = TRUE)
[13:21:38.727]                               parallel_sendData(master, data)
[13:21:38.727]                             }
[13:21:38.727]                             return(sendCondition)
[13:21:38.727]                           }
[13:21:38.727]                         }
[13:21:38.727]                         frame <- frame + 1L
[13:21:38.727]                         envir <- sys.frame(frame)
[13:21:38.727]                       }
[13:21:38.727]                     }
[13:21:38.727]                     sendCondition <<- function(cond) NULL
[13:21:38.727]                   }
[13:21:38.727]                 })
[13:21:38.727]                 withCallingHandlers({
[13:21:38.727]                   {
[13:21:38.727]                     do.call(function(...) {
[13:21:38.727]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:38.727]                       if (!identical(...future.globals.maxSize.org, 
[13:21:38.727]                         ...future.globals.maxSize)) {
[13:21:38.727]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:38.727]                         on.exit(options(oopts), add = TRUE)
[13:21:38.727]                       }
[13:21:38.727]                       {
[13:21:38.727]                         lapply(seq_along(...future.elements_ii), 
[13:21:38.727]                           FUN = function(jj) {
[13:21:38.727]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:38.727]                             ...future.FUN(...future.X_jj, ...)
[13:21:38.727]                           })
[13:21:38.727]                       }
[13:21:38.727]                     }, args = future.call.arguments)
[13:21:38.727]                   }
[13:21:38.727]                 }, immediateCondition = function(cond) {
[13:21:38.727]                   sendCondition <- ...future.makeSendCondition()
[13:21:38.727]                   sendCondition(cond)
[13:21:38.727]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:38.727]                   {
[13:21:38.727]                     inherits <- base::inherits
[13:21:38.727]                     invokeRestart <- base::invokeRestart
[13:21:38.727]                     is.null <- base::is.null
[13:21:38.727]                     muffled <- FALSE
[13:21:38.727]                     if (inherits(cond, "message")) {
[13:21:38.727]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:38.727]                       if (muffled) 
[13:21:38.727]                         invokeRestart("muffleMessage")
[13:21:38.727]                     }
[13:21:38.727]                     else if (inherits(cond, "warning")) {
[13:21:38.727]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:38.727]                       if (muffled) 
[13:21:38.727]                         invokeRestart("muffleWarning")
[13:21:38.727]                     }
[13:21:38.727]                     else if (inherits(cond, "condition")) {
[13:21:38.727]                       if (!is.null(pattern)) {
[13:21:38.727]                         computeRestarts <- base::computeRestarts
[13:21:38.727]                         grepl <- base::grepl
[13:21:38.727]                         restarts <- computeRestarts(cond)
[13:21:38.727]                         for (restart in restarts) {
[13:21:38.727]                           name <- restart$name
[13:21:38.727]                           if (is.null(name)) 
[13:21:38.727]                             next
[13:21:38.727]                           if (!grepl(pattern, name)) 
[13:21:38.727]                             next
[13:21:38.727]                           invokeRestart(restart)
[13:21:38.727]                           muffled <- TRUE
[13:21:38.727]                           break
[13:21:38.727]                         }
[13:21:38.727]                       }
[13:21:38.727]                     }
[13:21:38.727]                     invisible(muffled)
[13:21:38.727]                   }
[13:21:38.727]                   muffleCondition(cond)
[13:21:38.727]                 })
[13:21:38.727]             }))
[13:21:38.727]             future::FutureResult(value = ...future.value$value, 
[13:21:38.727]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:38.727]                   ...future.rng), globalenv = if (FALSE) 
[13:21:38.727]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:38.727]                     ...future.globalenv.names))
[13:21:38.727]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:38.727]         }, condition = base::local({
[13:21:38.727]             c <- base::c
[13:21:38.727]             inherits <- base::inherits
[13:21:38.727]             invokeRestart <- base::invokeRestart
[13:21:38.727]             length <- base::length
[13:21:38.727]             list <- base::list
[13:21:38.727]             seq.int <- base::seq.int
[13:21:38.727]             signalCondition <- base::signalCondition
[13:21:38.727]             sys.calls <- base::sys.calls
[13:21:38.727]             `[[` <- base::`[[`
[13:21:38.727]             `+` <- base::`+`
[13:21:38.727]             `<<-` <- base::`<<-`
[13:21:38.727]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:38.727]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:38.727]                   3L)]
[13:21:38.727]             }
[13:21:38.727]             function(cond) {
[13:21:38.727]                 is_error <- inherits(cond, "error")
[13:21:38.727]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:38.727]                   NULL)
[13:21:38.727]                 if (is_error) {
[13:21:38.727]                   sessionInformation <- function() {
[13:21:38.727]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:38.727]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:38.727]                       search = base::search(), system = base::Sys.info())
[13:21:38.727]                   }
[13:21:38.727]                   ...future.conditions[[length(...future.conditions) + 
[13:21:38.727]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:38.727]                     cond$call), session = sessionInformation(), 
[13:21:38.727]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:38.727]                   signalCondition(cond)
[13:21:38.727]                 }
[13:21:38.727]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:38.727]                 "immediateCondition"))) {
[13:21:38.727]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:38.727]                   ...future.conditions[[length(...future.conditions) + 
[13:21:38.727]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:38.727]                   if (TRUE && !signal) {
[13:21:38.727]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:38.727]                     {
[13:21:38.727]                       inherits <- base::inherits
[13:21:38.727]                       invokeRestart <- base::invokeRestart
[13:21:38.727]                       is.null <- base::is.null
[13:21:38.727]                       muffled <- FALSE
[13:21:38.727]                       if (inherits(cond, "message")) {
[13:21:38.727]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:38.727]                         if (muffled) 
[13:21:38.727]                           invokeRestart("muffleMessage")
[13:21:38.727]                       }
[13:21:38.727]                       else if (inherits(cond, "warning")) {
[13:21:38.727]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:38.727]                         if (muffled) 
[13:21:38.727]                           invokeRestart("muffleWarning")
[13:21:38.727]                       }
[13:21:38.727]                       else if (inherits(cond, "condition")) {
[13:21:38.727]                         if (!is.null(pattern)) {
[13:21:38.727]                           computeRestarts <- base::computeRestarts
[13:21:38.727]                           grepl <- base::grepl
[13:21:38.727]                           restarts <- computeRestarts(cond)
[13:21:38.727]                           for (restart in restarts) {
[13:21:38.727]                             name <- restart$name
[13:21:38.727]                             if (is.null(name)) 
[13:21:38.727]                               next
[13:21:38.727]                             if (!grepl(pattern, name)) 
[13:21:38.727]                               next
[13:21:38.727]                             invokeRestart(restart)
[13:21:38.727]                             muffled <- TRUE
[13:21:38.727]                             break
[13:21:38.727]                           }
[13:21:38.727]                         }
[13:21:38.727]                       }
[13:21:38.727]                       invisible(muffled)
[13:21:38.727]                     }
[13:21:38.727]                     muffleCondition(cond, pattern = "^muffle")
[13:21:38.727]                   }
[13:21:38.727]                 }
[13:21:38.727]                 else {
[13:21:38.727]                   if (TRUE) {
[13:21:38.727]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:38.727]                     {
[13:21:38.727]                       inherits <- base::inherits
[13:21:38.727]                       invokeRestart <- base::invokeRestart
[13:21:38.727]                       is.null <- base::is.null
[13:21:38.727]                       muffled <- FALSE
[13:21:38.727]                       if (inherits(cond, "message")) {
[13:21:38.727]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:38.727]                         if (muffled) 
[13:21:38.727]                           invokeRestart("muffleMessage")
[13:21:38.727]                       }
[13:21:38.727]                       else if (inherits(cond, "warning")) {
[13:21:38.727]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:38.727]                         if (muffled) 
[13:21:38.727]                           invokeRestart("muffleWarning")
[13:21:38.727]                       }
[13:21:38.727]                       else if (inherits(cond, "condition")) {
[13:21:38.727]                         if (!is.null(pattern)) {
[13:21:38.727]                           computeRestarts <- base::computeRestarts
[13:21:38.727]                           grepl <- base::grepl
[13:21:38.727]                           restarts <- computeRestarts(cond)
[13:21:38.727]                           for (restart in restarts) {
[13:21:38.727]                             name <- restart$name
[13:21:38.727]                             if (is.null(name)) 
[13:21:38.727]                               next
[13:21:38.727]                             if (!grepl(pattern, name)) 
[13:21:38.727]                               next
[13:21:38.727]                             invokeRestart(restart)
[13:21:38.727]                             muffled <- TRUE
[13:21:38.727]                             break
[13:21:38.727]                           }
[13:21:38.727]                         }
[13:21:38.727]                       }
[13:21:38.727]                       invisible(muffled)
[13:21:38.727]                     }
[13:21:38.727]                     muffleCondition(cond, pattern = "^muffle")
[13:21:38.727]                   }
[13:21:38.727]                 }
[13:21:38.727]             }
[13:21:38.727]         }))
[13:21:38.727]     }, error = function(ex) {
[13:21:38.727]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:38.727]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:38.727]                 ...future.rng), started = ...future.startTime, 
[13:21:38.727]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:38.727]             version = "1.8"), class = "FutureResult")
[13:21:38.727]     }, finally = {
[13:21:38.727]         if (!identical(...future.workdir, getwd())) 
[13:21:38.727]             setwd(...future.workdir)
[13:21:38.727]         {
[13:21:38.727]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:38.727]                 ...future.oldOptions$nwarnings <- NULL
[13:21:38.727]             }
[13:21:38.727]             base::options(...future.oldOptions)
[13:21:38.727]             if (.Platform$OS.type == "windows") {
[13:21:38.727]                 old_names <- names(...future.oldEnvVars)
[13:21:38.727]                 envs <- base::Sys.getenv()
[13:21:38.727]                 names <- names(envs)
[13:21:38.727]                 common <- intersect(names, old_names)
[13:21:38.727]                 added <- setdiff(names, old_names)
[13:21:38.727]                 removed <- setdiff(old_names, names)
[13:21:38.727]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:38.727]                   envs[common]]
[13:21:38.727]                 NAMES <- toupper(changed)
[13:21:38.727]                 args <- list()
[13:21:38.727]                 for (kk in seq_along(NAMES)) {
[13:21:38.727]                   name <- changed[[kk]]
[13:21:38.727]                   NAME <- NAMES[[kk]]
[13:21:38.727]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.727]                     next
[13:21:38.727]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:38.727]                 }
[13:21:38.727]                 NAMES <- toupper(added)
[13:21:38.727]                 for (kk in seq_along(NAMES)) {
[13:21:38.727]                   name <- added[[kk]]
[13:21:38.727]                   NAME <- NAMES[[kk]]
[13:21:38.727]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.727]                     next
[13:21:38.727]                   args[[name]] <- ""
[13:21:38.727]                 }
[13:21:38.727]                 NAMES <- toupper(removed)
[13:21:38.727]                 for (kk in seq_along(NAMES)) {
[13:21:38.727]                   name <- removed[[kk]]
[13:21:38.727]                   NAME <- NAMES[[kk]]
[13:21:38.727]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.727]                     next
[13:21:38.727]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:38.727]                 }
[13:21:38.727]                 if (length(args) > 0) 
[13:21:38.727]                   base::do.call(base::Sys.setenv, args = args)
[13:21:38.727]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:38.727]             }
[13:21:38.727]             else {
[13:21:38.727]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:38.727]             }
[13:21:38.727]             {
[13:21:38.727]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:38.727]                   0L) {
[13:21:38.727]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:38.727]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:38.727]                   base::options(opts)
[13:21:38.727]                 }
[13:21:38.727]                 {
[13:21:38.727]                   {
[13:21:38.727]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:38.727]                     NULL
[13:21:38.727]                   }
[13:21:38.727]                   options(future.plan = NULL)
[13:21:38.727]                   if (is.na(NA_character_)) 
[13:21:38.727]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:38.727]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:38.727]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:38.727]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:38.727]                     envir = parent.frame()) 
[13:21:38.727]                   {
[13:21:38.727]                     if (is.function(workers)) 
[13:21:38.727]                       workers <- workers()
[13:21:38.727]                     workers <- structure(as.integer(workers), 
[13:21:38.727]                       class = class(workers))
[13:21:38.727]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:38.727]                       workers >= 1)
[13:21:38.727]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:38.727]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:38.727]                     }
[13:21:38.727]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:38.727]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:38.727]                       envir = envir)
[13:21:38.727]                     if (!future$lazy) 
[13:21:38.727]                       future <- run(future)
[13:21:38.727]                     invisible(future)
[13:21:38.727]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:38.727]                 }
[13:21:38.727]             }
[13:21:38.727]         }
[13:21:38.727]     })
[13:21:38.727]     if (TRUE) {
[13:21:38.727]         base::sink(type = "output", split = FALSE)
[13:21:38.727]         if (TRUE) {
[13:21:38.727]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:38.727]         }
[13:21:38.727]         else {
[13:21:38.727]             ...future.result["stdout"] <- base::list(NULL)
[13:21:38.727]         }
[13:21:38.727]         base::close(...future.stdout)
[13:21:38.727]         ...future.stdout <- NULL
[13:21:38.727]     }
[13:21:38.727]     ...future.result$conditions <- ...future.conditions
[13:21:38.727]     ...future.result$finished <- base::Sys.time()
[13:21:38.727]     ...future.result
[13:21:38.727] }
[13:21:38.730] Exporting 11 global objects (94.95 KiB) to cluster node #2 ...
[13:21:38.730] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[13:21:38.772] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[13:21:38.773] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ...
[13:21:38.773] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ... DONE
[13:21:38.773] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[13:21:38.774] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[13:21:38.774] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[13:21:38.816] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[13:21:38.817] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[13:21:38.860] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[13:21:38.861] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[13:21:38.861] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[13:21:38.861] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ...
[13:21:38.861] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ... DONE
[13:21:38.862] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:21:38.862] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:21:38.862] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[13:21:38.863] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[13:21:38.863] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:21:38.863] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:21:38.863] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:21:38.864] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:21:38.864] Exporting 11 global objects (94.95 KiB) to cluster node #2 ... DONE
[13:21:38.865] MultisessionFuture started
[13:21:38.865] - Launch lazy future ... done
[13:21:38.865] run() for ‘MultisessionFuture’ ... done
[13:21:38.865] Created future:
[13:21:38.865] MultisessionFuture:
[13:21:38.865] Label: ‘future_vapply-2’
[13:21:38.865] Expression:
[13:21:38.865] {
[13:21:38.865]     do.call(function(...) {
[13:21:38.865]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:38.865]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:38.865]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:38.865]             on.exit(options(oopts), add = TRUE)
[13:21:38.865]         }
[13:21:38.865]         {
[13:21:38.865]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:38.865]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:38.865]                 ...future.FUN(...future.X_jj, ...)
[13:21:38.865]             })
[13:21:38.865]         }
[13:21:38.865]     }, args = future.call.arguments)
[13:21:38.865] }
[13:21:38.865] Lazy evaluation: FALSE
[13:21:38.865] Asynchronous evaluation: TRUE
[13:21:38.865] Local evaluation: TRUE
[13:21:38.865] Environment: R_GlobalEnv
[13:21:38.865] Capture standard output: TRUE
[13:21:38.865] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:38.865] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:38.865] Packages: 1 packages (‘future.apply’)
[13:21:38.865] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:38.865] Resolved: FALSE
[13:21:38.865] Value: <not collected>
[13:21:38.865] Conditions captured: <none>
[13:21:38.865] Early signaling: FALSE
[13:21:38.865] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:38.865] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:38.877] Chunk #2 of 2 ... DONE
[13:21:38.877] Launching 2 futures (chunks) ... DONE
[13:21:38.877] Resolving 2 futures (chunks) ...
[13:21:38.878] resolve() on list ...
[13:21:38.878]  recursive: 0
[13:21:38.878]  length: 2
[13:21:38.878] 
[13:21:38.878] receiveMessageFromWorker() for ClusterFuture ...
[13:21:38.878] - Validating connection of MultisessionFuture
[13:21:38.879] - received message: FutureResult
[13:21:38.879] - Received FutureResult
[13:21:38.879] - Erased future from FutureRegistry
[13:21:38.879] result() for ClusterFuture ...
[13:21:38.879] - result already collected: FutureResult
[13:21:38.879] result() for ClusterFuture ... done
[13:21:38.879] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:38.879] Future #1
[13:21:38.880] result() for ClusterFuture ...
[13:21:38.880] - result already collected: FutureResult
[13:21:38.880] result() for ClusterFuture ... done
[13:21:38.880] result() for ClusterFuture ...
[13:21:38.880] - result already collected: FutureResult
[13:21:38.880] result() for ClusterFuture ... done
[13:21:38.880] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:21:38.880] - nx: 2
[13:21:38.880] - relay: TRUE
[13:21:38.883] - stdout: TRUE
[13:21:38.883] - signal: TRUE
[13:21:38.883] - resignal: FALSE
[13:21:38.883] - force: TRUE
[13:21:38.883] - relayed: [n=2] FALSE, FALSE
[13:21:38.883] - queued futures: [n=2] FALSE, FALSE
[13:21:38.883]  - until=1
[13:21:38.883]  - relaying element #1
[13:21:38.883] result() for ClusterFuture ...
[13:21:38.883] - result already collected: FutureResult
[13:21:38.884] result() for ClusterFuture ... done
[13:21:38.884] result() for ClusterFuture ...
[13:21:38.884] - result already collected: FutureResult
[13:21:38.884] result() for ClusterFuture ... done
[13:21:38.884] result() for ClusterFuture ...
[13:21:38.884] - result already collected: FutureResult
[13:21:38.884] result() for ClusterFuture ... done
[13:21:38.884] result() for ClusterFuture ...
[13:21:38.884] - result already collected: FutureResult
[13:21:38.884] result() for ClusterFuture ... done
[13:21:38.884] - relayed: [n=2] TRUE, FALSE
[13:21:38.885] - queued futures: [n=2] TRUE, FALSE
[13:21:38.885] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:21:38.885]  length: 1 (resolved future 1)
[13:21:38.913] receiveMessageFromWorker() for ClusterFuture ...
[13:21:38.914] - Validating connection of MultisessionFuture
[13:21:38.914] - received message: FutureResult
[13:21:38.914] - Received FutureResult
[13:21:38.914] - Erased future from FutureRegistry
[13:21:38.914] result() for ClusterFuture ...
[13:21:38.914] - result already collected: FutureResult
[13:21:38.914] result() for ClusterFuture ... done
[13:21:38.914] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:38.915] Future #2
[13:21:38.915] result() for ClusterFuture ...
[13:21:38.915] - result already collected: FutureResult
[13:21:38.915] result() for ClusterFuture ... done
[13:21:38.915] result() for ClusterFuture ...
[13:21:38.915] - result already collected: FutureResult
[13:21:38.915] result() for ClusterFuture ... done
[13:21:38.915] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:21:38.915] - nx: 2
[13:21:38.915] - relay: TRUE
[13:21:38.915] - stdout: TRUE
[13:21:38.915] - signal: TRUE
[13:21:38.916] - resignal: FALSE
[13:21:38.916] - force: TRUE
[13:21:38.916] - relayed: [n=2] TRUE, FALSE
[13:21:38.916] - queued futures: [n=2] TRUE, FALSE
[13:21:38.916]  - until=2
[13:21:38.916]  - relaying element #2
[13:21:38.916] result() for ClusterFuture ...
[13:21:38.916] - result already collected: FutureResult
[13:21:38.916] result() for ClusterFuture ... done
[13:21:38.916] result() for ClusterFuture ...
[13:21:38.917] - result already collected: FutureResult
[13:21:38.917] result() for ClusterFuture ... done
[13:21:38.917] result() for ClusterFuture ...
[13:21:38.917] - result already collected: FutureResult
[13:21:38.917] result() for ClusterFuture ... done
[13:21:38.917] result() for ClusterFuture ...
[13:21:38.917] - result already collected: FutureResult
[13:21:38.917] result() for ClusterFuture ... done
[13:21:38.917] - relayed: [n=2] TRUE, TRUE
[13:21:38.917] - queued futures: [n=2] TRUE, TRUE
[13:21:38.917] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:21:38.918]  length: 0 (resolved future 2)
[13:21:38.918] Relaying remaining futures
[13:21:38.918] signalConditionsASAP(NULL, pos=0) ...
[13:21:38.918] - nx: 2
[13:21:38.918] - relay: TRUE
[13:21:38.918] - stdout: TRUE
[13:21:38.918] - signal: TRUE
[13:21:38.918] - resignal: FALSE
[13:21:38.918] - force: TRUE
[13:21:38.918] - relayed: [n=2] TRUE, TRUE
[13:21:38.918] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:21:38.918] - relayed: [n=2] TRUE, TRUE
[13:21:38.919] - queued futures: [n=2] TRUE, TRUE
[13:21:38.919] signalConditionsASAP(NULL, pos=0) ... done
[13:21:38.919] resolve() on list ... DONE
[13:21:38.919] result() for ClusterFuture ...
[13:21:38.919] - result already collected: FutureResult
[13:21:38.919] result() for ClusterFuture ... done
[13:21:38.919] result() for ClusterFuture ...
[13:21:38.919] - result already collected: FutureResult
[13:21:38.919] result() for ClusterFuture ... done
[13:21:38.919] result() for ClusterFuture ...
[13:21:38.919] - result already collected: FutureResult
[13:21:38.920] result() for ClusterFuture ... done
[13:21:38.920] result() for ClusterFuture ...
[13:21:38.920] - result already collected: FutureResult
[13:21:38.920] result() for ClusterFuture ... done
[13:21:38.920]  - Number of value chunks collected: 2
[13:21:38.920] Resolving 2 futures (chunks) ... DONE
[13:21:38.920] Reducing values from 2 chunks ...
[13:21:38.920]  - Number of values collected after concatenation: 10
[13:21:38.920]  - Number of values expected: 10
[13:21:38.920] Reducing values from 2 chunks ... DONE
[13:21:38.921] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[13:21:38.922] future_lapply() ...
[13:21:38.927] Number of chunks: 2
[13:21:38.927] getGlobalsAndPackagesXApply() ...
[13:21:38.927]  - future.globals: TRUE
[13:21:38.928] getGlobalsAndPackages() ...
[13:21:38.928] Searching for globals...
[13:21:38.931] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[13:21:38.931] Searching for globals ... DONE
[13:21:38.931] Resolving globals: FALSE
[13:21:38.932] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[13:21:38.933] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:38.933] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:38.933] - packages: [1] ‘future.apply’
[13:21:38.933] getGlobalsAndPackages() ... DONE
[13:21:38.933]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:38.933]  - needed namespaces: [n=1] ‘future.apply’
[13:21:38.933] Finding globals ... DONE
[13:21:38.934]  - use_args: TRUE
[13:21:38.934]  - Getting '...' globals ...
[13:21:38.934] resolve() on list ...
[13:21:38.934]  recursive: 0
[13:21:38.934]  length: 1
[13:21:38.934]  elements: ‘...’
[13:21:38.934]  length: 0 (resolved future 1)
[13:21:38.934] resolve() on list ... DONE
[13:21:38.934]    - '...' content: [n=0] 
[13:21:38.935] List of 1
[13:21:38.935]  $ ...: list()
[13:21:38.935]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:38.935]  - attr(*, "where")=List of 1
[13:21:38.935]   ..$ ...:<environment: 0x563b6ef5b9a8> 
[13:21:38.935]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:38.935]  - attr(*, "resolved")= logi TRUE
[13:21:38.935]  - attr(*, "total_size")= num NA
[13:21:38.937]  - Getting '...' globals ... DONE
[13:21:38.937] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:38.937] List of 8
[13:21:38.937]  $ ...future.FUN:function (x, ...)  
[13:21:38.937]  $ x_FUN        :function (x)  
[13:21:38.937]  $ times        : int 4
[13:21:38.937]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:38.937]  $ stop_if_not  :function (...)  
[13:21:38.937]  $ dim          : int [1:2] 2 2
[13:21:38.937]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:21:38.937]  $ ...          : list()
[13:21:38.937]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:38.937]  - attr(*, "where")=List of 8
[13:21:38.937]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:38.937]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:38.937]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:38.937]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:38.937]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:38.937]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:38.937]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:38.937]   ..$ ...          :<environment: 0x563b6ef5b9a8> 
[13:21:38.937]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:38.937]  - attr(*, "resolved")= logi FALSE
[13:21:38.937]  - attr(*, "total_size")= num 97304
[13:21:38.943] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:21:38.943] getGlobalsAndPackagesXApply() ... DONE
[13:21:38.943] Number of futures (= number of chunks): 2
[13:21:38.943] Launching 2 futures (chunks) ...
[13:21:38.943] Chunk #1 of 2 ...
[13:21:38.943]  - Finding globals in 'X' for chunk #1 ...
[13:21:38.944] getGlobalsAndPackages() ...
[13:21:38.944] Searching for globals...
[13:21:38.944] 
[13:21:38.944] Searching for globals ... DONE
[13:21:38.944] - globals: [0] <none>
[13:21:38.944] getGlobalsAndPackages() ... DONE
[13:21:38.944]    + additional globals found: [n=0] 
[13:21:38.944]    + additional namespaces needed: [n=0] 
[13:21:38.944]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:38.945]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:38.945]  - seeds: <none>
[13:21:38.945]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:38.945] getGlobalsAndPackages() ...
[13:21:38.945] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:38.945] Resolving globals: FALSE
[13:21:38.945] Tweak future expression to call with '...' arguments ...
[13:21:38.945] {
[13:21:38.945]     do.call(function(...) {
[13:21:38.945]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:38.945]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:38.945]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:38.945]             on.exit(options(oopts), add = TRUE)
[13:21:38.945]         }
[13:21:38.945]         {
[13:21:38.945]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:38.945]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:38.945]                 ...future.FUN(...future.X_jj, ...)
[13:21:38.945]             })
[13:21:38.945]         }
[13:21:38.945]     }, args = future.call.arguments)
[13:21:38.945] }
[13:21:38.946] Tweak future expression to call with '...' arguments ... DONE
[13:21:38.946] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:38.946] - packages: [1] ‘future.apply’
[13:21:38.946] getGlobalsAndPackages() ... DONE
[13:21:38.947] run() for ‘Future’ ...
[13:21:38.947] - state: ‘created’
[13:21:38.947] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:38.961] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:38.961] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:38.961]   - Field: ‘node’
[13:21:38.962]   - Field: ‘label’
[13:21:38.962]   - Field: ‘local’
[13:21:38.962]   - Field: ‘owner’
[13:21:38.962]   - Field: ‘envir’
[13:21:38.962]   - Field: ‘workers’
[13:21:38.962]   - Field: ‘packages’
[13:21:38.962]   - Field: ‘gc’
[13:21:38.962]   - Field: ‘conditions’
[13:21:38.962]   - Field: ‘persistent’
[13:21:38.962]   - Field: ‘expr’
[13:21:38.962]   - Field: ‘uuid’
[13:21:38.963]   - Field: ‘seed’
[13:21:38.963]   - Field: ‘version’
[13:21:38.963]   - Field: ‘result’
[13:21:38.963]   - Field: ‘asynchronous’
[13:21:38.963]   - Field: ‘calls’
[13:21:38.963]   - Field: ‘globals’
[13:21:38.963]   - Field: ‘stdout’
[13:21:38.963]   - Field: ‘earlySignal’
[13:21:38.963]   - Field: ‘lazy’
[13:21:38.963]   - Field: ‘state’
[13:21:38.963] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:38.964] - Launch lazy future ...
[13:21:38.964] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:38.964] Packages needed by future strategies (n = 0): <none>
[13:21:38.965] {
[13:21:38.965]     {
[13:21:38.965]         {
[13:21:38.965]             ...future.startTime <- base::Sys.time()
[13:21:38.965]             {
[13:21:38.965]                 {
[13:21:38.965]                   {
[13:21:38.965]                     {
[13:21:38.965]                       {
[13:21:38.965]                         base::local({
[13:21:38.965]                           has_future <- base::requireNamespace("future", 
[13:21:38.965]                             quietly = TRUE)
[13:21:38.965]                           if (has_future) {
[13:21:38.965]                             ns <- base::getNamespace("future")
[13:21:38.965]                             version <- ns[[".package"]][["version"]]
[13:21:38.965]                             if (is.null(version)) 
[13:21:38.965]                               version <- utils::packageVersion("future")
[13:21:38.965]                           }
[13:21:38.965]                           else {
[13:21:38.965]                             version <- NULL
[13:21:38.965]                           }
[13:21:38.965]                           if (!has_future || version < "1.8.0") {
[13:21:38.965]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:38.965]                               "", base::R.version$version.string), 
[13:21:38.965]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:38.965]                                 base::R.version$platform, 8 * 
[13:21:38.965]                                   base::.Machine$sizeof.pointer), 
[13:21:38.965]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:38.965]                                 "release", "version")], collapse = " "), 
[13:21:38.965]                               hostname = base::Sys.info()[["nodename"]])
[13:21:38.965]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:38.965]                               info)
[13:21:38.965]                             info <- base::paste(info, collapse = "; ")
[13:21:38.965]                             if (!has_future) {
[13:21:38.965]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:38.965]                                 info)
[13:21:38.965]                             }
[13:21:38.965]                             else {
[13:21:38.965]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:38.965]                                 info, version)
[13:21:38.965]                             }
[13:21:38.965]                             base::stop(msg)
[13:21:38.965]                           }
[13:21:38.965]                         })
[13:21:38.965]                       }
[13:21:38.965]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:38.965]                       base::options(mc.cores = 1L)
[13:21:38.965]                     }
[13:21:38.965]                     base::local({
[13:21:38.965]                       for (pkg in "future.apply") {
[13:21:38.965]                         base::loadNamespace(pkg)
[13:21:38.965]                         base::library(pkg, character.only = TRUE)
[13:21:38.965]                       }
[13:21:38.965]                     })
[13:21:38.965]                   }
[13:21:38.965]                   options(future.plan = NULL)
[13:21:38.965]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:38.965]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:38.965]                 }
[13:21:38.965]                 ...future.workdir <- getwd()
[13:21:38.965]             }
[13:21:38.965]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:38.965]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:38.965]         }
[13:21:38.965]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:38.965]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:38.965]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:38.965]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:38.965]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:38.965]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:38.965]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:38.965]             base::names(...future.oldOptions))
[13:21:38.965]     }
[13:21:38.965]     if (FALSE) {
[13:21:38.965]     }
[13:21:38.965]     else {
[13:21:38.965]         if (TRUE) {
[13:21:38.965]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:38.965]                 open = "w")
[13:21:38.965]         }
[13:21:38.965]         else {
[13:21:38.965]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:38.965]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:38.965]         }
[13:21:38.965]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:38.965]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:38.965]             base::sink(type = "output", split = FALSE)
[13:21:38.965]             base::close(...future.stdout)
[13:21:38.965]         }, add = TRUE)
[13:21:38.965]     }
[13:21:38.965]     ...future.frame <- base::sys.nframe()
[13:21:38.965]     ...future.conditions <- base::list()
[13:21:38.965]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:38.965]     if (FALSE) {
[13:21:38.965]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:38.965]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:38.965]     }
[13:21:38.965]     ...future.result <- base::tryCatch({
[13:21:38.965]         base::withCallingHandlers({
[13:21:38.965]             ...future.value <- base::withVisible(base::local({
[13:21:38.965]                 ...future.makeSendCondition <- base::local({
[13:21:38.965]                   sendCondition <- NULL
[13:21:38.965]                   function(frame = 1L) {
[13:21:38.965]                     if (is.function(sendCondition)) 
[13:21:38.965]                       return(sendCondition)
[13:21:38.965]                     ns <- getNamespace("parallel")
[13:21:38.965]                     if (exists("sendData", mode = "function", 
[13:21:38.965]                       envir = ns)) {
[13:21:38.965]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:38.965]                         envir = ns)
[13:21:38.965]                       envir <- sys.frame(frame)
[13:21:38.965]                       master <- NULL
[13:21:38.965]                       while (!identical(envir, .GlobalEnv) && 
[13:21:38.965]                         !identical(envir, emptyenv())) {
[13:21:38.965]                         if (exists("master", mode = "list", envir = envir, 
[13:21:38.965]                           inherits = FALSE)) {
[13:21:38.965]                           master <- get("master", mode = "list", 
[13:21:38.965]                             envir = envir, inherits = FALSE)
[13:21:38.965]                           if (inherits(master, c("SOCKnode", 
[13:21:38.965]                             "SOCK0node"))) {
[13:21:38.965]                             sendCondition <<- function(cond) {
[13:21:38.965]                               data <- list(type = "VALUE", value = cond, 
[13:21:38.965]                                 success = TRUE)
[13:21:38.965]                               parallel_sendData(master, data)
[13:21:38.965]                             }
[13:21:38.965]                             return(sendCondition)
[13:21:38.965]                           }
[13:21:38.965]                         }
[13:21:38.965]                         frame <- frame + 1L
[13:21:38.965]                         envir <- sys.frame(frame)
[13:21:38.965]                       }
[13:21:38.965]                     }
[13:21:38.965]                     sendCondition <<- function(cond) NULL
[13:21:38.965]                   }
[13:21:38.965]                 })
[13:21:38.965]                 withCallingHandlers({
[13:21:38.965]                   {
[13:21:38.965]                     do.call(function(...) {
[13:21:38.965]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:38.965]                       if (!identical(...future.globals.maxSize.org, 
[13:21:38.965]                         ...future.globals.maxSize)) {
[13:21:38.965]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:38.965]                         on.exit(options(oopts), add = TRUE)
[13:21:38.965]                       }
[13:21:38.965]                       {
[13:21:38.965]                         lapply(seq_along(...future.elements_ii), 
[13:21:38.965]                           FUN = function(jj) {
[13:21:38.965]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:38.965]                             ...future.FUN(...future.X_jj, ...)
[13:21:38.965]                           })
[13:21:38.965]                       }
[13:21:38.965]                     }, args = future.call.arguments)
[13:21:38.965]                   }
[13:21:38.965]                 }, immediateCondition = function(cond) {
[13:21:38.965]                   sendCondition <- ...future.makeSendCondition()
[13:21:38.965]                   sendCondition(cond)
[13:21:38.965]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:38.965]                   {
[13:21:38.965]                     inherits <- base::inherits
[13:21:38.965]                     invokeRestart <- base::invokeRestart
[13:21:38.965]                     is.null <- base::is.null
[13:21:38.965]                     muffled <- FALSE
[13:21:38.965]                     if (inherits(cond, "message")) {
[13:21:38.965]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:38.965]                       if (muffled) 
[13:21:38.965]                         invokeRestart("muffleMessage")
[13:21:38.965]                     }
[13:21:38.965]                     else if (inherits(cond, "warning")) {
[13:21:38.965]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:38.965]                       if (muffled) 
[13:21:38.965]                         invokeRestart("muffleWarning")
[13:21:38.965]                     }
[13:21:38.965]                     else if (inherits(cond, "condition")) {
[13:21:38.965]                       if (!is.null(pattern)) {
[13:21:38.965]                         computeRestarts <- base::computeRestarts
[13:21:38.965]                         grepl <- base::grepl
[13:21:38.965]                         restarts <- computeRestarts(cond)
[13:21:38.965]                         for (restart in restarts) {
[13:21:38.965]                           name <- restart$name
[13:21:38.965]                           if (is.null(name)) 
[13:21:38.965]                             next
[13:21:38.965]                           if (!grepl(pattern, name)) 
[13:21:38.965]                             next
[13:21:38.965]                           invokeRestart(restart)
[13:21:38.965]                           muffled <- TRUE
[13:21:38.965]                           break
[13:21:38.965]                         }
[13:21:38.965]                       }
[13:21:38.965]                     }
[13:21:38.965]                     invisible(muffled)
[13:21:38.965]                   }
[13:21:38.965]                   muffleCondition(cond)
[13:21:38.965]                 })
[13:21:38.965]             }))
[13:21:38.965]             future::FutureResult(value = ...future.value$value, 
[13:21:38.965]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:38.965]                   ...future.rng), globalenv = if (FALSE) 
[13:21:38.965]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:38.965]                     ...future.globalenv.names))
[13:21:38.965]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:38.965]         }, condition = base::local({
[13:21:38.965]             c <- base::c
[13:21:38.965]             inherits <- base::inherits
[13:21:38.965]             invokeRestart <- base::invokeRestart
[13:21:38.965]             length <- base::length
[13:21:38.965]             list <- base::list
[13:21:38.965]             seq.int <- base::seq.int
[13:21:38.965]             signalCondition <- base::signalCondition
[13:21:38.965]             sys.calls <- base::sys.calls
[13:21:38.965]             `[[` <- base::`[[`
[13:21:38.965]             `+` <- base::`+`
[13:21:38.965]             `<<-` <- base::`<<-`
[13:21:38.965]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:38.965]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:38.965]                   3L)]
[13:21:38.965]             }
[13:21:38.965]             function(cond) {
[13:21:38.965]                 is_error <- inherits(cond, "error")
[13:21:38.965]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:38.965]                   NULL)
[13:21:38.965]                 if (is_error) {
[13:21:38.965]                   sessionInformation <- function() {
[13:21:38.965]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:38.965]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:38.965]                       search = base::search(), system = base::Sys.info())
[13:21:38.965]                   }
[13:21:38.965]                   ...future.conditions[[length(...future.conditions) + 
[13:21:38.965]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:38.965]                     cond$call), session = sessionInformation(), 
[13:21:38.965]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:38.965]                   signalCondition(cond)
[13:21:38.965]                 }
[13:21:38.965]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:38.965]                 "immediateCondition"))) {
[13:21:38.965]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:38.965]                   ...future.conditions[[length(...future.conditions) + 
[13:21:38.965]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:38.965]                   if (TRUE && !signal) {
[13:21:38.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:38.965]                     {
[13:21:38.965]                       inherits <- base::inherits
[13:21:38.965]                       invokeRestart <- base::invokeRestart
[13:21:38.965]                       is.null <- base::is.null
[13:21:38.965]                       muffled <- FALSE
[13:21:38.965]                       if (inherits(cond, "message")) {
[13:21:38.965]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:38.965]                         if (muffled) 
[13:21:38.965]                           invokeRestart("muffleMessage")
[13:21:38.965]                       }
[13:21:38.965]                       else if (inherits(cond, "warning")) {
[13:21:38.965]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:38.965]                         if (muffled) 
[13:21:38.965]                           invokeRestart("muffleWarning")
[13:21:38.965]                       }
[13:21:38.965]                       else if (inherits(cond, "condition")) {
[13:21:38.965]                         if (!is.null(pattern)) {
[13:21:38.965]                           computeRestarts <- base::computeRestarts
[13:21:38.965]                           grepl <- base::grepl
[13:21:38.965]                           restarts <- computeRestarts(cond)
[13:21:38.965]                           for (restart in restarts) {
[13:21:38.965]                             name <- restart$name
[13:21:38.965]                             if (is.null(name)) 
[13:21:38.965]                               next
[13:21:38.965]                             if (!grepl(pattern, name)) 
[13:21:38.965]                               next
[13:21:38.965]                             invokeRestart(restart)
[13:21:38.965]                             muffled <- TRUE
[13:21:38.965]                             break
[13:21:38.965]                           }
[13:21:38.965]                         }
[13:21:38.965]                       }
[13:21:38.965]                       invisible(muffled)
[13:21:38.965]                     }
[13:21:38.965]                     muffleCondition(cond, pattern = "^muffle")
[13:21:38.965]                   }
[13:21:38.965]                 }
[13:21:38.965]                 else {
[13:21:38.965]                   if (TRUE) {
[13:21:38.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:38.965]                     {
[13:21:38.965]                       inherits <- base::inherits
[13:21:38.965]                       invokeRestart <- base::invokeRestart
[13:21:38.965]                       is.null <- base::is.null
[13:21:38.965]                       muffled <- FALSE
[13:21:38.965]                       if (inherits(cond, "message")) {
[13:21:38.965]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:38.965]                         if (muffled) 
[13:21:38.965]                           invokeRestart("muffleMessage")
[13:21:38.965]                       }
[13:21:38.965]                       else if (inherits(cond, "warning")) {
[13:21:38.965]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:38.965]                         if (muffled) 
[13:21:38.965]                           invokeRestart("muffleWarning")
[13:21:38.965]                       }
[13:21:38.965]                       else if (inherits(cond, "condition")) {
[13:21:38.965]                         if (!is.null(pattern)) {
[13:21:38.965]                           computeRestarts <- base::computeRestarts
[13:21:38.965]                           grepl <- base::grepl
[13:21:38.965]                           restarts <- computeRestarts(cond)
[13:21:38.965]                           for (restart in restarts) {
[13:21:38.965]                             name <- restart$name
[13:21:38.965]                             if (is.null(name)) 
[13:21:38.965]                               next
[13:21:38.965]                             if (!grepl(pattern, name)) 
[13:21:38.965]                               next
[13:21:38.965]                             invokeRestart(restart)
[13:21:38.965]                             muffled <- TRUE
[13:21:38.965]                             break
[13:21:38.965]                           }
[13:21:38.965]                         }
[13:21:38.965]                       }
[13:21:38.965]                       invisible(muffled)
[13:21:38.965]                     }
[13:21:38.965]                     muffleCondition(cond, pattern = "^muffle")
[13:21:38.965]                   }
[13:21:38.965]                 }
[13:21:38.965]             }
[13:21:38.965]         }))
[13:21:38.965]     }, error = function(ex) {
[13:21:38.965]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:38.965]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:38.965]                 ...future.rng), started = ...future.startTime, 
[13:21:38.965]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:38.965]             version = "1.8"), class = "FutureResult")
[13:21:38.965]     }, finally = {
[13:21:38.965]         if (!identical(...future.workdir, getwd())) 
[13:21:38.965]             setwd(...future.workdir)
[13:21:38.965]         {
[13:21:38.965]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:38.965]                 ...future.oldOptions$nwarnings <- NULL
[13:21:38.965]             }
[13:21:38.965]             base::options(...future.oldOptions)
[13:21:38.965]             if (.Platform$OS.type == "windows") {
[13:21:38.965]                 old_names <- names(...future.oldEnvVars)
[13:21:38.965]                 envs <- base::Sys.getenv()
[13:21:38.965]                 names <- names(envs)
[13:21:38.965]                 common <- intersect(names, old_names)
[13:21:38.965]                 added <- setdiff(names, old_names)
[13:21:38.965]                 removed <- setdiff(old_names, names)
[13:21:38.965]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:38.965]                   envs[common]]
[13:21:38.965]                 NAMES <- toupper(changed)
[13:21:38.965]                 args <- list()
[13:21:38.965]                 for (kk in seq_along(NAMES)) {
[13:21:38.965]                   name <- changed[[kk]]
[13:21:38.965]                   NAME <- NAMES[[kk]]
[13:21:38.965]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.965]                     next
[13:21:38.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:38.965]                 }
[13:21:38.965]                 NAMES <- toupper(added)
[13:21:38.965]                 for (kk in seq_along(NAMES)) {
[13:21:38.965]                   name <- added[[kk]]
[13:21:38.965]                   NAME <- NAMES[[kk]]
[13:21:38.965]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.965]                     next
[13:21:38.965]                   args[[name]] <- ""
[13:21:38.965]                 }
[13:21:38.965]                 NAMES <- toupper(removed)
[13:21:38.965]                 for (kk in seq_along(NAMES)) {
[13:21:38.965]                   name <- removed[[kk]]
[13:21:38.965]                   NAME <- NAMES[[kk]]
[13:21:38.965]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.965]                     next
[13:21:38.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:38.965]                 }
[13:21:38.965]                 if (length(args) > 0) 
[13:21:38.965]                   base::do.call(base::Sys.setenv, args = args)
[13:21:38.965]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:38.965]             }
[13:21:38.965]             else {
[13:21:38.965]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:38.965]             }
[13:21:38.965]             {
[13:21:38.965]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:38.965]                   0L) {
[13:21:38.965]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:38.965]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:38.965]                   base::options(opts)
[13:21:38.965]                 }
[13:21:38.965]                 {
[13:21:38.965]                   {
[13:21:38.965]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:38.965]                     NULL
[13:21:38.965]                   }
[13:21:38.965]                   options(future.plan = NULL)
[13:21:38.965]                   if (is.na(NA_character_)) 
[13:21:38.965]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:38.965]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:38.965]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:38.965]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:38.965]                     envir = parent.frame()) 
[13:21:38.965]                   {
[13:21:38.965]                     if (is.function(workers)) 
[13:21:38.965]                       workers <- workers()
[13:21:38.965]                     workers <- structure(as.integer(workers), 
[13:21:38.965]                       class = class(workers))
[13:21:38.965]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:38.965]                       workers >= 1)
[13:21:38.965]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:38.965]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:38.965]                     }
[13:21:38.965]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:38.965]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:38.965]                       envir = envir)
[13:21:38.965]                     if (!future$lazy) 
[13:21:38.965]                       future <- run(future)
[13:21:38.965]                     invisible(future)
[13:21:38.965]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:38.965]                 }
[13:21:38.965]             }
[13:21:38.965]         }
[13:21:38.965]     })
[13:21:38.965]     if (TRUE) {
[13:21:38.965]         base::sink(type = "output", split = FALSE)
[13:21:38.965]         if (TRUE) {
[13:21:38.965]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:38.965]         }
[13:21:38.965]         else {
[13:21:38.965]             ...future.result["stdout"] <- base::list(NULL)
[13:21:38.965]         }
[13:21:38.965]         base::close(...future.stdout)
[13:21:38.965]         ...future.stdout <- NULL
[13:21:38.965]     }
[13:21:38.965]     ...future.result$conditions <- ...future.conditions
[13:21:38.965]     ...future.result$finished <- base::Sys.time()
[13:21:38.965]     ...future.result
[13:21:38.965] }
[13:21:38.968] Exporting 11 global objects (95.02 KiB) to cluster node #1 ...
[13:21:38.968] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:21:39.012] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:21:39.013] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ...
[13:21:39.013] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ... DONE
[13:21:39.013] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:21:39.014] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:21:39.014] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:21:39.056] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:21:39.057] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:21:39.100] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:21:39.101] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[13:21:39.101] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[13:21:39.101] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[13:21:39.102] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[13:21:39.102] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:21:39.102] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:21:39.102] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[13:21:39.103] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[13:21:39.103] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:21:39.103] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:21:39.103] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:21:39.104] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:21:39.104] Exporting 11 global objects (95.02 KiB) to cluster node #1 ... DONE
[13:21:39.105] MultisessionFuture started
[13:21:39.105] - Launch lazy future ... done
[13:21:39.105] run() for ‘MultisessionFuture’ ... done
[13:21:39.105] Created future:
[13:21:39.105] MultisessionFuture:
[13:21:39.105] Label: ‘future_vapply-1’
[13:21:39.105] Expression:
[13:21:39.105] {
[13:21:39.105]     do.call(function(...) {
[13:21:39.105]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:39.105]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:39.105]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:39.105]             on.exit(options(oopts), add = TRUE)
[13:21:39.105]         }
[13:21:39.105]         {
[13:21:39.105]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:39.105]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:39.105]                 ...future.FUN(...future.X_jj, ...)
[13:21:39.105]             })
[13:21:39.105]         }
[13:21:39.105]     }, args = future.call.arguments)
[13:21:39.105] }
[13:21:39.105] Lazy evaluation: FALSE
[13:21:39.105] Asynchronous evaluation: TRUE
[13:21:39.105] Local evaluation: TRUE
[13:21:39.105] Environment: R_GlobalEnv
[13:21:39.105] Capture standard output: TRUE
[13:21:39.105] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:39.105] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:39.105] Packages: 1 packages (‘future.apply’)
[13:21:39.105] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:39.105] Resolved: FALSE
[13:21:39.105] Value: <not collected>
[13:21:39.105] Conditions captured: <none>
[13:21:39.105] Early signaling: FALSE
[13:21:39.105] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:39.105] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:39.117] Chunk #1 of 2 ... DONE
[13:21:39.117] Chunk #2 of 2 ...
[13:21:39.117]  - Finding globals in 'X' for chunk #2 ...
[13:21:39.117] getGlobalsAndPackages() ...
[13:21:39.118] Searching for globals...
[13:21:39.118] 
[13:21:39.118] Searching for globals ... DONE
[13:21:39.118] - globals: [0] <none>
[13:21:39.118] getGlobalsAndPackages() ... DONE
[13:21:39.118]    + additional globals found: [n=0] 
[13:21:39.118]    + additional namespaces needed: [n=0] 
[13:21:39.118]  - Finding globals in 'X' for chunk #2 ... DONE
[13:21:39.119]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:39.119]  - seeds: <none>
[13:21:39.119]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:39.119] getGlobalsAndPackages() ...
[13:21:39.119] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:39.119] Resolving globals: FALSE
[13:21:39.119] Tweak future expression to call with '...' arguments ...
[13:21:39.119] {
[13:21:39.119]     do.call(function(...) {
[13:21:39.119]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:39.119]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:39.119]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:39.119]             on.exit(options(oopts), add = TRUE)
[13:21:39.119]         }
[13:21:39.119]         {
[13:21:39.119]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:39.119]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:39.119]                 ...future.FUN(...future.X_jj, ...)
[13:21:39.119]             })
[13:21:39.119]         }
[13:21:39.119]     }, args = future.call.arguments)
[13:21:39.119] }
[13:21:39.120] Tweak future expression to call with '...' arguments ... DONE
[13:21:39.120] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:39.120] - packages: [1] ‘future.apply’
[13:21:39.120] getGlobalsAndPackages() ... DONE
[13:21:39.121] run() for ‘Future’ ...
[13:21:39.121] - state: ‘created’
[13:21:39.121] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:39.135] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:39.135] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:39.135]   - Field: ‘node’
[13:21:39.135]   - Field: ‘label’
[13:21:39.136]   - Field: ‘local’
[13:21:39.136]   - Field: ‘owner’
[13:21:39.136]   - Field: ‘envir’
[13:21:39.136]   - Field: ‘workers’
[13:21:39.136]   - Field: ‘packages’
[13:21:39.136]   - Field: ‘gc’
[13:21:39.136]   - Field: ‘conditions’
[13:21:39.136]   - Field: ‘persistent’
[13:21:39.136]   - Field: ‘expr’
[13:21:39.136]   - Field: ‘uuid’
[13:21:39.137]   - Field: ‘seed’
[13:21:39.137]   - Field: ‘version’
[13:21:39.137]   - Field: ‘result’
[13:21:39.137]   - Field: ‘asynchronous’
[13:21:39.137]   - Field: ‘calls’
[13:21:39.137]   - Field: ‘globals’
[13:21:39.137]   - Field: ‘stdout’
[13:21:39.137]   - Field: ‘earlySignal’
[13:21:39.137]   - Field: ‘lazy’
[13:21:39.137]   - Field: ‘state’
[13:21:39.137] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:39.138] - Launch lazy future ...
[13:21:39.138] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:39.138] Packages needed by future strategies (n = 0): <none>
[13:21:39.138] {
[13:21:39.138]     {
[13:21:39.138]         {
[13:21:39.138]             ...future.startTime <- base::Sys.time()
[13:21:39.138]             {
[13:21:39.138]                 {
[13:21:39.138]                   {
[13:21:39.138]                     {
[13:21:39.138]                       {
[13:21:39.138]                         base::local({
[13:21:39.138]                           has_future <- base::requireNamespace("future", 
[13:21:39.138]                             quietly = TRUE)
[13:21:39.138]                           if (has_future) {
[13:21:39.138]                             ns <- base::getNamespace("future")
[13:21:39.138]                             version <- ns[[".package"]][["version"]]
[13:21:39.138]                             if (is.null(version)) 
[13:21:39.138]                               version <- utils::packageVersion("future")
[13:21:39.138]                           }
[13:21:39.138]                           else {
[13:21:39.138]                             version <- NULL
[13:21:39.138]                           }
[13:21:39.138]                           if (!has_future || version < "1.8.0") {
[13:21:39.138]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:39.138]                               "", base::R.version$version.string), 
[13:21:39.138]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:39.138]                                 base::R.version$platform, 8 * 
[13:21:39.138]                                   base::.Machine$sizeof.pointer), 
[13:21:39.138]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:39.138]                                 "release", "version")], collapse = " "), 
[13:21:39.138]                               hostname = base::Sys.info()[["nodename"]])
[13:21:39.138]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:39.138]                               info)
[13:21:39.138]                             info <- base::paste(info, collapse = "; ")
[13:21:39.138]                             if (!has_future) {
[13:21:39.138]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:39.138]                                 info)
[13:21:39.138]                             }
[13:21:39.138]                             else {
[13:21:39.138]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:39.138]                                 info, version)
[13:21:39.138]                             }
[13:21:39.138]                             base::stop(msg)
[13:21:39.138]                           }
[13:21:39.138]                         })
[13:21:39.138]                       }
[13:21:39.138]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:39.138]                       base::options(mc.cores = 1L)
[13:21:39.138]                     }
[13:21:39.138]                     base::local({
[13:21:39.138]                       for (pkg in "future.apply") {
[13:21:39.138]                         base::loadNamespace(pkg)
[13:21:39.138]                         base::library(pkg, character.only = TRUE)
[13:21:39.138]                       }
[13:21:39.138]                     })
[13:21:39.138]                   }
[13:21:39.138]                   options(future.plan = NULL)
[13:21:39.138]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.138]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:39.138]                 }
[13:21:39.138]                 ...future.workdir <- getwd()
[13:21:39.138]             }
[13:21:39.138]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:39.138]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:39.138]         }
[13:21:39.138]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:39.138]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:39.138]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:39.138]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:39.138]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:39.138]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:39.138]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:39.138]             base::names(...future.oldOptions))
[13:21:39.138]     }
[13:21:39.138]     if (FALSE) {
[13:21:39.138]     }
[13:21:39.138]     else {
[13:21:39.138]         if (TRUE) {
[13:21:39.138]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:39.138]                 open = "w")
[13:21:39.138]         }
[13:21:39.138]         else {
[13:21:39.138]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:39.138]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:39.138]         }
[13:21:39.138]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:39.138]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:39.138]             base::sink(type = "output", split = FALSE)
[13:21:39.138]             base::close(...future.stdout)
[13:21:39.138]         }, add = TRUE)
[13:21:39.138]     }
[13:21:39.138]     ...future.frame <- base::sys.nframe()
[13:21:39.138]     ...future.conditions <- base::list()
[13:21:39.138]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:39.138]     if (FALSE) {
[13:21:39.138]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:39.138]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:39.138]     }
[13:21:39.138]     ...future.result <- base::tryCatch({
[13:21:39.138]         base::withCallingHandlers({
[13:21:39.138]             ...future.value <- base::withVisible(base::local({
[13:21:39.138]                 ...future.makeSendCondition <- base::local({
[13:21:39.138]                   sendCondition <- NULL
[13:21:39.138]                   function(frame = 1L) {
[13:21:39.138]                     if (is.function(sendCondition)) 
[13:21:39.138]                       return(sendCondition)
[13:21:39.138]                     ns <- getNamespace("parallel")
[13:21:39.138]                     if (exists("sendData", mode = "function", 
[13:21:39.138]                       envir = ns)) {
[13:21:39.138]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:39.138]                         envir = ns)
[13:21:39.138]                       envir <- sys.frame(frame)
[13:21:39.138]                       master <- NULL
[13:21:39.138]                       while (!identical(envir, .GlobalEnv) && 
[13:21:39.138]                         !identical(envir, emptyenv())) {
[13:21:39.138]                         if (exists("master", mode = "list", envir = envir, 
[13:21:39.138]                           inherits = FALSE)) {
[13:21:39.138]                           master <- get("master", mode = "list", 
[13:21:39.138]                             envir = envir, inherits = FALSE)
[13:21:39.138]                           if (inherits(master, c("SOCKnode", 
[13:21:39.138]                             "SOCK0node"))) {
[13:21:39.138]                             sendCondition <<- function(cond) {
[13:21:39.138]                               data <- list(type = "VALUE", value = cond, 
[13:21:39.138]                                 success = TRUE)
[13:21:39.138]                               parallel_sendData(master, data)
[13:21:39.138]                             }
[13:21:39.138]                             return(sendCondition)
[13:21:39.138]                           }
[13:21:39.138]                         }
[13:21:39.138]                         frame <- frame + 1L
[13:21:39.138]                         envir <- sys.frame(frame)
[13:21:39.138]                       }
[13:21:39.138]                     }
[13:21:39.138]                     sendCondition <<- function(cond) NULL
[13:21:39.138]                   }
[13:21:39.138]                 })
[13:21:39.138]                 withCallingHandlers({
[13:21:39.138]                   {
[13:21:39.138]                     do.call(function(...) {
[13:21:39.138]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:39.138]                       if (!identical(...future.globals.maxSize.org, 
[13:21:39.138]                         ...future.globals.maxSize)) {
[13:21:39.138]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:39.138]                         on.exit(options(oopts), add = TRUE)
[13:21:39.138]                       }
[13:21:39.138]                       {
[13:21:39.138]                         lapply(seq_along(...future.elements_ii), 
[13:21:39.138]                           FUN = function(jj) {
[13:21:39.138]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:39.138]                             ...future.FUN(...future.X_jj, ...)
[13:21:39.138]                           })
[13:21:39.138]                       }
[13:21:39.138]                     }, args = future.call.arguments)
[13:21:39.138]                   }
[13:21:39.138]                 }, immediateCondition = function(cond) {
[13:21:39.138]                   sendCondition <- ...future.makeSendCondition()
[13:21:39.138]                   sendCondition(cond)
[13:21:39.138]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.138]                   {
[13:21:39.138]                     inherits <- base::inherits
[13:21:39.138]                     invokeRestart <- base::invokeRestart
[13:21:39.138]                     is.null <- base::is.null
[13:21:39.138]                     muffled <- FALSE
[13:21:39.138]                     if (inherits(cond, "message")) {
[13:21:39.138]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:39.138]                       if (muffled) 
[13:21:39.138]                         invokeRestart("muffleMessage")
[13:21:39.138]                     }
[13:21:39.138]                     else if (inherits(cond, "warning")) {
[13:21:39.138]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:39.138]                       if (muffled) 
[13:21:39.138]                         invokeRestart("muffleWarning")
[13:21:39.138]                     }
[13:21:39.138]                     else if (inherits(cond, "condition")) {
[13:21:39.138]                       if (!is.null(pattern)) {
[13:21:39.138]                         computeRestarts <- base::computeRestarts
[13:21:39.138]                         grepl <- base::grepl
[13:21:39.138]                         restarts <- computeRestarts(cond)
[13:21:39.138]                         for (restart in restarts) {
[13:21:39.138]                           name <- restart$name
[13:21:39.138]                           if (is.null(name)) 
[13:21:39.138]                             next
[13:21:39.138]                           if (!grepl(pattern, name)) 
[13:21:39.138]                             next
[13:21:39.138]                           invokeRestart(restart)
[13:21:39.138]                           muffled <- TRUE
[13:21:39.138]                           break
[13:21:39.138]                         }
[13:21:39.138]                       }
[13:21:39.138]                     }
[13:21:39.138]                     invisible(muffled)
[13:21:39.138]                   }
[13:21:39.138]                   muffleCondition(cond)
[13:21:39.138]                 })
[13:21:39.138]             }))
[13:21:39.138]             future::FutureResult(value = ...future.value$value, 
[13:21:39.138]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.138]                   ...future.rng), globalenv = if (FALSE) 
[13:21:39.138]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:39.138]                     ...future.globalenv.names))
[13:21:39.138]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:39.138]         }, condition = base::local({
[13:21:39.138]             c <- base::c
[13:21:39.138]             inherits <- base::inherits
[13:21:39.138]             invokeRestart <- base::invokeRestart
[13:21:39.138]             length <- base::length
[13:21:39.138]             list <- base::list
[13:21:39.138]             seq.int <- base::seq.int
[13:21:39.138]             signalCondition <- base::signalCondition
[13:21:39.138]             sys.calls <- base::sys.calls
[13:21:39.138]             `[[` <- base::`[[`
[13:21:39.138]             `+` <- base::`+`
[13:21:39.138]             `<<-` <- base::`<<-`
[13:21:39.138]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:39.138]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:39.138]                   3L)]
[13:21:39.138]             }
[13:21:39.138]             function(cond) {
[13:21:39.138]                 is_error <- inherits(cond, "error")
[13:21:39.138]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:39.138]                   NULL)
[13:21:39.138]                 if (is_error) {
[13:21:39.138]                   sessionInformation <- function() {
[13:21:39.138]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:39.138]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:39.138]                       search = base::search(), system = base::Sys.info())
[13:21:39.138]                   }
[13:21:39.138]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.138]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:39.138]                     cond$call), session = sessionInformation(), 
[13:21:39.138]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:39.138]                   signalCondition(cond)
[13:21:39.138]                 }
[13:21:39.138]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:39.138]                 "immediateCondition"))) {
[13:21:39.138]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:39.138]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.138]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:39.138]                   if (TRUE && !signal) {
[13:21:39.138]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.138]                     {
[13:21:39.138]                       inherits <- base::inherits
[13:21:39.138]                       invokeRestart <- base::invokeRestart
[13:21:39.138]                       is.null <- base::is.null
[13:21:39.138]                       muffled <- FALSE
[13:21:39.138]                       if (inherits(cond, "message")) {
[13:21:39.138]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.138]                         if (muffled) 
[13:21:39.138]                           invokeRestart("muffleMessage")
[13:21:39.138]                       }
[13:21:39.138]                       else if (inherits(cond, "warning")) {
[13:21:39.138]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.138]                         if (muffled) 
[13:21:39.138]                           invokeRestart("muffleWarning")
[13:21:39.138]                       }
[13:21:39.138]                       else if (inherits(cond, "condition")) {
[13:21:39.138]                         if (!is.null(pattern)) {
[13:21:39.138]                           computeRestarts <- base::computeRestarts
[13:21:39.138]                           grepl <- base::grepl
[13:21:39.138]                           restarts <- computeRestarts(cond)
[13:21:39.138]                           for (restart in restarts) {
[13:21:39.138]                             name <- restart$name
[13:21:39.138]                             if (is.null(name)) 
[13:21:39.138]                               next
[13:21:39.138]                             if (!grepl(pattern, name)) 
[13:21:39.138]                               next
[13:21:39.138]                             invokeRestart(restart)
[13:21:39.138]                             muffled <- TRUE
[13:21:39.138]                             break
[13:21:39.138]                           }
[13:21:39.138]                         }
[13:21:39.138]                       }
[13:21:39.138]                       invisible(muffled)
[13:21:39.138]                     }
[13:21:39.138]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.138]                   }
[13:21:39.138]                 }
[13:21:39.138]                 else {
[13:21:39.138]                   if (TRUE) {
[13:21:39.138]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.138]                     {
[13:21:39.138]                       inherits <- base::inherits
[13:21:39.138]                       invokeRestart <- base::invokeRestart
[13:21:39.138]                       is.null <- base::is.null
[13:21:39.138]                       muffled <- FALSE
[13:21:39.138]                       if (inherits(cond, "message")) {
[13:21:39.138]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.138]                         if (muffled) 
[13:21:39.138]                           invokeRestart("muffleMessage")
[13:21:39.138]                       }
[13:21:39.138]                       else if (inherits(cond, "warning")) {
[13:21:39.138]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.138]                         if (muffled) 
[13:21:39.138]                           invokeRestart("muffleWarning")
[13:21:39.138]                       }
[13:21:39.138]                       else if (inherits(cond, "condition")) {
[13:21:39.138]                         if (!is.null(pattern)) {
[13:21:39.138]                           computeRestarts <- base::computeRestarts
[13:21:39.138]                           grepl <- base::grepl
[13:21:39.138]                           restarts <- computeRestarts(cond)
[13:21:39.138]                           for (restart in restarts) {
[13:21:39.138]                             name <- restart$name
[13:21:39.138]                             if (is.null(name)) 
[13:21:39.138]                               next
[13:21:39.138]                             if (!grepl(pattern, name)) 
[13:21:39.138]                               next
[13:21:39.138]                             invokeRestart(restart)
[13:21:39.138]                             muffled <- TRUE
[13:21:39.138]                             break
[13:21:39.138]                           }
[13:21:39.138]                         }
[13:21:39.138]                       }
[13:21:39.138]                       invisible(muffled)
[13:21:39.138]                     }
[13:21:39.138]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.138]                   }
[13:21:39.138]                 }
[13:21:39.138]             }
[13:21:39.138]         }))
[13:21:39.138]     }, error = function(ex) {
[13:21:39.138]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:39.138]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.138]                 ...future.rng), started = ...future.startTime, 
[13:21:39.138]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:39.138]             version = "1.8"), class = "FutureResult")
[13:21:39.138]     }, finally = {
[13:21:39.138]         if (!identical(...future.workdir, getwd())) 
[13:21:39.138]             setwd(...future.workdir)
[13:21:39.138]         {
[13:21:39.138]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:39.138]                 ...future.oldOptions$nwarnings <- NULL
[13:21:39.138]             }
[13:21:39.138]             base::options(...future.oldOptions)
[13:21:39.138]             if (.Platform$OS.type == "windows") {
[13:21:39.138]                 old_names <- names(...future.oldEnvVars)
[13:21:39.138]                 envs <- base::Sys.getenv()
[13:21:39.138]                 names <- names(envs)
[13:21:39.138]                 common <- intersect(names, old_names)
[13:21:39.138]                 added <- setdiff(names, old_names)
[13:21:39.138]                 removed <- setdiff(old_names, names)
[13:21:39.138]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:39.138]                   envs[common]]
[13:21:39.138]                 NAMES <- toupper(changed)
[13:21:39.138]                 args <- list()
[13:21:39.138]                 for (kk in seq_along(NAMES)) {
[13:21:39.138]                   name <- changed[[kk]]
[13:21:39.138]                   NAME <- NAMES[[kk]]
[13:21:39.138]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.138]                     next
[13:21:39.138]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.138]                 }
[13:21:39.138]                 NAMES <- toupper(added)
[13:21:39.138]                 for (kk in seq_along(NAMES)) {
[13:21:39.138]                   name <- added[[kk]]
[13:21:39.138]                   NAME <- NAMES[[kk]]
[13:21:39.138]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.138]                     next
[13:21:39.138]                   args[[name]] <- ""
[13:21:39.138]                 }
[13:21:39.138]                 NAMES <- toupper(removed)
[13:21:39.138]                 for (kk in seq_along(NAMES)) {
[13:21:39.138]                   name <- removed[[kk]]
[13:21:39.138]                   NAME <- NAMES[[kk]]
[13:21:39.138]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.138]                     next
[13:21:39.138]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.138]                 }
[13:21:39.138]                 if (length(args) > 0) 
[13:21:39.138]                   base::do.call(base::Sys.setenv, args = args)
[13:21:39.138]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:39.138]             }
[13:21:39.138]             else {
[13:21:39.138]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:39.138]             }
[13:21:39.138]             {
[13:21:39.138]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:39.138]                   0L) {
[13:21:39.138]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:39.138]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:39.138]                   base::options(opts)
[13:21:39.138]                 }
[13:21:39.138]                 {
[13:21:39.138]                   {
[13:21:39.138]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:39.138]                     NULL
[13:21:39.138]                   }
[13:21:39.138]                   options(future.plan = NULL)
[13:21:39.138]                   if (is.na(NA_character_)) 
[13:21:39.138]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.138]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:39.138]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:39.138]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:39.138]                     envir = parent.frame()) 
[13:21:39.138]                   {
[13:21:39.138]                     if (is.function(workers)) 
[13:21:39.138]                       workers <- workers()
[13:21:39.138]                     workers <- structure(as.integer(workers), 
[13:21:39.138]                       class = class(workers))
[13:21:39.138]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:39.138]                       workers >= 1)
[13:21:39.138]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:39.138]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:39.138]                     }
[13:21:39.138]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:39.138]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:39.138]                       envir = envir)
[13:21:39.138]                     if (!future$lazy) 
[13:21:39.138]                       future <- run(future)
[13:21:39.138]                     invisible(future)
[13:21:39.138]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:39.138]                 }
[13:21:39.138]             }
[13:21:39.138]         }
[13:21:39.138]     })
[13:21:39.138]     if (TRUE) {
[13:21:39.138]         base::sink(type = "output", split = FALSE)
[13:21:39.138]         if (TRUE) {
[13:21:39.138]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:39.138]         }
[13:21:39.138]         else {
[13:21:39.138]             ...future.result["stdout"] <- base::list(NULL)
[13:21:39.138]         }
[13:21:39.138]         base::close(...future.stdout)
[13:21:39.138]         ...future.stdout <- NULL
[13:21:39.138]     }
[13:21:39.138]     ...future.result$conditions <- ...future.conditions
[13:21:39.138]     ...future.result$finished <- base::Sys.time()
[13:21:39.138]     ...future.result
[13:21:39.138] }
[13:21:39.142] Exporting 11 global objects (95.02 KiB) to cluster node #2 ...
[13:21:39.142] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[13:21:39.188] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[13:21:39.189] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ...
[13:21:39.189] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ... DONE
[13:21:39.189] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[13:21:39.190] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[13:21:39.190] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[13:21:39.232] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[13:21:39.232] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[13:21:39.276] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[13:21:39.276] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[13:21:39.277] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[13:21:39.277] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[13:21:39.277] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[13:21:39.278] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:21:39.278] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:21:39.278] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[13:21:39.279] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[13:21:39.279] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:21:39.279] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:21:39.279] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:21:39.280] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:21:39.280] Exporting 11 global objects (95.02 KiB) to cluster node #2 ... DONE
[13:21:39.280] MultisessionFuture started
[13:21:39.281] - Launch lazy future ... done
[13:21:39.281] run() for ‘MultisessionFuture’ ... done
[13:21:39.281] Created future:
[13:21:39.281] MultisessionFuture:
[13:21:39.281] Label: ‘future_vapply-2’
[13:21:39.281] Expression:
[13:21:39.281] {
[13:21:39.281]     do.call(function(...) {
[13:21:39.281]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:39.281]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:39.281]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:39.281]             on.exit(options(oopts), add = TRUE)
[13:21:39.281]         }
[13:21:39.281]         {
[13:21:39.281]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:39.281]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:39.281]                 ...future.FUN(...future.X_jj, ...)
[13:21:39.281]             })
[13:21:39.281]         }
[13:21:39.281]     }, args = future.call.arguments)
[13:21:39.281] }
[13:21:39.281] Lazy evaluation: FALSE
[13:21:39.281] Asynchronous evaluation: TRUE
[13:21:39.281] Local evaluation: TRUE
[13:21:39.281] Environment: R_GlobalEnv
[13:21:39.281] Capture standard output: TRUE
[13:21:39.281] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:39.281] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:39.281] Packages: 1 packages (‘future.apply’)
[13:21:39.281] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:39.281] Resolved: FALSE
[13:21:39.281] Value: <not collected>
[13:21:39.281] Conditions captured: <none>
[13:21:39.281] Early signaling: FALSE
[13:21:39.281] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:39.281] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:39.293] Chunk #2 of 2 ... DONE
[13:21:39.293] Launching 2 futures (chunks) ... DONE
[13:21:39.293] Resolving 2 futures (chunks) ...
[13:21:39.293] resolve() on list ...
[13:21:39.293]  recursive: 0
[13:21:39.294]  length: 2
[13:21:39.294] 
[13:21:39.294] receiveMessageFromWorker() for ClusterFuture ...
[13:21:39.294] - Validating connection of MultisessionFuture
[13:21:39.294] - received message: FutureResult
[13:21:39.295] - Received FutureResult
[13:21:39.295] - Erased future from FutureRegistry
[13:21:39.295] result() for ClusterFuture ...
[13:21:39.295] - result already collected: FutureResult
[13:21:39.295] result() for ClusterFuture ... done
[13:21:39.295] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:39.295] Future #1
[13:21:39.295] result() for ClusterFuture ...
[13:21:39.295] - result already collected: FutureResult
[13:21:39.295] result() for ClusterFuture ... done
[13:21:39.296] result() for ClusterFuture ...
[13:21:39.296] - result already collected: FutureResult
[13:21:39.296] result() for ClusterFuture ... done
[13:21:39.296] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:21:39.296] - nx: 2
[13:21:39.296] - relay: TRUE
[13:21:39.296] - stdout: TRUE
[13:21:39.296] - signal: TRUE
[13:21:39.296] - resignal: FALSE
[13:21:39.296] - force: TRUE
[13:21:39.296] - relayed: [n=2] FALSE, FALSE
[13:21:39.297] - queued futures: [n=2] FALSE, FALSE
[13:21:39.297]  - until=1
[13:21:39.297]  - relaying element #1
[13:21:39.297] result() for ClusterFuture ...
[13:21:39.297] - result already collected: FutureResult
[13:21:39.297] result() for ClusterFuture ... done
[13:21:39.297] result() for ClusterFuture ...
[13:21:39.297] - result already collected: FutureResult
[13:21:39.297] result() for ClusterFuture ... done
[13:21:39.297] result() for ClusterFuture ...
[13:21:39.297] - result already collected: FutureResult
[13:21:39.298] result() for ClusterFuture ... done
[13:21:39.298] result() for ClusterFuture ...
[13:21:39.298] - result already collected: FutureResult
[13:21:39.298] result() for ClusterFuture ... done
[13:21:39.298] - relayed: [n=2] TRUE, FALSE
[13:21:39.298] - queued futures: [n=2] TRUE, FALSE
[13:21:39.298] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:21:39.298]  length: 1 (resolved future 1)
[13:21:39.329] receiveMessageFromWorker() for ClusterFuture ...
[13:21:39.329] - Validating connection of MultisessionFuture
[13:21:39.330] - received message: FutureResult
[13:21:39.330] - Received FutureResult
[13:21:39.330] - Erased future from FutureRegistry
[13:21:39.330] result() for ClusterFuture ...
[13:21:39.330] - result already collected: FutureResult
[13:21:39.330] result() for ClusterFuture ... done
[13:21:39.330] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:39.330] Future #2
[13:21:39.331] result() for ClusterFuture ...
[13:21:39.331] - result already collected: FutureResult
[13:21:39.331] result() for ClusterFuture ... done
[13:21:39.331] result() for ClusterFuture ...
[13:21:39.331] - result already collected: FutureResult
[13:21:39.331] result() for ClusterFuture ... done
[13:21:39.331] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:21:39.331] - nx: 2
[13:21:39.331] - relay: TRUE
[13:21:39.331] - stdout: TRUE
[13:21:39.331] - signal: TRUE
[13:21:39.332] - resignal: FALSE
[13:21:39.332] - force: TRUE
[13:21:39.332] - relayed: [n=2] TRUE, FALSE
[13:21:39.332] - queued futures: [n=2] TRUE, FALSE
[13:21:39.332]  - until=2
[13:21:39.332]  - relaying element #2
[13:21:39.332] result() for ClusterFuture ...
[13:21:39.332] - result already collected: FutureResult
[13:21:39.332] result() for ClusterFuture ... done
[13:21:39.332] result() for ClusterFuture ...
[13:21:39.332] - result already collected: FutureResult
[13:21:39.333] result() for ClusterFuture ... done
[13:21:39.333] result() for ClusterFuture ...
[13:21:39.333] - result already collected: FutureResult
[13:21:39.333] result() for ClusterFuture ... done
[13:21:39.333] result() for ClusterFuture ...
[13:21:39.333] - result already collected: FutureResult
[13:21:39.333] result() for ClusterFuture ... done
[13:21:39.333] - relayed: [n=2] TRUE, TRUE
[13:21:39.333] - queued futures: [n=2] TRUE, TRUE
[13:21:39.333] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:21:39.333]  length: 0 (resolved future 2)
[13:21:39.334] Relaying remaining futures
[13:21:39.334] signalConditionsASAP(NULL, pos=0) ...
[13:21:39.334] - nx: 2
[13:21:39.334] - relay: TRUE
[13:21:39.334] - stdout: TRUE
[13:21:39.334] - signal: TRUE
[13:21:39.334] - resignal: FALSE
[13:21:39.334] - force: TRUE
[13:21:39.334] - relayed: [n=2] TRUE, TRUE
[13:21:39.334] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:21:39.334] - relayed: [n=2] TRUE, TRUE
[13:21:39.335] - queued futures: [n=2] TRUE, TRUE
[13:21:39.335] signalConditionsASAP(NULL, pos=0) ... done
[13:21:39.335] resolve() on list ... DONE
[13:21:39.335] result() for ClusterFuture ...
[13:21:39.335] - result already collected: FutureResult
[13:21:39.335] result() for ClusterFuture ... done
[13:21:39.335] result() for ClusterFuture ...
[13:21:39.335] - result already collected: FutureResult
[13:21:39.335] result() for ClusterFuture ... done
[13:21:39.335] result() for ClusterFuture ...
[13:21:39.335] - result already collected: FutureResult
[13:21:39.336] result() for ClusterFuture ... done
[13:21:39.336] result() for ClusterFuture ...
[13:21:39.336] - result already collected: FutureResult
[13:21:39.336] result() for ClusterFuture ... done
[13:21:39.336]  - Number of value chunks collected: 2
[13:21:39.336] Resolving 2 futures (chunks) ... DONE
[13:21:39.336] Reducing values from 2 chunks ...
[13:21:39.336]  - Number of values collected after concatenation: 10
[13:21:39.336]  - Number of values expected: 10
[13:21:39.336] Reducing values from 2 chunks ... DONE
[13:21:39.337] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[13:21:39.339] future_lapply() ...
[13:21:39.344] Number of chunks: 2
[13:21:39.345] getGlobalsAndPackagesXApply() ...
[13:21:39.345]  - future.globals: TRUE
[13:21:39.345] getGlobalsAndPackages() ...
[13:21:39.345] Searching for globals...
[13:21:39.351] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[13:21:39.351] Searching for globals ... DONE
[13:21:39.352] Resolving globals: FALSE
[13:21:39.352] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[13:21:39.353] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:39.353] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:39.353] - packages: [1] ‘future.apply’
[13:21:39.353] getGlobalsAndPackages() ... DONE
[13:21:39.353]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:39.353]  - needed namespaces: [n=1] ‘future.apply’
[13:21:39.354] Finding globals ... DONE
[13:21:39.354]  - use_args: TRUE
[13:21:39.354]  - Getting '...' globals ...
[13:21:39.354] resolve() on list ...
[13:21:39.354]  recursive: 0
[13:21:39.354]  length: 1
[13:21:39.354]  elements: ‘...’
[13:21:39.354]  length: 0 (resolved future 1)
[13:21:39.355] resolve() on list ... DONE
[13:21:39.355]    - '...' content: [n=0] 
[13:21:39.355] List of 1
[13:21:39.355]  $ ...: list()
[13:21:39.355]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:39.355]  - attr(*, "where")=List of 1
[13:21:39.355]   ..$ ...:<environment: 0x563b70d785b0> 
[13:21:39.355]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:39.355]  - attr(*, "resolved")= logi TRUE
[13:21:39.355]  - attr(*, "total_size")= num NA
[13:21:39.357]  - Getting '...' globals ... DONE
[13:21:39.357] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:39.358] List of 8
[13:21:39.358]  $ ...future.FUN:function (x, ...)  
[13:21:39.358]  $ x_FUN        :function (x)  
[13:21:39.358]  $ times        : int 4
[13:21:39.358]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:39.358]  $ stop_if_not  :function (...)  
[13:21:39.358]  $ dim          : int [1:2] 2 2
[13:21:39.358]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:21:39.358]  $ ...          : list()
[13:21:39.358]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:39.358]  - attr(*, "where")=List of 8
[13:21:39.358]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:39.358]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:39.358]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:39.358]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:39.358]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:39.358]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:39.358]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:39.358]   ..$ ...          :<environment: 0x563b70d785b0> 
[13:21:39.358]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:39.358]  - attr(*, "resolved")= logi FALSE
[13:21:39.358]  - attr(*, "total_size")= num 105552
[13:21:39.363] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:21:39.363] getGlobalsAndPackagesXApply() ... DONE
[13:21:39.363] Number of futures (= number of chunks): 2
[13:21:39.364] Launching 2 futures (chunks) ...
[13:21:39.364] Chunk #1 of 2 ...
[13:21:39.364]  - Finding globals in 'X' for chunk #1 ...
[13:21:39.364] getGlobalsAndPackages() ...
[13:21:39.364] Searching for globals...
[13:21:39.364] 
[13:21:39.365] Searching for globals ... DONE
[13:21:39.365] - globals: [0] <none>
[13:21:39.365] getGlobalsAndPackages() ... DONE
[13:21:39.365]    + additional globals found: [n=0] 
[13:21:39.365]    + additional namespaces needed: [n=0] 
[13:21:39.365]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:39.365]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:39.365]  - seeds: <none>
[13:21:39.365]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:39.365] getGlobalsAndPackages() ...
[13:21:39.365] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:39.366] Resolving globals: FALSE
[13:21:39.366] Tweak future expression to call with '...' arguments ...
[13:21:39.366] {
[13:21:39.366]     do.call(function(...) {
[13:21:39.366]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:39.366]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:39.366]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:39.366]             on.exit(options(oopts), add = TRUE)
[13:21:39.366]         }
[13:21:39.366]         {
[13:21:39.366]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:39.366]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:39.366]                 ...future.FUN(...future.X_jj, ...)
[13:21:39.366]             })
[13:21:39.366]         }
[13:21:39.366]     }, args = future.call.arguments)
[13:21:39.366] }
[13:21:39.366] Tweak future expression to call with '...' arguments ... DONE
[13:21:39.367] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:39.367] - packages: [1] ‘future.apply’
[13:21:39.367] getGlobalsAndPackages() ... DONE
[13:21:39.367] run() for ‘Future’ ...
[13:21:39.367] - state: ‘created’
[13:21:39.368] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:39.382] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:39.382] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:39.382]   - Field: ‘node’
[13:21:39.382]   - Field: ‘label’
[13:21:39.382]   - Field: ‘local’
[13:21:39.382]   - Field: ‘owner’
[13:21:39.382]   - Field: ‘envir’
[13:21:39.383]   - Field: ‘workers’
[13:21:39.383]   - Field: ‘packages’
[13:21:39.383]   - Field: ‘gc’
[13:21:39.383]   - Field: ‘conditions’
[13:21:39.383]   - Field: ‘persistent’
[13:21:39.383]   - Field: ‘expr’
[13:21:39.383]   - Field: ‘uuid’
[13:21:39.383]   - Field: ‘seed’
[13:21:39.383]   - Field: ‘version’
[13:21:39.383]   - Field: ‘result’
[13:21:39.383]   - Field: ‘asynchronous’
[13:21:39.384]   - Field: ‘calls’
[13:21:39.384]   - Field: ‘globals’
[13:21:39.384]   - Field: ‘stdout’
[13:21:39.384]   - Field: ‘earlySignal’
[13:21:39.384]   - Field: ‘lazy’
[13:21:39.384]   - Field: ‘state’
[13:21:39.384] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:39.384] - Launch lazy future ...
[13:21:39.385] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:39.385] Packages needed by future strategies (n = 0): <none>
[13:21:39.385] {
[13:21:39.385]     {
[13:21:39.385]         {
[13:21:39.385]             ...future.startTime <- base::Sys.time()
[13:21:39.385]             {
[13:21:39.385]                 {
[13:21:39.385]                   {
[13:21:39.385]                     {
[13:21:39.385]                       {
[13:21:39.385]                         base::local({
[13:21:39.385]                           has_future <- base::requireNamespace("future", 
[13:21:39.385]                             quietly = TRUE)
[13:21:39.385]                           if (has_future) {
[13:21:39.385]                             ns <- base::getNamespace("future")
[13:21:39.385]                             version <- ns[[".package"]][["version"]]
[13:21:39.385]                             if (is.null(version)) 
[13:21:39.385]                               version <- utils::packageVersion("future")
[13:21:39.385]                           }
[13:21:39.385]                           else {
[13:21:39.385]                             version <- NULL
[13:21:39.385]                           }
[13:21:39.385]                           if (!has_future || version < "1.8.0") {
[13:21:39.385]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:39.385]                               "", base::R.version$version.string), 
[13:21:39.385]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:39.385]                                 base::R.version$platform, 8 * 
[13:21:39.385]                                   base::.Machine$sizeof.pointer), 
[13:21:39.385]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:39.385]                                 "release", "version")], collapse = " "), 
[13:21:39.385]                               hostname = base::Sys.info()[["nodename"]])
[13:21:39.385]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:39.385]                               info)
[13:21:39.385]                             info <- base::paste(info, collapse = "; ")
[13:21:39.385]                             if (!has_future) {
[13:21:39.385]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:39.385]                                 info)
[13:21:39.385]                             }
[13:21:39.385]                             else {
[13:21:39.385]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:39.385]                                 info, version)
[13:21:39.385]                             }
[13:21:39.385]                             base::stop(msg)
[13:21:39.385]                           }
[13:21:39.385]                         })
[13:21:39.385]                       }
[13:21:39.385]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:39.385]                       base::options(mc.cores = 1L)
[13:21:39.385]                     }
[13:21:39.385]                     base::local({
[13:21:39.385]                       for (pkg in "future.apply") {
[13:21:39.385]                         base::loadNamespace(pkg)
[13:21:39.385]                         base::library(pkg, character.only = TRUE)
[13:21:39.385]                       }
[13:21:39.385]                     })
[13:21:39.385]                   }
[13:21:39.385]                   options(future.plan = NULL)
[13:21:39.385]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.385]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:39.385]                 }
[13:21:39.385]                 ...future.workdir <- getwd()
[13:21:39.385]             }
[13:21:39.385]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:39.385]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:39.385]         }
[13:21:39.385]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:39.385]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:39.385]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:39.385]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:39.385]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:39.385]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:39.385]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:39.385]             base::names(...future.oldOptions))
[13:21:39.385]     }
[13:21:39.385]     if (FALSE) {
[13:21:39.385]     }
[13:21:39.385]     else {
[13:21:39.385]         if (TRUE) {
[13:21:39.385]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:39.385]                 open = "w")
[13:21:39.385]         }
[13:21:39.385]         else {
[13:21:39.385]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:39.385]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:39.385]         }
[13:21:39.385]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:39.385]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:39.385]             base::sink(type = "output", split = FALSE)
[13:21:39.385]             base::close(...future.stdout)
[13:21:39.385]         }, add = TRUE)
[13:21:39.385]     }
[13:21:39.385]     ...future.frame <- base::sys.nframe()
[13:21:39.385]     ...future.conditions <- base::list()
[13:21:39.385]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:39.385]     if (FALSE) {
[13:21:39.385]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:39.385]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:39.385]     }
[13:21:39.385]     ...future.result <- base::tryCatch({
[13:21:39.385]         base::withCallingHandlers({
[13:21:39.385]             ...future.value <- base::withVisible(base::local({
[13:21:39.385]                 ...future.makeSendCondition <- base::local({
[13:21:39.385]                   sendCondition <- NULL
[13:21:39.385]                   function(frame = 1L) {
[13:21:39.385]                     if (is.function(sendCondition)) 
[13:21:39.385]                       return(sendCondition)
[13:21:39.385]                     ns <- getNamespace("parallel")
[13:21:39.385]                     if (exists("sendData", mode = "function", 
[13:21:39.385]                       envir = ns)) {
[13:21:39.385]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:39.385]                         envir = ns)
[13:21:39.385]                       envir <- sys.frame(frame)
[13:21:39.385]                       master <- NULL
[13:21:39.385]                       while (!identical(envir, .GlobalEnv) && 
[13:21:39.385]                         !identical(envir, emptyenv())) {
[13:21:39.385]                         if (exists("master", mode = "list", envir = envir, 
[13:21:39.385]                           inherits = FALSE)) {
[13:21:39.385]                           master <- get("master", mode = "list", 
[13:21:39.385]                             envir = envir, inherits = FALSE)
[13:21:39.385]                           if (inherits(master, c("SOCKnode", 
[13:21:39.385]                             "SOCK0node"))) {
[13:21:39.385]                             sendCondition <<- function(cond) {
[13:21:39.385]                               data <- list(type = "VALUE", value = cond, 
[13:21:39.385]                                 success = TRUE)
[13:21:39.385]                               parallel_sendData(master, data)
[13:21:39.385]                             }
[13:21:39.385]                             return(sendCondition)
[13:21:39.385]                           }
[13:21:39.385]                         }
[13:21:39.385]                         frame <- frame + 1L
[13:21:39.385]                         envir <- sys.frame(frame)
[13:21:39.385]                       }
[13:21:39.385]                     }
[13:21:39.385]                     sendCondition <<- function(cond) NULL
[13:21:39.385]                   }
[13:21:39.385]                 })
[13:21:39.385]                 withCallingHandlers({
[13:21:39.385]                   {
[13:21:39.385]                     do.call(function(...) {
[13:21:39.385]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:39.385]                       if (!identical(...future.globals.maxSize.org, 
[13:21:39.385]                         ...future.globals.maxSize)) {
[13:21:39.385]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:39.385]                         on.exit(options(oopts), add = TRUE)
[13:21:39.385]                       }
[13:21:39.385]                       {
[13:21:39.385]                         lapply(seq_along(...future.elements_ii), 
[13:21:39.385]                           FUN = function(jj) {
[13:21:39.385]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:39.385]                             ...future.FUN(...future.X_jj, ...)
[13:21:39.385]                           })
[13:21:39.385]                       }
[13:21:39.385]                     }, args = future.call.arguments)
[13:21:39.385]                   }
[13:21:39.385]                 }, immediateCondition = function(cond) {
[13:21:39.385]                   sendCondition <- ...future.makeSendCondition()
[13:21:39.385]                   sendCondition(cond)
[13:21:39.385]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.385]                   {
[13:21:39.385]                     inherits <- base::inherits
[13:21:39.385]                     invokeRestart <- base::invokeRestart
[13:21:39.385]                     is.null <- base::is.null
[13:21:39.385]                     muffled <- FALSE
[13:21:39.385]                     if (inherits(cond, "message")) {
[13:21:39.385]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:39.385]                       if (muffled) 
[13:21:39.385]                         invokeRestart("muffleMessage")
[13:21:39.385]                     }
[13:21:39.385]                     else if (inherits(cond, "warning")) {
[13:21:39.385]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:39.385]                       if (muffled) 
[13:21:39.385]                         invokeRestart("muffleWarning")
[13:21:39.385]                     }
[13:21:39.385]                     else if (inherits(cond, "condition")) {
[13:21:39.385]                       if (!is.null(pattern)) {
[13:21:39.385]                         computeRestarts <- base::computeRestarts
[13:21:39.385]                         grepl <- base::grepl
[13:21:39.385]                         restarts <- computeRestarts(cond)
[13:21:39.385]                         for (restart in restarts) {
[13:21:39.385]                           name <- restart$name
[13:21:39.385]                           if (is.null(name)) 
[13:21:39.385]                             next
[13:21:39.385]                           if (!grepl(pattern, name)) 
[13:21:39.385]                             next
[13:21:39.385]                           invokeRestart(restart)
[13:21:39.385]                           muffled <- TRUE
[13:21:39.385]                           break
[13:21:39.385]                         }
[13:21:39.385]                       }
[13:21:39.385]                     }
[13:21:39.385]                     invisible(muffled)
[13:21:39.385]                   }
[13:21:39.385]                   muffleCondition(cond)
[13:21:39.385]                 })
[13:21:39.385]             }))
[13:21:39.385]             future::FutureResult(value = ...future.value$value, 
[13:21:39.385]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.385]                   ...future.rng), globalenv = if (FALSE) 
[13:21:39.385]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:39.385]                     ...future.globalenv.names))
[13:21:39.385]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:39.385]         }, condition = base::local({
[13:21:39.385]             c <- base::c
[13:21:39.385]             inherits <- base::inherits
[13:21:39.385]             invokeRestart <- base::invokeRestart
[13:21:39.385]             length <- base::length
[13:21:39.385]             list <- base::list
[13:21:39.385]             seq.int <- base::seq.int
[13:21:39.385]             signalCondition <- base::signalCondition
[13:21:39.385]             sys.calls <- base::sys.calls
[13:21:39.385]             `[[` <- base::`[[`
[13:21:39.385]             `+` <- base::`+`
[13:21:39.385]             `<<-` <- base::`<<-`
[13:21:39.385]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:39.385]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:39.385]                   3L)]
[13:21:39.385]             }
[13:21:39.385]             function(cond) {
[13:21:39.385]                 is_error <- inherits(cond, "error")
[13:21:39.385]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:39.385]                   NULL)
[13:21:39.385]                 if (is_error) {
[13:21:39.385]                   sessionInformation <- function() {
[13:21:39.385]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:39.385]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:39.385]                       search = base::search(), system = base::Sys.info())
[13:21:39.385]                   }
[13:21:39.385]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.385]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:39.385]                     cond$call), session = sessionInformation(), 
[13:21:39.385]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:39.385]                   signalCondition(cond)
[13:21:39.385]                 }
[13:21:39.385]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:39.385]                 "immediateCondition"))) {
[13:21:39.385]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:39.385]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.385]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:39.385]                   if (TRUE && !signal) {
[13:21:39.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.385]                     {
[13:21:39.385]                       inherits <- base::inherits
[13:21:39.385]                       invokeRestart <- base::invokeRestart
[13:21:39.385]                       is.null <- base::is.null
[13:21:39.385]                       muffled <- FALSE
[13:21:39.385]                       if (inherits(cond, "message")) {
[13:21:39.385]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.385]                         if (muffled) 
[13:21:39.385]                           invokeRestart("muffleMessage")
[13:21:39.385]                       }
[13:21:39.385]                       else if (inherits(cond, "warning")) {
[13:21:39.385]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.385]                         if (muffled) 
[13:21:39.385]                           invokeRestart("muffleWarning")
[13:21:39.385]                       }
[13:21:39.385]                       else if (inherits(cond, "condition")) {
[13:21:39.385]                         if (!is.null(pattern)) {
[13:21:39.385]                           computeRestarts <- base::computeRestarts
[13:21:39.385]                           grepl <- base::grepl
[13:21:39.385]                           restarts <- computeRestarts(cond)
[13:21:39.385]                           for (restart in restarts) {
[13:21:39.385]                             name <- restart$name
[13:21:39.385]                             if (is.null(name)) 
[13:21:39.385]                               next
[13:21:39.385]                             if (!grepl(pattern, name)) 
[13:21:39.385]                               next
[13:21:39.385]                             invokeRestart(restart)
[13:21:39.385]                             muffled <- TRUE
[13:21:39.385]                             break
[13:21:39.385]                           }
[13:21:39.385]                         }
[13:21:39.385]                       }
[13:21:39.385]                       invisible(muffled)
[13:21:39.385]                     }
[13:21:39.385]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.385]                   }
[13:21:39.385]                 }
[13:21:39.385]                 else {
[13:21:39.385]                   if (TRUE) {
[13:21:39.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.385]                     {
[13:21:39.385]                       inherits <- base::inherits
[13:21:39.385]                       invokeRestart <- base::invokeRestart
[13:21:39.385]                       is.null <- base::is.null
[13:21:39.385]                       muffled <- FALSE
[13:21:39.385]                       if (inherits(cond, "message")) {
[13:21:39.385]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.385]                         if (muffled) 
[13:21:39.385]                           invokeRestart("muffleMessage")
[13:21:39.385]                       }
[13:21:39.385]                       else if (inherits(cond, "warning")) {
[13:21:39.385]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.385]                         if (muffled) 
[13:21:39.385]                           invokeRestart("muffleWarning")
[13:21:39.385]                       }
[13:21:39.385]                       else if (inherits(cond, "condition")) {
[13:21:39.385]                         if (!is.null(pattern)) {
[13:21:39.385]                           computeRestarts <- base::computeRestarts
[13:21:39.385]                           grepl <- base::grepl
[13:21:39.385]                           restarts <- computeRestarts(cond)
[13:21:39.385]                           for (restart in restarts) {
[13:21:39.385]                             name <- restart$name
[13:21:39.385]                             if (is.null(name)) 
[13:21:39.385]                               next
[13:21:39.385]                             if (!grepl(pattern, name)) 
[13:21:39.385]                               next
[13:21:39.385]                             invokeRestart(restart)
[13:21:39.385]                             muffled <- TRUE
[13:21:39.385]                             break
[13:21:39.385]                           }
[13:21:39.385]                         }
[13:21:39.385]                       }
[13:21:39.385]                       invisible(muffled)
[13:21:39.385]                     }
[13:21:39.385]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.385]                   }
[13:21:39.385]                 }
[13:21:39.385]             }
[13:21:39.385]         }))
[13:21:39.385]     }, error = function(ex) {
[13:21:39.385]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:39.385]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.385]                 ...future.rng), started = ...future.startTime, 
[13:21:39.385]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:39.385]             version = "1.8"), class = "FutureResult")
[13:21:39.385]     }, finally = {
[13:21:39.385]         if (!identical(...future.workdir, getwd())) 
[13:21:39.385]             setwd(...future.workdir)
[13:21:39.385]         {
[13:21:39.385]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:39.385]                 ...future.oldOptions$nwarnings <- NULL
[13:21:39.385]             }
[13:21:39.385]             base::options(...future.oldOptions)
[13:21:39.385]             if (.Platform$OS.type == "windows") {
[13:21:39.385]                 old_names <- names(...future.oldEnvVars)
[13:21:39.385]                 envs <- base::Sys.getenv()
[13:21:39.385]                 names <- names(envs)
[13:21:39.385]                 common <- intersect(names, old_names)
[13:21:39.385]                 added <- setdiff(names, old_names)
[13:21:39.385]                 removed <- setdiff(old_names, names)
[13:21:39.385]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:39.385]                   envs[common]]
[13:21:39.385]                 NAMES <- toupper(changed)
[13:21:39.385]                 args <- list()
[13:21:39.385]                 for (kk in seq_along(NAMES)) {
[13:21:39.385]                   name <- changed[[kk]]
[13:21:39.385]                   NAME <- NAMES[[kk]]
[13:21:39.385]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.385]                     next
[13:21:39.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.385]                 }
[13:21:39.385]                 NAMES <- toupper(added)
[13:21:39.385]                 for (kk in seq_along(NAMES)) {
[13:21:39.385]                   name <- added[[kk]]
[13:21:39.385]                   NAME <- NAMES[[kk]]
[13:21:39.385]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.385]                     next
[13:21:39.385]                   args[[name]] <- ""
[13:21:39.385]                 }
[13:21:39.385]                 NAMES <- toupper(removed)
[13:21:39.385]                 for (kk in seq_along(NAMES)) {
[13:21:39.385]                   name <- removed[[kk]]
[13:21:39.385]                   NAME <- NAMES[[kk]]
[13:21:39.385]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.385]                     next
[13:21:39.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.385]                 }
[13:21:39.385]                 if (length(args) > 0) 
[13:21:39.385]                   base::do.call(base::Sys.setenv, args = args)
[13:21:39.385]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:39.385]             }
[13:21:39.385]             else {
[13:21:39.385]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:39.385]             }
[13:21:39.385]             {
[13:21:39.385]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:39.385]                   0L) {
[13:21:39.385]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:39.385]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:39.385]                   base::options(opts)
[13:21:39.385]                 }
[13:21:39.385]                 {
[13:21:39.385]                   {
[13:21:39.385]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:39.385]                     NULL
[13:21:39.385]                   }
[13:21:39.385]                   options(future.plan = NULL)
[13:21:39.385]                   if (is.na(NA_character_)) 
[13:21:39.385]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.385]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:39.385]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:39.385]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:39.385]                     envir = parent.frame()) 
[13:21:39.385]                   {
[13:21:39.385]                     if (is.function(workers)) 
[13:21:39.385]                       workers <- workers()
[13:21:39.385]                     workers <- structure(as.integer(workers), 
[13:21:39.385]                       class = class(workers))
[13:21:39.385]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:39.385]                       workers >= 1)
[13:21:39.385]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:39.385]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:39.385]                     }
[13:21:39.385]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:39.385]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:39.385]                       envir = envir)
[13:21:39.385]                     if (!future$lazy) 
[13:21:39.385]                       future <- run(future)
[13:21:39.385]                     invisible(future)
[13:21:39.385]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:39.385]                 }
[13:21:39.385]             }
[13:21:39.385]         }
[13:21:39.385]     })
[13:21:39.385]     if (TRUE) {
[13:21:39.385]         base::sink(type = "output", split = FALSE)
[13:21:39.385]         if (TRUE) {
[13:21:39.385]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:39.385]         }
[13:21:39.385]         else {
[13:21:39.385]             ...future.result["stdout"] <- base::list(NULL)
[13:21:39.385]         }
[13:21:39.385]         base::close(...future.stdout)
[13:21:39.385]         ...future.stdout <- NULL
[13:21:39.385]     }
[13:21:39.385]     ...future.result$conditions <- ...future.conditions
[13:21:39.385]     ...future.result$finished <- base::Sys.time()
[13:21:39.385]     ...future.result
[13:21:39.385] }
[13:21:39.388] Exporting 11 global objects (103.08 KiB) to cluster node #1 ...
[13:21:39.389] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:21:39.432] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:21:39.433] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #1 ...
[13:21:39.433] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #1 ... DONE
[13:21:39.433] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:21:39.434] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:21:39.434] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:21:39.476] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:21:39.477] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:21:39.520] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:21:39.520] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[13:21:39.521] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[13:21:39.521] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[13:21:39.521] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[13:21:39.522] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:21:39.522] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:21:39.522] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[13:21:39.523] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[13:21:39.523] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:21:39.523] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:21:39.523] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:21:39.524] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:21:39.524] Exporting 11 global objects (103.08 KiB) to cluster node #1 ... DONE
[13:21:39.525] MultisessionFuture started
[13:21:39.525] - Launch lazy future ... done
[13:21:39.525] run() for ‘MultisessionFuture’ ... done
[13:21:39.525] Created future:
[13:21:39.525] MultisessionFuture:
[13:21:39.525] Label: ‘future_vapply-1’
[13:21:39.525] Expression:
[13:21:39.525] {
[13:21:39.525]     do.call(function(...) {
[13:21:39.525]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:39.525]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:39.525]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:39.525]             on.exit(options(oopts), add = TRUE)
[13:21:39.525]         }
[13:21:39.525]         {
[13:21:39.525]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:39.525]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:39.525]                 ...future.FUN(...future.X_jj, ...)
[13:21:39.525]             })
[13:21:39.525]         }
[13:21:39.525]     }, args = future.call.arguments)
[13:21:39.525] }
[13:21:39.525] Lazy evaluation: FALSE
[13:21:39.525] Asynchronous evaluation: TRUE
[13:21:39.525] Local evaluation: TRUE
[13:21:39.525] Environment: R_GlobalEnv
[13:21:39.525] Capture standard output: TRUE
[13:21:39.525] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:39.525] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:39.525] Packages: 1 packages (‘future.apply’)
[13:21:39.525] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:39.525] Resolved: FALSE
[13:21:39.525] Value: <not collected>
[13:21:39.525] Conditions captured: <none>
[13:21:39.525] Early signaling: FALSE
[13:21:39.525] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:39.525] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:39.537] Chunk #1 of 2 ... DONE
[13:21:39.537] Chunk #2 of 2 ...
[13:21:39.537]  - Finding globals in 'X' for chunk #2 ...
[13:21:39.537] getGlobalsAndPackages() ...
[13:21:39.537] Searching for globals...
[13:21:39.538] 
[13:21:39.538] Searching for globals ... DONE
[13:21:39.538] - globals: [0] <none>
[13:21:39.538] getGlobalsAndPackages() ... DONE
[13:21:39.538]    + additional globals found: [n=0] 
[13:21:39.538]    + additional namespaces needed: [n=0] 
[13:21:39.538]  - Finding globals in 'X' for chunk #2 ... DONE
[13:21:39.538]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:39.538]  - seeds: <none>
[13:21:39.538]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:39.539] getGlobalsAndPackages() ...
[13:21:39.539] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:39.539] Resolving globals: FALSE
[13:21:39.539] Tweak future expression to call with '...' arguments ...
[13:21:39.539] {
[13:21:39.539]     do.call(function(...) {
[13:21:39.539]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:39.539]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:39.539]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:39.539]             on.exit(options(oopts), add = TRUE)
[13:21:39.539]         }
[13:21:39.539]         {
[13:21:39.539]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:39.539]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:39.539]                 ...future.FUN(...future.X_jj, ...)
[13:21:39.539]             })
[13:21:39.539]         }
[13:21:39.539]     }, args = future.call.arguments)
[13:21:39.539] }
[13:21:39.539] Tweak future expression to call with '...' arguments ... DONE
[13:21:39.540] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:39.540] - packages: [1] ‘future.apply’
[13:21:39.540] getGlobalsAndPackages() ... DONE
[13:21:39.540] run() for ‘Future’ ...
[13:21:39.541] - state: ‘created’
[13:21:39.541] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:39.555] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:39.555] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:39.555]   - Field: ‘node’
[13:21:39.555]   - Field: ‘label’
[13:21:39.555]   - Field: ‘local’
[13:21:39.555]   - Field: ‘owner’
[13:21:39.555]   - Field: ‘envir’
[13:21:39.556]   - Field: ‘workers’
[13:21:39.556]   - Field: ‘packages’
[13:21:39.556]   - Field: ‘gc’
[13:21:39.556]   - Field: ‘conditions’
[13:21:39.556]   - Field: ‘persistent’
[13:21:39.556]   - Field: ‘expr’
[13:21:39.556]   - Field: ‘uuid’
[13:21:39.556]   - Field: ‘seed’
[13:21:39.556]   - Field: ‘version’
[13:21:39.556]   - Field: ‘result’
[13:21:39.557]   - Field: ‘asynchronous’
[13:21:39.557]   - Field: ‘calls’
[13:21:39.557]   - Field: ‘globals’
[13:21:39.557]   - Field: ‘stdout’
[13:21:39.557]   - Field: ‘earlySignal’
[13:21:39.557]   - Field: ‘lazy’
[13:21:39.557]   - Field: ‘state’
[13:21:39.557] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:39.557] - Launch lazy future ...
[13:21:39.558] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:39.558] Packages needed by future strategies (n = 0): <none>
[13:21:39.558] {
[13:21:39.558]     {
[13:21:39.558]         {
[13:21:39.558]             ...future.startTime <- base::Sys.time()
[13:21:39.558]             {
[13:21:39.558]                 {
[13:21:39.558]                   {
[13:21:39.558]                     {
[13:21:39.558]                       {
[13:21:39.558]                         base::local({
[13:21:39.558]                           has_future <- base::requireNamespace("future", 
[13:21:39.558]                             quietly = TRUE)
[13:21:39.558]                           if (has_future) {
[13:21:39.558]                             ns <- base::getNamespace("future")
[13:21:39.558]                             version <- ns[[".package"]][["version"]]
[13:21:39.558]                             if (is.null(version)) 
[13:21:39.558]                               version <- utils::packageVersion("future")
[13:21:39.558]                           }
[13:21:39.558]                           else {
[13:21:39.558]                             version <- NULL
[13:21:39.558]                           }
[13:21:39.558]                           if (!has_future || version < "1.8.0") {
[13:21:39.558]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:39.558]                               "", base::R.version$version.string), 
[13:21:39.558]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:39.558]                                 base::R.version$platform, 8 * 
[13:21:39.558]                                   base::.Machine$sizeof.pointer), 
[13:21:39.558]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:39.558]                                 "release", "version")], collapse = " "), 
[13:21:39.558]                               hostname = base::Sys.info()[["nodename"]])
[13:21:39.558]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:39.558]                               info)
[13:21:39.558]                             info <- base::paste(info, collapse = "; ")
[13:21:39.558]                             if (!has_future) {
[13:21:39.558]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:39.558]                                 info)
[13:21:39.558]                             }
[13:21:39.558]                             else {
[13:21:39.558]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:39.558]                                 info, version)
[13:21:39.558]                             }
[13:21:39.558]                             base::stop(msg)
[13:21:39.558]                           }
[13:21:39.558]                         })
[13:21:39.558]                       }
[13:21:39.558]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:39.558]                       base::options(mc.cores = 1L)
[13:21:39.558]                     }
[13:21:39.558]                     base::local({
[13:21:39.558]                       for (pkg in "future.apply") {
[13:21:39.558]                         base::loadNamespace(pkg)
[13:21:39.558]                         base::library(pkg, character.only = TRUE)
[13:21:39.558]                       }
[13:21:39.558]                     })
[13:21:39.558]                   }
[13:21:39.558]                   options(future.plan = NULL)
[13:21:39.558]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.558]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:39.558]                 }
[13:21:39.558]                 ...future.workdir <- getwd()
[13:21:39.558]             }
[13:21:39.558]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:39.558]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:39.558]         }
[13:21:39.558]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:39.558]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:39.558]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:39.558]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:39.558]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:39.558]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:39.558]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:39.558]             base::names(...future.oldOptions))
[13:21:39.558]     }
[13:21:39.558]     if (FALSE) {
[13:21:39.558]     }
[13:21:39.558]     else {
[13:21:39.558]         if (TRUE) {
[13:21:39.558]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:39.558]                 open = "w")
[13:21:39.558]         }
[13:21:39.558]         else {
[13:21:39.558]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:39.558]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:39.558]         }
[13:21:39.558]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:39.558]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:39.558]             base::sink(type = "output", split = FALSE)
[13:21:39.558]             base::close(...future.stdout)
[13:21:39.558]         }, add = TRUE)
[13:21:39.558]     }
[13:21:39.558]     ...future.frame <- base::sys.nframe()
[13:21:39.558]     ...future.conditions <- base::list()
[13:21:39.558]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:39.558]     if (FALSE) {
[13:21:39.558]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:39.558]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:39.558]     }
[13:21:39.558]     ...future.result <- base::tryCatch({
[13:21:39.558]         base::withCallingHandlers({
[13:21:39.558]             ...future.value <- base::withVisible(base::local({
[13:21:39.558]                 ...future.makeSendCondition <- base::local({
[13:21:39.558]                   sendCondition <- NULL
[13:21:39.558]                   function(frame = 1L) {
[13:21:39.558]                     if (is.function(sendCondition)) 
[13:21:39.558]                       return(sendCondition)
[13:21:39.558]                     ns <- getNamespace("parallel")
[13:21:39.558]                     if (exists("sendData", mode = "function", 
[13:21:39.558]                       envir = ns)) {
[13:21:39.558]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:39.558]                         envir = ns)
[13:21:39.558]                       envir <- sys.frame(frame)
[13:21:39.558]                       master <- NULL
[13:21:39.558]                       while (!identical(envir, .GlobalEnv) && 
[13:21:39.558]                         !identical(envir, emptyenv())) {
[13:21:39.558]                         if (exists("master", mode = "list", envir = envir, 
[13:21:39.558]                           inherits = FALSE)) {
[13:21:39.558]                           master <- get("master", mode = "list", 
[13:21:39.558]                             envir = envir, inherits = FALSE)
[13:21:39.558]                           if (inherits(master, c("SOCKnode", 
[13:21:39.558]                             "SOCK0node"))) {
[13:21:39.558]                             sendCondition <<- function(cond) {
[13:21:39.558]                               data <- list(type = "VALUE", value = cond, 
[13:21:39.558]                                 success = TRUE)
[13:21:39.558]                               parallel_sendData(master, data)
[13:21:39.558]                             }
[13:21:39.558]                             return(sendCondition)
[13:21:39.558]                           }
[13:21:39.558]                         }
[13:21:39.558]                         frame <- frame + 1L
[13:21:39.558]                         envir <- sys.frame(frame)
[13:21:39.558]                       }
[13:21:39.558]                     }
[13:21:39.558]                     sendCondition <<- function(cond) NULL
[13:21:39.558]                   }
[13:21:39.558]                 })
[13:21:39.558]                 withCallingHandlers({
[13:21:39.558]                   {
[13:21:39.558]                     do.call(function(...) {
[13:21:39.558]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:39.558]                       if (!identical(...future.globals.maxSize.org, 
[13:21:39.558]                         ...future.globals.maxSize)) {
[13:21:39.558]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:39.558]                         on.exit(options(oopts), add = TRUE)
[13:21:39.558]                       }
[13:21:39.558]                       {
[13:21:39.558]                         lapply(seq_along(...future.elements_ii), 
[13:21:39.558]                           FUN = function(jj) {
[13:21:39.558]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:39.558]                             ...future.FUN(...future.X_jj, ...)
[13:21:39.558]                           })
[13:21:39.558]                       }
[13:21:39.558]                     }, args = future.call.arguments)
[13:21:39.558]                   }
[13:21:39.558]                 }, immediateCondition = function(cond) {
[13:21:39.558]                   sendCondition <- ...future.makeSendCondition()
[13:21:39.558]                   sendCondition(cond)
[13:21:39.558]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.558]                   {
[13:21:39.558]                     inherits <- base::inherits
[13:21:39.558]                     invokeRestart <- base::invokeRestart
[13:21:39.558]                     is.null <- base::is.null
[13:21:39.558]                     muffled <- FALSE
[13:21:39.558]                     if (inherits(cond, "message")) {
[13:21:39.558]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:39.558]                       if (muffled) 
[13:21:39.558]                         invokeRestart("muffleMessage")
[13:21:39.558]                     }
[13:21:39.558]                     else if (inherits(cond, "warning")) {
[13:21:39.558]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:39.558]                       if (muffled) 
[13:21:39.558]                         invokeRestart("muffleWarning")
[13:21:39.558]                     }
[13:21:39.558]                     else if (inherits(cond, "condition")) {
[13:21:39.558]                       if (!is.null(pattern)) {
[13:21:39.558]                         computeRestarts <- base::computeRestarts
[13:21:39.558]                         grepl <- base::grepl
[13:21:39.558]                         restarts <- computeRestarts(cond)
[13:21:39.558]                         for (restart in restarts) {
[13:21:39.558]                           name <- restart$name
[13:21:39.558]                           if (is.null(name)) 
[13:21:39.558]                             next
[13:21:39.558]                           if (!grepl(pattern, name)) 
[13:21:39.558]                             next
[13:21:39.558]                           invokeRestart(restart)
[13:21:39.558]                           muffled <- TRUE
[13:21:39.558]                           break
[13:21:39.558]                         }
[13:21:39.558]                       }
[13:21:39.558]                     }
[13:21:39.558]                     invisible(muffled)
[13:21:39.558]                   }
[13:21:39.558]                   muffleCondition(cond)
[13:21:39.558]                 })
[13:21:39.558]             }))
[13:21:39.558]             future::FutureResult(value = ...future.value$value, 
[13:21:39.558]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.558]                   ...future.rng), globalenv = if (FALSE) 
[13:21:39.558]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:39.558]                     ...future.globalenv.names))
[13:21:39.558]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:39.558]         }, condition = base::local({
[13:21:39.558]             c <- base::c
[13:21:39.558]             inherits <- base::inherits
[13:21:39.558]             invokeRestart <- base::invokeRestart
[13:21:39.558]             length <- base::length
[13:21:39.558]             list <- base::list
[13:21:39.558]             seq.int <- base::seq.int
[13:21:39.558]             signalCondition <- base::signalCondition
[13:21:39.558]             sys.calls <- base::sys.calls
[13:21:39.558]             `[[` <- base::`[[`
[13:21:39.558]             `+` <- base::`+`
[13:21:39.558]             `<<-` <- base::`<<-`
[13:21:39.558]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:39.558]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:39.558]                   3L)]
[13:21:39.558]             }
[13:21:39.558]             function(cond) {
[13:21:39.558]                 is_error <- inherits(cond, "error")
[13:21:39.558]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:39.558]                   NULL)
[13:21:39.558]                 if (is_error) {
[13:21:39.558]                   sessionInformation <- function() {
[13:21:39.558]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:39.558]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:39.558]                       search = base::search(), system = base::Sys.info())
[13:21:39.558]                   }
[13:21:39.558]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.558]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:39.558]                     cond$call), session = sessionInformation(), 
[13:21:39.558]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:39.558]                   signalCondition(cond)
[13:21:39.558]                 }
[13:21:39.558]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:39.558]                 "immediateCondition"))) {
[13:21:39.558]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:39.558]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.558]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:39.558]                   if (TRUE && !signal) {
[13:21:39.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.558]                     {
[13:21:39.558]                       inherits <- base::inherits
[13:21:39.558]                       invokeRestart <- base::invokeRestart
[13:21:39.558]                       is.null <- base::is.null
[13:21:39.558]                       muffled <- FALSE
[13:21:39.558]                       if (inherits(cond, "message")) {
[13:21:39.558]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.558]                         if (muffled) 
[13:21:39.558]                           invokeRestart("muffleMessage")
[13:21:39.558]                       }
[13:21:39.558]                       else if (inherits(cond, "warning")) {
[13:21:39.558]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.558]                         if (muffled) 
[13:21:39.558]                           invokeRestart("muffleWarning")
[13:21:39.558]                       }
[13:21:39.558]                       else if (inherits(cond, "condition")) {
[13:21:39.558]                         if (!is.null(pattern)) {
[13:21:39.558]                           computeRestarts <- base::computeRestarts
[13:21:39.558]                           grepl <- base::grepl
[13:21:39.558]                           restarts <- computeRestarts(cond)
[13:21:39.558]                           for (restart in restarts) {
[13:21:39.558]                             name <- restart$name
[13:21:39.558]                             if (is.null(name)) 
[13:21:39.558]                               next
[13:21:39.558]                             if (!grepl(pattern, name)) 
[13:21:39.558]                               next
[13:21:39.558]                             invokeRestart(restart)
[13:21:39.558]                             muffled <- TRUE
[13:21:39.558]                             break
[13:21:39.558]                           }
[13:21:39.558]                         }
[13:21:39.558]                       }
[13:21:39.558]                       invisible(muffled)
[13:21:39.558]                     }
[13:21:39.558]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.558]                   }
[13:21:39.558]                 }
[13:21:39.558]                 else {
[13:21:39.558]                   if (TRUE) {
[13:21:39.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.558]                     {
[13:21:39.558]                       inherits <- base::inherits
[13:21:39.558]                       invokeRestart <- base::invokeRestart
[13:21:39.558]                       is.null <- base::is.null
[13:21:39.558]                       muffled <- FALSE
[13:21:39.558]                       if (inherits(cond, "message")) {
[13:21:39.558]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.558]                         if (muffled) 
[13:21:39.558]                           invokeRestart("muffleMessage")
[13:21:39.558]                       }
[13:21:39.558]                       else if (inherits(cond, "warning")) {
[13:21:39.558]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.558]                         if (muffled) 
[13:21:39.558]                           invokeRestart("muffleWarning")
[13:21:39.558]                       }
[13:21:39.558]                       else if (inherits(cond, "condition")) {
[13:21:39.558]                         if (!is.null(pattern)) {
[13:21:39.558]                           computeRestarts <- base::computeRestarts
[13:21:39.558]                           grepl <- base::grepl
[13:21:39.558]                           restarts <- computeRestarts(cond)
[13:21:39.558]                           for (restart in restarts) {
[13:21:39.558]                             name <- restart$name
[13:21:39.558]                             if (is.null(name)) 
[13:21:39.558]                               next
[13:21:39.558]                             if (!grepl(pattern, name)) 
[13:21:39.558]                               next
[13:21:39.558]                             invokeRestart(restart)
[13:21:39.558]                             muffled <- TRUE
[13:21:39.558]                             break
[13:21:39.558]                           }
[13:21:39.558]                         }
[13:21:39.558]                       }
[13:21:39.558]                       invisible(muffled)
[13:21:39.558]                     }
[13:21:39.558]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.558]                   }
[13:21:39.558]                 }
[13:21:39.558]             }
[13:21:39.558]         }))
[13:21:39.558]     }, error = function(ex) {
[13:21:39.558]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:39.558]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.558]                 ...future.rng), started = ...future.startTime, 
[13:21:39.558]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:39.558]             version = "1.8"), class = "FutureResult")
[13:21:39.558]     }, finally = {
[13:21:39.558]         if (!identical(...future.workdir, getwd())) 
[13:21:39.558]             setwd(...future.workdir)
[13:21:39.558]         {
[13:21:39.558]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:39.558]                 ...future.oldOptions$nwarnings <- NULL
[13:21:39.558]             }
[13:21:39.558]             base::options(...future.oldOptions)
[13:21:39.558]             if (.Platform$OS.type == "windows") {
[13:21:39.558]                 old_names <- names(...future.oldEnvVars)
[13:21:39.558]                 envs <- base::Sys.getenv()
[13:21:39.558]                 names <- names(envs)
[13:21:39.558]                 common <- intersect(names, old_names)
[13:21:39.558]                 added <- setdiff(names, old_names)
[13:21:39.558]                 removed <- setdiff(old_names, names)
[13:21:39.558]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:39.558]                   envs[common]]
[13:21:39.558]                 NAMES <- toupper(changed)
[13:21:39.558]                 args <- list()
[13:21:39.558]                 for (kk in seq_along(NAMES)) {
[13:21:39.558]                   name <- changed[[kk]]
[13:21:39.558]                   NAME <- NAMES[[kk]]
[13:21:39.558]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.558]                     next
[13:21:39.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.558]                 }
[13:21:39.558]                 NAMES <- toupper(added)
[13:21:39.558]                 for (kk in seq_along(NAMES)) {
[13:21:39.558]                   name <- added[[kk]]
[13:21:39.558]                   NAME <- NAMES[[kk]]
[13:21:39.558]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.558]                     next
[13:21:39.558]                   args[[name]] <- ""
[13:21:39.558]                 }
[13:21:39.558]                 NAMES <- toupper(removed)
[13:21:39.558]                 for (kk in seq_along(NAMES)) {
[13:21:39.558]                   name <- removed[[kk]]
[13:21:39.558]                   NAME <- NAMES[[kk]]
[13:21:39.558]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.558]                     next
[13:21:39.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.558]                 }
[13:21:39.558]                 if (length(args) > 0) 
[13:21:39.558]                   base::do.call(base::Sys.setenv, args = args)
[13:21:39.558]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:39.558]             }
[13:21:39.558]             else {
[13:21:39.558]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:39.558]             }
[13:21:39.558]             {
[13:21:39.558]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:39.558]                   0L) {
[13:21:39.558]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:39.558]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:39.558]                   base::options(opts)
[13:21:39.558]                 }
[13:21:39.558]                 {
[13:21:39.558]                   {
[13:21:39.558]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:39.558]                     NULL
[13:21:39.558]                   }
[13:21:39.558]                   options(future.plan = NULL)
[13:21:39.558]                   if (is.na(NA_character_)) 
[13:21:39.558]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.558]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:39.558]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:39.558]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:39.558]                     envir = parent.frame()) 
[13:21:39.558]                   {
[13:21:39.558]                     if (is.function(workers)) 
[13:21:39.558]                       workers <- workers()
[13:21:39.558]                     workers <- structure(as.integer(workers), 
[13:21:39.558]                       class = class(workers))
[13:21:39.558]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:39.558]                       workers >= 1)
[13:21:39.558]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:39.558]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:39.558]                     }
[13:21:39.558]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:39.558]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:39.558]                       envir = envir)
[13:21:39.558]                     if (!future$lazy) 
[13:21:39.558]                       future <- run(future)
[13:21:39.558]                     invisible(future)
[13:21:39.558]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:39.558]                 }
[13:21:39.558]             }
[13:21:39.558]         }
[13:21:39.558]     })
[13:21:39.558]     if (TRUE) {
[13:21:39.558]         base::sink(type = "output", split = FALSE)
[13:21:39.558]         if (TRUE) {
[13:21:39.558]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:39.558]         }
[13:21:39.558]         else {
[13:21:39.558]             ...future.result["stdout"] <- base::list(NULL)
[13:21:39.558]         }
[13:21:39.558]         base::close(...future.stdout)
[13:21:39.558]         ...future.stdout <- NULL
[13:21:39.558]     }
[13:21:39.558]     ...future.result$conditions <- ...future.conditions
[13:21:39.558]     ...future.result$finished <- base::Sys.time()
[13:21:39.558]     ...future.result
[13:21:39.558] }
[13:21:39.561] Exporting 11 global objects (103.08 KiB) to cluster node #2 ...
[13:21:39.562] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[13:21:39.604] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[13:21:39.605] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #2 ...
[13:21:39.605] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #2 ... DONE
[13:21:39.605] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[13:21:39.606] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[13:21:39.606] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[13:21:39.648] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[13:21:39.649] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[13:21:39.692] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[13:21:39.692] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[13:21:39.693] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[13:21:39.693] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[13:21:39.694] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[13:21:39.694] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:21:39.694] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:21:39.694] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[13:21:39.695] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[13:21:39.695] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:21:39.695] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:21:39.695] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:21:39.696] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:21:39.696] Exporting 11 global objects (103.08 KiB) to cluster node #2 ... DONE
[13:21:39.697] MultisessionFuture started
[13:21:39.697] - Launch lazy future ... done
[13:21:39.697] run() for ‘MultisessionFuture’ ... done
[13:21:39.697] Created future:
[13:21:39.697] MultisessionFuture:
[13:21:39.697] Label: ‘future_vapply-2’
[13:21:39.697] Expression:
[13:21:39.697] {
[13:21:39.697]     do.call(function(...) {
[13:21:39.697]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:39.697]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:39.697]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:39.697]             on.exit(options(oopts), add = TRUE)
[13:21:39.697]         }
[13:21:39.697]         {
[13:21:39.697]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:39.697]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:39.697]                 ...future.FUN(...future.X_jj, ...)
[13:21:39.697]             })
[13:21:39.697]         }
[13:21:39.697]     }, args = future.call.arguments)
[13:21:39.697] }
[13:21:39.697] Lazy evaluation: FALSE
[13:21:39.697] Asynchronous evaluation: TRUE
[13:21:39.697] Local evaluation: TRUE
[13:21:39.697] Environment: R_GlobalEnv
[13:21:39.697] Capture standard output: TRUE
[13:21:39.697] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:39.697] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:39.697] Packages: 1 packages (‘future.apply’)
[13:21:39.697] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:39.697] Resolved: FALSE
[13:21:39.697] Value: <not collected>
[13:21:39.697] Conditions captured: <none>
[13:21:39.697] Early signaling: FALSE
[13:21:39.697] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:39.697] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:39.709] Chunk #2 of 2 ... DONE
[13:21:39.709] Launching 2 futures (chunks) ... DONE
[13:21:39.710] Resolving 2 futures (chunks) ...
[13:21:39.710] resolve() on list ...
[13:21:39.710]  recursive: 0
[13:21:39.710]  length: 2
[13:21:39.710] 
[13:21:39.711] receiveMessageFromWorker() for ClusterFuture ...
[13:21:39.711] - Validating connection of MultisessionFuture
[13:21:39.711] - received message: FutureResult
[13:21:39.711] - Received FutureResult
[13:21:39.711] - Erased future from FutureRegistry
[13:21:39.711] result() for ClusterFuture ...
[13:21:39.711] - result already collected: FutureResult
[13:21:39.711] result() for ClusterFuture ... done
[13:21:39.712] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:39.712] Future #1
[13:21:39.712] result() for ClusterFuture ...
[13:21:39.712] - result already collected: FutureResult
[13:21:39.712] result() for ClusterFuture ... done
[13:21:39.712] result() for ClusterFuture ...
[13:21:39.712] - result already collected: FutureResult
[13:21:39.712] result() for ClusterFuture ... done
[13:21:39.712] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:21:39.712] - nx: 2
[13:21:39.713] - relay: TRUE
[13:21:39.713] - stdout: TRUE
[13:21:39.713] - signal: TRUE
[13:21:39.713] - resignal: FALSE
[13:21:39.713] - force: TRUE
[13:21:39.713] - relayed: [n=2] FALSE, FALSE
[13:21:39.713] - queued futures: [n=2] FALSE, FALSE
[13:21:39.713]  - until=1
[13:21:39.713]  - relaying element #1
[13:21:39.713] result() for ClusterFuture ...
[13:21:39.713] - result already collected: FutureResult
[13:21:39.714] result() for ClusterFuture ... done
[13:21:39.714] result() for ClusterFuture ...
[13:21:39.714] - result already collected: FutureResult
[13:21:39.714] result() for ClusterFuture ... done
[13:21:39.714] result() for ClusterFuture ...
[13:21:39.714] - result already collected: FutureResult
[13:21:39.714] result() for ClusterFuture ... done
[13:21:39.714] result() for ClusterFuture ...
[13:21:39.714] - result already collected: FutureResult
[13:21:39.714] result() for ClusterFuture ... done
[13:21:39.714] - relayed: [n=2] TRUE, FALSE
[13:21:39.715] - queued futures: [n=2] TRUE, FALSE
[13:21:39.715] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:21:39.715]  length: 1 (resolved future 1)
[13:21:39.745] receiveMessageFromWorker() for ClusterFuture ...
[13:21:39.746] - Validating connection of MultisessionFuture
[13:21:39.746] - received message: FutureResult
[13:21:39.746] - Received FutureResult
[13:21:39.746] - Erased future from FutureRegistry
[13:21:39.746] result() for ClusterFuture ...
[13:21:39.746] - result already collected: FutureResult
[13:21:39.747] result() for ClusterFuture ... done
[13:21:39.747] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:39.747] Future #2
[13:21:39.747] result() for ClusterFuture ...
[13:21:39.747] - result already collected: FutureResult
[13:21:39.747] result() for ClusterFuture ... done
[13:21:39.747] result() for ClusterFuture ...
[13:21:39.747] - result already collected: FutureResult
[13:21:39.747] result() for ClusterFuture ... done
[13:21:39.747] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:21:39.748] - nx: 2
[13:21:39.748] - relay: TRUE
[13:21:39.748] - stdout: TRUE
[13:21:39.748] - signal: TRUE
[13:21:39.748] - resignal: FALSE
[13:21:39.748] - force: TRUE
[13:21:39.748] - relayed: [n=2] TRUE, FALSE
[13:21:39.748] - queued futures: [n=2] TRUE, FALSE
[13:21:39.748]  - until=2
[13:21:39.748]  - relaying element #2
[13:21:39.748] result() for ClusterFuture ...
[13:21:39.749] - result already collected: FutureResult
[13:21:39.749] result() for ClusterFuture ... done
[13:21:39.749] result() for ClusterFuture ...
[13:21:39.749] - result already collected: FutureResult
[13:21:39.749] result() for ClusterFuture ... done
[13:21:39.749] result() for ClusterFuture ...
[13:21:39.749] - result already collected: FutureResult
[13:21:39.749] result() for ClusterFuture ... done
[13:21:39.749] result() for ClusterFuture ...
[13:21:39.749] - result already collected: FutureResult
[13:21:39.749] result() for ClusterFuture ... done
[13:21:39.750] - relayed: [n=2] TRUE, TRUE
[13:21:39.750] - queued futures: [n=2] TRUE, TRUE
[13:21:39.750] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:21:39.750]  length: 0 (resolved future 2)
[13:21:39.750] Relaying remaining futures
[13:21:39.750] signalConditionsASAP(NULL, pos=0) ...
[13:21:39.750] - nx: 2
[13:21:39.750] - relay: TRUE
[13:21:39.750] - stdout: TRUE
[13:21:39.750] - signal: TRUE
[13:21:39.750] - resignal: FALSE
[13:21:39.751] - force: TRUE
[13:21:39.751] - relayed: [n=2] TRUE, TRUE
[13:21:39.751] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:21:39.751] - relayed: [n=2] TRUE, TRUE
[13:21:39.751] - queued futures: [n=2] TRUE, TRUE
[13:21:39.751] signalConditionsASAP(NULL, pos=0) ... done
[13:21:39.751] resolve() on list ... DONE
[13:21:39.751] result() for ClusterFuture ...
[13:21:39.751] - result already collected: FutureResult
[13:21:39.751] result() for ClusterFuture ... done
[13:21:39.751] result() for ClusterFuture ...
[13:21:39.752] - result already collected: FutureResult
[13:21:39.752] result() for ClusterFuture ... done
[13:21:39.752] result() for ClusterFuture ...
[13:21:39.752] - result already collected: FutureResult
[13:21:39.752] result() for ClusterFuture ... done
[13:21:39.752] result() for ClusterFuture ...
[13:21:39.752] - result already collected: FutureResult
[13:21:39.752] result() for ClusterFuture ... done
[13:21:39.752]  - Number of value chunks collected: 2
[13:21:39.752] Resolving 2 futures (chunks) ... DONE
[13:21:39.753] Reducing values from 2 chunks ...
[13:21:39.753]  - Number of values collected after concatenation: 10
[13:21:39.753]  - Number of values expected: 10
[13:21:39.753] Reducing values from 2 chunks ... DONE
[13:21:39.753] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[13:21:39.755] future_lapply() ...
[13:21:39.761] Number of chunks: 2
[13:21:39.761] getGlobalsAndPackagesXApply() ...
[13:21:39.761]  - future.globals: TRUE
[13:21:39.761] getGlobalsAndPackages() ...
[13:21:39.762] Searching for globals...
[13:21:39.765] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[13:21:39.765] Searching for globals ... DONE
[13:21:39.765] Resolving globals: FALSE
[13:21:39.766] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[13:21:39.767] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:39.767] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:39.767] - packages: [2] ‘stats’, ‘future.apply’
[13:21:39.767] getGlobalsAndPackages() ... DONE
[13:21:39.767]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:39.767]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[13:21:39.767] Finding globals ... DONE
[13:21:39.767]  - use_args: TRUE
[13:21:39.768]  - Getting '...' globals ...
[13:21:39.768] resolve() on list ...
[13:21:39.768]  recursive: 0
[13:21:39.768]  length: 1
[13:21:39.768]  elements: ‘...’
[13:21:39.768]  length: 0 (resolved future 1)
[13:21:39.768] resolve() on list ... DONE
[13:21:39.768]    - '...' content: [n=0] 
[13:21:39.769] List of 1
[13:21:39.769]  $ ...: list()
[13:21:39.769]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:39.769]  - attr(*, "where")=List of 1
[13:21:39.769]   ..$ ...:<environment: 0x563b70022838> 
[13:21:39.769]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:39.769]  - attr(*, "resolved")= logi TRUE
[13:21:39.769]  - attr(*, "total_size")= num NA
[13:21:39.771]  - Getting '...' globals ... DONE
[13:21:39.771] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:39.771] List of 8
[13:21:39.771]  $ ...future.FUN:function (x, ...)  
[13:21:39.771]  $ x_FUN        :function (x, ...)  
[13:21:39.771]  $ times        : int 5
[13:21:39.771]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:39.771]  $ stop_if_not  :function (...)  
[13:21:39.771]  $ dim          : NULL
[13:21:39.771]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:21:39.771]  $ ...          : list()
[13:21:39.771]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:39.771]  - attr(*, "where")=List of 8
[13:21:39.771]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:39.771]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:39.771]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:39.771]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:39.771]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:39.771]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:39.771]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:39.771]   ..$ ...          :<environment: 0x563b70022838> 
[13:21:39.771]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:39.771]  - attr(*, "resolved")= logi FALSE
[13:21:39.771]  - attr(*, "total_size")= num 95528
[13:21:39.779] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[13:21:39.779] getGlobalsAndPackagesXApply() ... DONE
[13:21:39.780] Number of futures (= number of chunks): 2
[13:21:39.780] Launching 2 futures (chunks) ...
[13:21:39.780] Chunk #1 of 2 ...
[13:21:39.780]  - Finding globals in 'X' for chunk #1 ...
[13:21:39.780] getGlobalsAndPackages() ...
[13:21:39.780] Searching for globals...
[13:21:39.780] 
[13:21:39.780] Searching for globals ... DONE
[13:21:39.781] - globals: [0] <none>
[13:21:39.781] getGlobalsAndPackages() ... DONE
[13:21:39.781]    + additional globals found: [n=0] 
[13:21:39.781]    + additional namespaces needed: [n=0] 
[13:21:39.781]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:39.781]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:39.781]  - seeds: <none>
[13:21:39.781]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:39.781] getGlobalsAndPackages() ...
[13:21:39.781] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:39.782] Resolving globals: FALSE
[13:21:39.782] Tweak future expression to call with '...' arguments ...
[13:21:39.782] {
[13:21:39.782]     do.call(function(...) {
[13:21:39.782]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:39.782]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:39.782]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:39.782]             on.exit(options(oopts), add = TRUE)
[13:21:39.782]         }
[13:21:39.782]         {
[13:21:39.782]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:39.782]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:39.782]                 ...future.FUN(...future.X_jj, ...)
[13:21:39.782]             })
[13:21:39.782]         }
[13:21:39.782]     }, args = future.call.arguments)
[13:21:39.782] }
[13:21:39.782] Tweak future expression to call with '...' arguments ... DONE
[13:21:39.783] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:39.783] - packages: [2] ‘stats’, ‘future.apply’
[13:21:39.783] getGlobalsAndPackages() ... DONE
[13:21:39.783] run() for ‘Future’ ...
[13:21:39.783] - state: ‘created’
[13:21:39.783] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:39.798] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:39.798] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:39.799]   - Field: ‘node’
[13:21:39.799]   - Field: ‘label’
[13:21:39.799]   - Field: ‘local’
[13:21:39.799]   - Field: ‘owner’
[13:21:39.799]   - Field: ‘envir’
[13:21:39.799]   - Field: ‘workers’
[13:21:39.799]   - Field: ‘packages’
[13:21:39.799]   - Field: ‘gc’
[13:21:39.799]   - Field: ‘conditions’
[13:21:39.800]   - Field: ‘persistent’
[13:21:39.800]   - Field: ‘expr’
[13:21:39.800]   - Field: ‘uuid’
[13:21:39.800]   - Field: ‘seed’
[13:21:39.800]   - Field: ‘version’
[13:21:39.800]   - Field: ‘result’
[13:21:39.800]   - Field: ‘asynchronous’
[13:21:39.800]   - Field: ‘calls’
[13:21:39.800]   - Field: ‘globals’
[13:21:39.801]   - Field: ‘stdout’
[13:21:39.801]   - Field: ‘earlySignal’
[13:21:39.801]   - Field: ‘lazy’
[13:21:39.801]   - Field: ‘state’
[13:21:39.801] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:39.801] - Launch lazy future ...
[13:21:39.801] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[13:21:39.801] Packages needed by future strategies (n = 0): <none>
[13:21:39.802] {
[13:21:39.802]     {
[13:21:39.802]         {
[13:21:39.802]             ...future.startTime <- base::Sys.time()
[13:21:39.802]             {
[13:21:39.802]                 {
[13:21:39.802]                   {
[13:21:39.802]                     {
[13:21:39.802]                       {
[13:21:39.802]                         base::local({
[13:21:39.802]                           has_future <- base::requireNamespace("future", 
[13:21:39.802]                             quietly = TRUE)
[13:21:39.802]                           if (has_future) {
[13:21:39.802]                             ns <- base::getNamespace("future")
[13:21:39.802]                             version <- ns[[".package"]][["version"]]
[13:21:39.802]                             if (is.null(version)) 
[13:21:39.802]                               version <- utils::packageVersion("future")
[13:21:39.802]                           }
[13:21:39.802]                           else {
[13:21:39.802]                             version <- NULL
[13:21:39.802]                           }
[13:21:39.802]                           if (!has_future || version < "1.8.0") {
[13:21:39.802]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:39.802]                               "", base::R.version$version.string), 
[13:21:39.802]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:39.802]                                 base::R.version$platform, 8 * 
[13:21:39.802]                                   base::.Machine$sizeof.pointer), 
[13:21:39.802]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:39.802]                                 "release", "version")], collapse = " "), 
[13:21:39.802]                               hostname = base::Sys.info()[["nodename"]])
[13:21:39.802]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:39.802]                               info)
[13:21:39.802]                             info <- base::paste(info, collapse = "; ")
[13:21:39.802]                             if (!has_future) {
[13:21:39.802]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:39.802]                                 info)
[13:21:39.802]                             }
[13:21:39.802]                             else {
[13:21:39.802]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:39.802]                                 info, version)
[13:21:39.802]                             }
[13:21:39.802]                             base::stop(msg)
[13:21:39.802]                           }
[13:21:39.802]                         })
[13:21:39.802]                       }
[13:21:39.802]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:39.802]                       base::options(mc.cores = 1L)
[13:21:39.802]                     }
[13:21:39.802]                     base::local({
[13:21:39.802]                       for (pkg in c("stats", "future.apply")) {
[13:21:39.802]                         base::loadNamespace(pkg)
[13:21:39.802]                         base::library(pkg, character.only = TRUE)
[13:21:39.802]                       }
[13:21:39.802]                     })
[13:21:39.802]                   }
[13:21:39.802]                   options(future.plan = NULL)
[13:21:39.802]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.802]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:39.802]                 }
[13:21:39.802]                 ...future.workdir <- getwd()
[13:21:39.802]             }
[13:21:39.802]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:39.802]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:39.802]         }
[13:21:39.802]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:39.802]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:39.802]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:39.802]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:39.802]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:39.802]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:39.802]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:39.802]             base::names(...future.oldOptions))
[13:21:39.802]     }
[13:21:39.802]     if (FALSE) {
[13:21:39.802]     }
[13:21:39.802]     else {
[13:21:39.802]         if (TRUE) {
[13:21:39.802]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:39.802]                 open = "w")
[13:21:39.802]         }
[13:21:39.802]         else {
[13:21:39.802]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:39.802]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:39.802]         }
[13:21:39.802]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:39.802]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:39.802]             base::sink(type = "output", split = FALSE)
[13:21:39.802]             base::close(...future.stdout)
[13:21:39.802]         }, add = TRUE)
[13:21:39.802]     }
[13:21:39.802]     ...future.frame <- base::sys.nframe()
[13:21:39.802]     ...future.conditions <- base::list()
[13:21:39.802]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:39.802]     if (FALSE) {
[13:21:39.802]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:39.802]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:39.802]     }
[13:21:39.802]     ...future.result <- base::tryCatch({
[13:21:39.802]         base::withCallingHandlers({
[13:21:39.802]             ...future.value <- base::withVisible(base::local({
[13:21:39.802]                 ...future.makeSendCondition <- base::local({
[13:21:39.802]                   sendCondition <- NULL
[13:21:39.802]                   function(frame = 1L) {
[13:21:39.802]                     if (is.function(sendCondition)) 
[13:21:39.802]                       return(sendCondition)
[13:21:39.802]                     ns <- getNamespace("parallel")
[13:21:39.802]                     if (exists("sendData", mode = "function", 
[13:21:39.802]                       envir = ns)) {
[13:21:39.802]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:39.802]                         envir = ns)
[13:21:39.802]                       envir <- sys.frame(frame)
[13:21:39.802]                       master <- NULL
[13:21:39.802]                       while (!identical(envir, .GlobalEnv) && 
[13:21:39.802]                         !identical(envir, emptyenv())) {
[13:21:39.802]                         if (exists("master", mode = "list", envir = envir, 
[13:21:39.802]                           inherits = FALSE)) {
[13:21:39.802]                           master <- get("master", mode = "list", 
[13:21:39.802]                             envir = envir, inherits = FALSE)
[13:21:39.802]                           if (inherits(master, c("SOCKnode", 
[13:21:39.802]                             "SOCK0node"))) {
[13:21:39.802]                             sendCondition <<- function(cond) {
[13:21:39.802]                               data <- list(type = "VALUE", value = cond, 
[13:21:39.802]                                 success = TRUE)
[13:21:39.802]                               parallel_sendData(master, data)
[13:21:39.802]                             }
[13:21:39.802]                             return(sendCondition)
[13:21:39.802]                           }
[13:21:39.802]                         }
[13:21:39.802]                         frame <- frame + 1L
[13:21:39.802]                         envir <- sys.frame(frame)
[13:21:39.802]                       }
[13:21:39.802]                     }
[13:21:39.802]                     sendCondition <<- function(cond) NULL
[13:21:39.802]                   }
[13:21:39.802]                 })
[13:21:39.802]                 withCallingHandlers({
[13:21:39.802]                   {
[13:21:39.802]                     do.call(function(...) {
[13:21:39.802]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:39.802]                       if (!identical(...future.globals.maxSize.org, 
[13:21:39.802]                         ...future.globals.maxSize)) {
[13:21:39.802]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:39.802]                         on.exit(options(oopts), add = TRUE)
[13:21:39.802]                       }
[13:21:39.802]                       {
[13:21:39.802]                         lapply(seq_along(...future.elements_ii), 
[13:21:39.802]                           FUN = function(jj) {
[13:21:39.802]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:39.802]                             ...future.FUN(...future.X_jj, ...)
[13:21:39.802]                           })
[13:21:39.802]                       }
[13:21:39.802]                     }, args = future.call.arguments)
[13:21:39.802]                   }
[13:21:39.802]                 }, immediateCondition = function(cond) {
[13:21:39.802]                   sendCondition <- ...future.makeSendCondition()
[13:21:39.802]                   sendCondition(cond)
[13:21:39.802]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.802]                   {
[13:21:39.802]                     inherits <- base::inherits
[13:21:39.802]                     invokeRestart <- base::invokeRestart
[13:21:39.802]                     is.null <- base::is.null
[13:21:39.802]                     muffled <- FALSE
[13:21:39.802]                     if (inherits(cond, "message")) {
[13:21:39.802]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:39.802]                       if (muffled) 
[13:21:39.802]                         invokeRestart("muffleMessage")
[13:21:39.802]                     }
[13:21:39.802]                     else if (inherits(cond, "warning")) {
[13:21:39.802]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:39.802]                       if (muffled) 
[13:21:39.802]                         invokeRestart("muffleWarning")
[13:21:39.802]                     }
[13:21:39.802]                     else if (inherits(cond, "condition")) {
[13:21:39.802]                       if (!is.null(pattern)) {
[13:21:39.802]                         computeRestarts <- base::computeRestarts
[13:21:39.802]                         grepl <- base::grepl
[13:21:39.802]                         restarts <- computeRestarts(cond)
[13:21:39.802]                         for (restart in restarts) {
[13:21:39.802]                           name <- restart$name
[13:21:39.802]                           if (is.null(name)) 
[13:21:39.802]                             next
[13:21:39.802]                           if (!grepl(pattern, name)) 
[13:21:39.802]                             next
[13:21:39.802]                           invokeRestart(restart)
[13:21:39.802]                           muffled <- TRUE
[13:21:39.802]                           break
[13:21:39.802]                         }
[13:21:39.802]                       }
[13:21:39.802]                     }
[13:21:39.802]                     invisible(muffled)
[13:21:39.802]                   }
[13:21:39.802]                   muffleCondition(cond)
[13:21:39.802]                 })
[13:21:39.802]             }))
[13:21:39.802]             future::FutureResult(value = ...future.value$value, 
[13:21:39.802]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.802]                   ...future.rng), globalenv = if (FALSE) 
[13:21:39.802]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:39.802]                     ...future.globalenv.names))
[13:21:39.802]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:39.802]         }, condition = base::local({
[13:21:39.802]             c <- base::c
[13:21:39.802]             inherits <- base::inherits
[13:21:39.802]             invokeRestart <- base::invokeRestart
[13:21:39.802]             length <- base::length
[13:21:39.802]             list <- base::list
[13:21:39.802]             seq.int <- base::seq.int
[13:21:39.802]             signalCondition <- base::signalCondition
[13:21:39.802]             sys.calls <- base::sys.calls
[13:21:39.802]             `[[` <- base::`[[`
[13:21:39.802]             `+` <- base::`+`
[13:21:39.802]             `<<-` <- base::`<<-`
[13:21:39.802]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:39.802]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:39.802]                   3L)]
[13:21:39.802]             }
[13:21:39.802]             function(cond) {
[13:21:39.802]                 is_error <- inherits(cond, "error")
[13:21:39.802]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:39.802]                   NULL)
[13:21:39.802]                 if (is_error) {
[13:21:39.802]                   sessionInformation <- function() {
[13:21:39.802]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:39.802]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:39.802]                       search = base::search(), system = base::Sys.info())
[13:21:39.802]                   }
[13:21:39.802]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.802]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:39.802]                     cond$call), session = sessionInformation(), 
[13:21:39.802]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:39.802]                   signalCondition(cond)
[13:21:39.802]                 }
[13:21:39.802]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:39.802]                 "immediateCondition"))) {
[13:21:39.802]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:39.802]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.802]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:39.802]                   if (TRUE && !signal) {
[13:21:39.802]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.802]                     {
[13:21:39.802]                       inherits <- base::inherits
[13:21:39.802]                       invokeRestart <- base::invokeRestart
[13:21:39.802]                       is.null <- base::is.null
[13:21:39.802]                       muffled <- FALSE
[13:21:39.802]                       if (inherits(cond, "message")) {
[13:21:39.802]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.802]                         if (muffled) 
[13:21:39.802]                           invokeRestart("muffleMessage")
[13:21:39.802]                       }
[13:21:39.802]                       else if (inherits(cond, "warning")) {
[13:21:39.802]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.802]                         if (muffled) 
[13:21:39.802]                           invokeRestart("muffleWarning")
[13:21:39.802]                       }
[13:21:39.802]                       else if (inherits(cond, "condition")) {
[13:21:39.802]                         if (!is.null(pattern)) {
[13:21:39.802]                           computeRestarts <- base::computeRestarts
[13:21:39.802]                           grepl <- base::grepl
[13:21:39.802]                           restarts <- computeRestarts(cond)
[13:21:39.802]                           for (restart in restarts) {
[13:21:39.802]                             name <- restart$name
[13:21:39.802]                             if (is.null(name)) 
[13:21:39.802]                               next
[13:21:39.802]                             if (!grepl(pattern, name)) 
[13:21:39.802]                               next
[13:21:39.802]                             invokeRestart(restart)
[13:21:39.802]                             muffled <- TRUE
[13:21:39.802]                             break
[13:21:39.802]                           }
[13:21:39.802]                         }
[13:21:39.802]                       }
[13:21:39.802]                       invisible(muffled)
[13:21:39.802]                     }
[13:21:39.802]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.802]                   }
[13:21:39.802]                 }
[13:21:39.802]                 else {
[13:21:39.802]                   if (TRUE) {
[13:21:39.802]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.802]                     {
[13:21:39.802]                       inherits <- base::inherits
[13:21:39.802]                       invokeRestart <- base::invokeRestart
[13:21:39.802]                       is.null <- base::is.null
[13:21:39.802]                       muffled <- FALSE
[13:21:39.802]                       if (inherits(cond, "message")) {
[13:21:39.802]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.802]                         if (muffled) 
[13:21:39.802]                           invokeRestart("muffleMessage")
[13:21:39.802]                       }
[13:21:39.802]                       else if (inherits(cond, "warning")) {
[13:21:39.802]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.802]                         if (muffled) 
[13:21:39.802]                           invokeRestart("muffleWarning")
[13:21:39.802]                       }
[13:21:39.802]                       else if (inherits(cond, "condition")) {
[13:21:39.802]                         if (!is.null(pattern)) {
[13:21:39.802]                           computeRestarts <- base::computeRestarts
[13:21:39.802]                           grepl <- base::grepl
[13:21:39.802]                           restarts <- computeRestarts(cond)
[13:21:39.802]                           for (restart in restarts) {
[13:21:39.802]                             name <- restart$name
[13:21:39.802]                             if (is.null(name)) 
[13:21:39.802]                               next
[13:21:39.802]                             if (!grepl(pattern, name)) 
[13:21:39.802]                               next
[13:21:39.802]                             invokeRestart(restart)
[13:21:39.802]                             muffled <- TRUE
[13:21:39.802]                             break
[13:21:39.802]                           }
[13:21:39.802]                         }
[13:21:39.802]                       }
[13:21:39.802]                       invisible(muffled)
[13:21:39.802]                     }
[13:21:39.802]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.802]                   }
[13:21:39.802]                 }
[13:21:39.802]             }
[13:21:39.802]         }))
[13:21:39.802]     }, error = function(ex) {
[13:21:39.802]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:39.802]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.802]                 ...future.rng), started = ...future.startTime, 
[13:21:39.802]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:39.802]             version = "1.8"), class = "FutureResult")
[13:21:39.802]     }, finally = {
[13:21:39.802]         if (!identical(...future.workdir, getwd())) 
[13:21:39.802]             setwd(...future.workdir)
[13:21:39.802]         {
[13:21:39.802]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:39.802]                 ...future.oldOptions$nwarnings <- NULL
[13:21:39.802]             }
[13:21:39.802]             base::options(...future.oldOptions)
[13:21:39.802]             if (.Platform$OS.type == "windows") {
[13:21:39.802]                 old_names <- names(...future.oldEnvVars)
[13:21:39.802]                 envs <- base::Sys.getenv()
[13:21:39.802]                 names <- names(envs)
[13:21:39.802]                 common <- intersect(names, old_names)
[13:21:39.802]                 added <- setdiff(names, old_names)
[13:21:39.802]                 removed <- setdiff(old_names, names)
[13:21:39.802]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:39.802]                   envs[common]]
[13:21:39.802]                 NAMES <- toupper(changed)
[13:21:39.802]                 args <- list()
[13:21:39.802]                 for (kk in seq_along(NAMES)) {
[13:21:39.802]                   name <- changed[[kk]]
[13:21:39.802]                   NAME <- NAMES[[kk]]
[13:21:39.802]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.802]                     next
[13:21:39.802]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.802]                 }
[13:21:39.802]                 NAMES <- toupper(added)
[13:21:39.802]                 for (kk in seq_along(NAMES)) {
[13:21:39.802]                   name <- added[[kk]]
[13:21:39.802]                   NAME <- NAMES[[kk]]
[13:21:39.802]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.802]                     next
[13:21:39.802]                   args[[name]] <- ""
[13:21:39.802]                 }
[13:21:39.802]                 NAMES <- toupper(removed)
[13:21:39.802]                 for (kk in seq_along(NAMES)) {
[13:21:39.802]                   name <- removed[[kk]]
[13:21:39.802]                   NAME <- NAMES[[kk]]
[13:21:39.802]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.802]                     next
[13:21:39.802]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.802]                 }
[13:21:39.802]                 if (length(args) > 0) 
[13:21:39.802]                   base::do.call(base::Sys.setenv, args = args)
[13:21:39.802]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:39.802]             }
[13:21:39.802]             else {
[13:21:39.802]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:39.802]             }
[13:21:39.802]             {
[13:21:39.802]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:39.802]                   0L) {
[13:21:39.802]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:39.802]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:39.802]                   base::options(opts)
[13:21:39.802]                 }
[13:21:39.802]                 {
[13:21:39.802]                   {
[13:21:39.802]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:39.802]                     NULL
[13:21:39.802]                   }
[13:21:39.802]                   options(future.plan = NULL)
[13:21:39.802]                   if (is.na(NA_character_)) 
[13:21:39.802]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.802]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:39.802]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:39.802]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:39.802]                     envir = parent.frame()) 
[13:21:39.802]                   {
[13:21:39.802]                     if (is.function(workers)) 
[13:21:39.802]                       workers <- workers()
[13:21:39.802]                     workers <- structure(as.integer(workers), 
[13:21:39.802]                       class = class(workers))
[13:21:39.802]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:39.802]                       workers >= 1)
[13:21:39.802]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:39.802]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:39.802]                     }
[13:21:39.802]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:39.802]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:39.802]                       envir = envir)
[13:21:39.802]                     if (!future$lazy) 
[13:21:39.802]                       future <- run(future)
[13:21:39.802]                     invisible(future)
[13:21:39.802]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:39.802]                 }
[13:21:39.802]             }
[13:21:39.802]         }
[13:21:39.802]     })
[13:21:39.802]     if (TRUE) {
[13:21:39.802]         base::sink(type = "output", split = FALSE)
[13:21:39.802]         if (TRUE) {
[13:21:39.802]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:39.802]         }
[13:21:39.802]         else {
[13:21:39.802]             ...future.result["stdout"] <- base::list(NULL)
[13:21:39.802]         }
[13:21:39.802]         base::close(...future.stdout)
[13:21:39.802]         ...future.stdout <- NULL
[13:21:39.802]     }
[13:21:39.802]     ...future.result$conditions <- ...future.conditions
[13:21:39.802]     ...future.result$finished <- base::Sys.time()
[13:21:39.802]     ...future.result
[13:21:39.802] }
[13:21:39.805] Exporting 11 global objects (93.29 KiB) to cluster node #1 ...
[13:21:39.805] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:21:39.848] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:21:39.849] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #1 ...
[13:21:39.849] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #1 ... DONE
[13:21:39.849] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:21:39.850] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:21:39.850] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:21:39.892] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:21:39.893] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:21:39.936] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:21:39.936] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[13:21:39.937] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[13:21:39.937] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[13:21:39.937] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[13:21:39.938] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:21:39.938] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:21:39.938] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ...
[13:21:39.939] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ... DONE
[13:21:39.939] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:21:39.939] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:21:39.939] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:21:39.940] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:21:39.940] Exporting 11 global objects (93.29 KiB) to cluster node #1 ... DONE
[13:21:39.941] MultisessionFuture started
[13:21:39.941] - Launch lazy future ... done
[13:21:39.941] run() for ‘MultisessionFuture’ ... done
[13:21:39.941] Created future:
[13:21:39.941] MultisessionFuture:
[13:21:39.941] Label: ‘future_vapply-1’
[13:21:39.941] Expression:
[13:21:39.941] {
[13:21:39.941]     do.call(function(...) {
[13:21:39.941]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:39.941]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:39.941]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:39.941]             on.exit(options(oopts), add = TRUE)
[13:21:39.941]         }
[13:21:39.941]         {
[13:21:39.941]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:39.941]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:39.941]                 ...future.FUN(...future.X_jj, ...)
[13:21:39.941]             })
[13:21:39.941]         }
[13:21:39.941]     }, args = future.call.arguments)
[13:21:39.941] }
[13:21:39.941] Lazy evaluation: FALSE
[13:21:39.941] Asynchronous evaluation: TRUE
[13:21:39.941] Local evaluation: TRUE
[13:21:39.941] Environment: R_GlobalEnv
[13:21:39.941] Capture standard output: TRUE
[13:21:39.941] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:39.941] Globals: 11 objects totaling 93.38 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:39.941] Packages: 2 packages (‘stats’, ‘future.apply’)
[13:21:39.941] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:39.941] Resolved: FALSE
[13:21:39.941] Value: <not collected>
[13:21:39.941] Conditions captured: <none>
[13:21:39.941] Early signaling: FALSE
[13:21:39.941] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:39.941] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:39.953] Chunk #1 of 2 ... DONE
[13:21:39.953] Chunk #2 of 2 ...
[13:21:39.953]  - Finding globals in 'X' for chunk #2 ...
[13:21:39.954] getGlobalsAndPackages() ...
[13:21:39.954] Searching for globals...
[13:21:39.954] 
[13:21:39.954] Searching for globals ... DONE
[13:21:39.954] - globals: [0] <none>
[13:21:39.954] getGlobalsAndPackages() ... DONE
[13:21:39.954]    + additional globals found: [n=0] 
[13:21:39.954]    + additional namespaces needed: [n=0] 
[13:21:39.955]  - Finding globals in 'X' for chunk #2 ... DONE
[13:21:39.955]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:39.955]  - seeds: <none>
[13:21:39.955]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:39.955] getGlobalsAndPackages() ...
[13:21:39.955] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:39.955] Resolving globals: FALSE
[13:21:39.955] Tweak future expression to call with '...' arguments ...
[13:21:39.955] {
[13:21:39.955]     do.call(function(...) {
[13:21:39.955]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:39.955]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:39.955]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:39.955]             on.exit(options(oopts), add = TRUE)
[13:21:39.955]         }
[13:21:39.955]         {
[13:21:39.955]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:39.955]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:39.955]                 ...future.FUN(...future.X_jj, ...)
[13:21:39.955]             })
[13:21:39.955]         }
[13:21:39.955]     }, args = future.call.arguments)
[13:21:39.955] }
[13:21:39.956] Tweak future expression to call with '...' arguments ... DONE
[13:21:39.956] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:39.957] - packages: [2] ‘stats’, ‘future.apply’
[13:21:39.957] getGlobalsAndPackages() ... DONE
[13:21:39.957] run() for ‘Future’ ...
[13:21:39.957] - state: ‘created’
[13:21:39.957] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:39.971] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:39.971] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:39.972]   - Field: ‘node’
[13:21:39.972]   - Field: ‘label’
[13:21:39.972]   - Field: ‘local’
[13:21:39.972]   - Field: ‘owner’
[13:21:39.972]   - Field: ‘envir’
[13:21:39.972]   - Field: ‘workers’
[13:21:39.972]   - Field: ‘packages’
[13:21:39.972]   - Field: ‘gc’
[13:21:39.973]   - Field: ‘conditions’
[13:21:39.973]   - Field: ‘persistent’
[13:21:39.973]   - Field: ‘expr’
[13:21:39.973]   - Field: ‘uuid’
[13:21:39.973]   - Field: ‘seed’
[13:21:39.973]   - Field: ‘version’
[13:21:39.973]   - Field: ‘result’
[13:21:39.973]   - Field: ‘asynchronous’
[13:21:39.973]   - Field: ‘calls’
[13:21:39.973]   - Field: ‘globals’
[13:21:39.973]   - Field: ‘stdout’
[13:21:39.974]   - Field: ‘earlySignal’
[13:21:39.974]   - Field: ‘lazy’
[13:21:39.974]   - Field: ‘state’
[13:21:39.974] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:39.974] - Launch lazy future ...
[13:21:39.974] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[13:21:39.974] Packages needed by future strategies (n = 0): <none>
[13:21:39.975] {
[13:21:39.975]     {
[13:21:39.975]         {
[13:21:39.975]             ...future.startTime <- base::Sys.time()
[13:21:39.975]             {
[13:21:39.975]                 {
[13:21:39.975]                   {
[13:21:39.975]                     {
[13:21:39.975]                       {
[13:21:39.975]                         base::local({
[13:21:39.975]                           has_future <- base::requireNamespace("future", 
[13:21:39.975]                             quietly = TRUE)
[13:21:39.975]                           if (has_future) {
[13:21:39.975]                             ns <- base::getNamespace("future")
[13:21:39.975]                             version <- ns[[".package"]][["version"]]
[13:21:39.975]                             if (is.null(version)) 
[13:21:39.975]                               version <- utils::packageVersion("future")
[13:21:39.975]                           }
[13:21:39.975]                           else {
[13:21:39.975]                             version <- NULL
[13:21:39.975]                           }
[13:21:39.975]                           if (!has_future || version < "1.8.0") {
[13:21:39.975]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:39.975]                               "", base::R.version$version.string), 
[13:21:39.975]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:39.975]                                 base::R.version$platform, 8 * 
[13:21:39.975]                                   base::.Machine$sizeof.pointer), 
[13:21:39.975]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:39.975]                                 "release", "version")], collapse = " "), 
[13:21:39.975]                               hostname = base::Sys.info()[["nodename"]])
[13:21:39.975]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:39.975]                               info)
[13:21:39.975]                             info <- base::paste(info, collapse = "; ")
[13:21:39.975]                             if (!has_future) {
[13:21:39.975]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:39.975]                                 info)
[13:21:39.975]                             }
[13:21:39.975]                             else {
[13:21:39.975]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:39.975]                                 info, version)
[13:21:39.975]                             }
[13:21:39.975]                             base::stop(msg)
[13:21:39.975]                           }
[13:21:39.975]                         })
[13:21:39.975]                       }
[13:21:39.975]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:39.975]                       base::options(mc.cores = 1L)
[13:21:39.975]                     }
[13:21:39.975]                     base::local({
[13:21:39.975]                       for (pkg in c("stats", "future.apply")) {
[13:21:39.975]                         base::loadNamespace(pkg)
[13:21:39.975]                         base::library(pkg, character.only = TRUE)
[13:21:39.975]                       }
[13:21:39.975]                     })
[13:21:39.975]                   }
[13:21:39.975]                   options(future.plan = NULL)
[13:21:39.975]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.975]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:39.975]                 }
[13:21:39.975]                 ...future.workdir <- getwd()
[13:21:39.975]             }
[13:21:39.975]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:39.975]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:39.975]         }
[13:21:39.975]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:39.975]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:39.975]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:39.975]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:39.975]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:39.975]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:39.975]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:39.975]             base::names(...future.oldOptions))
[13:21:39.975]     }
[13:21:39.975]     if (FALSE) {
[13:21:39.975]     }
[13:21:39.975]     else {
[13:21:39.975]         if (TRUE) {
[13:21:39.975]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:39.975]                 open = "w")
[13:21:39.975]         }
[13:21:39.975]         else {
[13:21:39.975]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:39.975]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:39.975]         }
[13:21:39.975]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:39.975]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:39.975]             base::sink(type = "output", split = FALSE)
[13:21:39.975]             base::close(...future.stdout)
[13:21:39.975]         }, add = TRUE)
[13:21:39.975]     }
[13:21:39.975]     ...future.frame <- base::sys.nframe()
[13:21:39.975]     ...future.conditions <- base::list()
[13:21:39.975]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:39.975]     if (FALSE) {
[13:21:39.975]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:39.975]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:39.975]     }
[13:21:39.975]     ...future.result <- base::tryCatch({
[13:21:39.975]         base::withCallingHandlers({
[13:21:39.975]             ...future.value <- base::withVisible(base::local({
[13:21:39.975]                 ...future.makeSendCondition <- base::local({
[13:21:39.975]                   sendCondition <- NULL
[13:21:39.975]                   function(frame = 1L) {
[13:21:39.975]                     if (is.function(sendCondition)) 
[13:21:39.975]                       return(sendCondition)
[13:21:39.975]                     ns <- getNamespace("parallel")
[13:21:39.975]                     if (exists("sendData", mode = "function", 
[13:21:39.975]                       envir = ns)) {
[13:21:39.975]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:39.975]                         envir = ns)
[13:21:39.975]                       envir <- sys.frame(frame)
[13:21:39.975]                       master <- NULL
[13:21:39.975]                       while (!identical(envir, .GlobalEnv) && 
[13:21:39.975]                         !identical(envir, emptyenv())) {
[13:21:39.975]                         if (exists("master", mode = "list", envir = envir, 
[13:21:39.975]                           inherits = FALSE)) {
[13:21:39.975]                           master <- get("master", mode = "list", 
[13:21:39.975]                             envir = envir, inherits = FALSE)
[13:21:39.975]                           if (inherits(master, c("SOCKnode", 
[13:21:39.975]                             "SOCK0node"))) {
[13:21:39.975]                             sendCondition <<- function(cond) {
[13:21:39.975]                               data <- list(type = "VALUE", value = cond, 
[13:21:39.975]                                 success = TRUE)
[13:21:39.975]                               parallel_sendData(master, data)
[13:21:39.975]                             }
[13:21:39.975]                             return(sendCondition)
[13:21:39.975]                           }
[13:21:39.975]                         }
[13:21:39.975]                         frame <- frame + 1L
[13:21:39.975]                         envir <- sys.frame(frame)
[13:21:39.975]                       }
[13:21:39.975]                     }
[13:21:39.975]                     sendCondition <<- function(cond) NULL
[13:21:39.975]                   }
[13:21:39.975]                 })
[13:21:39.975]                 withCallingHandlers({
[13:21:39.975]                   {
[13:21:39.975]                     do.call(function(...) {
[13:21:39.975]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:39.975]                       if (!identical(...future.globals.maxSize.org, 
[13:21:39.975]                         ...future.globals.maxSize)) {
[13:21:39.975]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:39.975]                         on.exit(options(oopts), add = TRUE)
[13:21:39.975]                       }
[13:21:39.975]                       {
[13:21:39.975]                         lapply(seq_along(...future.elements_ii), 
[13:21:39.975]                           FUN = function(jj) {
[13:21:39.975]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:39.975]                             ...future.FUN(...future.X_jj, ...)
[13:21:39.975]                           })
[13:21:39.975]                       }
[13:21:39.975]                     }, args = future.call.arguments)
[13:21:39.975]                   }
[13:21:39.975]                 }, immediateCondition = function(cond) {
[13:21:39.975]                   sendCondition <- ...future.makeSendCondition()
[13:21:39.975]                   sendCondition(cond)
[13:21:39.975]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.975]                   {
[13:21:39.975]                     inherits <- base::inherits
[13:21:39.975]                     invokeRestart <- base::invokeRestart
[13:21:39.975]                     is.null <- base::is.null
[13:21:39.975]                     muffled <- FALSE
[13:21:39.975]                     if (inherits(cond, "message")) {
[13:21:39.975]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:39.975]                       if (muffled) 
[13:21:39.975]                         invokeRestart("muffleMessage")
[13:21:39.975]                     }
[13:21:39.975]                     else if (inherits(cond, "warning")) {
[13:21:39.975]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:39.975]                       if (muffled) 
[13:21:39.975]                         invokeRestart("muffleWarning")
[13:21:39.975]                     }
[13:21:39.975]                     else if (inherits(cond, "condition")) {
[13:21:39.975]                       if (!is.null(pattern)) {
[13:21:39.975]                         computeRestarts <- base::computeRestarts
[13:21:39.975]                         grepl <- base::grepl
[13:21:39.975]                         restarts <- computeRestarts(cond)
[13:21:39.975]                         for (restart in restarts) {
[13:21:39.975]                           name <- restart$name
[13:21:39.975]                           if (is.null(name)) 
[13:21:39.975]                             next
[13:21:39.975]                           if (!grepl(pattern, name)) 
[13:21:39.975]                             next
[13:21:39.975]                           invokeRestart(restart)
[13:21:39.975]                           muffled <- TRUE
[13:21:39.975]                           break
[13:21:39.975]                         }
[13:21:39.975]                       }
[13:21:39.975]                     }
[13:21:39.975]                     invisible(muffled)
[13:21:39.975]                   }
[13:21:39.975]                   muffleCondition(cond)
[13:21:39.975]                 })
[13:21:39.975]             }))
[13:21:39.975]             future::FutureResult(value = ...future.value$value, 
[13:21:39.975]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.975]                   ...future.rng), globalenv = if (FALSE) 
[13:21:39.975]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:39.975]                     ...future.globalenv.names))
[13:21:39.975]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:39.975]         }, condition = base::local({
[13:21:39.975]             c <- base::c
[13:21:39.975]             inherits <- base::inherits
[13:21:39.975]             invokeRestart <- base::invokeRestart
[13:21:39.975]             length <- base::length
[13:21:39.975]             list <- base::list
[13:21:39.975]             seq.int <- base::seq.int
[13:21:39.975]             signalCondition <- base::signalCondition
[13:21:39.975]             sys.calls <- base::sys.calls
[13:21:39.975]             `[[` <- base::`[[`
[13:21:39.975]             `+` <- base::`+`
[13:21:39.975]             `<<-` <- base::`<<-`
[13:21:39.975]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:39.975]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:39.975]                   3L)]
[13:21:39.975]             }
[13:21:39.975]             function(cond) {
[13:21:39.975]                 is_error <- inherits(cond, "error")
[13:21:39.975]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:39.975]                   NULL)
[13:21:39.975]                 if (is_error) {
[13:21:39.975]                   sessionInformation <- function() {
[13:21:39.975]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:39.975]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:39.975]                       search = base::search(), system = base::Sys.info())
[13:21:39.975]                   }
[13:21:39.975]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.975]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:39.975]                     cond$call), session = sessionInformation(), 
[13:21:39.975]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:39.975]                   signalCondition(cond)
[13:21:39.975]                 }
[13:21:39.975]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:39.975]                 "immediateCondition"))) {
[13:21:39.975]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:39.975]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.975]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:39.975]                   if (TRUE && !signal) {
[13:21:39.975]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.975]                     {
[13:21:39.975]                       inherits <- base::inherits
[13:21:39.975]                       invokeRestart <- base::invokeRestart
[13:21:39.975]                       is.null <- base::is.null
[13:21:39.975]                       muffled <- FALSE
[13:21:39.975]                       if (inherits(cond, "message")) {
[13:21:39.975]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.975]                         if (muffled) 
[13:21:39.975]                           invokeRestart("muffleMessage")
[13:21:39.975]                       }
[13:21:39.975]                       else if (inherits(cond, "warning")) {
[13:21:39.975]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.975]                         if (muffled) 
[13:21:39.975]                           invokeRestart("muffleWarning")
[13:21:39.975]                       }
[13:21:39.975]                       else if (inherits(cond, "condition")) {
[13:21:39.975]                         if (!is.null(pattern)) {
[13:21:39.975]                           computeRestarts <- base::computeRestarts
[13:21:39.975]                           grepl <- base::grepl
[13:21:39.975]                           restarts <- computeRestarts(cond)
[13:21:39.975]                           for (restart in restarts) {
[13:21:39.975]                             name <- restart$name
[13:21:39.975]                             if (is.null(name)) 
[13:21:39.975]                               next
[13:21:39.975]                             if (!grepl(pattern, name)) 
[13:21:39.975]                               next
[13:21:39.975]                             invokeRestart(restart)
[13:21:39.975]                             muffled <- TRUE
[13:21:39.975]                             break
[13:21:39.975]                           }
[13:21:39.975]                         }
[13:21:39.975]                       }
[13:21:39.975]                       invisible(muffled)
[13:21:39.975]                     }
[13:21:39.975]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.975]                   }
[13:21:39.975]                 }
[13:21:39.975]                 else {
[13:21:39.975]                   if (TRUE) {
[13:21:39.975]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.975]                     {
[13:21:39.975]                       inherits <- base::inherits
[13:21:39.975]                       invokeRestart <- base::invokeRestart
[13:21:39.975]                       is.null <- base::is.null
[13:21:39.975]                       muffled <- FALSE
[13:21:39.975]                       if (inherits(cond, "message")) {
[13:21:39.975]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.975]                         if (muffled) 
[13:21:39.975]                           invokeRestart("muffleMessage")
[13:21:39.975]                       }
[13:21:39.975]                       else if (inherits(cond, "warning")) {
[13:21:39.975]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.975]                         if (muffled) 
[13:21:39.975]                           invokeRestart("muffleWarning")
[13:21:39.975]                       }
[13:21:39.975]                       else if (inherits(cond, "condition")) {
[13:21:39.975]                         if (!is.null(pattern)) {
[13:21:39.975]                           computeRestarts <- base::computeRestarts
[13:21:39.975]                           grepl <- base::grepl
[13:21:39.975]                           restarts <- computeRestarts(cond)
[13:21:39.975]                           for (restart in restarts) {
[13:21:39.975]                             name <- restart$name
[13:21:39.975]                             if (is.null(name)) 
[13:21:39.975]                               next
[13:21:39.975]                             if (!grepl(pattern, name)) 
[13:21:39.975]                               next
[13:21:39.975]                             invokeRestart(restart)
[13:21:39.975]                             muffled <- TRUE
[13:21:39.975]                             break
[13:21:39.975]                           }
[13:21:39.975]                         }
[13:21:39.975]                       }
[13:21:39.975]                       invisible(muffled)
[13:21:39.975]                     }
[13:21:39.975]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.975]                   }
[13:21:39.975]                 }
[13:21:39.975]             }
[13:21:39.975]         }))
[13:21:39.975]     }, error = function(ex) {
[13:21:39.975]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:39.975]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.975]                 ...future.rng), started = ...future.startTime, 
[13:21:39.975]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:39.975]             version = "1.8"), class = "FutureResult")
[13:21:39.975]     }, finally = {
[13:21:39.975]         if (!identical(...future.workdir, getwd())) 
[13:21:39.975]             setwd(...future.workdir)
[13:21:39.975]         {
[13:21:39.975]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:39.975]                 ...future.oldOptions$nwarnings <- NULL
[13:21:39.975]             }
[13:21:39.975]             base::options(...future.oldOptions)
[13:21:39.975]             if (.Platform$OS.type == "windows") {
[13:21:39.975]                 old_names <- names(...future.oldEnvVars)
[13:21:39.975]                 envs <- base::Sys.getenv()
[13:21:39.975]                 names <- names(envs)
[13:21:39.975]                 common <- intersect(names, old_names)
[13:21:39.975]                 added <- setdiff(names, old_names)
[13:21:39.975]                 removed <- setdiff(old_names, names)
[13:21:39.975]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:39.975]                   envs[common]]
[13:21:39.975]                 NAMES <- toupper(changed)
[13:21:39.975]                 args <- list()
[13:21:39.975]                 for (kk in seq_along(NAMES)) {
[13:21:39.975]                   name <- changed[[kk]]
[13:21:39.975]                   NAME <- NAMES[[kk]]
[13:21:39.975]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.975]                     next
[13:21:39.975]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.975]                 }
[13:21:39.975]                 NAMES <- toupper(added)
[13:21:39.975]                 for (kk in seq_along(NAMES)) {
[13:21:39.975]                   name <- added[[kk]]
[13:21:39.975]                   NAME <- NAMES[[kk]]
[13:21:39.975]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.975]                     next
[13:21:39.975]                   args[[name]] <- ""
[13:21:39.975]                 }
[13:21:39.975]                 NAMES <- toupper(removed)
[13:21:39.975]                 for (kk in seq_along(NAMES)) {
[13:21:39.975]                   name <- removed[[kk]]
[13:21:39.975]                   NAME <- NAMES[[kk]]
[13:21:39.975]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.975]                     next
[13:21:39.975]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.975]                 }
[13:21:39.975]                 if (length(args) > 0) 
[13:21:39.975]                   base::do.call(base::Sys.setenv, args = args)
[13:21:39.975]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:39.975]             }
[13:21:39.975]             else {
[13:21:39.975]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:39.975]             }
[13:21:39.975]             {
[13:21:39.975]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:39.975]                   0L) {
[13:21:39.975]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:39.975]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:39.975]                   base::options(opts)
[13:21:39.975]                 }
[13:21:39.975]                 {
[13:21:39.975]                   {
[13:21:39.975]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:39.975]                     NULL
[13:21:39.975]                   }
[13:21:39.975]                   options(future.plan = NULL)
[13:21:39.975]                   if (is.na(NA_character_)) 
[13:21:39.975]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.975]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:39.975]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:39.975]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:39.975]                     envir = parent.frame()) 
[13:21:39.975]                   {
[13:21:39.975]                     if (is.function(workers)) 
[13:21:39.975]                       workers <- workers()
[13:21:39.975]                     workers <- structure(as.integer(workers), 
[13:21:39.975]                       class = class(workers))
[13:21:39.975]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:39.975]                       workers >= 1)
[13:21:39.975]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:39.975]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:39.975]                     }
[13:21:39.975]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:39.975]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:39.975]                       envir = envir)
[13:21:39.975]                     if (!future$lazy) 
[13:21:39.975]                       future <- run(future)
[13:21:39.975]                     invisible(future)
[13:21:39.975]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:39.975]                 }
[13:21:39.975]             }
[13:21:39.975]         }
[13:21:39.975]     })
[13:21:39.975]     if (TRUE) {
[13:21:39.975]         base::sink(type = "output", split = FALSE)
[13:21:39.975]         if (TRUE) {
[13:21:39.975]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:39.975]         }
[13:21:39.975]         else {
[13:21:39.975]             ...future.result["stdout"] <- base::list(NULL)
[13:21:39.975]         }
[13:21:39.975]         base::close(...future.stdout)
[13:21:39.975]         ...future.stdout <- NULL
[13:21:39.975]     }
[13:21:39.975]     ...future.result$conditions <- ...future.conditions
[13:21:39.975]     ...future.result$finished <- base::Sys.time()
[13:21:39.975]     ...future.result
[13:21:39.975] }
[13:21:39.978] Exporting 11 global objects (93.29 KiB) to cluster node #2 ...
[13:21:39.978] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[13:21:40.020] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[13:21:40.021] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #2 ...
[13:21:40.021] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #2 ... DONE
[13:21:40.021] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[13:21:40.022] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[13:21:40.022] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[13:21:40.064] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[13:21:40.065] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[13:21:40.108] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[13:21:40.108] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[13:21:40.109] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[13:21:40.109] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[13:21:40.109] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[13:21:40.110] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:21:40.110] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:21:40.110] Exporting ‘...future.elements_ii’ (176 bytes) to cluster node #2 ...
[13:21:40.111] Exporting ‘...future.elements_ii’ (176 bytes) to cluster node #2 ... DONE
[13:21:40.111] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:21:40.111] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:21:40.111] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:21:40.112] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:21:40.112] Exporting 11 global objects (93.29 KiB) to cluster node #2 ... DONE
[13:21:40.113] MultisessionFuture started
[13:21:40.113] - Launch lazy future ... done
[13:21:40.113] run() for ‘MultisessionFuture’ ... done
[13:21:40.113] Created future:
[13:21:40.113] MultisessionFuture:
[13:21:40.113] Label: ‘future_vapply-2’
[13:21:40.113] Expression:
[13:21:40.113] {
[13:21:40.113]     do.call(function(...) {
[13:21:40.113]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:40.113]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:40.113]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:40.113]             on.exit(options(oopts), add = TRUE)
[13:21:40.113]         }
[13:21:40.113]         {
[13:21:40.113]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:40.113]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:40.113]                 ...future.FUN(...future.X_jj, ...)
[13:21:40.113]             })
[13:21:40.113]         }
[13:21:40.113]     }, args = future.call.arguments)
[13:21:40.113] }
[13:21:40.113] Lazy evaluation: FALSE
[13:21:40.113] Asynchronous evaluation: TRUE
[13:21:40.113] Local evaluation: TRUE
[13:21:40.113] Environment: R_GlobalEnv
[13:21:40.113] Capture standard output: TRUE
[13:21:40.113] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:40.113] Globals: 11 objects totaling 93.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:40.113] Packages: 2 packages (‘stats’, ‘future.apply’)
[13:21:40.113] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:40.113] Resolved: FALSE
[13:21:40.113] Value: <not collected>
[13:21:40.113] Conditions captured: <none>
[13:21:40.113] Early signaling: FALSE
[13:21:40.113] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:40.113] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:40.125] Chunk #2 of 2 ... DONE
[13:21:40.125] Launching 2 futures (chunks) ... DONE
[13:21:40.125] Resolving 2 futures (chunks) ...
[13:21:40.125] resolve() on list ...
[13:21:40.125]  recursive: 0
[13:21:40.126]  length: 2
[13:21:40.126] 
[13:21:40.126] receiveMessageFromWorker() for ClusterFuture ...
[13:21:40.126] - Validating connection of MultisessionFuture
[13:21:40.126] - received message: FutureResult
[13:21:40.127] - Received FutureResult
[13:21:40.127] - Erased future from FutureRegistry
[13:21:40.127] result() for ClusterFuture ...
[13:21:40.127] - result already collected: FutureResult
[13:21:40.127] result() for ClusterFuture ... done
[13:21:40.127] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:40.127] Future #1
[13:21:40.127] result() for ClusterFuture ...
[13:21:40.127] - result already collected: FutureResult
[13:21:40.127] result() for ClusterFuture ... done
[13:21:40.127] result() for ClusterFuture ...
[13:21:40.128] - result already collected: FutureResult
[13:21:40.128] result() for ClusterFuture ... done
[13:21:40.128] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:21:40.128] - nx: 2
[13:21:40.128] - relay: TRUE
[13:21:40.128] - stdout: TRUE
[13:21:40.128] - signal: TRUE
[13:21:40.128] - resignal: FALSE
[13:21:40.128] - force: TRUE
[13:21:40.128] - relayed: [n=2] FALSE, FALSE
[13:21:40.128] - queued futures: [n=2] FALSE, FALSE
[13:21:40.129]  - until=1
[13:21:40.129]  - relaying element #1
[13:21:40.129] result() for ClusterFuture ...
[13:21:40.129] - result already collected: FutureResult
[13:21:40.129] result() for ClusterFuture ... done
[13:21:40.129] result() for ClusterFuture ...
[13:21:40.129] - result already collected: FutureResult
[13:21:40.129] result() for ClusterFuture ... done
[13:21:40.129] result() for ClusterFuture ...
[13:21:40.129] - result already collected: FutureResult
[13:21:40.129] result() for ClusterFuture ... done
[13:21:40.130] result() for ClusterFuture ...
[13:21:40.130] - result already collected: FutureResult
[13:21:40.130] result() for ClusterFuture ... done
[13:21:40.130] - relayed: [n=2] TRUE, FALSE
[13:21:40.130] - queued futures: [n=2] TRUE, FALSE
[13:21:40.130] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:21:40.130]  length: 1 (resolved future 1)
[13:21:40.172] receiveMessageFromWorker() for ClusterFuture ...
[13:21:40.172] - Validating connection of MultisessionFuture
[13:21:40.172] - received message: FutureResult
[13:21:40.173] - Received FutureResult
[13:21:40.173] - Erased future from FutureRegistry
[13:21:40.173] result() for ClusterFuture ...
[13:21:40.173] - result already collected: FutureResult
[13:21:40.173] result() for ClusterFuture ... done
[13:21:40.173] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:40.173] Future #2
[13:21:40.173] result() for ClusterFuture ...
[13:21:40.173] - result already collected: FutureResult
[13:21:40.173] result() for ClusterFuture ... done
[13:21:40.174] result() for ClusterFuture ...
[13:21:40.174] - result already collected: FutureResult
[13:21:40.174] result() for ClusterFuture ... done
[13:21:40.174] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:21:40.174] - nx: 2
[13:21:40.174] - relay: TRUE
[13:21:40.174] - stdout: TRUE
[13:21:40.174] - signal: TRUE
[13:21:40.174] - resignal: FALSE
[13:21:40.174] - force: TRUE
[13:21:40.174] - relayed: [n=2] TRUE, FALSE
[13:21:40.175] - queued futures: [n=2] TRUE, FALSE
[13:21:40.175]  - until=2
[13:21:40.175]  - relaying element #2
[13:21:40.175] result() for ClusterFuture ...
[13:21:40.175] - result already collected: FutureResult
[13:21:40.175] result() for ClusterFuture ... done
[13:21:40.175] result() for ClusterFuture ...
[13:21:40.175] - result already collected: FutureResult
[13:21:40.175] result() for ClusterFuture ... done
[13:21:40.175] result() for ClusterFuture ...
[13:21:40.176] - result already collected: FutureResult
[13:21:40.176] result() for ClusterFuture ... done
[13:21:40.176] result() for ClusterFuture ...
[13:21:40.176] - result already collected: FutureResult
[13:21:40.176] result() for ClusterFuture ... done
[13:21:40.176] - relayed: [n=2] TRUE, TRUE
[13:21:40.176] - queued futures: [n=2] TRUE, TRUE
[13:21:40.176] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:21:40.176]  length: 0 (resolved future 2)
[13:21:40.176] Relaying remaining futures
[13:21:40.177] signalConditionsASAP(NULL, pos=0) ...
[13:21:40.177] - nx: 2
[13:21:40.177] - relay: TRUE
[13:21:40.177] - stdout: TRUE
[13:21:40.177] - signal: TRUE
[13:21:40.177] - resignal: FALSE
[13:21:40.177] - force: TRUE
[13:21:40.177] - relayed: [n=2] TRUE, TRUE
[13:21:40.177] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:21:40.177] - relayed: [n=2] TRUE, TRUE
[13:21:40.177] - queued futures: [n=2] TRUE, TRUE
[13:21:40.178] signalConditionsASAP(NULL, pos=0) ... done
[13:21:40.178] resolve() on list ... DONE
[13:21:40.178] result() for ClusterFuture ...
[13:21:40.178] - result already collected: FutureResult
[13:21:40.178] result() for ClusterFuture ... done
[13:21:40.178] result() for ClusterFuture ...
[13:21:40.178] - result already collected: FutureResult
[13:21:40.178] result() for ClusterFuture ... done
[13:21:40.178] result() for ClusterFuture ...
[13:21:40.178] - result already collected: FutureResult
[13:21:40.178] result() for ClusterFuture ... done
[13:21:40.178] result() for ClusterFuture ...
[13:21:40.179] - result already collected: FutureResult
[13:21:40.179] result() for ClusterFuture ... done
[13:21:40.179]  - Number of value chunks collected: 2
[13:21:40.179] Resolving 2 futures (chunks) ... DONE
[13:21:40.179] Reducing values from 2 chunks ...
[13:21:40.179]  - Number of values collected after concatenation: 3
[13:21:40.179]  - Number of values expected: 3
[13:21:40.179] Reducing values from 2 chunks ... DONE
[13:21:40.179] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[13:21:40.181] future_lapply() ...
[13:21:40.189] Number of chunks: 2
[13:21:40.189] getGlobalsAndPackagesXApply() ...
[13:21:40.189]  - future.globals: TRUE
[13:21:40.189] getGlobalsAndPackages() ...
[13:21:40.190] Searching for globals...
[13:21:40.194] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[13:21:40.195] Searching for globals ... DONE
[13:21:40.195] Resolving globals: FALSE
[13:21:40.196] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[13:21:40.196] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[13:21:40.196] - globals: [1] ‘FUN’
[13:21:40.196] - packages: [1] ‘stats’
[13:21:40.196] getGlobalsAndPackages() ... DONE
[13:21:40.196]  - globals found/used: [n=1] ‘FUN’
[13:21:40.197]  - needed namespaces: [n=1] ‘stats’
[13:21:40.197] Finding globals ... DONE
[13:21:40.197]  - use_args: TRUE
[13:21:40.197]  - Getting '...' globals ...
[13:21:40.197] resolve() on list ...
[13:21:40.197]  recursive: 0
[13:21:40.197]  length: 1
[13:21:40.197]  elements: ‘...’
[13:21:40.198]  length: 0 (resolved future 1)
[13:21:40.198] resolve() on list ... DONE
[13:21:40.198]    - '...' content: [n=0] 
[13:21:40.198] List of 1
[13:21:40.198]  $ ...: list()
[13:21:40.198]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:40.198]  - attr(*, "where")=List of 1
[13:21:40.198]   ..$ ...:<environment: 0x563b7038f8c0> 
[13:21:40.198]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:40.198]  - attr(*, "resolved")= logi TRUE
[13:21:40.198]  - attr(*, "total_size")= num NA
[13:21:40.201]  - Getting '...' globals ... DONE
[13:21:40.201] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:21:40.201] List of 2
[13:21:40.201]  $ ...future.FUN:function (x, na.rm = TRUE)  
[13:21:40.201]  $ ...          : list()
[13:21:40.201]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:40.201]  - attr(*, "where")=List of 2
[13:21:40.201]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:40.201]   ..$ ...          :<environment: 0x563b7038f8c0> 
[13:21:40.201]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:40.201]  - attr(*, "resolved")= logi FALSE
[13:21:40.201]  - attr(*, "total_size")= num 46960
[13:21:40.204] Packages to be attached in all futures: [n=1] ‘stats’
[13:21:40.204] getGlobalsAndPackagesXApply() ... DONE
[13:21:40.204] Number of futures (= number of chunks): 2
[13:21:40.204] Launching 2 futures (chunks) ...
[13:21:40.204] Chunk #1 of 2 ...
[13:21:40.204]  - Finding globals in 'X' for chunk #1 ...
[13:21:40.204] getGlobalsAndPackages() ...
[13:21:40.204] Searching for globals...
[13:21:40.205] 
[13:21:40.205] Searching for globals ... DONE
[13:21:40.205] - globals: [0] <none>
[13:21:40.205] getGlobalsAndPackages() ... DONE
[13:21:40.205]    + additional globals found: [n=0] 
[13:21:40.205]    + additional namespaces needed: [n=0] 
[13:21:40.205]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:40.205]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:40.205]  - seeds: <none>
[13:21:40.205]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:40.206] getGlobalsAndPackages() ...
[13:21:40.206] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:40.206] Resolving globals: FALSE
[13:21:40.206] Tweak future expression to call with '...' arguments ...
[13:21:40.206] {
[13:21:40.206]     do.call(function(...) {
[13:21:40.206]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:40.206]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:40.206]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:40.206]             on.exit(options(oopts), add = TRUE)
[13:21:40.206]         }
[13:21:40.206]         {
[13:21:40.206]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:40.206]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:40.206]                 ...future.FUN(...future.X_jj, ...)
[13:21:40.206]             })
[13:21:40.206]         }
[13:21:40.206]     }, args = future.call.arguments)
[13:21:40.206] }
[13:21:40.206] Tweak future expression to call with '...' arguments ... DONE
[13:21:40.207] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:40.207] - packages: [1] ‘stats’
[13:21:40.207] getGlobalsAndPackages() ... DONE
[13:21:40.207] run() for ‘Future’ ...
[13:21:40.207] - state: ‘created’
[13:21:40.207] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:40.221] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:40.222] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:40.222]   - Field: ‘node’
[13:21:40.222]   - Field: ‘label’
[13:21:40.222]   - Field: ‘local’
[13:21:40.222]   - Field: ‘owner’
[13:21:40.222]   - Field: ‘envir’
[13:21:40.222]   - Field: ‘workers’
[13:21:40.222]   - Field: ‘packages’
[13:21:40.222]   - Field: ‘gc’
[13:21:40.223]   - Field: ‘conditions’
[13:21:40.223]   - Field: ‘persistent’
[13:21:40.223]   - Field: ‘expr’
[13:21:40.223]   - Field: ‘uuid’
[13:21:40.223]   - Field: ‘seed’
[13:21:40.223]   - Field: ‘version’
[13:21:40.223]   - Field: ‘result’
[13:21:40.223]   - Field: ‘asynchronous’
[13:21:40.223]   - Field: ‘calls’
[13:21:40.223]   - Field: ‘globals’
[13:21:40.224]   - Field: ‘stdout’
[13:21:40.224]   - Field: ‘earlySignal’
[13:21:40.224]   - Field: ‘lazy’
[13:21:40.224]   - Field: ‘state’
[13:21:40.224] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:40.224] - Launch lazy future ...
[13:21:40.224] Packages needed by the future expression (n = 1): ‘stats’
[13:21:40.224] Packages needed by future strategies (n = 0): <none>
[13:21:40.225] {
[13:21:40.225]     {
[13:21:40.225]         {
[13:21:40.225]             ...future.startTime <- base::Sys.time()
[13:21:40.225]             {
[13:21:40.225]                 {
[13:21:40.225]                   {
[13:21:40.225]                     {
[13:21:40.225]                       {
[13:21:40.225]                         base::local({
[13:21:40.225]                           has_future <- base::requireNamespace("future", 
[13:21:40.225]                             quietly = TRUE)
[13:21:40.225]                           if (has_future) {
[13:21:40.225]                             ns <- base::getNamespace("future")
[13:21:40.225]                             version <- ns[[".package"]][["version"]]
[13:21:40.225]                             if (is.null(version)) 
[13:21:40.225]                               version <- utils::packageVersion("future")
[13:21:40.225]                           }
[13:21:40.225]                           else {
[13:21:40.225]                             version <- NULL
[13:21:40.225]                           }
[13:21:40.225]                           if (!has_future || version < "1.8.0") {
[13:21:40.225]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:40.225]                               "", base::R.version$version.string), 
[13:21:40.225]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:40.225]                                 base::R.version$platform, 8 * 
[13:21:40.225]                                   base::.Machine$sizeof.pointer), 
[13:21:40.225]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:40.225]                                 "release", "version")], collapse = " "), 
[13:21:40.225]                               hostname = base::Sys.info()[["nodename"]])
[13:21:40.225]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:40.225]                               info)
[13:21:40.225]                             info <- base::paste(info, collapse = "; ")
[13:21:40.225]                             if (!has_future) {
[13:21:40.225]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:40.225]                                 info)
[13:21:40.225]                             }
[13:21:40.225]                             else {
[13:21:40.225]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:40.225]                                 info, version)
[13:21:40.225]                             }
[13:21:40.225]                             base::stop(msg)
[13:21:40.225]                           }
[13:21:40.225]                         })
[13:21:40.225]                       }
[13:21:40.225]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:40.225]                       base::options(mc.cores = 1L)
[13:21:40.225]                     }
[13:21:40.225]                     base::local({
[13:21:40.225]                       for (pkg in "stats") {
[13:21:40.225]                         base::loadNamespace(pkg)
[13:21:40.225]                         base::library(pkg, character.only = TRUE)
[13:21:40.225]                       }
[13:21:40.225]                     })
[13:21:40.225]                   }
[13:21:40.225]                   options(future.plan = NULL)
[13:21:40.225]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:40.225]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:40.225]                 }
[13:21:40.225]                 ...future.workdir <- getwd()
[13:21:40.225]             }
[13:21:40.225]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:40.225]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:40.225]         }
[13:21:40.225]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:40.225]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:40.225]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:40.225]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:40.225]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:40.225]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:40.225]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:40.225]             base::names(...future.oldOptions))
[13:21:40.225]     }
[13:21:40.225]     if (FALSE) {
[13:21:40.225]     }
[13:21:40.225]     else {
[13:21:40.225]         if (TRUE) {
[13:21:40.225]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:40.225]                 open = "w")
[13:21:40.225]         }
[13:21:40.225]         else {
[13:21:40.225]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:40.225]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:40.225]         }
[13:21:40.225]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:40.225]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:40.225]             base::sink(type = "output", split = FALSE)
[13:21:40.225]             base::close(...future.stdout)
[13:21:40.225]         }, add = TRUE)
[13:21:40.225]     }
[13:21:40.225]     ...future.frame <- base::sys.nframe()
[13:21:40.225]     ...future.conditions <- base::list()
[13:21:40.225]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:40.225]     if (FALSE) {
[13:21:40.225]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:40.225]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:40.225]     }
[13:21:40.225]     ...future.result <- base::tryCatch({
[13:21:40.225]         base::withCallingHandlers({
[13:21:40.225]             ...future.value <- base::withVisible(base::local({
[13:21:40.225]                 ...future.makeSendCondition <- base::local({
[13:21:40.225]                   sendCondition <- NULL
[13:21:40.225]                   function(frame = 1L) {
[13:21:40.225]                     if (is.function(sendCondition)) 
[13:21:40.225]                       return(sendCondition)
[13:21:40.225]                     ns <- getNamespace("parallel")
[13:21:40.225]                     if (exists("sendData", mode = "function", 
[13:21:40.225]                       envir = ns)) {
[13:21:40.225]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:40.225]                         envir = ns)
[13:21:40.225]                       envir <- sys.frame(frame)
[13:21:40.225]                       master <- NULL
[13:21:40.225]                       while (!identical(envir, .GlobalEnv) && 
[13:21:40.225]                         !identical(envir, emptyenv())) {
[13:21:40.225]                         if (exists("master", mode = "list", envir = envir, 
[13:21:40.225]                           inherits = FALSE)) {
[13:21:40.225]                           master <- get("master", mode = "list", 
[13:21:40.225]                             envir = envir, inherits = FALSE)
[13:21:40.225]                           if (inherits(master, c("SOCKnode", 
[13:21:40.225]                             "SOCK0node"))) {
[13:21:40.225]                             sendCondition <<- function(cond) {
[13:21:40.225]                               data <- list(type = "VALUE", value = cond, 
[13:21:40.225]                                 success = TRUE)
[13:21:40.225]                               parallel_sendData(master, data)
[13:21:40.225]                             }
[13:21:40.225]                             return(sendCondition)
[13:21:40.225]                           }
[13:21:40.225]                         }
[13:21:40.225]                         frame <- frame + 1L
[13:21:40.225]                         envir <- sys.frame(frame)
[13:21:40.225]                       }
[13:21:40.225]                     }
[13:21:40.225]                     sendCondition <<- function(cond) NULL
[13:21:40.225]                   }
[13:21:40.225]                 })
[13:21:40.225]                 withCallingHandlers({
[13:21:40.225]                   {
[13:21:40.225]                     do.call(function(...) {
[13:21:40.225]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:40.225]                       if (!identical(...future.globals.maxSize.org, 
[13:21:40.225]                         ...future.globals.maxSize)) {
[13:21:40.225]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:40.225]                         on.exit(options(oopts), add = TRUE)
[13:21:40.225]                       }
[13:21:40.225]                       {
[13:21:40.225]                         lapply(seq_along(...future.elements_ii), 
[13:21:40.225]                           FUN = function(jj) {
[13:21:40.225]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:40.225]                             ...future.FUN(...future.X_jj, ...)
[13:21:40.225]                           })
[13:21:40.225]                       }
[13:21:40.225]                     }, args = future.call.arguments)
[13:21:40.225]                   }
[13:21:40.225]                 }, immediateCondition = function(cond) {
[13:21:40.225]                   sendCondition <- ...future.makeSendCondition()
[13:21:40.225]                   sendCondition(cond)
[13:21:40.225]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.225]                   {
[13:21:40.225]                     inherits <- base::inherits
[13:21:40.225]                     invokeRestart <- base::invokeRestart
[13:21:40.225]                     is.null <- base::is.null
[13:21:40.225]                     muffled <- FALSE
[13:21:40.225]                     if (inherits(cond, "message")) {
[13:21:40.225]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:40.225]                       if (muffled) 
[13:21:40.225]                         invokeRestart("muffleMessage")
[13:21:40.225]                     }
[13:21:40.225]                     else if (inherits(cond, "warning")) {
[13:21:40.225]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:40.225]                       if (muffled) 
[13:21:40.225]                         invokeRestart("muffleWarning")
[13:21:40.225]                     }
[13:21:40.225]                     else if (inherits(cond, "condition")) {
[13:21:40.225]                       if (!is.null(pattern)) {
[13:21:40.225]                         computeRestarts <- base::computeRestarts
[13:21:40.225]                         grepl <- base::grepl
[13:21:40.225]                         restarts <- computeRestarts(cond)
[13:21:40.225]                         for (restart in restarts) {
[13:21:40.225]                           name <- restart$name
[13:21:40.225]                           if (is.null(name)) 
[13:21:40.225]                             next
[13:21:40.225]                           if (!grepl(pattern, name)) 
[13:21:40.225]                             next
[13:21:40.225]                           invokeRestart(restart)
[13:21:40.225]                           muffled <- TRUE
[13:21:40.225]                           break
[13:21:40.225]                         }
[13:21:40.225]                       }
[13:21:40.225]                     }
[13:21:40.225]                     invisible(muffled)
[13:21:40.225]                   }
[13:21:40.225]                   muffleCondition(cond)
[13:21:40.225]                 })
[13:21:40.225]             }))
[13:21:40.225]             future::FutureResult(value = ...future.value$value, 
[13:21:40.225]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:40.225]                   ...future.rng), globalenv = if (FALSE) 
[13:21:40.225]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:40.225]                     ...future.globalenv.names))
[13:21:40.225]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:40.225]         }, condition = base::local({
[13:21:40.225]             c <- base::c
[13:21:40.225]             inherits <- base::inherits
[13:21:40.225]             invokeRestart <- base::invokeRestart
[13:21:40.225]             length <- base::length
[13:21:40.225]             list <- base::list
[13:21:40.225]             seq.int <- base::seq.int
[13:21:40.225]             signalCondition <- base::signalCondition
[13:21:40.225]             sys.calls <- base::sys.calls
[13:21:40.225]             `[[` <- base::`[[`
[13:21:40.225]             `+` <- base::`+`
[13:21:40.225]             `<<-` <- base::`<<-`
[13:21:40.225]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:40.225]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:40.225]                   3L)]
[13:21:40.225]             }
[13:21:40.225]             function(cond) {
[13:21:40.225]                 is_error <- inherits(cond, "error")
[13:21:40.225]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:40.225]                   NULL)
[13:21:40.225]                 if (is_error) {
[13:21:40.225]                   sessionInformation <- function() {
[13:21:40.225]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:40.225]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:40.225]                       search = base::search(), system = base::Sys.info())
[13:21:40.225]                   }
[13:21:40.225]                   ...future.conditions[[length(...future.conditions) + 
[13:21:40.225]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:40.225]                     cond$call), session = sessionInformation(), 
[13:21:40.225]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:40.225]                   signalCondition(cond)
[13:21:40.225]                 }
[13:21:40.225]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:40.225]                 "immediateCondition"))) {
[13:21:40.225]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:40.225]                   ...future.conditions[[length(...future.conditions) + 
[13:21:40.225]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:40.225]                   if (TRUE && !signal) {
[13:21:40.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.225]                     {
[13:21:40.225]                       inherits <- base::inherits
[13:21:40.225]                       invokeRestart <- base::invokeRestart
[13:21:40.225]                       is.null <- base::is.null
[13:21:40.225]                       muffled <- FALSE
[13:21:40.225]                       if (inherits(cond, "message")) {
[13:21:40.225]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:40.225]                         if (muffled) 
[13:21:40.225]                           invokeRestart("muffleMessage")
[13:21:40.225]                       }
[13:21:40.225]                       else if (inherits(cond, "warning")) {
[13:21:40.225]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:40.225]                         if (muffled) 
[13:21:40.225]                           invokeRestart("muffleWarning")
[13:21:40.225]                       }
[13:21:40.225]                       else if (inherits(cond, "condition")) {
[13:21:40.225]                         if (!is.null(pattern)) {
[13:21:40.225]                           computeRestarts <- base::computeRestarts
[13:21:40.225]                           grepl <- base::grepl
[13:21:40.225]                           restarts <- computeRestarts(cond)
[13:21:40.225]                           for (restart in restarts) {
[13:21:40.225]                             name <- restart$name
[13:21:40.225]                             if (is.null(name)) 
[13:21:40.225]                               next
[13:21:40.225]                             if (!grepl(pattern, name)) 
[13:21:40.225]                               next
[13:21:40.225]                             invokeRestart(restart)
[13:21:40.225]                             muffled <- TRUE
[13:21:40.225]                             break
[13:21:40.225]                           }
[13:21:40.225]                         }
[13:21:40.225]                       }
[13:21:40.225]                       invisible(muffled)
[13:21:40.225]                     }
[13:21:40.225]                     muffleCondition(cond, pattern = "^muffle")
[13:21:40.225]                   }
[13:21:40.225]                 }
[13:21:40.225]                 else {
[13:21:40.225]                   if (TRUE) {
[13:21:40.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.225]                     {
[13:21:40.225]                       inherits <- base::inherits
[13:21:40.225]                       invokeRestart <- base::invokeRestart
[13:21:40.225]                       is.null <- base::is.null
[13:21:40.225]                       muffled <- FALSE
[13:21:40.225]                       if (inherits(cond, "message")) {
[13:21:40.225]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:40.225]                         if (muffled) 
[13:21:40.225]                           invokeRestart("muffleMessage")
[13:21:40.225]                       }
[13:21:40.225]                       else if (inherits(cond, "warning")) {
[13:21:40.225]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:40.225]                         if (muffled) 
[13:21:40.225]                           invokeRestart("muffleWarning")
[13:21:40.225]                       }
[13:21:40.225]                       else if (inherits(cond, "condition")) {
[13:21:40.225]                         if (!is.null(pattern)) {
[13:21:40.225]                           computeRestarts <- base::computeRestarts
[13:21:40.225]                           grepl <- base::grepl
[13:21:40.225]                           restarts <- computeRestarts(cond)
[13:21:40.225]                           for (restart in restarts) {
[13:21:40.225]                             name <- restart$name
[13:21:40.225]                             if (is.null(name)) 
[13:21:40.225]                               next
[13:21:40.225]                             if (!grepl(pattern, name)) 
[13:21:40.225]                               next
[13:21:40.225]                             invokeRestart(restart)
[13:21:40.225]                             muffled <- TRUE
[13:21:40.225]                             break
[13:21:40.225]                           }
[13:21:40.225]                         }
[13:21:40.225]                       }
[13:21:40.225]                       invisible(muffled)
[13:21:40.225]                     }
[13:21:40.225]                     muffleCondition(cond, pattern = "^muffle")
[13:21:40.225]                   }
[13:21:40.225]                 }
[13:21:40.225]             }
[13:21:40.225]         }))
[13:21:40.225]     }, error = function(ex) {
[13:21:40.225]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:40.225]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:40.225]                 ...future.rng), started = ...future.startTime, 
[13:21:40.225]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:40.225]             version = "1.8"), class = "FutureResult")
[13:21:40.225]     }, finally = {
[13:21:40.225]         if (!identical(...future.workdir, getwd())) 
[13:21:40.225]             setwd(...future.workdir)
[13:21:40.225]         {
[13:21:40.225]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:40.225]                 ...future.oldOptions$nwarnings <- NULL
[13:21:40.225]             }
[13:21:40.225]             base::options(...future.oldOptions)
[13:21:40.225]             if (.Platform$OS.type == "windows") {
[13:21:40.225]                 old_names <- names(...future.oldEnvVars)
[13:21:40.225]                 envs <- base::Sys.getenv()
[13:21:40.225]                 names <- names(envs)
[13:21:40.225]                 common <- intersect(names, old_names)
[13:21:40.225]                 added <- setdiff(names, old_names)
[13:21:40.225]                 removed <- setdiff(old_names, names)
[13:21:40.225]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:40.225]                   envs[common]]
[13:21:40.225]                 NAMES <- toupper(changed)
[13:21:40.225]                 args <- list()
[13:21:40.225]                 for (kk in seq_along(NAMES)) {
[13:21:40.225]                   name <- changed[[kk]]
[13:21:40.225]                   NAME <- NAMES[[kk]]
[13:21:40.225]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.225]                     next
[13:21:40.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:40.225]                 }
[13:21:40.225]                 NAMES <- toupper(added)
[13:21:40.225]                 for (kk in seq_along(NAMES)) {
[13:21:40.225]                   name <- added[[kk]]
[13:21:40.225]                   NAME <- NAMES[[kk]]
[13:21:40.225]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.225]                     next
[13:21:40.225]                   args[[name]] <- ""
[13:21:40.225]                 }
[13:21:40.225]                 NAMES <- toupper(removed)
[13:21:40.225]                 for (kk in seq_along(NAMES)) {
[13:21:40.225]                   name <- removed[[kk]]
[13:21:40.225]                   NAME <- NAMES[[kk]]
[13:21:40.225]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.225]                     next
[13:21:40.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:40.225]                 }
[13:21:40.225]                 if (length(args) > 0) 
[13:21:40.225]                   base::do.call(base::Sys.setenv, args = args)
[13:21:40.225]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:40.225]             }
[13:21:40.225]             else {
[13:21:40.225]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:40.225]             }
[13:21:40.225]             {
[13:21:40.225]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:40.225]                   0L) {
[13:21:40.225]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:40.225]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:40.225]                   base::options(opts)
[13:21:40.225]                 }
[13:21:40.225]                 {
[13:21:40.225]                   {
[13:21:40.225]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:40.225]                     NULL
[13:21:40.225]                   }
[13:21:40.225]                   options(future.plan = NULL)
[13:21:40.225]                   if (is.na(NA_character_)) 
[13:21:40.225]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:40.225]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:40.225]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:40.225]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:40.225]                     envir = parent.frame()) 
[13:21:40.225]                   {
[13:21:40.225]                     if (is.function(workers)) 
[13:21:40.225]                       workers <- workers()
[13:21:40.225]                     workers <- structure(as.integer(workers), 
[13:21:40.225]                       class = class(workers))
[13:21:40.225]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:40.225]                       workers >= 1)
[13:21:40.225]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:40.225]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:40.225]                     }
[13:21:40.225]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:40.225]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:40.225]                       envir = envir)
[13:21:40.225]                     if (!future$lazy) 
[13:21:40.225]                       future <- run(future)
[13:21:40.225]                     invisible(future)
[13:21:40.225]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:40.225]                 }
[13:21:40.225]             }
[13:21:40.225]         }
[13:21:40.225]     })
[13:21:40.225]     if (TRUE) {
[13:21:40.225]         base::sink(type = "output", split = FALSE)
[13:21:40.225]         if (TRUE) {
[13:21:40.225]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:40.225]         }
[13:21:40.225]         else {
[13:21:40.225]             ...future.result["stdout"] <- base::list(NULL)
[13:21:40.225]         }
[13:21:40.225]         base::close(...future.stdout)
[13:21:40.225]         ...future.stdout <- NULL
[13:21:40.225]     }
[13:21:40.225]     ...future.result$conditions <- ...future.conditions
[13:21:40.225]     ...future.result$finished <- base::Sys.time()
[13:21:40.225]     ...future.result
[13:21:40.225] }
[13:21:40.228] Exporting 5 global objects (45.86 KiB) to cluster node #1 ...
[13:21:40.228] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #1 ...
[13:21:40.272] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #1 ... DONE
[13:21:40.273] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:21:40.273] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:21:40.273] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ...
[13:21:40.274] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ... DONE
[13:21:40.274] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:21:40.274] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:21:40.274] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:21:40.275] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:21:40.275] Exporting 5 global objects (45.86 KiB) to cluster node #1 ... DONE
[13:21:40.276] MultisessionFuture started
[13:21:40.276] - Launch lazy future ... done
[13:21:40.279] run() for ‘MultisessionFuture’ ... done
[13:21:40.279] Created future:
[13:21:40.279] MultisessionFuture:
[13:21:40.279] Label: ‘future_sapply-1’
[13:21:40.279] Expression:
[13:21:40.279] {
[13:21:40.279]     do.call(function(...) {
[13:21:40.279]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:40.279]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:40.279]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:40.279]             on.exit(options(oopts), add = TRUE)
[13:21:40.279]         }
[13:21:40.279]         {
[13:21:40.279]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:40.279]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:40.279]                 ...future.FUN(...future.X_jj, ...)
[13:21:40.279]             })
[13:21:40.279]         }
[13:21:40.279]     }, args = future.call.arguments)
[13:21:40.279] }
[13:21:40.279] Lazy evaluation: FALSE
[13:21:40.279] Asynchronous evaluation: TRUE
[13:21:40.279] Local evaluation: TRUE
[13:21:40.279] Environment: R_GlobalEnv
[13:21:40.279] Capture standard output: TRUE
[13:21:40.279] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:40.279] Globals: 5 objects totaling 46.14 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 288 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:21:40.279] Packages: 1 packages (‘stats’)
[13:21:40.279] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:40.279] Resolved: FALSE
[13:21:40.279] Value: <not collected>
[13:21:40.279] Conditions captured: <none>
[13:21:40.279] Early signaling: FALSE
[13:21:40.279] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:40.279] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:40.290] Chunk #1 of 2 ... DONE
[13:21:40.291] Chunk #2 of 2 ...
[13:21:40.291]  - Finding globals in 'X' for chunk #2 ...
[13:21:40.291] getGlobalsAndPackages() ...
[13:21:40.291] Searching for globals...
[13:21:40.291] 
[13:21:40.291] Searching for globals ... DONE
[13:21:40.291] - globals: [0] <none>
[13:21:40.292] getGlobalsAndPackages() ... DONE
[13:21:40.292]    + additional globals found: [n=0] 
[13:21:40.292]    + additional namespaces needed: [n=0] 
[13:21:40.292]  - Finding globals in 'X' for chunk #2 ... DONE
[13:21:40.292]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:40.292]  - seeds: <none>
[13:21:40.292]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:40.292] getGlobalsAndPackages() ...
[13:21:40.292] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:40.292] Resolving globals: FALSE
[13:21:40.293] Tweak future expression to call with '...' arguments ...
[13:21:40.293] {
[13:21:40.293]     do.call(function(...) {
[13:21:40.293]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:40.293]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:40.293]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:40.293]             on.exit(options(oopts), add = TRUE)
[13:21:40.293]         }
[13:21:40.293]         {
[13:21:40.293]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:40.293]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:40.293]                 ...future.FUN(...future.X_jj, ...)
[13:21:40.293]             })
[13:21:40.293]         }
[13:21:40.293]     }, args = future.call.arguments)
[13:21:40.293] }
[13:21:40.293] Tweak future expression to call with '...' arguments ... DONE
[13:21:40.293] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:40.294] - packages: [1] ‘stats’
[13:21:40.294] getGlobalsAndPackages() ... DONE
[13:21:40.294] run() for ‘Future’ ...
[13:21:40.294] - state: ‘created’
[13:21:40.294] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:40.309] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:40.309] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:40.309]   - Field: ‘node’
[13:21:40.309]   - Field: ‘label’
[13:21:40.309]   - Field: ‘local’
[13:21:40.309]   - Field: ‘owner’
[13:21:40.309]   - Field: ‘envir’
[13:21:40.309]   - Field: ‘workers’
[13:21:40.309]   - Field: ‘packages’
[13:21:40.310]   - Field: ‘gc’
[13:21:40.310]   - Field: ‘conditions’
[13:21:40.310]   - Field: ‘persistent’
[13:21:40.310]   - Field: ‘expr’
[13:21:40.310]   - Field: ‘uuid’
[13:21:40.310]   - Field: ‘seed’
[13:21:40.310]   - Field: ‘version’
[13:21:40.310]   - Field: ‘result’
[13:21:40.310]   - Field: ‘asynchronous’
[13:21:40.310]   - Field: ‘calls’
[13:21:40.310]   - Field: ‘globals’
[13:21:40.311]   - Field: ‘stdout’
[13:21:40.311]   - Field: ‘earlySignal’
[13:21:40.311]   - Field: ‘lazy’
[13:21:40.311]   - Field: ‘state’
[13:21:40.311] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:40.311] - Launch lazy future ...
[13:21:40.311] Packages needed by the future expression (n = 1): ‘stats’
[13:21:40.312] Packages needed by future strategies (n = 0): <none>
[13:21:40.312] {
[13:21:40.312]     {
[13:21:40.312]         {
[13:21:40.312]             ...future.startTime <- base::Sys.time()
[13:21:40.312]             {
[13:21:40.312]                 {
[13:21:40.312]                   {
[13:21:40.312]                     {
[13:21:40.312]                       {
[13:21:40.312]                         base::local({
[13:21:40.312]                           has_future <- base::requireNamespace("future", 
[13:21:40.312]                             quietly = TRUE)
[13:21:40.312]                           if (has_future) {
[13:21:40.312]                             ns <- base::getNamespace("future")
[13:21:40.312]                             version <- ns[[".package"]][["version"]]
[13:21:40.312]                             if (is.null(version)) 
[13:21:40.312]                               version <- utils::packageVersion("future")
[13:21:40.312]                           }
[13:21:40.312]                           else {
[13:21:40.312]                             version <- NULL
[13:21:40.312]                           }
[13:21:40.312]                           if (!has_future || version < "1.8.0") {
[13:21:40.312]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:40.312]                               "", base::R.version$version.string), 
[13:21:40.312]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:40.312]                                 base::R.version$platform, 8 * 
[13:21:40.312]                                   base::.Machine$sizeof.pointer), 
[13:21:40.312]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:40.312]                                 "release", "version")], collapse = " "), 
[13:21:40.312]                               hostname = base::Sys.info()[["nodename"]])
[13:21:40.312]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:40.312]                               info)
[13:21:40.312]                             info <- base::paste(info, collapse = "; ")
[13:21:40.312]                             if (!has_future) {
[13:21:40.312]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:40.312]                                 info)
[13:21:40.312]                             }
[13:21:40.312]                             else {
[13:21:40.312]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:40.312]                                 info, version)
[13:21:40.312]                             }
[13:21:40.312]                             base::stop(msg)
[13:21:40.312]                           }
[13:21:40.312]                         })
[13:21:40.312]                       }
[13:21:40.312]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:40.312]                       base::options(mc.cores = 1L)
[13:21:40.312]                     }
[13:21:40.312]                     base::local({
[13:21:40.312]                       for (pkg in "stats") {
[13:21:40.312]                         base::loadNamespace(pkg)
[13:21:40.312]                         base::library(pkg, character.only = TRUE)
[13:21:40.312]                       }
[13:21:40.312]                     })
[13:21:40.312]                   }
[13:21:40.312]                   options(future.plan = NULL)
[13:21:40.312]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:40.312]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:40.312]                 }
[13:21:40.312]                 ...future.workdir <- getwd()
[13:21:40.312]             }
[13:21:40.312]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:40.312]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:40.312]         }
[13:21:40.312]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:40.312]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:40.312]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:40.312]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:40.312]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:40.312]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:40.312]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:40.312]             base::names(...future.oldOptions))
[13:21:40.312]     }
[13:21:40.312]     if (FALSE) {
[13:21:40.312]     }
[13:21:40.312]     else {
[13:21:40.312]         if (TRUE) {
[13:21:40.312]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:40.312]                 open = "w")
[13:21:40.312]         }
[13:21:40.312]         else {
[13:21:40.312]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:40.312]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:40.312]         }
[13:21:40.312]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:40.312]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:40.312]             base::sink(type = "output", split = FALSE)
[13:21:40.312]             base::close(...future.stdout)
[13:21:40.312]         }, add = TRUE)
[13:21:40.312]     }
[13:21:40.312]     ...future.frame <- base::sys.nframe()
[13:21:40.312]     ...future.conditions <- base::list()
[13:21:40.312]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:40.312]     if (FALSE) {
[13:21:40.312]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:40.312]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:40.312]     }
[13:21:40.312]     ...future.result <- base::tryCatch({
[13:21:40.312]         base::withCallingHandlers({
[13:21:40.312]             ...future.value <- base::withVisible(base::local({
[13:21:40.312]                 ...future.makeSendCondition <- base::local({
[13:21:40.312]                   sendCondition <- NULL
[13:21:40.312]                   function(frame = 1L) {
[13:21:40.312]                     if (is.function(sendCondition)) 
[13:21:40.312]                       return(sendCondition)
[13:21:40.312]                     ns <- getNamespace("parallel")
[13:21:40.312]                     if (exists("sendData", mode = "function", 
[13:21:40.312]                       envir = ns)) {
[13:21:40.312]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:40.312]                         envir = ns)
[13:21:40.312]                       envir <- sys.frame(frame)
[13:21:40.312]                       master <- NULL
[13:21:40.312]                       while (!identical(envir, .GlobalEnv) && 
[13:21:40.312]                         !identical(envir, emptyenv())) {
[13:21:40.312]                         if (exists("master", mode = "list", envir = envir, 
[13:21:40.312]                           inherits = FALSE)) {
[13:21:40.312]                           master <- get("master", mode = "list", 
[13:21:40.312]                             envir = envir, inherits = FALSE)
[13:21:40.312]                           if (inherits(master, c("SOCKnode", 
[13:21:40.312]                             "SOCK0node"))) {
[13:21:40.312]                             sendCondition <<- function(cond) {
[13:21:40.312]                               data <- list(type = "VALUE", value = cond, 
[13:21:40.312]                                 success = TRUE)
[13:21:40.312]                               parallel_sendData(master, data)
[13:21:40.312]                             }
[13:21:40.312]                             return(sendCondition)
[13:21:40.312]                           }
[13:21:40.312]                         }
[13:21:40.312]                         frame <- frame + 1L
[13:21:40.312]                         envir <- sys.frame(frame)
[13:21:40.312]                       }
[13:21:40.312]                     }
[13:21:40.312]                     sendCondition <<- function(cond) NULL
[13:21:40.312]                   }
[13:21:40.312]                 })
[13:21:40.312]                 withCallingHandlers({
[13:21:40.312]                   {
[13:21:40.312]                     do.call(function(...) {
[13:21:40.312]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:40.312]                       if (!identical(...future.globals.maxSize.org, 
[13:21:40.312]                         ...future.globals.maxSize)) {
[13:21:40.312]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:40.312]                         on.exit(options(oopts), add = TRUE)
[13:21:40.312]                       }
[13:21:40.312]                       {
[13:21:40.312]                         lapply(seq_along(...future.elements_ii), 
[13:21:40.312]                           FUN = function(jj) {
[13:21:40.312]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:40.312]                             ...future.FUN(...future.X_jj, ...)
[13:21:40.312]                           })
[13:21:40.312]                       }
[13:21:40.312]                     }, args = future.call.arguments)
[13:21:40.312]                   }
[13:21:40.312]                 }, immediateCondition = function(cond) {
[13:21:40.312]                   sendCondition <- ...future.makeSendCondition()
[13:21:40.312]                   sendCondition(cond)
[13:21:40.312]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.312]                   {
[13:21:40.312]                     inherits <- base::inherits
[13:21:40.312]                     invokeRestart <- base::invokeRestart
[13:21:40.312]                     is.null <- base::is.null
[13:21:40.312]                     muffled <- FALSE
[13:21:40.312]                     if (inherits(cond, "message")) {
[13:21:40.312]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:40.312]                       if (muffled) 
[13:21:40.312]                         invokeRestart("muffleMessage")
[13:21:40.312]                     }
[13:21:40.312]                     else if (inherits(cond, "warning")) {
[13:21:40.312]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:40.312]                       if (muffled) 
[13:21:40.312]                         invokeRestart("muffleWarning")
[13:21:40.312]                     }
[13:21:40.312]                     else if (inherits(cond, "condition")) {
[13:21:40.312]                       if (!is.null(pattern)) {
[13:21:40.312]                         computeRestarts <- base::computeRestarts
[13:21:40.312]                         grepl <- base::grepl
[13:21:40.312]                         restarts <- computeRestarts(cond)
[13:21:40.312]                         for (restart in restarts) {
[13:21:40.312]                           name <- restart$name
[13:21:40.312]                           if (is.null(name)) 
[13:21:40.312]                             next
[13:21:40.312]                           if (!grepl(pattern, name)) 
[13:21:40.312]                             next
[13:21:40.312]                           invokeRestart(restart)
[13:21:40.312]                           muffled <- TRUE
[13:21:40.312]                           break
[13:21:40.312]                         }
[13:21:40.312]                       }
[13:21:40.312]                     }
[13:21:40.312]                     invisible(muffled)
[13:21:40.312]                   }
[13:21:40.312]                   muffleCondition(cond)
[13:21:40.312]                 })
[13:21:40.312]             }))
[13:21:40.312]             future::FutureResult(value = ...future.value$value, 
[13:21:40.312]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:40.312]                   ...future.rng), globalenv = if (FALSE) 
[13:21:40.312]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:40.312]                     ...future.globalenv.names))
[13:21:40.312]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:40.312]         }, condition = base::local({
[13:21:40.312]             c <- base::c
[13:21:40.312]             inherits <- base::inherits
[13:21:40.312]             invokeRestart <- base::invokeRestart
[13:21:40.312]             length <- base::length
[13:21:40.312]             list <- base::list
[13:21:40.312]             seq.int <- base::seq.int
[13:21:40.312]             signalCondition <- base::signalCondition
[13:21:40.312]             sys.calls <- base::sys.calls
[13:21:40.312]             `[[` <- base::`[[`
[13:21:40.312]             `+` <- base::`+`
[13:21:40.312]             `<<-` <- base::`<<-`
[13:21:40.312]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:40.312]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:40.312]                   3L)]
[13:21:40.312]             }
[13:21:40.312]             function(cond) {
[13:21:40.312]                 is_error <- inherits(cond, "error")
[13:21:40.312]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:40.312]                   NULL)
[13:21:40.312]                 if (is_error) {
[13:21:40.312]                   sessionInformation <- function() {
[13:21:40.312]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:40.312]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:40.312]                       search = base::search(), system = base::Sys.info())
[13:21:40.312]                   }
[13:21:40.312]                   ...future.conditions[[length(...future.conditions) + 
[13:21:40.312]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:40.312]                     cond$call), session = sessionInformation(), 
[13:21:40.312]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:40.312]                   signalCondition(cond)
[13:21:40.312]                 }
[13:21:40.312]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:40.312]                 "immediateCondition"))) {
[13:21:40.312]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:40.312]                   ...future.conditions[[length(...future.conditions) + 
[13:21:40.312]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:40.312]                   if (TRUE && !signal) {
[13:21:40.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.312]                     {
[13:21:40.312]                       inherits <- base::inherits
[13:21:40.312]                       invokeRestart <- base::invokeRestart
[13:21:40.312]                       is.null <- base::is.null
[13:21:40.312]                       muffled <- FALSE
[13:21:40.312]                       if (inherits(cond, "message")) {
[13:21:40.312]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:40.312]                         if (muffled) 
[13:21:40.312]                           invokeRestart("muffleMessage")
[13:21:40.312]                       }
[13:21:40.312]                       else if (inherits(cond, "warning")) {
[13:21:40.312]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:40.312]                         if (muffled) 
[13:21:40.312]                           invokeRestart("muffleWarning")
[13:21:40.312]                       }
[13:21:40.312]                       else if (inherits(cond, "condition")) {
[13:21:40.312]                         if (!is.null(pattern)) {
[13:21:40.312]                           computeRestarts <- base::computeRestarts
[13:21:40.312]                           grepl <- base::grepl
[13:21:40.312]                           restarts <- computeRestarts(cond)
[13:21:40.312]                           for (restart in restarts) {
[13:21:40.312]                             name <- restart$name
[13:21:40.312]                             if (is.null(name)) 
[13:21:40.312]                               next
[13:21:40.312]                             if (!grepl(pattern, name)) 
[13:21:40.312]                               next
[13:21:40.312]                             invokeRestart(restart)
[13:21:40.312]                             muffled <- TRUE
[13:21:40.312]                             break
[13:21:40.312]                           }
[13:21:40.312]                         }
[13:21:40.312]                       }
[13:21:40.312]                       invisible(muffled)
[13:21:40.312]                     }
[13:21:40.312]                     muffleCondition(cond, pattern = "^muffle")
[13:21:40.312]                   }
[13:21:40.312]                 }
[13:21:40.312]                 else {
[13:21:40.312]                   if (TRUE) {
[13:21:40.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.312]                     {
[13:21:40.312]                       inherits <- base::inherits
[13:21:40.312]                       invokeRestart <- base::invokeRestart
[13:21:40.312]                       is.null <- base::is.null
[13:21:40.312]                       muffled <- FALSE
[13:21:40.312]                       if (inherits(cond, "message")) {
[13:21:40.312]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:40.312]                         if (muffled) 
[13:21:40.312]                           invokeRestart("muffleMessage")
[13:21:40.312]                       }
[13:21:40.312]                       else if (inherits(cond, "warning")) {
[13:21:40.312]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:40.312]                         if (muffled) 
[13:21:40.312]                           invokeRestart("muffleWarning")
[13:21:40.312]                       }
[13:21:40.312]                       else if (inherits(cond, "condition")) {
[13:21:40.312]                         if (!is.null(pattern)) {
[13:21:40.312]                           computeRestarts <- base::computeRestarts
[13:21:40.312]                           grepl <- base::grepl
[13:21:40.312]                           restarts <- computeRestarts(cond)
[13:21:40.312]                           for (restart in restarts) {
[13:21:40.312]                             name <- restart$name
[13:21:40.312]                             if (is.null(name)) 
[13:21:40.312]                               next
[13:21:40.312]                             if (!grepl(pattern, name)) 
[13:21:40.312]                               next
[13:21:40.312]                             invokeRestart(restart)
[13:21:40.312]                             muffled <- TRUE
[13:21:40.312]                             break
[13:21:40.312]                           }
[13:21:40.312]                         }
[13:21:40.312]                       }
[13:21:40.312]                       invisible(muffled)
[13:21:40.312]                     }
[13:21:40.312]                     muffleCondition(cond, pattern = "^muffle")
[13:21:40.312]                   }
[13:21:40.312]                 }
[13:21:40.312]             }
[13:21:40.312]         }))
[13:21:40.312]     }, error = function(ex) {
[13:21:40.312]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:40.312]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:40.312]                 ...future.rng), started = ...future.startTime, 
[13:21:40.312]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:40.312]             version = "1.8"), class = "FutureResult")
[13:21:40.312]     }, finally = {
[13:21:40.312]         if (!identical(...future.workdir, getwd())) 
[13:21:40.312]             setwd(...future.workdir)
[13:21:40.312]         {
[13:21:40.312]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:40.312]                 ...future.oldOptions$nwarnings <- NULL
[13:21:40.312]             }
[13:21:40.312]             base::options(...future.oldOptions)
[13:21:40.312]             if (.Platform$OS.type == "windows") {
[13:21:40.312]                 old_names <- names(...future.oldEnvVars)
[13:21:40.312]                 envs <- base::Sys.getenv()
[13:21:40.312]                 names <- names(envs)
[13:21:40.312]                 common <- intersect(names, old_names)
[13:21:40.312]                 added <- setdiff(names, old_names)
[13:21:40.312]                 removed <- setdiff(old_names, names)
[13:21:40.312]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:40.312]                   envs[common]]
[13:21:40.312]                 NAMES <- toupper(changed)
[13:21:40.312]                 args <- list()
[13:21:40.312]                 for (kk in seq_along(NAMES)) {
[13:21:40.312]                   name <- changed[[kk]]
[13:21:40.312]                   NAME <- NAMES[[kk]]
[13:21:40.312]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.312]                     next
[13:21:40.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:40.312]                 }
[13:21:40.312]                 NAMES <- toupper(added)
[13:21:40.312]                 for (kk in seq_along(NAMES)) {
[13:21:40.312]                   name <- added[[kk]]
[13:21:40.312]                   NAME <- NAMES[[kk]]
[13:21:40.312]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.312]                     next
[13:21:40.312]                   args[[name]] <- ""
[13:21:40.312]                 }
[13:21:40.312]                 NAMES <- toupper(removed)
[13:21:40.312]                 for (kk in seq_along(NAMES)) {
[13:21:40.312]                   name <- removed[[kk]]
[13:21:40.312]                   NAME <- NAMES[[kk]]
[13:21:40.312]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.312]                     next
[13:21:40.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:40.312]                 }
[13:21:40.312]                 if (length(args) > 0) 
[13:21:40.312]                   base::do.call(base::Sys.setenv, args = args)
[13:21:40.312]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:40.312]             }
[13:21:40.312]             else {
[13:21:40.312]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:40.312]             }
[13:21:40.312]             {
[13:21:40.312]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:40.312]                   0L) {
[13:21:40.312]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:40.312]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:40.312]                   base::options(opts)
[13:21:40.312]                 }
[13:21:40.312]                 {
[13:21:40.312]                   {
[13:21:40.312]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:40.312]                     NULL
[13:21:40.312]                   }
[13:21:40.312]                   options(future.plan = NULL)
[13:21:40.312]                   if (is.na(NA_character_)) 
[13:21:40.312]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:40.312]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:40.312]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:40.312]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:40.312]                     envir = parent.frame()) 
[13:21:40.312]                   {
[13:21:40.312]                     if (is.function(workers)) 
[13:21:40.312]                       workers <- workers()
[13:21:40.312]                     workers <- structure(as.integer(workers), 
[13:21:40.312]                       class = class(workers))
[13:21:40.312]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:40.312]                       workers >= 1)
[13:21:40.312]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:40.312]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:40.312]                     }
[13:21:40.312]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:40.312]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:40.312]                       envir = envir)
[13:21:40.312]                     if (!future$lazy) 
[13:21:40.312]                       future <- run(future)
[13:21:40.312]                     invisible(future)
[13:21:40.312]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:40.312]                 }
[13:21:40.312]             }
[13:21:40.312]         }
[13:21:40.312]     })
[13:21:40.312]     if (TRUE) {
[13:21:40.312]         base::sink(type = "output", split = FALSE)
[13:21:40.312]         if (TRUE) {
[13:21:40.312]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:40.312]         }
[13:21:40.312]         else {
[13:21:40.312]             ...future.result["stdout"] <- base::list(NULL)
[13:21:40.312]         }
[13:21:40.312]         base::close(...future.stdout)
[13:21:40.312]         ...future.stdout <- NULL
[13:21:40.312]     }
[13:21:40.312]     ...future.result$conditions <- ...future.conditions
[13:21:40.312]     ...future.result$finished <- base::Sys.time()
[13:21:40.312]     ...future.result
[13:21:40.312] }
[13:21:40.315] Exporting 5 global objects (45.86 KiB) to cluster node #2 ...
[13:21:40.315] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #2 ...
[13:21:40.356] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #2 ... DONE
[13:21:40.357] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:21:40.357] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:21:40.357] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ...
[13:21:40.358] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ... DONE
[13:21:40.358] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:21:40.358] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:21:40.358] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:21:40.359] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:21:40.359] Exporting 5 global objects (45.86 KiB) to cluster node #2 ... DONE
[13:21:40.360] MultisessionFuture started
[13:21:40.360] - Launch lazy future ... done
[13:21:40.360] run() for ‘MultisessionFuture’ ... done
[13:21:40.360] Created future:
[13:21:40.360] MultisessionFuture:
[13:21:40.360] Label: ‘future_sapply-2’
[13:21:40.360] Expression:
[13:21:40.360] {
[13:21:40.360]     do.call(function(...) {
[13:21:40.360]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:40.360]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:40.360]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:40.360]             on.exit(options(oopts), add = TRUE)
[13:21:40.360]         }
[13:21:40.360]         {
[13:21:40.360]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:40.360]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:40.360]                 ...future.FUN(...future.X_jj, ...)
[13:21:40.360]             })
[13:21:40.360]         }
[13:21:40.360]     }, args = future.call.arguments)
[13:21:40.360] }
[13:21:40.360] Lazy evaluation: FALSE
[13:21:40.360] Asynchronous evaluation: TRUE
[13:21:40.360] Local evaluation: TRUE
[13:21:40.360] Environment: R_GlobalEnv
[13:21:40.360] Capture standard output: TRUE
[13:21:40.360] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:40.360] Globals: 5 objects totaling 46.11 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 256 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:21:40.360] Packages: 1 packages (‘stats’)
[13:21:40.360] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:40.360] Resolved: FALSE
[13:21:40.360] Value: <not collected>
[13:21:40.360] Conditions captured: <none>
[13:21:40.360] Early signaling: FALSE
[13:21:40.360] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:40.360] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:40.372] Chunk #2 of 2 ... DONE
[13:21:40.372] Launching 2 futures (chunks) ... DONE
[13:21:40.372] Resolving 2 futures (chunks) ...
[13:21:40.372] resolve() on list ...
[13:21:40.373]  recursive: 0
[13:21:40.373]  length: 2
[13:21:40.373] 
[13:21:40.373] receiveMessageFromWorker() for ClusterFuture ...
[13:21:40.373] - Validating connection of MultisessionFuture
[13:21:40.374] - received message: FutureResult
[13:21:40.374] - Received FutureResult
[13:21:40.374] - Erased future from FutureRegistry
[13:21:40.374] result() for ClusterFuture ...
[13:21:40.374] - result already collected: FutureResult
[13:21:40.374] result() for ClusterFuture ... done
[13:21:40.374] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:40.374] Future #1
[13:21:40.374] result() for ClusterFuture ...
[13:21:40.374] - result already collected: FutureResult
[13:21:40.375] result() for ClusterFuture ... done
[13:21:40.375] result() for ClusterFuture ...
[13:21:40.375] - result already collected: FutureResult
[13:21:40.375] result() for ClusterFuture ... done
[13:21:40.375] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:21:40.375] - nx: 2
[13:21:40.375] - relay: TRUE
[13:21:40.375] - stdout: TRUE
[13:21:40.375] - signal: TRUE
[13:21:40.375] - resignal: FALSE
[13:21:40.375] - force: TRUE
[13:21:40.375] - relayed: [n=2] FALSE, FALSE
[13:21:40.376] - queued futures: [n=2] FALSE, FALSE
[13:21:40.376]  - until=1
[13:21:40.376]  - relaying element #1
[13:21:40.376] result() for ClusterFuture ...
[13:21:40.376] - result already collected: FutureResult
[13:21:40.376] result() for ClusterFuture ... done
[13:21:40.376] result() for ClusterFuture ...
[13:21:40.376] - result already collected: FutureResult
[13:21:40.376] result() for ClusterFuture ... done
[13:21:40.377] result() for ClusterFuture ...
[13:21:40.377] - result already collected: FutureResult
[13:21:40.377] result() for ClusterFuture ... done
[13:21:40.377] result() for ClusterFuture ...
[13:21:40.377] - result already collected: FutureResult
[13:21:40.377] result() for ClusterFuture ... done
[13:21:40.377] - relayed: [n=2] TRUE, FALSE
[13:21:40.377] - queued futures: [n=2] TRUE, FALSE
[13:21:40.377] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:21:40.377]  length: 1 (resolved future 1)
[13:21:40.405] receiveMessageFromWorker() for ClusterFuture ...
[13:21:40.406] - Validating connection of MultisessionFuture
[13:21:40.406] - received message: FutureResult
[13:21:40.406] - Received FutureResult
[13:21:40.406] - Erased future from FutureRegistry
[13:21:40.406] result() for ClusterFuture ...
[13:21:40.406] - result already collected: FutureResult
[13:21:40.406] result() for ClusterFuture ... done
[13:21:40.406] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:40.407] Future #2
[13:21:40.407] result() for ClusterFuture ...
[13:21:40.407] - result already collected: FutureResult
[13:21:40.407] result() for ClusterFuture ... done
[13:21:40.407] result() for ClusterFuture ...
[13:21:40.407] - result already collected: FutureResult
[13:21:40.407] result() for ClusterFuture ... done
[13:21:40.407] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:21:40.407] - nx: 2
[13:21:40.407] - relay: TRUE
[13:21:40.407] - stdout: TRUE
[13:21:40.407] - signal: TRUE
[13:21:40.408] - resignal: FALSE
[13:21:40.408] - force: TRUE
[13:21:40.408] - relayed: [n=2] TRUE, FALSE
[13:21:40.408] - queued futures: [n=2] TRUE, FALSE
[13:21:40.408]  - until=2
[13:21:40.408]  - relaying element #2
[13:21:40.408] result() for ClusterFuture ...
[13:21:40.408] - result already collected: FutureResult
[13:21:40.408] result() for ClusterFuture ... done
[13:21:40.408] result() for ClusterFuture ...
[13:21:40.409] - result already collected: FutureResult
[13:21:40.409] result() for ClusterFuture ... done
[13:21:40.409] result() for ClusterFuture ...
[13:21:40.409] - result already collected: FutureResult
[13:21:40.409] result() for ClusterFuture ... done
[13:21:40.409] result() for ClusterFuture ...
[13:21:40.409] - result already collected: FutureResult
[13:21:40.409] result() for ClusterFuture ... done
[13:21:40.409] - relayed: [n=2] TRUE, TRUE
[13:21:40.409] - queued futures: [n=2] TRUE, TRUE
[13:21:40.409] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:21:40.410]  length: 0 (resolved future 2)
[13:21:40.410] Relaying remaining futures
[13:21:40.410] signalConditionsASAP(NULL, pos=0) ...
[13:21:40.410] - nx: 2
[13:21:40.410] - relay: TRUE
[13:21:40.410] - stdout: TRUE
[13:21:40.410] - signal: TRUE
[13:21:40.410] - resignal: FALSE
[13:21:40.410] - force: TRUE
[13:21:40.410] - relayed: [n=2] TRUE, TRUE
[13:21:40.410] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:21:40.411] - relayed: [n=2] TRUE, TRUE
[13:21:40.411] - queued futures: [n=2] TRUE, TRUE
[13:21:40.411] signalConditionsASAP(NULL, pos=0) ... done
[13:21:40.411] resolve() on list ... DONE
[13:21:40.411] result() for ClusterFuture ...
[13:21:40.411] - result already collected: FutureResult
[13:21:40.411] result() for ClusterFuture ... done
[13:21:40.411] result() for ClusterFuture ...
[13:21:40.411] - result already collected: FutureResult
[13:21:40.411] result() for ClusterFuture ... done
[13:21:40.411] result() for ClusterFuture ...
[13:21:40.411] - result already collected: FutureResult
[13:21:40.412] result() for ClusterFuture ... done
[13:21:40.412] result() for ClusterFuture ...
[13:21:40.412] - result already collected: FutureResult
[13:21:40.412] result() for ClusterFuture ... done
[13:21:40.412]  - Number of value chunks collected: 2
[13:21:40.412] Resolving 2 futures (chunks) ... DONE
[13:21:40.412] Reducing values from 2 chunks ...
[13:21:40.412]  - Number of values collected after concatenation: 7
[13:21:40.412]  - Number of values expected: 7
[13:21:40.412] Reducing values from 2 chunks ... DONE
[13:21:40.413] future_lapply() ... DONE
[13:21:40.413] future_lapply() ...
[13:21:40.419] Number of chunks: 2
[13:21:40.419] getGlobalsAndPackagesXApply() ...
[13:21:40.419]  - future.globals: TRUE
[13:21:40.419] getGlobalsAndPackages() ...
[13:21:40.419] Searching for globals...
[13:21:40.426] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[13:21:40.427] Searching for globals ... DONE
[13:21:40.427] Resolving globals: FALSE
[13:21:40.428] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[13:21:40.428] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[13:21:40.428] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:40.429] - packages: [2] ‘stats’, ‘future.apply’
[13:21:40.429] getGlobalsAndPackages() ... DONE
[13:21:40.429]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:40.429]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[13:21:40.429] Finding globals ... DONE
[13:21:40.429]  - use_args: TRUE
[13:21:40.429]  - Getting '...' globals ...
[13:21:40.430] resolve() on list ...
[13:21:40.430]  recursive: 0
[13:21:40.430]  length: 1
[13:21:40.430]  elements: ‘...’
[13:21:40.430]  length: 0 (resolved future 1)
[13:21:40.430] resolve() on list ... DONE
[13:21:40.430]    - '...' content: [n=0] 
[13:21:40.430] List of 1
[13:21:40.430]  $ ...: list()
[13:21:40.430]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:40.430]  - attr(*, "where")=List of 1
[13:21:40.430]   ..$ ...:<environment: 0x563b700e6038> 
[13:21:40.430]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:40.430]  - attr(*, "resolved")= logi TRUE
[13:21:40.430]  - attr(*, "total_size")= num NA
[13:21:40.433]  - Getting '...' globals ... DONE
[13:21:40.433] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:40.433] List of 8
[13:21:40.433]  $ ...future.FUN:function (x, ...)  
[13:21:40.433]  $ x_FUN        :function (x, na.rm = TRUE)  
[13:21:40.433]  $ times        : int 5
[13:21:40.433]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:40.433]  $ stop_if_not  :function (...)  
[13:21:40.433]  $ dim          : NULL
[13:21:40.433]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:21:40.433]  $ ...          : list()
[13:21:40.433]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:40.433]  - attr(*, "where")=List of 8
[13:21:40.433]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:40.433]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:40.433]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:40.433]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:40.433]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:40.433]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:40.433]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:40.433]   ..$ ...          :<environment: 0x563b700e6038> 
[13:21:40.433]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:40.433]  - attr(*, "resolved")= logi FALSE
[13:21:40.433]  - attr(*, "total_size")= num 141240
[13:21:40.438] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[13:21:40.438] getGlobalsAndPackagesXApply() ... DONE
[13:21:40.439] Number of futures (= number of chunks): 2
[13:21:40.439] Launching 2 futures (chunks) ...
[13:21:40.439] Chunk #1 of 2 ...
[13:21:40.439]  - Finding globals in 'X' for chunk #1 ...
[13:21:40.439] getGlobalsAndPackages() ...
[13:21:40.439] Searching for globals...
[13:21:40.439] 
[13:21:40.440] Searching for globals ... DONE
[13:21:40.440] - globals: [0] <none>
[13:21:40.440] getGlobalsAndPackages() ... DONE
[13:21:40.440]    + additional globals found: [n=0] 
[13:21:40.440]    + additional namespaces needed: [n=0] 
[13:21:40.440]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:40.440]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:40.440]  - seeds: <none>
[13:21:40.440]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:40.440] getGlobalsAndPackages() ...
[13:21:40.441] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:40.441] Resolving globals: FALSE
[13:21:40.441] Tweak future expression to call with '...' arguments ...
[13:21:40.441] {
[13:21:40.441]     do.call(function(...) {
[13:21:40.441]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:40.441]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:40.441]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:40.441]             on.exit(options(oopts), add = TRUE)
[13:21:40.441]         }
[13:21:40.441]         {
[13:21:40.441]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:40.441]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:40.441]                 ...future.FUN(...future.X_jj, ...)
[13:21:40.441]             })
[13:21:40.441]         }
[13:21:40.441]     }, args = future.call.arguments)
[13:21:40.441] }
[13:21:40.441] Tweak future expression to call with '...' arguments ... DONE
[13:21:40.442] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:40.442] - packages: [2] ‘stats’, ‘future.apply’
[13:21:40.442] getGlobalsAndPackages() ... DONE
[13:21:40.442] run() for ‘Future’ ...
[13:21:40.442] - state: ‘created’
[13:21:40.442] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:40.456] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:40.456] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:40.457]   - Field: ‘node’
[13:21:40.457]   - Field: ‘label’
[13:21:40.457]   - Field: ‘local’
[13:21:40.457]   - Field: ‘owner’
[13:21:40.457]   - Field: ‘envir’
[13:21:40.457]   - Field: ‘workers’
[13:21:40.457]   - Field: ‘packages’
[13:21:40.457]   - Field: ‘gc’
[13:21:40.457]   - Field: ‘conditions’
[13:21:40.458]   - Field: ‘persistent’
[13:21:40.458]   - Field: ‘expr’
[13:21:40.458]   - Field: ‘uuid’
[13:21:40.458]   - Field: ‘seed’
[13:21:40.458]   - Field: ‘version’
[13:21:40.458]   - Field: ‘result’
[13:21:40.458]   - Field: ‘asynchronous’
[13:21:40.458]   - Field: ‘calls’
[13:21:40.458]   - Field: ‘globals’
[13:21:40.458]   - Field: ‘stdout’
[13:21:40.458]   - Field: ‘earlySignal’
[13:21:40.459]   - Field: ‘lazy’
[13:21:40.459]   - Field: ‘state’
[13:21:40.459] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:40.459] - Launch lazy future ...
[13:21:40.459] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[13:21:40.459] Packages needed by future strategies (n = 0): <none>
[13:21:40.460] {
[13:21:40.460]     {
[13:21:40.460]         {
[13:21:40.460]             ...future.startTime <- base::Sys.time()
[13:21:40.460]             {
[13:21:40.460]                 {
[13:21:40.460]                   {
[13:21:40.460]                     {
[13:21:40.460]                       {
[13:21:40.460]                         base::local({
[13:21:40.460]                           has_future <- base::requireNamespace("future", 
[13:21:40.460]                             quietly = TRUE)
[13:21:40.460]                           if (has_future) {
[13:21:40.460]                             ns <- base::getNamespace("future")
[13:21:40.460]                             version <- ns[[".package"]][["version"]]
[13:21:40.460]                             if (is.null(version)) 
[13:21:40.460]                               version <- utils::packageVersion("future")
[13:21:40.460]                           }
[13:21:40.460]                           else {
[13:21:40.460]                             version <- NULL
[13:21:40.460]                           }
[13:21:40.460]                           if (!has_future || version < "1.8.0") {
[13:21:40.460]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:40.460]                               "", base::R.version$version.string), 
[13:21:40.460]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:40.460]                                 base::R.version$platform, 8 * 
[13:21:40.460]                                   base::.Machine$sizeof.pointer), 
[13:21:40.460]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:40.460]                                 "release", "version")], collapse = " "), 
[13:21:40.460]                               hostname = base::Sys.info()[["nodename"]])
[13:21:40.460]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:40.460]                               info)
[13:21:40.460]                             info <- base::paste(info, collapse = "; ")
[13:21:40.460]                             if (!has_future) {
[13:21:40.460]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:40.460]                                 info)
[13:21:40.460]                             }
[13:21:40.460]                             else {
[13:21:40.460]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:40.460]                                 info, version)
[13:21:40.460]                             }
[13:21:40.460]                             base::stop(msg)
[13:21:40.460]                           }
[13:21:40.460]                         })
[13:21:40.460]                       }
[13:21:40.460]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:40.460]                       base::options(mc.cores = 1L)
[13:21:40.460]                     }
[13:21:40.460]                     base::local({
[13:21:40.460]                       for (pkg in c("stats", "future.apply")) {
[13:21:40.460]                         base::loadNamespace(pkg)
[13:21:40.460]                         base::library(pkg, character.only = TRUE)
[13:21:40.460]                       }
[13:21:40.460]                     })
[13:21:40.460]                   }
[13:21:40.460]                   options(future.plan = NULL)
[13:21:40.460]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:40.460]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:40.460]                 }
[13:21:40.460]                 ...future.workdir <- getwd()
[13:21:40.460]             }
[13:21:40.460]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:40.460]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:40.460]         }
[13:21:40.460]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:40.460]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:40.460]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:40.460]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:40.460]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:40.460]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:40.460]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:40.460]             base::names(...future.oldOptions))
[13:21:40.460]     }
[13:21:40.460]     if (FALSE) {
[13:21:40.460]     }
[13:21:40.460]     else {
[13:21:40.460]         if (TRUE) {
[13:21:40.460]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:40.460]                 open = "w")
[13:21:40.460]         }
[13:21:40.460]         else {
[13:21:40.460]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:40.460]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:40.460]         }
[13:21:40.460]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:40.460]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:40.460]             base::sink(type = "output", split = FALSE)
[13:21:40.460]             base::close(...future.stdout)
[13:21:40.460]         }, add = TRUE)
[13:21:40.460]     }
[13:21:40.460]     ...future.frame <- base::sys.nframe()
[13:21:40.460]     ...future.conditions <- base::list()
[13:21:40.460]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:40.460]     if (FALSE) {
[13:21:40.460]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:40.460]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:40.460]     }
[13:21:40.460]     ...future.result <- base::tryCatch({
[13:21:40.460]         base::withCallingHandlers({
[13:21:40.460]             ...future.value <- base::withVisible(base::local({
[13:21:40.460]                 ...future.makeSendCondition <- base::local({
[13:21:40.460]                   sendCondition <- NULL
[13:21:40.460]                   function(frame = 1L) {
[13:21:40.460]                     if (is.function(sendCondition)) 
[13:21:40.460]                       return(sendCondition)
[13:21:40.460]                     ns <- getNamespace("parallel")
[13:21:40.460]                     if (exists("sendData", mode = "function", 
[13:21:40.460]                       envir = ns)) {
[13:21:40.460]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:40.460]                         envir = ns)
[13:21:40.460]                       envir <- sys.frame(frame)
[13:21:40.460]                       master <- NULL
[13:21:40.460]                       while (!identical(envir, .GlobalEnv) && 
[13:21:40.460]                         !identical(envir, emptyenv())) {
[13:21:40.460]                         if (exists("master", mode = "list", envir = envir, 
[13:21:40.460]                           inherits = FALSE)) {
[13:21:40.460]                           master <- get("master", mode = "list", 
[13:21:40.460]                             envir = envir, inherits = FALSE)
[13:21:40.460]                           if (inherits(master, c("SOCKnode", 
[13:21:40.460]                             "SOCK0node"))) {
[13:21:40.460]                             sendCondition <<- function(cond) {
[13:21:40.460]                               data <- list(type = "VALUE", value = cond, 
[13:21:40.460]                                 success = TRUE)
[13:21:40.460]                               parallel_sendData(master, data)
[13:21:40.460]                             }
[13:21:40.460]                             return(sendCondition)
[13:21:40.460]                           }
[13:21:40.460]                         }
[13:21:40.460]                         frame <- frame + 1L
[13:21:40.460]                         envir <- sys.frame(frame)
[13:21:40.460]                       }
[13:21:40.460]                     }
[13:21:40.460]                     sendCondition <<- function(cond) NULL
[13:21:40.460]                   }
[13:21:40.460]                 })
[13:21:40.460]                 withCallingHandlers({
[13:21:40.460]                   {
[13:21:40.460]                     do.call(function(...) {
[13:21:40.460]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:40.460]                       if (!identical(...future.globals.maxSize.org, 
[13:21:40.460]                         ...future.globals.maxSize)) {
[13:21:40.460]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:40.460]                         on.exit(options(oopts), add = TRUE)
[13:21:40.460]                       }
[13:21:40.460]                       {
[13:21:40.460]                         lapply(seq_along(...future.elements_ii), 
[13:21:40.460]                           FUN = function(jj) {
[13:21:40.460]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:40.460]                             ...future.FUN(...future.X_jj, ...)
[13:21:40.460]                           })
[13:21:40.460]                       }
[13:21:40.460]                     }, args = future.call.arguments)
[13:21:40.460]                   }
[13:21:40.460]                 }, immediateCondition = function(cond) {
[13:21:40.460]                   sendCondition <- ...future.makeSendCondition()
[13:21:40.460]                   sendCondition(cond)
[13:21:40.460]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.460]                   {
[13:21:40.460]                     inherits <- base::inherits
[13:21:40.460]                     invokeRestart <- base::invokeRestart
[13:21:40.460]                     is.null <- base::is.null
[13:21:40.460]                     muffled <- FALSE
[13:21:40.460]                     if (inherits(cond, "message")) {
[13:21:40.460]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:40.460]                       if (muffled) 
[13:21:40.460]                         invokeRestart("muffleMessage")
[13:21:40.460]                     }
[13:21:40.460]                     else if (inherits(cond, "warning")) {
[13:21:40.460]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:40.460]                       if (muffled) 
[13:21:40.460]                         invokeRestart("muffleWarning")
[13:21:40.460]                     }
[13:21:40.460]                     else if (inherits(cond, "condition")) {
[13:21:40.460]                       if (!is.null(pattern)) {
[13:21:40.460]                         computeRestarts <- base::computeRestarts
[13:21:40.460]                         grepl <- base::grepl
[13:21:40.460]                         restarts <- computeRestarts(cond)
[13:21:40.460]                         for (restart in restarts) {
[13:21:40.460]                           name <- restart$name
[13:21:40.460]                           if (is.null(name)) 
[13:21:40.460]                             next
[13:21:40.460]                           if (!grepl(pattern, name)) 
[13:21:40.460]                             next
[13:21:40.460]                           invokeRestart(restart)
[13:21:40.460]                           muffled <- TRUE
[13:21:40.460]                           break
[13:21:40.460]                         }
[13:21:40.460]                       }
[13:21:40.460]                     }
[13:21:40.460]                     invisible(muffled)
[13:21:40.460]                   }
[13:21:40.460]                   muffleCondition(cond)
[13:21:40.460]                 })
[13:21:40.460]             }))
[13:21:40.460]             future::FutureResult(value = ...future.value$value, 
[13:21:40.460]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:40.460]                   ...future.rng), globalenv = if (FALSE) 
[13:21:40.460]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:40.460]                     ...future.globalenv.names))
[13:21:40.460]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:40.460]         }, condition = base::local({
[13:21:40.460]             c <- base::c
[13:21:40.460]             inherits <- base::inherits
[13:21:40.460]             invokeRestart <- base::invokeRestart
[13:21:40.460]             length <- base::length
[13:21:40.460]             list <- base::list
[13:21:40.460]             seq.int <- base::seq.int
[13:21:40.460]             signalCondition <- base::signalCondition
[13:21:40.460]             sys.calls <- base::sys.calls
[13:21:40.460]             `[[` <- base::`[[`
[13:21:40.460]             `+` <- base::`+`
[13:21:40.460]             `<<-` <- base::`<<-`
[13:21:40.460]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:40.460]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:40.460]                   3L)]
[13:21:40.460]             }
[13:21:40.460]             function(cond) {
[13:21:40.460]                 is_error <- inherits(cond, "error")
[13:21:40.460]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:40.460]                   NULL)
[13:21:40.460]                 if (is_error) {
[13:21:40.460]                   sessionInformation <- function() {
[13:21:40.460]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:40.460]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:40.460]                       search = base::search(), system = base::Sys.info())
[13:21:40.460]                   }
[13:21:40.460]                   ...future.conditions[[length(...future.conditions) + 
[13:21:40.460]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:40.460]                     cond$call), session = sessionInformation(), 
[13:21:40.460]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:40.460]                   signalCondition(cond)
[13:21:40.460]                 }
[13:21:40.460]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:40.460]                 "immediateCondition"))) {
[13:21:40.460]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:40.460]                   ...future.conditions[[length(...future.conditions) + 
[13:21:40.460]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:40.460]                   if (TRUE && !signal) {
[13:21:40.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.460]                     {
[13:21:40.460]                       inherits <- base::inherits
[13:21:40.460]                       invokeRestart <- base::invokeRestart
[13:21:40.460]                       is.null <- base::is.null
[13:21:40.460]                       muffled <- FALSE
[13:21:40.460]                       if (inherits(cond, "message")) {
[13:21:40.460]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:40.460]                         if (muffled) 
[13:21:40.460]                           invokeRestart("muffleMessage")
[13:21:40.460]                       }
[13:21:40.460]                       else if (inherits(cond, "warning")) {
[13:21:40.460]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:40.460]                         if (muffled) 
[13:21:40.460]                           invokeRestart("muffleWarning")
[13:21:40.460]                       }
[13:21:40.460]                       else if (inherits(cond, "condition")) {
[13:21:40.460]                         if (!is.null(pattern)) {
[13:21:40.460]                           computeRestarts <- base::computeRestarts
[13:21:40.460]                           grepl <- base::grepl
[13:21:40.460]                           restarts <- computeRestarts(cond)
[13:21:40.460]                           for (restart in restarts) {
[13:21:40.460]                             name <- restart$name
[13:21:40.460]                             if (is.null(name)) 
[13:21:40.460]                               next
[13:21:40.460]                             if (!grepl(pattern, name)) 
[13:21:40.460]                               next
[13:21:40.460]                             invokeRestart(restart)
[13:21:40.460]                             muffled <- TRUE
[13:21:40.460]                             break
[13:21:40.460]                           }
[13:21:40.460]                         }
[13:21:40.460]                       }
[13:21:40.460]                       invisible(muffled)
[13:21:40.460]                     }
[13:21:40.460]                     muffleCondition(cond, pattern = "^muffle")
[13:21:40.460]                   }
[13:21:40.460]                 }
[13:21:40.460]                 else {
[13:21:40.460]                   if (TRUE) {
[13:21:40.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.460]                     {
[13:21:40.460]                       inherits <- base::inherits
[13:21:40.460]                       invokeRestart <- base::invokeRestart
[13:21:40.460]                       is.null <- base::is.null
[13:21:40.460]                       muffled <- FALSE
[13:21:40.460]                       if (inherits(cond, "message")) {
[13:21:40.460]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:40.460]                         if (muffled) 
[13:21:40.460]                           invokeRestart("muffleMessage")
[13:21:40.460]                       }
[13:21:40.460]                       else if (inherits(cond, "warning")) {
[13:21:40.460]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:40.460]                         if (muffled) 
[13:21:40.460]                           invokeRestart("muffleWarning")
[13:21:40.460]                       }
[13:21:40.460]                       else if (inherits(cond, "condition")) {
[13:21:40.460]                         if (!is.null(pattern)) {
[13:21:40.460]                           computeRestarts <- base::computeRestarts
[13:21:40.460]                           grepl <- base::grepl
[13:21:40.460]                           restarts <- computeRestarts(cond)
[13:21:40.460]                           for (restart in restarts) {
[13:21:40.460]                             name <- restart$name
[13:21:40.460]                             if (is.null(name)) 
[13:21:40.460]                               next
[13:21:40.460]                             if (!grepl(pattern, name)) 
[13:21:40.460]                               next
[13:21:40.460]                             invokeRestart(restart)
[13:21:40.460]                             muffled <- TRUE
[13:21:40.460]                             break
[13:21:40.460]                           }
[13:21:40.460]                         }
[13:21:40.460]                       }
[13:21:40.460]                       invisible(muffled)
[13:21:40.460]                     }
[13:21:40.460]                     muffleCondition(cond, pattern = "^muffle")
[13:21:40.460]                   }
[13:21:40.460]                 }
[13:21:40.460]             }
[13:21:40.460]         }))
[13:21:40.460]     }, error = function(ex) {
[13:21:40.460]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:40.460]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:40.460]                 ...future.rng), started = ...future.startTime, 
[13:21:40.460]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:40.460]             version = "1.8"), class = "FutureResult")
[13:21:40.460]     }, finally = {
[13:21:40.460]         if (!identical(...future.workdir, getwd())) 
[13:21:40.460]             setwd(...future.workdir)
[13:21:40.460]         {
[13:21:40.460]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:40.460]                 ...future.oldOptions$nwarnings <- NULL
[13:21:40.460]             }
[13:21:40.460]             base::options(...future.oldOptions)
[13:21:40.460]             if (.Platform$OS.type == "windows") {
[13:21:40.460]                 old_names <- names(...future.oldEnvVars)
[13:21:40.460]                 envs <- base::Sys.getenv()
[13:21:40.460]                 names <- names(envs)
[13:21:40.460]                 common <- intersect(names, old_names)
[13:21:40.460]                 added <- setdiff(names, old_names)
[13:21:40.460]                 removed <- setdiff(old_names, names)
[13:21:40.460]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:40.460]                   envs[common]]
[13:21:40.460]                 NAMES <- toupper(changed)
[13:21:40.460]                 args <- list()
[13:21:40.460]                 for (kk in seq_along(NAMES)) {
[13:21:40.460]                   name <- changed[[kk]]
[13:21:40.460]                   NAME <- NAMES[[kk]]
[13:21:40.460]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.460]                     next
[13:21:40.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:40.460]                 }
[13:21:40.460]                 NAMES <- toupper(added)
[13:21:40.460]                 for (kk in seq_along(NAMES)) {
[13:21:40.460]                   name <- added[[kk]]
[13:21:40.460]                   NAME <- NAMES[[kk]]
[13:21:40.460]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.460]                     next
[13:21:40.460]                   args[[name]] <- ""
[13:21:40.460]                 }
[13:21:40.460]                 NAMES <- toupper(removed)
[13:21:40.460]                 for (kk in seq_along(NAMES)) {
[13:21:40.460]                   name <- removed[[kk]]
[13:21:40.460]                   NAME <- NAMES[[kk]]
[13:21:40.460]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.460]                     next
[13:21:40.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:40.460]                 }
[13:21:40.460]                 if (length(args) > 0) 
[13:21:40.460]                   base::do.call(base::Sys.setenv, args = args)
[13:21:40.460]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:40.460]             }
[13:21:40.460]             else {
[13:21:40.460]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:40.460]             }
[13:21:40.460]             {
[13:21:40.460]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:40.460]                   0L) {
[13:21:40.460]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:40.460]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:40.460]                   base::options(opts)
[13:21:40.460]                 }
[13:21:40.460]                 {
[13:21:40.460]                   {
[13:21:40.460]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:40.460]                     NULL
[13:21:40.460]                   }
[13:21:40.460]                   options(future.plan = NULL)
[13:21:40.460]                   if (is.na(NA_character_)) 
[13:21:40.460]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:40.460]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:40.460]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:40.460]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:40.460]                     envir = parent.frame()) 
[13:21:40.460]                   {
[13:21:40.460]                     if (is.function(workers)) 
[13:21:40.460]                       workers <- workers()
[13:21:40.460]                     workers <- structure(as.integer(workers), 
[13:21:40.460]                       class = class(workers))
[13:21:40.460]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:40.460]                       workers >= 1)
[13:21:40.460]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:40.460]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:40.460]                     }
[13:21:40.460]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:40.460]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:40.460]                       envir = envir)
[13:21:40.460]                     if (!future$lazy) 
[13:21:40.460]                       future <- run(future)
[13:21:40.460]                     invisible(future)
[13:21:40.460]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:40.460]                 }
[13:21:40.460]             }
[13:21:40.460]         }
[13:21:40.460]     })
[13:21:40.460]     if (TRUE) {
[13:21:40.460]         base::sink(type = "output", split = FALSE)
[13:21:40.460]         if (TRUE) {
[13:21:40.460]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:40.460]         }
[13:21:40.460]         else {
[13:21:40.460]             ...future.result["stdout"] <- base::list(NULL)
[13:21:40.460]         }
[13:21:40.460]         base::close(...future.stdout)
[13:21:40.460]         ...future.stdout <- NULL
[13:21:40.460]     }
[13:21:40.460]     ...future.result$conditions <- ...future.conditions
[13:21:40.460]     ...future.result$finished <- base::Sys.time()
[13:21:40.460]     ...future.result
[13:21:40.460] }
[13:21:40.463] Exporting 11 global objects (137.93 KiB) to cluster node #1 ...
[13:21:40.463] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:21:40.504] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:21:40.505] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #1 ...
[13:21:40.548] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #1 ... DONE
[13:21:40.548] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:21:40.549] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:21:40.549] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:21:40.592] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:21:40.593] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:21:40.636] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:21:40.637] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[13:21:40.637] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[13:21:40.637] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[13:21:40.638] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[13:21:40.638] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:21:40.638] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:21:40.639] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ...
[13:21:40.639] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ... DONE
[13:21:40.639] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:21:40.640] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:21:40.640] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:21:40.640] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:21:40.640] Exporting 11 global objects (137.93 KiB) to cluster node #1 ... DONE
[13:21:40.641] MultisessionFuture started
[13:21:40.641] - Launch lazy future ... done
[13:21:40.641] run() for ‘MultisessionFuture’ ... done
[13:21:40.641] Created future:
[13:21:40.641] MultisessionFuture:
[13:21:40.641] Label: ‘future_vapply-1’
[13:21:40.641] Expression:
[13:21:40.641] {
[13:21:40.641]     do.call(function(...) {
[13:21:40.641]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:40.641]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:40.641]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:40.641]             on.exit(options(oopts), add = TRUE)
[13:21:40.641]         }
[13:21:40.641]         {
[13:21:40.641]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:40.641]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:40.641]                 ...future.FUN(...future.X_jj, ...)
[13:21:40.641]             })
[13:21:40.641]         }
[13:21:40.641]     }, args = future.call.arguments)
[13:21:40.641] }
[13:21:40.641] Lazy evaluation: FALSE
[13:21:40.641] Asynchronous evaluation: TRUE
[13:21:40.641] Local evaluation: TRUE
[13:21:40.641] Environment: R_GlobalEnv
[13:21:40.641] Capture standard output: TRUE
[13:21:40.641] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:40.641] Globals: 11 objects totaling 138.21 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:40.641] Packages: 2 packages (‘stats’, ‘future.apply’)
[13:21:40.641] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:40.641] Resolved: FALSE
[13:21:40.641] Value: <not collected>
[13:21:40.641] Conditions captured: <none>
[13:21:40.641] Early signaling: FALSE
[13:21:40.641] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:40.641] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:40.653] Chunk #1 of 2 ... DONE
[13:21:40.653] Chunk #2 of 2 ...
[13:21:40.653]  - Finding globals in 'X' for chunk #2 ...
[13:21:40.653] getGlobalsAndPackages() ...
[13:21:40.654] Searching for globals...
[13:21:40.654] 
[13:21:40.654] Searching for globals ... DONE
[13:21:40.654] - globals: [0] <none>
[13:21:40.654] getGlobalsAndPackages() ... DONE
[13:21:40.654]    + additional globals found: [n=0] 
[13:21:40.654]    + additional namespaces needed: [n=0] 
[13:21:40.654]  - Finding globals in 'X' for chunk #2 ... DONE
[13:21:40.655]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:40.655]  - seeds: <none>
[13:21:40.655]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:40.655] getGlobalsAndPackages() ...
[13:21:40.655] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:40.655] Resolving globals: FALSE
[13:21:40.655] Tweak future expression to call with '...' arguments ...
[13:21:40.655] {
[13:21:40.655]     do.call(function(...) {
[13:21:40.655]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:40.655]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:40.655]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:40.655]             on.exit(options(oopts), add = TRUE)
[13:21:40.655]         }
[13:21:40.655]         {
[13:21:40.655]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:40.655]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:40.655]                 ...future.FUN(...future.X_jj, ...)
[13:21:40.655]             })
[13:21:40.655]         }
[13:21:40.655]     }, args = future.call.arguments)
[13:21:40.655] }
[13:21:40.656] Tweak future expression to call with '...' arguments ... DONE
[13:21:40.656] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:40.656] - packages: [2] ‘stats’, ‘future.apply’
[13:21:40.656] getGlobalsAndPackages() ... DONE
[13:21:40.657] run() for ‘Future’ ...
[13:21:40.657] - state: ‘created’
[13:21:40.657] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:40.671] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:40.671] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:40.672]   - Field: ‘node’
[13:21:40.672]   - Field: ‘label’
[13:21:40.672]   - Field: ‘local’
[13:21:40.672]   - Field: ‘owner’
[13:21:40.672]   - Field: ‘envir’
[13:21:40.672]   - Field: ‘workers’
[13:21:40.672]   - Field: ‘packages’
[13:21:40.672]   - Field: ‘gc’
[13:21:40.672]   - Field: ‘conditions’
[13:21:40.672]   - Field: ‘persistent’
[13:21:40.673]   - Field: ‘expr’
[13:21:40.673]   - Field: ‘uuid’
[13:21:40.673]   - Field: ‘seed’
[13:21:40.673]   - Field: ‘version’
[13:21:40.673]   - Field: ‘result’
[13:21:40.673]   - Field: ‘asynchronous’
[13:21:40.673]   - Field: ‘calls’
[13:21:40.673]   - Field: ‘globals’
[13:21:40.673]   - Field: ‘stdout’
[13:21:40.673]   - Field: ‘earlySignal’
[13:21:40.673]   - Field: ‘lazy’
[13:21:40.674]   - Field: ‘state’
[13:21:40.674] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:40.674] - Launch lazy future ...
[13:21:40.674] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[13:21:40.674] Packages needed by future strategies (n = 0): <none>
[13:21:40.675] {
[13:21:40.675]     {
[13:21:40.675]         {
[13:21:40.675]             ...future.startTime <- base::Sys.time()
[13:21:40.675]             {
[13:21:40.675]                 {
[13:21:40.675]                   {
[13:21:40.675]                     {
[13:21:40.675]                       {
[13:21:40.675]                         base::local({
[13:21:40.675]                           has_future <- base::requireNamespace("future", 
[13:21:40.675]                             quietly = TRUE)
[13:21:40.675]                           if (has_future) {
[13:21:40.675]                             ns <- base::getNamespace("future")
[13:21:40.675]                             version <- ns[[".package"]][["version"]]
[13:21:40.675]                             if (is.null(version)) 
[13:21:40.675]                               version <- utils::packageVersion("future")
[13:21:40.675]                           }
[13:21:40.675]                           else {
[13:21:40.675]                             version <- NULL
[13:21:40.675]                           }
[13:21:40.675]                           if (!has_future || version < "1.8.0") {
[13:21:40.675]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:40.675]                               "", base::R.version$version.string), 
[13:21:40.675]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:40.675]                                 base::R.version$platform, 8 * 
[13:21:40.675]                                   base::.Machine$sizeof.pointer), 
[13:21:40.675]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:40.675]                                 "release", "version")], collapse = " "), 
[13:21:40.675]                               hostname = base::Sys.info()[["nodename"]])
[13:21:40.675]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:40.675]                               info)
[13:21:40.675]                             info <- base::paste(info, collapse = "; ")
[13:21:40.675]                             if (!has_future) {
[13:21:40.675]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:40.675]                                 info)
[13:21:40.675]                             }
[13:21:40.675]                             else {
[13:21:40.675]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:40.675]                                 info, version)
[13:21:40.675]                             }
[13:21:40.675]                             base::stop(msg)
[13:21:40.675]                           }
[13:21:40.675]                         })
[13:21:40.675]                       }
[13:21:40.675]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:40.675]                       base::options(mc.cores = 1L)
[13:21:40.675]                     }
[13:21:40.675]                     base::local({
[13:21:40.675]                       for (pkg in c("stats", "future.apply")) {
[13:21:40.675]                         base::loadNamespace(pkg)
[13:21:40.675]                         base::library(pkg, character.only = TRUE)
[13:21:40.675]                       }
[13:21:40.675]                     })
[13:21:40.675]                   }
[13:21:40.675]                   options(future.plan = NULL)
[13:21:40.675]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:40.675]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:40.675]                 }
[13:21:40.675]                 ...future.workdir <- getwd()
[13:21:40.675]             }
[13:21:40.675]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:40.675]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:40.675]         }
[13:21:40.675]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:40.675]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:40.675]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:40.675]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:40.675]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:40.675]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:40.675]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:40.675]             base::names(...future.oldOptions))
[13:21:40.675]     }
[13:21:40.675]     if (FALSE) {
[13:21:40.675]     }
[13:21:40.675]     else {
[13:21:40.675]         if (TRUE) {
[13:21:40.675]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:40.675]                 open = "w")
[13:21:40.675]         }
[13:21:40.675]         else {
[13:21:40.675]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:40.675]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:40.675]         }
[13:21:40.675]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:40.675]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:40.675]             base::sink(type = "output", split = FALSE)
[13:21:40.675]             base::close(...future.stdout)
[13:21:40.675]         }, add = TRUE)
[13:21:40.675]     }
[13:21:40.675]     ...future.frame <- base::sys.nframe()
[13:21:40.675]     ...future.conditions <- base::list()
[13:21:40.675]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:40.675]     if (FALSE) {
[13:21:40.675]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:40.675]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:40.675]     }
[13:21:40.675]     ...future.result <- base::tryCatch({
[13:21:40.675]         base::withCallingHandlers({
[13:21:40.675]             ...future.value <- base::withVisible(base::local({
[13:21:40.675]                 ...future.makeSendCondition <- base::local({
[13:21:40.675]                   sendCondition <- NULL
[13:21:40.675]                   function(frame = 1L) {
[13:21:40.675]                     if (is.function(sendCondition)) 
[13:21:40.675]                       return(sendCondition)
[13:21:40.675]                     ns <- getNamespace("parallel")
[13:21:40.675]                     if (exists("sendData", mode = "function", 
[13:21:40.675]                       envir = ns)) {
[13:21:40.675]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:40.675]                         envir = ns)
[13:21:40.675]                       envir <- sys.frame(frame)
[13:21:40.675]                       master <- NULL
[13:21:40.675]                       while (!identical(envir, .GlobalEnv) && 
[13:21:40.675]                         !identical(envir, emptyenv())) {
[13:21:40.675]                         if (exists("master", mode = "list", envir = envir, 
[13:21:40.675]                           inherits = FALSE)) {
[13:21:40.675]                           master <- get("master", mode = "list", 
[13:21:40.675]                             envir = envir, inherits = FALSE)
[13:21:40.675]                           if (inherits(master, c("SOCKnode", 
[13:21:40.675]                             "SOCK0node"))) {
[13:21:40.675]                             sendCondition <<- function(cond) {
[13:21:40.675]                               data <- list(type = "VALUE", value = cond, 
[13:21:40.675]                                 success = TRUE)
[13:21:40.675]                               parallel_sendData(master, data)
[13:21:40.675]                             }
[13:21:40.675]                             return(sendCondition)
[13:21:40.675]                           }
[13:21:40.675]                         }
[13:21:40.675]                         frame <- frame + 1L
[13:21:40.675]                         envir <- sys.frame(frame)
[13:21:40.675]                       }
[13:21:40.675]                     }
[13:21:40.675]                     sendCondition <<- function(cond) NULL
[13:21:40.675]                   }
[13:21:40.675]                 })
[13:21:40.675]                 withCallingHandlers({
[13:21:40.675]                   {
[13:21:40.675]                     do.call(function(...) {
[13:21:40.675]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:40.675]                       if (!identical(...future.globals.maxSize.org, 
[13:21:40.675]                         ...future.globals.maxSize)) {
[13:21:40.675]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:40.675]                         on.exit(options(oopts), add = TRUE)
[13:21:40.675]                       }
[13:21:40.675]                       {
[13:21:40.675]                         lapply(seq_along(...future.elements_ii), 
[13:21:40.675]                           FUN = function(jj) {
[13:21:40.675]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:40.675]                             ...future.FUN(...future.X_jj, ...)
[13:21:40.675]                           })
[13:21:40.675]                       }
[13:21:40.675]                     }, args = future.call.arguments)
[13:21:40.675]                   }
[13:21:40.675]                 }, immediateCondition = function(cond) {
[13:21:40.675]                   sendCondition <- ...future.makeSendCondition()
[13:21:40.675]                   sendCondition(cond)
[13:21:40.675]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.675]                   {
[13:21:40.675]                     inherits <- base::inherits
[13:21:40.675]                     invokeRestart <- base::invokeRestart
[13:21:40.675]                     is.null <- base::is.null
[13:21:40.675]                     muffled <- FALSE
[13:21:40.675]                     if (inherits(cond, "message")) {
[13:21:40.675]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:40.675]                       if (muffled) 
[13:21:40.675]                         invokeRestart("muffleMessage")
[13:21:40.675]                     }
[13:21:40.675]                     else if (inherits(cond, "warning")) {
[13:21:40.675]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:40.675]                       if (muffled) 
[13:21:40.675]                         invokeRestart("muffleWarning")
[13:21:40.675]                     }
[13:21:40.675]                     else if (inherits(cond, "condition")) {
[13:21:40.675]                       if (!is.null(pattern)) {
[13:21:40.675]                         computeRestarts <- base::computeRestarts
[13:21:40.675]                         grepl <- base::grepl
[13:21:40.675]                         restarts <- computeRestarts(cond)
[13:21:40.675]                         for (restart in restarts) {
[13:21:40.675]                           name <- restart$name
[13:21:40.675]                           if (is.null(name)) 
[13:21:40.675]                             next
[13:21:40.675]                           if (!grepl(pattern, name)) 
[13:21:40.675]                             next
[13:21:40.675]                           invokeRestart(restart)
[13:21:40.675]                           muffled <- TRUE
[13:21:40.675]                           break
[13:21:40.675]                         }
[13:21:40.675]                       }
[13:21:40.675]                     }
[13:21:40.675]                     invisible(muffled)
[13:21:40.675]                   }
[13:21:40.675]                   muffleCondition(cond)
[13:21:40.675]                 })
[13:21:40.675]             }))
[13:21:40.675]             future::FutureResult(value = ...future.value$value, 
[13:21:40.675]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:40.675]                   ...future.rng), globalenv = if (FALSE) 
[13:21:40.675]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:40.675]                     ...future.globalenv.names))
[13:21:40.675]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:40.675]         }, condition = base::local({
[13:21:40.675]             c <- base::c
[13:21:40.675]             inherits <- base::inherits
[13:21:40.675]             invokeRestart <- base::invokeRestart
[13:21:40.675]             length <- base::length
[13:21:40.675]             list <- base::list
[13:21:40.675]             seq.int <- base::seq.int
[13:21:40.675]             signalCondition <- base::signalCondition
[13:21:40.675]             sys.calls <- base::sys.calls
[13:21:40.675]             `[[` <- base::`[[`
[13:21:40.675]             `+` <- base::`+`
[13:21:40.675]             `<<-` <- base::`<<-`
[13:21:40.675]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:40.675]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:40.675]                   3L)]
[13:21:40.675]             }
[13:21:40.675]             function(cond) {
[13:21:40.675]                 is_error <- inherits(cond, "error")
[13:21:40.675]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:40.675]                   NULL)
[13:21:40.675]                 if (is_error) {
[13:21:40.675]                   sessionInformation <- function() {
[13:21:40.675]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:40.675]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:40.675]                       search = base::search(), system = base::Sys.info())
[13:21:40.675]                   }
[13:21:40.675]                   ...future.conditions[[length(...future.conditions) + 
[13:21:40.675]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:40.675]                     cond$call), session = sessionInformation(), 
[13:21:40.675]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:40.675]                   signalCondition(cond)
[13:21:40.675]                 }
[13:21:40.675]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:40.675]                 "immediateCondition"))) {
[13:21:40.675]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:40.675]                   ...future.conditions[[length(...future.conditions) + 
[13:21:40.675]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:40.675]                   if (TRUE && !signal) {
[13:21:40.675]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.675]                     {
[13:21:40.675]                       inherits <- base::inherits
[13:21:40.675]                       invokeRestart <- base::invokeRestart
[13:21:40.675]                       is.null <- base::is.null
[13:21:40.675]                       muffled <- FALSE
[13:21:40.675]                       if (inherits(cond, "message")) {
[13:21:40.675]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:40.675]                         if (muffled) 
[13:21:40.675]                           invokeRestart("muffleMessage")
[13:21:40.675]                       }
[13:21:40.675]                       else if (inherits(cond, "warning")) {
[13:21:40.675]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:40.675]                         if (muffled) 
[13:21:40.675]                           invokeRestart("muffleWarning")
[13:21:40.675]                       }
[13:21:40.675]                       else if (inherits(cond, "condition")) {
[13:21:40.675]                         if (!is.null(pattern)) {
[13:21:40.675]                           computeRestarts <- base::computeRestarts
[13:21:40.675]                           grepl <- base::grepl
[13:21:40.675]                           restarts <- computeRestarts(cond)
[13:21:40.675]                           for (restart in restarts) {
[13:21:40.675]                             name <- restart$name
[13:21:40.675]                             if (is.null(name)) 
[13:21:40.675]                               next
[13:21:40.675]                             if (!grepl(pattern, name)) 
[13:21:40.675]                               next
[13:21:40.675]                             invokeRestart(restart)
[13:21:40.675]                             muffled <- TRUE
[13:21:40.675]                             break
[13:21:40.675]                           }
[13:21:40.675]                         }
[13:21:40.675]                       }
[13:21:40.675]                       invisible(muffled)
[13:21:40.675]                     }
[13:21:40.675]                     muffleCondition(cond, pattern = "^muffle")
[13:21:40.675]                   }
[13:21:40.675]                 }
[13:21:40.675]                 else {
[13:21:40.675]                   if (TRUE) {
[13:21:40.675]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.675]                     {
[13:21:40.675]                       inherits <- base::inherits
[13:21:40.675]                       invokeRestart <- base::invokeRestart
[13:21:40.675]                       is.null <- base::is.null
[13:21:40.675]                       muffled <- FALSE
[13:21:40.675]                       if (inherits(cond, "message")) {
[13:21:40.675]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:40.675]                         if (muffled) 
[13:21:40.675]                           invokeRestart("muffleMessage")
[13:21:40.675]                       }
[13:21:40.675]                       else if (inherits(cond, "warning")) {
[13:21:40.675]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:40.675]                         if (muffled) 
[13:21:40.675]                           invokeRestart("muffleWarning")
[13:21:40.675]                       }
[13:21:40.675]                       else if (inherits(cond, "condition")) {
[13:21:40.675]                         if (!is.null(pattern)) {
[13:21:40.675]                           computeRestarts <- base::computeRestarts
[13:21:40.675]                           grepl <- base::grepl
[13:21:40.675]                           restarts <- computeRestarts(cond)
[13:21:40.675]                           for (restart in restarts) {
[13:21:40.675]                             name <- restart$name
[13:21:40.675]                             if (is.null(name)) 
[13:21:40.675]                               next
[13:21:40.675]                             if (!grepl(pattern, name)) 
[13:21:40.675]                               next
[13:21:40.675]                             invokeRestart(restart)
[13:21:40.675]                             muffled <- TRUE
[13:21:40.675]                             break
[13:21:40.675]                           }
[13:21:40.675]                         }
[13:21:40.675]                       }
[13:21:40.675]                       invisible(muffled)
[13:21:40.675]                     }
[13:21:40.675]                     muffleCondition(cond, pattern = "^muffle")
[13:21:40.675]                   }
[13:21:40.675]                 }
[13:21:40.675]             }
[13:21:40.675]         }))
[13:21:40.675]     }, error = function(ex) {
[13:21:40.675]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:40.675]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:40.675]                 ...future.rng), started = ...future.startTime, 
[13:21:40.675]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:40.675]             version = "1.8"), class = "FutureResult")
[13:21:40.675]     }, finally = {
[13:21:40.675]         if (!identical(...future.workdir, getwd())) 
[13:21:40.675]             setwd(...future.workdir)
[13:21:40.675]         {
[13:21:40.675]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:40.675]                 ...future.oldOptions$nwarnings <- NULL
[13:21:40.675]             }
[13:21:40.675]             base::options(...future.oldOptions)
[13:21:40.675]             if (.Platform$OS.type == "windows") {
[13:21:40.675]                 old_names <- names(...future.oldEnvVars)
[13:21:40.675]                 envs <- base::Sys.getenv()
[13:21:40.675]                 names <- names(envs)
[13:21:40.675]                 common <- intersect(names, old_names)
[13:21:40.675]                 added <- setdiff(names, old_names)
[13:21:40.675]                 removed <- setdiff(old_names, names)
[13:21:40.675]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:40.675]                   envs[common]]
[13:21:40.675]                 NAMES <- toupper(changed)
[13:21:40.675]                 args <- list()
[13:21:40.675]                 for (kk in seq_along(NAMES)) {
[13:21:40.675]                   name <- changed[[kk]]
[13:21:40.675]                   NAME <- NAMES[[kk]]
[13:21:40.675]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.675]                     next
[13:21:40.675]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:40.675]                 }
[13:21:40.675]                 NAMES <- toupper(added)
[13:21:40.675]                 for (kk in seq_along(NAMES)) {
[13:21:40.675]                   name <- added[[kk]]
[13:21:40.675]                   NAME <- NAMES[[kk]]
[13:21:40.675]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.675]                     next
[13:21:40.675]                   args[[name]] <- ""
[13:21:40.675]                 }
[13:21:40.675]                 NAMES <- toupper(removed)
[13:21:40.675]                 for (kk in seq_along(NAMES)) {
[13:21:40.675]                   name <- removed[[kk]]
[13:21:40.675]                   NAME <- NAMES[[kk]]
[13:21:40.675]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.675]                     next
[13:21:40.675]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:40.675]                 }
[13:21:40.675]                 if (length(args) > 0) 
[13:21:40.675]                   base::do.call(base::Sys.setenv, args = args)
[13:21:40.675]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:40.675]             }
[13:21:40.675]             else {
[13:21:40.675]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:40.675]             }
[13:21:40.675]             {
[13:21:40.675]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:40.675]                   0L) {
[13:21:40.675]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:40.675]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:40.675]                   base::options(opts)
[13:21:40.675]                 }
[13:21:40.675]                 {
[13:21:40.675]                   {
[13:21:40.675]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:40.675]                     NULL
[13:21:40.675]                   }
[13:21:40.675]                   options(future.plan = NULL)
[13:21:40.675]                   if (is.na(NA_character_)) 
[13:21:40.675]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:40.675]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:40.675]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:40.675]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:40.675]                     envir = parent.frame()) 
[13:21:40.675]                   {
[13:21:40.675]                     if (is.function(workers)) 
[13:21:40.675]                       workers <- workers()
[13:21:40.675]                     workers <- structure(as.integer(workers), 
[13:21:40.675]                       class = class(workers))
[13:21:40.675]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:40.675]                       workers >= 1)
[13:21:40.675]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:40.675]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:40.675]                     }
[13:21:40.675]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:40.675]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:40.675]                       envir = envir)
[13:21:40.675]                     if (!future$lazy) 
[13:21:40.675]                       future <- run(future)
[13:21:40.675]                     invisible(future)
[13:21:40.675]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:40.675]                 }
[13:21:40.675]             }
[13:21:40.675]         }
[13:21:40.675]     })
[13:21:40.675]     if (TRUE) {
[13:21:40.675]         base::sink(type = "output", split = FALSE)
[13:21:40.675]         if (TRUE) {
[13:21:40.675]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:40.675]         }
[13:21:40.675]         else {
[13:21:40.675]             ...future.result["stdout"] <- base::list(NULL)
[13:21:40.675]         }
[13:21:40.675]         base::close(...future.stdout)
[13:21:40.675]         ...future.stdout <- NULL
[13:21:40.675]     }
[13:21:40.675]     ...future.result$conditions <- ...future.conditions
[13:21:40.675]     ...future.result$finished <- base::Sys.time()
[13:21:40.675]     ...future.result
[13:21:40.675] }
[13:21:40.678] Exporting 11 global objects (137.93 KiB) to cluster node #2 ...
[13:21:40.678] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[13:21:40.720] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[13:21:40.721] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #2 ...
[13:21:40.764] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #2 ... DONE
[13:21:40.764] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[13:21:40.765] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[13:21:40.765] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[13:21:40.808] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[13:21:40.811] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[13:21:40.852] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[13:21:40.853] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[13:21:40.853] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[13:21:40.853] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[13:21:40.854] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[13:21:40.854] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:21:40.855] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:21:40.855] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ...
[13:21:40.855] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ... DONE
[13:21:40.855] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:21:40.856] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:21:40.856] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:21:40.856] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:21:40.856] Exporting 11 global objects (137.93 KiB) to cluster node #2 ... DONE
[13:21:40.857] MultisessionFuture started
[13:21:40.857] - Launch lazy future ... done
[13:21:40.857] run() for ‘MultisessionFuture’ ... done
[13:21:40.857] Created future:
[13:21:40.857] MultisessionFuture:
[13:21:40.857] Label: ‘future_vapply-2’
[13:21:40.857] Expression:
[13:21:40.857] {
[13:21:40.857]     do.call(function(...) {
[13:21:40.857]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:40.857]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:40.857]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:40.857]             on.exit(options(oopts), add = TRUE)
[13:21:40.857]         }
[13:21:40.857]         {
[13:21:40.857]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:40.857]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:40.857]                 ...future.FUN(...future.X_jj, ...)
[13:21:40.857]             })
[13:21:40.857]         }
[13:21:40.857]     }, args = future.call.arguments)
[13:21:40.857] }
[13:21:40.857] Lazy evaluation: FALSE
[13:21:40.857] Asynchronous evaluation: TRUE
[13:21:40.857] Local evaluation: TRUE
[13:21:40.857] Environment: R_GlobalEnv
[13:21:40.857] Capture standard output: TRUE
[13:21:40.857] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:40.857] Globals: 11 objects totaling 138.18 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:40.857] Packages: 2 packages (‘stats’, ‘future.apply’)
[13:21:40.857] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:40.857] Resolved: FALSE
[13:21:40.857] Value: <not collected>
[13:21:40.857] Conditions captured: <none>
[13:21:40.857] Early signaling: FALSE
[13:21:40.857] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:40.857] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:40.869] Chunk #2 of 2 ... DONE
[13:21:40.869] Launching 2 futures (chunks) ... DONE
[13:21:40.869] Resolving 2 futures (chunks) ...
[13:21:40.869] resolve() on list ...
[13:21:40.870]  recursive: 0
[13:21:40.870]  length: 2
[13:21:40.870] 
[13:21:40.870] receiveMessageFromWorker() for ClusterFuture ...
[13:21:40.870] - Validating connection of MultisessionFuture
[13:21:40.870] - received message: FutureResult
[13:21:40.871] - Received FutureResult
[13:21:40.871] - Erased future from FutureRegistry
[13:21:40.871] result() for ClusterFuture ...
[13:21:40.871] - result already collected: FutureResult
[13:21:40.871] result() for ClusterFuture ... done
[13:21:40.871] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:40.871] Future #1
[13:21:40.871] result() for ClusterFuture ...
[13:21:40.871] - result already collected: FutureResult
[13:21:40.871] result() for ClusterFuture ... done
[13:21:40.871] result() for ClusterFuture ...
[13:21:40.872] - result already collected: FutureResult
[13:21:40.872] result() for ClusterFuture ... done
[13:21:40.872] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:21:40.872] - nx: 2
[13:21:40.872] - relay: TRUE
[13:21:40.872] - stdout: TRUE
[13:21:40.872] - signal: TRUE
[13:21:40.872] - resignal: FALSE
[13:21:40.872] - force: TRUE
[13:21:40.872] - relayed: [n=2] FALSE, FALSE
[13:21:40.872] - queued futures: [n=2] FALSE, FALSE
[13:21:40.873]  - until=1
[13:21:40.873]  - relaying element #1
[13:21:40.873] result() for ClusterFuture ...
[13:21:40.873] - result already collected: FutureResult
[13:21:40.873] result() for ClusterFuture ... done
[13:21:40.873] result() for ClusterFuture ...
[13:21:40.873] - result already collected: FutureResult
[13:21:40.873] result() for ClusterFuture ... done
[13:21:40.873] result() for ClusterFuture ...
[13:21:40.873] - result already collected: FutureResult
[13:21:40.874] result() for ClusterFuture ... done
[13:21:40.874] result() for ClusterFuture ...
[13:21:40.874] - result already collected: FutureResult
[13:21:40.874] result() for ClusterFuture ... done
[13:21:40.874] - relayed: [n=2] TRUE, FALSE
[13:21:40.874] - queued futures: [n=2] TRUE, FALSE
[13:21:40.874] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:21:40.874]  length: 1 (resolved future 1)
[13:21:40.905] receiveMessageFromWorker() for ClusterFuture ...
[13:21:40.906] - Validating connection of MultisessionFuture
[13:21:40.906] - received message: FutureResult
[13:21:40.906] - Received FutureResult
[13:21:40.906] - Erased future from FutureRegistry
[13:21:40.906] result() for ClusterFuture ...
[13:21:40.906] - result already collected: FutureResult
[13:21:40.906] result() for ClusterFuture ... done
[13:21:40.906] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:40.907] Future #2
[13:21:40.907] result() for ClusterFuture ...
[13:21:40.907] - result already collected: FutureResult
[13:21:40.907] result() for ClusterFuture ... done
[13:21:40.907] result() for ClusterFuture ...
[13:21:40.907] - result already collected: FutureResult
[13:21:40.907] result() for ClusterFuture ... done
[13:21:40.907] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:21:40.907] - nx: 2
[13:21:40.907] - relay: TRUE
[13:21:40.908] - stdout: TRUE
[13:21:40.908] - signal: TRUE
[13:21:40.908] - resignal: FALSE
[13:21:40.908] - force: TRUE
[13:21:40.908] - relayed: [n=2] TRUE, FALSE
[13:21:40.908] - queued futures: [n=2] TRUE, FALSE
[13:21:40.908]  - until=2
[13:21:40.908]  - relaying element #2
[13:21:40.908] result() for ClusterFuture ...
[13:21:40.908] - result already collected: FutureResult
[13:21:40.909] result() for ClusterFuture ... done
[13:21:40.909] result() for ClusterFuture ...
[13:21:40.909] - result already collected: FutureResult
[13:21:40.909] result() for ClusterFuture ... done
[13:21:40.909] result() for ClusterFuture ...
[13:21:40.909] - result already collected: FutureResult
[13:21:40.909] result() for ClusterFuture ... done
[13:21:40.909] result() for ClusterFuture ...
[13:21:40.909] - result already collected: FutureResult
[13:21:40.909] result() for ClusterFuture ... done
[13:21:40.909] - relayed: [n=2] TRUE, TRUE
[13:21:40.910] - queued futures: [n=2] TRUE, TRUE
[13:21:40.910] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:21:40.910]  length: 0 (resolved future 2)
[13:21:40.910] Relaying remaining futures
[13:21:40.910] signalConditionsASAP(NULL, pos=0) ...
[13:21:40.910] - nx: 2
[13:21:40.910] - relay: TRUE
[13:21:40.910] - stdout: TRUE
[13:21:40.910] - signal: TRUE
[13:21:40.910] - resignal: FALSE
[13:21:40.910] - force: TRUE
[13:21:40.911] - relayed: [n=2] TRUE, TRUE
[13:21:40.911] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:21:40.911] - relayed: [n=2] TRUE, TRUE
[13:21:40.911] - queued futures: [n=2] TRUE, TRUE
[13:21:40.911] signalConditionsASAP(NULL, pos=0) ... done
[13:21:40.911] resolve() on list ... DONE
[13:21:40.911] result() for ClusterFuture ...
[13:21:40.911] - result already collected: FutureResult
[13:21:40.911] result() for ClusterFuture ... done
[13:21:40.911] result() for ClusterFuture ...
[13:21:40.911] - result already collected: FutureResult
[13:21:40.912] result() for ClusterFuture ... done
[13:21:40.912] result() for ClusterFuture ...
[13:21:40.912] - result already collected: FutureResult
[13:21:40.912] result() for ClusterFuture ... done
[13:21:40.912] result() for ClusterFuture ...
[13:21:40.912] - result already collected: FutureResult
[13:21:40.912] result() for ClusterFuture ... done
[13:21:40.912]  - Number of value chunks collected: 2
[13:21:40.912] Resolving 2 futures (chunks) ... DONE
[13:21:40.912] Reducing values from 2 chunks ...
[13:21:40.913]  - Number of values collected after concatenation: 7
[13:21:40.913]  - Number of values expected: 7
[13:21:40.913] Reducing values from 2 chunks ... DONE
[13:21:40.913] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[13:21:40.914] future_lapply() ...
[13:21:40.919] Number of chunks: 2
[13:21:40.919] getGlobalsAndPackagesXApply() ...
[13:21:40.919]  - future.globals: TRUE
[13:21:40.919] getGlobalsAndPackages() ...
[13:21:40.919] Searching for globals...
[13:21:40.920] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[13:21:40.921] Searching for globals ... DONE
[13:21:40.921] Resolving globals: FALSE
[13:21:40.921] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[13:21:40.921] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[13:21:40.922] - globals: [1] ‘FUN’
[13:21:40.922] 
[13:21:40.922] getGlobalsAndPackages() ... DONE
[13:21:40.922]  - globals found/used: [n=1] ‘FUN’
[13:21:40.922]  - needed namespaces: [n=0] 
[13:21:40.922] Finding globals ... DONE
[13:21:40.922]  - use_args: TRUE
[13:21:40.922]  - Getting '...' globals ...
[13:21:40.923] resolve() on list ...
[13:21:40.923]  recursive: 0
[13:21:40.923]  length: 1
[13:21:40.923]  elements: ‘...’
[13:21:40.923]  length: 0 (resolved future 1)
[13:21:40.923] resolve() on list ... DONE
[13:21:40.923]    - '...' content: [n=1] ‘y’
[13:21:40.923] List of 1
[13:21:40.923]  $ ...:List of 1
[13:21:40.923]   ..$ y: num [1:5] 2 4 6 8 10
[13:21:40.923]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:40.923]  - attr(*, "where")=List of 1
[13:21:40.923]   ..$ ...:<environment: 0x563b6ccaf188> 
[13:21:40.923]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:40.923]  - attr(*, "resolved")= logi TRUE
[13:21:40.923]  - attr(*, "total_size")= num NA
[13:21:40.926]  - Getting '...' globals ... DONE
[13:21:40.926] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:21:40.927] List of 2
[13:21:40.927]  $ ...future.FUN:function (x, y)  
[13:21:40.927]  $ ...          :List of 1
[13:21:40.927]   ..$ y: num [1:5] 2 4 6 8 10
[13:21:40.927]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:40.927]  - attr(*, "where")=List of 2
[13:21:40.927]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:40.927]   ..$ ...          :<environment: 0x563b6ccaf188> 
[13:21:40.927]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:40.927]  - attr(*, "resolved")= logi FALSE
[13:21:40.927]  - attr(*, "total_size")= num 4264
[13:21:40.930] Packages to be attached in all futures: [n=0] 
[13:21:40.930] getGlobalsAndPackagesXApply() ... DONE
[13:21:40.930] Number of futures (= number of chunks): 2
[13:21:40.930] Launching 2 futures (chunks) ...
[13:21:40.930] Chunk #1 of 2 ...
[13:21:40.930]  - Finding globals in 'X' for chunk #1 ...
[13:21:40.930] getGlobalsAndPackages() ...
[13:21:40.930] Searching for globals...
[13:21:40.931] 
[13:21:40.931] Searching for globals ... DONE
[13:21:40.931] - globals: [0] <none>
[13:21:40.931] getGlobalsAndPackages() ... DONE
[13:21:40.931]    + additional globals found: [n=0] 
[13:21:40.931]    + additional namespaces needed: [n=0] 
[13:21:40.931]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:40.931]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:40.931]  - seeds: <none>
[13:21:40.931]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:40.932] getGlobalsAndPackages() ...
[13:21:40.932] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:40.932] Resolving globals: FALSE
[13:21:40.932] Tweak future expression to call with '...' arguments ...
[13:21:40.932] {
[13:21:40.932]     do.call(function(...) {
[13:21:40.932]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:40.932]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:40.932]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:40.932]             on.exit(options(oopts), add = TRUE)
[13:21:40.932]         }
[13:21:40.932]         {
[13:21:40.932]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:40.932]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:40.932]                 ...future.FUN(...future.X_jj, ...)
[13:21:40.932]             })
[13:21:40.932]         }
[13:21:40.932]     }, args = future.call.arguments)
[13:21:40.932] }
[13:21:40.932] Tweak future expression to call with '...' arguments ... DONE
[13:21:40.933] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:40.933] 
[13:21:40.933] getGlobalsAndPackages() ... DONE
[13:21:40.933] run() for ‘Future’ ...
[13:21:40.933] - state: ‘created’
[13:21:40.933] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:40.948] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:40.948] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:40.948]   - Field: ‘node’
[13:21:40.948]   - Field: ‘label’
[13:21:40.948]   - Field: ‘local’
[13:21:40.948]   - Field: ‘owner’
[13:21:40.948]   - Field: ‘envir’
[13:21:40.948]   - Field: ‘workers’
[13:21:40.949]   - Field: ‘packages’
[13:21:40.949]   - Field: ‘gc’
[13:21:40.949]   - Field: ‘conditions’
[13:21:40.949]   - Field: ‘persistent’
[13:21:40.949]   - Field: ‘expr’
[13:21:40.949]   - Field: ‘uuid’
[13:21:40.949]   - Field: ‘seed’
[13:21:40.949]   - Field: ‘version’
[13:21:40.949]   - Field: ‘result’
[13:21:40.949]   - Field: ‘asynchronous’
[13:21:40.949]   - Field: ‘calls’
[13:21:40.950]   - Field: ‘globals’
[13:21:40.950]   - Field: ‘stdout’
[13:21:40.950]   - Field: ‘earlySignal’
[13:21:40.950]   - Field: ‘lazy’
[13:21:40.950]   - Field: ‘state’
[13:21:40.950] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:40.950] - Launch lazy future ...
[13:21:40.950] Packages needed by the future expression (n = 0): <none>
[13:21:40.951] Packages needed by future strategies (n = 0): <none>
[13:21:40.951] {
[13:21:40.951]     {
[13:21:40.951]         {
[13:21:40.951]             ...future.startTime <- base::Sys.time()
[13:21:40.951]             {
[13:21:40.951]                 {
[13:21:40.951]                   {
[13:21:40.951]                     {
[13:21:40.951]                       base::local({
[13:21:40.951]                         has_future <- base::requireNamespace("future", 
[13:21:40.951]                           quietly = TRUE)
[13:21:40.951]                         if (has_future) {
[13:21:40.951]                           ns <- base::getNamespace("future")
[13:21:40.951]                           version <- ns[[".package"]][["version"]]
[13:21:40.951]                           if (is.null(version)) 
[13:21:40.951]                             version <- utils::packageVersion("future")
[13:21:40.951]                         }
[13:21:40.951]                         else {
[13:21:40.951]                           version <- NULL
[13:21:40.951]                         }
[13:21:40.951]                         if (!has_future || version < "1.8.0") {
[13:21:40.951]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:40.951]                             "", base::R.version$version.string), 
[13:21:40.951]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:40.951]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:40.951]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:40.951]                               "release", "version")], collapse = " "), 
[13:21:40.951]                             hostname = base::Sys.info()[["nodename"]])
[13:21:40.951]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:40.951]                             info)
[13:21:40.951]                           info <- base::paste(info, collapse = "; ")
[13:21:40.951]                           if (!has_future) {
[13:21:40.951]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:40.951]                               info)
[13:21:40.951]                           }
[13:21:40.951]                           else {
[13:21:40.951]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:40.951]                               info, version)
[13:21:40.951]                           }
[13:21:40.951]                           base::stop(msg)
[13:21:40.951]                         }
[13:21:40.951]                       })
[13:21:40.951]                     }
[13:21:40.951]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:40.951]                     base::options(mc.cores = 1L)
[13:21:40.951]                   }
[13:21:40.951]                   options(future.plan = NULL)
[13:21:40.951]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:40.951]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:40.951]                 }
[13:21:40.951]                 ...future.workdir <- getwd()
[13:21:40.951]             }
[13:21:40.951]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:40.951]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:40.951]         }
[13:21:40.951]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:40.951]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:40.951]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:40.951]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:40.951]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:40.951]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:40.951]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:40.951]             base::names(...future.oldOptions))
[13:21:40.951]     }
[13:21:40.951]     if (FALSE) {
[13:21:40.951]     }
[13:21:40.951]     else {
[13:21:40.951]         if (TRUE) {
[13:21:40.951]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:40.951]                 open = "w")
[13:21:40.951]         }
[13:21:40.951]         else {
[13:21:40.951]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:40.951]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:40.951]         }
[13:21:40.951]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:40.951]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:40.951]             base::sink(type = "output", split = FALSE)
[13:21:40.951]             base::close(...future.stdout)
[13:21:40.951]         }, add = TRUE)
[13:21:40.951]     }
[13:21:40.951]     ...future.frame <- base::sys.nframe()
[13:21:40.951]     ...future.conditions <- base::list()
[13:21:40.951]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:40.951]     if (FALSE) {
[13:21:40.951]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:40.951]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:40.951]     }
[13:21:40.951]     ...future.result <- base::tryCatch({
[13:21:40.951]         base::withCallingHandlers({
[13:21:40.951]             ...future.value <- base::withVisible(base::local({
[13:21:40.951]                 ...future.makeSendCondition <- base::local({
[13:21:40.951]                   sendCondition <- NULL
[13:21:40.951]                   function(frame = 1L) {
[13:21:40.951]                     if (is.function(sendCondition)) 
[13:21:40.951]                       return(sendCondition)
[13:21:40.951]                     ns <- getNamespace("parallel")
[13:21:40.951]                     if (exists("sendData", mode = "function", 
[13:21:40.951]                       envir = ns)) {
[13:21:40.951]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:40.951]                         envir = ns)
[13:21:40.951]                       envir <- sys.frame(frame)
[13:21:40.951]                       master <- NULL
[13:21:40.951]                       while (!identical(envir, .GlobalEnv) && 
[13:21:40.951]                         !identical(envir, emptyenv())) {
[13:21:40.951]                         if (exists("master", mode = "list", envir = envir, 
[13:21:40.951]                           inherits = FALSE)) {
[13:21:40.951]                           master <- get("master", mode = "list", 
[13:21:40.951]                             envir = envir, inherits = FALSE)
[13:21:40.951]                           if (inherits(master, c("SOCKnode", 
[13:21:40.951]                             "SOCK0node"))) {
[13:21:40.951]                             sendCondition <<- function(cond) {
[13:21:40.951]                               data <- list(type = "VALUE", value = cond, 
[13:21:40.951]                                 success = TRUE)
[13:21:40.951]                               parallel_sendData(master, data)
[13:21:40.951]                             }
[13:21:40.951]                             return(sendCondition)
[13:21:40.951]                           }
[13:21:40.951]                         }
[13:21:40.951]                         frame <- frame + 1L
[13:21:40.951]                         envir <- sys.frame(frame)
[13:21:40.951]                       }
[13:21:40.951]                     }
[13:21:40.951]                     sendCondition <<- function(cond) NULL
[13:21:40.951]                   }
[13:21:40.951]                 })
[13:21:40.951]                 withCallingHandlers({
[13:21:40.951]                   {
[13:21:40.951]                     do.call(function(...) {
[13:21:40.951]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:40.951]                       if (!identical(...future.globals.maxSize.org, 
[13:21:40.951]                         ...future.globals.maxSize)) {
[13:21:40.951]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:40.951]                         on.exit(options(oopts), add = TRUE)
[13:21:40.951]                       }
[13:21:40.951]                       {
[13:21:40.951]                         lapply(seq_along(...future.elements_ii), 
[13:21:40.951]                           FUN = function(jj) {
[13:21:40.951]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:40.951]                             ...future.FUN(...future.X_jj, ...)
[13:21:40.951]                           })
[13:21:40.951]                       }
[13:21:40.951]                     }, args = future.call.arguments)
[13:21:40.951]                   }
[13:21:40.951]                 }, immediateCondition = function(cond) {
[13:21:40.951]                   sendCondition <- ...future.makeSendCondition()
[13:21:40.951]                   sendCondition(cond)
[13:21:40.951]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.951]                   {
[13:21:40.951]                     inherits <- base::inherits
[13:21:40.951]                     invokeRestart <- base::invokeRestart
[13:21:40.951]                     is.null <- base::is.null
[13:21:40.951]                     muffled <- FALSE
[13:21:40.951]                     if (inherits(cond, "message")) {
[13:21:40.951]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:40.951]                       if (muffled) 
[13:21:40.951]                         invokeRestart("muffleMessage")
[13:21:40.951]                     }
[13:21:40.951]                     else if (inherits(cond, "warning")) {
[13:21:40.951]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:40.951]                       if (muffled) 
[13:21:40.951]                         invokeRestart("muffleWarning")
[13:21:40.951]                     }
[13:21:40.951]                     else if (inherits(cond, "condition")) {
[13:21:40.951]                       if (!is.null(pattern)) {
[13:21:40.951]                         computeRestarts <- base::computeRestarts
[13:21:40.951]                         grepl <- base::grepl
[13:21:40.951]                         restarts <- computeRestarts(cond)
[13:21:40.951]                         for (restart in restarts) {
[13:21:40.951]                           name <- restart$name
[13:21:40.951]                           if (is.null(name)) 
[13:21:40.951]                             next
[13:21:40.951]                           if (!grepl(pattern, name)) 
[13:21:40.951]                             next
[13:21:40.951]                           invokeRestart(restart)
[13:21:40.951]                           muffled <- TRUE
[13:21:40.951]                           break
[13:21:40.951]                         }
[13:21:40.951]                       }
[13:21:40.951]                     }
[13:21:40.951]                     invisible(muffled)
[13:21:40.951]                   }
[13:21:40.951]                   muffleCondition(cond)
[13:21:40.951]                 })
[13:21:40.951]             }))
[13:21:40.951]             future::FutureResult(value = ...future.value$value, 
[13:21:40.951]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:40.951]                   ...future.rng), globalenv = if (FALSE) 
[13:21:40.951]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:40.951]                     ...future.globalenv.names))
[13:21:40.951]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:40.951]         }, condition = base::local({
[13:21:40.951]             c <- base::c
[13:21:40.951]             inherits <- base::inherits
[13:21:40.951]             invokeRestart <- base::invokeRestart
[13:21:40.951]             length <- base::length
[13:21:40.951]             list <- base::list
[13:21:40.951]             seq.int <- base::seq.int
[13:21:40.951]             signalCondition <- base::signalCondition
[13:21:40.951]             sys.calls <- base::sys.calls
[13:21:40.951]             `[[` <- base::`[[`
[13:21:40.951]             `+` <- base::`+`
[13:21:40.951]             `<<-` <- base::`<<-`
[13:21:40.951]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:40.951]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:40.951]                   3L)]
[13:21:40.951]             }
[13:21:40.951]             function(cond) {
[13:21:40.951]                 is_error <- inherits(cond, "error")
[13:21:40.951]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:40.951]                   NULL)
[13:21:40.951]                 if (is_error) {
[13:21:40.951]                   sessionInformation <- function() {
[13:21:40.951]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:40.951]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:40.951]                       search = base::search(), system = base::Sys.info())
[13:21:40.951]                   }
[13:21:40.951]                   ...future.conditions[[length(...future.conditions) + 
[13:21:40.951]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:40.951]                     cond$call), session = sessionInformation(), 
[13:21:40.951]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:40.951]                   signalCondition(cond)
[13:21:40.951]                 }
[13:21:40.951]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:40.951]                 "immediateCondition"))) {
[13:21:40.951]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:40.951]                   ...future.conditions[[length(...future.conditions) + 
[13:21:40.951]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:40.951]                   if (TRUE && !signal) {
[13:21:40.951]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.951]                     {
[13:21:40.951]                       inherits <- base::inherits
[13:21:40.951]                       invokeRestart <- base::invokeRestart
[13:21:40.951]                       is.null <- base::is.null
[13:21:40.951]                       muffled <- FALSE
[13:21:40.951]                       if (inherits(cond, "message")) {
[13:21:40.951]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:40.951]                         if (muffled) 
[13:21:40.951]                           invokeRestart("muffleMessage")
[13:21:40.951]                       }
[13:21:40.951]                       else if (inherits(cond, "warning")) {
[13:21:40.951]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:40.951]                         if (muffled) 
[13:21:40.951]                           invokeRestart("muffleWarning")
[13:21:40.951]                       }
[13:21:40.951]                       else if (inherits(cond, "condition")) {
[13:21:40.951]                         if (!is.null(pattern)) {
[13:21:40.951]                           computeRestarts <- base::computeRestarts
[13:21:40.951]                           grepl <- base::grepl
[13:21:40.951]                           restarts <- computeRestarts(cond)
[13:21:40.951]                           for (restart in restarts) {
[13:21:40.951]                             name <- restart$name
[13:21:40.951]                             if (is.null(name)) 
[13:21:40.951]                               next
[13:21:40.951]                             if (!grepl(pattern, name)) 
[13:21:40.951]                               next
[13:21:40.951]                             invokeRestart(restart)
[13:21:40.951]                             muffled <- TRUE
[13:21:40.951]                             break
[13:21:40.951]                           }
[13:21:40.951]                         }
[13:21:40.951]                       }
[13:21:40.951]                       invisible(muffled)
[13:21:40.951]                     }
[13:21:40.951]                     muffleCondition(cond, pattern = "^muffle")
[13:21:40.951]                   }
[13:21:40.951]                 }
[13:21:40.951]                 else {
[13:21:40.951]                   if (TRUE) {
[13:21:40.951]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.951]                     {
[13:21:40.951]                       inherits <- base::inherits
[13:21:40.951]                       invokeRestart <- base::invokeRestart
[13:21:40.951]                       is.null <- base::is.null
[13:21:40.951]                       muffled <- FALSE
[13:21:40.951]                       if (inherits(cond, "message")) {
[13:21:40.951]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:40.951]                         if (muffled) 
[13:21:40.951]                           invokeRestart("muffleMessage")
[13:21:40.951]                       }
[13:21:40.951]                       else if (inherits(cond, "warning")) {
[13:21:40.951]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:40.951]                         if (muffled) 
[13:21:40.951]                           invokeRestart("muffleWarning")
[13:21:40.951]                       }
[13:21:40.951]                       else if (inherits(cond, "condition")) {
[13:21:40.951]                         if (!is.null(pattern)) {
[13:21:40.951]                           computeRestarts <- base::computeRestarts
[13:21:40.951]                           grepl <- base::grepl
[13:21:40.951]                           restarts <- computeRestarts(cond)
[13:21:40.951]                           for (restart in restarts) {
[13:21:40.951]                             name <- restart$name
[13:21:40.951]                             if (is.null(name)) 
[13:21:40.951]                               next
[13:21:40.951]                             if (!grepl(pattern, name)) 
[13:21:40.951]                               next
[13:21:40.951]                             invokeRestart(restart)
[13:21:40.951]                             muffled <- TRUE
[13:21:40.951]                             break
[13:21:40.951]                           }
[13:21:40.951]                         }
[13:21:40.951]                       }
[13:21:40.951]                       invisible(muffled)
[13:21:40.951]                     }
[13:21:40.951]                     muffleCondition(cond, pattern = "^muffle")
[13:21:40.951]                   }
[13:21:40.951]                 }
[13:21:40.951]             }
[13:21:40.951]         }))
[13:21:40.951]     }, error = function(ex) {
[13:21:40.951]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:40.951]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:40.951]                 ...future.rng), started = ...future.startTime, 
[13:21:40.951]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:40.951]             version = "1.8"), class = "FutureResult")
[13:21:40.951]     }, finally = {
[13:21:40.951]         if (!identical(...future.workdir, getwd())) 
[13:21:40.951]             setwd(...future.workdir)
[13:21:40.951]         {
[13:21:40.951]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:40.951]                 ...future.oldOptions$nwarnings <- NULL
[13:21:40.951]             }
[13:21:40.951]             base::options(...future.oldOptions)
[13:21:40.951]             if (.Platform$OS.type == "windows") {
[13:21:40.951]                 old_names <- names(...future.oldEnvVars)
[13:21:40.951]                 envs <- base::Sys.getenv()
[13:21:40.951]                 names <- names(envs)
[13:21:40.951]                 common <- intersect(names, old_names)
[13:21:40.951]                 added <- setdiff(names, old_names)
[13:21:40.951]                 removed <- setdiff(old_names, names)
[13:21:40.951]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:40.951]                   envs[common]]
[13:21:40.951]                 NAMES <- toupper(changed)
[13:21:40.951]                 args <- list()
[13:21:40.951]                 for (kk in seq_along(NAMES)) {
[13:21:40.951]                   name <- changed[[kk]]
[13:21:40.951]                   NAME <- NAMES[[kk]]
[13:21:40.951]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.951]                     next
[13:21:40.951]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:40.951]                 }
[13:21:40.951]                 NAMES <- toupper(added)
[13:21:40.951]                 for (kk in seq_along(NAMES)) {
[13:21:40.951]                   name <- added[[kk]]
[13:21:40.951]                   NAME <- NAMES[[kk]]
[13:21:40.951]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.951]                     next
[13:21:40.951]                   args[[name]] <- ""
[13:21:40.951]                 }
[13:21:40.951]                 NAMES <- toupper(removed)
[13:21:40.951]                 for (kk in seq_along(NAMES)) {
[13:21:40.951]                   name <- removed[[kk]]
[13:21:40.951]                   NAME <- NAMES[[kk]]
[13:21:40.951]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.951]                     next
[13:21:40.951]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:40.951]                 }
[13:21:40.951]                 if (length(args) > 0) 
[13:21:40.951]                   base::do.call(base::Sys.setenv, args = args)
[13:21:40.951]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:40.951]             }
[13:21:40.951]             else {
[13:21:40.951]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:40.951]             }
[13:21:40.951]             {
[13:21:40.951]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:40.951]                   0L) {
[13:21:40.951]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:40.951]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:40.951]                   base::options(opts)
[13:21:40.951]                 }
[13:21:40.951]                 {
[13:21:40.951]                   {
[13:21:40.951]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:40.951]                     NULL
[13:21:40.951]                   }
[13:21:40.951]                   options(future.plan = NULL)
[13:21:40.951]                   if (is.na(NA_character_)) 
[13:21:40.951]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:40.951]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:40.951]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:40.951]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:40.951]                     envir = parent.frame()) 
[13:21:40.951]                   {
[13:21:40.951]                     if (is.function(workers)) 
[13:21:40.951]                       workers <- workers()
[13:21:40.951]                     workers <- structure(as.integer(workers), 
[13:21:40.951]                       class = class(workers))
[13:21:40.951]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:40.951]                       workers >= 1)
[13:21:40.951]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:40.951]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:40.951]                     }
[13:21:40.951]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:40.951]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:40.951]                       envir = envir)
[13:21:40.951]                     if (!future$lazy) 
[13:21:40.951]                       future <- run(future)
[13:21:40.951]                     invisible(future)
[13:21:40.951]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:40.951]                 }
[13:21:40.951]             }
[13:21:40.951]         }
[13:21:40.951]     })
[13:21:40.951]     if (TRUE) {
[13:21:40.951]         base::sink(type = "output", split = FALSE)
[13:21:40.951]         if (TRUE) {
[13:21:40.951]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:40.951]         }
[13:21:40.951]         else {
[13:21:40.951]             ...future.result["stdout"] <- base::list(NULL)
[13:21:40.951]         }
[13:21:40.951]         base::close(...future.stdout)
[13:21:40.951]         ...future.stdout <- NULL
[13:21:40.951]     }
[13:21:40.951]     ...future.result$conditions <- ...future.conditions
[13:21:40.951]     ...future.result$finished <- base::Sys.time()
[13:21:40.951]     ...future.result
[13:21:40.951] }
[13:21:40.954] Exporting 5 global objects (4.16 KiB) to cluster node #1 ...
[13:21:40.954] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #1 ...
[13:21:40.955] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #1 ... DONE
[13:21:40.955] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ...
[13:21:40.955] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ... DONE
[13:21:40.955] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[13:21:40.956] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[13:21:40.956] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:21:40.956] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:21:40.956] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:21:40.957] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:21:40.957] Exporting 5 global objects (4.16 KiB) to cluster node #1 ... DONE
[13:21:40.958] MultisessionFuture started
[13:21:40.958] - Launch lazy future ... done
[13:21:40.958] run() for ‘MultisessionFuture’ ... done
[13:21:40.958] Created future:
[13:21:40.958] MultisessionFuture:
[13:21:40.958] Label: ‘future_sapply-1’
[13:21:40.958] Expression:
[13:21:40.958] {
[13:21:40.958]     do.call(function(...) {
[13:21:40.958]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:40.958]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:40.958]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:40.958]             on.exit(options(oopts), add = TRUE)
[13:21:40.958]         }
[13:21:40.958]         {
[13:21:40.958]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:40.958]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:40.958]                 ...future.FUN(...future.X_jj, ...)
[13:21:40.958]             })
[13:21:40.958]         }
[13:21:40.958]     }, args = future.call.arguments)
[13:21:40.958] }
[13:21:40.958] Lazy evaluation: FALSE
[13:21:40.958] Asynchronous evaluation: TRUE
[13:21:40.958] Local evaluation: TRUE
[13:21:40.958] Environment: R_GlobalEnv
[13:21:40.958] Capture standard output: TRUE
[13:21:40.958] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:40.958] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:21:40.958] Packages: <none>
[13:21:40.958] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:40.958] Resolved: FALSE
[13:21:40.958] Value: <not collected>
[13:21:40.958] Conditions captured: <none>
[13:21:40.958] Early signaling: FALSE
[13:21:40.958] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:40.958] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:40.970] Chunk #1 of 2 ... DONE
[13:21:40.970] Chunk #2 of 2 ...
[13:21:40.970]  - Finding globals in 'X' for chunk #2 ...
[13:21:40.970] getGlobalsAndPackages() ...
[13:21:40.970] Searching for globals...
[13:21:40.971] 
[13:21:40.971] Searching for globals ... DONE
[13:21:40.971] - globals: [0] <none>
[13:21:40.971] getGlobalsAndPackages() ... DONE
[13:21:40.971]    + additional globals found: [n=0] 
[13:21:40.971]    + additional namespaces needed: [n=0] 
[13:21:40.971]  - Finding globals in 'X' for chunk #2 ... DONE
[13:21:40.971]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:40.971]  - seeds: <none>
[13:21:40.971]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:40.972] getGlobalsAndPackages() ...
[13:21:40.972] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:40.972] Resolving globals: FALSE
[13:21:40.972] Tweak future expression to call with '...' arguments ...
[13:21:40.972] {
[13:21:40.972]     do.call(function(...) {
[13:21:40.972]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:40.972]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:40.972]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:40.972]             on.exit(options(oopts), add = TRUE)
[13:21:40.972]         }
[13:21:40.972]         {
[13:21:40.972]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:40.972]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:40.972]                 ...future.FUN(...future.X_jj, ...)
[13:21:40.972]             })
[13:21:40.972]         }
[13:21:40.972]     }, args = future.call.arguments)
[13:21:40.972] }
[13:21:40.972] Tweak future expression to call with '...' arguments ... DONE
[13:21:40.973] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:40.973] 
[13:21:40.973] getGlobalsAndPackages() ... DONE
[13:21:40.973] run() for ‘Future’ ...
[13:21:40.973] - state: ‘created’
[13:21:40.973] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:40.988] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:40.988] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:40.988]   - Field: ‘node’
[13:21:40.988]   - Field: ‘label’
[13:21:40.988]   - Field: ‘local’
[13:21:40.988]   - Field: ‘owner’
[13:21:40.988]   - Field: ‘envir’
[13:21:40.988]   - Field: ‘workers’
[13:21:40.988]   - Field: ‘packages’
[13:21:40.989]   - Field: ‘gc’
[13:21:40.989]   - Field: ‘conditions’
[13:21:40.989]   - Field: ‘persistent’
[13:21:40.989]   - Field: ‘expr’
[13:21:40.989]   - Field: ‘uuid’
[13:21:40.989]   - Field: ‘seed’
[13:21:40.989]   - Field: ‘version’
[13:21:40.989]   - Field: ‘result’
[13:21:40.989]   - Field: ‘asynchronous’
[13:21:40.989]   - Field: ‘calls’
[13:21:40.989]   - Field: ‘globals’
[13:21:40.990]   - Field: ‘stdout’
[13:21:40.990]   - Field: ‘earlySignal’
[13:21:40.990]   - Field: ‘lazy’
[13:21:40.990]   - Field: ‘state’
[13:21:40.990] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:40.990] - Launch lazy future ...
[13:21:40.990] Packages needed by the future expression (n = 0): <none>
[13:21:40.990] Packages needed by future strategies (n = 0): <none>
[13:21:40.991] {
[13:21:40.991]     {
[13:21:40.991]         {
[13:21:40.991]             ...future.startTime <- base::Sys.time()
[13:21:40.991]             {
[13:21:40.991]                 {
[13:21:40.991]                   {
[13:21:40.991]                     {
[13:21:40.991]                       base::local({
[13:21:40.991]                         has_future <- base::requireNamespace("future", 
[13:21:40.991]                           quietly = TRUE)
[13:21:40.991]                         if (has_future) {
[13:21:40.991]                           ns <- base::getNamespace("future")
[13:21:40.991]                           version <- ns[[".package"]][["version"]]
[13:21:40.991]                           if (is.null(version)) 
[13:21:40.991]                             version <- utils::packageVersion("future")
[13:21:40.991]                         }
[13:21:40.991]                         else {
[13:21:40.991]                           version <- NULL
[13:21:40.991]                         }
[13:21:40.991]                         if (!has_future || version < "1.8.0") {
[13:21:40.991]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:40.991]                             "", base::R.version$version.string), 
[13:21:40.991]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:40.991]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:40.991]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:40.991]                               "release", "version")], collapse = " "), 
[13:21:40.991]                             hostname = base::Sys.info()[["nodename"]])
[13:21:40.991]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:40.991]                             info)
[13:21:40.991]                           info <- base::paste(info, collapse = "; ")
[13:21:40.991]                           if (!has_future) {
[13:21:40.991]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:40.991]                               info)
[13:21:40.991]                           }
[13:21:40.991]                           else {
[13:21:40.991]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:40.991]                               info, version)
[13:21:40.991]                           }
[13:21:40.991]                           base::stop(msg)
[13:21:40.991]                         }
[13:21:40.991]                       })
[13:21:40.991]                     }
[13:21:40.991]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:40.991]                     base::options(mc.cores = 1L)
[13:21:40.991]                   }
[13:21:40.991]                   options(future.plan = NULL)
[13:21:40.991]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:40.991]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:40.991]                 }
[13:21:40.991]                 ...future.workdir <- getwd()
[13:21:40.991]             }
[13:21:40.991]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:40.991]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:40.991]         }
[13:21:40.991]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:40.991]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:40.991]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:40.991]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:40.991]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:40.991]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:40.991]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:40.991]             base::names(...future.oldOptions))
[13:21:40.991]     }
[13:21:40.991]     if (FALSE) {
[13:21:40.991]     }
[13:21:40.991]     else {
[13:21:40.991]         if (TRUE) {
[13:21:40.991]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:40.991]                 open = "w")
[13:21:40.991]         }
[13:21:40.991]         else {
[13:21:40.991]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:40.991]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:40.991]         }
[13:21:40.991]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:40.991]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:40.991]             base::sink(type = "output", split = FALSE)
[13:21:40.991]             base::close(...future.stdout)
[13:21:40.991]         }, add = TRUE)
[13:21:40.991]     }
[13:21:40.991]     ...future.frame <- base::sys.nframe()
[13:21:40.991]     ...future.conditions <- base::list()
[13:21:40.991]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:40.991]     if (FALSE) {
[13:21:40.991]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:40.991]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:40.991]     }
[13:21:40.991]     ...future.result <- base::tryCatch({
[13:21:40.991]         base::withCallingHandlers({
[13:21:40.991]             ...future.value <- base::withVisible(base::local({
[13:21:40.991]                 ...future.makeSendCondition <- base::local({
[13:21:40.991]                   sendCondition <- NULL
[13:21:40.991]                   function(frame = 1L) {
[13:21:40.991]                     if (is.function(sendCondition)) 
[13:21:40.991]                       return(sendCondition)
[13:21:40.991]                     ns <- getNamespace("parallel")
[13:21:40.991]                     if (exists("sendData", mode = "function", 
[13:21:40.991]                       envir = ns)) {
[13:21:40.991]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:40.991]                         envir = ns)
[13:21:40.991]                       envir <- sys.frame(frame)
[13:21:40.991]                       master <- NULL
[13:21:40.991]                       while (!identical(envir, .GlobalEnv) && 
[13:21:40.991]                         !identical(envir, emptyenv())) {
[13:21:40.991]                         if (exists("master", mode = "list", envir = envir, 
[13:21:40.991]                           inherits = FALSE)) {
[13:21:40.991]                           master <- get("master", mode = "list", 
[13:21:40.991]                             envir = envir, inherits = FALSE)
[13:21:40.991]                           if (inherits(master, c("SOCKnode", 
[13:21:40.991]                             "SOCK0node"))) {
[13:21:40.991]                             sendCondition <<- function(cond) {
[13:21:40.991]                               data <- list(type = "VALUE", value = cond, 
[13:21:40.991]                                 success = TRUE)
[13:21:40.991]                               parallel_sendData(master, data)
[13:21:40.991]                             }
[13:21:40.991]                             return(sendCondition)
[13:21:40.991]                           }
[13:21:40.991]                         }
[13:21:40.991]                         frame <- frame + 1L
[13:21:40.991]                         envir <- sys.frame(frame)
[13:21:40.991]                       }
[13:21:40.991]                     }
[13:21:40.991]                     sendCondition <<- function(cond) NULL
[13:21:40.991]                   }
[13:21:40.991]                 })
[13:21:40.991]                 withCallingHandlers({
[13:21:40.991]                   {
[13:21:40.991]                     do.call(function(...) {
[13:21:40.991]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:40.991]                       if (!identical(...future.globals.maxSize.org, 
[13:21:40.991]                         ...future.globals.maxSize)) {
[13:21:40.991]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:40.991]                         on.exit(options(oopts), add = TRUE)
[13:21:40.991]                       }
[13:21:40.991]                       {
[13:21:40.991]                         lapply(seq_along(...future.elements_ii), 
[13:21:40.991]                           FUN = function(jj) {
[13:21:40.991]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:40.991]                             ...future.FUN(...future.X_jj, ...)
[13:21:40.991]                           })
[13:21:40.991]                       }
[13:21:40.991]                     }, args = future.call.arguments)
[13:21:40.991]                   }
[13:21:40.991]                 }, immediateCondition = function(cond) {
[13:21:40.991]                   sendCondition <- ...future.makeSendCondition()
[13:21:40.991]                   sendCondition(cond)
[13:21:40.991]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.991]                   {
[13:21:40.991]                     inherits <- base::inherits
[13:21:40.991]                     invokeRestart <- base::invokeRestart
[13:21:40.991]                     is.null <- base::is.null
[13:21:40.991]                     muffled <- FALSE
[13:21:40.991]                     if (inherits(cond, "message")) {
[13:21:40.991]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:40.991]                       if (muffled) 
[13:21:40.991]                         invokeRestart("muffleMessage")
[13:21:40.991]                     }
[13:21:40.991]                     else if (inherits(cond, "warning")) {
[13:21:40.991]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:40.991]                       if (muffled) 
[13:21:40.991]                         invokeRestart("muffleWarning")
[13:21:40.991]                     }
[13:21:40.991]                     else if (inherits(cond, "condition")) {
[13:21:40.991]                       if (!is.null(pattern)) {
[13:21:40.991]                         computeRestarts <- base::computeRestarts
[13:21:40.991]                         grepl <- base::grepl
[13:21:40.991]                         restarts <- computeRestarts(cond)
[13:21:40.991]                         for (restart in restarts) {
[13:21:40.991]                           name <- restart$name
[13:21:40.991]                           if (is.null(name)) 
[13:21:40.991]                             next
[13:21:40.991]                           if (!grepl(pattern, name)) 
[13:21:40.991]                             next
[13:21:40.991]                           invokeRestart(restart)
[13:21:40.991]                           muffled <- TRUE
[13:21:40.991]                           break
[13:21:40.991]                         }
[13:21:40.991]                       }
[13:21:40.991]                     }
[13:21:40.991]                     invisible(muffled)
[13:21:40.991]                   }
[13:21:40.991]                   muffleCondition(cond)
[13:21:40.991]                 })
[13:21:40.991]             }))
[13:21:40.991]             future::FutureResult(value = ...future.value$value, 
[13:21:40.991]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:40.991]                   ...future.rng), globalenv = if (FALSE) 
[13:21:40.991]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:40.991]                     ...future.globalenv.names))
[13:21:40.991]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:40.991]         }, condition = base::local({
[13:21:40.991]             c <- base::c
[13:21:40.991]             inherits <- base::inherits
[13:21:40.991]             invokeRestart <- base::invokeRestart
[13:21:40.991]             length <- base::length
[13:21:40.991]             list <- base::list
[13:21:40.991]             seq.int <- base::seq.int
[13:21:40.991]             signalCondition <- base::signalCondition
[13:21:40.991]             sys.calls <- base::sys.calls
[13:21:40.991]             `[[` <- base::`[[`
[13:21:40.991]             `+` <- base::`+`
[13:21:40.991]             `<<-` <- base::`<<-`
[13:21:40.991]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:40.991]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:40.991]                   3L)]
[13:21:40.991]             }
[13:21:40.991]             function(cond) {
[13:21:40.991]                 is_error <- inherits(cond, "error")
[13:21:40.991]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:40.991]                   NULL)
[13:21:40.991]                 if (is_error) {
[13:21:40.991]                   sessionInformation <- function() {
[13:21:40.991]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:40.991]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:40.991]                       search = base::search(), system = base::Sys.info())
[13:21:40.991]                   }
[13:21:40.991]                   ...future.conditions[[length(...future.conditions) + 
[13:21:40.991]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:40.991]                     cond$call), session = sessionInformation(), 
[13:21:40.991]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:40.991]                   signalCondition(cond)
[13:21:40.991]                 }
[13:21:40.991]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:40.991]                 "immediateCondition"))) {
[13:21:40.991]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:40.991]                   ...future.conditions[[length(...future.conditions) + 
[13:21:40.991]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:40.991]                   if (TRUE && !signal) {
[13:21:40.991]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.991]                     {
[13:21:40.991]                       inherits <- base::inherits
[13:21:40.991]                       invokeRestart <- base::invokeRestart
[13:21:40.991]                       is.null <- base::is.null
[13:21:40.991]                       muffled <- FALSE
[13:21:40.991]                       if (inherits(cond, "message")) {
[13:21:40.991]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:40.991]                         if (muffled) 
[13:21:40.991]                           invokeRestart("muffleMessage")
[13:21:40.991]                       }
[13:21:40.991]                       else if (inherits(cond, "warning")) {
[13:21:40.991]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:40.991]                         if (muffled) 
[13:21:40.991]                           invokeRestart("muffleWarning")
[13:21:40.991]                       }
[13:21:40.991]                       else if (inherits(cond, "condition")) {
[13:21:40.991]                         if (!is.null(pattern)) {
[13:21:40.991]                           computeRestarts <- base::computeRestarts
[13:21:40.991]                           grepl <- base::grepl
[13:21:40.991]                           restarts <- computeRestarts(cond)
[13:21:40.991]                           for (restart in restarts) {
[13:21:40.991]                             name <- restart$name
[13:21:40.991]                             if (is.null(name)) 
[13:21:40.991]                               next
[13:21:40.991]                             if (!grepl(pattern, name)) 
[13:21:40.991]                               next
[13:21:40.991]                             invokeRestart(restart)
[13:21:40.991]                             muffled <- TRUE
[13:21:40.991]                             break
[13:21:40.991]                           }
[13:21:40.991]                         }
[13:21:40.991]                       }
[13:21:40.991]                       invisible(muffled)
[13:21:40.991]                     }
[13:21:40.991]                     muffleCondition(cond, pattern = "^muffle")
[13:21:40.991]                   }
[13:21:40.991]                 }
[13:21:40.991]                 else {
[13:21:40.991]                   if (TRUE) {
[13:21:40.991]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.991]                     {
[13:21:40.991]                       inherits <- base::inherits
[13:21:40.991]                       invokeRestart <- base::invokeRestart
[13:21:40.991]                       is.null <- base::is.null
[13:21:40.991]                       muffled <- FALSE
[13:21:40.991]                       if (inherits(cond, "message")) {
[13:21:40.991]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:40.991]                         if (muffled) 
[13:21:40.991]                           invokeRestart("muffleMessage")
[13:21:40.991]                       }
[13:21:40.991]                       else if (inherits(cond, "warning")) {
[13:21:40.991]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:40.991]                         if (muffled) 
[13:21:40.991]                           invokeRestart("muffleWarning")
[13:21:40.991]                       }
[13:21:40.991]                       else if (inherits(cond, "condition")) {
[13:21:40.991]                         if (!is.null(pattern)) {
[13:21:40.991]                           computeRestarts <- base::computeRestarts
[13:21:40.991]                           grepl <- base::grepl
[13:21:40.991]                           restarts <- computeRestarts(cond)
[13:21:40.991]                           for (restart in restarts) {
[13:21:40.991]                             name <- restart$name
[13:21:40.991]                             if (is.null(name)) 
[13:21:40.991]                               next
[13:21:40.991]                             if (!grepl(pattern, name)) 
[13:21:40.991]                               next
[13:21:40.991]                             invokeRestart(restart)
[13:21:40.991]                             muffled <- TRUE
[13:21:40.991]                             break
[13:21:40.991]                           }
[13:21:40.991]                         }
[13:21:40.991]                       }
[13:21:40.991]                       invisible(muffled)
[13:21:40.991]                     }
[13:21:40.991]                     muffleCondition(cond, pattern = "^muffle")
[13:21:40.991]                   }
[13:21:40.991]                 }
[13:21:40.991]             }
[13:21:40.991]         }))
[13:21:40.991]     }, error = function(ex) {
[13:21:40.991]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:40.991]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:40.991]                 ...future.rng), started = ...future.startTime, 
[13:21:40.991]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:40.991]             version = "1.8"), class = "FutureResult")
[13:21:40.991]     }, finally = {
[13:21:40.991]         if (!identical(...future.workdir, getwd())) 
[13:21:40.991]             setwd(...future.workdir)
[13:21:40.991]         {
[13:21:40.991]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:40.991]                 ...future.oldOptions$nwarnings <- NULL
[13:21:40.991]             }
[13:21:40.991]             base::options(...future.oldOptions)
[13:21:40.991]             if (.Platform$OS.type == "windows") {
[13:21:40.991]                 old_names <- names(...future.oldEnvVars)
[13:21:40.991]                 envs <- base::Sys.getenv()
[13:21:40.991]                 names <- names(envs)
[13:21:40.991]                 common <- intersect(names, old_names)
[13:21:40.991]                 added <- setdiff(names, old_names)
[13:21:40.991]                 removed <- setdiff(old_names, names)
[13:21:40.991]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:40.991]                   envs[common]]
[13:21:40.991]                 NAMES <- toupper(changed)
[13:21:40.991]                 args <- list()
[13:21:40.991]                 for (kk in seq_along(NAMES)) {
[13:21:40.991]                   name <- changed[[kk]]
[13:21:40.991]                   NAME <- NAMES[[kk]]
[13:21:40.991]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.991]                     next
[13:21:40.991]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:40.991]                 }
[13:21:40.991]                 NAMES <- toupper(added)
[13:21:40.991]                 for (kk in seq_along(NAMES)) {
[13:21:40.991]                   name <- added[[kk]]
[13:21:40.991]                   NAME <- NAMES[[kk]]
[13:21:40.991]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.991]                     next
[13:21:40.991]                   args[[name]] <- ""
[13:21:40.991]                 }
[13:21:40.991]                 NAMES <- toupper(removed)
[13:21:40.991]                 for (kk in seq_along(NAMES)) {
[13:21:40.991]                   name <- removed[[kk]]
[13:21:40.991]                   NAME <- NAMES[[kk]]
[13:21:40.991]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.991]                     next
[13:21:40.991]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:40.991]                 }
[13:21:40.991]                 if (length(args) > 0) 
[13:21:40.991]                   base::do.call(base::Sys.setenv, args = args)
[13:21:40.991]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:40.991]             }
[13:21:40.991]             else {
[13:21:40.991]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:40.991]             }
[13:21:40.991]             {
[13:21:40.991]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:40.991]                   0L) {
[13:21:40.991]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:40.991]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:40.991]                   base::options(opts)
[13:21:40.991]                 }
[13:21:40.991]                 {
[13:21:40.991]                   {
[13:21:40.991]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:40.991]                     NULL
[13:21:40.991]                   }
[13:21:40.991]                   options(future.plan = NULL)
[13:21:40.991]                   if (is.na(NA_character_)) 
[13:21:40.991]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:40.991]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:40.991]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:40.991]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:40.991]                     envir = parent.frame()) 
[13:21:40.991]                   {
[13:21:40.991]                     if (is.function(workers)) 
[13:21:40.991]                       workers <- workers()
[13:21:40.991]                     workers <- structure(as.integer(workers), 
[13:21:40.991]                       class = class(workers))
[13:21:40.991]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:40.991]                       workers >= 1)
[13:21:40.991]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:40.991]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:40.991]                     }
[13:21:40.991]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:40.991]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:40.991]                       envir = envir)
[13:21:40.991]                     if (!future$lazy) 
[13:21:40.991]                       future <- run(future)
[13:21:40.991]                     invisible(future)
[13:21:40.991]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:40.991]                 }
[13:21:40.991]             }
[13:21:40.991]         }
[13:21:40.991]     })
[13:21:40.991]     if (TRUE) {
[13:21:40.991]         base::sink(type = "output", split = FALSE)
[13:21:40.991]         if (TRUE) {
[13:21:40.991]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:40.991]         }
[13:21:40.991]         else {
[13:21:40.991]             ...future.result["stdout"] <- base::list(NULL)
[13:21:40.991]         }
[13:21:40.991]         base::close(...future.stdout)
[13:21:40.991]         ...future.stdout <- NULL
[13:21:40.991]     }
[13:21:40.991]     ...future.result$conditions <- ...future.conditions
[13:21:40.991]     ...future.result$finished <- base::Sys.time()
[13:21:40.991]     ...future.result
[13:21:40.991] }
[13:21:40.994] Exporting 5 global objects (4.16 KiB) to cluster node #2 ...
[13:21:40.994] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #2 ...
[13:21:40.994] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #2 ... DONE
[13:21:40.995] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ...
[13:21:40.995] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ... DONE
[13:21:40.995] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[13:21:40.996] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[13:21:40.996] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:21:40.996] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:21:40.996] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:21:40.996] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:21:40.997] Exporting 5 global objects (4.16 KiB) to cluster node #2 ... DONE
[13:21:40.997] MultisessionFuture started
[13:21:40.997] - Launch lazy future ... done
[13:21:40.997] run() for ‘MultisessionFuture’ ... done
[13:21:40.997] Created future:
[13:21:40.997] MultisessionFuture:
[13:21:40.997] Label: ‘future_sapply-2’
[13:21:40.997] Expression:
[13:21:40.997] {
[13:21:40.997]     do.call(function(...) {
[13:21:40.997]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:40.997]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:40.997]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:40.997]             on.exit(options(oopts), add = TRUE)
[13:21:40.997]         }
[13:21:40.997]         {
[13:21:40.997]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:40.997]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:40.997]                 ...future.FUN(...future.X_jj, ...)
[13:21:40.997]             })
[13:21:40.997]         }
[13:21:40.997]     }, args = future.call.arguments)
[13:21:40.997] }
[13:21:40.997] Lazy evaluation: FALSE
[13:21:40.997] Asynchronous evaluation: TRUE
[13:21:40.997] Local evaluation: TRUE
[13:21:40.997] Environment: R_GlobalEnv
[13:21:40.997] Capture standard output: TRUE
[13:21:40.997] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:40.997] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:21:40.997] Packages: <none>
[13:21:40.997] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:40.997] Resolved: FALSE
[13:21:40.997] Value: <not collected>
[13:21:40.997] Conditions captured: <none>
[13:21:40.997] Early signaling: FALSE
[13:21:40.997] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:40.997] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:41.009] Chunk #2 of 2 ... DONE
[13:21:41.009] Launching 2 futures (chunks) ... DONE
[13:21:41.009] Resolving 2 futures (chunks) ...
[13:21:41.010] resolve() on list ...
[13:21:41.010]  recursive: 0
[13:21:41.010]  length: 2
[13:21:41.010] 
[13:21:41.010] receiveMessageFromWorker() for ClusterFuture ...
[13:21:41.010] - Validating connection of MultisessionFuture
[13:21:41.011] - received message: FutureResult
[13:21:41.011] - Received FutureResult
[13:21:41.011] - Erased future from FutureRegistry
[13:21:41.011] result() for ClusterFuture ...
[13:21:41.011] - result already collected: FutureResult
[13:21:41.011] result() for ClusterFuture ... done
[13:21:41.011] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:41.011] Future #1
[13:21:41.011] result() for ClusterFuture ...
[13:21:41.012] - result already collected: FutureResult
[13:21:41.012] result() for ClusterFuture ... done
[13:21:41.012] result() for ClusterFuture ...
[13:21:41.012] - result already collected: FutureResult
[13:21:41.012] result() for ClusterFuture ... done
[13:21:41.012] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:21:41.012] - nx: 2
[13:21:41.012] - relay: TRUE
[13:21:41.012] - stdout: TRUE
[13:21:41.012] - signal: TRUE
[13:21:41.013] - resignal: FALSE
[13:21:41.013] - force: TRUE
[13:21:41.013] - relayed: [n=2] FALSE, FALSE
[13:21:41.013] - queued futures: [n=2] FALSE, FALSE
[13:21:41.013]  - until=1
[13:21:41.013]  - relaying element #1
[13:21:41.013] result() for ClusterFuture ...
[13:21:41.013] - result already collected: FutureResult
[13:21:41.013] result() for ClusterFuture ... done
[13:21:41.013] result() for ClusterFuture ...
[13:21:41.013] - result already collected: FutureResult
[13:21:41.013] result() for ClusterFuture ... done
[13:21:41.014] result() for ClusterFuture ...
[13:21:41.014] - result already collected: FutureResult
[13:21:41.014] result() for ClusterFuture ... done
[13:21:41.014] result() for ClusterFuture ...
[13:21:41.014] - result already collected: FutureResult
[13:21:41.014] result() for ClusterFuture ... done
[13:21:41.014] - relayed: [n=2] TRUE, FALSE
[13:21:41.014] - queued futures: [n=2] TRUE, FALSE
[13:21:41.014] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:21:41.014]  length: 1 (resolved future 1)
[13:21:41.045] receiveMessageFromWorker() for ClusterFuture ...
[13:21:41.046] - Validating connection of MultisessionFuture
[13:21:41.046] - received message: FutureResult
[13:21:41.046] - Received FutureResult
[13:21:41.046] - Erased future from FutureRegistry
[13:21:41.046] result() for ClusterFuture ...
[13:21:41.047] - result already collected: FutureResult
[13:21:41.047] result() for ClusterFuture ... done
[13:21:41.047] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:41.047] Future #2
[13:21:41.047] result() for ClusterFuture ...
[13:21:41.047] - result already collected: FutureResult
[13:21:41.047] result() for ClusterFuture ... done
[13:21:41.047] result() for ClusterFuture ...
[13:21:41.047] - result already collected: FutureResult
[13:21:41.047] result() for ClusterFuture ... done
[13:21:41.048] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:21:41.048] - nx: 2
[13:21:41.048] - relay: TRUE
[13:21:41.048] - stdout: TRUE
[13:21:41.048] - signal: TRUE
[13:21:41.048] - resignal: FALSE
[13:21:41.048] - force: TRUE
[13:21:41.048] - relayed: [n=2] TRUE, FALSE
[13:21:41.048] - queued futures: [n=2] TRUE, FALSE
[13:21:41.048]  - until=2
[13:21:41.049]  - relaying element #2
[13:21:41.049] result() for ClusterFuture ...
[13:21:41.049] - result already collected: FutureResult
[13:21:41.049] result() for ClusterFuture ... done
[13:21:41.049] result() for ClusterFuture ...
[13:21:41.049] - result already collected: FutureResult
[13:21:41.049] result() for ClusterFuture ... done
[13:21:41.049] result() for ClusterFuture ...
[13:21:41.049] - result already collected: FutureResult
[13:21:41.049] result() for ClusterFuture ... done
[13:21:41.049] result() for ClusterFuture ...
[13:21:41.050] - result already collected: FutureResult
[13:21:41.050] result() for ClusterFuture ... done
[13:21:41.050] - relayed: [n=2] TRUE, TRUE
[13:21:41.050] - queued futures: [n=2] TRUE, TRUE
[13:21:41.050] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:21:41.050]  length: 0 (resolved future 2)
[13:21:41.050] Relaying remaining futures
[13:21:41.050] signalConditionsASAP(NULL, pos=0) ...
[13:21:41.050] - nx: 2
[13:21:41.050] - relay: TRUE
[13:21:41.050] - stdout: TRUE
[13:21:41.051] - signal: TRUE
[13:21:41.051] - resignal: FALSE
[13:21:41.051] - force: TRUE
[13:21:41.051] - relayed: [n=2] TRUE, TRUE
[13:21:41.051] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:21:41.051] - relayed: [n=2] TRUE, TRUE
[13:21:41.051] - queued futures: [n=2] TRUE, TRUE
[13:21:41.051] signalConditionsASAP(NULL, pos=0) ... done
[13:21:41.051] resolve() on list ... DONE
[13:21:41.051] result() for ClusterFuture ...
[13:21:41.051] - result already collected: FutureResult
[13:21:41.052] result() for ClusterFuture ... done
[13:21:41.052] result() for ClusterFuture ...
[13:21:41.052] - result already collected: FutureResult
[13:21:41.052] result() for ClusterFuture ... done
[13:21:41.052] result() for ClusterFuture ...
[13:21:41.052] - result already collected: FutureResult
[13:21:41.052] result() for ClusterFuture ... done
[13:21:41.052] result() for ClusterFuture ...
[13:21:41.052] - result already collected: FutureResult
[13:21:41.052] result() for ClusterFuture ... done
[13:21:41.053]  - Number of value chunks collected: 2
[13:21:41.053] Resolving 2 futures (chunks) ... DONE
[13:21:41.053] Reducing values from 2 chunks ...
[13:21:41.053]  - Number of values collected after concatenation: 4
[13:21:41.053]  - Number of values expected: 4
[13:21:41.053] Reducing values from 2 chunks ... DONE
[13:21:41.053] future_lapply() ... DONE
[13:21:41.054] future_lapply() ...
[13:21:41.059] Number of chunks: 2
[13:21:41.059] getGlobalsAndPackagesXApply() ...
[13:21:41.059]  - future.globals: TRUE
[13:21:41.059] getGlobalsAndPackages() ...
[13:21:41.060] Searching for globals...
[13:21:41.063] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[13:21:41.063] Searching for globals ... DONE
[13:21:41.063] Resolving globals: FALSE
[13:21:41.064] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[13:21:41.067] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:41.068] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:41.068] - packages: [1] ‘future.apply’
[13:21:41.068] getGlobalsAndPackages() ... DONE
[13:21:41.068]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:41.068]  - needed namespaces: [n=1] ‘future.apply’
[13:21:41.068] Finding globals ... DONE
[13:21:41.068]  - use_args: TRUE
[13:21:41.068]  - Getting '...' globals ...
[13:21:41.069] resolve() on list ...
[13:21:41.069]  recursive: 0
[13:21:41.069]  length: 1
[13:21:41.069]  elements: ‘...’
[13:21:41.069]  length: 0 (resolved future 1)
[13:21:41.069] resolve() on list ... DONE
[13:21:41.069]    - '...' content: [n=1] ‘y’
[13:21:41.069] List of 1
[13:21:41.069]  $ ...:List of 1
[13:21:41.069]   ..$ y: num [1:5] 2 4 6 8 10
[13:21:41.069]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:41.069]  - attr(*, "where")=List of 1
[13:21:41.069]   ..$ ...:<environment: 0x563b716eae20> 
[13:21:41.069]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:41.069]  - attr(*, "resolved")= logi TRUE
[13:21:41.069]  - attr(*, "total_size")= num NA
[13:21:41.072]  - Getting '...' globals ... DONE
[13:21:41.072] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:41.073] List of 8
[13:21:41.073]  $ ...future.FUN:function (x, ...)  
[13:21:41.073]  $ x_FUN        :function (x, y)  
[13:21:41.073]  $ times        : int 15
[13:21:41.073]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:41.073]  $ stop_if_not  :function (...)  
[13:21:41.073]  $ dim          : int [1:2] 3 5
[13:21:41.073]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:21:41.073]  $ ...          :List of 1
[13:21:41.073]   ..$ y: num [1:5] 2 4 6 8 10
[13:21:41.073]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:41.073]  - attr(*, "where")=List of 8
[13:21:41.073]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:41.073]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:41.073]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:41.073]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:41.073]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:41.073]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:41.073]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:41.073]   ..$ ...          :<environment: 0x563b716eae20> 
[13:21:41.073]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:41.073]  - attr(*, "resolved")= logi FALSE
[13:21:41.073]  - attr(*, "total_size")= num 98600
[13:21:41.078] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:21:41.079] getGlobalsAndPackagesXApply() ... DONE
[13:21:41.079] Number of futures (= number of chunks): 2
[13:21:41.079] Launching 2 futures (chunks) ...
[13:21:41.079] Chunk #1 of 2 ...
[13:21:41.079]  - Finding globals in 'X' for chunk #1 ...
[13:21:41.079] getGlobalsAndPackages() ...
[13:21:41.079] Searching for globals...
[13:21:41.080] 
[13:21:41.080] Searching for globals ... DONE
[13:21:41.080] - globals: [0] <none>
[13:21:41.080] getGlobalsAndPackages() ... DONE
[13:21:41.080]    + additional globals found: [n=0] 
[13:21:41.080]    + additional namespaces needed: [n=0] 
[13:21:41.080]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:41.080]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:41.080]  - seeds: <none>
[13:21:41.081]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:41.081] getGlobalsAndPackages() ...
[13:21:41.081] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:41.081] Resolving globals: FALSE
[13:21:41.081] Tweak future expression to call with '...' arguments ...
[13:21:41.081] {
[13:21:41.081]     do.call(function(...) {
[13:21:41.081]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:41.081]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:41.081]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:41.081]             on.exit(options(oopts), add = TRUE)
[13:21:41.081]         }
[13:21:41.081]         {
[13:21:41.081]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:41.081]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:41.081]                 ...future.FUN(...future.X_jj, ...)
[13:21:41.081]             })
[13:21:41.081]         }
[13:21:41.081]     }, args = future.call.arguments)
[13:21:41.081] }
[13:21:41.081] Tweak future expression to call with '...' arguments ... DONE
[13:21:41.082] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:41.082] - packages: [1] ‘future.apply’
[13:21:41.082] getGlobalsAndPackages() ... DONE
[13:21:41.082] run() for ‘Future’ ...
[13:21:41.083] - state: ‘created’
[13:21:41.083] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:41.102] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:41.103] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:41.103]   - Field: ‘node’
[13:21:41.103]   - Field: ‘label’
[13:21:41.103]   - Field: ‘local’
[13:21:41.103]   - Field: ‘owner’
[13:21:41.103]   - Field: ‘envir’
[13:21:41.103]   - Field: ‘workers’
[13:21:41.103]   - Field: ‘packages’
[13:21:41.103]   - Field: ‘gc’
[13:21:41.104]   - Field: ‘conditions’
[13:21:41.104]   - Field: ‘persistent’
[13:21:41.104]   - Field: ‘expr’
[13:21:41.104]   - Field: ‘uuid’
[13:21:41.104]   - Field: ‘seed’
[13:21:41.104]   - Field: ‘version’
[13:21:41.104]   - Field: ‘result’
[13:21:41.104]   - Field: ‘asynchronous’
[13:21:41.104]   - Field: ‘calls’
[13:21:41.104]   - Field: ‘globals’
[13:21:41.105]   - Field: ‘stdout’
[13:21:41.105]   - Field: ‘earlySignal’
[13:21:41.105]   - Field: ‘lazy’
[13:21:41.105]   - Field: ‘state’
[13:21:41.105] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:41.105] - Launch lazy future ...
[13:21:41.105] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:41.106] Packages needed by future strategies (n = 0): <none>
[13:21:41.106] {
[13:21:41.106]     {
[13:21:41.106]         {
[13:21:41.106]             ...future.startTime <- base::Sys.time()
[13:21:41.106]             {
[13:21:41.106]                 {
[13:21:41.106]                   {
[13:21:41.106]                     {
[13:21:41.106]                       {
[13:21:41.106]                         base::local({
[13:21:41.106]                           has_future <- base::requireNamespace("future", 
[13:21:41.106]                             quietly = TRUE)
[13:21:41.106]                           if (has_future) {
[13:21:41.106]                             ns <- base::getNamespace("future")
[13:21:41.106]                             version <- ns[[".package"]][["version"]]
[13:21:41.106]                             if (is.null(version)) 
[13:21:41.106]                               version <- utils::packageVersion("future")
[13:21:41.106]                           }
[13:21:41.106]                           else {
[13:21:41.106]                             version <- NULL
[13:21:41.106]                           }
[13:21:41.106]                           if (!has_future || version < "1.8.0") {
[13:21:41.106]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:41.106]                               "", base::R.version$version.string), 
[13:21:41.106]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:41.106]                                 base::R.version$platform, 8 * 
[13:21:41.106]                                   base::.Machine$sizeof.pointer), 
[13:21:41.106]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:41.106]                                 "release", "version")], collapse = " "), 
[13:21:41.106]                               hostname = base::Sys.info()[["nodename"]])
[13:21:41.106]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:41.106]                               info)
[13:21:41.106]                             info <- base::paste(info, collapse = "; ")
[13:21:41.106]                             if (!has_future) {
[13:21:41.106]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:41.106]                                 info)
[13:21:41.106]                             }
[13:21:41.106]                             else {
[13:21:41.106]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:41.106]                                 info, version)
[13:21:41.106]                             }
[13:21:41.106]                             base::stop(msg)
[13:21:41.106]                           }
[13:21:41.106]                         })
[13:21:41.106]                       }
[13:21:41.106]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:41.106]                       base::options(mc.cores = 1L)
[13:21:41.106]                     }
[13:21:41.106]                     base::local({
[13:21:41.106]                       for (pkg in "future.apply") {
[13:21:41.106]                         base::loadNamespace(pkg)
[13:21:41.106]                         base::library(pkg, character.only = TRUE)
[13:21:41.106]                       }
[13:21:41.106]                     })
[13:21:41.106]                   }
[13:21:41.106]                   options(future.plan = NULL)
[13:21:41.106]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.106]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:41.106]                 }
[13:21:41.106]                 ...future.workdir <- getwd()
[13:21:41.106]             }
[13:21:41.106]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:41.106]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:41.106]         }
[13:21:41.106]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:41.106]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:41.106]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:41.106]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:41.106]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:41.106]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:41.106]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:41.106]             base::names(...future.oldOptions))
[13:21:41.106]     }
[13:21:41.106]     if (FALSE) {
[13:21:41.106]     }
[13:21:41.106]     else {
[13:21:41.106]         if (TRUE) {
[13:21:41.106]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:41.106]                 open = "w")
[13:21:41.106]         }
[13:21:41.106]         else {
[13:21:41.106]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:41.106]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:41.106]         }
[13:21:41.106]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:41.106]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:41.106]             base::sink(type = "output", split = FALSE)
[13:21:41.106]             base::close(...future.stdout)
[13:21:41.106]         }, add = TRUE)
[13:21:41.106]     }
[13:21:41.106]     ...future.frame <- base::sys.nframe()
[13:21:41.106]     ...future.conditions <- base::list()
[13:21:41.106]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:41.106]     if (FALSE) {
[13:21:41.106]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:41.106]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:41.106]     }
[13:21:41.106]     ...future.result <- base::tryCatch({
[13:21:41.106]         base::withCallingHandlers({
[13:21:41.106]             ...future.value <- base::withVisible(base::local({
[13:21:41.106]                 ...future.makeSendCondition <- base::local({
[13:21:41.106]                   sendCondition <- NULL
[13:21:41.106]                   function(frame = 1L) {
[13:21:41.106]                     if (is.function(sendCondition)) 
[13:21:41.106]                       return(sendCondition)
[13:21:41.106]                     ns <- getNamespace("parallel")
[13:21:41.106]                     if (exists("sendData", mode = "function", 
[13:21:41.106]                       envir = ns)) {
[13:21:41.106]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:41.106]                         envir = ns)
[13:21:41.106]                       envir <- sys.frame(frame)
[13:21:41.106]                       master <- NULL
[13:21:41.106]                       while (!identical(envir, .GlobalEnv) && 
[13:21:41.106]                         !identical(envir, emptyenv())) {
[13:21:41.106]                         if (exists("master", mode = "list", envir = envir, 
[13:21:41.106]                           inherits = FALSE)) {
[13:21:41.106]                           master <- get("master", mode = "list", 
[13:21:41.106]                             envir = envir, inherits = FALSE)
[13:21:41.106]                           if (inherits(master, c("SOCKnode", 
[13:21:41.106]                             "SOCK0node"))) {
[13:21:41.106]                             sendCondition <<- function(cond) {
[13:21:41.106]                               data <- list(type = "VALUE", value = cond, 
[13:21:41.106]                                 success = TRUE)
[13:21:41.106]                               parallel_sendData(master, data)
[13:21:41.106]                             }
[13:21:41.106]                             return(sendCondition)
[13:21:41.106]                           }
[13:21:41.106]                         }
[13:21:41.106]                         frame <- frame + 1L
[13:21:41.106]                         envir <- sys.frame(frame)
[13:21:41.106]                       }
[13:21:41.106]                     }
[13:21:41.106]                     sendCondition <<- function(cond) NULL
[13:21:41.106]                   }
[13:21:41.106]                 })
[13:21:41.106]                 withCallingHandlers({
[13:21:41.106]                   {
[13:21:41.106]                     do.call(function(...) {
[13:21:41.106]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:41.106]                       if (!identical(...future.globals.maxSize.org, 
[13:21:41.106]                         ...future.globals.maxSize)) {
[13:21:41.106]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:41.106]                         on.exit(options(oopts), add = TRUE)
[13:21:41.106]                       }
[13:21:41.106]                       {
[13:21:41.106]                         lapply(seq_along(...future.elements_ii), 
[13:21:41.106]                           FUN = function(jj) {
[13:21:41.106]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:41.106]                             ...future.FUN(...future.X_jj, ...)
[13:21:41.106]                           })
[13:21:41.106]                       }
[13:21:41.106]                     }, args = future.call.arguments)
[13:21:41.106]                   }
[13:21:41.106]                 }, immediateCondition = function(cond) {
[13:21:41.106]                   sendCondition <- ...future.makeSendCondition()
[13:21:41.106]                   sendCondition(cond)
[13:21:41.106]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.106]                   {
[13:21:41.106]                     inherits <- base::inherits
[13:21:41.106]                     invokeRestart <- base::invokeRestart
[13:21:41.106]                     is.null <- base::is.null
[13:21:41.106]                     muffled <- FALSE
[13:21:41.106]                     if (inherits(cond, "message")) {
[13:21:41.106]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:41.106]                       if (muffled) 
[13:21:41.106]                         invokeRestart("muffleMessage")
[13:21:41.106]                     }
[13:21:41.106]                     else if (inherits(cond, "warning")) {
[13:21:41.106]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:41.106]                       if (muffled) 
[13:21:41.106]                         invokeRestart("muffleWarning")
[13:21:41.106]                     }
[13:21:41.106]                     else if (inherits(cond, "condition")) {
[13:21:41.106]                       if (!is.null(pattern)) {
[13:21:41.106]                         computeRestarts <- base::computeRestarts
[13:21:41.106]                         grepl <- base::grepl
[13:21:41.106]                         restarts <- computeRestarts(cond)
[13:21:41.106]                         for (restart in restarts) {
[13:21:41.106]                           name <- restart$name
[13:21:41.106]                           if (is.null(name)) 
[13:21:41.106]                             next
[13:21:41.106]                           if (!grepl(pattern, name)) 
[13:21:41.106]                             next
[13:21:41.106]                           invokeRestart(restart)
[13:21:41.106]                           muffled <- TRUE
[13:21:41.106]                           break
[13:21:41.106]                         }
[13:21:41.106]                       }
[13:21:41.106]                     }
[13:21:41.106]                     invisible(muffled)
[13:21:41.106]                   }
[13:21:41.106]                   muffleCondition(cond)
[13:21:41.106]                 })
[13:21:41.106]             }))
[13:21:41.106]             future::FutureResult(value = ...future.value$value, 
[13:21:41.106]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.106]                   ...future.rng), globalenv = if (FALSE) 
[13:21:41.106]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:41.106]                     ...future.globalenv.names))
[13:21:41.106]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:41.106]         }, condition = base::local({
[13:21:41.106]             c <- base::c
[13:21:41.106]             inherits <- base::inherits
[13:21:41.106]             invokeRestart <- base::invokeRestart
[13:21:41.106]             length <- base::length
[13:21:41.106]             list <- base::list
[13:21:41.106]             seq.int <- base::seq.int
[13:21:41.106]             signalCondition <- base::signalCondition
[13:21:41.106]             sys.calls <- base::sys.calls
[13:21:41.106]             `[[` <- base::`[[`
[13:21:41.106]             `+` <- base::`+`
[13:21:41.106]             `<<-` <- base::`<<-`
[13:21:41.106]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:41.106]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:41.106]                   3L)]
[13:21:41.106]             }
[13:21:41.106]             function(cond) {
[13:21:41.106]                 is_error <- inherits(cond, "error")
[13:21:41.106]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:41.106]                   NULL)
[13:21:41.106]                 if (is_error) {
[13:21:41.106]                   sessionInformation <- function() {
[13:21:41.106]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:41.106]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:41.106]                       search = base::search(), system = base::Sys.info())
[13:21:41.106]                   }
[13:21:41.106]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.106]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:41.106]                     cond$call), session = sessionInformation(), 
[13:21:41.106]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:41.106]                   signalCondition(cond)
[13:21:41.106]                 }
[13:21:41.106]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:41.106]                 "immediateCondition"))) {
[13:21:41.106]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:41.106]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.106]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:41.106]                   if (TRUE && !signal) {
[13:21:41.106]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.106]                     {
[13:21:41.106]                       inherits <- base::inherits
[13:21:41.106]                       invokeRestart <- base::invokeRestart
[13:21:41.106]                       is.null <- base::is.null
[13:21:41.106]                       muffled <- FALSE
[13:21:41.106]                       if (inherits(cond, "message")) {
[13:21:41.106]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.106]                         if (muffled) 
[13:21:41.106]                           invokeRestart("muffleMessage")
[13:21:41.106]                       }
[13:21:41.106]                       else if (inherits(cond, "warning")) {
[13:21:41.106]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.106]                         if (muffled) 
[13:21:41.106]                           invokeRestart("muffleWarning")
[13:21:41.106]                       }
[13:21:41.106]                       else if (inherits(cond, "condition")) {
[13:21:41.106]                         if (!is.null(pattern)) {
[13:21:41.106]                           computeRestarts <- base::computeRestarts
[13:21:41.106]                           grepl <- base::grepl
[13:21:41.106]                           restarts <- computeRestarts(cond)
[13:21:41.106]                           for (restart in restarts) {
[13:21:41.106]                             name <- restart$name
[13:21:41.106]                             if (is.null(name)) 
[13:21:41.106]                               next
[13:21:41.106]                             if (!grepl(pattern, name)) 
[13:21:41.106]                               next
[13:21:41.106]                             invokeRestart(restart)
[13:21:41.106]                             muffled <- TRUE
[13:21:41.106]                             break
[13:21:41.106]                           }
[13:21:41.106]                         }
[13:21:41.106]                       }
[13:21:41.106]                       invisible(muffled)
[13:21:41.106]                     }
[13:21:41.106]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.106]                   }
[13:21:41.106]                 }
[13:21:41.106]                 else {
[13:21:41.106]                   if (TRUE) {
[13:21:41.106]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.106]                     {
[13:21:41.106]                       inherits <- base::inherits
[13:21:41.106]                       invokeRestart <- base::invokeRestart
[13:21:41.106]                       is.null <- base::is.null
[13:21:41.106]                       muffled <- FALSE
[13:21:41.106]                       if (inherits(cond, "message")) {
[13:21:41.106]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.106]                         if (muffled) 
[13:21:41.106]                           invokeRestart("muffleMessage")
[13:21:41.106]                       }
[13:21:41.106]                       else if (inherits(cond, "warning")) {
[13:21:41.106]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.106]                         if (muffled) 
[13:21:41.106]                           invokeRestart("muffleWarning")
[13:21:41.106]                       }
[13:21:41.106]                       else if (inherits(cond, "condition")) {
[13:21:41.106]                         if (!is.null(pattern)) {
[13:21:41.106]                           computeRestarts <- base::computeRestarts
[13:21:41.106]                           grepl <- base::grepl
[13:21:41.106]                           restarts <- computeRestarts(cond)
[13:21:41.106]                           for (restart in restarts) {
[13:21:41.106]                             name <- restart$name
[13:21:41.106]                             if (is.null(name)) 
[13:21:41.106]                               next
[13:21:41.106]                             if (!grepl(pattern, name)) 
[13:21:41.106]                               next
[13:21:41.106]                             invokeRestart(restart)
[13:21:41.106]                             muffled <- TRUE
[13:21:41.106]                             break
[13:21:41.106]                           }
[13:21:41.106]                         }
[13:21:41.106]                       }
[13:21:41.106]                       invisible(muffled)
[13:21:41.106]                     }
[13:21:41.106]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.106]                   }
[13:21:41.106]                 }
[13:21:41.106]             }
[13:21:41.106]         }))
[13:21:41.106]     }, error = function(ex) {
[13:21:41.106]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:41.106]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.106]                 ...future.rng), started = ...future.startTime, 
[13:21:41.106]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:41.106]             version = "1.8"), class = "FutureResult")
[13:21:41.106]     }, finally = {
[13:21:41.106]         if (!identical(...future.workdir, getwd())) 
[13:21:41.106]             setwd(...future.workdir)
[13:21:41.106]         {
[13:21:41.106]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:41.106]                 ...future.oldOptions$nwarnings <- NULL
[13:21:41.106]             }
[13:21:41.106]             base::options(...future.oldOptions)
[13:21:41.106]             if (.Platform$OS.type == "windows") {
[13:21:41.106]                 old_names <- names(...future.oldEnvVars)
[13:21:41.106]                 envs <- base::Sys.getenv()
[13:21:41.106]                 names <- names(envs)
[13:21:41.106]                 common <- intersect(names, old_names)
[13:21:41.106]                 added <- setdiff(names, old_names)
[13:21:41.106]                 removed <- setdiff(old_names, names)
[13:21:41.106]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:41.106]                   envs[common]]
[13:21:41.106]                 NAMES <- toupper(changed)
[13:21:41.106]                 args <- list()
[13:21:41.106]                 for (kk in seq_along(NAMES)) {
[13:21:41.106]                   name <- changed[[kk]]
[13:21:41.106]                   NAME <- NAMES[[kk]]
[13:21:41.106]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.106]                     next
[13:21:41.106]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.106]                 }
[13:21:41.106]                 NAMES <- toupper(added)
[13:21:41.106]                 for (kk in seq_along(NAMES)) {
[13:21:41.106]                   name <- added[[kk]]
[13:21:41.106]                   NAME <- NAMES[[kk]]
[13:21:41.106]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.106]                     next
[13:21:41.106]                   args[[name]] <- ""
[13:21:41.106]                 }
[13:21:41.106]                 NAMES <- toupper(removed)
[13:21:41.106]                 for (kk in seq_along(NAMES)) {
[13:21:41.106]                   name <- removed[[kk]]
[13:21:41.106]                   NAME <- NAMES[[kk]]
[13:21:41.106]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.106]                     next
[13:21:41.106]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.106]                 }
[13:21:41.106]                 if (length(args) > 0) 
[13:21:41.106]                   base::do.call(base::Sys.setenv, args = args)
[13:21:41.106]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:41.106]             }
[13:21:41.106]             else {
[13:21:41.106]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:41.106]             }
[13:21:41.106]             {
[13:21:41.106]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:41.106]                   0L) {
[13:21:41.106]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:41.106]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:41.106]                   base::options(opts)
[13:21:41.106]                 }
[13:21:41.106]                 {
[13:21:41.106]                   {
[13:21:41.106]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:41.106]                     NULL
[13:21:41.106]                   }
[13:21:41.106]                   options(future.plan = NULL)
[13:21:41.106]                   if (is.na(NA_character_)) 
[13:21:41.106]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.106]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:41.106]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:41.106]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:41.106]                     envir = parent.frame()) 
[13:21:41.106]                   {
[13:21:41.106]                     if (is.function(workers)) 
[13:21:41.106]                       workers <- workers()
[13:21:41.106]                     workers <- structure(as.integer(workers), 
[13:21:41.106]                       class = class(workers))
[13:21:41.106]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:41.106]                       workers >= 1)
[13:21:41.106]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:41.106]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:41.106]                     }
[13:21:41.106]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:41.106]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:41.106]                       envir = envir)
[13:21:41.106]                     if (!future$lazy) 
[13:21:41.106]                       future <- run(future)
[13:21:41.106]                     invisible(future)
[13:21:41.106]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:41.106]                 }
[13:21:41.106]             }
[13:21:41.106]         }
[13:21:41.106]     })
[13:21:41.106]     if (TRUE) {
[13:21:41.106]         base::sink(type = "output", split = FALSE)
[13:21:41.106]         if (TRUE) {
[13:21:41.106]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:41.106]         }
[13:21:41.106]         else {
[13:21:41.106]             ...future.result["stdout"] <- base::list(NULL)
[13:21:41.106]         }
[13:21:41.106]         base::close(...future.stdout)
[13:21:41.106]         ...future.stdout <- NULL
[13:21:41.106]     }
[13:21:41.106]     ...future.result$conditions <- ...future.conditions
[13:21:41.106]     ...future.result$finished <- base::Sys.time()
[13:21:41.106]     ...future.result
[13:21:41.106] }
[13:21:41.109] Exporting 11 global objects (96.29 KiB) to cluster node #1 ...
[13:21:41.109] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:21:41.152] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:21:41.153] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #1 ...
[13:21:41.153] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #1 ... DONE
[13:21:41.153] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:21:41.153] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:21:41.154] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:21:41.196] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:21:41.196] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:21:41.240] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:21:41.240] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[13:21:41.241] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[13:21:41.241] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[13:21:41.241] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[13:21:41.242] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ...
[13:21:41.242] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ... DONE
[13:21:41.242] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[13:21:41.242] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[13:21:41.242] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:21:41.243] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:21:41.243] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:21:41.243] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:21:41.243] Exporting 11 global objects (96.29 KiB) to cluster node #1 ... DONE
[13:21:41.244] MultisessionFuture started
[13:21:41.244] - Launch lazy future ... done
[13:21:41.244] run() for ‘MultisessionFuture’ ... done
[13:21:41.244] Created future:
[13:21:41.244] MultisessionFuture:
[13:21:41.244] Label: ‘future_vapply-1’
[13:21:41.244] Expression:
[13:21:41.244] {
[13:21:41.244]     do.call(function(...) {
[13:21:41.244]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:41.244]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:41.244]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:41.244]             on.exit(options(oopts), add = TRUE)
[13:21:41.244]         }
[13:21:41.244]         {
[13:21:41.244]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:41.244]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:41.244]                 ...future.FUN(...future.X_jj, ...)
[13:21:41.244]             })
[13:21:41.244]         }
[13:21:41.244]     }, args = future.call.arguments)
[13:21:41.244] }
[13:21:41.244] Lazy evaluation: FALSE
[13:21:41.244] Asynchronous evaluation: TRUE
[13:21:41.244] Local evaluation: TRUE
[13:21:41.244] Environment: R_GlobalEnv
[13:21:41.244] Capture standard output: TRUE
[13:21:41.244] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:41.244] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:41.244] Packages: 1 packages (‘future.apply’)
[13:21:41.244] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:41.244] Resolved: FALSE
[13:21:41.244] Value: <not collected>
[13:21:41.244] Conditions captured: <none>
[13:21:41.244] Early signaling: FALSE
[13:21:41.244] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:41.244] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:41.256] Chunk #1 of 2 ... DONE
[13:21:41.256] Chunk #2 of 2 ...
[13:21:41.257]  - Finding globals in 'X' for chunk #2 ...
[13:21:41.257] getGlobalsAndPackages() ...
[13:21:41.257] Searching for globals...
[13:21:41.257] 
[13:21:41.257] Searching for globals ... DONE
[13:21:41.257] - globals: [0] <none>
[13:21:41.257] getGlobalsAndPackages() ... DONE
[13:21:41.258]    + additional globals found: [n=0] 
[13:21:41.258]    + additional namespaces needed: [n=0] 
[13:21:41.258]  - Finding globals in 'X' for chunk #2 ... DONE
[13:21:41.258]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:41.258]  - seeds: <none>
[13:21:41.258]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:41.258] getGlobalsAndPackages() ...
[13:21:41.258] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:41.258] Resolving globals: FALSE
[13:21:41.258] Tweak future expression to call with '...' arguments ...
[13:21:41.259] {
[13:21:41.259]     do.call(function(...) {
[13:21:41.259]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:41.259]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:41.259]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:41.259]             on.exit(options(oopts), add = TRUE)
[13:21:41.259]         }
[13:21:41.259]         {
[13:21:41.259]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:41.259]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:41.259]                 ...future.FUN(...future.X_jj, ...)
[13:21:41.259]             })
[13:21:41.259]         }
[13:21:41.259]     }, args = future.call.arguments)
[13:21:41.259] }
[13:21:41.259] Tweak future expression to call with '...' arguments ... DONE
[13:21:41.259] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:41.260] - packages: [1] ‘future.apply’
[13:21:41.260] getGlobalsAndPackages() ... DONE
[13:21:41.260] run() for ‘Future’ ...
[13:21:41.260] - state: ‘created’
[13:21:41.260] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:41.274] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:41.274] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:41.274]   - Field: ‘node’
[13:21:41.275]   - Field: ‘label’
[13:21:41.275]   - Field: ‘local’
[13:21:41.275]   - Field: ‘owner’
[13:21:41.275]   - Field: ‘envir’
[13:21:41.275]   - Field: ‘workers’
[13:21:41.275]   - Field: ‘packages’
[13:21:41.275]   - Field: ‘gc’
[13:21:41.275]   - Field: ‘conditions’
[13:21:41.275]   - Field: ‘persistent’
[13:21:41.275]   - Field: ‘expr’
[13:21:41.275]   - Field: ‘uuid’
[13:21:41.276]   - Field: ‘seed’
[13:21:41.276]   - Field: ‘version’
[13:21:41.276]   - Field: ‘result’
[13:21:41.276]   - Field: ‘asynchronous’
[13:21:41.276]   - Field: ‘calls’
[13:21:41.276]   - Field: ‘globals’
[13:21:41.276]   - Field: ‘stdout’
[13:21:41.276]   - Field: ‘earlySignal’
[13:21:41.276]   - Field: ‘lazy’
[13:21:41.276]   - Field: ‘state’
[13:21:41.277] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:41.277] - Launch lazy future ...
[13:21:41.277] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:41.277] Packages needed by future strategies (n = 0): <none>
[13:21:41.278] {
[13:21:41.278]     {
[13:21:41.278]         {
[13:21:41.278]             ...future.startTime <- base::Sys.time()
[13:21:41.278]             {
[13:21:41.278]                 {
[13:21:41.278]                   {
[13:21:41.278]                     {
[13:21:41.278]                       {
[13:21:41.278]                         base::local({
[13:21:41.278]                           has_future <- base::requireNamespace("future", 
[13:21:41.278]                             quietly = TRUE)
[13:21:41.278]                           if (has_future) {
[13:21:41.278]                             ns <- base::getNamespace("future")
[13:21:41.278]                             version <- ns[[".package"]][["version"]]
[13:21:41.278]                             if (is.null(version)) 
[13:21:41.278]                               version <- utils::packageVersion("future")
[13:21:41.278]                           }
[13:21:41.278]                           else {
[13:21:41.278]                             version <- NULL
[13:21:41.278]                           }
[13:21:41.278]                           if (!has_future || version < "1.8.0") {
[13:21:41.278]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:41.278]                               "", base::R.version$version.string), 
[13:21:41.278]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:41.278]                                 base::R.version$platform, 8 * 
[13:21:41.278]                                   base::.Machine$sizeof.pointer), 
[13:21:41.278]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:41.278]                                 "release", "version")], collapse = " "), 
[13:21:41.278]                               hostname = base::Sys.info()[["nodename"]])
[13:21:41.278]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:41.278]                               info)
[13:21:41.278]                             info <- base::paste(info, collapse = "; ")
[13:21:41.278]                             if (!has_future) {
[13:21:41.278]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:41.278]                                 info)
[13:21:41.278]                             }
[13:21:41.278]                             else {
[13:21:41.278]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:41.278]                                 info, version)
[13:21:41.278]                             }
[13:21:41.278]                             base::stop(msg)
[13:21:41.278]                           }
[13:21:41.278]                         })
[13:21:41.278]                       }
[13:21:41.278]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:41.278]                       base::options(mc.cores = 1L)
[13:21:41.278]                     }
[13:21:41.278]                     base::local({
[13:21:41.278]                       for (pkg in "future.apply") {
[13:21:41.278]                         base::loadNamespace(pkg)
[13:21:41.278]                         base::library(pkg, character.only = TRUE)
[13:21:41.278]                       }
[13:21:41.278]                     })
[13:21:41.278]                   }
[13:21:41.278]                   options(future.plan = NULL)
[13:21:41.278]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.278]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:41.278]                 }
[13:21:41.278]                 ...future.workdir <- getwd()
[13:21:41.278]             }
[13:21:41.278]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:41.278]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:41.278]         }
[13:21:41.278]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:41.278]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:41.278]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:41.278]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:41.278]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:41.278]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:41.278]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:41.278]             base::names(...future.oldOptions))
[13:21:41.278]     }
[13:21:41.278]     if (FALSE) {
[13:21:41.278]     }
[13:21:41.278]     else {
[13:21:41.278]         if (TRUE) {
[13:21:41.278]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:41.278]                 open = "w")
[13:21:41.278]         }
[13:21:41.278]         else {
[13:21:41.278]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:41.278]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:41.278]         }
[13:21:41.278]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:41.278]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:41.278]             base::sink(type = "output", split = FALSE)
[13:21:41.278]             base::close(...future.stdout)
[13:21:41.278]         }, add = TRUE)
[13:21:41.278]     }
[13:21:41.278]     ...future.frame <- base::sys.nframe()
[13:21:41.278]     ...future.conditions <- base::list()
[13:21:41.278]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:41.278]     if (FALSE) {
[13:21:41.278]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:41.278]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:41.278]     }
[13:21:41.278]     ...future.result <- base::tryCatch({
[13:21:41.278]         base::withCallingHandlers({
[13:21:41.278]             ...future.value <- base::withVisible(base::local({
[13:21:41.278]                 ...future.makeSendCondition <- base::local({
[13:21:41.278]                   sendCondition <- NULL
[13:21:41.278]                   function(frame = 1L) {
[13:21:41.278]                     if (is.function(sendCondition)) 
[13:21:41.278]                       return(sendCondition)
[13:21:41.278]                     ns <- getNamespace("parallel")
[13:21:41.278]                     if (exists("sendData", mode = "function", 
[13:21:41.278]                       envir = ns)) {
[13:21:41.278]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:41.278]                         envir = ns)
[13:21:41.278]                       envir <- sys.frame(frame)
[13:21:41.278]                       master <- NULL
[13:21:41.278]                       while (!identical(envir, .GlobalEnv) && 
[13:21:41.278]                         !identical(envir, emptyenv())) {
[13:21:41.278]                         if (exists("master", mode = "list", envir = envir, 
[13:21:41.278]                           inherits = FALSE)) {
[13:21:41.278]                           master <- get("master", mode = "list", 
[13:21:41.278]                             envir = envir, inherits = FALSE)
[13:21:41.278]                           if (inherits(master, c("SOCKnode", 
[13:21:41.278]                             "SOCK0node"))) {
[13:21:41.278]                             sendCondition <<- function(cond) {
[13:21:41.278]                               data <- list(type = "VALUE", value = cond, 
[13:21:41.278]                                 success = TRUE)
[13:21:41.278]                               parallel_sendData(master, data)
[13:21:41.278]                             }
[13:21:41.278]                             return(sendCondition)
[13:21:41.278]                           }
[13:21:41.278]                         }
[13:21:41.278]                         frame <- frame + 1L
[13:21:41.278]                         envir <- sys.frame(frame)
[13:21:41.278]                       }
[13:21:41.278]                     }
[13:21:41.278]                     sendCondition <<- function(cond) NULL
[13:21:41.278]                   }
[13:21:41.278]                 })
[13:21:41.278]                 withCallingHandlers({
[13:21:41.278]                   {
[13:21:41.278]                     do.call(function(...) {
[13:21:41.278]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:41.278]                       if (!identical(...future.globals.maxSize.org, 
[13:21:41.278]                         ...future.globals.maxSize)) {
[13:21:41.278]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:41.278]                         on.exit(options(oopts), add = TRUE)
[13:21:41.278]                       }
[13:21:41.278]                       {
[13:21:41.278]                         lapply(seq_along(...future.elements_ii), 
[13:21:41.278]                           FUN = function(jj) {
[13:21:41.278]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:41.278]                             ...future.FUN(...future.X_jj, ...)
[13:21:41.278]                           })
[13:21:41.278]                       }
[13:21:41.278]                     }, args = future.call.arguments)
[13:21:41.278]                   }
[13:21:41.278]                 }, immediateCondition = function(cond) {
[13:21:41.278]                   sendCondition <- ...future.makeSendCondition()
[13:21:41.278]                   sendCondition(cond)
[13:21:41.278]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.278]                   {
[13:21:41.278]                     inherits <- base::inherits
[13:21:41.278]                     invokeRestart <- base::invokeRestart
[13:21:41.278]                     is.null <- base::is.null
[13:21:41.278]                     muffled <- FALSE
[13:21:41.278]                     if (inherits(cond, "message")) {
[13:21:41.278]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:41.278]                       if (muffled) 
[13:21:41.278]                         invokeRestart("muffleMessage")
[13:21:41.278]                     }
[13:21:41.278]                     else if (inherits(cond, "warning")) {
[13:21:41.278]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:41.278]                       if (muffled) 
[13:21:41.278]                         invokeRestart("muffleWarning")
[13:21:41.278]                     }
[13:21:41.278]                     else if (inherits(cond, "condition")) {
[13:21:41.278]                       if (!is.null(pattern)) {
[13:21:41.278]                         computeRestarts <- base::computeRestarts
[13:21:41.278]                         grepl <- base::grepl
[13:21:41.278]                         restarts <- computeRestarts(cond)
[13:21:41.278]                         for (restart in restarts) {
[13:21:41.278]                           name <- restart$name
[13:21:41.278]                           if (is.null(name)) 
[13:21:41.278]                             next
[13:21:41.278]                           if (!grepl(pattern, name)) 
[13:21:41.278]                             next
[13:21:41.278]                           invokeRestart(restart)
[13:21:41.278]                           muffled <- TRUE
[13:21:41.278]                           break
[13:21:41.278]                         }
[13:21:41.278]                       }
[13:21:41.278]                     }
[13:21:41.278]                     invisible(muffled)
[13:21:41.278]                   }
[13:21:41.278]                   muffleCondition(cond)
[13:21:41.278]                 })
[13:21:41.278]             }))
[13:21:41.278]             future::FutureResult(value = ...future.value$value, 
[13:21:41.278]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.278]                   ...future.rng), globalenv = if (FALSE) 
[13:21:41.278]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:41.278]                     ...future.globalenv.names))
[13:21:41.278]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:41.278]         }, condition = base::local({
[13:21:41.278]             c <- base::c
[13:21:41.278]             inherits <- base::inherits
[13:21:41.278]             invokeRestart <- base::invokeRestart
[13:21:41.278]             length <- base::length
[13:21:41.278]             list <- base::list
[13:21:41.278]             seq.int <- base::seq.int
[13:21:41.278]             signalCondition <- base::signalCondition
[13:21:41.278]             sys.calls <- base::sys.calls
[13:21:41.278]             `[[` <- base::`[[`
[13:21:41.278]             `+` <- base::`+`
[13:21:41.278]             `<<-` <- base::`<<-`
[13:21:41.278]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:41.278]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:41.278]                   3L)]
[13:21:41.278]             }
[13:21:41.278]             function(cond) {
[13:21:41.278]                 is_error <- inherits(cond, "error")
[13:21:41.278]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:41.278]                   NULL)
[13:21:41.278]                 if (is_error) {
[13:21:41.278]                   sessionInformation <- function() {
[13:21:41.278]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:41.278]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:41.278]                       search = base::search(), system = base::Sys.info())
[13:21:41.278]                   }
[13:21:41.278]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.278]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:41.278]                     cond$call), session = sessionInformation(), 
[13:21:41.278]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:41.278]                   signalCondition(cond)
[13:21:41.278]                 }
[13:21:41.278]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:41.278]                 "immediateCondition"))) {
[13:21:41.278]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:41.278]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.278]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:41.278]                   if (TRUE && !signal) {
[13:21:41.278]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.278]                     {
[13:21:41.278]                       inherits <- base::inherits
[13:21:41.278]                       invokeRestart <- base::invokeRestart
[13:21:41.278]                       is.null <- base::is.null
[13:21:41.278]                       muffled <- FALSE
[13:21:41.278]                       if (inherits(cond, "message")) {
[13:21:41.278]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.278]                         if (muffled) 
[13:21:41.278]                           invokeRestart("muffleMessage")
[13:21:41.278]                       }
[13:21:41.278]                       else if (inherits(cond, "warning")) {
[13:21:41.278]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.278]                         if (muffled) 
[13:21:41.278]                           invokeRestart("muffleWarning")
[13:21:41.278]                       }
[13:21:41.278]                       else if (inherits(cond, "condition")) {
[13:21:41.278]                         if (!is.null(pattern)) {
[13:21:41.278]                           computeRestarts <- base::computeRestarts
[13:21:41.278]                           grepl <- base::grepl
[13:21:41.278]                           restarts <- computeRestarts(cond)
[13:21:41.278]                           for (restart in restarts) {
[13:21:41.278]                             name <- restart$name
[13:21:41.278]                             if (is.null(name)) 
[13:21:41.278]                               next
[13:21:41.278]                             if (!grepl(pattern, name)) 
[13:21:41.278]                               next
[13:21:41.278]                             invokeRestart(restart)
[13:21:41.278]                             muffled <- TRUE
[13:21:41.278]                             break
[13:21:41.278]                           }
[13:21:41.278]                         }
[13:21:41.278]                       }
[13:21:41.278]                       invisible(muffled)
[13:21:41.278]                     }
[13:21:41.278]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.278]                   }
[13:21:41.278]                 }
[13:21:41.278]                 else {
[13:21:41.278]                   if (TRUE) {
[13:21:41.278]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.278]                     {
[13:21:41.278]                       inherits <- base::inherits
[13:21:41.278]                       invokeRestart <- base::invokeRestart
[13:21:41.278]                       is.null <- base::is.null
[13:21:41.278]                       muffled <- FALSE
[13:21:41.278]                       if (inherits(cond, "message")) {
[13:21:41.278]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.278]                         if (muffled) 
[13:21:41.278]                           invokeRestart("muffleMessage")
[13:21:41.278]                       }
[13:21:41.278]                       else if (inherits(cond, "warning")) {
[13:21:41.278]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.278]                         if (muffled) 
[13:21:41.278]                           invokeRestart("muffleWarning")
[13:21:41.278]                       }
[13:21:41.278]                       else if (inherits(cond, "condition")) {
[13:21:41.278]                         if (!is.null(pattern)) {
[13:21:41.278]                           computeRestarts <- base::computeRestarts
[13:21:41.278]                           grepl <- base::grepl
[13:21:41.278]                           restarts <- computeRestarts(cond)
[13:21:41.278]                           for (restart in restarts) {
[13:21:41.278]                             name <- restart$name
[13:21:41.278]                             if (is.null(name)) 
[13:21:41.278]                               next
[13:21:41.278]                             if (!grepl(pattern, name)) 
[13:21:41.278]                               next
[13:21:41.278]                             invokeRestart(restart)
[13:21:41.278]                             muffled <- TRUE
[13:21:41.278]                             break
[13:21:41.278]                           }
[13:21:41.278]                         }
[13:21:41.278]                       }
[13:21:41.278]                       invisible(muffled)
[13:21:41.278]                     }
[13:21:41.278]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.278]                   }
[13:21:41.278]                 }
[13:21:41.278]             }
[13:21:41.278]         }))
[13:21:41.278]     }, error = function(ex) {
[13:21:41.278]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:41.278]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.278]                 ...future.rng), started = ...future.startTime, 
[13:21:41.278]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:41.278]             version = "1.8"), class = "FutureResult")
[13:21:41.278]     }, finally = {
[13:21:41.278]         if (!identical(...future.workdir, getwd())) 
[13:21:41.278]             setwd(...future.workdir)
[13:21:41.278]         {
[13:21:41.278]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:41.278]                 ...future.oldOptions$nwarnings <- NULL
[13:21:41.278]             }
[13:21:41.278]             base::options(...future.oldOptions)
[13:21:41.278]             if (.Platform$OS.type == "windows") {
[13:21:41.278]                 old_names <- names(...future.oldEnvVars)
[13:21:41.278]                 envs <- base::Sys.getenv()
[13:21:41.278]                 names <- names(envs)
[13:21:41.278]                 common <- intersect(names, old_names)
[13:21:41.278]                 added <- setdiff(names, old_names)
[13:21:41.278]                 removed <- setdiff(old_names, names)
[13:21:41.278]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:41.278]                   envs[common]]
[13:21:41.278]                 NAMES <- toupper(changed)
[13:21:41.278]                 args <- list()
[13:21:41.278]                 for (kk in seq_along(NAMES)) {
[13:21:41.278]                   name <- changed[[kk]]
[13:21:41.278]                   NAME <- NAMES[[kk]]
[13:21:41.278]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.278]                     next
[13:21:41.278]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.278]                 }
[13:21:41.278]                 NAMES <- toupper(added)
[13:21:41.278]                 for (kk in seq_along(NAMES)) {
[13:21:41.278]                   name <- added[[kk]]
[13:21:41.278]                   NAME <- NAMES[[kk]]
[13:21:41.278]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.278]                     next
[13:21:41.278]                   args[[name]] <- ""
[13:21:41.278]                 }
[13:21:41.278]                 NAMES <- toupper(removed)
[13:21:41.278]                 for (kk in seq_along(NAMES)) {
[13:21:41.278]                   name <- removed[[kk]]
[13:21:41.278]                   NAME <- NAMES[[kk]]
[13:21:41.278]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.278]                     next
[13:21:41.278]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.278]                 }
[13:21:41.278]                 if (length(args) > 0) 
[13:21:41.278]                   base::do.call(base::Sys.setenv, args = args)
[13:21:41.278]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:41.278]             }
[13:21:41.278]             else {
[13:21:41.278]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:41.278]             }
[13:21:41.278]             {
[13:21:41.278]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:41.278]                   0L) {
[13:21:41.278]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:41.278]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:41.278]                   base::options(opts)
[13:21:41.278]                 }
[13:21:41.278]                 {
[13:21:41.278]                   {
[13:21:41.278]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:41.278]                     NULL
[13:21:41.278]                   }
[13:21:41.278]                   options(future.plan = NULL)
[13:21:41.278]                   if (is.na(NA_character_)) 
[13:21:41.278]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.278]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:41.278]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:41.278]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:41.278]                     envir = parent.frame()) 
[13:21:41.278]                   {
[13:21:41.278]                     if (is.function(workers)) 
[13:21:41.278]                       workers <- workers()
[13:21:41.278]                     workers <- structure(as.integer(workers), 
[13:21:41.278]                       class = class(workers))
[13:21:41.278]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:41.278]                       workers >= 1)
[13:21:41.278]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:41.278]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:41.278]                     }
[13:21:41.278]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:41.278]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:41.278]                       envir = envir)
[13:21:41.278]                     if (!future$lazy) 
[13:21:41.278]                       future <- run(future)
[13:21:41.278]                     invisible(future)
[13:21:41.278]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:41.278]                 }
[13:21:41.278]             }
[13:21:41.278]         }
[13:21:41.278]     })
[13:21:41.278]     if (TRUE) {
[13:21:41.278]         base::sink(type = "output", split = FALSE)
[13:21:41.278]         if (TRUE) {
[13:21:41.278]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:41.278]         }
[13:21:41.278]         else {
[13:21:41.278]             ...future.result["stdout"] <- base::list(NULL)
[13:21:41.278]         }
[13:21:41.278]         base::close(...future.stdout)
[13:21:41.278]         ...future.stdout <- NULL
[13:21:41.278]     }
[13:21:41.278]     ...future.result$conditions <- ...future.conditions
[13:21:41.278]     ...future.result$finished <- base::Sys.time()
[13:21:41.278]     ...future.result
[13:21:41.278] }
[13:21:41.281] Exporting 11 global objects (96.29 KiB) to cluster node #2 ...
[13:21:41.281] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[13:21:41.324] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[13:21:41.325] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #2 ...
[13:21:41.325] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #2 ... DONE
[13:21:41.325] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[13:21:41.326] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[13:21:41.326] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[13:21:41.368] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[13:21:41.368] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[13:21:41.412] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[13:21:41.412] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[13:21:41.413] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[13:21:41.413] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[13:21:41.413] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[13:21:41.414] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ...
[13:21:41.414] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ... DONE
[13:21:41.414] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[13:21:41.415] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[13:21:41.415] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:21:41.415] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:21:41.415] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:21:41.416] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:21:41.416] Exporting 11 global objects (96.29 KiB) to cluster node #2 ... DONE
[13:21:41.416] MultisessionFuture started
[13:21:41.417] - Launch lazy future ... done
[13:21:41.417] run() for ‘MultisessionFuture’ ... done
[13:21:41.417] Created future:
[13:21:41.417] MultisessionFuture:
[13:21:41.417] Label: ‘future_vapply-2’
[13:21:41.417] Expression:
[13:21:41.417] {
[13:21:41.417]     do.call(function(...) {
[13:21:41.417]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:41.417]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:41.417]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:41.417]             on.exit(options(oopts), add = TRUE)
[13:21:41.417]         }
[13:21:41.417]         {
[13:21:41.417]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:41.417]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:41.417]                 ...future.FUN(...future.X_jj, ...)
[13:21:41.417]             })
[13:21:41.417]         }
[13:21:41.417]     }, args = future.call.arguments)
[13:21:41.417] }
[13:21:41.417] Lazy evaluation: FALSE
[13:21:41.417] Asynchronous evaluation: TRUE
[13:21:41.417] Local evaluation: TRUE
[13:21:41.417] Environment: R_GlobalEnv
[13:21:41.417] Capture standard output: TRUE
[13:21:41.417] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:41.417] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:41.417] Packages: 1 packages (‘future.apply’)
[13:21:41.417] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:41.417] Resolved: FALSE
[13:21:41.417] Value: <not collected>
[13:21:41.417] Conditions captured: <none>
[13:21:41.417] Early signaling: FALSE
[13:21:41.417] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:41.417] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:41.429] Chunk #2 of 2 ... DONE
[13:21:41.429] Launching 2 futures (chunks) ... DONE
[13:21:41.429] Resolving 2 futures (chunks) ...
[13:21:41.429] resolve() on list ...
[13:21:41.430]  recursive: 0
[13:21:41.430]  length: 2
[13:21:41.430] 
[13:21:41.430] receiveMessageFromWorker() for ClusterFuture ...
[13:21:41.430] - Validating connection of MultisessionFuture
[13:21:41.431] - received message: FutureResult
[13:21:41.431] - Received FutureResult
[13:21:41.431] - Erased future from FutureRegistry
[13:21:41.431] result() for ClusterFuture ...
[13:21:41.431] - result already collected: FutureResult
[13:21:41.431] result() for ClusterFuture ... done
[13:21:41.431] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:41.431] Future #1
[13:21:41.431] result() for ClusterFuture ...
[13:21:41.432] - result already collected: FutureResult
[13:21:41.432] result() for ClusterFuture ... done
[13:21:41.432] result() for ClusterFuture ...
[13:21:41.432] - result already collected: FutureResult
[13:21:41.432] result() for ClusterFuture ... done
[13:21:41.432] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:21:41.432] - nx: 2
[13:21:41.432] - relay: TRUE
[13:21:41.432] - stdout: TRUE
[13:21:41.432] - signal: TRUE
[13:21:41.432] - resignal: FALSE
[13:21:41.433] - force: TRUE
[13:21:41.433] - relayed: [n=2] FALSE, FALSE
[13:21:41.433] - queued futures: [n=2] FALSE, FALSE
[13:21:41.433]  - until=1
[13:21:41.433]  - relaying element #1
[13:21:41.433] result() for ClusterFuture ...
[13:21:41.433] - result already collected: FutureResult
[13:21:41.433] result() for ClusterFuture ... done
[13:21:41.433] result() for ClusterFuture ...
[13:21:41.433] - result already collected: FutureResult
[13:21:41.433] result() for ClusterFuture ... done
[13:21:41.434] result() for ClusterFuture ...
[13:21:41.434] - result already collected: FutureResult
[13:21:41.434] result() for ClusterFuture ... done
[13:21:41.434] result() for ClusterFuture ...
[13:21:41.434] - result already collected: FutureResult
[13:21:41.434] result() for ClusterFuture ... done
[13:21:41.434] - relayed: [n=2] TRUE, FALSE
[13:21:41.434] - queued futures: [n=2] TRUE, FALSE
[13:21:41.434] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:21:41.434]  length: 1 (resolved future 1)
[13:21:41.465] receiveMessageFromWorker() for ClusterFuture ...
[13:21:41.465] - Validating connection of MultisessionFuture
[13:21:41.466] - received message: FutureResult
[13:21:41.466] - Received FutureResult
[13:21:41.466] - Erased future from FutureRegistry
[13:21:41.466] result() for ClusterFuture ...
[13:21:41.466] - result already collected: FutureResult
[13:21:41.466] result() for ClusterFuture ... done
[13:21:41.466] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:41.466] Future #2
[13:21:41.467] result() for ClusterFuture ...
[13:21:41.467] - result already collected: FutureResult
[13:21:41.467] result() for ClusterFuture ... done
[13:21:41.467] result() for ClusterFuture ...
[13:21:41.467] - result already collected: FutureResult
[13:21:41.467] result() for ClusterFuture ... done
[13:21:41.467] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:21:41.467] - nx: 2
[13:21:41.467] - relay: TRUE
[13:21:41.467] - stdout: TRUE
[13:21:41.467] - signal: TRUE
[13:21:41.468] - resignal: FALSE
[13:21:41.468] - force: TRUE
[13:21:41.468] - relayed: [n=2] TRUE, FALSE
[13:21:41.468] - queued futures: [n=2] TRUE, FALSE
[13:21:41.468]  - until=2
[13:21:41.468]  - relaying element #2
[13:21:41.468] result() for ClusterFuture ...
[13:21:41.468] - result already collected: FutureResult
[13:21:41.468] result() for ClusterFuture ... done
[13:21:41.468] result() for ClusterFuture ...
[13:21:41.469] - result already collected: FutureResult
[13:21:41.469] result() for ClusterFuture ... done
[13:21:41.469] result() for ClusterFuture ...
[13:21:41.469] - result already collected: FutureResult
[13:21:41.469] result() for ClusterFuture ... done
[13:21:41.469] result() for ClusterFuture ...
[13:21:41.469] - result already collected: FutureResult
[13:21:41.469] result() for ClusterFuture ... done
[13:21:41.469] - relayed: [n=2] TRUE, TRUE
[13:21:41.469] - queued futures: [n=2] TRUE, TRUE
[13:21:41.469] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:21:41.470]  length: 0 (resolved future 2)
[13:21:41.470] Relaying remaining futures
[13:21:41.470] signalConditionsASAP(NULL, pos=0) ...
[13:21:41.470] - nx: 2
[13:21:41.470] - relay: TRUE
[13:21:41.470] - stdout: TRUE
[13:21:41.470] - signal: TRUE
[13:21:41.470] - resignal: FALSE
[13:21:41.470] - force: TRUE
[13:21:41.470] - relayed: [n=2] TRUE, TRUE
[13:21:41.470] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:21:41.471] - relayed: [n=2] TRUE, TRUE
[13:21:41.471] - queued futures: [n=2] TRUE, TRUE
[13:21:41.471] signalConditionsASAP(NULL, pos=0) ... done
[13:21:41.471] resolve() on list ... DONE
[13:21:41.471] result() for ClusterFuture ...
[13:21:41.471] - result already collected: FutureResult
[13:21:41.471] result() for ClusterFuture ... done
[13:21:41.471] result() for ClusterFuture ...
[13:21:41.471] - result already collected: FutureResult
[13:21:41.471] result() for ClusterFuture ... done
[13:21:41.471] result() for ClusterFuture ...
[13:21:41.472] - result already collected: FutureResult
[13:21:41.472] result() for ClusterFuture ... done
[13:21:41.472] result() for ClusterFuture ...
[13:21:41.472] - result already collected: FutureResult
[13:21:41.472] result() for ClusterFuture ... done
[13:21:41.472]  - Number of value chunks collected: 2
[13:21:41.472] Resolving 2 futures (chunks) ... DONE
[13:21:41.472] Reducing values from 2 chunks ...
[13:21:41.472]  - Number of values collected after concatenation: 4
[13:21:41.472]  - Number of values expected: 4
[13:21:41.472] Reducing values from 2 chunks ... DONE
[13:21:41.473] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[13:21:41.474] future_lapply() ...
[13:21:41.480] Number of chunks: 2
[13:21:41.480] getGlobalsAndPackagesXApply() ...
[13:21:41.481]  - future.globals: TRUE
[13:21:41.481] getGlobalsAndPackages() ...
[13:21:41.481] Searching for globals...
[13:21:41.484] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:21:41.484] Searching for globals ... DONE
[13:21:41.484] Resolving globals: FALSE
[13:21:41.485] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[13:21:41.486] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:41.486] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:41.486] - packages: [1] ‘future.apply’
[13:21:41.486] getGlobalsAndPackages() ... DONE
[13:21:41.486]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:41.486]  - needed namespaces: [n=1] ‘future.apply’
[13:21:41.486] Finding globals ... DONE
[13:21:41.486]  - use_args: TRUE
[13:21:41.486]  - Getting '...' globals ...
[13:21:41.487] resolve() on list ...
[13:21:41.487]  recursive: 0
[13:21:41.487]  length: 1
[13:21:41.487]  elements: ‘...’
[13:21:41.487]  length: 0 (resolved future 1)
[13:21:41.487] resolve() on list ... DONE
[13:21:41.487]    - '...' content: [n=0] 
[13:21:41.487] List of 1
[13:21:41.487]  $ ...: list()
[13:21:41.487]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:41.487]  - attr(*, "where")=List of 1
[13:21:41.487]   ..$ ...:<environment: 0x563b70e68798> 
[13:21:41.487]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:41.487]  - attr(*, "resolved")= logi TRUE
[13:21:41.487]  - attr(*, "total_size")= num NA
[13:21:41.490]  - Getting '...' globals ... DONE
[13:21:41.490] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:41.490] List of 8
[13:21:41.490]  $ ...future.FUN:function (x, ...)  
[13:21:41.490]  $ x_FUN        :function (x)  
[13:21:41.490]  $ times        : int 1
[13:21:41.490]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:41.490]  $ stop_if_not  :function (...)  
[13:21:41.490]  $ dim          : NULL
[13:21:41.490]  $ valid_types  : chr "logical"
[13:21:41.490]  $ ...          : list()
[13:21:41.490]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:41.490]  - attr(*, "where")=List of 8
[13:21:41.490]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:41.490]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:41.490]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:41.490]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:41.490]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:41.490]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:41.490]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:41.490]   ..$ ...          :<environment: 0x563b70e68798> 
[13:21:41.490]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:41.490]  - attr(*, "resolved")= logi FALSE
[13:21:41.490]  - attr(*, "total_size")= num 94200
[13:21:41.496] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:21:41.496] getGlobalsAndPackagesXApply() ... DONE
[13:21:41.496] Number of futures (= number of chunks): 2
[13:21:41.496] Launching 2 futures (chunks) ...
[13:21:41.496] Chunk #1 of 2 ...
[13:21:41.496]  - Finding globals in 'X' for chunk #1 ...
[13:21:41.497] getGlobalsAndPackages() ...
[13:21:41.497] Searching for globals...
[13:21:41.497] 
[13:21:41.497] Searching for globals ... DONE
[13:21:41.497] - globals: [0] <none>
[13:21:41.497] getGlobalsAndPackages() ... DONE
[13:21:41.497]    + additional globals found: [n=0] 
[13:21:41.497]    + additional namespaces needed: [n=0] 
[13:21:41.497]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:41.498]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:41.498]  - seeds: <none>
[13:21:41.498]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:41.498] getGlobalsAndPackages() ...
[13:21:41.498] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:41.498] Resolving globals: FALSE
[13:21:41.498] Tweak future expression to call with '...' arguments ...
[13:21:41.498] {
[13:21:41.498]     do.call(function(...) {
[13:21:41.498]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:41.498]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:41.498]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:41.498]             on.exit(options(oopts), add = TRUE)
[13:21:41.498]         }
[13:21:41.498]         {
[13:21:41.498]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:41.498]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:41.498]                 ...future.FUN(...future.X_jj, ...)
[13:21:41.498]             })
[13:21:41.498]         }
[13:21:41.498]     }, args = future.call.arguments)
[13:21:41.498] }
[13:21:41.499] Tweak future expression to call with '...' arguments ... DONE
[13:21:41.502] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:41.502] - packages: [1] ‘future.apply’
[13:21:41.502] getGlobalsAndPackages() ... DONE
[13:21:41.502] run() for ‘Future’ ...
[13:21:41.502] - state: ‘created’
[13:21:41.503] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:41.517] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:41.517] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:41.518]   - Field: ‘node’
[13:21:41.518]   - Field: ‘label’
[13:21:41.518]   - Field: ‘local’
[13:21:41.518]   - Field: ‘owner’
[13:21:41.518]   - Field: ‘envir’
[13:21:41.518]   - Field: ‘workers’
[13:21:41.518]   - Field: ‘packages’
[13:21:41.518]   - Field: ‘gc’
[13:21:41.518]   - Field: ‘conditions’
[13:21:41.518]   - Field: ‘persistent’
[13:21:41.519]   - Field: ‘expr’
[13:21:41.519]   - Field: ‘uuid’
[13:21:41.519]   - Field: ‘seed’
[13:21:41.519]   - Field: ‘version’
[13:21:41.519]   - Field: ‘result’
[13:21:41.519]   - Field: ‘asynchronous’
[13:21:41.519]   - Field: ‘calls’
[13:21:41.519]   - Field: ‘globals’
[13:21:41.519]   - Field: ‘stdout’
[13:21:41.519]   - Field: ‘earlySignal’
[13:21:41.519]   - Field: ‘lazy’
[13:21:41.520]   - Field: ‘state’
[13:21:41.520] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:41.520] - Launch lazy future ...
[13:21:41.520] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:41.520] Packages needed by future strategies (n = 0): <none>
[13:21:41.521] {
[13:21:41.521]     {
[13:21:41.521]         {
[13:21:41.521]             ...future.startTime <- base::Sys.time()
[13:21:41.521]             {
[13:21:41.521]                 {
[13:21:41.521]                   {
[13:21:41.521]                     {
[13:21:41.521]                       {
[13:21:41.521]                         base::local({
[13:21:41.521]                           has_future <- base::requireNamespace("future", 
[13:21:41.521]                             quietly = TRUE)
[13:21:41.521]                           if (has_future) {
[13:21:41.521]                             ns <- base::getNamespace("future")
[13:21:41.521]                             version <- ns[[".package"]][["version"]]
[13:21:41.521]                             if (is.null(version)) 
[13:21:41.521]                               version <- utils::packageVersion("future")
[13:21:41.521]                           }
[13:21:41.521]                           else {
[13:21:41.521]                             version <- NULL
[13:21:41.521]                           }
[13:21:41.521]                           if (!has_future || version < "1.8.0") {
[13:21:41.521]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:41.521]                               "", base::R.version$version.string), 
[13:21:41.521]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:41.521]                                 base::R.version$platform, 8 * 
[13:21:41.521]                                   base::.Machine$sizeof.pointer), 
[13:21:41.521]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:41.521]                                 "release", "version")], collapse = " "), 
[13:21:41.521]                               hostname = base::Sys.info()[["nodename"]])
[13:21:41.521]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:41.521]                               info)
[13:21:41.521]                             info <- base::paste(info, collapse = "; ")
[13:21:41.521]                             if (!has_future) {
[13:21:41.521]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:41.521]                                 info)
[13:21:41.521]                             }
[13:21:41.521]                             else {
[13:21:41.521]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:41.521]                                 info, version)
[13:21:41.521]                             }
[13:21:41.521]                             base::stop(msg)
[13:21:41.521]                           }
[13:21:41.521]                         })
[13:21:41.521]                       }
[13:21:41.521]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:41.521]                       base::options(mc.cores = 1L)
[13:21:41.521]                     }
[13:21:41.521]                     base::local({
[13:21:41.521]                       for (pkg in "future.apply") {
[13:21:41.521]                         base::loadNamespace(pkg)
[13:21:41.521]                         base::library(pkg, character.only = TRUE)
[13:21:41.521]                       }
[13:21:41.521]                     })
[13:21:41.521]                   }
[13:21:41.521]                   options(future.plan = NULL)
[13:21:41.521]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.521]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:41.521]                 }
[13:21:41.521]                 ...future.workdir <- getwd()
[13:21:41.521]             }
[13:21:41.521]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:41.521]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:41.521]         }
[13:21:41.521]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:41.521]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:41.521]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:41.521]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:41.521]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:41.521]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:41.521]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:41.521]             base::names(...future.oldOptions))
[13:21:41.521]     }
[13:21:41.521]     if (FALSE) {
[13:21:41.521]     }
[13:21:41.521]     else {
[13:21:41.521]         if (TRUE) {
[13:21:41.521]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:41.521]                 open = "w")
[13:21:41.521]         }
[13:21:41.521]         else {
[13:21:41.521]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:41.521]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:41.521]         }
[13:21:41.521]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:41.521]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:41.521]             base::sink(type = "output", split = FALSE)
[13:21:41.521]             base::close(...future.stdout)
[13:21:41.521]         }, add = TRUE)
[13:21:41.521]     }
[13:21:41.521]     ...future.frame <- base::sys.nframe()
[13:21:41.521]     ...future.conditions <- base::list()
[13:21:41.521]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:41.521]     if (FALSE) {
[13:21:41.521]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:41.521]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:41.521]     }
[13:21:41.521]     ...future.result <- base::tryCatch({
[13:21:41.521]         base::withCallingHandlers({
[13:21:41.521]             ...future.value <- base::withVisible(base::local({
[13:21:41.521]                 ...future.makeSendCondition <- base::local({
[13:21:41.521]                   sendCondition <- NULL
[13:21:41.521]                   function(frame = 1L) {
[13:21:41.521]                     if (is.function(sendCondition)) 
[13:21:41.521]                       return(sendCondition)
[13:21:41.521]                     ns <- getNamespace("parallel")
[13:21:41.521]                     if (exists("sendData", mode = "function", 
[13:21:41.521]                       envir = ns)) {
[13:21:41.521]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:41.521]                         envir = ns)
[13:21:41.521]                       envir <- sys.frame(frame)
[13:21:41.521]                       master <- NULL
[13:21:41.521]                       while (!identical(envir, .GlobalEnv) && 
[13:21:41.521]                         !identical(envir, emptyenv())) {
[13:21:41.521]                         if (exists("master", mode = "list", envir = envir, 
[13:21:41.521]                           inherits = FALSE)) {
[13:21:41.521]                           master <- get("master", mode = "list", 
[13:21:41.521]                             envir = envir, inherits = FALSE)
[13:21:41.521]                           if (inherits(master, c("SOCKnode", 
[13:21:41.521]                             "SOCK0node"))) {
[13:21:41.521]                             sendCondition <<- function(cond) {
[13:21:41.521]                               data <- list(type = "VALUE", value = cond, 
[13:21:41.521]                                 success = TRUE)
[13:21:41.521]                               parallel_sendData(master, data)
[13:21:41.521]                             }
[13:21:41.521]                             return(sendCondition)
[13:21:41.521]                           }
[13:21:41.521]                         }
[13:21:41.521]                         frame <- frame + 1L
[13:21:41.521]                         envir <- sys.frame(frame)
[13:21:41.521]                       }
[13:21:41.521]                     }
[13:21:41.521]                     sendCondition <<- function(cond) NULL
[13:21:41.521]                   }
[13:21:41.521]                 })
[13:21:41.521]                 withCallingHandlers({
[13:21:41.521]                   {
[13:21:41.521]                     do.call(function(...) {
[13:21:41.521]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:41.521]                       if (!identical(...future.globals.maxSize.org, 
[13:21:41.521]                         ...future.globals.maxSize)) {
[13:21:41.521]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:41.521]                         on.exit(options(oopts), add = TRUE)
[13:21:41.521]                       }
[13:21:41.521]                       {
[13:21:41.521]                         lapply(seq_along(...future.elements_ii), 
[13:21:41.521]                           FUN = function(jj) {
[13:21:41.521]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:41.521]                             ...future.FUN(...future.X_jj, ...)
[13:21:41.521]                           })
[13:21:41.521]                       }
[13:21:41.521]                     }, args = future.call.arguments)
[13:21:41.521]                   }
[13:21:41.521]                 }, immediateCondition = function(cond) {
[13:21:41.521]                   sendCondition <- ...future.makeSendCondition()
[13:21:41.521]                   sendCondition(cond)
[13:21:41.521]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.521]                   {
[13:21:41.521]                     inherits <- base::inherits
[13:21:41.521]                     invokeRestart <- base::invokeRestart
[13:21:41.521]                     is.null <- base::is.null
[13:21:41.521]                     muffled <- FALSE
[13:21:41.521]                     if (inherits(cond, "message")) {
[13:21:41.521]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:41.521]                       if (muffled) 
[13:21:41.521]                         invokeRestart("muffleMessage")
[13:21:41.521]                     }
[13:21:41.521]                     else if (inherits(cond, "warning")) {
[13:21:41.521]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:41.521]                       if (muffled) 
[13:21:41.521]                         invokeRestart("muffleWarning")
[13:21:41.521]                     }
[13:21:41.521]                     else if (inherits(cond, "condition")) {
[13:21:41.521]                       if (!is.null(pattern)) {
[13:21:41.521]                         computeRestarts <- base::computeRestarts
[13:21:41.521]                         grepl <- base::grepl
[13:21:41.521]                         restarts <- computeRestarts(cond)
[13:21:41.521]                         for (restart in restarts) {
[13:21:41.521]                           name <- restart$name
[13:21:41.521]                           if (is.null(name)) 
[13:21:41.521]                             next
[13:21:41.521]                           if (!grepl(pattern, name)) 
[13:21:41.521]                             next
[13:21:41.521]                           invokeRestart(restart)
[13:21:41.521]                           muffled <- TRUE
[13:21:41.521]                           break
[13:21:41.521]                         }
[13:21:41.521]                       }
[13:21:41.521]                     }
[13:21:41.521]                     invisible(muffled)
[13:21:41.521]                   }
[13:21:41.521]                   muffleCondition(cond)
[13:21:41.521]                 })
[13:21:41.521]             }))
[13:21:41.521]             future::FutureResult(value = ...future.value$value, 
[13:21:41.521]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.521]                   ...future.rng), globalenv = if (FALSE) 
[13:21:41.521]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:41.521]                     ...future.globalenv.names))
[13:21:41.521]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:41.521]         }, condition = base::local({
[13:21:41.521]             c <- base::c
[13:21:41.521]             inherits <- base::inherits
[13:21:41.521]             invokeRestart <- base::invokeRestart
[13:21:41.521]             length <- base::length
[13:21:41.521]             list <- base::list
[13:21:41.521]             seq.int <- base::seq.int
[13:21:41.521]             signalCondition <- base::signalCondition
[13:21:41.521]             sys.calls <- base::sys.calls
[13:21:41.521]             `[[` <- base::`[[`
[13:21:41.521]             `+` <- base::`+`
[13:21:41.521]             `<<-` <- base::`<<-`
[13:21:41.521]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:41.521]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:41.521]                   3L)]
[13:21:41.521]             }
[13:21:41.521]             function(cond) {
[13:21:41.521]                 is_error <- inherits(cond, "error")
[13:21:41.521]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:41.521]                   NULL)
[13:21:41.521]                 if (is_error) {
[13:21:41.521]                   sessionInformation <- function() {
[13:21:41.521]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:41.521]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:41.521]                       search = base::search(), system = base::Sys.info())
[13:21:41.521]                   }
[13:21:41.521]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.521]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:41.521]                     cond$call), session = sessionInformation(), 
[13:21:41.521]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:41.521]                   signalCondition(cond)
[13:21:41.521]                 }
[13:21:41.521]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:41.521]                 "immediateCondition"))) {
[13:21:41.521]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:41.521]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.521]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:41.521]                   if (TRUE && !signal) {
[13:21:41.521]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.521]                     {
[13:21:41.521]                       inherits <- base::inherits
[13:21:41.521]                       invokeRestart <- base::invokeRestart
[13:21:41.521]                       is.null <- base::is.null
[13:21:41.521]                       muffled <- FALSE
[13:21:41.521]                       if (inherits(cond, "message")) {
[13:21:41.521]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.521]                         if (muffled) 
[13:21:41.521]                           invokeRestart("muffleMessage")
[13:21:41.521]                       }
[13:21:41.521]                       else if (inherits(cond, "warning")) {
[13:21:41.521]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.521]                         if (muffled) 
[13:21:41.521]                           invokeRestart("muffleWarning")
[13:21:41.521]                       }
[13:21:41.521]                       else if (inherits(cond, "condition")) {
[13:21:41.521]                         if (!is.null(pattern)) {
[13:21:41.521]                           computeRestarts <- base::computeRestarts
[13:21:41.521]                           grepl <- base::grepl
[13:21:41.521]                           restarts <- computeRestarts(cond)
[13:21:41.521]                           for (restart in restarts) {
[13:21:41.521]                             name <- restart$name
[13:21:41.521]                             if (is.null(name)) 
[13:21:41.521]                               next
[13:21:41.521]                             if (!grepl(pattern, name)) 
[13:21:41.521]                               next
[13:21:41.521]                             invokeRestart(restart)
[13:21:41.521]                             muffled <- TRUE
[13:21:41.521]                             break
[13:21:41.521]                           }
[13:21:41.521]                         }
[13:21:41.521]                       }
[13:21:41.521]                       invisible(muffled)
[13:21:41.521]                     }
[13:21:41.521]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.521]                   }
[13:21:41.521]                 }
[13:21:41.521]                 else {
[13:21:41.521]                   if (TRUE) {
[13:21:41.521]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.521]                     {
[13:21:41.521]                       inherits <- base::inherits
[13:21:41.521]                       invokeRestart <- base::invokeRestart
[13:21:41.521]                       is.null <- base::is.null
[13:21:41.521]                       muffled <- FALSE
[13:21:41.521]                       if (inherits(cond, "message")) {
[13:21:41.521]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.521]                         if (muffled) 
[13:21:41.521]                           invokeRestart("muffleMessage")
[13:21:41.521]                       }
[13:21:41.521]                       else if (inherits(cond, "warning")) {
[13:21:41.521]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.521]                         if (muffled) 
[13:21:41.521]                           invokeRestart("muffleWarning")
[13:21:41.521]                       }
[13:21:41.521]                       else if (inherits(cond, "condition")) {
[13:21:41.521]                         if (!is.null(pattern)) {
[13:21:41.521]                           computeRestarts <- base::computeRestarts
[13:21:41.521]                           grepl <- base::grepl
[13:21:41.521]                           restarts <- computeRestarts(cond)
[13:21:41.521]                           for (restart in restarts) {
[13:21:41.521]                             name <- restart$name
[13:21:41.521]                             if (is.null(name)) 
[13:21:41.521]                               next
[13:21:41.521]                             if (!grepl(pattern, name)) 
[13:21:41.521]                               next
[13:21:41.521]                             invokeRestart(restart)
[13:21:41.521]                             muffled <- TRUE
[13:21:41.521]                             break
[13:21:41.521]                           }
[13:21:41.521]                         }
[13:21:41.521]                       }
[13:21:41.521]                       invisible(muffled)
[13:21:41.521]                     }
[13:21:41.521]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.521]                   }
[13:21:41.521]                 }
[13:21:41.521]             }
[13:21:41.521]         }))
[13:21:41.521]     }, error = function(ex) {
[13:21:41.521]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:41.521]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.521]                 ...future.rng), started = ...future.startTime, 
[13:21:41.521]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:41.521]             version = "1.8"), class = "FutureResult")
[13:21:41.521]     }, finally = {
[13:21:41.521]         if (!identical(...future.workdir, getwd())) 
[13:21:41.521]             setwd(...future.workdir)
[13:21:41.521]         {
[13:21:41.521]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:41.521]                 ...future.oldOptions$nwarnings <- NULL
[13:21:41.521]             }
[13:21:41.521]             base::options(...future.oldOptions)
[13:21:41.521]             if (.Platform$OS.type == "windows") {
[13:21:41.521]                 old_names <- names(...future.oldEnvVars)
[13:21:41.521]                 envs <- base::Sys.getenv()
[13:21:41.521]                 names <- names(envs)
[13:21:41.521]                 common <- intersect(names, old_names)
[13:21:41.521]                 added <- setdiff(names, old_names)
[13:21:41.521]                 removed <- setdiff(old_names, names)
[13:21:41.521]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:41.521]                   envs[common]]
[13:21:41.521]                 NAMES <- toupper(changed)
[13:21:41.521]                 args <- list()
[13:21:41.521]                 for (kk in seq_along(NAMES)) {
[13:21:41.521]                   name <- changed[[kk]]
[13:21:41.521]                   NAME <- NAMES[[kk]]
[13:21:41.521]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.521]                     next
[13:21:41.521]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.521]                 }
[13:21:41.521]                 NAMES <- toupper(added)
[13:21:41.521]                 for (kk in seq_along(NAMES)) {
[13:21:41.521]                   name <- added[[kk]]
[13:21:41.521]                   NAME <- NAMES[[kk]]
[13:21:41.521]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.521]                     next
[13:21:41.521]                   args[[name]] <- ""
[13:21:41.521]                 }
[13:21:41.521]                 NAMES <- toupper(removed)
[13:21:41.521]                 for (kk in seq_along(NAMES)) {
[13:21:41.521]                   name <- removed[[kk]]
[13:21:41.521]                   NAME <- NAMES[[kk]]
[13:21:41.521]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.521]                     next
[13:21:41.521]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.521]                 }
[13:21:41.521]                 if (length(args) > 0) 
[13:21:41.521]                   base::do.call(base::Sys.setenv, args = args)
[13:21:41.521]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:41.521]             }
[13:21:41.521]             else {
[13:21:41.521]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:41.521]             }
[13:21:41.521]             {
[13:21:41.521]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:41.521]                   0L) {
[13:21:41.521]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:41.521]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:41.521]                   base::options(opts)
[13:21:41.521]                 }
[13:21:41.521]                 {
[13:21:41.521]                   {
[13:21:41.521]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:41.521]                     NULL
[13:21:41.521]                   }
[13:21:41.521]                   options(future.plan = NULL)
[13:21:41.521]                   if (is.na(NA_character_)) 
[13:21:41.521]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.521]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:41.521]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:41.521]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:41.521]                     envir = parent.frame()) 
[13:21:41.521]                   {
[13:21:41.521]                     if (is.function(workers)) 
[13:21:41.521]                       workers <- workers()
[13:21:41.521]                     workers <- structure(as.integer(workers), 
[13:21:41.521]                       class = class(workers))
[13:21:41.521]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:41.521]                       workers >= 1)
[13:21:41.521]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:41.521]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:41.521]                     }
[13:21:41.521]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:41.521]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:41.521]                       envir = envir)
[13:21:41.521]                     if (!future$lazy) 
[13:21:41.521]                       future <- run(future)
[13:21:41.521]                     invisible(future)
[13:21:41.521]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:41.521]                 }
[13:21:41.521]             }
[13:21:41.521]         }
[13:21:41.521]     })
[13:21:41.521]     if (TRUE) {
[13:21:41.521]         base::sink(type = "output", split = FALSE)
[13:21:41.521]         if (TRUE) {
[13:21:41.521]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:41.521]         }
[13:21:41.521]         else {
[13:21:41.521]             ...future.result["stdout"] <- base::list(NULL)
[13:21:41.521]         }
[13:21:41.521]         base::close(...future.stdout)
[13:21:41.521]         ...future.stdout <- NULL
[13:21:41.521]     }
[13:21:41.521]     ...future.result$conditions <- ...future.conditions
[13:21:41.521]     ...future.result$finished <- base::Sys.time()
[13:21:41.521]     ...future.result
[13:21:41.521] }
[13:21:41.524] Exporting 11 global objects (91.99 KiB) to cluster node #1 ...
[13:21:41.524] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:21:41.568] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:21:41.569] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[13:21:41.569] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[13:21:41.569] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:21:41.570] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:21:41.570] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:21:41.612] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:21:41.613] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:21:41.656] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:21:41.657] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[13:21:41.657] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[13:21:41.657] Exporting ‘valid_types’ (112 bytes) to cluster node #1 ...
[13:21:41.658] Exporting ‘valid_types’ (112 bytes) to cluster node #1 ... DONE
[13:21:41.658] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:21:41.658] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:21:41.658] Exporting ‘...future.elements_ii’ (1.78 KiB) to cluster node #1 ...
[13:21:41.659] Exporting ‘...future.elements_ii’ (1.78 KiB) to cluster node #1 ... DONE
[13:21:41.659] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:21:41.659] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:21:41.660] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:21:41.660] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:21:41.660] Exporting 11 global objects (91.99 KiB) to cluster node #1 ... DONE
[13:21:41.661] MultisessionFuture started
[13:21:41.661] - Launch lazy future ... done
[13:21:41.661] run() for ‘MultisessionFuture’ ... done
[13:21:41.661] Created future:
[13:21:41.661] MultisessionFuture:
[13:21:41.661] Label: ‘future_vapply-1’
[13:21:41.661] Expression:
[13:21:41.661] {
[13:21:41.661]     do.call(function(...) {
[13:21:41.661]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:41.661]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:41.661]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:41.661]             on.exit(options(oopts), add = TRUE)
[13:21:41.661]         }
[13:21:41.661]         {
[13:21:41.661]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:41.661]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:41.661]                 ...future.FUN(...future.X_jj, ...)
[13:21:41.661]             })
[13:21:41.661]         }
[13:21:41.661]     }, args = future.call.arguments)
[13:21:41.661] }
[13:21:41.661] Lazy evaluation: FALSE
[13:21:41.661] Asynchronous evaluation: TRUE
[13:21:41.661] Local evaluation: TRUE
[13:21:41.661] Environment: R_GlobalEnv
[13:21:41.661] Capture standard output: TRUE
[13:21:41.661] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:41.661] Globals: 11 objects totaling 93.77 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:41.661] Packages: 1 packages (‘future.apply’)
[13:21:41.661] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:41.661] Resolved: FALSE
[13:21:41.661] Value: <not collected>
[13:21:41.661] Conditions captured: <none>
[13:21:41.661] Early signaling: FALSE
[13:21:41.661] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:41.661] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:41.673] Chunk #1 of 2 ... DONE
[13:21:41.673] Chunk #2 of 2 ...
[13:21:41.674]  - Finding globals in 'X' for chunk #2 ...
[13:21:41.674] getGlobalsAndPackages() ...
[13:21:41.674] Searching for globals...
[13:21:41.674] 
[13:21:41.674] Searching for globals ... DONE
[13:21:41.674] - globals: [0] <none>
[13:21:41.674] getGlobalsAndPackages() ... DONE
[13:21:41.674]    + additional globals found: [n=0] 
[13:21:41.675]    + additional namespaces needed: [n=0] 
[13:21:41.675]  - Finding globals in 'X' for chunk #2 ... DONE
[13:21:41.675]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:41.675]  - seeds: <none>
[13:21:41.675]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:41.675] getGlobalsAndPackages() ...
[13:21:41.675] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:41.675] Resolving globals: FALSE
[13:21:41.675] Tweak future expression to call with '...' arguments ...
[13:21:41.675] {
[13:21:41.675]     do.call(function(...) {
[13:21:41.675]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:41.675]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:41.675]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:41.675]             on.exit(options(oopts), add = TRUE)
[13:21:41.675]         }
[13:21:41.675]         {
[13:21:41.675]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:41.675]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:41.675]                 ...future.FUN(...future.X_jj, ...)
[13:21:41.675]             })
[13:21:41.675]         }
[13:21:41.675]     }, args = future.call.arguments)
[13:21:41.675] }
[13:21:41.676] Tweak future expression to call with '...' arguments ... DONE
[13:21:41.676] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:41.677] - packages: [1] ‘future.apply’
[13:21:41.677] getGlobalsAndPackages() ... DONE
[13:21:41.677] run() for ‘Future’ ...
[13:21:41.677] - state: ‘created’
[13:21:41.677] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:41.695] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:41.695] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:41.695]   - Field: ‘node’
[13:21:41.695]   - Field: ‘label’
[13:21:41.695]   - Field: ‘local’
[13:21:41.695]   - Field: ‘owner’
[13:21:41.695]   - Field: ‘envir’
[13:21:41.695]   - Field: ‘workers’
[13:21:41.696]   - Field: ‘packages’
[13:21:41.696]   - Field: ‘gc’
[13:21:41.696]   - Field: ‘conditions’
[13:21:41.696]   - Field: ‘persistent’
[13:21:41.696]   - Field: ‘expr’
[13:21:41.696]   - Field: ‘uuid’
[13:21:41.696]   - Field: ‘seed’
[13:21:41.696]   - Field: ‘version’
[13:21:41.696]   - Field: ‘result’
[13:21:41.696]   - Field: ‘asynchronous’
[13:21:41.696]   - Field: ‘calls’
[13:21:41.697]   - Field: ‘globals’
[13:21:41.697]   - Field: ‘stdout’
[13:21:41.697]   - Field: ‘earlySignal’
[13:21:41.697]   - Field: ‘lazy’
[13:21:41.697]   - Field: ‘state’
[13:21:41.697] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:41.697] - Launch lazy future ...
[13:21:41.697] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:41.698] Packages needed by future strategies (n = 0): <none>
[13:21:41.698] {
[13:21:41.698]     {
[13:21:41.698]         {
[13:21:41.698]             ...future.startTime <- base::Sys.time()
[13:21:41.698]             {
[13:21:41.698]                 {
[13:21:41.698]                   {
[13:21:41.698]                     {
[13:21:41.698]                       {
[13:21:41.698]                         base::local({
[13:21:41.698]                           has_future <- base::requireNamespace("future", 
[13:21:41.698]                             quietly = TRUE)
[13:21:41.698]                           if (has_future) {
[13:21:41.698]                             ns <- base::getNamespace("future")
[13:21:41.698]                             version <- ns[[".package"]][["version"]]
[13:21:41.698]                             if (is.null(version)) 
[13:21:41.698]                               version <- utils::packageVersion("future")
[13:21:41.698]                           }
[13:21:41.698]                           else {
[13:21:41.698]                             version <- NULL
[13:21:41.698]                           }
[13:21:41.698]                           if (!has_future || version < "1.8.0") {
[13:21:41.698]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:41.698]                               "", base::R.version$version.string), 
[13:21:41.698]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:41.698]                                 base::R.version$platform, 8 * 
[13:21:41.698]                                   base::.Machine$sizeof.pointer), 
[13:21:41.698]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:41.698]                                 "release", "version")], collapse = " "), 
[13:21:41.698]                               hostname = base::Sys.info()[["nodename"]])
[13:21:41.698]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:41.698]                               info)
[13:21:41.698]                             info <- base::paste(info, collapse = "; ")
[13:21:41.698]                             if (!has_future) {
[13:21:41.698]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:41.698]                                 info)
[13:21:41.698]                             }
[13:21:41.698]                             else {
[13:21:41.698]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:41.698]                                 info, version)
[13:21:41.698]                             }
[13:21:41.698]                             base::stop(msg)
[13:21:41.698]                           }
[13:21:41.698]                         })
[13:21:41.698]                       }
[13:21:41.698]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:41.698]                       base::options(mc.cores = 1L)
[13:21:41.698]                     }
[13:21:41.698]                     base::local({
[13:21:41.698]                       for (pkg in "future.apply") {
[13:21:41.698]                         base::loadNamespace(pkg)
[13:21:41.698]                         base::library(pkg, character.only = TRUE)
[13:21:41.698]                       }
[13:21:41.698]                     })
[13:21:41.698]                   }
[13:21:41.698]                   options(future.plan = NULL)
[13:21:41.698]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.698]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:41.698]                 }
[13:21:41.698]                 ...future.workdir <- getwd()
[13:21:41.698]             }
[13:21:41.698]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:41.698]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:41.698]         }
[13:21:41.698]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:41.698]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:41.698]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:41.698]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:41.698]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:41.698]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:41.698]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:41.698]             base::names(...future.oldOptions))
[13:21:41.698]     }
[13:21:41.698]     if (FALSE) {
[13:21:41.698]     }
[13:21:41.698]     else {
[13:21:41.698]         if (TRUE) {
[13:21:41.698]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:41.698]                 open = "w")
[13:21:41.698]         }
[13:21:41.698]         else {
[13:21:41.698]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:41.698]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:41.698]         }
[13:21:41.698]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:41.698]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:41.698]             base::sink(type = "output", split = FALSE)
[13:21:41.698]             base::close(...future.stdout)
[13:21:41.698]         }, add = TRUE)
[13:21:41.698]     }
[13:21:41.698]     ...future.frame <- base::sys.nframe()
[13:21:41.698]     ...future.conditions <- base::list()
[13:21:41.698]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:41.698]     if (FALSE) {
[13:21:41.698]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:41.698]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:41.698]     }
[13:21:41.698]     ...future.result <- base::tryCatch({
[13:21:41.698]         base::withCallingHandlers({
[13:21:41.698]             ...future.value <- base::withVisible(base::local({
[13:21:41.698]                 ...future.makeSendCondition <- base::local({
[13:21:41.698]                   sendCondition <- NULL
[13:21:41.698]                   function(frame = 1L) {
[13:21:41.698]                     if (is.function(sendCondition)) 
[13:21:41.698]                       return(sendCondition)
[13:21:41.698]                     ns <- getNamespace("parallel")
[13:21:41.698]                     if (exists("sendData", mode = "function", 
[13:21:41.698]                       envir = ns)) {
[13:21:41.698]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:41.698]                         envir = ns)
[13:21:41.698]                       envir <- sys.frame(frame)
[13:21:41.698]                       master <- NULL
[13:21:41.698]                       while (!identical(envir, .GlobalEnv) && 
[13:21:41.698]                         !identical(envir, emptyenv())) {
[13:21:41.698]                         if (exists("master", mode = "list", envir = envir, 
[13:21:41.698]                           inherits = FALSE)) {
[13:21:41.698]                           master <- get("master", mode = "list", 
[13:21:41.698]                             envir = envir, inherits = FALSE)
[13:21:41.698]                           if (inherits(master, c("SOCKnode", 
[13:21:41.698]                             "SOCK0node"))) {
[13:21:41.698]                             sendCondition <<- function(cond) {
[13:21:41.698]                               data <- list(type = "VALUE", value = cond, 
[13:21:41.698]                                 success = TRUE)
[13:21:41.698]                               parallel_sendData(master, data)
[13:21:41.698]                             }
[13:21:41.698]                             return(sendCondition)
[13:21:41.698]                           }
[13:21:41.698]                         }
[13:21:41.698]                         frame <- frame + 1L
[13:21:41.698]                         envir <- sys.frame(frame)
[13:21:41.698]                       }
[13:21:41.698]                     }
[13:21:41.698]                     sendCondition <<- function(cond) NULL
[13:21:41.698]                   }
[13:21:41.698]                 })
[13:21:41.698]                 withCallingHandlers({
[13:21:41.698]                   {
[13:21:41.698]                     do.call(function(...) {
[13:21:41.698]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:41.698]                       if (!identical(...future.globals.maxSize.org, 
[13:21:41.698]                         ...future.globals.maxSize)) {
[13:21:41.698]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:41.698]                         on.exit(options(oopts), add = TRUE)
[13:21:41.698]                       }
[13:21:41.698]                       {
[13:21:41.698]                         lapply(seq_along(...future.elements_ii), 
[13:21:41.698]                           FUN = function(jj) {
[13:21:41.698]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:41.698]                             ...future.FUN(...future.X_jj, ...)
[13:21:41.698]                           })
[13:21:41.698]                       }
[13:21:41.698]                     }, args = future.call.arguments)
[13:21:41.698]                   }
[13:21:41.698]                 }, immediateCondition = function(cond) {
[13:21:41.698]                   sendCondition <- ...future.makeSendCondition()
[13:21:41.698]                   sendCondition(cond)
[13:21:41.698]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.698]                   {
[13:21:41.698]                     inherits <- base::inherits
[13:21:41.698]                     invokeRestart <- base::invokeRestart
[13:21:41.698]                     is.null <- base::is.null
[13:21:41.698]                     muffled <- FALSE
[13:21:41.698]                     if (inherits(cond, "message")) {
[13:21:41.698]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:41.698]                       if (muffled) 
[13:21:41.698]                         invokeRestart("muffleMessage")
[13:21:41.698]                     }
[13:21:41.698]                     else if (inherits(cond, "warning")) {
[13:21:41.698]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:41.698]                       if (muffled) 
[13:21:41.698]                         invokeRestart("muffleWarning")
[13:21:41.698]                     }
[13:21:41.698]                     else if (inherits(cond, "condition")) {
[13:21:41.698]                       if (!is.null(pattern)) {
[13:21:41.698]                         computeRestarts <- base::computeRestarts
[13:21:41.698]                         grepl <- base::grepl
[13:21:41.698]                         restarts <- computeRestarts(cond)
[13:21:41.698]                         for (restart in restarts) {
[13:21:41.698]                           name <- restart$name
[13:21:41.698]                           if (is.null(name)) 
[13:21:41.698]                             next
[13:21:41.698]                           if (!grepl(pattern, name)) 
[13:21:41.698]                             next
[13:21:41.698]                           invokeRestart(restart)
[13:21:41.698]                           muffled <- TRUE
[13:21:41.698]                           break
[13:21:41.698]                         }
[13:21:41.698]                       }
[13:21:41.698]                     }
[13:21:41.698]                     invisible(muffled)
[13:21:41.698]                   }
[13:21:41.698]                   muffleCondition(cond)
[13:21:41.698]                 })
[13:21:41.698]             }))
[13:21:41.698]             future::FutureResult(value = ...future.value$value, 
[13:21:41.698]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.698]                   ...future.rng), globalenv = if (FALSE) 
[13:21:41.698]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:41.698]                     ...future.globalenv.names))
[13:21:41.698]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:41.698]         }, condition = base::local({
[13:21:41.698]             c <- base::c
[13:21:41.698]             inherits <- base::inherits
[13:21:41.698]             invokeRestart <- base::invokeRestart
[13:21:41.698]             length <- base::length
[13:21:41.698]             list <- base::list
[13:21:41.698]             seq.int <- base::seq.int
[13:21:41.698]             signalCondition <- base::signalCondition
[13:21:41.698]             sys.calls <- base::sys.calls
[13:21:41.698]             `[[` <- base::`[[`
[13:21:41.698]             `+` <- base::`+`
[13:21:41.698]             `<<-` <- base::`<<-`
[13:21:41.698]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:41.698]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:41.698]                   3L)]
[13:21:41.698]             }
[13:21:41.698]             function(cond) {
[13:21:41.698]                 is_error <- inherits(cond, "error")
[13:21:41.698]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:41.698]                   NULL)
[13:21:41.698]                 if (is_error) {
[13:21:41.698]                   sessionInformation <- function() {
[13:21:41.698]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:41.698]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:41.698]                       search = base::search(), system = base::Sys.info())
[13:21:41.698]                   }
[13:21:41.698]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.698]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:41.698]                     cond$call), session = sessionInformation(), 
[13:21:41.698]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:41.698]                   signalCondition(cond)
[13:21:41.698]                 }
[13:21:41.698]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:41.698]                 "immediateCondition"))) {
[13:21:41.698]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:41.698]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.698]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:41.698]                   if (TRUE && !signal) {
[13:21:41.698]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.698]                     {
[13:21:41.698]                       inherits <- base::inherits
[13:21:41.698]                       invokeRestart <- base::invokeRestart
[13:21:41.698]                       is.null <- base::is.null
[13:21:41.698]                       muffled <- FALSE
[13:21:41.698]                       if (inherits(cond, "message")) {
[13:21:41.698]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.698]                         if (muffled) 
[13:21:41.698]                           invokeRestart("muffleMessage")
[13:21:41.698]                       }
[13:21:41.698]                       else if (inherits(cond, "warning")) {
[13:21:41.698]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.698]                         if (muffled) 
[13:21:41.698]                           invokeRestart("muffleWarning")
[13:21:41.698]                       }
[13:21:41.698]                       else if (inherits(cond, "condition")) {
[13:21:41.698]                         if (!is.null(pattern)) {
[13:21:41.698]                           computeRestarts <- base::computeRestarts
[13:21:41.698]                           grepl <- base::grepl
[13:21:41.698]                           restarts <- computeRestarts(cond)
[13:21:41.698]                           for (restart in restarts) {
[13:21:41.698]                             name <- restart$name
[13:21:41.698]                             if (is.null(name)) 
[13:21:41.698]                               next
[13:21:41.698]                             if (!grepl(pattern, name)) 
[13:21:41.698]                               next
[13:21:41.698]                             invokeRestart(restart)
[13:21:41.698]                             muffled <- TRUE
[13:21:41.698]                             break
[13:21:41.698]                           }
[13:21:41.698]                         }
[13:21:41.698]                       }
[13:21:41.698]                       invisible(muffled)
[13:21:41.698]                     }
[13:21:41.698]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.698]                   }
[13:21:41.698]                 }
[13:21:41.698]                 else {
[13:21:41.698]                   if (TRUE) {
[13:21:41.698]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.698]                     {
[13:21:41.698]                       inherits <- base::inherits
[13:21:41.698]                       invokeRestart <- base::invokeRestart
[13:21:41.698]                       is.null <- base::is.null
[13:21:41.698]                       muffled <- FALSE
[13:21:41.698]                       if (inherits(cond, "message")) {
[13:21:41.698]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.698]                         if (muffled) 
[13:21:41.698]                           invokeRestart("muffleMessage")
[13:21:41.698]                       }
[13:21:41.698]                       else if (inherits(cond, "warning")) {
[13:21:41.698]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.698]                         if (muffled) 
[13:21:41.698]                           invokeRestart("muffleWarning")
[13:21:41.698]                       }
[13:21:41.698]                       else if (inherits(cond, "condition")) {
[13:21:41.698]                         if (!is.null(pattern)) {
[13:21:41.698]                           computeRestarts <- base::computeRestarts
[13:21:41.698]                           grepl <- base::grepl
[13:21:41.698]                           restarts <- computeRestarts(cond)
[13:21:41.698]                           for (restart in restarts) {
[13:21:41.698]                             name <- restart$name
[13:21:41.698]                             if (is.null(name)) 
[13:21:41.698]                               next
[13:21:41.698]                             if (!grepl(pattern, name)) 
[13:21:41.698]                               next
[13:21:41.698]                             invokeRestart(restart)
[13:21:41.698]                             muffled <- TRUE
[13:21:41.698]                             break
[13:21:41.698]                           }
[13:21:41.698]                         }
[13:21:41.698]                       }
[13:21:41.698]                       invisible(muffled)
[13:21:41.698]                     }
[13:21:41.698]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.698]                   }
[13:21:41.698]                 }
[13:21:41.698]             }
[13:21:41.698]         }))
[13:21:41.698]     }, error = function(ex) {
[13:21:41.698]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:41.698]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.698]                 ...future.rng), started = ...future.startTime, 
[13:21:41.698]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:41.698]             version = "1.8"), class = "FutureResult")
[13:21:41.698]     }, finally = {
[13:21:41.698]         if (!identical(...future.workdir, getwd())) 
[13:21:41.698]             setwd(...future.workdir)
[13:21:41.698]         {
[13:21:41.698]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:41.698]                 ...future.oldOptions$nwarnings <- NULL
[13:21:41.698]             }
[13:21:41.698]             base::options(...future.oldOptions)
[13:21:41.698]             if (.Platform$OS.type == "windows") {
[13:21:41.698]                 old_names <- names(...future.oldEnvVars)
[13:21:41.698]                 envs <- base::Sys.getenv()
[13:21:41.698]                 names <- names(envs)
[13:21:41.698]                 common <- intersect(names, old_names)
[13:21:41.698]                 added <- setdiff(names, old_names)
[13:21:41.698]                 removed <- setdiff(old_names, names)
[13:21:41.698]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:41.698]                   envs[common]]
[13:21:41.698]                 NAMES <- toupper(changed)
[13:21:41.698]                 args <- list()
[13:21:41.698]                 for (kk in seq_along(NAMES)) {
[13:21:41.698]                   name <- changed[[kk]]
[13:21:41.698]                   NAME <- NAMES[[kk]]
[13:21:41.698]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.698]                     next
[13:21:41.698]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.698]                 }
[13:21:41.698]                 NAMES <- toupper(added)
[13:21:41.698]                 for (kk in seq_along(NAMES)) {
[13:21:41.698]                   name <- added[[kk]]
[13:21:41.698]                   NAME <- NAMES[[kk]]
[13:21:41.698]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.698]                     next
[13:21:41.698]                   args[[name]] <- ""
[13:21:41.698]                 }
[13:21:41.698]                 NAMES <- toupper(removed)
[13:21:41.698]                 for (kk in seq_along(NAMES)) {
[13:21:41.698]                   name <- removed[[kk]]
[13:21:41.698]                   NAME <- NAMES[[kk]]
[13:21:41.698]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.698]                     next
[13:21:41.698]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.698]                 }
[13:21:41.698]                 if (length(args) > 0) 
[13:21:41.698]                   base::do.call(base::Sys.setenv, args = args)
[13:21:41.698]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:41.698]             }
[13:21:41.698]             else {
[13:21:41.698]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:41.698]             }
[13:21:41.698]             {
[13:21:41.698]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:41.698]                   0L) {
[13:21:41.698]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:41.698]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:41.698]                   base::options(opts)
[13:21:41.698]                 }
[13:21:41.698]                 {
[13:21:41.698]                   {
[13:21:41.698]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:41.698]                     NULL
[13:21:41.698]                   }
[13:21:41.698]                   options(future.plan = NULL)
[13:21:41.698]                   if (is.na(NA_character_)) 
[13:21:41.698]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.698]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:41.698]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:41.698]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:41.698]                     envir = parent.frame()) 
[13:21:41.698]                   {
[13:21:41.698]                     if (is.function(workers)) 
[13:21:41.698]                       workers <- workers()
[13:21:41.698]                     workers <- structure(as.integer(workers), 
[13:21:41.698]                       class = class(workers))
[13:21:41.698]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:41.698]                       workers >= 1)
[13:21:41.698]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:41.698]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:41.698]                     }
[13:21:41.698]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:41.698]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:41.698]                       envir = envir)
[13:21:41.698]                     if (!future$lazy) 
[13:21:41.698]                       future <- run(future)
[13:21:41.698]                     invisible(future)
[13:21:41.698]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:41.698]                 }
[13:21:41.698]             }
[13:21:41.698]         }
[13:21:41.698]     })
[13:21:41.698]     if (TRUE) {
[13:21:41.698]         base::sink(type = "output", split = FALSE)
[13:21:41.698]         if (TRUE) {
[13:21:41.698]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:41.698]         }
[13:21:41.698]         else {
[13:21:41.698]             ...future.result["stdout"] <- base::list(NULL)
[13:21:41.698]         }
[13:21:41.698]         base::close(...future.stdout)
[13:21:41.698]         ...future.stdout <- NULL
[13:21:41.698]     }
[13:21:41.698]     ...future.result$conditions <- ...future.conditions
[13:21:41.698]     ...future.result$finished <- base::Sys.time()
[13:21:41.698]     ...future.result
[13:21:41.698] }
[13:21:41.701] Exporting 11 global objects (91.99 KiB) to cluster node #2 ...
[13:21:41.702] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[13:21:41.744] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[13:21:41.745] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[13:21:41.745] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[13:21:41.745] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[13:21:41.746] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[13:21:41.746] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[13:21:41.788] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[13:21:41.789] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[13:21:41.832] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[13:21:41.833] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[13:21:41.833] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[13:21:41.833] Exporting ‘valid_types’ (112 bytes) to cluster node #2 ...
[13:21:41.834] Exporting ‘valid_types’ (112 bytes) to cluster node #2 ... DONE
[13:21:41.834] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:21:41.834] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:21:41.835] Exporting ‘...future.elements_ii’ (1.48 KiB) to cluster node #2 ...
[13:21:41.835] Exporting ‘...future.elements_ii’ (1.48 KiB) to cluster node #2 ... DONE
[13:21:41.835] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:21:41.835] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:21:41.836] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:21:41.836] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:21:41.836] Exporting 11 global objects (91.99 KiB) to cluster node #2 ... DONE
[13:21:41.837] MultisessionFuture started
[13:21:41.837] - Launch lazy future ... done
[13:21:41.837] run() for ‘MultisessionFuture’ ... done
[13:21:41.837] Created future:
[13:21:41.837] MultisessionFuture:
[13:21:41.837] Label: ‘future_vapply-2’
[13:21:41.837] Expression:
[13:21:41.837] {
[13:21:41.837]     do.call(function(...) {
[13:21:41.837]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:41.837]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:41.837]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:41.837]             on.exit(options(oopts), add = TRUE)
[13:21:41.837]         }
[13:21:41.837]         {
[13:21:41.837]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:41.837]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:41.837]                 ...future.FUN(...future.X_jj, ...)
[13:21:41.837]             })
[13:21:41.837]         }
[13:21:41.837]     }, args = future.call.arguments)
[13:21:41.837] }
[13:21:41.837] Lazy evaluation: FALSE
[13:21:41.837] Asynchronous evaluation: TRUE
[13:21:41.837] Local evaluation: TRUE
[13:21:41.837] Environment: R_GlobalEnv
[13:21:41.837] Capture standard output: TRUE
[13:21:41.837] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:41.837] Globals: 11 objects totaling 93.48 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:41.837] Packages: 1 packages (‘future.apply’)
[13:21:41.837] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:41.837] Resolved: FALSE
[13:21:41.837] Value: <not collected>
[13:21:41.837] Conditions captured: <none>
[13:21:41.837] Early signaling: FALSE
[13:21:41.837] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:41.837] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:41.849] Chunk #2 of 2 ... DONE
[13:21:41.849] Launching 2 futures (chunks) ... DONE
[13:21:41.849] Resolving 2 futures (chunks) ...
[13:21:41.850] resolve() on list ...
[13:21:41.850]  recursive: 0
[13:21:41.850]  length: 2
[13:21:41.850] 
[13:21:41.851] receiveMessageFromWorker() for ClusterFuture ...
[13:21:41.851] - Validating connection of MultisessionFuture
[13:21:41.851] - received message: FutureResult
[13:21:41.851] - Received FutureResult
[13:21:41.851] - Erased future from FutureRegistry
[13:21:41.851] result() for ClusterFuture ...
[13:21:41.851] - result already collected: FutureResult
[13:21:41.851] result() for ClusterFuture ... done
[13:21:41.851] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:41.852] Future #1
[13:21:41.852] result() for ClusterFuture ...
[13:21:41.852] - result already collected: FutureResult
[13:21:41.852] result() for ClusterFuture ... done
[13:21:41.852] result() for ClusterFuture ...
[13:21:41.852] - result already collected: FutureResult
[13:21:41.852] result() for ClusterFuture ... done
[13:21:41.852] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:21:41.852] - nx: 2
[13:21:41.852] - relay: TRUE
[13:21:41.853] - stdout: TRUE
[13:21:41.853] - signal: TRUE
[13:21:41.853] - resignal: FALSE
[13:21:41.853] - force: TRUE
[13:21:41.853] - relayed: [n=2] FALSE, FALSE
[13:21:41.853] - queued futures: [n=2] FALSE, FALSE
[13:21:41.853]  - until=1
[13:21:41.853]  - relaying element #1
[13:21:41.853] result() for ClusterFuture ...
[13:21:41.853] - result already collected: FutureResult
[13:21:41.853] result() for ClusterFuture ... done
[13:21:41.854] result() for ClusterFuture ...
[13:21:41.854] - result already collected: FutureResult
[13:21:41.854] result() for ClusterFuture ... done
[13:21:41.854] result() for ClusterFuture ...
[13:21:41.854] - result already collected: FutureResult
[13:21:41.854] result() for ClusterFuture ... done
[13:21:41.854] result() for ClusterFuture ...
[13:21:41.854] - result already collected: FutureResult
[13:21:41.854] result() for ClusterFuture ... done
[13:21:41.854] - relayed: [n=2] TRUE, FALSE
[13:21:41.854] - queued futures: [n=2] TRUE, FALSE
[13:21:41.854] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:21:41.855]  length: 1 (resolved future 1)
[13:21:41.885] receiveMessageFromWorker() for ClusterFuture ...
[13:21:41.886] - Validating connection of MultisessionFuture
[13:21:41.886] - received message: FutureResult
[13:21:41.886] - Received FutureResult
[13:21:41.886] - Erased future from FutureRegistry
[13:21:41.886] result() for ClusterFuture ...
[13:21:41.886] - result already collected: FutureResult
[13:21:41.886] result() for ClusterFuture ... done
[13:21:41.886] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:41.887] Future #2
[13:21:41.887] result() for ClusterFuture ...
[13:21:41.887] - result already collected: FutureResult
[13:21:41.887] result() for ClusterFuture ... done
[13:21:41.887] result() for ClusterFuture ...
[13:21:41.887] - result already collected: FutureResult
[13:21:41.887] result() for ClusterFuture ... done
[13:21:41.887] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:21:41.887] - nx: 2
[13:21:41.887] - relay: TRUE
[13:21:41.887] - stdout: TRUE
[13:21:41.888] - signal: TRUE
[13:21:41.888] - resignal: FALSE
[13:21:41.888] - force: TRUE
[13:21:41.888] - relayed: [n=2] TRUE, FALSE
[13:21:41.888] - queued futures: [n=2] TRUE, FALSE
[13:21:41.888]  - until=2
[13:21:41.888]  - relaying element #2
[13:21:41.888] result() for ClusterFuture ...
[13:21:41.888] - result already collected: FutureResult
[13:21:41.888] result() for ClusterFuture ... done
[13:21:41.888] result() for ClusterFuture ...
[13:21:41.889] - result already collected: FutureResult
[13:21:41.889] result() for ClusterFuture ... done
[13:21:41.889] result() for ClusterFuture ...
[13:21:41.889] - result already collected: FutureResult
[13:21:41.889] result() for ClusterFuture ... done
[13:21:41.889] result() for ClusterFuture ...
[13:21:41.889] - result already collected: FutureResult
[13:21:41.889] result() for ClusterFuture ... done
[13:21:41.889] - relayed: [n=2] TRUE, TRUE
[13:21:41.889] - queued futures: [n=2] TRUE, TRUE
[13:21:41.889] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:21:41.890]  length: 0 (resolved future 2)
[13:21:41.890] Relaying remaining futures
[13:21:41.890] signalConditionsASAP(NULL, pos=0) ...
[13:21:41.890] - nx: 2
[13:21:41.890] - relay: TRUE
[13:21:41.890] - stdout: TRUE
[13:21:41.890] - signal: TRUE
[13:21:41.890] - resignal: FALSE
[13:21:41.890] - force: TRUE
[13:21:41.890] - relayed: [n=2] TRUE, TRUE
[13:21:41.890] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:21:41.891] - relayed: [n=2] TRUE, TRUE
[13:21:41.891] - queued futures: [n=2] TRUE, TRUE
[13:21:41.891] signalConditionsASAP(NULL, pos=0) ... done
[13:21:41.891] resolve() on list ... DONE
[13:21:41.891] result() for ClusterFuture ...
[13:21:41.891] - result already collected: FutureResult
[13:21:41.891] result() for ClusterFuture ... done
[13:21:41.891] result() for ClusterFuture ...
[13:21:41.891] - result already collected: FutureResult
[13:21:41.891] result() for ClusterFuture ... done
[13:21:41.891] result() for ClusterFuture ...
[13:21:41.892] - result already collected: FutureResult
[13:21:41.892] result() for ClusterFuture ... done
[13:21:41.892] result() for ClusterFuture ...
[13:21:41.892] - result already collected: FutureResult
[13:21:41.892] result() for ClusterFuture ... done
[13:21:41.892]  - Number of value chunks collected: 2
[13:21:41.892] Resolving 2 futures (chunks) ... DONE
[13:21:41.892] Reducing values from 2 chunks ...
[13:21:41.892]  - Number of values collected after concatenation: 11
[13:21:41.892]  - Number of values expected: 11
[13:21:41.892] Reducing values from 2 chunks ... DONE
[13:21:41.893] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[13:21:41.894] future_lapply() ...
[13:21:41.899] Number of chunks: 2
[13:21:41.899] getGlobalsAndPackagesXApply() ...
[13:21:41.899]  - future.globals: TRUE
[13:21:41.900] getGlobalsAndPackages() ...
[13:21:41.900] Searching for globals...
[13:21:41.903] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:21:41.903] Searching for globals ... DONE
[13:21:41.903] Resolving globals: FALSE
[13:21:41.904] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[13:21:41.904] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:41.904] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:41.905] - packages: [1] ‘future.apply’
[13:21:41.905] getGlobalsAndPackages() ... DONE
[13:21:41.905]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:41.905]  - needed namespaces: [n=1] ‘future.apply’
[13:21:41.905] Finding globals ... DONE
[13:21:41.905]  - use_args: TRUE
[13:21:41.905]  - Getting '...' globals ...
[13:21:41.905] resolve() on list ...
[13:21:41.906]  recursive: 0
[13:21:41.906]  length: 1
[13:21:41.906]  elements: ‘...’
[13:21:41.906]  length: 0 (resolved future 1)
[13:21:41.906] resolve() on list ... DONE
[13:21:41.906]    - '...' content: [n=0] 
[13:21:41.906] List of 1
[13:21:41.906]  $ ...: list()
[13:21:41.906]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:41.906]  - attr(*, "where")=List of 1
[13:21:41.906]   ..$ ...:<environment: 0x563b7023eec0> 
[13:21:41.906]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:41.906]  - attr(*, "resolved")= logi TRUE
[13:21:41.906]  - attr(*, "total_size")= num NA
[13:21:41.909]  - Getting '...' globals ... DONE
[13:21:41.909] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:41.909] List of 8
[13:21:41.909]  $ ...future.FUN:function (x, ...)  
[13:21:41.909]  $ x_FUN        :function (x)  
[13:21:41.909]  $ times        : int 1
[13:21:41.909]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:41.909]  $ stop_if_not  :function (...)  
[13:21:41.909]  $ dim          : NULL
[13:21:41.909]  $ valid_types  : chr [1:2] "logical" "integer"
[13:21:41.909]  $ ...          : list()
[13:21:41.909]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:41.909]  - attr(*, "where")=List of 8
[13:21:41.909]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:41.909]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:41.909]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:41.909]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:41.909]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:41.909]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:41.909]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:41.909]   ..$ ...          :<environment: 0x563b7023eec0> 
[13:21:41.909]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:41.909]  - attr(*, "resolved")= logi FALSE
[13:21:41.909]  - attr(*, "total_size")= num 94264
[13:21:41.914] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:21:41.914] getGlobalsAndPackagesXApply() ... DONE
[13:21:41.915] Number of futures (= number of chunks): 2
[13:21:41.915] Launching 2 futures (chunks) ...
[13:21:41.915] Chunk #1 of 2 ...
[13:21:41.915]  - Finding globals in 'X' for chunk #1 ...
[13:21:41.915] getGlobalsAndPackages() ...
[13:21:41.915] Searching for globals...
[13:21:41.915] 
[13:21:41.915] Searching for globals ... DONE
[13:21:41.916] - globals: [0] <none>
[13:21:41.916] getGlobalsAndPackages() ... DONE
[13:21:41.916]    + additional globals found: [n=0] 
[13:21:41.916]    + additional namespaces needed: [n=0] 
[13:21:41.916]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:41.916]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:41.916]  - seeds: <none>
[13:21:41.916]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:41.916] getGlobalsAndPackages() ...
[13:21:41.916] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:41.917] Resolving globals: FALSE
[13:21:41.917] Tweak future expression to call with '...' arguments ...
[13:21:41.917] {
[13:21:41.917]     do.call(function(...) {
[13:21:41.917]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:41.917]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:41.917]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:41.917]             on.exit(options(oopts), add = TRUE)
[13:21:41.917]         }
[13:21:41.917]         {
[13:21:41.917]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:41.917]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:41.917]                 ...future.FUN(...future.X_jj, ...)
[13:21:41.917]             })
[13:21:41.917]         }
[13:21:41.917]     }, args = future.call.arguments)
[13:21:41.917] }
[13:21:41.917] Tweak future expression to call with '...' arguments ... DONE
[13:21:41.918] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:41.918] - packages: [1] ‘future.apply’
[13:21:41.918] getGlobalsAndPackages() ... DONE
[13:21:41.918] run() for ‘Future’ ...
[13:21:41.918] - state: ‘created’
[13:21:41.918] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:41.933] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:41.933] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:41.933]   - Field: ‘node’
[13:21:41.933]   - Field: ‘label’
[13:21:41.933]   - Field: ‘local’
[13:21:41.934]   - Field: ‘owner’
[13:21:41.934]   - Field: ‘envir’
[13:21:41.934]   - Field: ‘workers’
[13:21:41.934]   - Field: ‘packages’
[13:21:41.934]   - Field: ‘gc’
[13:21:41.934]   - Field: ‘conditions’
[13:21:41.934]   - Field: ‘persistent’
[13:21:41.934]   - Field: ‘expr’
[13:21:41.934]   - Field: ‘uuid’
[13:21:41.934]   - Field: ‘seed’
[13:21:41.934]   - Field: ‘version’
[13:21:41.935]   - Field: ‘result’
[13:21:41.935]   - Field: ‘asynchronous’
[13:21:41.935]   - Field: ‘calls’
[13:21:41.935]   - Field: ‘globals’
[13:21:41.935]   - Field: ‘stdout’
[13:21:41.935]   - Field: ‘earlySignal’
[13:21:41.935]   - Field: ‘lazy’
[13:21:41.935]   - Field: ‘state’
[13:21:41.935] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:41.935] - Launch lazy future ...
[13:21:41.936] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:41.936] Packages needed by future strategies (n = 0): <none>
[13:21:41.936] {
[13:21:41.936]     {
[13:21:41.936]         {
[13:21:41.936]             ...future.startTime <- base::Sys.time()
[13:21:41.936]             {
[13:21:41.936]                 {
[13:21:41.936]                   {
[13:21:41.936]                     {
[13:21:41.936]                       {
[13:21:41.936]                         base::local({
[13:21:41.936]                           has_future <- base::requireNamespace("future", 
[13:21:41.936]                             quietly = TRUE)
[13:21:41.936]                           if (has_future) {
[13:21:41.936]                             ns <- base::getNamespace("future")
[13:21:41.936]                             version <- ns[[".package"]][["version"]]
[13:21:41.936]                             if (is.null(version)) 
[13:21:41.936]                               version <- utils::packageVersion("future")
[13:21:41.936]                           }
[13:21:41.936]                           else {
[13:21:41.936]                             version <- NULL
[13:21:41.936]                           }
[13:21:41.936]                           if (!has_future || version < "1.8.0") {
[13:21:41.936]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:41.936]                               "", base::R.version$version.string), 
[13:21:41.936]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:41.936]                                 base::R.version$platform, 8 * 
[13:21:41.936]                                   base::.Machine$sizeof.pointer), 
[13:21:41.936]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:41.936]                                 "release", "version")], collapse = " "), 
[13:21:41.936]                               hostname = base::Sys.info()[["nodename"]])
[13:21:41.936]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:41.936]                               info)
[13:21:41.936]                             info <- base::paste(info, collapse = "; ")
[13:21:41.936]                             if (!has_future) {
[13:21:41.936]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:41.936]                                 info)
[13:21:41.936]                             }
[13:21:41.936]                             else {
[13:21:41.936]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:41.936]                                 info, version)
[13:21:41.936]                             }
[13:21:41.936]                             base::stop(msg)
[13:21:41.936]                           }
[13:21:41.936]                         })
[13:21:41.936]                       }
[13:21:41.936]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:41.936]                       base::options(mc.cores = 1L)
[13:21:41.936]                     }
[13:21:41.936]                     base::local({
[13:21:41.936]                       for (pkg in "future.apply") {
[13:21:41.936]                         base::loadNamespace(pkg)
[13:21:41.936]                         base::library(pkg, character.only = TRUE)
[13:21:41.936]                       }
[13:21:41.936]                     })
[13:21:41.936]                   }
[13:21:41.936]                   options(future.plan = NULL)
[13:21:41.936]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.936]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:41.936]                 }
[13:21:41.936]                 ...future.workdir <- getwd()
[13:21:41.936]             }
[13:21:41.936]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:41.936]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:41.936]         }
[13:21:41.936]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:41.936]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:41.936]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:41.936]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:41.936]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:41.936]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:41.936]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:41.936]             base::names(...future.oldOptions))
[13:21:41.936]     }
[13:21:41.936]     if (FALSE) {
[13:21:41.936]     }
[13:21:41.936]     else {
[13:21:41.936]         if (TRUE) {
[13:21:41.936]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:41.936]                 open = "w")
[13:21:41.936]         }
[13:21:41.936]         else {
[13:21:41.936]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:41.936]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:41.936]         }
[13:21:41.936]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:41.936]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:41.936]             base::sink(type = "output", split = FALSE)
[13:21:41.936]             base::close(...future.stdout)
[13:21:41.936]         }, add = TRUE)
[13:21:41.936]     }
[13:21:41.936]     ...future.frame <- base::sys.nframe()
[13:21:41.936]     ...future.conditions <- base::list()
[13:21:41.936]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:41.936]     if (FALSE) {
[13:21:41.936]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:41.936]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:41.936]     }
[13:21:41.936]     ...future.result <- base::tryCatch({
[13:21:41.936]         base::withCallingHandlers({
[13:21:41.936]             ...future.value <- base::withVisible(base::local({
[13:21:41.936]                 ...future.makeSendCondition <- base::local({
[13:21:41.936]                   sendCondition <- NULL
[13:21:41.936]                   function(frame = 1L) {
[13:21:41.936]                     if (is.function(sendCondition)) 
[13:21:41.936]                       return(sendCondition)
[13:21:41.936]                     ns <- getNamespace("parallel")
[13:21:41.936]                     if (exists("sendData", mode = "function", 
[13:21:41.936]                       envir = ns)) {
[13:21:41.936]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:41.936]                         envir = ns)
[13:21:41.936]                       envir <- sys.frame(frame)
[13:21:41.936]                       master <- NULL
[13:21:41.936]                       while (!identical(envir, .GlobalEnv) && 
[13:21:41.936]                         !identical(envir, emptyenv())) {
[13:21:41.936]                         if (exists("master", mode = "list", envir = envir, 
[13:21:41.936]                           inherits = FALSE)) {
[13:21:41.936]                           master <- get("master", mode = "list", 
[13:21:41.936]                             envir = envir, inherits = FALSE)
[13:21:41.936]                           if (inherits(master, c("SOCKnode", 
[13:21:41.936]                             "SOCK0node"))) {
[13:21:41.936]                             sendCondition <<- function(cond) {
[13:21:41.936]                               data <- list(type = "VALUE", value = cond, 
[13:21:41.936]                                 success = TRUE)
[13:21:41.936]                               parallel_sendData(master, data)
[13:21:41.936]                             }
[13:21:41.936]                             return(sendCondition)
[13:21:41.936]                           }
[13:21:41.936]                         }
[13:21:41.936]                         frame <- frame + 1L
[13:21:41.936]                         envir <- sys.frame(frame)
[13:21:41.936]                       }
[13:21:41.936]                     }
[13:21:41.936]                     sendCondition <<- function(cond) NULL
[13:21:41.936]                   }
[13:21:41.936]                 })
[13:21:41.936]                 withCallingHandlers({
[13:21:41.936]                   {
[13:21:41.936]                     do.call(function(...) {
[13:21:41.936]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:41.936]                       if (!identical(...future.globals.maxSize.org, 
[13:21:41.936]                         ...future.globals.maxSize)) {
[13:21:41.936]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:41.936]                         on.exit(options(oopts), add = TRUE)
[13:21:41.936]                       }
[13:21:41.936]                       {
[13:21:41.936]                         lapply(seq_along(...future.elements_ii), 
[13:21:41.936]                           FUN = function(jj) {
[13:21:41.936]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:41.936]                             ...future.FUN(...future.X_jj, ...)
[13:21:41.936]                           })
[13:21:41.936]                       }
[13:21:41.936]                     }, args = future.call.arguments)
[13:21:41.936]                   }
[13:21:41.936]                 }, immediateCondition = function(cond) {
[13:21:41.936]                   sendCondition <- ...future.makeSendCondition()
[13:21:41.936]                   sendCondition(cond)
[13:21:41.936]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.936]                   {
[13:21:41.936]                     inherits <- base::inherits
[13:21:41.936]                     invokeRestart <- base::invokeRestart
[13:21:41.936]                     is.null <- base::is.null
[13:21:41.936]                     muffled <- FALSE
[13:21:41.936]                     if (inherits(cond, "message")) {
[13:21:41.936]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:41.936]                       if (muffled) 
[13:21:41.936]                         invokeRestart("muffleMessage")
[13:21:41.936]                     }
[13:21:41.936]                     else if (inherits(cond, "warning")) {
[13:21:41.936]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:41.936]                       if (muffled) 
[13:21:41.936]                         invokeRestart("muffleWarning")
[13:21:41.936]                     }
[13:21:41.936]                     else if (inherits(cond, "condition")) {
[13:21:41.936]                       if (!is.null(pattern)) {
[13:21:41.936]                         computeRestarts <- base::computeRestarts
[13:21:41.936]                         grepl <- base::grepl
[13:21:41.936]                         restarts <- computeRestarts(cond)
[13:21:41.936]                         for (restart in restarts) {
[13:21:41.936]                           name <- restart$name
[13:21:41.936]                           if (is.null(name)) 
[13:21:41.936]                             next
[13:21:41.936]                           if (!grepl(pattern, name)) 
[13:21:41.936]                             next
[13:21:41.936]                           invokeRestart(restart)
[13:21:41.936]                           muffled <- TRUE
[13:21:41.936]                           break
[13:21:41.936]                         }
[13:21:41.936]                       }
[13:21:41.936]                     }
[13:21:41.936]                     invisible(muffled)
[13:21:41.936]                   }
[13:21:41.936]                   muffleCondition(cond)
[13:21:41.936]                 })
[13:21:41.936]             }))
[13:21:41.936]             future::FutureResult(value = ...future.value$value, 
[13:21:41.936]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.936]                   ...future.rng), globalenv = if (FALSE) 
[13:21:41.936]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:41.936]                     ...future.globalenv.names))
[13:21:41.936]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:41.936]         }, condition = base::local({
[13:21:41.936]             c <- base::c
[13:21:41.936]             inherits <- base::inherits
[13:21:41.936]             invokeRestart <- base::invokeRestart
[13:21:41.936]             length <- base::length
[13:21:41.936]             list <- base::list
[13:21:41.936]             seq.int <- base::seq.int
[13:21:41.936]             signalCondition <- base::signalCondition
[13:21:41.936]             sys.calls <- base::sys.calls
[13:21:41.936]             `[[` <- base::`[[`
[13:21:41.936]             `+` <- base::`+`
[13:21:41.936]             `<<-` <- base::`<<-`
[13:21:41.936]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:41.936]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:41.936]                   3L)]
[13:21:41.936]             }
[13:21:41.936]             function(cond) {
[13:21:41.936]                 is_error <- inherits(cond, "error")
[13:21:41.936]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:41.936]                   NULL)
[13:21:41.936]                 if (is_error) {
[13:21:41.936]                   sessionInformation <- function() {
[13:21:41.936]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:41.936]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:41.936]                       search = base::search(), system = base::Sys.info())
[13:21:41.936]                   }
[13:21:41.936]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.936]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:41.936]                     cond$call), session = sessionInformation(), 
[13:21:41.936]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:41.936]                   signalCondition(cond)
[13:21:41.936]                 }
[13:21:41.936]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:41.936]                 "immediateCondition"))) {
[13:21:41.936]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:41.936]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.936]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:41.936]                   if (TRUE && !signal) {
[13:21:41.936]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.936]                     {
[13:21:41.936]                       inherits <- base::inherits
[13:21:41.936]                       invokeRestart <- base::invokeRestart
[13:21:41.936]                       is.null <- base::is.null
[13:21:41.936]                       muffled <- FALSE
[13:21:41.936]                       if (inherits(cond, "message")) {
[13:21:41.936]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.936]                         if (muffled) 
[13:21:41.936]                           invokeRestart("muffleMessage")
[13:21:41.936]                       }
[13:21:41.936]                       else if (inherits(cond, "warning")) {
[13:21:41.936]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.936]                         if (muffled) 
[13:21:41.936]                           invokeRestart("muffleWarning")
[13:21:41.936]                       }
[13:21:41.936]                       else if (inherits(cond, "condition")) {
[13:21:41.936]                         if (!is.null(pattern)) {
[13:21:41.936]                           computeRestarts <- base::computeRestarts
[13:21:41.936]                           grepl <- base::grepl
[13:21:41.936]                           restarts <- computeRestarts(cond)
[13:21:41.936]                           for (restart in restarts) {
[13:21:41.936]                             name <- restart$name
[13:21:41.936]                             if (is.null(name)) 
[13:21:41.936]                               next
[13:21:41.936]                             if (!grepl(pattern, name)) 
[13:21:41.936]                               next
[13:21:41.936]                             invokeRestart(restart)
[13:21:41.936]                             muffled <- TRUE
[13:21:41.936]                             break
[13:21:41.936]                           }
[13:21:41.936]                         }
[13:21:41.936]                       }
[13:21:41.936]                       invisible(muffled)
[13:21:41.936]                     }
[13:21:41.936]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.936]                   }
[13:21:41.936]                 }
[13:21:41.936]                 else {
[13:21:41.936]                   if (TRUE) {
[13:21:41.936]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.936]                     {
[13:21:41.936]                       inherits <- base::inherits
[13:21:41.936]                       invokeRestart <- base::invokeRestart
[13:21:41.936]                       is.null <- base::is.null
[13:21:41.936]                       muffled <- FALSE
[13:21:41.936]                       if (inherits(cond, "message")) {
[13:21:41.936]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.936]                         if (muffled) 
[13:21:41.936]                           invokeRestart("muffleMessage")
[13:21:41.936]                       }
[13:21:41.936]                       else if (inherits(cond, "warning")) {
[13:21:41.936]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.936]                         if (muffled) 
[13:21:41.936]                           invokeRestart("muffleWarning")
[13:21:41.936]                       }
[13:21:41.936]                       else if (inherits(cond, "condition")) {
[13:21:41.936]                         if (!is.null(pattern)) {
[13:21:41.936]                           computeRestarts <- base::computeRestarts
[13:21:41.936]                           grepl <- base::grepl
[13:21:41.936]                           restarts <- computeRestarts(cond)
[13:21:41.936]                           for (restart in restarts) {
[13:21:41.936]                             name <- restart$name
[13:21:41.936]                             if (is.null(name)) 
[13:21:41.936]                               next
[13:21:41.936]                             if (!grepl(pattern, name)) 
[13:21:41.936]                               next
[13:21:41.936]                             invokeRestart(restart)
[13:21:41.936]                             muffled <- TRUE
[13:21:41.936]                             break
[13:21:41.936]                           }
[13:21:41.936]                         }
[13:21:41.936]                       }
[13:21:41.936]                       invisible(muffled)
[13:21:41.936]                     }
[13:21:41.936]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.936]                   }
[13:21:41.936]                 }
[13:21:41.936]             }
[13:21:41.936]         }))
[13:21:41.936]     }, error = function(ex) {
[13:21:41.936]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:41.936]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.936]                 ...future.rng), started = ...future.startTime, 
[13:21:41.936]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:41.936]             version = "1.8"), class = "FutureResult")
[13:21:41.936]     }, finally = {
[13:21:41.936]         if (!identical(...future.workdir, getwd())) 
[13:21:41.936]             setwd(...future.workdir)
[13:21:41.936]         {
[13:21:41.936]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:41.936]                 ...future.oldOptions$nwarnings <- NULL
[13:21:41.936]             }
[13:21:41.936]             base::options(...future.oldOptions)
[13:21:41.936]             if (.Platform$OS.type == "windows") {
[13:21:41.936]                 old_names <- names(...future.oldEnvVars)
[13:21:41.936]                 envs <- base::Sys.getenv()
[13:21:41.936]                 names <- names(envs)
[13:21:41.936]                 common <- intersect(names, old_names)
[13:21:41.936]                 added <- setdiff(names, old_names)
[13:21:41.936]                 removed <- setdiff(old_names, names)
[13:21:41.936]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:41.936]                   envs[common]]
[13:21:41.936]                 NAMES <- toupper(changed)
[13:21:41.936]                 args <- list()
[13:21:41.936]                 for (kk in seq_along(NAMES)) {
[13:21:41.936]                   name <- changed[[kk]]
[13:21:41.936]                   NAME <- NAMES[[kk]]
[13:21:41.936]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.936]                     next
[13:21:41.936]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.936]                 }
[13:21:41.936]                 NAMES <- toupper(added)
[13:21:41.936]                 for (kk in seq_along(NAMES)) {
[13:21:41.936]                   name <- added[[kk]]
[13:21:41.936]                   NAME <- NAMES[[kk]]
[13:21:41.936]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.936]                     next
[13:21:41.936]                   args[[name]] <- ""
[13:21:41.936]                 }
[13:21:41.936]                 NAMES <- toupper(removed)
[13:21:41.936]                 for (kk in seq_along(NAMES)) {
[13:21:41.936]                   name <- removed[[kk]]
[13:21:41.936]                   NAME <- NAMES[[kk]]
[13:21:41.936]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.936]                     next
[13:21:41.936]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.936]                 }
[13:21:41.936]                 if (length(args) > 0) 
[13:21:41.936]                   base::do.call(base::Sys.setenv, args = args)
[13:21:41.936]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:41.936]             }
[13:21:41.936]             else {
[13:21:41.936]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:41.936]             }
[13:21:41.936]             {
[13:21:41.936]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:41.936]                   0L) {
[13:21:41.936]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:41.936]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:41.936]                   base::options(opts)
[13:21:41.936]                 }
[13:21:41.936]                 {
[13:21:41.936]                   {
[13:21:41.936]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:41.936]                     NULL
[13:21:41.936]                   }
[13:21:41.936]                   options(future.plan = NULL)
[13:21:41.936]                   if (is.na(NA_character_)) 
[13:21:41.936]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.936]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:41.936]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:41.936]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:41.936]                     envir = parent.frame()) 
[13:21:41.936]                   {
[13:21:41.936]                     if (is.function(workers)) 
[13:21:41.936]                       workers <- workers()
[13:21:41.936]                     workers <- structure(as.integer(workers), 
[13:21:41.936]                       class = class(workers))
[13:21:41.936]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:41.936]                       workers >= 1)
[13:21:41.936]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:41.936]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:41.936]                     }
[13:21:41.936]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:41.936]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:41.936]                       envir = envir)
[13:21:41.936]                     if (!future$lazy) 
[13:21:41.936]                       future <- run(future)
[13:21:41.936]                     invisible(future)
[13:21:41.936]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:41.936]                 }
[13:21:41.936]             }
[13:21:41.936]         }
[13:21:41.936]     })
[13:21:41.936]     if (TRUE) {
[13:21:41.936]         base::sink(type = "output", split = FALSE)
[13:21:41.936]         if (TRUE) {
[13:21:41.936]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:41.936]         }
[13:21:41.936]         else {
[13:21:41.936]             ...future.result["stdout"] <- base::list(NULL)
[13:21:41.936]         }
[13:21:41.936]         base::close(...future.stdout)
[13:21:41.936]         ...future.stdout <- NULL
[13:21:41.936]     }
[13:21:41.936]     ...future.result$conditions <- ...future.conditions
[13:21:41.936]     ...future.result$finished <- base::Sys.time()
[13:21:41.936]     ...future.result
[13:21:41.936] }
[13:21:41.940] Exporting 11 global objects (92.05 KiB) to cluster node #1 ...
[13:21:41.940] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:21:41.984] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:21:41.985] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[13:21:41.985] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[13:21:41.985] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:21:41.986] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:21:41.986] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:21:42.028] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:21:42.029] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:21:42.072] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:21:42.072] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[13:21:42.073] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[13:21:42.073] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[13:21:42.074] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[13:21:42.074] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:21:42.074] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:21:42.074] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[13:21:42.075] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[13:21:42.075] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:21:42.075] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:21:42.075] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:21:42.076] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:21:42.076] Exporting 11 global objects (92.05 KiB) to cluster node #1 ... DONE
[13:21:42.077] MultisessionFuture started
[13:21:42.077] - Launch lazy future ... done
[13:21:42.077] run() for ‘MultisessionFuture’ ... done
[13:21:42.077] Created future:
[13:21:42.077] MultisessionFuture:
[13:21:42.077] Label: ‘future_vapply-1’
[13:21:42.077] Expression:
[13:21:42.077] {
[13:21:42.077]     do.call(function(...) {
[13:21:42.077]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:42.077]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:42.077]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:42.077]             on.exit(options(oopts), add = TRUE)
[13:21:42.077]         }
[13:21:42.077]         {
[13:21:42.077]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:42.077]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:42.077]                 ...future.FUN(...future.X_jj, ...)
[13:21:42.077]             })
[13:21:42.077]         }
[13:21:42.077]     }, args = future.call.arguments)
[13:21:42.077] }
[13:21:42.077] Lazy evaluation: FALSE
[13:21:42.077] Asynchronous evaluation: TRUE
[13:21:42.077] Local evaluation: TRUE
[13:21:42.077] Environment: R_GlobalEnv
[13:21:42.077] Capture standard output: TRUE
[13:21:42.077] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:42.077] Globals: 11 objects totaling 92.11 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:42.077] Packages: 1 packages (‘future.apply’)
[13:21:42.077] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:42.077] Resolved: FALSE
[13:21:42.077] Value: <not collected>
[13:21:42.077] Conditions captured: <none>
[13:21:42.077] Early signaling: FALSE
[13:21:42.077] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:42.077] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:42.089] Chunk #1 of 2 ... DONE
[13:21:42.089] Chunk #2 of 2 ...
[13:21:42.089]  - Finding globals in 'X' for chunk #2 ...
[13:21:42.089] getGlobalsAndPackages() ...
[13:21:42.089] Searching for globals...
[13:21:42.090] 
[13:21:42.090] Searching for globals ... DONE
[13:21:42.090] - globals: [0] <none>
[13:21:42.090] getGlobalsAndPackages() ... DONE
[13:21:42.090]    + additional globals found: [n=0] 
[13:21:42.090]    + additional namespaces needed: [n=0] 
[13:21:42.090]  - Finding globals in 'X' for chunk #2 ... DONE
[13:21:42.090]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:42.090]  - seeds: <none>
[13:21:42.091]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:42.091] getGlobalsAndPackages() ...
[13:21:42.091] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:42.091] Resolving globals: FALSE
[13:21:42.091] Tweak future expression to call with '...' arguments ...
[13:21:42.091] {
[13:21:42.091]     do.call(function(...) {
[13:21:42.091]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:42.091]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:42.091]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:42.091]             on.exit(options(oopts), add = TRUE)
[13:21:42.091]         }
[13:21:42.091]         {
[13:21:42.091]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:42.091]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:42.091]                 ...future.FUN(...future.X_jj, ...)
[13:21:42.091]             })
[13:21:42.091]         }
[13:21:42.091]     }, args = future.call.arguments)
[13:21:42.091] }
[13:21:42.091] Tweak future expression to call with '...' arguments ... DONE
[13:21:42.095] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:42.095] - packages: [1] ‘future.apply’
[13:21:42.095] getGlobalsAndPackages() ... DONE
[13:21:42.095] run() for ‘Future’ ...
[13:21:42.095] - state: ‘created’
[13:21:42.096] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:42.110] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:42.110] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:42.110]   - Field: ‘node’
[13:21:42.110]   - Field: ‘label’
[13:21:42.110]   - Field: ‘local’
[13:21:42.111]   - Field: ‘owner’
[13:21:42.111]   - Field: ‘envir’
[13:21:42.111]   - Field: ‘workers’
[13:21:42.111]   - Field: ‘packages’
[13:21:42.111]   - Field: ‘gc’
[13:21:42.111]   - Field: ‘conditions’
[13:21:42.111]   - Field: ‘persistent’
[13:21:42.111]   - Field: ‘expr’
[13:21:42.111]   - Field: ‘uuid’
[13:21:42.111]   - Field: ‘seed’
[13:21:42.111]   - Field: ‘version’
[13:21:42.112]   - Field: ‘result’
[13:21:42.112]   - Field: ‘asynchronous’
[13:21:42.112]   - Field: ‘calls’
[13:21:42.112]   - Field: ‘globals’
[13:21:42.112]   - Field: ‘stdout’
[13:21:42.112]   - Field: ‘earlySignal’
[13:21:42.112]   - Field: ‘lazy’
[13:21:42.112]   - Field: ‘state’
[13:21:42.112] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:42.112] - Launch lazy future ...
[13:21:42.113] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:42.113] Packages needed by future strategies (n = 0): <none>
[13:21:42.113] {
[13:21:42.113]     {
[13:21:42.113]         {
[13:21:42.113]             ...future.startTime <- base::Sys.time()
[13:21:42.113]             {
[13:21:42.113]                 {
[13:21:42.113]                   {
[13:21:42.113]                     {
[13:21:42.113]                       {
[13:21:42.113]                         base::local({
[13:21:42.113]                           has_future <- base::requireNamespace("future", 
[13:21:42.113]                             quietly = TRUE)
[13:21:42.113]                           if (has_future) {
[13:21:42.113]                             ns <- base::getNamespace("future")
[13:21:42.113]                             version <- ns[[".package"]][["version"]]
[13:21:42.113]                             if (is.null(version)) 
[13:21:42.113]                               version <- utils::packageVersion("future")
[13:21:42.113]                           }
[13:21:42.113]                           else {
[13:21:42.113]                             version <- NULL
[13:21:42.113]                           }
[13:21:42.113]                           if (!has_future || version < "1.8.0") {
[13:21:42.113]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:42.113]                               "", base::R.version$version.string), 
[13:21:42.113]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:42.113]                                 base::R.version$platform, 8 * 
[13:21:42.113]                                   base::.Machine$sizeof.pointer), 
[13:21:42.113]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:42.113]                                 "release", "version")], collapse = " "), 
[13:21:42.113]                               hostname = base::Sys.info()[["nodename"]])
[13:21:42.113]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:42.113]                               info)
[13:21:42.113]                             info <- base::paste(info, collapse = "; ")
[13:21:42.113]                             if (!has_future) {
[13:21:42.113]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:42.113]                                 info)
[13:21:42.113]                             }
[13:21:42.113]                             else {
[13:21:42.113]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:42.113]                                 info, version)
[13:21:42.113]                             }
[13:21:42.113]                             base::stop(msg)
[13:21:42.113]                           }
[13:21:42.113]                         })
[13:21:42.113]                       }
[13:21:42.113]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:42.113]                       base::options(mc.cores = 1L)
[13:21:42.113]                     }
[13:21:42.113]                     base::local({
[13:21:42.113]                       for (pkg in "future.apply") {
[13:21:42.113]                         base::loadNamespace(pkg)
[13:21:42.113]                         base::library(pkg, character.only = TRUE)
[13:21:42.113]                       }
[13:21:42.113]                     })
[13:21:42.113]                   }
[13:21:42.113]                   options(future.plan = NULL)
[13:21:42.113]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:42.113]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:42.113]                 }
[13:21:42.113]                 ...future.workdir <- getwd()
[13:21:42.113]             }
[13:21:42.113]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:42.113]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:42.113]         }
[13:21:42.113]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:42.113]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:42.113]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:42.113]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:42.113]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:42.113]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:42.113]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:42.113]             base::names(...future.oldOptions))
[13:21:42.113]     }
[13:21:42.113]     if (FALSE) {
[13:21:42.113]     }
[13:21:42.113]     else {
[13:21:42.113]         if (TRUE) {
[13:21:42.113]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:42.113]                 open = "w")
[13:21:42.113]         }
[13:21:42.113]         else {
[13:21:42.113]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:42.113]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:42.113]         }
[13:21:42.113]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:42.113]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:42.113]             base::sink(type = "output", split = FALSE)
[13:21:42.113]             base::close(...future.stdout)
[13:21:42.113]         }, add = TRUE)
[13:21:42.113]     }
[13:21:42.113]     ...future.frame <- base::sys.nframe()
[13:21:42.113]     ...future.conditions <- base::list()
[13:21:42.113]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:42.113]     if (FALSE) {
[13:21:42.113]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:42.113]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:42.113]     }
[13:21:42.113]     ...future.result <- base::tryCatch({
[13:21:42.113]         base::withCallingHandlers({
[13:21:42.113]             ...future.value <- base::withVisible(base::local({
[13:21:42.113]                 ...future.makeSendCondition <- base::local({
[13:21:42.113]                   sendCondition <- NULL
[13:21:42.113]                   function(frame = 1L) {
[13:21:42.113]                     if (is.function(sendCondition)) 
[13:21:42.113]                       return(sendCondition)
[13:21:42.113]                     ns <- getNamespace("parallel")
[13:21:42.113]                     if (exists("sendData", mode = "function", 
[13:21:42.113]                       envir = ns)) {
[13:21:42.113]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:42.113]                         envir = ns)
[13:21:42.113]                       envir <- sys.frame(frame)
[13:21:42.113]                       master <- NULL
[13:21:42.113]                       while (!identical(envir, .GlobalEnv) && 
[13:21:42.113]                         !identical(envir, emptyenv())) {
[13:21:42.113]                         if (exists("master", mode = "list", envir = envir, 
[13:21:42.113]                           inherits = FALSE)) {
[13:21:42.113]                           master <- get("master", mode = "list", 
[13:21:42.113]                             envir = envir, inherits = FALSE)
[13:21:42.113]                           if (inherits(master, c("SOCKnode", 
[13:21:42.113]                             "SOCK0node"))) {
[13:21:42.113]                             sendCondition <<- function(cond) {
[13:21:42.113]                               data <- list(type = "VALUE", value = cond, 
[13:21:42.113]                                 success = TRUE)
[13:21:42.113]                               parallel_sendData(master, data)
[13:21:42.113]                             }
[13:21:42.113]                             return(sendCondition)
[13:21:42.113]                           }
[13:21:42.113]                         }
[13:21:42.113]                         frame <- frame + 1L
[13:21:42.113]                         envir <- sys.frame(frame)
[13:21:42.113]                       }
[13:21:42.113]                     }
[13:21:42.113]                     sendCondition <<- function(cond) NULL
[13:21:42.113]                   }
[13:21:42.113]                 })
[13:21:42.113]                 withCallingHandlers({
[13:21:42.113]                   {
[13:21:42.113]                     do.call(function(...) {
[13:21:42.113]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:42.113]                       if (!identical(...future.globals.maxSize.org, 
[13:21:42.113]                         ...future.globals.maxSize)) {
[13:21:42.113]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:42.113]                         on.exit(options(oopts), add = TRUE)
[13:21:42.113]                       }
[13:21:42.113]                       {
[13:21:42.113]                         lapply(seq_along(...future.elements_ii), 
[13:21:42.113]                           FUN = function(jj) {
[13:21:42.113]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:42.113]                             ...future.FUN(...future.X_jj, ...)
[13:21:42.113]                           })
[13:21:42.113]                       }
[13:21:42.113]                     }, args = future.call.arguments)
[13:21:42.113]                   }
[13:21:42.113]                 }, immediateCondition = function(cond) {
[13:21:42.113]                   sendCondition <- ...future.makeSendCondition()
[13:21:42.113]                   sendCondition(cond)
[13:21:42.113]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:42.113]                   {
[13:21:42.113]                     inherits <- base::inherits
[13:21:42.113]                     invokeRestart <- base::invokeRestart
[13:21:42.113]                     is.null <- base::is.null
[13:21:42.113]                     muffled <- FALSE
[13:21:42.113]                     if (inherits(cond, "message")) {
[13:21:42.113]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:42.113]                       if (muffled) 
[13:21:42.113]                         invokeRestart("muffleMessage")
[13:21:42.113]                     }
[13:21:42.113]                     else if (inherits(cond, "warning")) {
[13:21:42.113]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:42.113]                       if (muffled) 
[13:21:42.113]                         invokeRestart("muffleWarning")
[13:21:42.113]                     }
[13:21:42.113]                     else if (inherits(cond, "condition")) {
[13:21:42.113]                       if (!is.null(pattern)) {
[13:21:42.113]                         computeRestarts <- base::computeRestarts
[13:21:42.113]                         grepl <- base::grepl
[13:21:42.113]                         restarts <- computeRestarts(cond)
[13:21:42.113]                         for (restart in restarts) {
[13:21:42.113]                           name <- restart$name
[13:21:42.113]                           if (is.null(name)) 
[13:21:42.113]                             next
[13:21:42.113]                           if (!grepl(pattern, name)) 
[13:21:42.113]                             next
[13:21:42.113]                           invokeRestart(restart)
[13:21:42.113]                           muffled <- TRUE
[13:21:42.113]                           break
[13:21:42.113]                         }
[13:21:42.113]                       }
[13:21:42.113]                     }
[13:21:42.113]                     invisible(muffled)
[13:21:42.113]                   }
[13:21:42.113]                   muffleCondition(cond)
[13:21:42.113]                 })
[13:21:42.113]             }))
[13:21:42.113]             future::FutureResult(value = ...future.value$value, 
[13:21:42.113]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:42.113]                   ...future.rng), globalenv = if (FALSE) 
[13:21:42.113]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:42.113]                     ...future.globalenv.names))
[13:21:42.113]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:42.113]         }, condition = base::local({
[13:21:42.113]             c <- base::c
[13:21:42.113]             inherits <- base::inherits
[13:21:42.113]             invokeRestart <- base::invokeRestart
[13:21:42.113]             length <- base::length
[13:21:42.113]             list <- base::list
[13:21:42.113]             seq.int <- base::seq.int
[13:21:42.113]             signalCondition <- base::signalCondition
[13:21:42.113]             sys.calls <- base::sys.calls
[13:21:42.113]             `[[` <- base::`[[`
[13:21:42.113]             `+` <- base::`+`
[13:21:42.113]             `<<-` <- base::`<<-`
[13:21:42.113]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:42.113]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:42.113]                   3L)]
[13:21:42.113]             }
[13:21:42.113]             function(cond) {
[13:21:42.113]                 is_error <- inherits(cond, "error")
[13:21:42.113]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:42.113]                   NULL)
[13:21:42.113]                 if (is_error) {
[13:21:42.113]                   sessionInformation <- function() {
[13:21:42.113]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:42.113]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:42.113]                       search = base::search(), system = base::Sys.info())
[13:21:42.113]                   }
[13:21:42.113]                   ...future.conditions[[length(...future.conditions) + 
[13:21:42.113]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:42.113]                     cond$call), session = sessionInformation(), 
[13:21:42.113]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:42.113]                   signalCondition(cond)
[13:21:42.113]                 }
[13:21:42.113]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:42.113]                 "immediateCondition"))) {
[13:21:42.113]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:42.113]                   ...future.conditions[[length(...future.conditions) + 
[13:21:42.113]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:42.113]                   if (TRUE && !signal) {
[13:21:42.113]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:42.113]                     {
[13:21:42.113]                       inherits <- base::inherits
[13:21:42.113]                       invokeRestart <- base::invokeRestart
[13:21:42.113]                       is.null <- base::is.null
[13:21:42.113]                       muffled <- FALSE
[13:21:42.113]                       if (inherits(cond, "message")) {
[13:21:42.113]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:42.113]                         if (muffled) 
[13:21:42.113]                           invokeRestart("muffleMessage")
[13:21:42.113]                       }
[13:21:42.113]                       else if (inherits(cond, "warning")) {
[13:21:42.113]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:42.113]                         if (muffled) 
[13:21:42.113]                           invokeRestart("muffleWarning")
[13:21:42.113]                       }
[13:21:42.113]                       else if (inherits(cond, "condition")) {
[13:21:42.113]                         if (!is.null(pattern)) {
[13:21:42.113]                           computeRestarts <- base::computeRestarts
[13:21:42.113]                           grepl <- base::grepl
[13:21:42.113]                           restarts <- computeRestarts(cond)
[13:21:42.113]                           for (restart in restarts) {
[13:21:42.113]                             name <- restart$name
[13:21:42.113]                             if (is.null(name)) 
[13:21:42.113]                               next
[13:21:42.113]                             if (!grepl(pattern, name)) 
[13:21:42.113]                               next
[13:21:42.113]                             invokeRestart(restart)
[13:21:42.113]                             muffled <- TRUE
[13:21:42.113]                             break
[13:21:42.113]                           }
[13:21:42.113]                         }
[13:21:42.113]                       }
[13:21:42.113]                       invisible(muffled)
[13:21:42.113]                     }
[13:21:42.113]                     muffleCondition(cond, pattern = "^muffle")
[13:21:42.113]                   }
[13:21:42.113]                 }
[13:21:42.113]                 else {
[13:21:42.113]                   if (TRUE) {
[13:21:42.113]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:42.113]                     {
[13:21:42.113]                       inherits <- base::inherits
[13:21:42.113]                       invokeRestart <- base::invokeRestart
[13:21:42.113]                       is.null <- base::is.null
[13:21:42.113]                       muffled <- FALSE
[13:21:42.113]                       if (inherits(cond, "message")) {
[13:21:42.113]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:42.113]                         if (muffled) 
[13:21:42.113]                           invokeRestart("muffleMessage")
[13:21:42.113]                       }
[13:21:42.113]                       else if (inherits(cond, "warning")) {
[13:21:42.113]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:42.113]                         if (muffled) 
[13:21:42.113]                           invokeRestart("muffleWarning")
[13:21:42.113]                       }
[13:21:42.113]                       else if (inherits(cond, "condition")) {
[13:21:42.113]                         if (!is.null(pattern)) {
[13:21:42.113]                           computeRestarts <- base::computeRestarts
[13:21:42.113]                           grepl <- base::grepl
[13:21:42.113]                           restarts <- computeRestarts(cond)
[13:21:42.113]                           for (restart in restarts) {
[13:21:42.113]                             name <- restart$name
[13:21:42.113]                             if (is.null(name)) 
[13:21:42.113]                               next
[13:21:42.113]                             if (!grepl(pattern, name)) 
[13:21:42.113]                               next
[13:21:42.113]                             invokeRestart(restart)
[13:21:42.113]                             muffled <- TRUE
[13:21:42.113]                             break
[13:21:42.113]                           }
[13:21:42.113]                         }
[13:21:42.113]                       }
[13:21:42.113]                       invisible(muffled)
[13:21:42.113]                     }
[13:21:42.113]                     muffleCondition(cond, pattern = "^muffle")
[13:21:42.113]                   }
[13:21:42.113]                 }
[13:21:42.113]             }
[13:21:42.113]         }))
[13:21:42.113]     }, error = function(ex) {
[13:21:42.113]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:42.113]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:42.113]                 ...future.rng), started = ...future.startTime, 
[13:21:42.113]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:42.113]             version = "1.8"), class = "FutureResult")
[13:21:42.113]     }, finally = {
[13:21:42.113]         if (!identical(...future.workdir, getwd())) 
[13:21:42.113]             setwd(...future.workdir)
[13:21:42.113]         {
[13:21:42.113]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:42.113]                 ...future.oldOptions$nwarnings <- NULL
[13:21:42.113]             }
[13:21:42.113]             base::options(...future.oldOptions)
[13:21:42.113]             if (.Platform$OS.type == "windows") {
[13:21:42.113]                 old_names <- names(...future.oldEnvVars)
[13:21:42.113]                 envs <- base::Sys.getenv()
[13:21:42.113]                 names <- names(envs)
[13:21:42.113]                 common <- intersect(names, old_names)
[13:21:42.113]                 added <- setdiff(names, old_names)
[13:21:42.113]                 removed <- setdiff(old_names, names)
[13:21:42.113]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:42.113]                   envs[common]]
[13:21:42.113]                 NAMES <- toupper(changed)
[13:21:42.113]                 args <- list()
[13:21:42.113]                 for (kk in seq_along(NAMES)) {
[13:21:42.113]                   name <- changed[[kk]]
[13:21:42.113]                   NAME <- NAMES[[kk]]
[13:21:42.113]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:42.113]                     next
[13:21:42.113]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:42.113]                 }
[13:21:42.113]                 NAMES <- toupper(added)
[13:21:42.113]                 for (kk in seq_along(NAMES)) {
[13:21:42.113]                   name <- added[[kk]]
[13:21:42.113]                   NAME <- NAMES[[kk]]
[13:21:42.113]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:42.113]                     next
[13:21:42.113]                   args[[name]] <- ""
[13:21:42.113]                 }
[13:21:42.113]                 NAMES <- toupper(removed)
[13:21:42.113]                 for (kk in seq_along(NAMES)) {
[13:21:42.113]                   name <- removed[[kk]]
[13:21:42.113]                   NAME <- NAMES[[kk]]
[13:21:42.113]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:42.113]                     next
[13:21:42.113]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:42.113]                 }
[13:21:42.113]                 if (length(args) > 0) 
[13:21:42.113]                   base::do.call(base::Sys.setenv, args = args)
[13:21:42.113]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:42.113]             }
[13:21:42.113]             else {
[13:21:42.113]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:42.113]             }
[13:21:42.113]             {
[13:21:42.113]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:42.113]                   0L) {
[13:21:42.113]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:42.113]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:42.113]                   base::options(opts)
[13:21:42.113]                 }
[13:21:42.113]                 {
[13:21:42.113]                   {
[13:21:42.113]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:42.113]                     NULL
[13:21:42.113]                   }
[13:21:42.113]                   options(future.plan = NULL)
[13:21:42.113]                   if (is.na(NA_character_)) 
[13:21:42.113]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:42.113]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:42.113]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:42.113]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:42.113]                     envir = parent.frame()) 
[13:21:42.113]                   {
[13:21:42.113]                     if (is.function(workers)) 
[13:21:42.113]                       workers <- workers()
[13:21:42.113]                     workers <- structure(as.integer(workers), 
[13:21:42.113]                       class = class(workers))
[13:21:42.113]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:42.113]                       workers >= 1)
[13:21:42.113]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:42.113]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:42.113]                     }
[13:21:42.113]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:42.113]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:42.113]                       envir = envir)
[13:21:42.113]                     if (!future$lazy) 
[13:21:42.113]                       future <- run(future)
[13:21:42.113]                     invisible(future)
[13:21:42.113]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:42.113]                 }
[13:21:42.113]             }
[13:21:42.113]         }
[13:21:42.113]     })
[13:21:42.113]     if (TRUE) {
[13:21:42.113]         base::sink(type = "output", split = FALSE)
[13:21:42.113]         if (TRUE) {
[13:21:42.113]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:42.113]         }
[13:21:42.113]         else {
[13:21:42.113]             ...future.result["stdout"] <- base::list(NULL)
[13:21:42.113]         }
[13:21:42.113]         base::close(...future.stdout)
[13:21:42.113]         ...future.stdout <- NULL
[13:21:42.113]     }
[13:21:42.113]     ...future.result$conditions <- ...future.conditions
[13:21:42.113]     ...future.result$finished <- base::Sys.time()
[13:21:42.113]     ...future.result
[13:21:42.113] }
[13:21:42.117] Exporting 11 global objects (92.05 KiB) to cluster node #2 ...
[13:21:42.117] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[13:21:42.160] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[13:21:42.161] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[13:21:42.161] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[13:21:42.161] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[13:21:42.162] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[13:21:42.162] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[13:21:42.204] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[13:21:42.205] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[13:21:42.248] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[13:21:42.248] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[13:21:42.249] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[13:21:42.249] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ...
[13:21:42.249] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ... DONE
[13:21:42.250] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:21:42.250] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:21:42.250] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[13:21:42.251] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[13:21:42.251] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:21:42.251] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:21:42.251] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:21:42.252] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:21:42.252] Exporting 11 global objects (92.05 KiB) to cluster node #2 ... DONE
[13:21:42.253] MultisessionFuture started
[13:21:42.253] - Launch lazy future ... done
[13:21:42.253] run() for ‘MultisessionFuture’ ... done
[13:21:42.253] Created future:
[13:21:42.253] MultisessionFuture:
[13:21:42.253] Label: ‘future_vapply-2’
[13:21:42.253] Expression:
[13:21:42.253] {
[13:21:42.253]     do.call(function(...) {
[13:21:42.253]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:42.253]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:42.253]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:42.253]             on.exit(options(oopts), add = TRUE)
[13:21:42.253]         }
[13:21:42.253]         {
[13:21:42.253]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:42.253]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:42.253]                 ...future.FUN(...future.X_jj, ...)
[13:21:42.253]             })
[13:21:42.253]         }
[13:21:42.253]     }, args = future.call.arguments)
[13:21:42.253] }
[13:21:42.253] Lazy evaluation: FALSE
[13:21:42.253] Asynchronous evaluation: TRUE
[13:21:42.253] Local evaluation: TRUE
[13:21:42.253] Environment: R_GlobalEnv
[13:21:42.253] Capture standard output: TRUE
[13:21:42.253] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:42.253] Globals: 11 objects totaling 92.16 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:42.253] Packages: 1 packages (‘future.apply’)
[13:21:42.253] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:42.253] Resolved: FALSE
[13:21:42.253] Value: <not collected>
[13:21:42.253] Conditions captured: <none>
[13:21:42.253] Early signaling: FALSE
[13:21:42.253] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:42.253] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:42.265] Chunk #2 of 2 ... DONE
[13:21:42.265] Launching 2 futures (chunks) ... DONE
[13:21:42.265] Resolving 2 futures (chunks) ...
[13:21:42.266] resolve() on list ...
[13:21:42.266]  recursive: 0
[13:21:42.266]  length: 2
[13:21:42.266] 
[13:21:42.266] receiveMessageFromWorker() for ClusterFuture ...
[13:21:42.267] - Validating connection of MultisessionFuture
[13:21:42.267] - received message: FutureResult
[13:21:42.267] - Received FutureResult
[13:21:42.267] - Erased future from FutureRegistry
[13:21:42.267] result() for ClusterFuture ...
[13:21:42.267] - result already collected: FutureResult
[13:21:42.267] result() for ClusterFuture ... done
[13:21:42.267] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:42.268] Future #1
[13:21:42.268] result() for ClusterFuture ...
[13:21:42.268] - result already collected: FutureResult
[13:21:42.268] result() for ClusterFuture ... done
[13:21:42.268] result() for ClusterFuture ...
[13:21:42.268] - result already collected: FutureResult
[13:21:42.268] result() for ClusterFuture ... done
[13:21:42.268] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:21:42.268] - nx: 2
[13:21:42.268] - relay: TRUE
[13:21:42.268] - stdout: TRUE
[13:21:42.269] - signal: TRUE
[13:21:42.269] - resignal: FALSE
[13:21:42.269] - force: TRUE
[13:21:42.269] - relayed: [n=2] FALSE, FALSE
[13:21:42.269] - queued futures: [n=2] FALSE, FALSE
[13:21:42.269]  - until=1
[13:21:42.269]  - relaying element #1
[13:21:42.269] result() for ClusterFuture ...
[13:21:42.269] - result already collected: FutureResult
[13:21:42.269] result() for ClusterFuture ... done
[13:21:42.269] result() for ClusterFuture ...
[13:21:42.270] - result already collected: FutureResult
[13:21:42.270] result() for ClusterFuture ... done
[13:21:42.270] result() for ClusterFuture ...
[13:21:42.270] - result already collected: FutureResult
[13:21:42.270] result() for ClusterFuture ... done
[13:21:42.270] result() for ClusterFuture ...
[13:21:42.270] - result already collected: FutureResult
[13:21:42.270] result() for ClusterFuture ... done
[13:21:42.270] - relayed: [n=2] TRUE, FALSE
[13:21:42.270] - queued futures: [n=2] TRUE, FALSE
[13:21:42.270] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:21:42.271]  length: 1 (resolved future 1)
[13:21:42.301] receiveMessageFromWorker() for ClusterFuture ...
[13:21:42.301] - Validating connection of MultisessionFuture
[13:21:42.302] - received message: FutureResult
[13:21:42.302] - Received FutureResult
[13:21:42.302] - Erased future from FutureRegistry
[13:21:42.302] result() for ClusterFuture ...
[13:21:42.302] - result already collected: FutureResult
[13:21:42.302] result() for ClusterFuture ... done
[13:21:42.302] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:42.302] Future #2
[13:21:42.302] result() for ClusterFuture ...
[13:21:42.302] - result already collected: FutureResult
[13:21:42.303] result() for ClusterFuture ... done
[13:21:42.303] result() for ClusterFuture ...
[13:21:42.303] - result already collected: FutureResult
[13:21:42.303] result() for ClusterFuture ... done
[13:21:42.303] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:21:42.303] - nx: 2
[13:21:42.303] - relay: TRUE
[13:21:42.303] - stdout: TRUE
[13:21:42.303] - signal: TRUE
[13:21:42.303] - resignal: FALSE
[13:21:42.304] - force: TRUE
[13:21:42.304] - relayed: [n=2] TRUE, FALSE
[13:21:42.304] - queued futures: [n=2] TRUE, FALSE
[13:21:42.304]  - until=2
[13:21:42.304]  - relaying element #2
[13:21:42.304] result() for ClusterFuture ...
[13:21:42.304] - result already collected: FutureResult
[13:21:42.304] result() for ClusterFuture ... done
[13:21:42.304] result() for ClusterFuture ...
[13:21:42.304] - result already collected: FutureResult
[13:21:42.304] result() for ClusterFuture ... done
[13:21:42.305] result() for ClusterFuture ...
[13:21:42.305] - result already collected: FutureResult
[13:21:42.305] result() for ClusterFuture ... done
[13:21:42.305] result() for ClusterFuture ...
[13:21:42.305] - result already collected: FutureResult
[13:21:42.305] result() for ClusterFuture ... done
[13:21:42.305] - relayed: [n=2] TRUE, TRUE
[13:21:42.305] - queued futures: [n=2] TRUE, TRUE
[13:21:42.305] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:21:42.305]  length: 0 (resolved future 2)
[13:21:42.306] Relaying remaining futures
[13:21:42.306] signalConditionsASAP(NULL, pos=0) ...
[13:21:42.306] - nx: 2
[13:21:42.306] - relay: TRUE
[13:21:42.306] - stdout: TRUE
[13:21:42.306] - signal: TRUE
[13:21:42.306] - resignal: FALSE
[13:21:42.306] - force: TRUE
[13:21:42.306] - relayed: [n=2] TRUE, TRUE
[13:21:42.306] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:21:42.306] - relayed: [n=2] TRUE, TRUE
[13:21:42.307] - queued futures: [n=2] TRUE, TRUE
[13:21:42.307] signalConditionsASAP(NULL, pos=0) ... done
[13:21:42.307] resolve() on list ... DONE
[13:21:42.307] result() for ClusterFuture ...
[13:21:42.307] - result already collected: FutureResult
[13:21:42.307] result() for ClusterFuture ... done
[13:21:42.307] result() for ClusterFuture ...
[13:21:42.307] - result already collected: FutureResult
[13:21:42.307] result() for ClusterFuture ... done
[13:21:42.307] result() for ClusterFuture ...
[13:21:42.307] - result already collected: FutureResult
[13:21:42.307] result() for ClusterFuture ... done
[13:21:42.308] result() for ClusterFuture ...
[13:21:42.308] - result already collected: FutureResult
[13:21:42.308] result() for ClusterFuture ... done
[13:21:42.308]  - Number of value chunks collected: 2
[13:21:42.308] Resolving 2 futures (chunks) ... DONE
[13:21:42.308] Reducing values from 2 chunks ...
[13:21:42.308]  - Number of values collected after concatenation: 3
[13:21:42.308]  - Number of values expected: 3
[13:21:42.308] Reducing values from 2 chunks ... DONE
[13:21:42.308] future_lapply() ... DONE
- exceptions ...
[13:21:42.309] future_lapply() ...
[13:21:42.314] Number of chunks: 2
[13:21:42.314] getGlobalsAndPackagesXApply() ...
[13:21:42.314]  - future.globals: TRUE
[13:21:42.314] getGlobalsAndPackages() ...
[13:21:42.315] Searching for globals...
[13:21:42.318] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:21:42.318] Searching for globals ... DONE
[13:21:42.318] Resolving globals: FALSE
[13:21:42.319] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[13:21:42.319] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:21:42.320] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:42.320] - packages: [1] ‘future.apply’
[13:21:42.320] getGlobalsAndPackages() ... DONE
[13:21:42.320]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:21:42.320]  - needed namespaces: [n=1] ‘future.apply’
[13:21:42.320] Finding globals ... DONE
[13:21:42.320]  - use_args: TRUE
[13:21:42.320]  - Getting '...' globals ...
[13:21:42.321] resolve() on list ...
[13:21:42.321]  recursive: 0
[13:21:42.321]  length: 1
[13:21:42.321]  elements: ‘...’
[13:21:42.321]  length: 0 (resolved future 1)
[13:21:42.321] resolve() on list ... DONE
[13:21:42.321]    - '...' content: [n=0] 
[13:21:42.321] List of 1
[13:21:42.321]  $ ...: list()
[13:21:42.321]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:42.321]  - attr(*, "where")=List of 1
[13:21:42.321]   ..$ ...:<environment: 0x563b6fe6d348> 
[13:21:42.321]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:42.321]  - attr(*, "resolved")= logi TRUE
[13:21:42.321]  - attr(*, "total_size")= num NA
[13:21:42.324]  - Getting '...' globals ... DONE
[13:21:42.324] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:21:42.324] List of 8
[13:21:42.324]  $ ...future.FUN:function (x, ...)  
[13:21:42.324]  $ x_FUN        :function (x)  
[13:21:42.324]  $ times        : int 2
[13:21:42.324]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:21:42.324]  $ stop_if_not  :function (...)  
[13:21:42.324]  $ dim          : NULL
[13:21:42.324]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:21:42.324]  $ ...          : list()
[13:21:42.324]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:21:42.324]  - attr(*, "where")=List of 8
[13:21:42.324]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:21:42.324]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:21:42.324]   ..$ times        :<environment: R_EmptyEnv> 
[13:21:42.324]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:21:42.324]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:21:42.324]   ..$ dim          :<environment: R_EmptyEnv> 
[13:21:42.324]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:21:42.324]   ..$ ...          :<environment: 0x563b6fe6d348> 
[13:21:42.324]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:42.324]  - attr(*, "resolved")= logi FALSE
[13:21:42.324]  - attr(*, "total_size")= num 95128
[13:21:42.330] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:21:42.330] getGlobalsAndPackagesXApply() ... DONE
[13:21:42.330] Number of futures (= number of chunks): 2
[13:21:42.330] Launching 2 futures (chunks) ...
[13:21:42.330] Chunk #1 of 2 ...
[13:21:42.330]  - Finding globals in 'X' for chunk #1 ...
[13:21:42.330] getGlobalsAndPackages() ...
[13:21:42.331] Searching for globals...
[13:21:42.331] 
[13:21:42.331] Searching for globals ... DONE
[13:21:42.331] - globals: [0] <none>
[13:21:42.331] getGlobalsAndPackages() ... DONE
[13:21:42.331]    + additional globals found: [n=0] 
[13:21:42.331]    + additional namespaces needed: [n=0] 
[13:21:42.331]  - Finding globals in 'X' for chunk #1 ... DONE
[13:21:42.331]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:42.332]  - seeds: <none>
[13:21:42.332]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:42.332] getGlobalsAndPackages() ...
[13:21:42.332] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:42.332] Resolving globals: FALSE
[13:21:42.332] Tweak future expression to call with '...' arguments ...
[13:21:42.332] {
[13:21:42.332]     do.call(function(...) {
[13:21:42.332]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:42.332]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:42.332]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:42.332]             on.exit(options(oopts), add = TRUE)
[13:21:42.332]         }
[13:21:42.332]         {
[13:21:42.332]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:42.332]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:42.332]                 ...future.FUN(...future.X_jj, ...)
[13:21:42.332]             })
[13:21:42.332]         }
[13:21:42.332]     }, args = future.call.arguments)
[13:21:42.332] }
[13:21:42.333] Tweak future expression to call with '...' arguments ... DONE
[13:21:42.333] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:42.333] - packages: [1] ‘future.apply’
[13:21:42.333] getGlobalsAndPackages() ... DONE
[13:21:42.334] run() for ‘Future’ ...
[13:21:42.334] - state: ‘created’
[13:21:42.334] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:42.348] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:42.348] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:42.348]   - Field: ‘node’
[13:21:42.348]   - Field: ‘label’
[13:21:42.348]   - Field: ‘local’
[13:21:42.348]   - Field: ‘owner’
[13:21:42.348]   - Field: ‘envir’
[13:21:42.349]   - Field: ‘workers’
[13:21:42.349]   - Field: ‘packages’
[13:21:42.349]   - Field: ‘gc’
[13:21:42.349]   - Field: ‘conditions’
[13:21:42.349]   - Field: ‘persistent’
[13:21:42.349]   - Field: ‘expr’
[13:21:42.349]   - Field: ‘uuid’
[13:21:42.349]   - Field: ‘seed’
[13:21:42.349]   - Field: ‘version’
[13:21:42.349]   - Field: ‘result’
[13:21:42.349]   - Field: ‘asynchronous’
[13:21:42.349]   - Field: ‘calls’
[13:21:42.350]   - Field: ‘globals’
[13:21:42.350]   - Field: ‘stdout’
[13:21:42.350]   - Field: ‘earlySignal’
[13:21:42.350]   - Field: ‘lazy’
[13:21:42.350]   - Field: ‘state’
[13:21:42.350] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:42.350] - Launch lazy future ...
[13:21:42.350] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:42.351] Packages needed by future strategies (n = 0): <none>
[13:21:42.351] {
[13:21:42.351]     {
[13:21:42.351]         {
[13:21:42.351]             ...future.startTime <- base::Sys.time()
[13:21:42.351]             {
[13:21:42.351]                 {
[13:21:42.351]                   {
[13:21:42.351]                     {
[13:21:42.351]                       {
[13:21:42.351]                         base::local({
[13:21:42.351]                           has_future <- base::requireNamespace("future", 
[13:21:42.351]                             quietly = TRUE)
[13:21:42.351]                           if (has_future) {
[13:21:42.351]                             ns <- base::getNamespace("future")
[13:21:42.351]                             version <- ns[[".package"]][["version"]]
[13:21:42.351]                             if (is.null(version)) 
[13:21:42.351]                               version <- utils::packageVersion("future")
[13:21:42.351]                           }
[13:21:42.351]                           else {
[13:21:42.351]                             version <- NULL
[13:21:42.351]                           }
[13:21:42.351]                           if (!has_future || version < "1.8.0") {
[13:21:42.351]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:42.351]                               "", base::R.version$version.string), 
[13:21:42.351]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:42.351]                                 base::R.version$platform, 8 * 
[13:21:42.351]                                   base::.Machine$sizeof.pointer), 
[13:21:42.351]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:42.351]                                 "release", "version")], collapse = " "), 
[13:21:42.351]                               hostname = base::Sys.info()[["nodename"]])
[13:21:42.351]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:42.351]                               info)
[13:21:42.351]                             info <- base::paste(info, collapse = "; ")
[13:21:42.351]                             if (!has_future) {
[13:21:42.351]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:42.351]                                 info)
[13:21:42.351]                             }
[13:21:42.351]                             else {
[13:21:42.351]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:42.351]                                 info, version)
[13:21:42.351]                             }
[13:21:42.351]                             base::stop(msg)
[13:21:42.351]                           }
[13:21:42.351]                         })
[13:21:42.351]                       }
[13:21:42.351]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:42.351]                       base::options(mc.cores = 1L)
[13:21:42.351]                     }
[13:21:42.351]                     base::local({
[13:21:42.351]                       for (pkg in "future.apply") {
[13:21:42.351]                         base::loadNamespace(pkg)
[13:21:42.351]                         base::library(pkg, character.only = TRUE)
[13:21:42.351]                       }
[13:21:42.351]                     })
[13:21:42.351]                   }
[13:21:42.351]                   options(future.plan = NULL)
[13:21:42.351]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:42.351]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:42.351]                 }
[13:21:42.351]                 ...future.workdir <- getwd()
[13:21:42.351]             }
[13:21:42.351]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:42.351]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:42.351]         }
[13:21:42.351]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:42.351]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:42.351]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:42.351]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:42.351]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:42.351]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:42.351]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:42.351]             base::names(...future.oldOptions))
[13:21:42.351]     }
[13:21:42.351]     if (FALSE) {
[13:21:42.351]     }
[13:21:42.351]     else {
[13:21:42.351]         if (TRUE) {
[13:21:42.351]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:42.351]                 open = "w")
[13:21:42.351]         }
[13:21:42.351]         else {
[13:21:42.351]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:42.351]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:42.351]         }
[13:21:42.351]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:42.351]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:42.351]             base::sink(type = "output", split = FALSE)
[13:21:42.351]             base::close(...future.stdout)
[13:21:42.351]         }, add = TRUE)
[13:21:42.351]     }
[13:21:42.351]     ...future.frame <- base::sys.nframe()
[13:21:42.351]     ...future.conditions <- base::list()
[13:21:42.351]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:42.351]     if (FALSE) {
[13:21:42.351]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:42.351]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:42.351]     }
[13:21:42.351]     ...future.result <- base::tryCatch({
[13:21:42.351]         base::withCallingHandlers({
[13:21:42.351]             ...future.value <- base::withVisible(base::local({
[13:21:42.351]                 ...future.makeSendCondition <- base::local({
[13:21:42.351]                   sendCondition <- NULL
[13:21:42.351]                   function(frame = 1L) {
[13:21:42.351]                     if (is.function(sendCondition)) 
[13:21:42.351]                       return(sendCondition)
[13:21:42.351]                     ns <- getNamespace("parallel")
[13:21:42.351]                     if (exists("sendData", mode = "function", 
[13:21:42.351]                       envir = ns)) {
[13:21:42.351]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:42.351]                         envir = ns)
[13:21:42.351]                       envir <- sys.frame(frame)
[13:21:42.351]                       master <- NULL
[13:21:42.351]                       while (!identical(envir, .GlobalEnv) && 
[13:21:42.351]                         !identical(envir, emptyenv())) {
[13:21:42.351]                         if (exists("master", mode = "list", envir = envir, 
[13:21:42.351]                           inherits = FALSE)) {
[13:21:42.351]                           master <- get("master", mode = "list", 
[13:21:42.351]                             envir = envir, inherits = FALSE)
[13:21:42.351]                           if (inherits(master, c("SOCKnode", 
[13:21:42.351]                             "SOCK0node"))) {
[13:21:42.351]                             sendCondition <<- function(cond) {
[13:21:42.351]                               data <- list(type = "VALUE", value = cond, 
[13:21:42.351]                                 success = TRUE)
[13:21:42.351]                               parallel_sendData(master, data)
[13:21:42.351]                             }
[13:21:42.351]                             return(sendCondition)
[13:21:42.351]                           }
[13:21:42.351]                         }
[13:21:42.351]                         frame <- frame + 1L
[13:21:42.351]                         envir <- sys.frame(frame)
[13:21:42.351]                       }
[13:21:42.351]                     }
[13:21:42.351]                     sendCondition <<- function(cond) NULL
[13:21:42.351]                   }
[13:21:42.351]                 })
[13:21:42.351]                 withCallingHandlers({
[13:21:42.351]                   {
[13:21:42.351]                     do.call(function(...) {
[13:21:42.351]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:42.351]                       if (!identical(...future.globals.maxSize.org, 
[13:21:42.351]                         ...future.globals.maxSize)) {
[13:21:42.351]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:42.351]                         on.exit(options(oopts), add = TRUE)
[13:21:42.351]                       }
[13:21:42.351]                       {
[13:21:42.351]                         lapply(seq_along(...future.elements_ii), 
[13:21:42.351]                           FUN = function(jj) {
[13:21:42.351]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:42.351]                             ...future.FUN(...future.X_jj, ...)
[13:21:42.351]                           })
[13:21:42.351]                       }
[13:21:42.351]                     }, args = future.call.arguments)
[13:21:42.351]                   }
[13:21:42.351]                 }, immediateCondition = function(cond) {
[13:21:42.351]                   sendCondition <- ...future.makeSendCondition()
[13:21:42.351]                   sendCondition(cond)
[13:21:42.351]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:42.351]                   {
[13:21:42.351]                     inherits <- base::inherits
[13:21:42.351]                     invokeRestart <- base::invokeRestart
[13:21:42.351]                     is.null <- base::is.null
[13:21:42.351]                     muffled <- FALSE
[13:21:42.351]                     if (inherits(cond, "message")) {
[13:21:42.351]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:42.351]                       if (muffled) 
[13:21:42.351]                         invokeRestart("muffleMessage")
[13:21:42.351]                     }
[13:21:42.351]                     else if (inherits(cond, "warning")) {
[13:21:42.351]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:42.351]                       if (muffled) 
[13:21:42.351]                         invokeRestart("muffleWarning")
[13:21:42.351]                     }
[13:21:42.351]                     else if (inherits(cond, "condition")) {
[13:21:42.351]                       if (!is.null(pattern)) {
[13:21:42.351]                         computeRestarts <- base::computeRestarts
[13:21:42.351]                         grepl <- base::grepl
[13:21:42.351]                         restarts <- computeRestarts(cond)
[13:21:42.351]                         for (restart in restarts) {
[13:21:42.351]                           name <- restart$name
[13:21:42.351]                           if (is.null(name)) 
[13:21:42.351]                             next
[13:21:42.351]                           if (!grepl(pattern, name)) 
[13:21:42.351]                             next
[13:21:42.351]                           invokeRestart(restart)
[13:21:42.351]                           muffled <- TRUE
[13:21:42.351]                           break
[13:21:42.351]                         }
[13:21:42.351]                       }
[13:21:42.351]                     }
[13:21:42.351]                     invisible(muffled)
[13:21:42.351]                   }
[13:21:42.351]                   muffleCondition(cond)
[13:21:42.351]                 })
[13:21:42.351]             }))
[13:21:42.351]             future::FutureResult(value = ...future.value$value, 
[13:21:42.351]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:42.351]                   ...future.rng), globalenv = if (FALSE) 
[13:21:42.351]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:42.351]                     ...future.globalenv.names))
[13:21:42.351]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:42.351]         }, condition = base::local({
[13:21:42.351]             c <- base::c
[13:21:42.351]             inherits <- base::inherits
[13:21:42.351]             invokeRestart <- base::invokeRestart
[13:21:42.351]             length <- base::length
[13:21:42.351]             list <- base::list
[13:21:42.351]             seq.int <- base::seq.int
[13:21:42.351]             signalCondition <- base::signalCondition
[13:21:42.351]             sys.calls <- base::sys.calls
[13:21:42.351]             `[[` <- base::`[[`
[13:21:42.351]             `+` <- base::`+`
[13:21:42.351]             `<<-` <- base::`<<-`
[13:21:42.351]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:42.351]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:42.351]                   3L)]
[13:21:42.351]             }
[13:21:42.351]             function(cond) {
[13:21:42.351]                 is_error <- inherits(cond, "error")
[13:21:42.351]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:42.351]                   NULL)
[13:21:42.351]                 if (is_error) {
[13:21:42.351]                   sessionInformation <- function() {
[13:21:42.351]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:42.351]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:42.351]                       search = base::search(), system = base::Sys.info())
[13:21:42.351]                   }
[13:21:42.351]                   ...future.conditions[[length(...future.conditions) + 
[13:21:42.351]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:42.351]                     cond$call), session = sessionInformation(), 
[13:21:42.351]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:42.351]                   signalCondition(cond)
[13:21:42.351]                 }
[13:21:42.351]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:42.351]                 "immediateCondition"))) {
[13:21:42.351]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:42.351]                   ...future.conditions[[length(...future.conditions) + 
[13:21:42.351]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:42.351]                   if (TRUE && !signal) {
[13:21:42.351]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:42.351]                     {
[13:21:42.351]                       inherits <- base::inherits
[13:21:42.351]                       invokeRestart <- base::invokeRestart
[13:21:42.351]                       is.null <- base::is.null
[13:21:42.351]                       muffled <- FALSE
[13:21:42.351]                       if (inherits(cond, "message")) {
[13:21:42.351]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:42.351]                         if (muffled) 
[13:21:42.351]                           invokeRestart("muffleMessage")
[13:21:42.351]                       }
[13:21:42.351]                       else if (inherits(cond, "warning")) {
[13:21:42.351]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:42.351]                         if (muffled) 
[13:21:42.351]                           invokeRestart("muffleWarning")
[13:21:42.351]                       }
[13:21:42.351]                       else if (inherits(cond, "condition")) {
[13:21:42.351]                         if (!is.null(pattern)) {
[13:21:42.351]                           computeRestarts <- base::computeRestarts
[13:21:42.351]                           grepl <- base::grepl
[13:21:42.351]                           restarts <- computeRestarts(cond)
[13:21:42.351]                           for (restart in restarts) {
[13:21:42.351]                             name <- restart$name
[13:21:42.351]                             if (is.null(name)) 
[13:21:42.351]                               next
[13:21:42.351]                             if (!grepl(pattern, name)) 
[13:21:42.351]                               next
[13:21:42.351]                             invokeRestart(restart)
[13:21:42.351]                             muffled <- TRUE
[13:21:42.351]                             break
[13:21:42.351]                           }
[13:21:42.351]                         }
[13:21:42.351]                       }
[13:21:42.351]                       invisible(muffled)
[13:21:42.351]                     }
[13:21:42.351]                     muffleCondition(cond, pattern = "^muffle")
[13:21:42.351]                   }
[13:21:42.351]                 }
[13:21:42.351]                 else {
[13:21:42.351]                   if (TRUE) {
[13:21:42.351]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:42.351]                     {
[13:21:42.351]                       inherits <- base::inherits
[13:21:42.351]                       invokeRestart <- base::invokeRestart
[13:21:42.351]                       is.null <- base::is.null
[13:21:42.351]                       muffled <- FALSE
[13:21:42.351]                       if (inherits(cond, "message")) {
[13:21:42.351]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:42.351]                         if (muffled) 
[13:21:42.351]                           invokeRestart("muffleMessage")
[13:21:42.351]                       }
[13:21:42.351]                       else if (inherits(cond, "warning")) {
[13:21:42.351]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:42.351]                         if (muffled) 
[13:21:42.351]                           invokeRestart("muffleWarning")
[13:21:42.351]                       }
[13:21:42.351]                       else if (inherits(cond, "condition")) {
[13:21:42.351]                         if (!is.null(pattern)) {
[13:21:42.351]                           computeRestarts <- base::computeRestarts
[13:21:42.351]                           grepl <- base::grepl
[13:21:42.351]                           restarts <- computeRestarts(cond)
[13:21:42.351]                           for (restart in restarts) {
[13:21:42.351]                             name <- restart$name
[13:21:42.351]                             if (is.null(name)) 
[13:21:42.351]                               next
[13:21:42.351]                             if (!grepl(pattern, name)) 
[13:21:42.351]                               next
[13:21:42.351]                             invokeRestart(restart)
[13:21:42.351]                             muffled <- TRUE
[13:21:42.351]                             break
[13:21:42.351]                           }
[13:21:42.351]                         }
[13:21:42.351]                       }
[13:21:42.351]                       invisible(muffled)
[13:21:42.351]                     }
[13:21:42.351]                     muffleCondition(cond, pattern = "^muffle")
[13:21:42.351]                   }
[13:21:42.351]                 }
[13:21:42.351]             }
[13:21:42.351]         }))
[13:21:42.351]     }, error = function(ex) {
[13:21:42.351]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:42.351]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:42.351]                 ...future.rng), started = ...future.startTime, 
[13:21:42.351]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:42.351]             version = "1.8"), class = "FutureResult")
[13:21:42.351]     }, finally = {
[13:21:42.351]         if (!identical(...future.workdir, getwd())) 
[13:21:42.351]             setwd(...future.workdir)
[13:21:42.351]         {
[13:21:42.351]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:42.351]                 ...future.oldOptions$nwarnings <- NULL
[13:21:42.351]             }
[13:21:42.351]             base::options(...future.oldOptions)
[13:21:42.351]             if (.Platform$OS.type == "windows") {
[13:21:42.351]                 old_names <- names(...future.oldEnvVars)
[13:21:42.351]                 envs <- base::Sys.getenv()
[13:21:42.351]                 names <- names(envs)
[13:21:42.351]                 common <- intersect(names, old_names)
[13:21:42.351]                 added <- setdiff(names, old_names)
[13:21:42.351]                 removed <- setdiff(old_names, names)
[13:21:42.351]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:42.351]                   envs[common]]
[13:21:42.351]                 NAMES <- toupper(changed)
[13:21:42.351]                 args <- list()
[13:21:42.351]                 for (kk in seq_along(NAMES)) {
[13:21:42.351]                   name <- changed[[kk]]
[13:21:42.351]                   NAME <- NAMES[[kk]]
[13:21:42.351]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:42.351]                     next
[13:21:42.351]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:42.351]                 }
[13:21:42.351]                 NAMES <- toupper(added)
[13:21:42.351]                 for (kk in seq_along(NAMES)) {
[13:21:42.351]                   name <- added[[kk]]
[13:21:42.351]                   NAME <- NAMES[[kk]]
[13:21:42.351]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:42.351]                     next
[13:21:42.351]                   args[[name]] <- ""
[13:21:42.351]                 }
[13:21:42.351]                 NAMES <- toupper(removed)
[13:21:42.351]                 for (kk in seq_along(NAMES)) {
[13:21:42.351]                   name <- removed[[kk]]
[13:21:42.351]                   NAME <- NAMES[[kk]]
[13:21:42.351]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:42.351]                     next
[13:21:42.351]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:42.351]                 }
[13:21:42.351]                 if (length(args) > 0) 
[13:21:42.351]                   base::do.call(base::Sys.setenv, args = args)
[13:21:42.351]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:42.351]             }
[13:21:42.351]             else {
[13:21:42.351]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:42.351]             }
[13:21:42.351]             {
[13:21:42.351]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:42.351]                   0L) {
[13:21:42.351]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:42.351]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:42.351]                   base::options(opts)
[13:21:42.351]                 }
[13:21:42.351]                 {
[13:21:42.351]                   {
[13:21:42.351]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:42.351]                     NULL
[13:21:42.351]                   }
[13:21:42.351]                   options(future.plan = NULL)
[13:21:42.351]                   if (is.na(NA_character_)) 
[13:21:42.351]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:42.351]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:42.351]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:42.351]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:42.351]                     envir = parent.frame()) 
[13:21:42.351]                   {
[13:21:42.351]                     if (is.function(workers)) 
[13:21:42.351]                       workers <- workers()
[13:21:42.351]                     workers <- structure(as.integer(workers), 
[13:21:42.351]                       class = class(workers))
[13:21:42.351]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:42.351]                       workers >= 1)
[13:21:42.351]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:42.351]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:42.351]                     }
[13:21:42.351]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:42.351]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:42.351]                       envir = envir)
[13:21:42.351]                     if (!future$lazy) 
[13:21:42.351]                       future <- run(future)
[13:21:42.351]                     invisible(future)
[13:21:42.351]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:42.351]                 }
[13:21:42.351]             }
[13:21:42.351]         }
[13:21:42.351]     })
[13:21:42.351]     if (TRUE) {
[13:21:42.351]         base::sink(type = "output", split = FALSE)
[13:21:42.351]         if (TRUE) {
[13:21:42.351]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:42.351]         }
[13:21:42.351]         else {
[13:21:42.351]             ...future.result["stdout"] <- base::list(NULL)
[13:21:42.351]         }
[13:21:42.351]         base::close(...future.stdout)
[13:21:42.351]         ...future.stdout <- NULL
[13:21:42.351]     }
[13:21:42.351]     ...future.result$conditions <- ...future.conditions
[13:21:42.351]     ...future.result$finished <- base::Sys.time()
[13:21:42.351]     ...future.result
[13:21:42.351] }
[13:21:42.354] Exporting 11 global objects (92.90 KiB) to cluster node #1 ...
[13:21:42.354] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:21:42.396] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:21:42.397] Exporting ‘x_FUN’ (848 bytes) to cluster node #1 ...
[13:21:42.397] Exporting ‘x_FUN’ (848 bytes) to cluster node #1 ... DONE
[13:21:42.397] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:21:42.398] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:21:42.398] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:21:42.440] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:21:42.440] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:21:42.484] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:21:42.484] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[13:21:42.485] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[13:21:42.485] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[13:21:42.485] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[13:21:42.486] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:21:42.486] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:21:42.486] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[13:21:42.487] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[13:21:42.487] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:21:42.487] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:21:42.487] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:21:42.488] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:21:42.488] Exporting 11 global objects (92.90 KiB) to cluster node #1 ... DONE
[13:21:42.489] MultisessionFuture started
[13:21:42.489] - Launch lazy future ... done
[13:21:42.489] run() for ‘MultisessionFuture’ ... done
[13:21:42.489] Created future:
[13:21:42.489] MultisessionFuture:
[13:21:42.489] Label: ‘future_vapply-1’
[13:21:42.489] Expression:
[13:21:42.489] {
[13:21:42.489]     do.call(function(...) {
[13:21:42.489]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:42.489]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:42.489]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:42.489]             on.exit(options(oopts), add = TRUE)
[13:21:42.489]         }
[13:21:42.489]         {
[13:21:42.489]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:42.489]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:42.489]                 ...future.FUN(...future.X_jj, ...)
[13:21:42.489]             })
[13:21:42.489]         }
[13:21:42.489]     }, args = future.call.arguments)
[13:21:42.489] }
[13:21:42.489] Lazy evaluation: FALSE
[13:21:42.489] Asynchronous evaluation: TRUE
[13:21:42.489] Local evaluation: TRUE
[13:21:42.489] Environment: R_GlobalEnv
[13:21:42.489] Capture standard output: TRUE
[13:21:42.489] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:42.489] Globals: 11 objects totaling 92.95 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:42.489] Packages: 1 packages (‘future.apply’)
[13:21:42.489] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:42.489] Resolved: FALSE
[13:21:42.489] Value: <not collected>
[13:21:42.489] Conditions captured: <none>
[13:21:42.489] Early signaling: FALSE
[13:21:42.489] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:42.489] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:42.501] Chunk #1 of 2 ... DONE
[13:21:42.501] Chunk #2 of 2 ...
[13:21:42.501]  - Finding globals in 'X' for chunk #2 ...
[13:21:42.501] getGlobalsAndPackages() ...
[13:21:42.502] Searching for globals...
[13:21:42.502] 
[13:21:42.502] Searching for globals ... DONE
[13:21:42.502] - globals: [0] <none>
[13:21:42.502] getGlobalsAndPackages() ... DONE
[13:21:42.502]    + additional globals found: [n=0] 
[13:21:42.502]    + additional namespaces needed: [n=0] 
[13:21:42.502]  - Finding globals in 'X' for chunk #2 ... DONE
[13:21:42.502]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:21:42.503]  - seeds: <none>
[13:21:42.503]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:42.503] getGlobalsAndPackages() ...
[13:21:42.503] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:42.503] Resolving globals: FALSE
[13:21:42.503] Tweak future expression to call with '...' arguments ...
[13:21:42.503] {
[13:21:42.503]     do.call(function(...) {
[13:21:42.503]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:42.503]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:42.503]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:42.503]             on.exit(options(oopts), add = TRUE)
[13:21:42.503]         }
[13:21:42.503]         {
[13:21:42.503]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:42.503]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:42.503]                 ...future.FUN(...future.X_jj, ...)
[13:21:42.503]             })
[13:21:42.503]         }
[13:21:42.503]     }, args = future.call.arguments)
[13:21:42.503] }
[13:21:42.504] Tweak future expression to call with '...' arguments ... DONE
[13:21:42.504] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:21:42.504] - packages: [1] ‘future.apply’
[13:21:42.504] getGlobalsAndPackages() ... DONE
[13:21:42.505] run() for ‘Future’ ...
[13:21:42.505] - state: ‘created’
[13:21:42.505] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:42.519] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:42.519] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:42.519]   - Field: ‘node’
[13:21:42.520]   - Field: ‘label’
[13:21:42.520]   - Field: ‘local’
[13:21:42.520]   - Field: ‘owner’
[13:21:42.520]   - Field: ‘envir’
[13:21:42.520]   - Field: ‘workers’
[13:21:42.520]   - Field: ‘packages’
[13:21:42.520]   - Field: ‘gc’
[13:21:42.520]   - Field: ‘conditions’
[13:21:42.520]   - Field: ‘persistent’
[13:21:42.520]   - Field: ‘expr’
[13:21:42.521]   - Field: ‘uuid’
[13:21:42.521]   - Field: ‘seed’
[13:21:42.521]   - Field: ‘version’
[13:21:42.521]   - Field: ‘result’
[13:21:42.521]   - Field: ‘asynchronous’
[13:21:42.521]   - Field: ‘calls’
[13:21:42.521]   - Field: ‘globals’
[13:21:42.521]   - Field: ‘stdout’
[13:21:42.521]   - Field: ‘earlySignal’
[13:21:42.521]   - Field: ‘lazy’
[13:21:42.521]   - Field: ‘state’
[13:21:42.522] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:42.522] - Launch lazy future ...
[13:21:42.522] Packages needed by the future expression (n = 1): ‘future.apply’
[13:21:42.522] Packages needed by future strategies (n = 0): <none>
[13:21:42.523] {
[13:21:42.523]     {
[13:21:42.523]         {
[13:21:42.523]             ...future.startTime <- base::Sys.time()
[13:21:42.523]             {
[13:21:42.523]                 {
[13:21:42.523]                   {
[13:21:42.523]                     {
[13:21:42.523]                       {
[13:21:42.523]                         base::local({
[13:21:42.523]                           has_future <- base::requireNamespace("future", 
[13:21:42.523]                             quietly = TRUE)
[13:21:42.523]                           if (has_future) {
[13:21:42.523]                             ns <- base::getNamespace("future")
[13:21:42.523]                             version <- ns[[".package"]][["version"]]
[13:21:42.523]                             if (is.null(version)) 
[13:21:42.523]                               version <- utils::packageVersion("future")
[13:21:42.523]                           }
[13:21:42.523]                           else {
[13:21:42.523]                             version <- NULL
[13:21:42.523]                           }
[13:21:42.523]                           if (!has_future || version < "1.8.0") {
[13:21:42.523]                             info <- base::c(r_version = base::gsub("R version ", 
[13:21:42.523]                               "", base::R.version$version.string), 
[13:21:42.523]                               platform = base::sprintf("%s (%s-bit)", 
[13:21:42.523]                                 base::R.version$platform, 8 * 
[13:21:42.523]                                   base::.Machine$sizeof.pointer), 
[13:21:42.523]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:42.523]                                 "release", "version")], collapse = " "), 
[13:21:42.523]                               hostname = base::Sys.info()[["nodename"]])
[13:21:42.523]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:21:42.523]                               info)
[13:21:42.523]                             info <- base::paste(info, collapse = "; ")
[13:21:42.523]                             if (!has_future) {
[13:21:42.523]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:42.523]                                 info)
[13:21:42.523]                             }
[13:21:42.523]                             else {
[13:21:42.523]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:42.523]                                 info, version)
[13:21:42.523]                             }
[13:21:42.523]                             base::stop(msg)
[13:21:42.523]                           }
[13:21:42.523]                         })
[13:21:42.523]                       }
[13:21:42.523]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:42.523]                       base::options(mc.cores = 1L)
[13:21:42.523]                     }
[13:21:42.523]                     base::local({
[13:21:42.523]                       for (pkg in "future.apply") {
[13:21:42.523]                         base::loadNamespace(pkg)
[13:21:42.523]                         base::library(pkg, character.only = TRUE)
[13:21:42.523]                       }
[13:21:42.523]                     })
[13:21:42.523]                   }
[13:21:42.523]                   options(future.plan = NULL)
[13:21:42.523]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:42.523]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:42.523]                 }
[13:21:42.523]                 ...future.workdir <- getwd()
[13:21:42.523]             }
[13:21:42.523]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:42.523]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:42.523]         }
[13:21:42.523]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:42.523]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:21:42.523]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:42.523]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:42.523]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:42.523]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:42.523]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:42.523]             base::names(...future.oldOptions))
[13:21:42.523]     }
[13:21:42.523]     if (FALSE) {
[13:21:42.523]     }
[13:21:42.523]     else {
[13:21:42.523]         if (TRUE) {
[13:21:42.523]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:42.523]                 open = "w")
[13:21:42.523]         }
[13:21:42.523]         else {
[13:21:42.523]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:42.523]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:42.523]         }
[13:21:42.523]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:42.523]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:42.523]             base::sink(type = "output", split = FALSE)
[13:21:42.523]             base::close(...future.stdout)
[13:21:42.523]         }, add = TRUE)
[13:21:42.523]     }
[13:21:42.523]     ...future.frame <- base::sys.nframe()
[13:21:42.523]     ...future.conditions <- base::list()
[13:21:42.523]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:42.523]     if (FALSE) {
[13:21:42.523]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:42.523]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:42.523]     }
[13:21:42.523]     ...future.result <- base::tryCatch({
[13:21:42.523]         base::withCallingHandlers({
[13:21:42.523]             ...future.value <- base::withVisible(base::local({
[13:21:42.523]                 ...future.makeSendCondition <- base::local({
[13:21:42.523]                   sendCondition <- NULL
[13:21:42.523]                   function(frame = 1L) {
[13:21:42.523]                     if (is.function(sendCondition)) 
[13:21:42.523]                       return(sendCondition)
[13:21:42.523]                     ns <- getNamespace("parallel")
[13:21:42.523]                     if (exists("sendData", mode = "function", 
[13:21:42.523]                       envir = ns)) {
[13:21:42.523]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:42.523]                         envir = ns)
[13:21:42.523]                       envir <- sys.frame(frame)
[13:21:42.523]                       master <- NULL
[13:21:42.523]                       while (!identical(envir, .GlobalEnv) && 
[13:21:42.523]                         !identical(envir, emptyenv())) {
[13:21:42.523]                         if (exists("master", mode = "list", envir = envir, 
[13:21:42.523]                           inherits = FALSE)) {
[13:21:42.523]                           master <- get("master", mode = "list", 
[13:21:42.523]                             envir = envir, inherits = FALSE)
[13:21:42.523]                           if (inherits(master, c("SOCKnode", 
[13:21:42.523]                             "SOCK0node"))) {
[13:21:42.523]                             sendCondition <<- function(cond) {
[13:21:42.523]                               data <- list(type = "VALUE", value = cond, 
[13:21:42.523]                                 success = TRUE)
[13:21:42.523]                               parallel_sendData(master, data)
[13:21:42.523]                             }
[13:21:42.523]                             return(sendCondition)
[13:21:42.523]                           }
[13:21:42.523]                         }
[13:21:42.523]                         frame <- frame + 1L
[13:21:42.523]                         envir <- sys.frame(frame)
[13:21:42.523]                       }
[13:21:42.523]                     }
[13:21:42.523]                     sendCondition <<- function(cond) NULL
[13:21:42.523]                   }
[13:21:42.523]                 })
[13:21:42.523]                 withCallingHandlers({
[13:21:42.523]                   {
[13:21:42.523]                     do.call(function(...) {
[13:21:42.523]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:42.523]                       if (!identical(...future.globals.maxSize.org, 
[13:21:42.523]                         ...future.globals.maxSize)) {
[13:21:42.523]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:42.523]                         on.exit(options(oopts), add = TRUE)
[13:21:42.523]                       }
[13:21:42.523]                       {
[13:21:42.523]                         lapply(seq_along(...future.elements_ii), 
[13:21:42.523]                           FUN = function(jj) {
[13:21:42.523]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:42.523]                             ...future.FUN(...future.X_jj, ...)
[13:21:42.523]                           })
[13:21:42.523]                       }
[13:21:42.523]                     }, args = future.call.arguments)
[13:21:42.523]                   }
[13:21:42.523]                 }, immediateCondition = function(cond) {
[13:21:42.523]                   sendCondition <- ...future.makeSendCondition()
[13:21:42.523]                   sendCondition(cond)
[13:21:42.523]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:42.523]                   {
[13:21:42.523]                     inherits <- base::inherits
[13:21:42.523]                     invokeRestart <- base::invokeRestart
[13:21:42.523]                     is.null <- base::is.null
[13:21:42.523]                     muffled <- FALSE
[13:21:42.523]                     if (inherits(cond, "message")) {
[13:21:42.523]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:42.523]                       if (muffled) 
[13:21:42.523]                         invokeRestart("muffleMessage")
[13:21:42.523]                     }
[13:21:42.523]                     else if (inherits(cond, "warning")) {
[13:21:42.523]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:42.523]                       if (muffled) 
[13:21:42.523]                         invokeRestart("muffleWarning")
[13:21:42.523]                     }
[13:21:42.523]                     else if (inherits(cond, "condition")) {
[13:21:42.523]                       if (!is.null(pattern)) {
[13:21:42.523]                         computeRestarts <- base::computeRestarts
[13:21:42.523]                         grepl <- base::grepl
[13:21:42.523]                         restarts <- computeRestarts(cond)
[13:21:42.523]                         for (restart in restarts) {
[13:21:42.523]                           name <- restart$name
[13:21:42.523]                           if (is.null(name)) 
[13:21:42.523]                             next
[13:21:42.523]                           if (!grepl(pattern, name)) 
[13:21:42.523]                             next
[13:21:42.523]                           invokeRestart(restart)
[13:21:42.523]                           muffled <- TRUE
[13:21:42.523]                           break
[13:21:42.523]                         }
[13:21:42.523]                       }
[13:21:42.523]                     }
[13:21:42.523]                     invisible(muffled)
[13:21:42.523]                   }
[13:21:42.523]                   muffleCondition(cond)
[13:21:42.523]                 })
[13:21:42.523]             }))
[13:21:42.523]             future::FutureResult(value = ...future.value$value, 
[13:21:42.523]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:42.523]                   ...future.rng), globalenv = if (FALSE) 
[13:21:42.523]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:42.523]                     ...future.globalenv.names))
[13:21:42.523]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:42.523]         }, condition = base::local({
[13:21:42.523]             c <- base::c
[13:21:42.523]             inherits <- base::inherits
[13:21:42.523]             invokeRestart <- base::invokeRestart
[13:21:42.523]             length <- base::length
[13:21:42.523]             list <- base::list
[13:21:42.523]             seq.int <- base::seq.int
[13:21:42.523]             signalCondition <- base::signalCondition
[13:21:42.523]             sys.calls <- base::sys.calls
[13:21:42.523]             `[[` <- base::`[[`
[13:21:42.523]             `+` <- base::`+`
[13:21:42.523]             `<<-` <- base::`<<-`
[13:21:42.523]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:42.523]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:42.523]                   3L)]
[13:21:42.523]             }
[13:21:42.523]             function(cond) {
[13:21:42.523]                 is_error <- inherits(cond, "error")
[13:21:42.523]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:42.523]                   NULL)
[13:21:42.523]                 if (is_error) {
[13:21:42.523]                   sessionInformation <- function() {
[13:21:42.523]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:42.523]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:42.523]                       search = base::search(), system = base::Sys.info())
[13:21:42.523]                   }
[13:21:42.523]                   ...future.conditions[[length(...future.conditions) + 
[13:21:42.523]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:42.523]                     cond$call), session = sessionInformation(), 
[13:21:42.523]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:42.523]                   signalCondition(cond)
[13:21:42.523]                 }
[13:21:42.523]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:42.523]                 "immediateCondition"))) {
[13:21:42.523]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:42.523]                   ...future.conditions[[length(...future.conditions) + 
[13:21:42.523]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:42.523]                   if (TRUE && !signal) {
[13:21:42.523]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:42.523]                     {
[13:21:42.523]                       inherits <- base::inherits
[13:21:42.523]                       invokeRestart <- base::invokeRestart
[13:21:42.523]                       is.null <- base::is.null
[13:21:42.523]                       muffled <- FALSE
[13:21:42.523]                       if (inherits(cond, "message")) {
[13:21:42.523]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:42.523]                         if (muffled) 
[13:21:42.523]                           invokeRestart("muffleMessage")
[13:21:42.523]                       }
[13:21:42.523]                       else if (inherits(cond, "warning")) {
[13:21:42.523]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:42.523]                         if (muffled) 
[13:21:42.523]                           invokeRestart("muffleWarning")
[13:21:42.523]                       }
[13:21:42.523]                       else if (inherits(cond, "condition")) {
[13:21:42.523]                         if (!is.null(pattern)) {
[13:21:42.523]                           computeRestarts <- base::computeRestarts
[13:21:42.523]                           grepl <- base::grepl
[13:21:42.523]                           restarts <- computeRestarts(cond)
[13:21:42.523]                           for (restart in restarts) {
[13:21:42.523]                             name <- restart$name
[13:21:42.523]                             if (is.null(name)) 
[13:21:42.523]                               next
[13:21:42.523]                             if (!grepl(pattern, name)) 
[13:21:42.523]                               next
[13:21:42.523]                             invokeRestart(restart)
[13:21:42.523]                             muffled <- TRUE
[13:21:42.523]                             break
[13:21:42.523]                           }
[13:21:42.523]                         }
[13:21:42.523]                       }
[13:21:42.523]                       invisible(muffled)
[13:21:42.523]                     }
[13:21:42.523]                     muffleCondition(cond, pattern = "^muffle")
[13:21:42.523]                   }
[13:21:42.523]                 }
[13:21:42.523]                 else {
[13:21:42.523]                   if (TRUE) {
[13:21:42.523]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:42.523]                     {
[13:21:42.523]                       inherits <- base::inherits
[13:21:42.523]                       invokeRestart <- base::invokeRestart
[13:21:42.523]                       is.null <- base::is.null
[13:21:42.523]                       muffled <- FALSE
[13:21:42.523]                       if (inherits(cond, "message")) {
[13:21:42.523]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:42.523]                         if (muffled) 
[13:21:42.523]                           invokeRestart("muffleMessage")
[13:21:42.523]                       }
[13:21:42.523]                       else if (inherits(cond, "warning")) {
[13:21:42.523]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:42.523]                         if (muffled) 
[13:21:42.523]                           invokeRestart("muffleWarning")
[13:21:42.523]                       }
[13:21:42.523]                       else if (inherits(cond, "condition")) {
[13:21:42.523]                         if (!is.null(pattern)) {
[13:21:42.523]                           computeRestarts <- base::computeRestarts
[13:21:42.523]                           grepl <- base::grepl
[13:21:42.523]                           restarts <- computeRestarts(cond)
[13:21:42.523]                           for (restart in restarts) {
[13:21:42.523]                             name <- restart$name
[13:21:42.523]                             if (is.null(name)) 
[13:21:42.523]                               next
[13:21:42.523]                             if (!grepl(pattern, name)) 
[13:21:42.523]                               next
[13:21:42.523]                             invokeRestart(restart)
[13:21:42.523]                             muffled <- TRUE
[13:21:42.523]                             break
[13:21:42.523]                           }
[13:21:42.523]                         }
[13:21:42.523]                       }
[13:21:42.523]                       invisible(muffled)
[13:21:42.523]                     }
[13:21:42.523]                     muffleCondition(cond, pattern = "^muffle")
[13:21:42.523]                   }
[13:21:42.523]                 }
[13:21:42.523]             }
[13:21:42.523]         }))
[13:21:42.523]     }, error = function(ex) {
[13:21:42.523]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:42.523]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:42.523]                 ...future.rng), started = ...future.startTime, 
[13:21:42.523]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:42.523]             version = "1.8"), class = "FutureResult")
[13:21:42.523]     }, finally = {
[13:21:42.523]         if (!identical(...future.workdir, getwd())) 
[13:21:42.523]             setwd(...future.workdir)
[13:21:42.523]         {
[13:21:42.523]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:42.523]                 ...future.oldOptions$nwarnings <- NULL
[13:21:42.523]             }
[13:21:42.523]             base::options(...future.oldOptions)
[13:21:42.523]             if (.Platform$OS.type == "windows") {
[13:21:42.523]                 old_names <- names(...future.oldEnvVars)
[13:21:42.523]                 envs <- base::Sys.getenv()
[13:21:42.523]                 names <- names(envs)
[13:21:42.523]                 common <- intersect(names, old_names)
[13:21:42.523]                 added <- setdiff(names, old_names)
[13:21:42.523]                 removed <- setdiff(old_names, names)
[13:21:42.523]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:42.523]                   envs[common]]
[13:21:42.523]                 NAMES <- toupper(changed)
[13:21:42.523]                 args <- list()
[13:21:42.523]                 for (kk in seq_along(NAMES)) {
[13:21:42.523]                   name <- changed[[kk]]
[13:21:42.523]                   NAME <- NAMES[[kk]]
[13:21:42.523]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:42.523]                     next
[13:21:42.523]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:42.523]                 }
[13:21:42.523]                 NAMES <- toupper(added)
[13:21:42.523]                 for (kk in seq_along(NAMES)) {
[13:21:42.523]                   name <- added[[kk]]
[13:21:42.523]                   NAME <- NAMES[[kk]]
[13:21:42.523]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:42.523]                     next
[13:21:42.523]                   args[[name]] <- ""
[13:21:42.523]                 }
[13:21:42.523]                 NAMES <- toupper(removed)
[13:21:42.523]                 for (kk in seq_along(NAMES)) {
[13:21:42.523]                   name <- removed[[kk]]
[13:21:42.523]                   NAME <- NAMES[[kk]]
[13:21:42.523]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:42.523]                     next
[13:21:42.523]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:42.523]                 }
[13:21:42.523]                 if (length(args) > 0) 
[13:21:42.523]                   base::do.call(base::Sys.setenv, args = args)
[13:21:42.523]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:42.523]             }
[13:21:42.523]             else {
[13:21:42.523]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:42.523]             }
[13:21:42.523]             {
[13:21:42.523]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:42.523]                   0L) {
[13:21:42.523]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:42.523]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:42.523]                   base::options(opts)
[13:21:42.523]                 }
[13:21:42.523]                 {
[13:21:42.523]                   {
[13:21:42.523]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:42.523]                     NULL
[13:21:42.523]                   }
[13:21:42.523]                   options(future.plan = NULL)
[13:21:42.523]                   if (is.na(NA_character_)) 
[13:21:42.523]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:42.523]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:42.523]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:42.523]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:42.523]                     envir = parent.frame()) 
[13:21:42.523]                   {
[13:21:42.523]                     if (is.function(workers)) 
[13:21:42.523]                       workers <- workers()
[13:21:42.523]                     workers <- structure(as.integer(workers), 
[13:21:42.523]                       class = class(workers))
[13:21:42.523]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:42.523]                       workers >= 1)
[13:21:42.523]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:42.523]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:42.523]                     }
[13:21:42.523]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:42.523]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:42.523]                       envir = envir)
[13:21:42.523]                     if (!future$lazy) 
[13:21:42.523]                       future <- run(future)
[13:21:42.523]                     invisible(future)
[13:21:42.523]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:42.523]                 }
[13:21:42.523]             }
[13:21:42.523]         }
[13:21:42.523]     })
[13:21:42.523]     if (TRUE) {
[13:21:42.523]         base::sink(type = "output", split = FALSE)
[13:21:42.523]         if (TRUE) {
[13:21:42.523]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:42.523]         }
[13:21:42.523]         else {
[13:21:42.523]             ...future.result["stdout"] <- base::list(NULL)
[13:21:42.523]         }
[13:21:42.523]         base::close(...future.stdout)
[13:21:42.523]         ...future.stdout <- NULL
[13:21:42.523]     }
[13:21:42.523]     ...future.result$conditions <- ...future.conditions
[13:21:42.523]     ...future.result$finished <- base::Sys.time()
[13:21:42.523]     ...future.result
[13:21:42.523] }
[13:21:42.526] Exporting 11 global objects (92.90 KiB) to cluster node #2 ...
[13:21:42.526] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[13:21:42.568] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[13:21:42.569] Exporting ‘x_FUN’ (848 bytes) to cluster node #2 ...
[13:21:42.569] Exporting ‘x_FUN’ (848 bytes) to cluster node #2 ... DONE
[13:21:42.569] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[13:21:42.570] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[13:21:42.570] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[13:21:42.612] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[13:21:42.613] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[13:21:42.656] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[13:21:42.657] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[13:21:42.657] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[13:21:42.657] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[13:21:42.658] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[13:21:42.658] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:21:42.658] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:21:42.658] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[13:21:42.659] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[13:21:42.659] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:21:42.659] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:21:42.660] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:21:42.660] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:21:42.660] Exporting 11 global objects (92.90 KiB) to cluster node #2 ... DONE
[13:21:42.661] MultisessionFuture started
[13:21:42.661] - Launch lazy future ... done
[13:21:42.661] run() for ‘MultisessionFuture’ ... done
[13:21:42.661] Created future:
[13:21:42.661] MultisessionFuture:
[13:21:42.661] Label: ‘future_vapply-2’
[13:21:42.661] Expression:
[13:21:42.661] {
[13:21:42.661]     do.call(function(...) {
[13:21:42.661]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:21:42.661]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:21:42.661]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:21:42.661]             on.exit(options(oopts), add = TRUE)
[13:21:42.661]         }
[13:21:42.661]         {
[13:21:42.661]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:21:42.661]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:21:42.661]                 ...future.FUN(...future.X_jj, ...)
[13:21:42.661]             })
[13:21:42.661]         }
[13:21:42.661]     }, args = future.call.arguments)
[13:21:42.661] }
[13:21:42.661] Lazy evaluation: FALSE
[13:21:42.661] Asynchronous evaluation: TRUE
[13:21:42.661] Local evaluation: TRUE
[13:21:42.661] Environment: R_GlobalEnv
[13:21:42.661] Capture standard output: TRUE
[13:21:42.661] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:21:42.661] Globals: 11 objects totaling 93.01 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:21:42.661] Packages: 1 packages (‘future.apply’)
[13:21:42.661] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:21:42.661] Resolved: FALSE
[13:21:42.661] Value: <not collected>
[13:21:42.661] Conditions captured: <none>
[13:21:42.661] Early signaling: FALSE
[13:21:42.661] Owner process: cbab0820-deaf-912a-53a0-378e5ccb62a6
[13:21:42.661] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:42.673] Chunk #2 of 2 ... DONE
[13:21:42.673] Launching 2 futures (chunks) ... DONE
[13:21:42.673] Resolving 2 futures (chunks) ...
[13:21:42.673] resolve() on list ...
[13:21:42.673]  recursive: 0
[13:21:42.674]  length: 2
[13:21:42.674] 
[13:21:42.674] receiveMessageFromWorker() for ClusterFuture ...
[13:21:42.674] - Validating connection of MultisessionFuture
[13:21:42.675] - received message: FutureResult
[13:21:42.675] - Received FutureResult
[13:21:42.675] - Erased future from FutureRegistry
[13:21:42.675] result() for ClusterFuture ...
[13:21:42.675] - result already collected: FutureResult
[13:21:42.675] result() for ClusterFuture ... done
[13:21:42.675] signalConditions() ...
[13:21:42.675]  - include = ‘immediateCondition’
[13:21:42.675]  - exclude = 
[13:21:42.676]  - resignal = FALSE
[13:21:42.678]  - Number of conditions: 1
[13:21:42.679] signalConditions() ... done
[13:21:42.679] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:42.679] Future #1
[13:21:42.679] result() for ClusterFuture ...
[13:21:42.679] - result already collected: FutureResult
[13:21:42.679] result() for ClusterFuture ... done
[13:21:42.679] result() for ClusterFuture ...
[13:21:42.679] - result already collected: FutureResult
[13:21:42.679] result() for ClusterFuture ... done
[13:21:42.679] signalConditions() ...
[13:21:42.679]  - include = ‘immediateCondition’
[13:21:42.679]  - exclude = 
[13:21:42.680]  - resignal = FALSE
[13:21:42.680]  - Number of conditions: 1
[13:21:42.680] signalConditions() ... done
[13:21:42.680] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:21:42.680] - nx: 2
[13:21:42.680] - relay: TRUE
[13:21:42.680] - stdout: TRUE
[13:21:42.680] - signal: TRUE
[13:21:42.680] - resignal: FALSE
[13:21:42.680] - force: TRUE
[13:21:42.681] - relayed: [n=2] FALSE, FALSE
[13:21:42.681] - queued futures: [n=2] FALSE, FALSE
[13:21:42.681]  - until=1
[13:21:42.681]  - relaying element #1
[13:21:42.681] result() for ClusterFuture ...
[13:21:42.681] - result already collected: FutureResult
[13:21:42.681] result() for ClusterFuture ... done
[13:21:42.681] result() for ClusterFuture ...
[13:21:42.681] - result already collected: FutureResult
[13:21:42.681] result() for ClusterFuture ... done
[13:21:42.681] signalConditions() ...
[13:21:42.681]  - include = ‘immediateCondition’
[13:21:42.682]  - exclude = 
[13:21:42.682]  - resignal = FALSE
[13:21:42.682]  - Number of conditions: 1
[13:21:42.682] signalConditions() ... done
[13:21:42.682] result() for ClusterFuture ...
[13:21:42.682] - result already collected: FutureResult
[13:21:42.682] result() for ClusterFuture ... done
[13:21:42.682] signalConditions() ...
[13:21:42.682]  - include = ‘immediateCondition’
[13:21:42.682]  - exclude = 
[13:21:42.682]  - resignal = FALSE
[13:21:42.682]  - Number of conditions: 1
[13:21:42.683] signalConditions() ... done
[13:21:42.683] result() for ClusterFuture ...
[13:21:42.683] - result already collected: FutureResult
[13:21:42.683] result() for ClusterFuture ... done
[13:21:42.683] signalConditions() ...
[13:21:42.683]  - include = ‘condition’
[13:21:42.683]  - exclude = ‘immediateCondition’
[13:21:42.683]  - resignal = TRUE
[13:21:42.683]  - Number of conditions: 1
[13:21:42.683]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:21:42.683] signalConditions() ... done
[13:21:42.684] - relayed: [n=2] FALSE, FALSE
[13:21:42.684] - queued futures: [n=2] TRUE, FALSE
[13:21:42.684] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:21:42.684] plan(): Setting new future strategy stack:
[13:21:42.684] List of future strategies:
[13:21:42.684] 1. sequential:
[13:21:42.684]    - args: function (..., envir = parent.frame())
[13:21:42.684]    - tweaked: FALSE
[13:21:42.684]    - call: plan(sequential)
[13:21:42.685] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> 
> message("*** future_vapply() ... DONE")
*** future_vapply() ... DONE
> 
> source("incl/end.R")
[13:21:42.686] plan(): Setting new future strategy stack:
[13:21:42.686] List of future strategies:
[13:21:42.686] 1. FutureStrategy:
[13:21:42.686]    - args: function (..., envir = parent.frame())
[13:21:42.686]    - tweaked: FALSE
[13:21:42.686]    - call: future::plan(oplan)
[13:21:42.686] plan(): nbrOfWorkers() = 1
> 
